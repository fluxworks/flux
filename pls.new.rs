#![allow
(
    ambiguous_glob_reexports,
    dead_code,
    elided_named_lifetimes,
    non_camel_case_types,
    non_snake_case,
    private_interfaces,
    stable_features,
    unknown_lints,
    unreachable_patterns,
    unused_assignments,
    unused_imports,
    unused_macros,
    unused_mut,
    unused_unsafe,
    unused_variables,
)]
/*
#[macro_use] extern crate bitflags;
*/
#[macro_use] extern crate lazy_static;
/**/
extern crate rand;
extern crate fnv;
extern crate memchr;
extern crate nix;
extern crate regex as re;
extern crate smallvec;
extern crate time as timed;
extern crate unicode_normalization;
extern crate unicode_width;
//extern crate libc;
#[macro_use] pub mod macros
{
    use ::
    {
        *,
    };    
    /// OVER::map    
    #[macro_export] macro_rules! map
    {
        { } => { ::collections::HashMap::new() };
        
        { $( $key:expr => $value:expr ),+ , } => { map!{ $( $key => $value),+ } };
        
        { $( $key:expr => $value:expr ),* } =>
        {
            {
                let mut _map = ::collections::HashMap::new();
                $( let _ = _map.insert($key, $value); )*
                _map
            }
        }
    }
    /// Given an int, creates and returns a `BigInt`.
    #[macro_export] macro_rules! int
    {
        ($int:expr) => 
        {{
            use num::big::BigInt;

            let _b: BigInt = $int.into();
            _b
        }};
    }
    /// Given two ints, creates and returns a `BigRational`.
    #[macro_export] macro_rules! frac
    {
        ($int1:expr, $int2:expr) => 
        {{
            ::num::rational::BigRational::new($int1.into(), $int2.into())
        }};
    }
    /// Converts each element in a list to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! arr
    {
        [] =>
        {
            ::database::arrays::Arr::from_vec(vec![]).unwrap()
        };

        [ $( $elem:expr ),+ , ] => { try_arr![ $( $elem ),+ ].unwrap() };

        [ $( $elem:expr ),+ ] => { try_arr![ $( $elem ),+ ].unwrap() };
    }
    /// Converts each element in a list to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! try_arr
    {
        [ $( $elem:expr ),+ , ] => { try_arr![ $( $elem ),+ ] };

        [ $( $elem:expr ),+ ] =>
        {
            {
                ::database::arrays::Arr::from_vec(vec![ $( $elem.into() ),+ ])
            }
        };
    }
    /// Converts each element to `Value`s and returns a `Tup` containing a vector of the values.
    #[macro_export] macro_rules! tup
    {
        ( $( $elem:expr ),* , ) => { tup!( $( $elem ),* ) };

        ( $( $elem:expr ),* ) =>
        {
            {
                ::database::tuples::Tup::from_vec(vec![ $( $elem.into() ),+ ])            
            }
        };
    }
    /// Given a list of field/value pairs, returns an `Obj` containing each pair.
    #[macro_export] macro_rules! obj
    {
        {} => { ::database::objects::Obj::from_map_unchecked( ::collections::HashMap::new() ) };
        { $( $field:expr => $inner:expr ),+ , } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
        { $( $field:expr => $inner:expr ),+ } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
    }
    /// Given a list of field to `Value` pairs, returns an `Obj` with the fields and values.
    #[macro_export] macro_rules! try_obj 
    {
        { $( $field:expr => $inner:expr ),+ , } =>
        {
            try_obj!{ $( $field => $inner ),* };
        };

        { $( $field:expr => $inner:expr ),+ } =>
        {
            {
                use ::database::objects::Obj;
                let mut _map = ::collections::HashMap::new();
                let mut _parent: Option<::database::values::Value> = None;
                $(
                    if $field == "^" { _parent = Some($inner.into()); }
                    else { _map.insert($field.into(), $inner.into()); }
                )*

                match _parent
                {
                    Some(parent) => match parent.get_obj()
                    {
                        Ok(parent) => Obj::from_map_with_parent(_map, parent),
                        e @ Err(_) => e,
                    }

                    None => Obj::from_map(_map),
                }
            }
        };
    }

    #[macro_export] macro_rules! bitflags
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $BitFlags:ident: $T:ty {
                $(
                    $(#[$inner:ident $($args:tt)*])*
                    const $Flag:tt = $value:expr;
                )*
            }

            $($t:tt)*
        ) =>
        {
            __declare_public_bitflags!
            {
                $(#[$outer])*
                $vis struct $BitFlags
            }
            
            __impl_public_bitflags_consts!
            {
                $BitFlags: $T
                {
                    $(
                        $(#[$inner $($args)*])*
                        const $Flag = $value;
                    )*
                }
            }
            
            const _: () =
            {
                __declare_internal_bitflags! { $vis struct InternalBitFlags: $T }
                
                __impl_internal_bitflags!
                {
                    InternalBitFlags: $T, $BitFlags
                    {$(
                        $(#[$inner $($args)*])*
                        const $Flag = $value;
                    )*}
                }
                
                __impl_public_bitflags_forward!
                {
                    $BitFlags: $T, InternalBitFlags
                }
                
                __impl_public_bitflags_ops!
                {
                    $BitFlags
                }
                
                __impl_public_bitflags_iter!
                {
                    $BitFlags: $T, $BitFlags
                }
            };
            
            bitflags!
            {
                $($t)*
            }
        };

        (
            $(#[$outer:meta])*
            impl $BitFlags:ident: $T:ty
            {$(
                $(#[$inner:ident $($args:tt)*])*
                const $Flag:tt = $value:expr;
            )*}

            $($t:tt)*
        ) => 
        {
            __impl_public_bitflags_consts!
            {
                $BitFlags: $T {
                    $(
                        $(#[$inner $($args)*])*
                        const $Flag = $value;
                    )*
                }
            }
            
            const _: () =
            {
                __impl_public_bitflags!
                {
                    $(#[$outer])*
                    $BitFlags: $T, $BitFlags
                    {$(
                        $(#[$inner $($args)*])*
                        const $Flag = $value;
                    )*}
                }
                
                __impl_public_bitflags_ops!
                {
                    $BitFlags
                }
                
                __impl_public_bitflags_iter!
                {
                    $BitFlags: $T, $BitFlags
                }
            };
            
            bitflags!
            {
                $($t)*
            }
        };

        () => {};
    }
    /// Implement functions on bitflags types.
    #[macro_export] macro_rules! __impl_bitflags
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty
            {
                fn empty() $empty:block
                fn all() $all:block
                fn bits($bits0:ident) $bits:block
                fn from_bits($from_bits0:ident) $from_bits:block
                fn from_bits_truncate($from_bits_truncate0:ident) $from_bits_truncate:block
                fn from_bits_retain($from_bits_retain0:ident) $from_bits_retain:block
                fn from_name($from_name0:ident) $from_name:block
                fn is_empty($is_empty0:ident) $is_empty:block
                fn is_all($is_all0:ident) $is_all:block
                fn intersects($intersects0:ident, $intersects1:ident) $intersects:block
                fn contains($contains0:ident, $contains1:ident) $contains:block
                fn insert($insert0:ident, $insert1:ident) $insert:block
                fn remove($remove0:ident, $remove1:ident) $remove:block
                fn toggle($toggle0:ident, $toggle1:ident) $toggle:block
                fn set($set0:ident, $set1:ident, $set2:ident) $set:block
                fn intersection($intersection0:ident, $intersection1:ident) $intersection:block
                fn union($union0:ident, $union1:ident) $union:block
                fn difference($difference0:ident, $difference1:ident) $difference:block
                fn symmetric_difference($symmetric_difference0:ident, $symmetric_difference1:ident) $symmetric_difference:block
                fn complement($complement0:ident) $complement:block
            }
        ) =>
        {
            $(#[$outer])*
            impl $PublicBitFlags
            {
                /// Get a flags value with all bits unset.
                #[inline] pub const fn empty() -> Self { $empty }
                /// Get a flags value with all known bits set.
                #[inline] pub const fn all() -> Self { $all }
                /// Get the underlying bits value.
                #[inline] pub const fn bits(&self) -> $T
                {
                    let $bits0 = self;
                    $bits
                }
                /// Convert from a bits value.
                #[inline] pub const fn from_bits(bits: $T) -> ::option::Option<Self>
                {
                    let $from_bits0 = bits;
                    $from_bits
                }
                /// Convert from a bits value, unsetting any unknown bits.
                #[inline] pub const fn from_bits_truncate(bits: $T) -> Self
                {
                    let $from_bits_truncate0 = bits;
                    $from_bits_truncate
                }
                /// Convert from a bits value exactly.
                #[inline] pub const fn from_bits_retain(bits: $T) -> Self
                {
                    let $from_bits_retain0 = bits;
                    $from_bits_retain
                }
                /// Get a flags value with the bits of a flag with the given name set.
                #[inline] pub fn from_name(name: &str) -> ::option::Option<Self>
                {
                    let $from_name0 = name;
                    $from_name
                }
                /// Whether all bits in this flags value are unset.
                #[inline] pub const fn is_empty(&self) -> bool
                {
                    let $is_empty0 = self;
                    $is_empty
                }
                /// Whether all known bits in this flags value are set.
                #[inline] pub const fn is_all(&self) -> bool
                {
                    let $is_all0 = self;
                    $is_all
                }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline] pub const fn intersects(&self, other: Self) -> bool
                {
                    let $intersects0 = self;
                    let $intersects1 = other;
                    $intersects
                }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline] pub const fn contains(&self, other: Self) -> bool
                {
                    let $contains0 = self;
                    let $contains1 = other;
                    $contains
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] pub fn insert(&mut self, other: Self)
                {
                    let $insert0 = self;
                    let $insert1 = other;
                    $insert
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[inline] pub fn remove(&mut self, other: Self) 
                {
                    let $remove0 = self;
                    let $remove1 = other;
                    $remove
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] pub fn toggle(&mut self, other: Self) 
                {
                    let $toggle0 = self;
                    let $toggle1 = other;
                    $toggle
                }
                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline] pub fn set(&mut self, other: Self, value: bool) 
                {
                    let $set0 = self;
                    let $set1 = other;
                    let $set2 = value;
                    $set
                }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline] #[must_use] pub const fn intersection(self, other: Self) -> Self 
                {
                    let $intersection0 = self;
                    let $intersection1 = other;
                    $intersection
                }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] #[must_use] pub const fn union(self, other: Self) -> Self 
                {
                    let $union0 = self;
                    let $union1 = other;
                    $union
                }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[inline] #[must_use] pub const fn difference(self, other: Self) -> Self 
                {
                    let $difference0 = self;
                    let $difference1 = other;
                    $difference
                }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] #[must_use] pub const fn symmetric_difference(self, other: Self) -> Self 
                {
                    let $symmetric_difference0 = self;
                    let $symmetric_difference1 = other;
                    $symmetric_difference
                }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline] #[must_use] pub const fn complement(self) -> Self 
                {
                    let $complement0 = self;
                    $complement
                }
            }
        };
    }
    /// A macro that matches flags values, similar to Rust's `match` statement.
    #[macro_export] macro_rules! bitflags_match
    {
        ($operation:expr,
        {
            $($t:tt)*
        }) =>
        {
            (|| 
            {
                __bitflags_match!($operation, { $($t)* })
            })()
        };
    }
    /// Expand the `bitflags_match` macro
    #[macro_export] macro_rules! __bitflags_match
    {
        ($operation:expr, { $pattern:expr => { $($body:tt)* } , $($t:tt)+ }) =>
        {
            __bitflags_match!($operation, { $pattern => { $($body)* } $($t)+ })
        };
        
        ($operation:expr, { $pattern:expr => { $($body:tt)* } $($t:tt)+ }) =>
        {{
                if $operation == $pattern
                {
                    return { $($body)* };
                }

                __bitflags_match!($operation, { $($t)+ })
        }};
        
        ($operation:expr, { $pattern:expr => $body:expr , $($t:tt)+ }) =>
        { {
            if $operation == $pattern { return $body; }
            __bitflags_match!($operation, { $($t)+ })
        }};
        
        ($operation:expr, { _ => $default:expr $(,)? }) => { $default }
    }
    /// A macro that processed the input to `bitflags!`
    /// and shuffles attributes around based on whether or not they're "expression-safe".
    #[macro_export] macro_rules! __bitflags_expr_safe_attrs
    {
        (
            $(#[$inner:ident $($args:tt)*])*
            { $e:expr }
        ) =>
        {
            __bitflags_expr_safe_attrs!
            {
                expr: { $e },
                attrs:
                {
                    unprocessed: [$(#[$inner $($args)*])*],
                    processed: [],
                },
            }
        };
        
        (
            expr: { $e:expr },
            attrs: 
            {
                unprocessed:
                [
                    #[cfg $($args:tt)*]
                    $($attrs_rest:tt)*
                ],
                processed: [$($expr:tt)*],
            },
        ) =>
        {
            __bitflags_expr_safe_attrs!
            {
                expr: { $e },
                attrs:
                {
                    unprocessed:
                    [
                        $($attrs_rest)*
                    ],
                    processed:
                    [
                        $($expr)*
                        #[cfg $($args)*]
                    ],
                },
            }
        };
        
        (
            expr: { $e:expr },
                attrs: {
                unprocessed: [
                    #[$other:ident $($args:tt)*]
                    $($attrs_rest:tt)*
                ],
                processed: [$($expr:tt)*],
            },
        ) =>
        {
            __bitflags_expr_safe_attrs!
            {
                expr: { $e },
                attrs:
                {
                    unprocessed: 
                    [
                        $($attrs_rest)*
                    ],
                    processed:
                    [
                        $($expr)*
                    ],
                },
            }
        };
        
        (
            expr: { $e:expr },
            attrs:
            {
                unprocessed: [],
                processed: [$(#[$expr:ident $($exprargs:tt)*])*],
            },
        ) => 
        {
            $(#[$expr $($exprargs)*])*
            { $e }
        }
    }
    /// Implement a flag, which may be a wildcard `_`.
    #[macro_export] macro_rules! __bitflags_flag
    {
        ({
            name: _,
            named: { $($named:tt)* },
            unnamed: { $($unnamed:tt)* },
        }) => { $($unnamed)* };

        ({
            name: $Flag:ident,
            named: { $($named:tt)* },
            unnamed: { $($unnamed:tt)* },
        }) => { $($named)* };
    }
    /// Declare the `bitflags`-facing bitflags struct.
    #[macro_export] macro_rules! __declare_internal_bitflags
    {
        (
            $vis:vis struct $InternalBitFlags:ident: $T:ty
        ) =>
        {
            #[repr( transparent )] #[derive( Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash )]            
            $vis struct $InternalBitFlags($T);
        };
    }
    /// Implement functions on the private (bitflags-facing) bitflags type.
    #[macro_export] macro_rules! __impl_internal_bitflags
    {
        (
            $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident
            {
                $(
                    $(#[$inner:ident $($args:tt)*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) =>
        {
            impl ::bit::flags::traits::PublicFlags for $PublicBitFlags
            {
                type Primitive = $T;
                type Internal = $InternalBitFlags;
            }

            impl ::default::Default for $InternalBitFlags
            {
                #[inline] fn default() -> Self {
                    $InternalBitFlags::empty()
                }
            }

            impl ::fmt::Debug for $InternalBitFlags {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    if self.is_empty()
                    {
                        write!(f, "{:#x}", <$T as ::bit::flags::Bits>::EMPTY)
                    } else {
                        ::fmt::Display::fmt(self, f)
                    }
                }
            }

            impl ::fmt::Display for $InternalBitFlags {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    ::bit::flags::parser::to_writer(&$PublicBitFlags(*self), f)
                }
            }

            impl ::str::FromStr for $InternalBitFlags {
                type Err = ::bit::flags::parser::ParseError;

                fn from_str(s: &str) -> ::result::Result<Self, Self::Err> {
                    ::bit::flags::parser::from_str::<$PublicBitFlags>(s).map(|flags| flags.0)
                }
            }

            impl ::convert::AsRef<$T> for $InternalBitFlags {
                fn as_ref(&self) -> &$T {
                    &self.0
                }
            }

            impl ::convert::From<$T> for $InternalBitFlags {
                fn from(bits: $T) -> Self {
                    Self::from_bits_retain(bits)
                }
            }
            

            __impl_public_bitflags! {
                $InternalBitFlags: $T, $PublicBitFlags {
                    $(
                        $(#[$inner $($args)*])*
                        const $Flag = $value;
                    )*
                }
            }

            __impl_public_bitflags_ops! {
                $InternalBitFlags
            }

            __impl_public_bitflags_iter! {
                $InternalBitFlags: $T, $PublicBitFlags
            }

            impl $InternalBitFlags {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline] pub fn bits_mut(&mut self) -> &mut $T {
                    &mut self.0
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_bits
    {
        ($($u:ty, $i:ty,)*) => {
            $(
                impl Bits for $u {
                    const EMPTY: $u = 0;
                    const ALL: $u = <$u>::MAX;
                }

                impl Bits for $i {
                    const EMPTY: $i = 0;
                    const ALL: $i = <$u>::MAX as $i;
                }

                impl ParseHex for $u {
                    fn parse_hex(input: &str) -> Result<Self, ParseError> {
                        <$u>::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))
                    }
                }

                impl ParseHex for $i {
                    fn parse_hex(input: &str) -> Result<Self, ParseError> {
                        <$i>::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))
                    }
                }

                impl WriteHex for $u {
                    fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result {
                        write!(writer, "{:x}", self)
                    }
                }

                impl WriteHex for $i {
                    fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result {
                        write!(writer, "{:x}", self)
                    }
                }

                impl Primitive for $i {}
                impl Primitive for $u {}
            )*
        }
    }
    /// Declare the user-facing bitflags struct.
    #[macro_export] macro_rules! __declare_public_bitflags
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            $vis struct $PublicBitFlags(<$PublicBitFlags as ::bit::flags::traits::PublicFlags>::Internal);
        };
    }
    /// Implement functions on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_forward
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident
        ) =>
        {
            __impl_bitflags!
            {
                $(#[$outer])*
                $PublicBitFlags: $T
                {
                    fn empty() {
                        Self($InternalBitFlags::empty())
                    }

                    fn all() {
                        Self($InternalBitFlags::all())
                    }

                    fn bits(f) {
                        f.0.bits()
                    }

                    fn from_bits(bits) 
                    {
                        match $InternalBitFlags::from_bits(bits)
                        {
                            ::option::Option::Some(bits) => ::option::Option::Some(Self(bits)),
                            ::option::Option::None => ::option::Option::None,
                        }
                    }

                    fn from_bits_truncate(bits){ Self($InternalBitFlags::from_bits_truncate(bits)) }

                    fn from_bits_retain(bits){ Self($InternalBitFlags::from_bits_retain(bits)) }

                    fn from_name(name)
                    {
                        match $InternalBitFlags::from_name(name)
                        {
                            ::option::Option::Some(bits) => ::option::Option::Some(Self(bits)),
                            ::option::Option::None => ::option::Option::None,
                        }
                    }

                    fn is_empty(f) { f.0.is_empty() }
                    fn is_all(f) { f.0.is_all() }
                    fn intersects(f, other) { f.0.intersects(other.0) }
                    fn contains(f, other) { f.0.contains(other.0) }
                    fn insert(f, other) { f.0.insert(other.0) }
                    fn remove(f, other) { f.0.remove(other.0) }
                    fn toggle(f, other) { f.0.toggle(other.0) }
                    fn set(f, other, value) { f.0.set(other.0, value) }
                    fn intersection(f, other) { Self(f.0.intersection(other.0)) }
                    fn union(f, other) { Self(f.0.union(other.0)) }
                    fn difference(f, other) { Self(f.0.difference(other.0)) }
                    fn symmetric_difference(f, other) { Self(f.0.symmetric_difference(other.0)) }
                    fn complement(f) { Self(f.0.complement()) }
                }
            }
        };
    }
    /// Implement functions on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags
    {
        (
            $(#[$outer:meta])*
            $BitFlags:ident: $T:ty, $PublicBitFlags:ident
            {$(
                    $(#[$inner:ident $($args:tt)*])*
                    const $Flag:tt = $value:expr;
            )*}
        ) =>
        {
            __impl_bitflags!
            {
                $(#[$outer])*
                $BitFlags: $T
                {
                    fn empty() { Self(<$T as ::bit::flags::Bits>::EMPTY) }

                    fn all()
                    {
                        let mut truncated = <$T as ::bit::flags::Bits>::EMPTY;
                        let mut i = 0;

                        $(
                            __bitflags_expr_safe_attrs!
                            ($(
                                #[$inner $($args)*])*
                                {{
                                    let flag = <$PublicBitFlags as ::bit::flags::Flags>::FLAGS[i].value().bits();
                                    truncated = truncated | flag;
                                    i += 1;
                                }}
                            );
                        )*

                        let _ = i;
                        Self::from_bits_retain(truncated)
                    }

                    fn bits(f) { f.0 }

                    fn from_bits(bits)
                    {
                        let truncated = Self::from_bits_truncate(bits).0;

                        if truncated == bits { ::option::Option::Some(Self(bits)) }
                        else { ::option::Option::None }
                    }

                    fn from_bits_truncate(bits) { Self(bits & Self::all().bits()) }

                    fn from_bits_retain(bits) { Self(bits) }

                    fn from_name(name)
                    {
                        $(
                            __bitflags_flag!
                            ({
                                name: $Flag,
                                named:
                                {
                                    __bitflags_expr_safe_attrs!
                                    (
                                        $(#[$inner $($args)*])*
                                        {
                                            if name == stringify!($Flag)
                                            {
                                                return ::option::Option::Some(Self($PublicBitFlags::$Flag.bits()));
                                            }
                                        }
                                    );
                                },
                                unnamed: {},
                            });
                        )*

                        let _ = name;
                        ::option::Option::None
                    }

                    fn is_empty(f) { f.bits() == <$T as ::bit::flags::Bits>::EMPTY }

                    fn is_all(f) { Self::all().bits() | f.bits() == f.bits() }

                    fn intersects(f, other) { f.bits() & other.bits() != <$T as ::bit::flags::Bits>::EMPTY }

                    fn contains(f, other) { f.bits() & other.bits() == other.bits() }

                    fn insert(f, other) { *f = Self::from_bits_retain(f.bits()).union(other); }

                    fn remove(f, other) { *f = Self::from_bits_retain(f.bits()).difference(other); }

                    fn toggle(f, other) { *f = Self::from_bits_retain(f.bits()).symmetric_difference(other); }

                    fn set(f, other, value)
                    {
                        if value { f.insert(other); }
                        else { f.remove(other); }
                    }

                    fn intersection(f, other) { Self::from_bits_retain(f.bits() & other.bits()) }

                    fn union(f, other) { Self::from_bits_retain(f.bits() | other.bits()) }

                    fn difference(f, other) { Self::from_bits_retain(f.bits() & !other.bits()) }

                    fn symmetric_difference(f, other) { Self::from_bits_retain(f.bits() ^ other.bits()) }

                    fn complement(f) { Self::from_bits_truncate(!f.bits()) }
                }
            }
        };
    }
    /// Implement iterators on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_iter
    {
        (
            $(#[$outer:meta])*
            $BitFlags:ident: $T:ty, $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            impl $BitFlags
            {
                /// Yield a set of contained flags values.
                #[inline] pub const fn iter(&self) -> ::bit::flags::iter::Iter<$PublicBitFlags>
                {
                    ::bit::flags::iter::Iter::__private_const_new
                    (
                        <$PublicBitFlags as ::bit::flags::Flags>::FLAGS,
                        $PublicBitFlags::from_bits_retain(self.bits()),
                        $PublicBitFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                #[inline] pub const fn iter_names(&self) -> ::bit::flags::iter::IterNames<$PublicBitFlags>
                {
                    ::bit::flags::iter::IterNames::__private_const_new
                    (
                        <$PublicBitFlags as ::bit::flags::Flags>::FLAGS,
                        $PublicBitFlags::from_bits_retain(self.bits()),
                        $PublicBitFlags::from_bits_retain(self.bits()),
                    )
                }
            }

            $(#[$outer:meta])*
            impl ::iter::IntoIterator for $BitFlags
            {
                type Item = $PublicBitFlags;
                type IntoIter = ::bit::flags::iter::Iter<$PublicBitFlags>;
                fn into_iter(self) -> Self::IntoIter { self.iter() }
            }
        };
    }
    /// Implement traits on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_ops
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            impl ::fmt::Binary for $PublicBitFlags
            {
                fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::Binary::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::Octal for $PublicBitFlags
            {
                fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::Octal::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::LowerHex for $PublicBitFlags
            {
                fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::LowerHex::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::UpperHex for $PublicBitFlags
            {
                fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::UpperHex::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::ops::BitOr for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] fn bitor(self, other: $PublicBitFlags) -> Self { self.union(other) }
            }

            $(#[$outer])*
            impl ::ops::BitOrAssign for $PublicBitFlags
            {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] fn bitor_assign(&mut self, other: Self) { self.insert(other); }
            }

            $(#[$outer])*
            impl ::ops::BitXor for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] fn bitxor(self, other: Self) -> Self { self.symmetric_difference(other) }
            }

            $(#[$outer])*
            impl ::ops::BitXorAssign for $PublicBitFlags
            {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] fn bitxor_assign(&mut self, other: Self) { self.toggle(other); }
            }

            $(#[$outer])*
            impl ::ops::BitAnd for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline] fn bitand(self, other: Self) -> Self { self.intersection(other) }
            }

            $(#[$outer])*
            impl ::ops::BitAndAssign for $PublicBitFlags
            {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline] fn bitand_assign(&mut self, other: Self) 
                { *self = Self::from_bits_retain(self.bits()).intersection(other); }
            }

            $(#[$outer])*
            impl ::ops::Sub for $PublicBitFlags
            {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[inline] fn sub(self, other: Self) -> Self { self.difference(other) }
            }

            $(#[$outer])*
            impl ::ops::SubAssign for $PublicBitFlags
            {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[inline] fn sub_assign(&mut self, other: Self) { self.remove(other); }
            }

            $(#[$outer])*
            impl ::ops::Not for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline] fn not(self) -> Self { self.complement() }
            }

            $(#[$outer])*
            impl ::iter::Extend<$PublicBitFlags> for $PublicBitFlags
            {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<T: ::iter::IntoIterator<Item = Self>>
                (
                    &mut self,
                    iterator: T,
                )
                {
                    for item in iterator
                    {
                        self.insert(item)
                    }
                }
            }

            $(#[$outer])*
            impl ::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags
            {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<T: ::iter::IntoIterator<Item = Self>>( iterator:T ) -> Self
                {
                    use ::iter::Extend;
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
        };
    }
    /// Implement constants on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_consts
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty
            {
                $(
                    $(#[$inner:ident $($args:tt)*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) =>
        {
            $(#[$outer])*
            impl $PublicBitFlags
            {
                $(
                    __bitflags_flag!
                    ({
                        name: $Flag,
                        named:
                        {
                            $(#[$inner $($args)*])*
                            pub const $Flag: Self = Self::from_bits_retain($value);
                        },
                        unnamed: {},
                    });
                )*
            }

            $(#[$outer])*
            impl ::bit::flags::Flags for $PublicBitFlags
            {
                const FLAGS: &'static [::bit::flags::Flag<$PublicBitFlags>] = 
                &[
                    $(
                        __bitflags_flag!
                        ({
                            name: $Flag,
                            named:
                            {
                                __bitflags_expr_safe_attrs!
                                (
                                    $(#[$inner $($args)*])*
                                    {
                                        #[allow(
                                            deprecated,
                                            non_upper_case_globals,
                                        )]
                                        ::bit::flags::Flag::new( stringify!($Flag), $PublicBitFlags::$Flag )
                                    }
                                )
                            },
                            unnamed:
                            {
                                __bitflags_expr_safe_attrs!
                                (
                                    $(#[$inner $($args)*])*
                                    {
                                        ::bit::flags::Flag::new("", $PublicBitFlags::from_bits_retain($value))
                                    }
                                )
                            },
                        }),
                    )*
                ];

                type Bits = $T;
                fn bits(&self) -> $T { $PublicBitFlags::bits(self) }
                fn from_bits_retain(bits: $T) -> $PublicBitFlags { $PublicBitFlags::from_bits_retain(bits) }
            }
        };
    }
    /// Generates buffer methods (to be invoked from within an impl block) forwarded to a buffer contained in self.
    #[macro_export] macro_rules! forward_screen_buffer_methods
    {
        ( |$slf:ident| $field:expr ) => {
            pub fn size(&self) -> ::system::terminal::Size {
                let $slf = self;
                $field.size()
            }

            pub fn cursor(&self) -> ::system::terminal::Cursor {
                let $slf = self;
                $field.cursor()
            }

            pub fn set_cursor(&self, pos: ::system::terminal::Cursor) {
                let $slf = self;
                $field.set_cursor(pos);
            }

            pub fn next_line(&self, column: usize) {
                let $slf = self;
                $field.next_line(column);
            }

            pub fn clear_screen(&self) {
                let $slf = self;
                $field.clear_screen();
            }

            pub fn clear_attributes(&self) {
                let $slf = self;
                $field.clear_attributes();
            }

            pub fn add_style(&self, style: ::system::terminal::Style) {
                let $slf = self;
                $field.add_style(style);
            }

            pub fn remove_style(&self, style: ::system::terminal::Style) {
                let $slf = self;
                $field.remove_style(style);
            }

            pub fn set_style(&self, style: ::system::terminal::Style) {
                let $slf = self;
                $field.set_style(style);
            }

            pub fn set_fg(&self, fg: Option<::system::terminal::Color>) {
                let $slf = self;
                $field.set_fg(fg);
            }

            pub fn set_bg(&self, bg: Option<::system::terminal::Color>) {
                let $slf = self;
                $field.set_bg(bg);
            }

            pub fn set_theme(&self, theme: ::system::terminal::Theme) {
                let $slf = self;
                $field.set_theme(theme)
            }

            pub fn write_char(&self, ch: char) {
                let $slf = self;
                let _ = $field.write_char(ch);
            }

            pub fn write_str(&self, s: &str) {
                let $slf = self;
                let _ = $field.write_str(s);
            }

            pub fn write_at(&self, pos: ::system::terminal::Cursor, text: &str) {
                let $slf = self;
                let _ = $field.write_at(pos, text);
            }

            pub fn write_styled(&self,
                    fg: Option<::system::terminal::Color>, bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style, text: &str) {
                let $slf = self;
                let _ = $field.write_styled(fg, bg, style, text);
            }

            pub fn write_styled_at(&self, pos: ::system::terminal::Cursor,
                    fg: Option<::system::terminal::Color>, bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style, text: &str) {
                let $slf = self;
                let _ = $field.write_styled_at(pos, fg, bg, style, text);
            }
        }
    }
    
    #[macro_export] macro_rules! forward_screen_buffer_mut_methods
    {
        ( |$slf:ident| $field:expr ) => {
            pub fn size(&self) -> ::system::terminal::Size {
                let $slf = self;
                $field.size()
            }

            pub fn cursor(&self) -> ::system::terminal::Cursor {
                let $slf = self;
                $field.cursor()
            }

            pub fn set_cursor(&mut self, pos: ::system::terminal::Cursor) {
                let $slf = self;
                $field.set_cursor(pos);
            }

            pub fn next_line(&mut self, column: usize) {
                let $slf = self;
                $field.next_line(column);
            }

            pub fn clear_screen(&mut self) {
                let $slf = self;
                $field.clear_screen();
            }

            pub fn clear_attributes(&mut self) {
                let $slf = self;
                $field.clear_attributes();
            }

            pub fn add_style(&mut self, style: ::system::terminal::Style) {
                let $slf = self;
                $field.add_style(style);
            }

            pub fn remove_style(&mut self, style: ::system::terminal::Style) {
                let $slf = self;
                $field.remove_style(style);
            }

            pub fn set_style(&mut self, style: ::system::terminal::Style) {
                let $slf = self;
                $field.set_style(style);
            }

            pub fn set_fg(&mut self, fg: Option<::system::terminal::Color>) {
                let $slf = self;
                $field.set_fg(fg);
            }

            pub fn set_bg(&mut self, bg: Option<::system::terminal::Color>) {
                let $slf = self;
                $field.set_bg(bg);
            }

            pub fn set_theme(&mut self, theme: ::system::terminal::Theme) {
                let $slf = self;
                $field.set_theme(theme);
            }

            pub fn write_char(&mut self, ch: char) {
                let $slf = self;
                let _ = $field.write_char(ch);
            }

            pub fn write_str(&mut self, s: &str) {
                let $slf = self;
                let _ = $field.write_str(s);
            }

            pub fn write_at(&mut self, pos: ::system::terminal::Cursor, text: &str) {
                let $slf = self;
                let _ = $field.write_at(pos, text);
            }

            pub fn write_styled(&mut self,
                    fg: Option<::system::terminal::Color>, bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style, text: &str) {
                let $slf = self;
                let _ = $field.write_styled(fg, bg, style, text);
            }

            pub fn write_styled_at(&mut self, pos: ::system::terminal::Cursor,
                    fg: Option<::system::terminal::Color>, bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style, text: &str) {
                let $slf = self;
                let _ = $field.write_styled_at(pos, fg, bg, style, text);
            }
        }
    }
    /// Expand a parametrized string.
    #[macro_export] macro_rules! expand 
    {
        ($value:expr) => ( ::expand!($value;) );

        ($value:expr => $context:expr) => ( ::expand!($value => $context;) );

        ($value:expr; $($item:expr),*) =>
        ( ::expand!($value => &mut ::default::Default::default(); $($item),*) );

        ($value:expr => $context:expr; $($item:expr),*) => 
        ({
            let mut output = ::vec::Vec::new();
            ::expand!(&mut output, $value => $context; $($item),*).map(|()| output)
        });

        ($output:expr, $value:expr) => ( ::expand!($output, $value;) );

        ($output:expr, $value:expr => $context:expr) => ( ::expand!($output, $value => $context;) );

        ($output:expr, $value:expr; $($item:expr),*) =>
        ( ::expand!($output, $value => &mut ::default::Default::default(); $($item),*) );

        ($output:expr, $value:expr => $context:expr; $($item:expr),*) =>
        ({
            use ::mode::Expands;
            $value.expand($output, &[$($item.into()),*], $context)
        })
    }
    /**/
    #[macro_export] macro_rules! log
    {
        ($fmt:expr) =>
        (
            let log_file = if let Ok(x) = ::env::var("PLS_LOG_FILE") { x.clone() }
            else { String::new() };

            if !log_file.is_empty()
            {
                use ::io::Write as _;

                let msg = $fmt;
                match ::fs::OpenOptions::new().append(true).create(true).open(&log_file)
                {
                    Ok(mut cfile) =>
                    {
                        let pid = ::process::getpid();
                        let now = ::time::c::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes())
                        {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }

                    Err(_) => println!("tlog: open file error"),
                }

            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }
    /**/
    #[macro_export] macro_rules! println_stderr
    {
        ($fmt:expr) =>
        (
            use ::io::Write;
            match writeln!( &mut ::io::stderr(), $fmt)
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );

        ($fmt:expr, $($arg:tt)*) =>
        (
            match writeln!( &mut ::io::stderr(), $fmt, $($arg)*)
            {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }
}

pub mod alloc
{
    pub use std::alloc::{ * };
}

pub mod arch
{
    pub use std::arch::{ x86_64::{ * }, * };
}

pub mod bit
{
    use ::
    {
        *,
    };

    pub mod flags
    {
        //! Generate types for C-style flags with ergonomic APIs.
        use ::
        {
            *,
        }; 

        pub mod iter
        {
            /// Yield the bits of a source flags value in a set of contained flags values.
            use ::
            {
                bit::flags::
                {
                    Flag, Flags,
                },
                *,
            };
            /// An iterator over flags values.
            pub struct Iter<B: 'static>
            {
                inner: IterNames<B>,
                done: bool,
            }

            impl<B: Flags> Iter<B>
            {
                pub fn new(flags: &B) -> Self
                {
                    Iter
                    {
                        inner: IterNames::new(flags),
                        done: false,
                    }
                }
            }

            impl<B: 'static> Iter<B>
            {
                pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self
                {
                    Iter
                    {
                        inner: IterNames::__private_const_new(flags, source, remaining),
                        done: false,
                    }
                }
            }

            impl<B: Flags> Iterator for Iter<B>
            {
                type Item = B;
                fn next(&mut self) -> Option<Self::Item>
                {
                    match self.inner.next()
                    {
                        Some((_, flag)) => Some(flag),
                        None if !self.done =>
                        {
                            self.done = true;
                            if !self.inner.remaining().is_empty()
                            {
                                Some(B::from_bits_retain(self.inner.remaining.bits()))
                            } else { None }
                        }
                        None => None,
                    }
                }
            }
            /// An iterator over flags values.
            pub struct IterNames<B: 'static>
            {
                flags: &'static [Flag<B>],
                idx: usize,
                source: B,
                remaining: B,
            }

            impl<B: Flags> IterNames<B>
            {
                pub fn new(flags: &B) -> Self
                {
                    IterNames
                    {
                        flags: B::FLAGS,
                        idx: 0,
                        remaining: B::from_bits_retain(flags.bits()),
                        source: B::from_bits_retain(flags.bits()),
                    }
                }
            }

            impl<B: 'static> IterNames<B>
            {
                pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self
                {
                    IterNames
                    {
                        flags,
                        idx: 0,
                        remaining,
                        source,
                    }
                }
                /// Get a flags value of any remaining bits that haven't been yielded yet.
                pub fn remaining(&self) -> &B { &self.remaining }
            }

            impl<B: Flags> Iterator for IterNames<B>
            {
                type Item = (&'static str, B);
                fn next(&mut self) -> Option<Self::Item>
                {
                    while let Some(flag) = self.flags.get(self.idx)
                    {
                        if self.remaining.is_empty() { return None; }
                        self.idx += 1;
                        
                        if flag.name().is_empty() { continue; }

                        let bits = flag.value().bits();
                        
                        if self.source.contains(B::from_bits_retain(bits)) && 
                        self.remaining.intersects(B::from_bits_retain(bits))
                        {
                            self.remaining.remove(B::from_bits_retain(bits));
                            return Some((flag.name(), B::from_bits_retain(bits)));
                        }
                    }

                    None
                }
            }
        } pub use self::iter::{ * };

        pub mod parser
        {
            //! Parsing flags from text.
            use ::
            {
                bit::flags::{ Bits, Flags },
                fmt::{ Write },
                *,
            };
            /// Write a flags value as text.
            pub fn to_writer<B: Flags>(flags: &B, mut writer: impl Write) -> Result<(), fmt::Error> where
            B::Bits: WriteHex,
            {
                let mut first = true;
                let mut iter = flags.iter_names();
                
                for (name, _) in &mut iter
                {
                    if !first { writer.write_str(" | ")?; }

                    first = false;
                    writer.write_str(name)?;
                }
                
                let remaining = iter.remaining().bits();
                if remaining != B::Bits::EMPTY
                {
                    if !first { writer.write_str(" | ")?; }

                    writer.write_str("0x")?;
                    remaining.write_hex(writer)?;
                }

                fmt::Result::Ok(())
            }
            /// Parse a flags value from text.
            pub fn from_str<B: Flags>(input: &str) -> Result<B, ParseError> where
            B::Bits: ParseHex,
            {
                let mut parsed_flags = B::empty();

                if input.trim().is_empty() { return Ok(parsed_flags); }

                for flag in input.split('|')
                {
                    let flag = flag.trim();
                    
                    if flag.is_empty() { return Err(ParseError::empty_flag()); }
                    
                    let parsed_flag = if let Some(flag) = flag.strip_prefix("0x")
                    {
                        let bits = <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;
                        B::from_bits_retain(bits)
                    }
                    
                    else { B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))? };

                    parsed_flags.insert(parsed_flag);
                }

                Ok(parsed_flags)
            }
            /// Write a flags value as text, ignoring any unknown bits.
            pub fn to_writer_truncate<B: Flags>(flags: &B, writer: impl Write) -> Result<(), fmt::Error> where
            B::Bits: WriteHex,
            { to_writer(&B::from_bits_truncate(flags.bits()), writer) }
            /// Parse a flags value from text.
            pub fn from_str_truncate<B: Flags>(input: &str) -> Result<B, ParseError> where
            B::Bits: ParseHex,
            { Ok(B::from_bits_truncate(from_str::<B>(input)?.bits())) }
            /// Write only the contained, defined, named flags in a flags value as text.
            pub fn to_writer_strict<B: Flags>(flags: &B, mut writer: impl Write) -> Result<(), fmt::Error>
            {
                let mut first = true;
                let mut iter = flags.iter_names();
                
                for (name, _) in &mut iter
                {
                    if !first {
                        writer.write_str(" | ")?;
                    }

                    first = false;
                    writer.write_str(name)?;
                }

                fmt::Result::Ok(())
            }
            /// Parse a flags value from text.
            pub fn from_str_strict<B: Flags>(input: &str) -> Result<B, ParseError>
            {
                let mut parsed_flags = B::empty();
                
                if input.trim().is_empty() { return Ok(parsed_flags); }

                for flag in input.split('|')
                {
                    let flag = flag.trim();
                    
                    if flag.is_empty() { return Err(ParseError::empty_flag()); }
                    
                    if flag.starts_with("0x"){ return Err(ParseError::invalid_hex_flag("unsupported hex value")); }

                    let parsed_flag = B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))?;

                    parsed_flags.insert(parsed_flag);
                }

                Ok(parsed_flags)
            }
            /// Encode a value as a hex string.
            pub trait WriteHex
            {
                /// Write the value as hex.
                fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result;
            }
            /// Parse a value from a hex string.
            pub trait ParseHex
            {
                /// Parse the value from hex.
                fn parse_hex(input: &str) -> Result<Self, ParseError> where Self: Sized;
            }
            /// An error encountered while parsing flags from text.
            #[derive(Debug)]
            pub struct ParseError(ParseErrorKind);

            #[derive(Debug)]
            pub enum ParseErrorKind
            {
                EmptyFlag,
                InvalidNamedFlag
                {
                    got: String,
                },
                InvalidHexFlag
                {
                    got: String,
                },
            }

            impl ParseError
            {
                /// An invalid hex flag was encountered.
                pub fn invalid_hex_flag(flag: impl fmt::Display) -> Self
                {
                    let _flag = flag;
                    let got = _flag.to_string();
                    ParseError(ParseErrorKind::InvalidHexFlag { got })
                }
                /// A named flag that doesn't correspond to any on the flags type was encountered.
                pub fn invalid_named_flag(flag: impl fmt::Display) -> Self
                {
                    let _flag = flag;
                    let got = _flag.to_string();
                    ParseError(ParseErrorKind::InvalidNamedFlag { got })
                }
                /// A hex or named flag wasn't found between separators.
                pub const fn empty_flag() -> Self
                {
                    ParseError(ParseErrorKind::EmptyFlag)
                }
            }

            impl fmt::Display for ParseError
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    match &self.0
                    {
                        ParseErrorKind::InvalidNamedFlag { got } =>
                        {
                            let _got = got;
                            write!(f, "unrecognized named flag")?;
                            write!(f, " `{}`", _got)?;
                        }

                        ParseErrorKind::InvalidHexFlag { got } =>
                        {
                            let _got = got;
                            write!(f, "invalid hex flag")?;
                            write!(f, " `{}`", _got)?;
                        }

                        ParseErrorKind::EmptyFlag => { write!(f, "encountered empty flag")?; }
                    }

                    Ok(())
                }
            }
            
            impl ::error::Error for ParseError {}
        } pub use self::parser::{ * };

        pub mod traits
        {
            use ::
            {
                bit::flags::
                {
                    iter::{ self },
                    parser::{ ParseError, ParseHex, WriteHex },
                },
                ops::{ BitAnd, BitOr, BitXor, Not },
                *,
            };
            /// A defined flags value that may be named or unnamed.
            #[derive(Debug)]
            pub struct Flag<B>
            {
                name: &'static str,
                value: B,
            }

            impl<B> Flag<B>
            {
                /// Define a flag.
                pub const fn new(name: &'static str, value: B) -> Self { Flag { name, value } }
                /// Get the name of this flag.
                pub const fn name(&self) -> &'static str { self.name }
                /// Get the flags value of this flag.
                pub const fn value(&self) -> &B { &self.value }
                /// Whether the flag is named.
                pub const fn is_named(&self) -> bool { !self.name.is_empty() }
                /// Whether the flag is unnamed.
                pub const fn is_unnamed(&self) -> bool { self.name.is_empty() }
            }
            /// A set of defined flags using a bits type as storage.
            pub trait Flags: Sized + 'static
            {
                /// The set of defined flags.
                const FLAGS: &'static [Flag<Self>];
                /// The underlying bits type.
                type Bits: Bits;
                /// Get a flags value with all bits unset.
                fn empty() -> Self { Self::from_bits_retain(Self::Bits::EMPTY) }
                /// Get a flags value with all known bits set.
                fn all() -> Self
                {
                    let mut truncated = Self::Bits::EMPTY;

                    for flag in Self::FLAGS.iter()
                    {
                        truncated = truncated | flag.value().bits();
                    }

                    Self::from_bits_retain(truncated)
                }
                /// This method will return `true` if any unknown bits are set.
                fn contains_unknown_bits(&self) -> bool { Self::all().bits() & self.bits() != self.bits() }
                /// Get the underlying bits value.
                fn bits(&self) -> Self::Bits;
                /// Convert from a bits value.
                fn from_bits(bits: Self::Bits) -> Option<Self>
                {
                    let truncated = Self::from_bits_truncate(bits);

                    if truncated.bits() == bits { Some( truncated ) } else { None }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                fn from_bits_truncate(bits: Self::Bits) -> Self { Self::from_bits_retain(bits & Self::all().bits()) }
                /// Convert from a bits value exactly.
                fn from_bits_retain(bits: Self::Bits) -> Self;
                /// Get a flags value with the bits of a flag with the given name set.
                fn from_name(name: &str) -> Option<Self>
                {
                    if name.is_empty() { return None; }

                    for flag in Self::FLAGS
                    {
                        if flag.name() == name { return Some(Self::from_bits_retain(flag.value().bits())); }
                    }

                    None
                }
                /// Yield a set of contained flags values.
                fn iter(&self) -> iter::Iter<Self> { iter::Iter::new(self) }
                /// Yield a set of contained named flags values.
                fn iter_names(&self) -> iter::IterNames<Self> { iter::IterNames::new(self) }
                /// Whether all bits in this flags value are unset.
                fn is_empty(&self) -> bool { self.bits() == Self::Bits::EMPTY }
                /// Whether all known bits in this flags value are set.
                fn is_all(&self) -> bool { Self::all().bits() | self.bits() == self.bits() }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                fn intersects(&self, other: Self) -> bool where
                Self: Sized,
                { self.bits() & other.bits() != Self::Bits::EMPTY }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                fn contains(&self, other: Self) -> bool where
                Self: Sized,
                { self.bits() & other.bits() == other.bits() }
                /// Remove any unknown bits from the flags.
                fn truncate(&mut self) where Self: Sized,
                { *self = Self::from_bits_truncate(self.bits()); }
                /// The bitwise or (`|`) of the bits in two flags values.
                fn insert(&mut self, other: Self) where
                Self: Sized,
                { *self = Self::from_bits_retain(self.bits()).union(other); }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                fn remove(&mut self, other: Self) where
                Self: Sized,
                { *self = Self::from_bits_retain(self.bits()).difference(other); }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                fn toggle(&mut self, other: Self) where
                Self: Sized,
                { *self = Self::from_bits_retain(self.bits()).symmetric_difference(other); }
                /// Call [`Flags::insert`] when `value` is `true` or [`Flags::remove`] when `value` is `false`.
                fn set(&mut self, other: Self, value: bool) where
                Self: Sized,
                {
                    if value { self.insert(other); }
                    else { self.remove(other); }
                }
                /// Unsets all bits in the flags.
                fn clear(&mut self) where
                Self: Sized,
                { *self = Self::empty(); }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[must_use] fn intersection(self, other: Self) -> Self
                { Self::from_bits_retain(self.bits() & other.bits()) }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[must_use] fn union(self, other: Self) -> Self { Self::from_bits_retain(self.bits() | other.bits()) }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[must_use] fn difference(self, other: Self) -> Self
                { Self::from_bits_retain(self.bits() & !other.bits()) }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[must_use] fn symmetric_difference(self, other: Self) -> Self
                { Self::from_bits_retain(self.bits() ^ other.bits()) }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[must_use] fn complement(self) -> Self { Self::from_bits_truncate(!self.bits()) }
            }
            /// A bits type that can be used as storage for a flags type.
            pub trait Bits:
            Clone
            + Copy
            + PartialEq
            + BitAnd<Output = Self>
            + BitOr<Output = Self>
            + BitXor<Output = Self>
            + Not<Output = Self>
            + Sized
            + 'static
            {
                /// A value with all bits unset.
                const EMPTY: Self;
                /// A value with all bits set.
                const ALL: Self;
            }
            
            pub trait Primitive {}

            impl_bits! { u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, usize, isize, }
            /// A trait for referencing the `bitflags`-owned internal type without exposing it publicly.
            pub trait PublicFlags
            {
                /// The type of the underlying storage.
                type Primitive: Primitive;
                /// The type of the internal field on the generated flags type.
                type Internal;
            }
            
            pub trait BitFlags: ImplementedByBitFlagsMacro + Flags
            {
                /// An iterator over enabled flags in an instance of the type.
                type Iter: Iterator<Item = Self>;
                /// An iterator over the raw names and bits for enabled flags in an instance of the type.
                type IterNames: Iterator<Item = (&'static str, Self)>;
            }
            
            impl<B: Flags> BitFlags for B
            {
                type Iter = iter::Iter<Self>;
                type IterNames = iter::IterNames<Self>;
            }

            impl<B: Flags> ImplementedByBitFlagsMacro for B {}
            /// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.
            pub trait ImplementedByBitFlagsMacro {}

            pub mod __private 
            {
                pub use super::{ImplementedByBitFlagsMacro, PublicFlags};
            }
        } pub use self::traits::{ * };
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod cell
{
   pub use std::cell::{ * };
}

pub mod char
{
    //! Character stream used for parsing.
    pub use std::char::{ * };
    use ::
    {
        cell::{ RefCell },
        fs::{ File },
        io::{ self, Read },
        iter::{ Peekable },
        rc::{ Rc },
        str::{ Chars },
        *,
    };
    
    pub const CTRL_MASK: u8 = 0x1f;
    pub const CTRL_MAX: u32 = 0x1f;
    pub const CTRL_BIT: u8 = 0x40;
    pub const UNCTRL_BIT: u8 = 0x40;

    #[derive(Clone, Debug)]
    struct Inner
    {
        file: Option<String>,
        contents: String,
        stream: Peekable<Chars<'static>>,
        line: usize,
        col: usize,
    }

    #[derive(Clone, Debug)]
    pub struct CharStream
    {
        inner: Rc<RefCell<Inner>>,
    }

    impl CharStream
    {
        pub fn from_file(path: &str) -> io::Result<CharStream>
        {
            let mut file = File::open(path)?;

            let len = file.metadata()?.len();
            let mut contents = String::with_capacity(len as usize);

            file.read_to_string(&mut contents)?;

            Self::from_string_impl(Some(String::from(path)), contents)
        }

        pub fn from_string(contents: String) -> io::Result<CharStream>
        {
            Self::from_string_impl(None, contents)
        }

        pub fn from_string_impl(file: Option<String>, contents: String) -> io::Result<CharStream>
        {
            let chars: Chars = unsafe { mem::transmute(contents.chars()) };
            let stream = chars.peekable();

            Ok(CharStream
            {
                inner: Rc::new(RefCell::new(Inner
                {
                    file,
                    contents,
                    stream,
                    line: 1,
                    col: 1,
                })),
            })
        }

        pub fn peek(&self) -> Option<char>
        {
            let mut inner = self.inner.borrow_mut();
            let opt = inner.stream.peek();
            match opt
            {
                Some(ch) => Some(*ch),
                None => None,
            }
        }

        pub fn file(&self) -> Option<String>
        {
            let inner = self.inner.borrow();
            inner.file.clone()
        }

        pub fn line(&self) -> usize
        {
            let inner = self.inner.borrow();
            inner.line
        }

        pub fn col(&self) -> usize
        {
            let inner = self.inner.borrow();
            inner.col
        }

        fn set_line(&mut self, value: usize)
        {
            let mut inner = self.inner.borrow_mut();
            inner.line = value;
        }

        fn set_col(&mut self, value: usize)
        {
            let mut inner = self.inner.borrow_mut();
            inner.col = value;
        }
    }

    impl Iterator for CharStream
    {
        type Item = char;

        fn next(&mut self) -> Option<Self::Item>
        {
            let opt =
            {
                let mut inner = self.inner.borrow_mut();
                inner.stream.next()
            };

            match opt
            {
                Some(ch) =>
                {
                    if ch == '\n' {
                        let line = self.line();
                        self.set_line(line + 1);
                        self.set_col(1);
                    } else {
                        let col = self.col();
                        self.set_col(col + 1);
                    }
                    Some(ch)
                }
                None => None,
            }
        }
    }
    /*
    pub fn format_char(...) -> String */
    pub fn format( ch:char ) -> String
    {
        match ch
        {
            '\n' => String::from("\\n"),
            ch => format!("{}", ch),
        }
    }
    /*
    pub fn get_escape_char(...) -> Option<char> */
    /// If `ch` preceded by a backslash together form an escape character, then return this char.
    pub fn get_escape(ch: char) -> Option<char>
    {
        match ch 
        {
            '\\' => Some('\\'),
            '"' => Some('"'),
            '\'' => Some('\''),
            '$' => Some('$'),
            'n' => Some('\n'),
            'r' => Some('\r'),
            't' => Some('\t'),
            _ => None,
        }
    }
    /*
    pub fn char_width(ch: char) -> Option<usize> */
    /// Returns the width of a character in the terminal.
    #[inline] pub fn width(ch: char) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
    /// Returns the control character corresponding to the given character.
    #[inline] pub fn ctrl(ch: char) -> char { ((ch as u8) & CTRL_MASK) as char }
    /// Returns the printable character corresponding to the given control character.
    pub fn unctrl(c: char) -> char { ((c as u8) | CTRL_BIT) as char }
    /// Returns the ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_upper(ch: char) -> char { ((ch as u8) | UNCTRL_BIT) as char }
    /// Returns the lowercase ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_lower(ch: char) -> char { unctrl_upper(ch).to_ascii_lowercase() }
    // ::linefeed::chars.rs
    // Provides utilities for manipulating character values
    /// Character value indicating end-of-file
    pub const EOF: char = '\x04';
    /// Character value generated by the Escape key
    pub const ESCAPE: char = '\x1b';
    /// Character value generated by the Backspace key( RUBOUT )
    #[cfg(unix)] pub const DELETE: char = RUBOUT;
    /// Character value generated by the Backspace key( Ctrl-H )
    #[cfg(windows)] pub const DELETE: char = '\x08';
    /// Character value generated by the Backspace key on some systems
    pub const RUBOUT: char = '\x7f';
    /*
    pub fn parse_char_name(...) -> Option<String> */
    /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
    pub fn parse_name(name: &str) -> Option<String>
    {
        let name_lc = name.to_lowercase();
        let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
        let is_meta = contains_any(&name_lc, &["m-", "meta-"]);

        let name = match name_lc.rfind('-')
        {
            Some(pos) => &name_lc[pos + 1..],
            None => &name_lc[..]
        };

        let ch = match name
        {
            "del" | "rubout"  => DELETE,
            "esc" | "escape"  => ESCAPE,
            "lfd" | "newline" => '\n',
            "ret" | "return"  => '\r',
            "spc" | "space"   => ' ',
            "tab"             => '\t',
            s if !s.is_empty() => s.chars().next().unwrap(),
            _ => return None
        };

        let ch = match (is_ctrl, is_meta)
        {
            (true,  true)  => meta(ctrl(ch)),
            (true,  false) => ctrl(ch).to_string(),
            (false, true)  => meta(ch),
            (false, false) => ch.to_string(),
        };

        Some(ch)
    }
    /// Returns a character sequence escaped for user-facing display.
    pub fn escape_sequence(s: &str) -> String
    {
        let mut res = String::with_capacity(s.len());

        for ch in s.chars() {
            match ch {
                ESCAPE => res.push_str(r"\e"),
                RUBOUT => res.push_str(r"\C-?"),
                '\\' => res.push_str(r"\\"),
                '\'' => res.push_str(r"\'"),
                '"' => res.push_str(r#"\""#),
                ch if is_ctrl(ch) => {
                    res.push_str(r"\C-");
                    res.push(unctrl_lower(ch));
                }
                ch => res.push(ch)
            }
        }

        res
    }
    /// Returns a meta sequence for the given character.
    pub fn meta(ch: char) -> String
    {
        let mut s = String::with_capacity(ch.len_utf8() + 1);
        s.push(ESCAPE);
        s.push(ch);
        s
    }

    fn contains_any(s: &str, strs: &[&str]) -> bool { strs.iter().any(|a| s.contains(a)) }
    /// Returns whether the given character is a control character.
    pub fn is_ctrl(c: char) -> bool { c != '\0' && c as u32 <= CTRL_MAX }
    
    #[inline] #[must_use] pub const fn len_utf16(code: u32) -> usize { if (code & 0xFFFF) == code { 1 } else { 2 } }
    /// Encodes a raw `u32` value as native endian UTF-16 into the provided `u16` buffer,
    /// and then returns the subslice of the buffer that contains the encoded character.
    #[inline] pub const fn encodes_utf16_raw(mut code: u32, dst: &mut [u16]) -> Option<&mut [u16]>
    {
        let len = len_utf16(code);
        match (len, &mut *dst)
        {
            (1, [a, ..]) => { *a = code as u16; }

            (2, [a, b, ..]) =>
            {
                code -= 0x1_0000;
                *a = (code >> 10) as u16 | 0xD800;
                *b = (code & 0x3FF) as u16 | 0xDC00;
            }
            _ => { return None; }
        };
        
        unsafe { Some( slice::from_raw_parts_mut(dst.as_mut_ptr(), len) ) }
    }
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}
/*
over | the best data format. */
pub mod database
{
    use ::
    {
        collections::
        {
            hash_map::{Iter, Keys, Values},
            HashMap,
        },
        ffi::{ CStr },
        io::{ Write as _ },
        path::{ Path },
        sync::{ Arc, Mutex },
        str::{ SmallCString },
        *,
    };
    /// Indent step in .over files.
    const INDENT_STEP: usize = 4; 

    pub mod arrays
    {
        //! `Arr` module | An array container which can hold an arbitrary number of elements of a single type.
        use ::
        {
            database::
            {
                parses::format::Format,
                types::Type,
                values::Value,
                OverError, OverResult, INDENT_STEP,
            },
            slice::Iter,
            sync::Arc,
            *,
        };
        
        #[derive(Clone, Debug)]
        struct ArrInner 
        {
            vec: Vec<Value>,
            inner_t: Type,
        }
        /// `Arr` struct.
        #[derive(Clone, Debug)]
        pub struct Arr 
        {
            inner: Arc<ArrInner>,
        }

        impl Arr 
        {
            /// Returns a new `Arr` from the given vector of `Value`s.
            pub fn from_vec(vec: Vec<Value>) -> OverResult<Arr> 
            {
                let mut tcur = Type::Any;
                let mut has_any = true;

                for value in &vec {
                    let tnew = value.get_type();

                    if has_any {
                        match Type::most_specific(&tcur, &tnew) {
                            Some((t, any)) => {
                                tcur = t;
                                has_any = any;
                            }
                            None => return Err(OverError::ArrayTypeMismatch(tcur, tnew)),
                        }
                    } else if tcur != tnew {
                        return Err(OverError::ArrayTypeMismatch(tcur, tnew));
                    }
                }

                Ok(Arr {
                    inner: Arc::new(ArrInner { vec, inner_t: tcur }),
                })
            }
            /// Returns a new `Arr` from the given vector of `Value`s without checks.
            pub fn from_vec_unchecked(vec: Vec<Value>, inner_t: Type) -> Arr 
            {
                Arr {
                    inner: Arc::new(ArrInner { vec, inner_t }),
                }
            }
            /// Returns a reference to the inner vec of this `Arr`.
            pub fn vec_ref(&self) -> &Vec<Value> 
            {
                &self.inner.vec
            }
            /// Iterates over each `Value` in `self`, applying `Fn` `f`.
            pub fn with_each<F>(&self, mut f: F) where
                F: FnMut(&Value),
            {
                for value in &self.inner.vec {
                    f(value)
                }
            }
            /// Gets the value at `index`.
            pub fn get(&self, index: usize) -> OverResult<Value> 
            {
                if index >= self.inner.vec.len() {
                    Err(OverError::IndexError(index))
                } else {
                    Ok(self.inner.vec[index].clone())
                }
            }
            /// Returns the type of all elements in this `Arr`.
            pub fn inner_type(&self) -> Type 
            {
                self.inner.inner_t.clone()
            }
            /// Returns the length of this `Arr`.
            pub fn len(&self) -> usize 
            {
                self.inner.vec.len()
            }
            /// Returns whether this `Arr` is empty.
            pub fn is_empty(&self) -> bool
            {
                self.inner.vec.is_empty()
            }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq(&self, other: &Self) -> bool 
            {
                Arc::ptr_eq(&self.inner, &other.inner)
            }
            /// Returns an iterator over the Arr.
            pub fn iter(&self) -> Iter<Value> 
            {
                self.vec_ref().iter()
            }
        }

        impl Default for Arr 
        
        {
            fn default() -> Self  { Self::from_vec_unchecked(vec![], Type::Any) }
        }

        impl fmt::Display for Arr 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            { write!(f, "{}", self.format(true, INDENT_STEP)) }
        }

        impl PartialEq for Arr 
        
        {
            fn eq(&self, other: &Self) -> bool 
            {
                if self.inner.inner_t != other.inner.inner_t {
                    return false;
                }

                self.inner.vec == other.inner.vec
            }
        }
    } pub use self::arrays::{ * };

    pub mod error
    {
        //! Error module.
        use ::
        {
            database::
            {
                parses::error::ParseError,
                types::Type,
            },
            error::{ Error },
            *,
        };
        /// Result type for this crate.
        pub type OverResult<T> = Result<T, OverError>;
        /// The fabulous OVER error type.
        #[derive(Debug, PartialEq, Eq)]
        pub enum OverError
        {
            // Query Errors
            DatabaseNotFound,
            EnvironmentFileNotFound,
            NoParentFound,
            Unfounded,               // NotFound
            // Index Errors
            BoundaryError(usize),    // TupOutOfBounds( u )
            IndexError(usize),       // ArrOutOfBounds( u )
            // Invalid Errors
            IoError(String),
            ParseError(String), // Parse
            ExpandError(String), // Expand( e )            
            FieldNotFound(String),
            InvalidFieldName(String),           
            // Mismatch Errors
            ArrayTypeMismatch(Type, Type),
            TupleMismatch(Type, Type, usize), // TupTypeMismatch
            TypeMismatch(Type, Type),
            
        }

        impl fmt::Display for OverError
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                use self::OverError::*;
                match *self 
                {
                    IndexError(ref index) => write!(f, "Arr index {} out of bounds", index),
                    ArrayTypeMismatch(ref expected, ref found) => write!
                    (
                        f,
                        "Array inner types do not match: expected {}, found {}",
                        expected, found
                    ),
                    DatabaseNotFound  => write!(f, "Database not found."),
                    EnvironmentFileNotFound  => write!(f, "Environment File not found."),
                    FieldNotFound(ref field) => write!(f, "Field not found: \"{}\"", field),
                    InvalidFieldName(ref field) => write!(f, "Invalid field name: \"{}\"", field),
                    NoParentFound => write!(f, "No parent found for this obj"),
                    BoundaryError(ref index) => write!(f, "Tup index {} out of bounds", index),
                    TupleMismatch(ref expected, ref found, ref index) => write!(
                        f,
                        "Tup inner types do not match at index {}: expected {}, found {}",
                        index, expected, found
                    ),
                    TypeMismatch(ref expected, ref found) => {
                        write!(f, "Type mismatch: expected {}, found {}", expected, found)
                    }

                    ParseError(ref error) | IoError(ref error) | ExpandError(ref error) => write!(f, "{}", error),
                    _ => write!(f, "Unknown Database Error" ),
                    
                }
            }
        }

        impl Error for OverError
        {
            fn description(&self) -> &str
            {
                use self::OverError::*;
                match *self
                {
                    IndexError(_) => "Arr index out of bounds",
                    ArrayTypeMismatch(_, _) => "Arr inner types do not match",
                    DatabaseNotFound => "Database not found",
                    EnvironmentFileNotFound => "Environment File not found",
                    FieldNotFound(_) => "Field not found",
                    InvalidFieldName(_) => "Invalid field name",
                    NoParentFound => "No parent found for this obj",
                    BoundaryError(_) => "Tup index out of bounds",
                    TupleMismatch(_, _, _) => "Tup inner types do not match",
                    TypeMismatch(_, _) => "Type mismatch",
                    ParseError(ref error) | IoError(ref error) | ExpandError(ref error) => error,
                    _ => "Unknown Error Description"
                }
            }
        }

        impl From<io::Error> for OverError
        {
            fn from(e: io::Error) -> Self
            {
                OverError::IoError(format!("{}", e))
            }
        }

        impl From<ParseError> for OverError
        {
            fn from(e: ParseError) -> Self
            {
                OverError::ParseError(format!("{}", e))
            }
        }

    } pub use self::error::{ * };

    pub mod objects
    {
        //! `Obj` module | A hashmap of keys to values, where values can be any type, including other objects.
        use ::
        {
            collections::
            {
                hash_map::{Iter, Keys, Values},
                HashMap,
            },
            database::
            {
                arrays::Arr,
                error::OverError,
                parses::{ self, format::Format },
                tuples::Tup,
                types::Type,
                values::Value,
                OverResult, INDENT_STEP,
            },
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ Zero },
            },
            str::{ FromStr },
            sync::
            {
                atomic::{AtomicUsize, Ordering}, Arc,
            },
            *,
        };

        lazy_static! 
        {
            static ref CUR_ID: AtomicUsize = AtomicUsize::new(0);
        }

        fn get_id() -> usize 
        {
            CUR_ID.fetch_add(1, Ordering::Relaxed)
        }

        #[derive(Clone, Debug)]
        struct ObjInner 
        {
            map: HashMap<String, Value>,
            parent: Option<Obj>,
            id: usize,
        }
        /// `Obj` struct.
        #[derive(Clone, Debug)]
        pub struct Obj 
        {
            inner: Arc<ObjInner>,
        }

        macro_rules! get_fn 
        {
            ( $doc:expr, $name:tt, $type:ty ) => {
                #[doc=$doc]
                pub fn $name(&self, field: &str) -> OverResult<$type> {
                    match self.get(field) {
                        Some(value) => {
                            match value.$name() {
                                Ok(result) => Ok(result),
                                e @ Err(_) => e,
                            }
                        }
                        None => Err(OverError::FieldNotFound(field.into())),
                    }
                }
            }
        }

        impl Obj 
        {
            /// Returns a new `Obj` created from the given `HashMap`.
            pub fn from_map(obj_map: HashMap<String, Value>) -> OverResult<Obj> 
            {
                for field in obj_map.keys() {
                    if !Self::is_valid_field(field) {
                        return Err(OverError::InvalidFieldName((*field).clone()));
                    }
                }
                let id = get_id();

                Ok(Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: None,
                        id,
                    }),
                })
            }
            /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
            pub fn from_map_with_parent(obj_map: HashMap<String, Value>, parent: Obj) -> OverResult<Obj> 
            {
                for field in obj_map.keys() {
                    if !Self::is_valid_field(field) {
                        return Err(OverError::InvalidFieldName(field.clone()));
                    }
                }
                let id = get_id();

                Ok(Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: Some(parent),
                        id,
                    }),
                })
            }
            /// Returns a new `Obj` created from the given `HashMap`.
            pub fn from_map_unchecked(obj_map: HashMap<String, Value>) -> Obj 
            {
                let id = get_id();

                Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: None,
                        id,
                    }),
                }
            }
            /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
            pub fn from_map_with_parent_unchecked(obj_map: HashMap<String, Value>, parent: Obj) -> Obj 
            {
                let id = get_id();

                Obj {
                    inner: Arc::new(ObjInner {
                        map: obj_map,
                        parent: Some(parent),
                        id,
                    }),
                }
            }
            /// Returns the ID of this `Obj`.
            pub fn id(&self) -> usize 
            {
                self.inner.id
            }
            /// Returns a reference to the inner map of this `Obj`.
            pub fn map_ref(&self) -> &HashMap<String, Value> 
            {
                &self.inner.map
            }
            /// Returns a new `Obj` loaded from a file.
            pub fn from_file(path: &str) -> OverResult<Obj> 
            {
                Ok(parses::load_from_file(path)?)
            }
            /// Writes this `Obj` to given file in `.over` representation.
            pub fn write_to_file(&self, path: &str) -> OverResult<()> 
            {
                str::write_file(path, &self.write_str())?;
                Ok(())
            }
            /// Writes this `Obj` to a `String`.
            pub fn write_str(&self) -> String 
            {
                self.format(false, 0)
            }
            /// Iterates over each `(String, Value)` pair in `self`, applying `f`.
            pub fn with_each<F>(&self, mut f: F) where
                F: FnMut(&String, &Value),
            {
                for (field, value) in &self.inner.map {
                    f(field, value)
                }
            }
            /// Returns the number of fields for this `Obj` (parent fields not included).
            pub fn len(&self) -> usize 
            {
                self.inner.map.len()
            }
            /// Returns whether this `Obj` is empty.
            pub fn is_empty(&self) -> bool
            {
                self.inner.map.is_empty()
            }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq(&self, other: &Self) -> bool 
            {
                Arc::ptr_eq(&self.inner, &other.inner)
            }
            /// Returns true if this `Obj` contains `field`.
            pub fn contains(&self, field: &str) -> bool
            {
                self.inner.map.contains_key(field)
            }
            /// Gets the `Value` associated with `field`.
            pub fn get(&self, field: &str) -> Option<Value> 
            {
                match self.inner.map.get(field) {
                    Some(value) => Some(value.clone()),
                    None => match self.inner.parent {
                        Some(ref parent) => parent.get(field),
                        None => None,
                    },
                }
            }
            /// Gets the `Value` associated with `field` and the `Obj` where it was found.
            pub fn get_with_source(&self, field: &str) -> Option<(Value, Obj)> 
            {
                match self.inner.map.get(field) {
                    Some(value) => Some((value.clone(), self.clone())),
                    None => match self.inner.parent {
                        Some(ref parent) => parent.get_with_source(field),
                        None => None,
                    },
                }
            }

            get_fn!(
                "Returns the `bool` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Bool`.",
                get_bool,
                bool
            );
            get_fn!(
                "Returns the `BigInt` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Int`.",
                get_int,
                BigInt
            );
            get_fn!(
                "Returns the `BigRational` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Frac`.",
                get_frac,
                BigRational
            );
            get_fn!(
                "Returns the `char` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Char`.",
                get_char,
                char
            );
            get_fn!(
                "Returns the `String` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Str`.",
                get_str,
                String
            );
            get_fn!(
                "Returns the `Arr` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Arr`.",
                get_arr,
                Arr
            );
            get_fn!(
                "Returns the `Tup` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Tup`.",
                get_tup,
                Tup
            );
            get_fn!(
                "Returns the `Obj` found at `field`. \
                Returns an error if the field was not found \
                or if the `Value` at `field` is not `Obj`.",
                get_obj,
                Obj
            );
            /// Returns whether this `Obj` has a parent.
            pub fn has_parent(&self) -> bool
            {
                self.inner.parent.is_some()
            }
            /// Returns the parent for this `Obj`.
            pub fn get_parent(&self) -> Option<Obj> 
            {
                match self.inner.parent {
                    Some(ref parent) => Some(parent.clone()),
                    None => None,
                }
            }
            /// Returns true if `field` is a valid field name for an `Obj`.
            pub fn is_valid_field(field: &str) -> bool 
            {
                let mut first = true;

                for ch in field.chars() {
                    if first {
                        if !Self::is_valid_field_char(ch, true) {
                            return false;
                        }
                        first = false;
                    } else if !Self::is_valid_field_char(ch, false) {
                        return false;
                    }
                }

                true
            }
            /// Returns true if the given char is valid for a field, depending on whether it is the first char or not.
            pub fn is_valid_field_char(ch: char, first: bool) -> bool
            {
                match ch {
                    ch if ch.is_alphabetic() => true,
                    ch if is::char_digit(ch) => !first,
                    '_' => true,
                    '^' => first,
                    _ => false,
                }
            }
            /// An iterator visiting all fields (keys) in arbitrary order.
            pub fn keys(&self) -> Keys<String, Value> 
            {
                self.map_ref().keys()
            }
            /// An iterator visiting all values in arbitrary order.
            pub fn values(&self) -> Values<String, Value> 
            {
                self.map_ref().values()
            }
            /// An iterator visiting all field-value pairs in arbitrary order.
            pub fn iter(&self) -> Iter<String, Value> 
            {
                self.map_ref().iter()
            }
        }

        impl Default for Obj 
        
        {
            fn default() -> Self {
                Self::from_map_unchecked(map! {})
            }
        }

        impl fmt::Display for Obj 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {write!(f, "{}", self.format(true, INDENT_STEP))
            }
        }

        impl FromStr for Obj
        {
            type Err = OverError;

            fn from_str(s: &str) -> Result<Self, Self::Err> 
            {
                Ok(parses::load_from_str(s)?)
            }
        }
        /// For two Objs to be equal, the following two checks must pass:
        /// 1. If either Obj has a parent, then both must have parents and the parents must be equal.
        /// 2. The two Objs must have all the same fields pointing to the same values.
        impl PartialEq for Obj 
        
        {
            fn eq(&self, other: &Self) -> bool 
            {
                let inner = &self.inner;
                let other_inner = &other.inner;
                
                if inner.parent.is_some() && other_inner.parent.is_some() {
                    let parent = self.get_parent().unwrap();
                    let other_parent = other.get_parent().unwrap();
                    if parent != other_parent {
                        return false;
                    }
                } else if !(inner.parent.is_none() && other_inner.parent.is_none()) {
                    return false;
                }
                
                inner.map == other_inner.map
            }
        }
        
        impl Eq for Obj {}
    } pub use self::objects::{ * };

    pub mod tuples
    {
        use ::
        {
            database::
            {
                parses::format::Format,
                types::Type,
                values::Value,
                OverError, OverResult, INDENT_STEP,
            },
            slice::Iter,
            sync::Arc,
            *,
        };
        
        #[derive(Clone, Debug)]
        struct TupInner 
        {
            vec: Vec<Value>,
            inner_tvec: Vec<Type>,
        }
        /// `Tup` struct.
        #[derive(Clone, Debug)]
        pub struct Tup 
        {
            inner: Arc<TupInner>,
        }

        impl Tup 
        {
            /// Returns a new `Tup` from the given vector of `Value`s.
            pub fn from_vec(values: Vec<Value>) -> Tup {
                let tvec: Vec<Type> = values.iter().map(|val| val.get_type()).collect();

                Tup {
                    inner: Arc::new(TupInner {
                        vec: values,
                        inner_tvec: tvec,
                    }),
                }
            }
            /// Returns a reference to the inner vec of this `Tup`.
            pub fn vec_ref(&self) -> &Vec<Value> 
            {
                &self.inner.vec
            }
            /// Iterates over each `Value` in `self`, applying `Fn` `f`.
            pub fn with_each<F>(&self, mut f: F) where
                F: FnMut(&Value),
            {
                for value in &self.inner.vec {
                    f(value)
                }
            }
            /// Gets the value at `index`.
            /// Returns an error if `index` is out of bounds.
            pub fn get(&self, index: usize) -> OverResult<Value> {
                if index >= self.inner.vec.len() {
                    Err(OverError::BoundaryError(index))
                } else {
                    Ok(self.inner.vec[index].clone())
                }
            }
            /// Returns the type vector of this `Tup`.
            pub fn inner_type_vec(&self) -> Vec<Type> 
            {
                self.inner.inner_tvec.clone()
            }
            /// Returns the length of this `Tup`.
            pub fn len(&self) -> usize {
                self.inner.vec.len()
            }
            /// Returns whether this `Tup` is empty.
            pub fn is_empty(&self) -> bool
            {
                self.inner.vec.is_empty()
            }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq(&self, other: &Self) -> bool {
                Arc::ptr_eq(&self.inner, &other.inner)
            }
            /// Returns an iterator over the Tup.
            pub fn iter(&self) -> Iter<Value> 
            {
                self.vec_ref().iter()
            }
        }

        impl Default for Tup 
        
        {
            fn default() -> Self {
                Self::from_vec(vec![])
            }
        }

        impl fmt::Display for Tup 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {write!(f, "{}", self.format(true, INDENT_STEP))
            }
        }

        impl From<Vec<Value>> for Tup 
        
        {
            fn from(vec: Vec<Value>) -> Self {
                Self::from_vec(vec)
            }
        }

        impl PartialEq for Tup 
        
        {
            fn eq(&self, other: &Self) -> bool {
                if self.inner.inner_tvec != other.inner.inner_tvec {
                    return false;
                }

                self.inner.vec == other.inner.vec
            }
        }
    } pub use self::tuples::{ * };

    pub mod types
    {
        //! Module for types.
        use ::
        {
            *,
        };
        /// Enum of possible types for `Value`s.
        #[derive(Clone, Debug)]
        pub enum Type 
        {
            /// A type used to indicate an empty Arr.
            Any,
            /// Null value.
            Null,
            /// A Capability Marker
            True,
            /// A boolean type.
            Bool,
            /// A signed integer type.
            Int,
            /// A fractional type.
            Frac,
            /// A character type.
            Char,
            /// A string type.
            Str,
            /// An array type, containing the type of its sub-elements.
            Arr(Box<Type>),
            /// A tuple type, containing the types of its sub-elements.
            Tup(Vec<Type>),
            /// An object type.
            Obj,
            /// A Capability Number
            Number,
            /// A Capability String
            String,
        }

        impl Type 
        {
            /// Returns true if this type is strictly the same as `other`.
            pub fn is(&self, other: &Type) -> bool
            {
                use self::Type::*;

                match *self
                {
                    Any => 
                    {
                        if let Any = *other { true }
                        else { false }
                    }
                    
                    Null => 
                    {
                        if let Null = *other { true }
                        else { false }
                    }

                    True => 
                    {
                        if let True = *other { true }
                        else { false }
                    }

                    Bool => 
                    {
                        if let Bool = *other { true }
                        else { false }
                    }

                    Int => 
                    {
                        if let Int = *other { true }
                        else { false }
                    }

                    Frac => 
                    {
                        if let Frac = *other { true }
                        else { false }
                    }

                    Char => 
                    {
                        if let Char = *other { true }
                        else { false }
                    }

                    Str => 
                    {
                        if let Str = *other { true }
                        else { false }
                    }

                    Obj => 
                    {
                        if let Obj = *other { true }
                        else { false }
                    }
                    
                    Number =>
                    {
                        if let Number = *other { true }
                        else { false }
                    }

                    String =>
                    {
                        if let String = *other { true }
                        else { false }
                    }

                    Arr(ref t1) =>
                    {
                        if let Arr(ref t2) = *other { t1.is(t2) }
                        else { false }
                    }

                    Tup( ref tvec1 ) =>
                    {
                        if let Tup( ref tvec2 ) = *other
                        {
                            if tvec1.len() != tvec2.len() { return false; }

                            tvec1.iter().zip(tvec2.iter()).all(|(t1, t2)| t1.is(t2))
                        }
                        
                        else { false }
                    }
                }
            }
            /// Returns true if this `Type` contains `Any`.
            pub fn has_any(&self) -> bool
            {
                match *self
                {
                    Type::Any => true,
                    Type::Arr(ref t) => Self::has_any(t),
                    Type::Tup(ref tvec) => tvec.iter().any(|t| Self::has_any(t)),
                    _ => false,
                }
            }
            /// Returns a type with the most specificity that can be applied to the two input types as well
            /// as `true` if the returned type is not maximally specific, that is, it contains `Any`.
            pub fn most_specific(type1: &Type, type2: &Type) -> Option<(Type, bool)>
            {
                use self::Type::*;

                if let Any = *type2
                {
                    return Some((type1.clone(), type1.has_any()));
                }

                match *type1
                {
                    Any => Some((type2.clone(), type2.has_any())),

                    Arr(ref t1) =>
                    {
                        if let Arr(ref t2) = *type2
                        {
                            Self::most_specific(t1, t2).map(|(t, any)| (Arr(Box::new(t)), any))
                        }

                        else { None }
                    }

                    Tup(ref tvec1) =>
                    {
                        if let Tup(ref tvec2) = *type2
                        {
                            if tvec1.len() == tvec2.len()
                            {
                                let mut has_any = false;

                                let tvec: Option<Vec<Type>> = tvec1
                                .iter()
                                .zip(tvec2.iter())
                                .map(|(t1, t2)|
                                {
                                    Self::most_specific(t1, t2).map(|(t, any)|
                                    {
                                        if !has_any && any { has_any = any; }

                                        t
                                    })
                                }).collect();

                                tvec.map(|tvec| (Tup(tvec), has_any))
                            }
                            else { None }
                        } else {
                            None
                        }
                    }

                    ref t =>
                    {
                        if t == type2 { Some((t.clone(), false)) }
                        else { None }
                    }
                }
            }
        }
        /// Two types are considered equal if one of them is Any or they have the same variant.
        impl PartialEq for Type 
        {
            fn eq(&self, other: &Self) -> bool
            {
                use self::Type::*;
                
                if let Any = *other
                {
                    return true;
                }

                match *self
                {
                    Any => true,

                    Arr(ref box1) =>
                    {
                        if let Arr(ref box2) = *other { box1 == box2 }
                        else { false }
                    }
                    
                    Tup(ref tvec1) =>
                    {
                        if let Tup(ref tvec2) = *other { tvec1 == tvec2 }
                        else { false }
                    }

                    _ => self.is(other),
                }
            }
        }

        impl Eq for Type {}

        impl fmt::Display for Type 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                use self::Type::*;

                match *self
                {
                    Any => write!(f, "Any"),
                    Null => write!(f, "Null"),
                    True => write!(f, "True"),
                    Bool => write!(f, "Bool"),
                    Int => write!(f, "Int"),
                    Frac => write!(f, "Frac"),
                    Char => write!(f, "Char"),
                    Str => write!(f, "Str"),
                    Arr(ref boxxy) => write!(f, "Arr({})", boxxy),
                    Tup(ref tvec) => write!
                    (
                        f,
                        "Tup({})",
                        match tvec.get(0) 
                        {
                            Some(t1) => tvec
                            .iter()
                            .skip(1)
                            .fold(format!("{}", t1), |s, t| format!("{}, {}", s, t)),
                            None => format!(""),
                        }
                    ),
                    Obj => write!(f, "Obj"),
                    Number => write!(f, "Number"),
                    String => write!(f, "String"),
                }
            }
        }
    } pub use self::types::{ * };

    pub mod values
    {
        //! Module for values
        use ::
        {
            database::
            {
                arrays,
                error::OverError,
                objects,
                parses::{ format::Format },
                tuples,
                types::Type,
                OverResult, INDENT_STEP,
            },
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ ToPrimitive },
            },
            *,
        };

        macro_rules! get_fn 
        {
            ( $doc:expr, $name:tt, $type:ty, $variant:ident ) => {
                #[doc=$doc]
                pub fn $name(&self) -> OverResult<$type> {
                    if let Value::$variant(ref inner) = *self {
                        Ok(inner.clone())
                    } else {
                        Err(OverError::TypeMismatch(Type::$variant, self.get_type()))
                    }
                }
            }
        }

        macro_rules! impl_from 
        {
            ($type:ty, $fn:tt) => {
                impl From<$type> for Value {
                    fn from(inner: $type) -> Self {
                        Value::$fn(inner.into())
                    }
                }
            };
        }

        macro_rules! impl_eq 
        {
            ($valtype:ident, $type:ty) => 
            {
                impl PartialEq<$type> for Value 
                {
                    fn eq(&self, other: &$type) -> bool {
                        match *self {
                            Value::$valtype(ref value) => value == other,
                            _ => false,
                        }
                    }
                }

                impl PartialEq<Value> for $type
                {
                    fn eq(&self, other: &Value) -> bool {
                        match *other {
                            Value::$valtype(ref value) => value == self,
                            _ => false,
                        }
                    }
                }
            };
        }

        macro_rules! impl_eq_int 
        {
            ($type:ty, $fn:tt) => {
                impl PartialEq<$type> for Value {
                    fn eq(&self, other: &$type) -> bool {
                        match *self {
                            Value::Int(ref value) => match value.$fn() {
                                Some(value) => value == *other,
                                None => false,
                            },
                            _ => false,
                        }
                    }
                }

                impl PartialEq<Value> for $type {
                    fn eq(&self, other: &Value) -> bool {
                        match *other {
                            Value::Int(ref value) => match value.$fn() {
                                Some(value) => value == *self,
                                None => false,
                            },
                            _ => false,
                        }
                    }
                }
            };
        }

        macro_rules! from_type_marker_to_value 
        {
            (number $ty:ty) => 
            {
                impl From<$ty> for Value 
                {
                    fn from(value: $ty) -> Self {
                        Value::Number(value as i32)
                    }
                }
            };

            (string ref $ty:ty) => 
            {
                impl<'a> From<&'a $ty> for Value 
                {
                    fn from(value: &'a $ty) -> Self {
                        Value::String(value.into())
                    }
                }
            };

            (string $ty:ty) => 
            {
                impl From<$ty> for Value 
                {
                    fn from(value: $ty) -> Self {
                        Value::String(value.into())
                    }
                }
            };
        }
        /// Enum of possible values and their inner types.
        #[derive(Clone, Debug, PartialEq)]
        pub enum Value
        {
            /// A null value.
            Null,
            // Copy values.
            /// A boolean value.
            Bool(bool),
            /// A signed integer value.
            Int(BigInt),
            /// A fractional value.
            Frac(BigRational),
            /// A character value.
            Char(char),
            /// A string value.
            Str(String),
            // Reference values.
            /// An array value.
            Arr(arrays::Arr),
            /// A tuple value.
            Tup(tuples::Tup),
            /// An object value.
            Obj(objects::Obj),
            /// A Capability Boolean.
            True,
            /// A Capability  number.
            Number(i32),
            /// A Capability string requiring expansion.
	        String(Vec<u8>),
        }

        impl Value 
        {
            /// Returns true if this `Value` is null.
            pub fn is_null(&self) -> bool
            {
                if let Value::Null = *self { true }
                else { false }
            }
            /// Returns the `Type` of this `Value`.
            pub fn get_type(&self) -> Type
            {
                use self::Value::*;

                match *self
                {
                    Null => Type::Null,
                    True => Type::True,
                    Bool(_) => Type::Bool,
                    Int(_) => Type::Int,
                    Frac(_) => Type::Frac,
                    Char(_) => Type::Char,
                    Str(_) => Type::Str,
                    Arr(ref arr) => Type::Arr(Box::new(arr.inner_type())),
                    Tup(ref tup) => Type::Tup(tup.inner_type_vec()),
                    Obj(_) => Type::Obj,
                    Number( _ ) => Type::Number,
                    String( _ ) => Type::String,
                }
            }

            get_fn!
            (
                "Returns the `bool` contained in this `Value`. \
                Returns an error if this `Value` is not `Bool`.",
                get_bool,
                bool,
                Bool
            );

            get_fn!
            (
                "Returns the `BigInt` contained in this `Value`. \
                Returns an error if this `Value` is not `Int`.",
                get_int,
                BigInt,
                Int
            );
            /// Returns the `BigRational` contained in this `Value`.
            pub fn get_frac(&self) -> OverResult<BigRational>
            {
                match *self
                {
                    Value::Frac(ref inner) => Ok(inner.clone()),
                    Value::Int(ref inner) => Ok(frac!(inner.clone(), 1)),
                    _ => Err(OverError::TypeMismatch(Type::Frac, self.get_type())),
                }
            }

            get_fn!
            (
                "Returns the `char` contained in this `Value`.",
                get_char,
                char,
                Char
            );

            get_fn!
            (
                "Returns the `String` contained in this `Value`.",
                get_str,
                String,
                Str
            );

            get_fn!
            (
                "Returns the `Obj` contained in this `Value`.",
                get_obj,
                objects::Obj,
                Obj
            );
            /// Returns the `Arr` contained in this `Value`.
            pub fn get_arr(&self) -> OverResult<arrays::Arr>
            {
                if let Value::Arr(ref inner) = *self { Ok(inner.clone()) }
                
                else
                {
                    Err(OverError::TypeMismatch
                    (
                        Type::Arr(Box::new(Type::Any)),
                        self.get_type(),
                    ))
                }
            }
            /// Returns the `Tup` contained in this `Value`.
            pub fn get_tup(&self) -> OverResult<tuples::Tup>
            {
                if let Value::Tup(ref inner) = *self
                {
                    Ok(inner.clone())
                }

                else
                {
                    Err(OverError::TypeMismatch(Type::Tup(vec![]), self.get_type()))
                }
            }
        }

        impl fmt::Display for Value
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, "{}", self.format(true, INDENT_STEP)) }
        }

        impl<'a> PartialEq<&'a str> for Value 
        {
            fn eq(&self, other: &&str) -> bool
            {
                match *self
                {
                    Value::Str(ref value) => value == &other.replace("\r\n", "\n"),
                    _ => false,
                }
            }
        }

        impl<'a> PartialEq<Value> for &'a str 
        {
            fn eq(&self, other: &Value) -> bool
            {
                match *other
                {
                    Value::Str(ref value) => value == &self.replace("\r\n", "\n"),
                    _ => false,
                }
            }
        }

        impl PartialEq<String> for Value 
        {
            fn eq(&self, other: &String) -> bool
            {
                &other.as_str() == self
            }
        }

        impl PartialEq<Value> for String
        {
            fn eq(&self, other: &Value) -> bool
            {
                &self.as_str() == other
            }
        }

        impl<'a> From<&'a str> for Value
        {
            fn from(inner: &str) -> Self
            {
                Value::Str(inner.into())
            }
        }

        impl From<()> for Value
        {
            fn from(_: ()) -> Self { Value::True }
        }
        
        impl_eq!(Bool, bool);
        impl_eq!(Int, BigInt);
        impl_eq!(Frac, BigRational);
        impl_eq!(Char, char);
        impl_eq!(Arr, arrays::Arr);
        impl_eq!(Tup, tuples::Tup);
        impl_eq!(Obj, objects::Obj);
        
        impl_eq_int!(usize, to_usize);
        impl_eq_int!(u8, to_u8);
        impl_eq_int!(u16, to_u16);
        impl_eq_int!(u32, to_u32);
        impl_eq_int!(u64, to_u64);
        impl_eq_int!(i8, to_i8);
        impl_eq_int!(i16, to_i16);
        impl_eq_int!(i32, to_i32);
        impl_eq_int!(i64, to_i64);
        
        impl_from!(bool, Bool);
        impl_from!(usize, Int);
        impl_from!(u8, Int);
        impl_from!(u16, Int);
        impl_from!(u32, Int);
        impl_from!(u64, Int);
        impl_from!(i8, Int);
        impl_from!(i16, Int);
        impl_from!(i32, Int);
        impl_from!(i64, Int);
        impl_from!(BigInt, Int);    
        impl_from!(BigRational, Frac);
        impl_from!(char, Char);
        impl_from!(String, Str);
        impl_from!(arrays::Arr, Arr);
        impl_from!(tuples::Tup, Tup);
        impl_from!(objects::Obj, Obj);
        /*
        from_type_marker_to_value!(number u8);
        from_type_marker_to_value!(number i8);
        from_type_marker_to_value!(number u16);
        from_type_marker_to_value!(number i16);
        from_type_marker_to_value!(number u32);
        from_type_marker_to_value!(number i32);
        from_type_marker_to_value!(string String);
        from_type_marker_to_value!(string ref str);
        from_type_marker_to_value!(string Vec<u8>);
        from_type_marker_to_value!(string ref [u8]); */
    } pub use self::values::{ * };

    pub mod parses
    {
        //! Functions for loading/writing Objs.
        use ::
        {
            *,
        }; use super::Obj;

        pub const MAX_DEPTH: usize = 64;

        pub type ParseResult<T> = Result<T, ParseError>;
        
        pub mod error
        {
            //! Module for parse errors.
            use ::
            {
                database::
                {
                    types::{ Type },
                    OverError,
                },
                error::{ Error },
                num::
                {
                    big::{ BigInt, ParseBigIntError },
                    ParseIntError,
                },
                *,
            };
            
            use super::
            {
                ParseResult,
                MAX_DEPTH,
            };

            pub fn parse_err<T>(file: Option<String>, kind: ParseErrorKind) -> ParseResult<T>
            { Err(ParseError { file, kind }) }
            /// Error kind.
            #[derive( Debug )]
            pub enum ParseErrorKind
            {
                BinaryOperatorError(Type, Type, char, usize, usize),
                CyclicInclude(String, usize, usize),
                DuplicateField(String, usize, usize),
                DuplicateGlobal(String, usize, usize),
                ExpectedType(Type, Type, usize, usize),
                GlobalNotFound(String, usize, usize),
                InvalidIndex(BigInt, usize, usize),
                InvalidClosingBracket(Option<char>, char, usize, usize),
                InvalidDot(Type, usize, usize),
                InvalidEscapeChar(char, usize, usize),
                InvalidFieldChar(char, usize, usize),
                InvalidFieldName(String, usize, usize),
                InvalidIncludeChar(char, usize, usize),
                InvalidIncludePath(String, usize, usize),
                InvalidIncludeToken(Type, usize, usize),
                InvalidNumeric(usize, usize),
                InvalidValue(String, usize, usize),
                InvalidValueChar(char, usize, usize),
                MaxDepth(usize, usize),
                UnaryOperatorError(Type, char, usize, usize),
                UnexpectedEnd(usize),
                VariableNotFound(String, usize, usize),

                IoError(String),
                OverError(String),
                ParseIntError(String),
            }
            /// Parse error.
            #[derive( Debug )]
            pub struct ParseError
            {
                /// The file this error occurred in.
                pub file: Option<String>,
                /// Error kind.
                pub kind: ParseErrorKind,
            }

            impl fmt::Display for ParseError
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    use self::ParseErrorKind::*;

                    if let Some(ref file) = (*self).file {
                        write!(f, "{}: ", file)?;
                    }

                    match (*self).kind {
                        BinaryOperatorError(ref expected, ref found, ref op, ref line, ref col) => write!(
                            f,
                            "Could not apply operator {} on types {} and {} at line {}, column {}",
                            op, expected, found, line, col,
                        ),
                        CyclicInclude(ref file, ref line, ref col) => write!(
                            f,
                            "Tried to cyclically include file \"{}\" at line {}, column {}",
                            file, line, col
                        ),
                        DuplicateField(ref field, ref line, ref col) => write!(
                            f,
                            "Duplicate field \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        DuplicateGlobal(ref field, ref line, ref col) => write!(
                            f,
                            "Duplicate global \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        ExpectedType(ref expected, ref found, ref line, ref col) => write!(
                            f,
                            "Expected {} at line {}, column {}; found {}",
                            expected, line, col, found
                        ),
                        GlobalNotFound(ref var, ref line, ref col) => write!(
                            f,
                            "Global \"{}\" at line {}, column {} could not be found",
                            var, line, col
                        ),
                        InvalidClosingBracket(ref expected, ref found, ref line, ref col) => write!(
                            f,
                            "Invalid closing bracket '{}' at line {}, column {}; expected {}",
                            found,
                            line,
                            col,
                            match *expected {
                                Some(ch) => format!("'{}'", ch),
                                None => String::from("none"),
                            }
                        ),
                        InvalidDot(ref t, ref line, ref col) => write!(
                            f,
                            "Invalid use of dot notation on value of type {} at line {}, column {}; \
                            value must be an Obj, Arr, or Tup.",
                            t, line, col
                        ),
                        InvalidEscapeChar(ref ch, ref line, ref col) => write!(
                            f,
                            "Invalid escape character '\\{}' at line {}, column {}. \
                            If you meant to write a backslash, use '\\\\'",
                            ::char::format(*ch),
                            line,
                            col
                        ),
                        InvalidFieldChar(ref ch, ref line, ref col) => write!(
                            f,
                            "Invalid character '{}' for field at line {}, column {}",
                            ::char::format(*ch),
                            line,
                            col
                        ),
                        InvalidFieldName(ref field, ref line, ref col) => write!(
                            f,
                            "Invalid field name \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        InvalidIncludeChar(ref found, ref line, ref col) => write!(
                            f,
                            "Invalid include token character \'{}\' at line {}, column {}",
                            found, line, col
                        ),
                        InvalidIncludePath(ref path, ref line, ref col) => write!(
                            f,
                            "Invalid include path \"{}\" at line {}, column {}",
                            path, line, col
                        ),
                        InvalidIncludeToken(ref t, ref line, ref col) => write!(
                            f,
                            "Invalid value of type \"{}\" at line {}, column {}; \
                            must be either a Str value or one of the tokens \
                            \"Obj\", \"Arr\", \"Tup\", or \"Str\"",
                            t, line, col
                        ),
                        InvalidIndex(ref index, ref line, ref col) => write!(
                            f,
                            "Invalid index {} at line {}, column {}",
                            index, line, col
                        ),
                        InvalidNumeric(ref line, ref col) => {
                            write!(f, "Invalid numeric value at line {}, column {}", line, col)
                        }
                        InvalidValue(ref value, ref line, ref col) => write!(
                            f,
                            "Invalid value \"{}\" at line {}, column {}",
                            value, line, col
                        ),
                        InvalidValueChar(ref ch, ref line, ref col) => write!(
                            f,
                            "Invalid character '{}' for value at line {}, column {}",
                            ::char::format(*ch),
                            line,
                            col
                        ),
                        MaxDepth(ref line, ref col) => write!(
                            f,
                            "Exceeded maximum recursion depth ({}) at line {}, column {}",
                            MAX_DEPTH, line, col
                        ),
                        UnaryOperatorError(ref found, ref op, ref line, ref col) => write!(
                            f,
                            "Could not apply operator {} on type {} at line {}, column {}",
                            op, found, line, col,
                        ),
                        UnexpectedEnd(ref line) => write!(f, "Unexpected end at line {}", line,),
                        VariableNotFound(ref var, ref line, ref col) => write!(
                            f,
                            "Variable \"{}\" at line {}, column {} could not be found",
                            var, line, col
                        ),

                        IoError(ref error) | OverError(ref error) | ParseIntError(ref error) => {
                            write!(f, "{}", error)
                        }
                    }
                }
            }

            impl Error for ParseError
            {
                fn description(&self) -> &str
                {
                    use self::ParseErrorKind::*;

                    match (*self).kind
                    {
                        BinaryOperatorError(_, _, _, _, _) | UnaryOperatorError(_, _, _, _) =>
                        {
                            "Could not apply operator"
                        }

                        CyclicInclude(_, _, _) => "Tried to cyclically include file",
                        DuplicateField(_, _, _) => "Duplicate field",
                        DuplicateGlobal(_, _, _) => "Duplicate global",
                        ExpectedType(_, _, _, _) => "Expected different type",
                        GlobalNotFound(_, _, _) => "Global could not be found",
                        InvalidClosingBracket(_, _, _, _) => "Invalid closing bracket",
                        InvalidDot(_, _, _) => "Invalid use of dot notation",
                        InvalidEscapeChar(_, _, _) => "Invalid escape character",
                        InvalidFieldChar(_, _, _) => "Invalid character for field",
                        InvalidFieldName(_, _, _) => "Invalid field name",
                        InvalidIncludeChar(_, _, _) => "Invalid include character",
                        InvalidIncludePath(_, _, _) => "Invalid include path",
                        InvalidIncludeToken(_, _, _) => "Invalid include token",
                        InvalidIndex(_, _, _) => "Invalid index",
                        InvalidNumeric(_, _) => "Invalid numeric value",
                        InvalidValue(_, _, _) => "Invalid value",
                        InvalidValueChar(_, _, _) => "Invalid character for value",
                        MaxDepth(_, _) => "Exceeded maximum depth for a container",
                        UnexpectedEnd(_) => "Unexpected end when reading value",
                        VariableNotFound(_, _, _) => "Variable could not be found",

                        IoError(ref error) | OverError(ref error) | ParseIntError(ref error) => error,
                    }
                }
            }

            impl ParseError
            {
                /// Convert an `OverError` to a `ParseError` given line and column numbers.
                pub fn from_over(e: &OverError, file: Option<String>, line: usize, col: usize) -> Self
                {
                    ParseError
                    {
                        file,
                        kind: ParseErrorKind::OverError(format!("{} at line {}, col {}", e, line, col)),
                    }
                }
            }

            impl From<io::Error> for ParseError
            {
                fn from(e: io::Error) -> Self
                {
                    ParseError {
                        file: None,
                        kind: ParseErrorKind::IoError(format!("{}", e)),
                    }
                }
            }

            impl From<ParseIntError> for ParseError
            {
                fn from(e: ParseIntError) -> Self
                {
                    ParseError {
                        file: None,
                        kind: ParseErrorKind::ParseIntError(format!("{}", e)),
                    }
                }
            }

            impl From<ParseBigIntError> for ParseError
            {
                fn from(e: ParseBigIntError) -> Self
                {
                    ParseError {
                        file: None,
                        kind: ParseErrorKind::ParseIntError(format!("{}", e)),
                    }
                }
            }
        } use self::error::ParseError;

        pub mod format
        {
            //! Module containing functions for formatting output of objects.
            use ::
            {
                database::{ arrays::Arr, objects::Obj, tuples::Tup, values::Value, INDENT_STEP },
                num::
                {
                    big::BigInt,
                    rational::BigRational,
                    traits::One,
                },
                *,
            };
            
            fn indent(amount: usize) -> String { " ".repeat(amount) }

            fn get_char_map(ch: char) -> Option<&'static str>
            {
                match ch
                {
                    '\\' => Some("\\\\"),
                    '\"' => Some("\\\""),
                    '\'' => Some("\\\'"),
                    '$' => Some("\\$"),
                    '\n' => Some("\\n"),
                    '\r' => Some("\\r"),
                    '\t' => Some("\\t"),
                    _ => None,
                }
            }

            fn replace_all(s: &str) -> String
            {
                let mut string = String::with_capacity(s.len());

                for ch in s.chars()
                {
                    if let Some(s) = get_char_map(ch) { string.push_str(s); }
                    else { string.push(ch); }
                }

                string
            }
            /// Trait for formatting a .over representation of an object.
            pub trait Format
            {
                fn format(&self, full: bool, indent_amt: usize) -> String;
            }

            impl Format for BigRational
            {
                fn format(&self, _full: bool, _indent_amt: usize) -> String
                {
                    let frac_fmt = format!("{}", *self);

                    if *self.denom() == BigInt::one() { format!("{}.0", frac_fmt) } else { frac_fmt }
                }
            }

            impl Format for char
            {
                fn format(&self, _full: bool, _indent_amt: usize) -> String
                {
                    if let Some(s) = get_char_map(*self) { format!("\'{}\'", s) }
                    else { format!("\'{}\'", *self) }
                }
            }

            impl Format for String
            {
                fn format(&self, _full: bool, _indent_amt: usize) -> String { format!("\"{}\"", replace_all(self)) }
            }

            impl Format for Value
            {
                fn format(&self, _full: bool, indent_amt: usize) -> String
                {
                    match *self
                    {
                        Value::Null => String::from("null"),
                        Value::True => String::from("True"),
                        Value::Bool(ref inner) =>
                        {
                            if *inner { String::from("true") }
                            else { String::from("false") }
                        }
                        Value::Int(ref inner) => format!("{}", inner),
                        Value::Frac(ref inner) => inner.format(true, indent_amt),
                        Value::Char(ref inner) => inner.format(true, indent_amt),
                        Value::Str(ref inner) => inner.format(true, indent_amt),
                        Value::Arr(ref inner) => inner.format(true, indent_amt),
                        Value::Tup(ref inner) => inner.format(true, indent_amt),
                        Value::Obj(ref inner) => inner.format(true, indent_amt),
                        Value::Number(ref inner) => format!("{}", inner),
                        Value::String(ref inner) => format!("{:?}", inner),
                    }
                }
            }

            impl Format for Arr
            {
                fn format(&self, full: bool, indent_amt: usize) -> String
                {
                    match self.len()
                    {
                        0 =>
                        {
                            if full { String::from("[]") } 
                            else { String::new() }
                        }

                        1 =>
                        {
                            let f = self.get(0).unwrap().format(true, indent_amt);

                            if full { format!("[{}]", f) }
                            else { f }
                        }

                        _ =>
                        {
                            let mut s = if full { String::from("[\n") }
                            else { String::new() };

                            self.with_each(|value|
                            {
                                s.push_str(&format!
                                (
                                    "{}{}\n",
                                    indent(indent_amt),
                                    value.format(true, indent_amt + INDENT_STEP)
                                ))
                            });

                            if full
                            {
                                let actual_indent_amt = if indent_amt == 0 { 0 }
                                else { indent_amt - INDENT_STEP };

                                s.push_str(&format!("{}]", indent(actual_indent_amt)));
                            }

                            s
                        }
                    }
                }
            }

            impl Format for Tup
            {
                fn format(&self, full: bool, indent_amt: usize) -> String
                {
                    match self.len()
                    {
                        0 =>
                        {
                            if full { String::from("()") }
                            else { String::new() }
                        }

                        1 =>
                        {
                            let f = self.get(0).unwrap().format(true, indent_amt);

                            if full { format!("({})", f) }
                            else { f }
                        }

                        _ =>
                        {
                            let mut s = if full { String::from("(\n") }
                            else { String::new() };

                            self.with_each(|value|
                            {
                                s.push_str(&format!
                                (
                                    "{}{}\n",
                                    indent(indent_amt),
                                    value.format(true, indent_amt + INDENT_STEP)
                                ))
                            });

                            if full { s.push_str(&format!("{})", indent(indent_amt - INDENT_STEP))); }

                            s
                        }
                    }
                }
            }

            impl Format for Obj
            {
                fn format(&self, full: bool, indent_amt: usize) -> String
                {
                    if self.is_empty() && !self.has_parent()
                    {
                        if full { String::from("{}") } else { String::new() }
                    }
                    
                    else
                    {
                        let mut s = if full { String::from("{\n") }

                        else { String::new() };

                        if let Some(parent) = self.get_parent()
                        {
                            s.push_str(&format!
                            (
                                "{}^: {}\n",
                                indent(indent_amt),
                                parent.format(true, indent_amt + INDENT_STEP)
                            ));
                        }

                        self.with_each(|field, value|
                        {
                            s.push_str(&format!
                            (
                                "{}{}: {}\n",
                                indent(indent_amt),
                                field,
                                value.format(true, indent_amt + INDENT_STEP)
                            ));
                        });

                        if full { s.push_str(&format!("{}}}", indent(indent_amt - INDENT_STEP))); }

                        s
                    }
                }
            }
        }

        pub mod parser
        {
            //! Module containing parsing functions.
            use ::
            {
                char::{ CharStream },
                collections::{ HashMap, HashSet, VecDeque },
                database::
                {
                    arrays::{self, Arr},
                    objects::Obj,
                    tuples::Tup,
                    types::Type,
                    values::Value,
                },
                num::
                {
                    big::{ BigInt },
                    rational::{ BigRational },
                    fractional::{ frac_from_whole_and_dec },
                    traits::{ ToPrimitive, Zero },
                },
                ops::{ Deref },
                path::{ Path },
                *,
            };

            use super::
            {
                error::ParseErrorKind::*,
                error::{parse_err, ParseError},
                ParseResult, MAX_DEPTH,
            };
            
            type ObjMap = HashMap<String, Value>;
            type GlobalMap = HashMap<String, Value>;
            type IncludedMap = (HashMap<String, Value>, HashSet<String>);

            lazy_static!
            {
                static ref OBJ_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
                static ref STR_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
                static ref ARR_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
                static ref TUP_SENTINEL: Obj = Obj::from_map_unchecked(HashMap::new());
            }
            /// Parses given file as an `Obj`.
            pub fn parse_obj_file(path: &str) -> ParseResult<Obj> 
            {
                let stream = CharStream::from_file(path)?;
                parse_obj_stream(stream, &mut (HashMap::new(), HashSet::new()))
            }
            /// Parses given file as an `Obj`, keeping track of already encountered includes.
            pub fn parse_obj_file_includes(path: &str, included: &mut IncludedMap) -> ParseResult<Obj> 
            {
                let stream = CharStream::from_file(path)?;
                parse_obj_stream(stream, included)
            }
            /// Parses given &str as an `Obj`.
            pub fn parse_obj_str(contents: &str) -> ParseResult<Obj> 
            {
                let contents = String::from(contents);
                let stream = CharStream::from_string(contents)?;
                parse_obj_stream(stream, &mut (HashMap::new(), HashSet::new()))
            }
            /// Parses an Obj given a character stream.
            #[inline] fn parse_obj_stream(mut stream: CharStream, mut included: &mut IncludedMap) -> ParseResult<Obj> 
            {
                let mut obj: ObjMap = HashMap::new();
                
                if !find_char(stream.clone()) 
                {
                    return Ok(Obj::from_map_unchecked(obj));
                }

                let mut globals: GlobalMap = HashMap::new();
                let mut parent = None;
                
                while parse_field_value_pair
                (
                    &mut stream,
                    &mut obj,
                    &mut globals,
                    &mut included,
                    &mut parent,
                    1,
                    None,
                )? {}

                Ok(match parent 
                {
                    Some(parent) => Obj::from_map_with_parent_unchecked(obj, parent),
                    None => Obj::from_map_unchecked(obj),
                })
            }
            /// Parses a sub-Obj in a file. It *must* start with { and end with }.
            pub fn parse_obj
            (
                mut stream: &mut CharStream,
                globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value> 
            {
                if depth > MAX_DEPTH 
                {
                    return parse_err(stream.file(), MaxDepth(stream.line(), stream.col()));
                }
                
                let ch = stream.next().unwrap();
                assert_eq!(ch, '{');
                
                if !find_char(stream.clone()) 
                {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                let mut obj: ObjMap = HashMap::new();
                let mut parent = None;
                
                while parse_field_value_pair
                (
                    &mut stream,
                    &mut obj,
                    globals,
                    &mut included,
                    &mut parent,
                    depth,
                    Some('}'),
                )? {}

                let obj = match parent 
                {
                    Some(parent) => Obj::from_map_with_parent_unchecked(obj, parent),
                    None => Obj::from_map_unchecked(obj),
                };
                Ok(obj.into())
            }
            /// Parses a field/value pair.
            #[inline] pub fn parse_field_value_pair
            (
                mut stream: &mut CharStream,
                obj: &mut ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                parent: &mut Option<Obj>,
                depth: usize,
                cur_brace: Option<char>,
            ) -> ParseResult<bool>
            {
                let peek = stream.peek().unwrap();
                if peek == '}' && cur_brace.is_some() 
                {
                    let _ = stream.next();
                    return Ok(false);
                } else if is::end_delimiter(peek) 
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidClosingBracket(cur_brace, peek, stream.line(), stream.col()),
                    );
                }
                
                let (field_line, field_col) = (stream.line(), stream.col());
                let (field, is_global, is_parent) = parse_field(stream.clone(), field_line, field_col)?;

                if !is_global && !is_parent && obj.contains_key(&field) 
                {
                    return parse_err(stream.file(), DuplicateField(field, field_line, field_col));
                } 
                
                else if is_parent && parent.is_some() 
                {
                    return parse_err(
                        stream.file(),
                        DuplicateField("^".into(), field_line, field_col),
                    );
                }
                
                if !find_char(stream.clone()) 
                {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }
                
                let (value_line, value_col) = (stream.line(), stream.col());
                let value = parse_value
                (
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    value_line,
                    value_col,
                    depth,
                    cur_brace,
                    true,
                )?;
                
                if is_global 
                {
                    if globals.contains_key(&field) 
                    {
                        return parse_err(stream.file(), DuplicateGlobal(field, field_line, field_col));
                    }
                    globals.insert(field, value);
                } else if is_parent 
                {
                    let par = value
                        .get_obj()
                        .map_err(|e| ParseError::from_over(&e, stream.file(), value_line, value_col))?;
                    *parent = Some(par);
                } else 
                {
                    obj.insert(field, value);
                }
                
                if !find_char(stream.clone()) 
                {
                    match cur_brace 
                    {
                        Some(_) => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                        None => return Ok(false),
                    }
                }

                Ok(true)
            }
            /// Parses an Arr given a file.
            fn parse_arr_file(path: &str, mut included: &mut IncludedMap) -> ParseResult<Arr> 
            {
                let mut stream = CharStream::from_file(path)?;

                let obj: ObjMap = HashMap::new();
                let mut globals: GlobalMap = HashMap::new();

                let mut vec = Vec::new();
                let mut tcur = Type::Any;
                let mut has_any = true;

                loop 
                {
                    if !find_char(stream.clone()) 
                    {
                        break;
                    }
                    
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value
                    (
                        &mut stream,
                        &obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        1,
                        None,
                        true,
                    )?;

                    let tnew = value.get_type();

                    if has_any 
                    {
                        match Type::most_specific(&tcur, &tnew) 
                        {
                            Some((t, any)) => 
                            {
                                tcur = t;
                                has_any = any;
                            }
                            None => 
                            {
                                return parse_err
                                (
                                    stream.file(),
                                    ExpectedType(tcur, tnew, value_line, value_col),
                                );
                            }
                        }
                    } else if tcur != tnew 
                    {
                        return parse_err
                        (
                            stream.file(),
                            ExpectedType(tcur, tnew, value_line, value_col),
                        );
                    }

                    vec.push(value);
                }

                let arr = Arr::from_vec_unchecked(vec, tcur);

                Ok(arr)
            }
            /// Parses a sub-Arr in a file. It *must* start with [ and end with ].
            pub fn parse_arr
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value>
            {
                if depth > MAX_DEPTH {
                    return parse_err(stream.file(), MaxDepth(stream.line(), stream.col()));
                }
                
                let ch = stream.next().unwrap();
                assert_eq!(ch, '[');

                let mut vec = Vec::new();
                let mut tcur = Type::Any;
                let mut has_any = true;

                loop {
                    if !find_char(stream.clone()) {
                        return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                    }

                    let peek = stream.peek().unwrap();
                    if peek == ']' {
                        let _ = stream.next();
                        break;
                    } else if is::end_delimiter(peek) {
                        return parse_err(
                            stream.file(),
                            InvalidClosingBracket(Some(']'), peek, stream.line(), stream.col()),
                        );
                    }
                    
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value(
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        depth,
                        Some(']'),
                        true,
                    )?;

                    let tnew = value.get_type();

                    if has_any {
                        match Type::most_specific(&tcur, &tnew) {
                            Some((t, any)) => {
                                tcur = t;
                                has_any = any;
                            }
                            None => {
                                return parse_err(
                                    stream.file(),
                                    ExpectedType(tcur, tnew, value_line, value_col),
                                );
                            }
                        }
                    } else if tcur != tnew {
                        return parse_err(
                            stream.file(),
                            ExpectedType(tcur, tnew, value_line, value_col),
                        );
                    }

                    vec.push(value);
                }

                let arr = Arr::from_vec_unchecked(vec, tcur);

                Ok(arr.into())
            }
            /// Parses a Tup given a file.
            pub fn parse_tup_file(path: &str, mut included: &mut IncludedMap) -> ParseResult<Tup>
            {
                let mut stream = CharStream::from_file(path)?;

                let mut vec: Vec<Value> = Vec::new();
                let obj: ObjMap = HashMap::new();
                let mut globals: GlobalMap = HashMap::new();

                loop {
                    if !find_char(stream.clone()) {
                        break;
                    }

                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value(
                        &mut stream,
                        &obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        1,
                        None,
                        true,
                    )?;

                    vec.push(value);
                }

                Ok(vec.into())
            }
            /// Parses a sub-Tup in a file. It *must* start with ( and end with ).
            pub fn parse_tup
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value>
            {
                if depth > MAX_DEPTH { return parse_err(stream.file(), MaxDepth(stream.line(), stream.col())); }
                let mut vec = Vec::new();
                let ch = stream.next().unwrap();
                assert_eq!(ch, '(');
                
                loop 
                {
                    if !find_char(stream.clone()) { return parse_err(stream.file(), UnexpectedEnd(stream.line())); }

                    let peek = stream.peek().unwrap();

                    if peek == ')' 
                    {
                        let _ = stream.next();
                        break;
                    } 
                    else if is::end_delimiter(peek) 
                    {
                        return parse_err
                        (
                            stream.file(),
                            InvalidClosingBracket(Some(')'), peek, stream.line(), stream.col()),
                        );
                    }
                    
                    let (value_line, value_col) = (stream.line(), stream.col());
                    let value = parse_value
                    (
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        value_line,
                        value_col,
                        depth,
                        Some(')'),
                        true,
                    )?;

                    vec.push(value);
                }

                let tup = Tup::from_vec(vec);

                Ok(tup.into())
            }
            /// Gets the next field in the char stream.
            pub fn parse_field
            (
                mut stream: CharStream,
                line: usize,
                col: usize,
            ) -> ParseResult<(String, bool, bool)>
            {
                let mut field = String::new();
                let mut first = true;
                let mut is_global = false;

                let ch = stream.peek().unwrap();
                if ch == '@' {
                    let ch = stream.next().unwrap();
                    is_global = true;
                    field.push(ch);
                }

                while let Some(ch) = stream.next() {
                    match ch {
                        ':' if !first => {
                            break;
                        }
                        ch if Obj::is_valid_field_char(ch, first) => field.push(ch),
                        ch => {
                            return parse_err(
                                stream.file(),
                                InvalidFieldChar(ch, stream.line(), stream.col() - 1),
                            );
                        }
                    }

                    first = false;
                }
                
                match field.as_str() {
                    _field_str if is::reserved(_field_str) => {
                        parse_err(stream.file(), InvalidFieldName(field.clone(), line, col))
                    }
                    "^" => Ok((field.clone(), false, true)),
                    bad if bad.starts_with('^') => {
                        parse_err(stream.file(), InvalidFieldName(field.clone(), line, col))
                    }
                    _ => Ok((field.clone(), is_global, false)),
                }
            }
            /// Gets the next value in the char stream.
            pub fn parse_value
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                line: usize,
                col: usize,
                depth: usize,
                cur_brace: Option<char>,
                is_first: bool,
            ) -> ParseResult<Value>
            {
                let res = match stream.peek().unwrap() {
                    '"' => parse_str(&mut stream)?,
                    '\'' => parse_char(&mut stream)?,
                    '{' => parse_obj(&mut stream, &mut globals, included, depth + 1)?,
                    '[' => parse_arr(&mut stream, obj, &mut globals, included, depth + 1)?,
                    '(' => parse_tup(&mut stream, obj, &mut globals, included, depth + 1)?,
                    '@' => parse_variable(
                        &mut stream,
                        obj,
                        globals,
                        included,
                        line,
                        col,
                        depth,
                        cur_brace,
                    )?,
                    '<' => parse_include(&mut stream, obj, &mut globals, &mut included, depth + 1)?,
                    ch @ '+' | ch @ '-' => {
                        parse_unary_op(&mut stream, obj, globals, included, depth, cur_brace, ch)?
                    }
                    ch if is::numeric_char(ch) => parse_numeric(&mut stream, line, col)?,
                    ch if Obj::is_valid_field_char(ch, true) => parse_variable(
                        &mut stream,
                        obj,
                        globals,
                        included,
                        line,
                        col,
                        depth,
                        cur_brace,
                    )?,
                    ch => {
                        return parse_err(stream.file(), InvalidValueChar(ch, line, col));
                    }
                };
                
                if is_first {
                    let mut val_deque: VecDeque<(Value, usize, usize)> = VecDeque::new();
                    let mut op_deque: VecDeque<char> = VecDeque::new();
                    val_deque.push_back((res, line, col));

                    loop {
                        match stream.peek() {
                            Some(ch) if is::operator(ch) => {
                                let _ = stream.next();
                                if stream.peek().is_none() {
                                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                                }

                                let (line2, col2) = (stream.line(), stream.col());
                                let val2 = parse_value(
                                    &mut stream,
                                    obj,
                                    &mut globals,
                                    &mut included,
                                    line2,
                                    col2,
                                    depth,
                                    cur_brace,
                                    false,
                                )?;

                                if is::priority_operator(ch) {
                                    let (val1, line1, col1) = val_deque.pop_back().unwrap();
                                    let res = binary_op_on_values(stream, val1, val2, ch, line2, col2)?;
                                    val_deque.push_back((res, line1, col1));
                                } else {
                                    val_deque.push_back((val2, line2, col2));
                                    op_deque.push_back(ch);
                                }
                            }
                            _ => break,
                        }
                    }
                    
                    check_value_end(stream, cur_brace)?;

                    let (mut val1, _, _) = val_deque.pop_front().unwrap();
                    while !op_deque.is_empty() 
                    {
                        let (val2, line2, col2) = val_deque.pop_front().unwrap();
                        val1 = binary_op_on_values(
                            stream,
                            val1,
                            val2,
                            op_deque.pop_front().unwrap(),
                            line2,
                            col2,
                        )?;
                    }
                    Ok(val1)
                } else {
                    Ok(res)
                }
            }

            fn parse_unary_op
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
                cur_brace: Option<char>,
                ch: char,
            ) -> ParseResult<Value>
            {
                let _ = stream.next();
                let line = stream.line();
                let col = stream.col();

                let res = match stream.peek() {
                    Some(_) => parse_value(
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                        false,
                    )?,
                    None => return parse_err(stream.file(), UnexpectedEnd(line)),
                };
                unary_op_on_value(stream, res, ch, line, col)
            }
            /// Gets the next numeric (either Int or Frac) in the character stream.
            fn parse_numeric(stream: &mut CharStream, line: usize, col: usize) -> ParseResult<Value>
            {
                let mut s1 = String::new();
                let mut s2 = String::new();
                let mut dec = false;
                let mut under = false;

                while let Some(ch) = stream.peek() {
                    match ch {
                        ch if is::value_end_char(ch) => break,
                        ch if is::char_digit(ch) => {
                            if !dec {
                                s1.push(ch);
                            } else {
                                s2.push(ch);
                            }
                        }
                        '.' | ',' => {
                            if !dec {
                                dec = true;
                            } else {
                                return parse_err(
                                    stream.file(),
                                    InvalidValueChar(ch, stream.line(), stream.col()),
                                );
                            }
                        }
                        '_' => {
                            if !under {
                                under = true;
                            } else {
                                return parse_err(
                                    stream.file(),
                                    InvalidValueChar(ch, stream.line(), stream.col()),
                                );
                            }
                        }
                        _ => {
                            return parse_err(
                                stream.file(),
                                InvalidValueChar(ch, stream.line(), stream.col()),
                            );
                        }
                    }

                    if ch != '_' {
                        under = false;
                    }

                    let _ = stream.next();
                }

                if dec {
                    if s1.is_empty() && s2.is_empty() {
                        return parse_err(stream.file(), InvalidNumeric(line, col));
                    }

                    let whole: BigInt = if s1.is_empty() {
                        0u8.into()
                    } else {
                        s1.parse()?
                    };
                    
                    let s2 = s2.trim_end_matches('0');

                    let (decimal, dec_len): (BigInt, usize) = if s2.is_empty() {
                        (0u8.into(), 1)
                    } else {
                        (s2.parse()?, s2.len())
                    };

                    let f = frac_from_whole_and_dec(whole, decimal, dec_len);
                    Ok(f.into())
                } else {
                    if s1.is_empty() {
                        return parse_err(stream.file(), InvalidNumeric(line, col));
                    }

                    let i: BigInt = s1.parse()?;
                    Ok(i.into())
                }
            }
            /// Parses a variable name and gets a value from the corresponding variable.
            fn parse_variable
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                line: usize,
                col: usize,
                depth: usize,
                cur_brace: Option<char>,
            ) -> ParseResult<Value>
            {
                let mut var = String::new();
                let mut is_global = false;
                let mut dot = false;
                let mut dot_global = false;

                let ch = stream.peek().unwrap();
                if ch == '@' {
                    let ch = stream.next().unwrap();
                    is_global = true;
                    var.push(ch);
                }

                while let Some(ch) = stream.peek() {
                    match ch {
                        '.' => {
                            let _ = stream.next();
                            match stream.peek() {
                                Some('@') => dot_global = true,
                                Some(ch) if Obj::is_valid_field_char(ch, true) || is::numeric_char(ch) => (),
                                Some(ch) => {
                                    return parse_err(
                                        stream.file(),
                                        InvalidValueChar(ch, stream.line(), stream.col()),
                                    );
                                }
                                None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                            }

                            dot = true;
                            break;
                        }
                        ch if is::value_end_char(ch) => break,
                        ch if Obj::is_valid_field_char(ch, false) => {
                            let _ = stream.next();
                            var.push(ch);
                        }
                        ch => {
                            return parse_err(
                                stream.file(),
                                InvalidValueChar(ch, stream.line(), stream.col()),
                            );
                        }
                    }
                }

                let mut value = match var.as_str() {
                    "null" => Value::Null,
                    "true" => Value::Bool(true),
                    "false" => Value::Bool(false),

                    "Obj" => Value::Obj(OBJ_SENTINEL.clone()),
                    "Str" => Value::Obj(STR_SENTINEL.clone()),
                    "Arr" => Value::Obj(ARR_SENTINEL.clone()),
                    "Tup" => Value::Obj(TUP_SENTINEL.clone()),

                    var @ "@" => return parse_err(stream.file(), InvalidValue(var.into(), line, col)),
                    var if is_global => {
                        match globals.get(var) {
                            Some(value) => value.clone(),
                            None => {
                                let var = String::from(var);
                                return parse_err(stream.file(), GlobalNotFound(var, line, col));
                            }
                        }
                    }
                    var => {
                        match obj.get(var) {
                            Some(value) => value.clone(),
                            None => {
                                let var = String::from(var);
                                return parse_err(stream.file(), VariableNotFound(var, line, col));
                            }
                        }
                    }
                };

                if dot {
                    value = match value {
                        Value::Arr(arr) => {
                            let (line, col) = (stream.line(), stream.col());
                            let value = parse_value(
                                &mut stream,
                                obj,
                                &mut globals,
                                &mut included,
                                line,
                                col,
                                depth + 1,
                                cur_brace,
                                false,
                            )?;

                            match value {
                                Value::Int(int) => match int.to_usize() {
                                    Some(index) => arr
                                        .get(index)
                                        .map_err(|e| ParseError::from_over(&e, stream.file(), line, col))?,
                                    None => return parse_err(stream.file(), InvalidIndex(int, line, col)),
                                },
                                _ => {
                                    return parse_err(
                                        stream.file(),
                                        ExpectedType(Type::Int, value.get_type(), line, col),
                                    );
                                }
                            }
                        }
                        Value::Tup(tup) => {
                            let (line, col) = (stream.line(), stream.col());
                            let value = parse_value(
                                &mut stream,
                                obj,
                                &mut globals,
                                &mut included,
                                line,
                                col,
                                depth + 1,
                                cur_brace,
                                false,
                            )?;

                            match value {
                                Value::Int(int) => match int.to_usize() {
                                    Some(index) => tup
                                        .get(index)
                                        .map_err(|e| ParseError::from_over(&e, stream.file(), line, col))?,
                                    None => return parse_err(stream.file(), InvalidIndex(int, line, col)),
                                },
                                _ => {
                                    return parse_err(
                                        stream.file(),
                                        ExpectedType(Type::Int, value.get_type(), line, col),
                                    );
                                }
                            }
                        }
                        Value::Obj(obj) => {
                            let (line, col) = (stream.line(), stream.col());

                            if dot_global {
                                return parse_err(stream.file(), InvalidValueChar('@', line, col));
                            }

                            parse_variable(
                                &mut stream,
                                obj.map_ref(),
                                globals,
                                included,
                                line,
                                col,
                                depth + 1,
                                cur_brace,
                            )?
                        }
                        _ => return parse_err(stream.file(), InvalidDot(value.get_type(), line, col)),
                    }
                }

                Ok(value)
            }
            /// Gets the next Char in the character stream.
            pub fn parse_char(stream: &mut CharStream) -> ParseResult<Value>
            {
                let ch = stream.next().unwrap();
                assert_eq!(ch, '\'');

                let (escape, mut ch) = match stream.next() {
                    Some('\\') => (true, '\0'),
                    Some(ch) if ch == '\n' || ch == '\r' || ch == '\t' => {
                        return parse_err(
                            stream.file(),
                            InvalidValueChar(ch, stream.line(), stream.col() - 1),
                        );
                    }
                    Some(ch) => (false, ch),
                    None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                };

                if escape {
                    ch = match stream.next() {
                        Some(ch) => match char::get_escape(ch) {
                            Some(ch) => ch,
                            None => {
                                return parse_err(
                                    stream.file(),
                                    InvalidEscapeChar(ch, stream.line(), stream.col() - 1),
                                );
                            }
                        },
                        None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                    }
                }

                match stream.next() {
                    Some('\'') => (),
                    Some(ch) => {
                        return parse_err(
                            stream.file(),
                            InvalidValueChar(ch, stream.line(), stream.col() - 1),
                        );
                    }
                    None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                }

                Ok(ch.into())
            }

            fn parse_str_file(path: &str) -> ParseResult<String>
            {
                let s = str::read_file(path)?.replace("\r\n", "\n");
                Ok(s)
            }
            /// Gets the next Str in the character stream.
            pub fn parse_str(stream: &mut CharStream) -> ParseResult<Value>
            {
                let ch = stream.next().unwrap();
                assert_eq!(ch, '"');

                let mut s = String::new();
                let mut escape = false;

                loop {
                    match stream.next() {
                        Some(ch) => {
                            if escape {
                                match char::get_escape(ch) {
                                    Some(ch) => s.push(ch),
                                    None => {
                                        return parse_err(
                                            stream.file(),
                                            InvalidEscapeChar(ch, stream.line(), stream.col() - 1),
                                        );
                                    }
                                }
                                escape = false;
                            } else {
                                match ch {
                                    '"' => break,
                                    '\\' => escape = true,
                                    _ => s.push(ch),
                                }
                            }
                        }
                        None => return parse_err(stream.file(), UnexpectedEnd(stream.line())),
                    }
                }
                
                let s = s.replace("\r\n", "\n");

                Ok(s.into())
            }

            pub fn parse_include
            (
                mut stream: &mut CharStream,
                obj: &ObjMap,
                mut globals: &mut GlobalMap,
                mut included: &mut IncludedMap,
                depth: usize,
            ) -> ParseResult<Value>
            {
                enum IncludeType {
                    Obj,
                    Str,
                    Arr,
                    Tup,
                }
                
                if depth > MAX_DEPTH {
                    return parse_err(stream.file(), MaxDepth(stream.line(), stream.col()));
                }

                let ch = stream.next().unwrap();
                assert_eq!(ch, '<');
                
                if !find_char(stream.clone()) {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                let (mut line, mut col) = (stream.line(), stream.col());
                let mut value = parse_value(
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    line,
                    col,
                    depth,
                    Some('>'),
                    true,
                )?;

                let mut include_type = IncludeType::Obj;
                let mut parse_again = true;

                match value {
                    Value::Obj(ref obj) if obj.ptr_eq(&OBJ_SENTINEL) => include_type = IncludeType::Obj,
                    Value::Obj(ref obj) if obj.ptr_eq(&STR_SENTINEL) => include_type = IncludeType::Str,
                    Value::Obj(ref obj) if obj.ptr_eq(&ARR_SENTINEL) => include_type = IncludeType::Arr,
                    Value::Obj(ref obj) if obj.ptr_eq(&TUP_SENTINEL) => include_type = IncludeType::Tup,
                    Value::Str(_) => parse_again = false,
                    _ => {
                        return parse_err(
                            stream.file(),
                            InvalidIncludeToken(value.get_type(), line, col),
                        );
                    }
                }

                if parse_again {
                    if !find_char(stream.clone()) {
                        return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                    }

                    line = stream.line();
                    col = stream.col();
                    value = parse_value(
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth,
                        Some('>'),
                        true,
                    )?;
                }
                
                if !find_char(stream.clone()) {
                    return parse_err(stream.file(), UnexpectedEnd(stream.line()));
                }

                match stream.next().unwrap() {
                    '>' => (),
                    ch => {
                        return parse_err(
                            stream.file(),
                            InvalidClosingBracket(Some('>'), ch, stream.line(), stream.col() - 1),
                        );
                    }
                }
                
                let include_file = match value {
                    Value::Str(s) => s,
                    _ => {
                        return parse_err(
                            stream.file(),
                            ExpectedType(Type::Str, value.get_type(), line, col),
                        );
                    }
                };

                let pathbuf = match stream.file().as_ref() {
                    Some(file) => Path::new(file)
                        .parent()
                        .unwrap()
                        .join(Path::new(&include_file)),
                    None => Path::new(&include_file).to_path_buf(),
                };
                let path = pathbuf.as_path();
                if !path.is_file() {
                    return parse_err(stream.file(), InvalidIncludePath(include_file, line, col));
                } 
                let path_str = match path.to_str() {
                    Some(path) => path,
                    None => return parse_err(stream.file(), InvalidIncludePath(include_file, line, col)),
                }; 
                let path = match path.canonicalize() {
                    Ok(path) => path,
                    Err(_) => return parse_err(stream.file(), InvalidIncludePath(include_file, line, col)),
                };
                let full_path_str = match path.to_str() {
                    Some(path) => path,
                    None => return parse_err(stream.file(), InvalidIncludePath(include_file, line, col)),
                };
                
                let storing = if let Some(file) = stream.file() {
                    let full_file = String::from(Path::new(&file).canonicalize().unwrap().to_str().unwrap());
                    included.1.insert(full_file.clone());
                    Some(full_file)
                } else {
                    None
                };
                if included.1.contains(full_path_str) {
                    return parse_err(stream.file(), CyclicInclude(include_file, line, col));
                }
                
                let value = if included.0.contains_key(full_path_str) {
                    let value = &included.0[full_path_str];
                    value.clone()
                } else {
                    let value: Value = match include_type {
                        IncludeType::Obj => parse_obj_file_includes(path_str, included)?.into(),
                        IncludeType::Str => parse_str_file(path_str)?.into(),
                        IncludeType::Arr => parse_arr_file(path_str, included)?.into(),
                        IncludeType::Tup => parse_tup_file(path_str, included)?.into(),
                    };
                    
                    included.0.insert(full_path_str.into(), value.clone());
                    value
                };
                
                if let Some(file) = storing {
                    included.1.remove(&file);
                }

                Ok(value)
            }
            /// Tries to perform a unary operation on a single value.
            pub fn unary_op_on_value
            (
                stream: &CharStream,
                val: Value,
                op: char,
                line: usize,
                col: usize,
            ) -> ParseResult<Value>
            {
                use ::database::types::Type::*;

                let t = val.get_type();

                Ok(match op {
                    '+' => match t {
                        Int | Frac => val,
                        _ => return parse_err(stream.file(), UnaryOperatorError(t, op, line, col)),
                    },
                    '-' => match t {
                        Int => (-val.get_int().unwrap()).into(),
                        Frac => (-val.get_frac().unwrap()).into(),
                        _ => return parse_err(stream.file(), UnaryOperatorError(t, op, line, col)),
                    },
                    _ => return parse_err(stream.file(), UnaryOperatorError(t, op, line, col)),
                })
            }
            /// Tries to perform an operation on two values.
            pub fn binary_op_on_values
            (
                stream: &CharStream,
                mut val1: Value,
                mut val2: Value,
                op: char,
                line: usize,
                col: usize,
            ) -> ParseResult<Value>
            {
                use ::database::types::Type::*;

                let (mut type1, mut type2) = (val1.get_type(), val2.get_type());
                
                if type1 == Int && type2 == Frac 
                {
                    val1 = Value::Frac(BigRational::new(val1.get_int().unwrap(), 1.into()));
                    type1 = Frac;
                }
                
                else if type1 == Frac && type2 == Int 
                {
                    val2 = Value::Frac(BigRational::new(val2.get_int().unwrap(), 1.into()));
                    type2 = Frac;
                }

                Ok(match op 
                {
                    '+' => 
                    {
                        match type1 
                        {
                            Int if type2 == Int => (val1.get_int().unwrap() + val2.get_int().unwrap()).into(),
                            Frac if type2 == Frac => (val1.get_frac().unwrap() + val2.get_frac().unwrap()).into(),
                            Char if type2 == Char => 
                            {
                                let mut s = string::String::with_capacity(2);
                                s.push(val1.get_char().unwrap());
                                s.push(val2.get_char().unwrap());
                                s.into()
                            }

                            Char if type2 == Str => 
                            {
                                let str2 = val2.get_str().unwrap();
                                let mut s = string::String::with_capacity(1 + str2.len());
                                s.push(val1.get_char().unwrap());
                                s.push_str(&str2);
                                s.into()
                            }

                            Str if type2 == Char => 
                            {
                                let str1 = val1.get_str().unwrap();
                                let mut s = string::String::with_capacity(str1.len() + 1);
                                s.push_str(&str1);
                                s.push(val2.get_char().unwrap());
                                s.into()
                            }

                            Str if type2 == Str => 
                            {
                                let str1 = val1.get_str().unwrap();
                                let str2 = val2.get_str().unwrap();
                                let mut s = string::String::with_capacity(str1.len() + str2.len());
                                s.push_str(&str1);
                                s.push_str(&str2);
                                s.into()
                            }

                            Arr(_) => 
                            {
                                match Type::most_specific(&type1, &type2) 
                                {
                                    Some((t, _)) => 
                                    {
                                        let (arr1, arr2) = (val1.get_arr().unwrap(), val2.get_arr().unwrap());
                                        let (mut vec1, mut vec2) =
                                            (arr1.vec_ref().clone(), arr2.vec_ref().clone());

                                        let mut vec = Vec::with_capacity(vec1.len() + vec2.len());
                                        vec.append(&mut vec1);
                                        vec.append(&mut vec2);
                                        
                                        let arr = if let Arr(ref t) = t { arrays::Arr::from_vec_unchecked(vec, t.deref().clone()) }
                                        else { panic!("Logic error") };

                                        arr.into()
                                    }

                                    None =>
                                    {
                                        return parse_err
                                        (
                                            stream.file(),
                                            BinaryOperatorError(type1, type2, op, line, col),
                                        );
                                    }
                                }
                            }
                            _ => {
                                return parse_err
                                (
                                    stream.file(),
                                    BinaryOperatorError(type1, type2, op, line, col),
                                );
                            }
                        }
                    }
                    '-' => match type1 
                    {
                        Int if type2 == Int => (val1.get_int().unwrap() - val2.get_int().unwrap()).into(),
                        Frac if type2 == Frac => (val1.get_frac().unwrap() - val2.get_frac().unwrap()).into(),
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    }
                    ,
                    '*' => match type1 
                    {
                        Int if type2 == Int => (val1.get_int().unwrap() * val2.get_int().unwrap()).into(),
                        Frac if type2 == Frac => (val1.get_frac().unwrap() * val2.get_frac().unwrap()).into(),
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    }
                    ,
                    '/' => match type1 
                    {
                        Int if type2 == Int => {
                            let (int1, int2) = (val1.get_int().unwrap(), val2.get_int().unwrap());
                            if int2.is_zero() {
                                return parse_err(stream.file(), InvalidNumeric(line, col));
                            }
                            BigRational::new(int1, int2).into()
                        }
                        Frac if type2 == Frac => {
                            let (frac1, frac2) = (val1.get_frac().unwrap(), val2.get_frac().unwrap());
                            if frac2.is_zero() {
                                return parse_err(stream.file(), InvalidNumeric(line, col));
                            }
                            (frac1 / frac2).into()
                        }
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    }
                    ,
                    '%' => match type1 
                    {
                        Int if type2 == Int => {
                            let int2 = val2.get_int().unwrap();
                            if int2.is_zero() {
                                return parse_err(stream.file(), InvalidNumeric(line, col));
                            }
                            (val1.get_int().unwrap() % int2).into()
                        }
                        _ => {
                            return parse_err(
                                stream.file(),
                                BinaryOperatorError(type1, type2, op, line, col),
                            );
                        }
                    },
                    _ => 
                    {
                        return parse_err(
                            stream.file(),
                            BinaryOperatorError(type1, type2, op, line, col),
                        );
                    }
                })
            }
            /// Finds the next non-whitespace character, ignoring comments, and update stream position.
            pub fn find_char(mut stream: CharStream) -> bool
            {
                while let Some(ch) = stream.peek() 
                {
                    match ch 
                    {
                        '#' => 
                        {
                            loop {
                                let ch = stream.next();
                                if ch.is_none() 
                                {
                                    return false;
                                }
                                if ch.unwrap() == '\n' 
                                {
                                    break;
                                }
                            }
                        }

                        ch if ch.is_whitespace() => 
                        {
                            let _ = stream.next();
                        }

                        _ => return true,
                    }
                }

                false
            }
            /// Helper function to make sure values are followed by a correct end delimiter.
            pub fn check_value_end(stream: &CharStream, cur_brace: Option<char>) -> ParseResult<()>
            {
                match stream.peek() 
                {
                    Some(ch) => match ch 
                    {
                        ch if is::value_end_char(ch) => 
                        {
                            if is::end_delimiter(ch) && Some(ch) != cur_brace 
                            {
                                parse_err(
                                    stream.file(),
                                    InvalidClosingBracket(cur_brace, ch, stream.line(), stream.col()),
                                )
                            } else 
                            {
                                Ok(())
                            }
                        }

                        ch => parse_err
                        (
                            stream.file(),
                            InvalidValueChar(ch, stream.line(), stream.col()),
                        ),
                    },
                    None => Ok(()),
                }
            }
        }
        /// Load an `Obj` from a file.
        pub fn load_from_file(path: &str) -> ParseResult<Obj> { parser::parse_obj_file(path) }
        /// Load an `Obj` from a &str.
        pub fn load_from_str(contents: &str) -> ParseResult<Obj> { parser::parse_obj_str(contents) }
    } pub use self::parses::{ * };
    /// Database, table, column, collation, function, module, vfs name
    pub enum Named<'a> 
    {
        Small( SmallCString ),
        C( &'a CStr ),
    }

    impl ops::Deref for Named<'_>
    {
        type Target = CStr;
        #[inline] fn deref(&self) -> &CStr
        {
            match self
            {
                Named::Small(s) => s.as_cstr(),
                Named::C(s) => s,
            }
        }
    }

    pub trait Name: fmt::Debug
    {
        /// As C string
        fn as_cstr(&self) -> OverResult<Named<'_>>;
    }
    /// pls custom database.
    #[derive(Eq, PartialEq, Clone, Debug)]
    pub struct Database
    {
        pub name:String,
        pub description:String,
        pub alias:Vec<String>,
        pub object:Option<Obj>,
    }
    
    impl Database 
    {
        /// Create a new database with constant support.
        pub const fn new() -> Self
        {
            Self
            {
                name:String::new(),
                description:String::new(),
                alias: Vec::new(),
                object: None,
            }
        }
        /// Create a new database with a backing name, description, and Obj
        pub fn create( name:String, description:String, object:Obj ) -> Self
        {
            Self
            {
                name,
                description,
                alias: Vec::new(),
                object:Some( object ),
            }
        }
        /// Create a new database with a backing name, description, and HashMap
        pub fn create_from_map( name:String, description:String, map:HashMap<String, values::Value> ) -> OverResult<Self>
        {
            match Obj::from_map( map )
            {
                Ok( object ) => Ok( Self::create( name, description, object ) ),
                Err( e ) => Err( e )
            }
        }
        /// Create a new database with a backing name, description, and HashMap, and given parent.
        pub fn create_from_map_with_parent( name:String, description:String, map:HashMap<String, values::Value>, parent: Obj ) -> OverResult<Self>
        {
            match Obj::from_map_with_parent( map, parent )
            {
                Ok( object ) => Ok( Self::create( name, description, object ) ),
                Err( e ) => Err( e )
            }
        }
        /// Build the object data of the database once it has been established.
        pub fn build( &mut self ) -> Self
        {
            match &self.object
            {
                None =>
                {
                    self.object = Some( Obj::default() );
                    return self.clone();
                }
                Some( db ) => self.clone()
            }
        }
        /// Load a database from the current environment.
        pub fn from_env() -> OverResult<Self> 
        {
            if let Ok( filepath ) = env::var("PLS") { Self::from_file( &filepath ) }
            else  { Err( OverError::EnvironmentFileNotFound ) }
        }
        /// Returns a new `Obj` loaded from a file.
        pub fn from_file( filepath:&str ) -> OverResult<Self>
        {
            Ok( Self::create( "pls".to_string(), "...".to_string(), Obj::from_file( filepath )? ) )
        }
        /// Gets the `Value` associated with `field`.
        pub fn get(&self, field: &str) -> OverResult<values::Value>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    match db.get( field )
                    {
                        None => Err( OverError::FieldNotFound( field.to_string() ) ),
                        Some( found ) =>
                        {
                            Ok( found )
                        }
                    }
                }
            }
        }
        /// Read a terminal mode.
        ///
        /// ## Example
        ///
        /// ```
        /// let info        = Database::from_env().unwrap();
        /// let colors: i32 = info.read::<mode::MaxColors>().unwrap().into();
        /// ```
        pub fn read<'a, M: ::mode::Mode<'a>>(&'a self) -> Option<M>
        { 
            /*
            M::from( self.object.get( M::name()) ) */
            None
        }
        /// Returns the ID of this `Obj`.
        pub fn identify( &self ) -> usize
        {
            match &self.object
            {
                None => 0,
                Some( db ) => 
                {
                    return db.id();
                }
            }
        }
        /// Returns a reference to the inner map of this `Obj`.
        pub fn refer( &self ) -> Option<&HashMap<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) => 
                {
                    return Some( db.map_ref() );
                }
            }
        }
        /// Writes this `Obj` to given file in `.over` representation.
        pub fn write_to_file( &self, path:&str ) -> OverResult<()> 
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    db.write_to_file( path )
                }
            }
        }
        /// Writes this `Obj` to a `String`.
        pub fn write_str(&self) -> String
        {
            match &self.object
            {
                None => String::new(),
                Some( db ) =>
                {
                    return db.write_str();
                }
            }
        }
        /// Iterates over each `(String, Value)` pair in `self`, applying `f`.
        pub fn with_each<F>(&self, mut f: F) where
        F: FnMut(&String, &values::Value),
        {
            match &self.object
            {
                None => { return },
                Some( db ) =>
                {
                    db.with_each( f )
                }
            }
        }
        /// Returns the number of fields for this `Obj` (parent fields not included).
        pub fn len(&self) -> usize
        {
            match &self.object
            {
                None => 0,
                Some( db ) =>
                {
                    return db.len();
                }
            }
        }
        /// Returns whether this `Obj` is empty.
        pub fn is_empty(&self) -> bool
        {
            match &self.object
            {
                None => true,
                Some( db ) =>
                {
                    return db.is_empty();
                }
            }
        }
        /// Returns whether `self` and `other` point to the same data.
        pub fn ptr_eq(&self, other: &Self) -> bool
        {
            match &self.object
            {
                None => false,
                Some( this ) =>
                {
                    match &other.object
                    {
                        None => false,
                        Some( that ) =>
                        {
                            this.ptr_eq( &that )
                        }
                    }
                }
            }
        }
        /// Returns whether this `Obj` is empty.
        pub fn contains(&self, field: &str) -> bool
        {
            match &self.object
            {
                None => false,
                Some( db ) =>
                {
                    return db.contains( field );
                }
            }
        }
        /// Gets the `Value` associated with `field` and the `Obj` where it was found.
        pub fn get_with_source(&self, field: &str) -> Option<(values::Value, Obj)>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return db.get_with_source( field );
                }
            }
        }
        /// Returns the `bool` found at `field`.
        pub fn get_bool(&self, field: &str) -> OverResult<bool>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_bool( field );
                }
            }
        }
        /// Returns the `BigInt` found at `field`.
        pub fn get_int(&self, field: &str) -> OverResult<num::big::BigInt>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_int( field );
                }
            }
        }
        /// Returns the `BigRational` found at `field`.
        pub fn get_frac(&self, field: &str) -> OverResult<num::rational::BigRational>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_frac( field );
                }
            }
        }
        /// Returns the `char` found at `field`.
        pub fn get_char(&self, field: &str) -> OverResult<char>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_char( field );
                }
            }
        }
        /// Returns the `String` found at `field`.
        pub fn get_str(&self, field: &str) -> OverResult<String>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_str( field );
                }
            }
        }
        /// Returns the `Arr` found at `field`.
        pub fn get_arr(&self, field: &str) -> OverResult<Arr>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_arr( field );
                }
            }
        }
        /// Returns the `Tup` found at `field`.
        pub fn get_tup(&self, field: &str) -> OverResult<Tup>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_tup( field );
                }
            }
        }
        /// Returns the `Obj` found at `field`.
        pub fn get_obj(&self, field: &str) -> OverResult<Obj>
        {
            match &self.object
            {
                None => Err( OverError::DatabaseNotFound ),
                Some( db ) =>
                {
                    return db.get_obj( field );
                }
            }
        }
        /// Returns whether this `Obj` has a parent.
        pub fn has_parent(&self) -> bool
        {
            match &self.object
            {
                None => false,
                Some( db ) =>
                {
                    return db.has_parent();
                }
            }
        }
        /// Returns the parent for this `Obj`.
        pub fn get_parent(&self) -> Option<Obj>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return db.get_parent();
                }
            }
        }
        /// Returns true if `field` is a valid field name for an `Obj`.
        pub fn valid( &self, field: &str ) -> bool
        {
            Obj::is_valid_field( field )
        }
        /// An iterator visiting all fields (keys) in arbitrary order.
        pub fn keys(&self) -> Option<Keys<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return Some( db.keys() );
                }
            }
        }
        /// An iterator visiting all fields (keys) in arbitrary order.
        pub fn values(&self) -> Option<Values<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return Some( db.values() );
                }
            }
        }
        /// An iterator visiting all fields (keys) in arbitrary order.
        pub fn iter(&self) -> Option<Iter<String, values::Value>>
        {
            match &self.object
            {
                None => None,
                Some( db ) =>
                {
                    return Some( db.iter() );
                }
            }
        }
    }
    /// Allows interrupting a long-running computation.
    pub struct InterruptHandle
    {
        db_lock: Arc<Mutex<*mut Database>>,
    }

    unsafe impl Send for InterruptHandle {}
    unsafe impl Sync for InterruptHandle {}

    impl InterruptHandle
    {
        pub const fn new() -> Self
        {
            Self
            {
                db_lock: Arc::new( ptr::null_mut )
            }
        }
        /// Interrupt the query currently executing on another thread.
        pub fn interrupt(&self)
        {
            /*
            let db_handle = self.db_lock.lock().unwrap();
            if !db_handle.is_null() { unsafe { ffi::sqlite3_interrupt(*db_handle) } } */
        }
    }

    #[repr(C)] #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    pub enum OpenFlags
    {
        /// The database is opened in read-only mode.
        OPEN_READ_ONLY = 1,
        /// The database is opened for reading and writing if possible, 
        /// or reading only if the file is write-protected by the operating system.
        OPEN_READ_WRITE = 2,
        /// The database is created if it does not already exist
        OPEN_CREATE = 4,
        /// The filename can be interpreted as a URI if this flag is set.
        OPEN_URI = 64,
        /// The database will be opened as an in-memory database.
        OPEN_MEMORY = 128,
        /// The new database connection will not use a per-connection mutex.
        OPEN_NO_MUTEX = 32768,
        /// The new database connection will use the "serialized" threading mode.
        OPEN_FULL_MUTEX = 65536,
        /// The database is opened with shared cache enabled.
        OPEN_SHARED_CACHE = 0x0002_0000,
        /// The database is opened shared cache disabled.
        OPEN_PRIVATE_CACHE = 0x0004_0000,
        /// The database filename is not allowed to be a symbolic link. (3.31.0)
        OPEN_NOFOLLOW = 0x0100_0000,
        /// Extended result codes. (3.37.0)
        OPEN_EXRESCODE = 0x0200_0000,
    }    
    /// A connection to a SQLite database.
    pub struct Connection
    {

    }

    impl Connection
    {
        /// Create a new connection
        pub const fn new() -> Self
        {
            Self
            {

            }
        }
        /// Create a new connection
        pub fn create() -> Self
        {
            Self
            {

            }
        }
        /// Open a new connection to a OVER database.
        #[inline] pub fn open<P: AsRef<Path>>(path: P) -> OverResult<Self>
        {
            Ok( Self::new() )
        }
        /// Open a new connection to an in-memory OVER database.
        #[inline] pub fn open_in_memory() -> OverResult<Self>
        {
            Ok( Self::new() )
        }
        /// Open a new connection to an OVER database with flags.
        #[inline] pub fn open_with_flags<P: AsRef<Path>>(path: P, flags: OpenFlags) -> OverResult<Self>
        {
            Ok( Self::new() )
        }
        /// Open a new connection to an OVER database using the specific flags and vfs name.
        pub fn open_with_flags_and_vfs<P: AsRef<Path>, V: Name>
        (
            path: P,
            flags: OpenFlags,
            vfs: V,
        ) -> OverResult<Self>
        {
            Ok( Self::new() )
        }
        /// Open a new connection to an in-memory OVER database.
        pub fn open_in_memory_with_flags(flags: OpenFlags) -> OverResult<Self>
        {
            Ok( Self::new() )
        }
        /// Open a new connection to an in-memory OVER database using the specific flags and vfs name.
        #[inline] pub fn open_in_memory_with_flags_and_vfs<V: Name>(flags: OpenFlags, vfs: V) -> OverResult<Self>
        {
            Ok( Self::new() )
        }
        /// Convenience method to run multiple OVER statements.
        pub fn execute_batch( &self, query:&str ) -> OverResult<()>
        {
            Ok( () )
        }
        /// Convenience method to prepare and execute a single OVER statement.
        #[inline] pub fn execute<P: Params>(&self, query: &str, params: P) -> OverResult<usize>
        {
            Ok( () )
        }
        /// Returns the path to the database file, if one exists and is known.
        #[inline] pub fn path(&self) -> Option<&str>
        {
            None
        }
        /// Attempts to free as much heap memory as possible from the database connection.
        #[inline] pub fn release_memory(&self) -> OverResult<()>
        {
            Ok( () )
        }
        /// Get the SQLite rowid of the most recent successful INSERT.
        #[inline] pub fn last_insert_rowid(&self) -> i64
        {
            0
        }
        /// Convenience method to execute a query that is expected to return a single row.
        #[inline] pub fn query_row<T, P, F>(&self, query: &str, params: P, f: F) -> OverResult<T> where
        P: Params,
        F: FnOnce(&Row<'_>) -> OverResult<T>
        {
            Ok( () )
        }
        /// Convenience method to execute a query that is expected to return exactly one row.
        pub fn query_one<T, P, F>(&self, query: &str, params: P, f: F) -> OverResult<T> where
        P: Params,
        F: FnOnce(&Row<'_>) -> OverResult<T>,
        {
            Ok( () )
        }
        /// Convenience method to execute a query that is expected to return a single row,
        /// and execute a mapping via `f` on that returned row with the possibility of failure.
        #[inline] pub fn query_row_and_then<T, P, F>(&self, query: &str, params: P, f: F) -> OverResult<T> where
        P: Params,
        F: FnOnce(&Row<'_>) -> OverResult<T>,
        {
            Ok( () )
        }
        /// Prepare a SQL statement for execution.
        #[inline] pub fn prepare(&self, query: &str) -> OverResult<Statement<'_>>
        {
            Ok( () )
        }
        /// Prepare a SQL statement for execution.
        #[inline] pub fn prepare_with_flags(&self, query: &str, flags: PrepFlags) -> OverResult<Statement<'_>>
        {
            Ok( () )
        }
        /// Close the SQLite connection.
        #[inline] pub fn close(self) -> OverResult<()>
        {
            Ok( () )
        }
        /// Enable loading of OVER extensions from both OVER queries and Rust.
        #[inline] pub unsafe fn load_extension_enable(&self) -> OverResult<()>
        {
            Ok( () )
        }
        /// Disable loading of SQLite extensions.
        #[inline] pub fn load_extension_disable(&self) -> OverResult<()>
        {
            Ok( () )
        }
        /// Load the OVER extension at `dylib_path`. `dylib_path` is passed
        /// through to `over_load_extension`, which may attempt OS-specific
        /// modifications if the file cannot be loaded directly.
        #[inline] pub unsafe fn load_extension<P: AsRef<Path>, N: Name>
        (
            &self,
            dylib_path: P,
            entry_point: Option<N>,
        ) -> OverResult<()> 
        {
            Ok( () )
        }
        /// Get access to the underlying OVER database connection handle.
        #[inline] pub unsafe fn handle(&self) -> *mut Database
        {
            ptr::null_mut()
        }
        /// Create a `Connection` from a raw handle.
        #[inline] pub unsafe fn from_handle( db: *mut Database ) -> OverResult<Self>
        {
            Ok( Self { } )
        }
        /// Helper to register an OVER extension written in Rust.
        pub unsafe fn extension_init2
        (
            db: *mut Database,
            pz_err_msg: *mut *mut c_char,
            p_api: *mut Routines,
            init: fn(Self) -> OverResult<bool>,
        ) -> c_int 
        {
            0            
        }
        /// Create a `Connection` from a raw owned handle.
        #[inline] pub unsafe fn from_handle_owned( db: *mut Database ) -> OverResult<Self> 
        {
            Ok( Self { } )
        }
        /// Get access to a handle that can be used to interrupt long-running queries from another thread.
        #[inline] pub fn get_interrupt_handle(&self) -> InterruptHandle 
        {
            InterruptHandle::new()
        }

        #[inline] pub fn decode_result(&self, code: c_int) -> OverResult<()>
        {
            Ok( () )
        }
        /// Return the number of rows modified, inserted or deleted by the most
        /// recently completed INSERT, UPDATE or DELETE statement on the database
        /// connection.
        #[inline] pub fn changes(&self) -> u64 { 0 }
        /// Return the total number of rows modified, inserted or deleted by all
        /// completed INSERT, UPDATE or DELETE statements since the database
        /// connection was opened, including those executed as part of trigger programs.
        #[inline] pub fn total_changes(&self) -> u64 { 0 }
        /// Test for auto-commit mode.
        #[inline] pub fn is_autocommit(&self) -> bool { false }
        /// Determine if all associated prepared statements have been reset.
        #[inline] pub fn is_busy(&self) -> bool { false }
        /// Flush caches to disk mid-transaction
        pub fn cache_flush(&self) -> OverResult<()>
        {
            Ok( () )
        }
        /// Determine if a database is read-only
        pub fn is_readonly<N: Name>(&self, db_name: N) -> OverResult<bool>
        {
            Ok( true )
        }
        /// Return the schema name for a database connection.
        pub fn db_name(&self, index: usize) -> OverResult<String>
        {
            Ok( String::new() )
        }
        /// Determine whether an interrupt is currently in effect
        pub fn is_interrupted(&self) -> bool { false }
    }

    impl Drop for Connection
    {
        #[inline] fn drop(&mut self)
        {
            self.flush_prepared_statement_cache();
        }
    }
    
    unsafe impl Send for Connection {}

    // pub fn init_db(hfile: &str, htable: &str)
    pub fn initialize(hfile: &str, htable: &str)
    {
        let path = Path::new(hfile);
        if !path.exists() {
            let _parent = match path.parent() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: history init - no parent found");
                    return;
                }
            };
            let parent = match _parent.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: parent to_str is None");
                    return;
                }
            };
            match fs::create_dir_all(parent) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!("cicada: histdir create error: {}", e);
                    return;
                }
            }
            match fs::File::create(hfile) {
                Ok(_) => {
                    println!("cicada: created history file: {}", hfile);
                }
                Err(e) => {
                    println_stderr!("cicada: history: file create failed: {}", e);
                }
            }
        }

        let conn = match Conn::open(hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: open db error: {}", e);
                return;
            }
        };
        let sql = format!(
            "
            CREATE TABLE IF NOT EXISTS {}
                (inp TEXT,
                rtn INTEGER,
                tsb REAL,
                tse REAL,
                sessionid TEXT,
                out TEXT,
                info TEXT
                );
        ",
            htable
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: query error: {}", e),
        }
    }
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod env
{
    pub use std::env::{ * };
    /**/
    pub fn get_user_home() -> String
    {
        match var("HOME")
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: env HOME error: {}", e);
                String::new()
            }
        }
    }
}

pub mod error
{
    pub use std::error::{ * };

    pub mod no
    {
        use ::
        {
            error::{ Error },
            system::{ self as _ },
            *,
        };

        pub mod system
        {
            use ::
            {
                *,
            }; use super::Errno;

            pub const STRERROR_NAME: &str = "";
        
            pub mod unix
            {
                //! Implementation of `errno` functionality for Unix systems.
                use ffi::c_int;
                use ::
                {
                    error::no::{ Errno },
                    libc::{ unix::{ * }, * },
                    nix::libc::{ ERANGE, strerror_r, strlen },
                    *,
                };

                extern "C" 
                {
                    #[cfg_attr
                    (
                        any
                        (
                            target_os = "openbsd",
                            target_os = "netbsd",
                        ),
                        link_name = "__errno"
                    )]

                    #[cfg_attr
                    (
                        any( target_os = "linux", ),
                        link_name = "__errno_location"
                    )]
                    fn errno_location() -> *mut c_int;
                }

                fn from_utf8_lossy(input: &[u8]) -> &str
                {
                    match str::from_utf8(input)
                    {
                        Ok(valid) => valid,
                        Err(error) => unsafe { str::from_utf8_unchecked(&input[..error.valid_up_to()]) },
                    }
                }

                pub fn with_description<F, T>(err: Errno, callback: F) -> T where
                F: FnOnce(Result<&str, Errno>) -> T
                {
                    let mut buf = [0u8; 1024];
                    let c_str = unsafe
                    {
                        let rc = strerror_r(err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t);
                        if rc != 0
                        {
                            let fm_err = match rc < 0
                            {
                                true => errno(),
                                false => Errno(rc),
                            };

                            if fm_err != Errno( ERANGE ) { return callback(Err(fm_err)); }
                        }

                        let c_str_len = strlen(buf.as_ptr() as *const _);
                        &buf[..c_str_len]
                    };
                    callback(Ok(from_utf8_lossy(c_str)))
                }

                pub const STRERROR_NAME: &str = "strerror_r";

                pub fn errno() -> Errno { unsafe { Errno(*errno_location()) } }

                pub fn set_errno(Errno(errno): Errno) { unsafe { *errno_location() = errno; } }
            } #[cfg( unix )] pub use self::unix::{ * };

            pub mod windows
            {
                use ::
                {
                    char::{ self, REPLACEMENT_CHARACTER },
                    error::{ Error, no::{ Errno } },
                    libc::{ windows::{ * }, * },
                    *,
                };

                fn from_utf16_lossy<'a>(input: &[u16], output: &'a mut [u8]) -> &'a str
                {
                    let mut output_len = 0;
                    for c in char::decode_utf16
                    (
                        input.iter()
                        .copied()
                        .take_while(|&x| x != 0))
                        .map(|x| x.unwrap_or(REPLACEMENT_CHARACTER))
                    {
                        let c_len = c.len_utf8();
                        
                        if c_len > output.len() - output_len { break; }

                        c.encode_utf8(&mut output[output_len..]);
                        output_len += c_len;
                    }

                    unsafe { str::from_utf8_unchecked(&output[..output_len]) }
                }

                pub fn with_description<F, T>(err: Errno, callback: F) -> T where
                F: FnOnce(Result<&str, Errno>) -> T
                {
                    unsafe
                    {
                        let lang_id = 0x0800_u32;
                        let mut buf = [0u16; 2048];
                        let res = FormatMessageW
                        (
                            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                            ptr::null_mut(),
                            err.0 as u32,
                            lang_id,
                            buf.as_mut_ptr(),
                            buf.len() as u32,
                            ptr::null_mut(),
                        );
                        
                        if res == 0
                        {
                            let fm_err = errno();
                            return callback(Err(fm_err));
                        }

                        let mut msg = [0u8; 2048];
                        let msg = from_utf16_lossy(&buf[..res as usize], &mut msg[..]);
                        callback(Ok(msg.trim_end()))
                    }
                }

                pub const STRERROR_NAME: &str = "FormatMessageW";

                pub fn errno() -> Errno {
                    unsafe { Errno(GetLastError() as i32) }
                }

                pub fn set_errno(Errno(errno): Errno) {
                    unsafe { SetLastError(errno as WIN32_ERROR) }
                }
            } #[cfg( windows )] pub use self::windows::{ * };

            pub fn with_description<F, T>(_err: Errno, _callback: F) -> T where
            F: FnOnce(Result<&str, Errno>) -> T
            { unreachable!() }
            /*
            pub fn with_description<F, T>(_err: Errno, _callback: F) -> T where
            F: FnOnce(Result<&str, Errno>) -> T
            { unreachable!() }
            
            pub fn errno() -> Errno { unreachable!() }

            pub fn set_errno(_: Errno) { unreachable!() } */
        }
        /// Wraps a platform-specific error code.
        #[derive(Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash)]
        pub struct Errno(pub i32);

        impl fmt::Debug for Errno 
        {
            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
            {
                system::with_description(*self, |desc| 
                {
                    fmt.debug_struct("Errno")
                    .field("code", &self.0)
                    .field("description", &desc.ok())
                    .finish()
                })
            }
        }

        impl fmt::Display for Errno
        {
            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result
            {
                system::with_description(*self, |desc| match desc
                {
                    Ok(desc) => fmt.write_str(desc),
                    Err(fm_err) => write!
                    (
                        fmt,
                        "OS error {} ({} returned error {})",
                        self.0,
                        sys::STRERROR_NAME,
                        fm_err.0
                    ),
                })
            }
        }

        impl From<Errno> for i32 
        {
            fn from(e: Errno) -> Self { e.0 }
        }
        
        impl Error for Errno
        {
            fn description(&self) -> &str { "system error" }
        }
        
        impl From<Errno> for io::Error
        {
            fn from(errno: Errno) -> Self { io::Error::from_raw_os_error(errno.0) }
        }
        /// Returns the platform-specific value of `errno`.
        pub fn errno() -> Errno { system::errno() }
        /// Sets the platform-specific value of `errno`.
        pub fn set_errno(err: Errno) { system::set_errno(err) }
    }

    pub mod uuid
    {
        use ::
        {
            *,
        };

        /// A general error that can occur when working with UUIDs.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub struct Error(pub(crate) ErrorKind);

        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub(crate) enum ErrorKind
        {
            /// Invalid character in the [`Uuid`] string.
            Char { character: char, index: usize },
            /// A simple [`Uuid`] didn't contain 32 characters.
            SimpleLength { len: usize },
            /// A byte array didn't contain 16 bytes
            ByteLength { len: usize },
            /// A hyphenated [`Uuid`] didn't contain 5 groups
            GroupCount { count: usize },
            /// A hyphenated [`Uuid`] had a group that wasn't the right length
            GroupLength 
            {
                group: usize,
                len: usize,
                index: usize,
            },
            /// The input was not a valid UTF8 string
            InvalidUTF8,
            /// The UUID is nil.
            Nil,
            /// Some other error occurred.
            Other,
        }
        /// A string that is guaranteed to fail to parse to a [`Uuid`].
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub struct InvalidUuid<'a>(pub(crate) &'a [u8]);

        impl<'a> InvalidUuid<'a> 
        {
            /// Converts the lightweight error type into detailed diagnostics.
            pub fn into_err(self) -> Error 
            {
                let input_str = match ::str::from_utf8(self.0) 
                {
                    Ok(s) => s,
                    Err(_) => return Error(ErrorKind::InvalidUTF8),
                };

                let (uuid_str, offset, simple) = match input_str.as_bytes() 
                {
                    [b'{', s @ .., b'}'] => (s, 1, false),
                    [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] => {
                        (s, "urn:uuid:".len(), false)
                    }
                    s => (s, 0, true),
                };

                let mut hyphen_count = 0;
                let mut group_bounds = [0; 4];
                
                let uuid_str = unsafe { ::str::from_utf8_unchecked(uuid_str) };

                for (index, character) in uuid_str.char_indices() 
                {
                    let byte = character as u8;
                    if character as u32 - byte as u32 > 0 {
                        return Error(ErrorKind::Char {
                            character,
                            index: index + offset + 1,
                        });
                    } else if byte == b'-' {
                        if hyphen_count < 4 {
                            group_bounds[hyphen_count] = index;
                        }
                        hyphen_count += 1;
                    } else if !byte.is_ascii_hexdigit() {
                        return Error(ErrorKind::Char {
                            character: byte as char,
                            index: index + offset + 1,
                        });
                    }
                }

                if hyphen_count == 0 && simple {
                    Error(ErrorKind::SimpleLength {
                        len: input_str.len(),
                    })
                } else if hyphen_count != 4 {
                    Error(ErrorKind::GroupCount {
                        count: hyphen_count + 1,
                    })
                } else {
                    const BLOCK_STARTS: [usize; 5] = [0, 9, 14, 19, 24];
                    for i in 0..4 {
                        if group_bounds[i] != BLOCK_STARTS[i + 1] - 1 {
                            return Error(ErrorKind::GroupLength {
                                group: i,
                                len: group_bounds[i] - BLOCK_STARTS[i],
                                index: offset + BLOCK_STARTS[i] + 1,
                            });
                        }
                    }
                    Error(ErrorKind::GroupLength {
                        group: 4,
                        len: input_str.len() - BLOCK_STARTS[4],
                        index: offset + BLOCK_STARTS[4] + 1,
                    })
                }
            }
        }
        
        impl fmt::Display for Error 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
            {
                match self.0 
                {
                    ErrorKind::Char {
                        character, index, ..
                    } => {
                        write!(f, "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `{}` at {}", character, index)
                    }
                    ErrorKind::SimpleLength { len } => {
                        write!(
                            f,
                            "invalid length: expected length 32 for simple format, found {}",
                            len
                        )
                    }
                    ErrorKind::ByteLength { len } => {
                        write!(f, "invalid length: expected 16 bytes, found {}", len)
                    }
                    ErrorKind::GroupCount { count } => {
                        write!(f, "invalid group count: expected 5, found {}", count)
                    }
                    ErrorKind::GroupLength { group, len, .. } => 
                    {
                        let expected = [8, 4, 4, 4, 12][group];
                        write!(
                            f,
                            "invalid group length in group {}: expected {}, found {}",
                            group, expected, len
                        )
                    }
                    ErrorKind::InvalidUTF8 => write!(f, "non-UTF8 input"),
                    ErrorKind::Nil => write!(f, "the UUID is nil"),
                    ErrorKind::Other => write!(f, "failed to parse a UUID"),
                }
            }
        }
        
        impl error::Error for Error {}
    }
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod fs
{
    pub use std::fs::{ * };
}

pub mod glob
{
    //! Support for matching file paths against Unix shell style patterns.
    use ::
    {
        cmp::{ self, Ordering },
        error::{ Error },
        fs::{ self, DirEntry },
        ops::{ Deref },
        path::{ self, Component, Path, PathBuf },
        str::{ FromStr },
        *
    };
    

    use self::CharSpecifier::{CharRange, SingleChar};
    use self::MatchResult::{EntirePatternDoesntMatch, Match, SubPatternDoesntMatch};
    use self::PatternToken::AnyExcept;
    use self::PatternToken::{AnyChar, AnyRecursiveSequence, AnySequence, AnyWithin, Char};
    /// An iterator that yields `Path`s from the filesystem that match a particular pattern.
    #[derive(Debug)]
    pub struct Paths
    {
        dir_patterns: Vec<Pattern>,
        require_dir: bool,
        options: MatchOptions,
        todo: Vec<Result<(PathWrapper, usize), GlobError>>,
        scope: Option<PathWrapper>,
    }
    /// Return an iterator that produces all the `Path`s that match the given pattern using default match options,
    /// which may be absolute or relative to the current working directory.
    pub fn glob(pattern: &str) -> Result<Paths, PatternError>
    {
        glob_with(pattern, MatchOptions::new())
    }
    /// Return an iterator with all the `Path`s that match the given pattern using the specified match options, 
    /// which may be absolute or relative to the current working directory.
    pub fn glob_with(pattern: &str, options: MatchOptions) -> Result<Paths, PatternError>
    {
        #[cfg(windows)]
        fn check_windows_verbatim(p: &Path) -> bool
        {
            match p.components().next() {
                Some(Component::Prefix(ref p)) => {
                    // Allow VerbatimDisk paths. std canonicalize() generates them, and they work fine
                    p.kind().is_verbatim()
                        && if let std::path::Prefix::VerbatimDisk(_) = p.kind() {
                            false
                        } else {
                            true
                        }
                }
                _ => false,
            }
        }
        #[cfg(not(windows))]
        fn check_windows_verbatim(_: &Path) -> bool {
            false
        }

        #[cfg(windows)]
        fn to_scope(p: &Path) -> PathBuf {
            // FIXME handle volume relative paths here
            p.to_path_buf()
        }
        #[cfg(not(windows))]
        fn to_scope(p: &Path) -> PathBuf {
            p.to_path_buf()
        }

        // make sure that the pattern is valid first, else early return with error
        let _ = Pattern::new(pattern)?;

        let mut components = Path::new(pattern).components().peekable();
        loop {
            match components.peek() {
                Some(&Component::Prefix(..)) | Some(&Component::RootDir) => {
                    components.next();
                }
                _ => break,
            }
        }
        let rest = components.map(|s| s.as_os_str()).collect::<PathBuf>();
        let normalized_pattern = Path::new(pattern).iter().collect::<PathBuf>();
        let root_len = normalized_pattern.to_str().unwrap().len() - rest.to_str().unwrap().len();
        let root = if root_len > 0 {
            Some(Path::new(&pattern[..root_len]))
        } else {
            None
        };

        if root_len > 0 && check_windows_verbatim(root.unwrap()) {
            // FIXME: How do we want to handle verbatim paths? I'm inclined to
            // return nothing, since we can't very well find all UNC shares with a
            // 1-letter server name.
            return Ok(Paths {
                dir_patterns: Vec::new(),
                require_dir: false,
                options,
                todo: Vec::new(),
                scope: None,
            });
        }

        let scope = root.map_or_else(|| PathBuf::from("."), to_scope);
        let scope = PathWrapper::from_path(scope);

        let mut dir_patterns = Vec::new();
        let components =
            pattern[cmp::min(root_len, pattern.len())..].split_terminator(path::is_separator);

        for component in components {
            dir_patterns.push(Pattern::new(component)?);
        }

        if root_len == pattern.len() {
            dir_patterns.push(Pattern {
                original: "".to_string(),
                tokens: Vec::new(),
                is_recursive: false,
            });
        }

        let last_is_separator = pattern.chars().next_back().map(path::is_separator);
        let require_dir = last_is_separator == Some(true);
        let todo = Vec::new();

        Ok(Paths {
            dir_patterns,
            require_dir,
            options,
            todo,
            scope: Some(scope),
        })
    }
    /// A glob iteration error.
    #[derive(Debug)]
    pub struct GlobError
    {
        path: PathBuf,
        error: io::Error,
    }

    impl GlobError
    {
        /// The Path that the error corresponds to.
        pub fn path(&self) -> &Path { &self.path }
        /// The error in question.
        pub fn error(&self) -> &io::Error { &self.error }
        /// Consumes self, returning the _raw_ underlying `io::Error`
        pub fn into_error(self) -> io::Error { self.error }
    }

    impl Error for GlobError
    {
        fn description(&self) -> &str { self.error.description() }
        
        fn cause(&self) -> Option<&Error> { Some(&self.error) }
    }

    impl fmt::Display for GlobError
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
        {
            write!
            (
                f,
                "attempting to read `{}` resulted in an error: {}",
                self.path.display(),
                self.error
            )
        }
    }

    #[derive(Debug)]
    struct PathWrapper
    {
        path: PathBuf,
        is_directory: bool,
    }

    impl PathWrapper
    {
        fn from_dir_entry(path: PathBuf, e: DirEntry) -> Self
        {
            let is_directory = e
            .file_type()
            .ok()
            .and_then(|file_type|
            {
                if file_type.is_symlink() { None } else { Some(file_type.is_dir()) }
            })
            .or_else(|| fs::metadata(&path).map(|m| m.is_dir()).ok())
            .unwrap_or(false);

            Self { path, is_directory }
        }

        fn from_path(path: PathBuf) -> Self
        {
            let is_directory = fs::metadata(&path).map(|m| m.is_dir()).unwrap_or(false);
            Self { path, is_directory }
        }

        fn into_path(self) -> PathBuf { self.path }
    }

    impl Deref for PathWrapper
    {
        type Target = Path;
        fn deref(&self) -> &Self::Target { self.path.deref() }
    }

    impl AsRef<Path> for PathWrapper
    {
        fn as_ref(&self) -> &Path { self.path.as_ref() }
    }
    /// An alias for a glob iteration result.
    pub type GlobResult = Result<PathBuf, GlobError>;

    impl Iterator for Paths
    {
        type Item = GlobResult;
        fn next(&mut self) -> Option<GlobResult>
        {
            if let Some(scope) = self.scope.take()
            {
                if !self.dir_patterns.is_empty()
                {
                    assert!(self.dir_patterns.len() < std::usize::MAX);
                    fill_todo(&mut self.todo, &self.dir_patterns, 0, &scope, self.options);
                }
            }

            loop
            {
                if self.dir_patterns.is_empty() || self.todo.is_empty() { return None; }

                let (path, mut idx) = match self.todo.pop().unwrap()
                {
                    Ok(pair) => pair,
                    Err(e) => return Some(Err(e)),
                };
                
                if idx == std::usize::MAX
                {
                    if self.require_dir && !path.is_directory { continue; }
                    return Some(Ok(path.into_path()));
                }

                if self.dir_patterns[idx].is_recursive
                {
                    let mut next = idx;
                    
                    while (next + 1) < self.dir_patterns.len() && self.dir_patterns[next + 1].is_recursive
                    { next += 1; }

                    if path.is_directory
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            next,
                            &path,
                            self.options,
                        );

                        if next == self.dir_patterns.len() - 1 
                        {
                            return Some(Ok(path.into_path()));
                        }
                        
                        else
                        {
                            idx = next + 1;
                        }
                    }
                    
                    else if next == self.dir_patterns.len() - 1 { continue; }
                    else { idx = next + 1; }
                }
                
                if self.dir_patterns[idx].matches_with
                (
                    {
                        match path.file_name().and_then(|s| s.to_str())
                        {
                            None => continue,
                            Some(x) => x,
                        }
                    },
                    self.options,
                )
                {
                    if idx == self.dir_patterns.len() - 1
                    {
                        if !self.require_dir || path.is_directory { return Some(Ok(path.into_path())); }
                    }
                    
                    else
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            idx + 1,
                            &path,
                            self.options,
                        );
                    }
                }
            }
        }
    }
    /// A pattern parsing error.
    #[derive(Debug)]
    #[allow(missing_copy_implementations)]
    pub struct PatternError
    {
        /// The approximate character index of where the error occurred.
        pub pos: usize,
        /// A message describing the error.
        pub msg: &'static str,
    }

    impl Error for PatternError
    {
        fn description(&self) -> &str { self.msg }
    }

    impl fmt::Display for PatternError
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
        {
            write!
            (
                f,
                "Pattern syntax error near position {}: {}",
                self.pos, self.msg
            )
        }
    }
    /// A compiled Unix shell style pattern.
    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug)]
    pub struct Pattern
    {
        original: String,
        tokens: Vec<PatternToken>,
        is_recursive: bool,
    }
    /// Show the original glob pattern.
    impl fmt::Display for Pattern
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { self.original.fmt(f) }
    }

    impl FromStr for Pattern
    {
        type Err = PatternError;
        fn from_str(s: &str) -> Result<Self, PatternError> { Self::new(s) }
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum PatternToken
    {
        Char(char),
        AnyChar,
        AnySequence,
        AnyRecursiveSequence,
        AnyWithin(Vec<CharSpecifier>),
        AnyExcept(Vec<CharSpecifier>),
    }

    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum CharSpecifier
    {
        SingleChar(char),
        CharRange(char, char),
    }

    #[derive(Copy, Clone, PartialEq)]
    enum MatchResult
    {
        Match,
        SubPatternDoesntMatch,
        EntirePatternDoesntMatch,
    }

    const ERROR_WILDCARDS: &str = "wildcards are either regular `*` or recursive `**`";
    const ERROR_RECURSIVE_WILDCARDS: &str = "recursive wildcards must form a single path component";
    const ERROR_INVALID_RANGE: &str = "invalid range pattern";

    impl Pattern
    {
        /// This function compiles Unix shell style patterns.
        pub fn new(pattern: &str) -> Result<Self, PatternError>
        {
            let chars = pattern.chars().collect::<Vec<_>>();
            let mut tokens = Vec::new();
            let mut is_recursive = false;
            let mut i = 0;

            while i < chars.len()
            {
                match chars[i]
                {
                    '?' =>
                    {
                        tokens.push(AnyChar);
                        i += 1;
                    }
                    
                    '*' =>
                    {
                        let old = i;

                        while i < chars.len() && chars[i] == '*' { i += 1; }

                        let count = i - old;

                        match count.cmp(&2)
                        {
                            Ordering::Greater =>
                            {
                                return Err(PatternError
                                {
                                    pos: old + 2,
                                    msg: ERROR_WILDCARDS,
                                })
                            }

                            Ordering::Equal =>
                            {
                                let is_valid = if i == 2 || path::is_separator(chars[i - count - 1])
                                {
                                    if i < chars.len() && path::is_separator(chars[i])
                                    {
                                        i += 1;
                                        true
                                    }
                                    
                                    else if i == chars.len()
                                    {
                                        true
                                    } 
                                    
                                    else
                                    {
                                        return Err(PatternError
                                        {
                                            pos: i,
                                            msg: ERROR_RECURSIVE_WILDCARDS,
                                        });
                                    }
                                }
                                
                                else
                                {
                                    return Err(PatternError
                                    {
                                        pos: old - 1,
                                        msg: ERROR_RECURSIVE_WILDCARDS,
                                    });
                                };

                                if is_valid
                                {
                                    let tokens_len = tokens.len();

                                    if !(tokens_len > 1 && tokens[tokens_len - 1] == AnyRecursiveSequence)
                                    {
                                        is_recursive = true;
                                        tokens.push(AnyRecursiveSequence);
                                    }
                                }
                            }

                            Ordering::Less => tokens.push(AnySequence),
                        }
                    }
                    '[' => {
                        if i + 4 <= chars.len() && chars[i + 1] == '!' {
                            match chars[i + 3..].iter().position(|x| *x == ']') {
                                None => (),
                                Some(j) => {
                                    let chars = &chars[i + 2..i + 3 + j];
                                    let cs = parse_char_specifiers(chars);
                                    tokens.push(AnyExcept(cs));
                                    i += j + 4;
                                    continue;
                                }
                            }
                        } else if i + 3 <= chars.len() && chars[i + 1] != '!' {
                            match chars[i + 2..].iter().position(|x| *x == ']') {
                                None => (),
                                Some(j) => {
                                    let cs = parse_char_specifiers(&chars[i + 1..i + 2 + j]);
                                    tokens.push(AnyWithin(cs));
                                    i += j + 3;
                                    continue;
                                }
                            }
                        }

                        // if we get here then this is not a valid range pattern
                        return Err(PatternError {
                            pos: i,
                            msg: ERROR_INVALID_RANGE,
                        });
                    }
                    c => {
                        tokens.push(Char(c));
                        i += 1;
                    }
                }
            }

            Ok(Self
            {
                tokens,
                original: pattern.to_string(),
                is_recursive,
            })
        }
        /// Escape metacharacters within the given string by surrounding them in brackets.
        pub fn escape(s: &str) -> String
        {
            let mut escaped = String::new();
            for c in s.chars()
            {
                match c
                {
                    '?' | '*' | '[' | ']' =>
                    {
                        escaped.push('[');
                        escaped.push(c);
                        escaped.push(']');
                    }

                    c => { escaped.push(c); }
                }
            }
            escaped
        }
        /// Return if the given `str` matches this `Pattern` using the default options (i.e. `MatchOptions::new()`).
        pub fn matches(&self, str: &str) -> bool { self.matches_with(str, MatchOptions::new()) }
        /// Return if the given `Path`, when converted to a `str`,
        /// matches this `Pattern` using the default match options (i.e. `MatchOptions::new()`).
        pub fn matches_path(&self, path: &Path) -> bool
        {
            path.to_str().map_or(false, |s| self.matches(s))
        }
        /// Return if the given `str` matches this `Pattern` using the specified match options.
        pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool
        {
            self.matches_from(true, str.chars(), 0, options) == Match
        }
        /// Return if the given `Path`, when converted to a `str`,
        /// matches this `Pattern` using the specified match options.
        pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool
        {
            path.to_str().map_or(false, |s| self.matches_with(s, options))
        }
        /// Access the original glob pattern.
        pub fn as_str(&self) -> &str { &self.original }

        fn matches_from
        (
            &self,
            mut follows_separator: bool,
            mut file: ::str::Chars,
            i: usize,
            options: MatchOptions,
        ) -> MatchResult
        {
            for (ti, token) in self.tokens[i..].iter().enumerate()
            {
                match *token
                {
                    AnySequence | AnyRecursiveSequence =>
                    {
                        debug_assert!(match *token {
                            AnyRecursiveSequence => follows_separator,
                            _ => true,
                        });
                        
                        match self.matches_from(follows_separator, file.clone(), i + ti + 1, options)
                        {
                            SubPatternDoesntMatch => (),
                            m => return m,
                        };

                        while let Some(c) = file.next()
                        {
                            if follows_separator && options.require_literal_leading_dot && c == '.'
                            { return SubPatternDoesntMatch; }

                            follows_separator = path::is_separator(c);

                            match *token
                            {
                                AnyRecursiveSequence if !follows_separator => continue,
                                AnySequence if options.require_literal_separator && follows_separator =>
                                { return SubPatternDoesntMatch }
                                _ => (),
                            }

                            match self.matches_from
                            (
                                follows_separator,
                                file.clone(),
                                i + ti + 1,
                                options,
                            )
                            {
                                SubPatternDoesntMatch => (),
                                m => return m,
                            }
                        }
                    }
                    _ => {
                        let c = match file.next() {
                            Some(c) => c,
                            None => return EntirePatternDoesntMatch,
                        };

                        let is_sep = path::is_separator(c);

                        if !match *token {
                            AnyChar | AnyWithin(..) | AnyExcept(..)
                                if (options.require_literal_separator && is_sep)
                                    || (follows_separator
                                        && options.require_literal_leading_dot
                                        && c == '.') =>
                            {
                                false
                            }
                            AnyChar => true,
                            AnyWithin(ref specifiers) => in_char_specifiers(specifiers, c, options),
                            AnyExcept(ref specifiers) => !in_char_specifiers(specifiers, c, options),
                            Char(c2) => chars_eq(c, c2, options.case_sensitive),
                            AnySequence | AnyRecursiveSequence => unreachable!(),
                        } {
                            return SubPatternDoesntMatch;
                        }
                        follows_separator = is_sep;
                    }
                }
            }
            
            if file.next().is_none() { Match } else { SubPatternDoesntMatch }
        }
    }
    
    fn fill_todo
    (
        todo: &mut Vec<Result<(PathWrapper, usize), GlobError>>,
        patterns: &[Pattern],
        idx: usize,
        path: &PathWrapper,
        options: MatchOptions,
    )
    {
        fn pattern_as_str(pattern: &Pattern) -> Option<String>
        {
            let mut s = String::new();
            
            for token in &pattern.tokens
            {
                match *token
                {
                    Char(c) => s.push(c),
                    _ => return None,
                }
            }

            Some(s)
        }

        let add = |todo: &mut Vec<_>, next_path: PathWrapper|
        {
            if idx + 1 == patterns.len() { todo.push(Ok((next_path, std::usize::MAX))); }
            else { fill_todo(todo, patterns, idx + 1, &next_path, options); }
        };

        let pattern = &patterns[idx];
        let is_dir = path.is_directory;
        let curdir = path.as_ref() == Path::new(".");

        match pattern_as_str(pattern)
        {
            Some(s) =>
            {
                let special = "." == s || ".." == s;
                let next_path = if curdir { PathBuf::from(s) } else { path.join(&s) };

                let next_path = PathWrapper::from_path(next_path);
                
                if (special && is_dir) 
                || (!special && (fs::metadata(&next_path).is_ok() || fs::symlink_metadata(&next_path).is_ok()))
                { add(todo, next_path); }
            }

            None if is_dir =>
            {
                let dirs = fs::read_dir(path).and_then(|d|
                {
                    d.map(|e|
                    {
                        e.map(|e|
                        {
                            let path = if curdir { PathBuf::from(e.path().file_name().unwrap()) }
                            else { e.path() };

                            PathWrapper::from_dir_entry(path, e)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
                });

                match dirs 
                {
                    Ok(mut children) =>
                    {
                        if options.require_literal_leading_dot {
                            children .retain
                            (
                                |x| !x
                                .file_name()
                                .unwrap()
                                .to_str()
                                .unwrap()
                                .starts_with('.')
                            );
                        }

                        children.sort_by(|p1, p2| p2.file_name().cmp(&p1.file_name()));
                        todo.extend(children.into_iter().map(|x| Ok((x, idx))));
                        
                        if !pattern.tokens.is_empty() && pattern.tokens[0] == Char('.')
                        {
                            for &special in &[".", ".."]
                            {
                                if pattern.matches_with(special, options)
                                { add(todo, PathWrapper::from_path(path.join(special))); }
                            }
                        }
                    }

                    Err(e) =>
                    {
                        todo.push(Err(GlobError
                        {
                            path: path.to_path_buf(),
                            error: e,
                        }));
                    }
                }
            }

            None => {}
        }
    }

    fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> 
    {
        let mut cs = Vec::new();
        let mut i = 0;

        while i < s.len() 
        {
            if i + 3 <= s.len() && s[i + 1] == '-' 
            {
                cs.push(CharRange(s[i], s[i + 2]));
                i += 3;
            }
            
            else 
            {
                cs.push(SingleChar(s[i]));
                i += 1;
            }
        }

        cs
    }

    fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool 
    {
        for &specifier in specifiers.iter() 
        {
            match specifier 
            {
                SingleChar(sc) => 
                {
                    if chars_eq(c, sc, options.case_sensitive) { return true; }
                }

                CharRange(start, end) =>
                {
                    if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii()
                    {
                        let start = start.to_ascii_lowercase();
                        let end = end.to_ascii_lowercase();
                        let start_up = start.to_uppercase().next().unwrap();
                        let end_up = end.to_uppercase().next().unwrap();
                        
                        if start != start_up && end != end_up
                        {
                            let c = c.to_ascii_lowercase();
                            if c >= start && c <= end { return true; }
                        }
                    }

                    if c >= start && c <= end { return true; }
                }
            }
        }

        false
    }
    /// A helper function to determine if two chars are (possibly case-insensitively) equal.
    fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool
    {
        if cfg!(windows) && path::is_separator(a) && path::is_separator(b) { true }
        else if !case_sensitive && a.is_ascii() && b.is_ascii() { a.eq_ignore_ascii_case(&b) }
        else { a == b }
    }
    /// Configuration options to modify the behaviour of `Pattern::matches_with(..)`.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    pub struct MatchOptions
    {
        /// Whether or not patterns should be matched in a case-sensitive manner.
        pub case_sensitive: bool,
        /// Whether or not path-component separator characters must be matched by a literal `/`,
        /// rather than by `*` or `?` or `[...]`.
        pub require_literal_separator: bool,
        /// Whether or not paths that contain components that start with a `.` will require that `.`
        /// appears literally in the pattern; `*`, `?`, `**`, or `[...]` will not match.
        pub require_literal_leading_dot: bool,
    }

    impl MatchOptions
    {
        /// Constructs a new `MatchOptions` with default field values.
        pub fn new() -> Self
        {
            Self
            {
                case_sensitive: true,
                require_literal_separator: false,
                require_literal_leading_dot: false,
            }
        }
    }
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod history
{
    use ::
    {
        collections::{ HashMap },
        database::{ Database, Connection },
        path::{ Path },
        shell::{ Shell },
        system::{ DefaultTerminal, Interface },
        *,
    };
    // pub fn init(rl: &mut Interface<DefaultTerminal>  )
    pub fn initialize(rl: &mut Interface<DefaultTerminal>)
    {
        let mut hist_size: usize = 99999;

        if let Ok(x) = env::var("HISTORY_SIZE")
        {
            if let Ok(y) = x.parse::<usize>() { hist_size = y; }
        }

        rl.set_history_size(hist_size);

        let history_table = get_table();
        let hfile = get_file();

        if !Path::new(&hfile).exists()
        {
            ::database::initialize(&hfile, &history_table);
        }

        let mut delete_dups = true;

        if let Ok(x) = env::var("HISTORY_DELETE_DUPS")
        {
            if x == "0" { delete_dups = false; }
        }
        
        if delete_dups
        {
            deduplicate();
        }

        let conn = match Connection::open(&hfile)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let query = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
        let mut stmt = match conn.prepare(&query)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: prepare select error: {}", e);
                return;
            }
        };

        let rows = match stmt.query_map([], |row| row.get(0))
        {
            Ok(x) => x,
            Err(e) => 
            {
                println_stderr!("cicada: query select error: {}", e);
                return;
            }
        };

        let mut dict_helper: HashMap<String, bool> = HashMap::new();

        for x in rows.flatten()
        {
            let inp: String = x;

            if dict_helper.contains_key(&inp) { continue; }
            
            dict_helper.insert(inp.clone(), true);
            rl.add_history(inp.trim().to_string());
        }
    }
    // pub fn get_history_file() -> String 
    pub fn get_file() -> String 
    {
        if let Ok(hfile) = env::var("HISTORY_FILE") { hfile }
        
        else if let Ok(d) = env::var("XDG_DATA_HOME") { format!("{}/{}", d, "cicada/history.sqlite") }
        
        else
        {
            let home = get_user_home();
            format!("{}/{}", home, ".local/share/cicada/history.sqlite")
        }
    }
    // pub fn get_history_table() -> String
    pub fn get_table() -> String
    {
        if let Ok(hfile) = env::var("HISTORY_TABLE") { hfile }        
        else { String::from("cicada_history") }
    }
    // pub fn delete_duplicated_histories()
    pub fn deduplicate()
    {
        let hfile = get_file();
        let history_table = get_table();
        let conn = match Connection::open(&hfile)
        {
            Ok(x) => x,
            Err(e) => 
            {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };

        let query = format!
        (
            "DELETE FROM {} WHERE rowid NOT IN (SELECT MAX(rowid) FROM {} GROUP BY inp)",
            history_table, history_table
        );
        /*match conn.execute(&query, [])
        {
            Ok(_) => {}
            Err(e) => match e
            {
                SqliteFailure(ee, msg) => {
                    if ee.extended_code == 5 {
                        log!(
                            "failed to delete dup histories: {}",
                            msg.unwrap_or("db is locked?".to_owned()),
                        );
                        return;
                    }
                    println_stderr!(
                        "cicada: history: delete dups error: {}: {:?}",
                        &ee,
                        &msg
                    );
                }
                _ => {
                    println_stderr!("cicada: history: delete dup error: {}", e);
                }
            },
        } */
    }
    // pub fn add_raw(sh: &shell::Shell, line: &str, status: i32, tsb: f64, tse: f64)
    pub fn add(sh: &shell::Shell, line: &str, status: i32, tsb: f64, tse: f64)
    {
        let hfile = get_file();
        let history_table = get_table();
        
        if !Path::new(&hfile).exists()
        {
            database::initialize(&hfile, &history_table);
        }

        let conn = match Connection::open(&hfile) 
        {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        
        let sql = format!
        (
            "INSERT INTO \
            {} (inp, rtn, tsb, tse, sessionid, info) \
            VALUES('{}', {}, {}, {}, '{}', 'dir:{}|');",
            history_table,
            str::replace(line.trim(), "'", "''"),
            status,
            tsb,
            tse,
            sh.session_id,
            sh.current_dir,
        );
        
        match conn.execute(&sql, [])
        {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: save error: {}", e),
        }
    }
    // pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str, status: i32, tsb: f64, tse: f64)
    pub fn append(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str, status: i32, tsb: f64, tse: f64)
    {
        add( sh, line, status, tsb, tse );
        rl.add_history(line.to_string());
    }
    // pub fn add_history(sh: &Shell, ts: f64, input: &str) 
    pub fn insert(sh: &Shell, ts: f64, input: &str) 
    {
        let (tsb, tse) = (ts, ts + 1.0);
        add(sh, input, 0, tsb, tse);
    }
    // pub fn list_current_history(sh: &Shell, cx: &Connection, opt: &OptMain) -> (String, String) //
    pub fn list( sh: &Shell, cx: &Connection ) -> ( String, String )
    {
        /*
            let mut result_stderr = String::new();
            let result_stdout = String::new();

            let history_table = get_table();
            let mut sql = format!("SELECT ROWID, inp, tsb FROM {} WHERE ROWID > 0", history_table);
            if !opt.pattern.is_empty() {
                sql = format!("{} AND inp LIKE '%{}%'", sql, opt.pattern)
            }

            if opt.session {
                sql = format!("{} AND sessionid = '{}'", sql, sh.session_id)
            }
            if opt.pwd {
                sql = format!("{} AND info like '%dir:{}|%'", sql, sh.current_dir)
            }

            if opt.asc {
                sql = format!("{} ORDER BY tsb", sql);
            } else {
                sql = format!("{} order by tsb desc", sql);
            };

            sql = format!("{} limit {} ", sql, opt.limit);

            let mut stmt = match cx.prepare(&sql) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: prepare select error: {:?}", e);
                    result_stderr.push_str(&info);
                    return (result_stdout, result_stderr);
                }
            };

            let mut rows = match stmt.query([]) {
                Ok(x) => x,
                Err(e) => {
                    let info = format!("history: query error: {:?}", e);
                    result_stderr.push_str(&info);
                    return (result_stdout, result_stderr);
                }
            };

            let mut lines = Vec::new();
            loop 
            {
                match rows.next() 
                {
                    Ok(_rows) => 
                    {
                        if let Some(row) = _rows {
                            let row_id: i32 = match row.get(0) {
                                Ok(x) => x,
                                Err(e) => {
                                    let info = format!("history: error: {:?}", e);
                                    result_stderr.push_str(&info);
                                    return (result_stdout, result_stderr);
                                }
                            };
                            let inp: String = match row.get(1) {
                                Ok(x) => x,
                                Err(e) => {
                                    let info = format!("history: error: {:?}", e);
                                    result_stderr.push_str(&info);
                                    return (result_stdout, result_stderr);
                                }
                            };

                            if opt.no_id {
                                lines.push(inp.to_string());
                            } else if opt.only_id {
                                lines.push(row_id.to_string());
                            } else if opt.show_date {
                                let tsb: f64 = match row.get(2) {
                                    Ok(x) => x,
                                    Err(e) => {
                                        let info = format!("history: error: {:?}", e);
                                        result_stderr.push_str(&info);
                                        return (result_stdout, result_stderr);
                                    }
                                };
                                let dt = time::DateTime::from_timestamp(tsb);
                                lines.push(format!("{}: {}: {}", row_id, dt, inp));
                            } else {
                                lines.push(format!("{}: {}", row_id, inp));
                            }
                        } else {
                            break;
                        }
                    }

                    Err(e) =>
                    {
                        let info = format!("history: rows next error: {:?}", e);
                        result_stderr.push_str(&info);
                        return (result_stdout, result_stderr);
                    }
                }
            }

            if !opt.asc { lines.reverse(); }

            let buffer = lines.join("\n");

            (buffer, result_stderr)
        */
        ( String::new(), String::new() )
    }
    // pub fn delete_history_item(conn: &Conn, rowid: usize) -> bool
    pub fn delete( cx:&Connection, rowid:usize ) -> bool
    {
        let history_table = history::get_table();
        let query = format!("DELETE from {} where rowid = {}", history_table, rowid);
        match cx.execute( &query, [] )
        {
            Ok(_) => true,
            Err(e) =>
            {
                log!("history: error when delete: {:?}", e);
                false
            }
        }
    }
}

pub mod io
{
    pub use std::io::{ * };
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod is
{
    use ::
    {
        ffi::{ OsString },
        path::{ PathBuf },
        regex::{ contains },
        *,
    };
    /*
    pub fn is_alphabetic(...) -> bool */
    /// Tests if byte is ASCII alphabetic: A-Z, a-z
    #[inline] pub fn alphabetic(chr: u8) -> bool { (chr >= 0x41 && chr <= 0x5A) || (chr >= 0x61 && chr <= 0x7A) }
    /*
    pub fn is_digit(...) -> bool */
    /// Tests if byte is ASCII digit: 0-9
    #[inline] pub fn digit(chr: u8) -> bool { chr >= 0x30 && chr <= 0x39 }
    /*
    pub fn is_hex_digit(...) -> bool */
    /// Tests if byte is ASCII hex digit: 0-9, A-F, a-f
    #[inline] pub fn hex_digit(chr: u8) -> bool 
    { (chr >= 0x30 && chr <= 0x39) || (chr >= 0x41 && chr <= 0x46) || (chr >= 0x61 && chr <= 0x66) }
    /*
    pub fn is_oct_digit(...) -> bool */
    /// Tests if byte is ASCII octal digit: 0-7
    #[inline] pub fn oct_digit(chr: u8) -> bool { chr >= 0x30 && chr <= 0x37 }
    /*
    pub fn is_alphanumeric(...) -> bool */
    /// Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9
    #[inline] pub fn alphanumeric(chr: u8) -> bool { alphabetic(chr) || digit(chr) }
    /*
    pub fn is_space(...) -> bool */
    /// Tests if byte is ASCII space or tab
    #[inline] pub fn space(chr: u8) -> bool { chr == b' ' || chr == b'\t' }
    /*
    pub fn is_newline(...) -> bool */
    /// Tests if byte is ASCII newline: \n
    #[inline] pub fn newline(chr: u8) -> bool { chr == b'\n' }
    /*
    pub fn is_value_end_char(...) -> bool */
    /// Returns true if this character signifies the legal end of a value.
    pub fn value_end_char(ch: char) -> bool { whitespace(ch) || end_delimiter(ch) || operator(ch) }
    /*
    pub fn is_whitespace(...) -> bool */
    /// Returns true if the character is either whitespace or '#' (start of a comment).
    pub fn whitespace(ch: char) -> bool 
    {
        ch.is_whitespace() || ch == '#'
    }
    /*
    pub fn is_end_delimiter(...) -> bool */
    pub fn end_delimiter(ch: char) -> bool 
    {
        match ch {
            ')' | ']' | '}' | '>' => true,
            _ => false,
        }
    }
    /*
    pub fn is_numeric_char(...) -> bool */
    pub fn numeric_char(ch: char) -> bool 
    {
        match ch {
            _ch if is::char_digit(_ch) => true,
            '.' | ',' => true,
            _ => false,
        }
    }
    /*
    pub fn is_priority_operator(...) -> bool */
    pub fn priority_operator(ch: char) -> bool 
    {
        match ch {
            '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /*
    pub fn is_operator(...) -> bool */
    pub fn operator(ch: char) -> bool
    {
        match ch {
            '+' | '-' | '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /*
    pub fn is_reserved(...) -> bool */
    pub fn reserved(field: &str) -> bool 
    {
        match field {
            "@" | "null" | "true" | "false" | "Obj" | "Str" | "Arr" | "Tup" => true,
            _ => false,
        }
    }
    /*
    pub fn is_digit(...) -> bool */
    /// Returns true if `ch` is an ASCII decimal digit.
    pub fn char_digit(ch: char) -> bool
    {
        match ch
        {
            '0'..='9' => true,
            _ => false,
        }
    }
    /*
    pub fn is_combining_mark(ch: char) -> bool */
    /// Returns whether the given character is a combining mark.
    #[inline] pub fn combining_mark(ch: char) -> bool
    {
        use unicode_normalization::char::is_combining_mark;
        is_combining_mark(ch)
    }
    /*
    pub fn is_visible(ch: char) -> bool */
    pub fn visible(ch: char) -> bool
    {
        match ch
        {
            '\t' | '\r' | '\n' => true,
            _ => char::width(ch).unwrap_or(0) != 0
        }
    }
    /*
    pub fn is_ctrl(...) -> bool */
    /// Returns whether the given character is a control character.
    #[inline] pub fn ctrl(ch: char) -> bool
    {
        let ch = ch as u32;
        ch & ( 0x1f as u32 ) == ch
    }
    /*
    pub fn is_absolute_path(...) -> Option<PathBuf> */
    pub fn absolute_path( path:OsString ) -> Option<PathBuf>
    {
        let path = PathBuf::from(path);
        
        if path.is_absolute() { Some(path) }
        else { None }
    }
    /*
    pub fn is_printable(c: char) -> bool */
    /// Returns whether the character is printable.
    pub fn printable(c: char) -> bool { c == '\t' || c == '\n' || !(c == '\0' || is::ctrl(c)) }
    /*
    fn is_flag(...) -> bool */
    pub fn flag(i: u8) -> bool { i == b' ' || i == b'-' || i == b'+' || i == b'#' }
    /*
    fn is_wide(...) -> bool */
    pub fn wide( ch:char ) -> bool { ::char::width(ch) == Some(2) }
    /*
    fn is_env(...) -> bool */
    pub fn env(line: &str) -> bool { contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$") }
    /*
    fn is_arithmetic(...) -> bool */
    pub fn arithmetic(line: &str) -> bool
    {
        match true
        {
            true if !contains(line, r"[0-9]+") => { return false; }
            true if !contains(line, r"\+|\-|\*|/|\^") => { return false; }
            _ =>{ return contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$"); }
        }
    }
    /*
    fn is_builtin(...) -> bool */
    pub fn builtin(s: &str) -> bool
    {
        let builtins =
        [
            "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg", "history", "jobs", "read", "source", 
            "ulimit", "unalias", "vox", "minfd", "set", "unset", "unpath",
        ];

        builtins.contains(&s)
    }
    /*
    fn is_shell_altering_command(...) -> bool */
    pub fn shell_altering_command(line: &str) -> bool
    {
        let line = line.trim();

        if contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") { return true; }

        line.starts_with("alias ")
        || line.starts_with("export ")
        || line.starts_with("unalias ")
        || line.starts_with("unset ")
        || line.starts_with("source ")
    }
    /*
    pub fn unquote(s: &str) -> String
    {
        let args = parsers::line::line_to_plain_tokens(s);
        if args.is_empty() {
            return String::new();
        }
        args[0].clone()
    }

    
    */
}
/*
libc */
pub mod libc
{
    //! libc - Raw FFI bindings to platforms' system libraries
    pub mod primitives
    {
        //! This module contains type aliases for C's platform-specific types and fixed-width integer types.
        use ::
        {
            *,
        };

        pub type c_schar = i8;
        pub type c_uchar = u8;
        pub type c_short = i16;
        pub type c_ushort = u16;

        pub type c_longlong = i64;
        pub type c_ulonglong = u64;

        pub type c_float = f32;
        pub type c_double = f64;
        
        pub type c_char = i8;
        
        pub type c_int = i32;
        pub type c_uint = u32;

        pub type c_long = i32;
        pub type c_ulong = u32;

    } pub use self::primitives::{ * };

    pub mod jobs
    {
        use ::
        {
            io::
            {
                Write as _,
            },
            nix::
            {
                sys::
                {
                    signal::Signal,
                    wait::waitpid,
                    wait::WaitPidFlag as WF,
                    wait::WaitStatus as WS,
                },
                unistd::{ Pid },
            },
            types::{ * },
            *,
        };
        // pub fn get_job_line(job: &types::Job, trim: bool) -> String
        pub fn get_line( job:&Job, trim:bool ) -> String
        {
            let mut cmd = job.cmd.clone();
            if trim && cmd.len() > 50 {
                cmd.truncate(50);
                cmd.push_str(" ...");
            }
            let _cmd = if job.is_bg && job.status == "Running" {
                format!("{} &", cmd)
            } else {
                cmd
            };
            format!("[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd)
        }
        // pub fn print_job(job: &types::Job)
        pub fn print( job:&Job )
        {
            let line = get_line(job, true);
            println_stderr!("{}", line);
        }
        // pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str)
        pub fn mark_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str)
        {
            if let Some(mut job) = sh.remove_pid_from_job(gid, pid)
            {
                job.status = reason.to_string();
                if job.is_bg
                {
                    println_stderr!("");
                    print( &job );
                }
            }
        }
        // pub fn mark_job_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool)
        pub fn mark_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool)
        {
            sh.mark_job_as_stopped(gid);
            
            if !report { return; }
            
            if let Some(job) = sh.get_job_by_gid(gid)
            {
                println_stderr!("");
                print(job);
            }
        }
        // pub fn mark_job_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool)
        pub fn mark_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool)
        {
            let _gid = if gid == 0 { unsafe { libc::getpgid(pid) } }
            else { gid };

            if let Some(job) = sh.mark_job_member_stopped(pid, gid)
            {
                if job.all_members_stopped() { mark_as_stopped(sh, gid, report); }
            }
        }
        // pub fn mark_job_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32)
        pub fn mark_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32)
        {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid(pid) }
            } else {
                gid
            };

            if let Some(job) = sh.mark_job_member_continued(pid, gid)
            {
                if job.all_members_running()
                {
                    mark_as_running(sh, gid, true);
                }
            }
        }
        // pub fn mark_job_as_running(sh: &mut shell::Shell, gid: i32, bg: bool)
        pub fn mark_as_running(sh: &mut shell::Shell, gid: i32, bg: bool)
        {
            sh.mark_job_as_running(gid, bg);
        }
        
        pub fn waitpidx(wpid: i32, block: bool) -> types::WaitStatus
        {
            let options = if block {
                Some(WF::WUNTRACED | WF::WCONTINUED)
            } else {
                Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
            };
            match waitpid(Pid::from_raw(wpid), options) {
                Ok(WS::Exited(pid, status)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_exited(pid, status)
                }
                Ok(WS::Stopped(pid, sig)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_stopped(pid, sig as i32)
                }
                Ok(WS::Continued(pid)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_continuted(pid)
                }
                Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_signaled(pid, sig as i32)
                }
                Ok(WS::StillAlive) => {
                    types::WaitStatus::empty()
                }
                Ok(_others) => {
                    types::WaitStatus::from_others()
                }
                Err(e) => {
                    types::WaitStatus::from_error(e as i32)
                }
            }
        }
        // pub fn wait_fg_job(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult
        pub fn wait_fg(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult
        {
            let mut cmd_result = CommandResult::new();
            let mut count_waited = 0;
            let count_child = pids.len();

            if count_child == 0 { return cmd_result; }
            
            let pid_last = pids.last().unwrap();

            loop
            {
                let ws = waitpidx(-1, true);
                
                if ws.is_error()
                {
                    let err = ws.get_errno();

                    if err == nix::Error::ECHILD { break; }

                    log!("jobc unexpected waitpid error: {}", err);
                    cmd_result = CommandResult::from_status(gid, err as i32);
                    break;
                }

                let pid = ws.get_pid();
                let is_a_fg_child = pids.contains(&pid);

                if is_a_fg_child && !ws.is_continued() { count_waited += 1; }

                if ws.is_exited()
                {
                    if is_a_fg_child
                    {
                        mark_as_done(sh, gid, pid, "Done");
                    }

                    else
                    {
                        let status = ws.get_status();
                        signals::insert_reap_map(pid, status);
                    }
                }
                
                else if ws.is_stopped()
                {
                    if is_a_fg_child
                    {
                        mark_member_stopped(sh, pid, gid, true);
                    }

                    else
                    {
                        signals::insert_stopped_map(pid);
                        mark_member_stopped(sh, pid, 0, false);
                    }
                }
                
                else if ws.is_continued()
                {
                    if !is_a_fg_child { signals::insert_cont_map(pid); }
                    continue;
                }

                else if ws.is_signaled()
                {
                    if is_a_fg_child { mark_as_done(sh, gid, pid, "Killed"); }
                    else
                    {
                        signals::killed_map_insert(pid, ws.get_signal());
                    }
                }

                if is_a_fg_child && pid == *pid_last
                {
                    let status = ws.get_status();
                    cmd_result.status = status;
                }

                if count_waited >= count_child { break; }
            }

            cmd_result
        }
        // pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool)
        pub fn try_wait_bg( sh: &mut shell::Shell, report: bool, sig_handler_enabled:bool )
        {
            if sh.jobs.is_empty() { return; }

            if !sig_handler_enabled { signals::handle_sigchld(Signal::SIGCHLD as i32); }

            let jobs = sh.jobs.clone();

            for (_i, job) in jobs.iter()
            {
                for pid in job.pids.iter()
                {
                    if let Some(_status) = signals::pop_reap_map(*pid)
                    {
                        mark_as_done(sh, job.gid, *pid, "Done");
                        continue;
                    }

                    if let Some(sig) = signals::killed_map_pop(*pid)
                    {
                        let reason = if sig == Signal::SIGQUIT as i32
                        {
                            format!("Quit: {}", sig)
                        }
                        
                        else if sig == Signal::SIGINT as i32
                        {
                            format!("Interrupt: {}", sig)
                        }
                        
                        else if sig == Signal::SIGKILL as i32
                        {
                            format!("Killed: {}", sig)
                        }
                        
                        else if sig == Signal::SIGTERM as i32
                        {
                            format!("Terminated: {}", sig)
                        }
                        
                        else
                        {
                            format!("Killed: {}", sig)
                        };

                        mark_as_done(sh, job.gid, *pid, &reason);
                        continue;
                    }

                    if signals::pop_stopped_map(*pid) {
                        mark_member_stopped(sh, *pid, job.gid, report);
                    } else if signals::pop_cont_map(*pid) {
                        mark_member_continued(sh, *pid, job.gid);
                    }
                }
            }
        }
    }
    
    pub mod unix
    {
        use ::
        {
            ffi::{ * },
            *,
        };
        
        pub type intmax_t = i64;
        pub type uintmax_t = u64;
        pub type size_t = usize;
        pub type ptrdiff_t = isize;
        pub type intptr_t = isize;
        pub type uintptr_t = usize;
        pub type ssize_t = isize;
        pub type pid_t = i32;
        pub type in_addr_t = u32;
        pub type in_port_t = u16;
        pub type sighandler_t = size_t;
        pub type cc_t = c_uchar;
        pub type tcflag_t = c_uint;        
        pub type uid_t = u32;
        pub type gid_t = u32;
        pub const NCCS: usize = 32;

        
        pub const STDIN_FILENO: c_int = 0;
        pub const STDOUT_FILENO: c_int = 1;
        pub const STDERR_FILENO: c_int = 2;
        
        pub const TIOCGWINSZ: c_int = 0x5401;
        pub const TIOCSWINSZ: c_int = 0x5402;
        pub const TIOCLINUX: c_int = 0x5403;
        pub const TIOCGPGRP: c_int = 0x540f;
        pub const TIOCSPGRP: c_int = 0x5410;

        pub const _SC_GETPW_R_SIZE_MAX: c_int = 51;
        
        #[repr(C)]
        pub struct passwd
        {
            pub pw_name: *mut c_char,
            pub pw_passwd: *mut c_char,
            pub pw_uid: uid_t,
            pub pw_gid: gid_t,
            pub pw_gecos: *mut c_char,
            pub pw_dir: *mut c_char,
            pub pw_shell: *mut c_char,
        }

        extern "C"
        {
            pub fn ioctl( fd:c_int, request:c_int, ... ) -> c_int;
            pub fn sysconf( name:c_int ) -> c_long;
            pub fn getopt(argc: c_int, argv: *const *mut c_char, optstr: *const c_char) -> c_int;
            pub fn getpgid(pid: pid_t) -> pid_t;
            pub fn getpgrp() -> pid_t;
            pub fn getpid() -> pid_t;
            pub fn getppid() -> pid_t;
            pub fn getuid() -> uid_t;
            pub fn isatty(fd: c_int) -> c_int;
            pub fn getpwuid_r
            (
                uid: uid_t,
                pwd: *mut passwd,
                buf: *mut c_char,
                buflen: size_t,
                result: *mut *mut passwd,
            ) -> c_int;
        }

        pub struct termios
        {
            pub c_iflag: tcflag_t,
            pub c_oflag: tcflag_t,
            pub c_cflag: tcflag_t,
            pub c_lflag: tcflag_t,
            pub c_line: cc_t,
            pub c_cc: [cc_t; NCCS],
        }

    } #[cfg(unix)] pub use self::unix::*;

    pub mod windows
    {
        use ::
        {
            ffi::{ OsStr },
            os::
            {
                raw::{ c_void },
            },
            *,
        };

        pub mod constants
        {
            use super::{ * };

            pub const S_OK: HRESULT = 0;
            pub const S_FALSE: HRESULT = 1;
            pub const MAX_PATH: usize = 260;
            pub const FALSE: BOOL = 0;
            pub const TRUE: BOOL = 1;
            pub const INFINITE: DWORD = 0xFFFFFFFF;            
            pub const RIGHT_ALT_PRESSED: DWORD = 0x0001;
            pub const LEFT_ALT_PRESSED: DWORD = 0x0002;
            pub const RIGHT_CTRL_PRESSED: DWORD = 0x0004;
            pub const LEFT_CTRL_PRESSED: DWORD = 0x0008;
            pub const SHIFT_PRESSED: DWORD = 0x0010;
            pub const NUMLOCK_ON: DWORD = 0x0020;
            pub const SCROLLLOCK_ON: DWORD = 0x0040;
            pub const CAPSLOCK_ON: DWORD = 0x0080;
            pub const ENHANCED_KEY: DWORD = 0x0100;
            pub const NLS_DBCSCHAR: DWORD = 0x00010000;
            pub const NLS_ALPHANUMERIC: DWORD = 0x00000000;
            pub const NLS_KATAKANA: DWORD = 0x00020000;
            pub const NLS_HIRAGANA: DWORD = 0x00040000;
            pub const NLS_ROMAN: DWORD = 0x00400000;
            pub const NLS_IME_CONVERSION: DWORD = 0x00800000;
            pub const NLS_IME_DISABLE: DWORD = 0x20000000;
            pub const CTRL_C_EVENT: DWORD = 0;
            pub const CTRL_BREAK_EVENT: DWORD = 1;
            pub const CTRL_CLOSE_EVENT: DWORD = 2;
            pub const CTRL_LOGOFF_EVENT: DWORD = 5;
            pub const CTRL_SHUTDOWN_EVENT: DWORD = 6;
            pub const ENABLE_PROCESSED_INPUT: DWORD = 0x0001;
            pub const ENABLE_LINE_INPUT: DWORD = 0x0002;
            pub const ENABLE_ECHO_INPUT: DWORD = 0x0004;
            pub const ENABLE_WINDOW_INPUT: DWORD = 0x0008;
            pub const ENABLE_MOUSE_INPUT: DWORD = 0x0010;
            pub const ENABLE_INSERT_MODE: DWORD = 0x0020;
            pub const ENABLE_QUICK_EDIT_MODE: DWORD = 0x0040;
            pub const ENABLE_EXTENDED_FLAGS: DWORD = 0x0080;
            pub const ENABLE_AUTO_POSITION: DWORD = 0x0100;
            pub const ENABLE_VIRTUAL_TERMINAL_INPUT: DWORD = 0x0200;
            pub const ENABLE_PROCESSED_OUTPUT: DWORD = 0x0001;
            pub const ENABLE_WRAP_AT_EOL_OUTPUT: DWORD = 0x0002;
            pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING: DWORD = 0x0004;
            pub const DISABLE_NEWLINE_AUTO_RETURN: DWORD = 0x0008;
            pub const ENABLE_LVB_GRID_WORLDWIDE: DWORD = 0x0010;
            pub const MAXIMUM_PROC_PER_GROUP: UCHAR = 64;
            pub const MAXIMUM_PROCESSORS: UCHAR = MAXIMUM_PROC_PER_GROUP;
            pub const OBJ_HANDLE_TAGBITS: usize = 0x00000003;
            pub const SYSTEM_CACHE_ALIGNMENT_SIZE: usize = 128;
            pub const UCSCHAR_INVALID_CHARACTER: UCSCHAR = 0xffffffff;
            pub const MIN_UCSCHAR: UCSCHAR = 0;
            pub const MAX_UCSCHAR: UCSCHAR = 0x0010FFFF;
            pub const WAIT_TIMEOUT: DWORD = 258;
            pub const FILE_SHARE_READ: DWORD = 0x00000001;
            pub const FILE_SHARE_WRITE: DWORD = 0x00000002;
            pub const FILE_SHARE_DELETE: DWORD = 0x00000004;
            pub const CONSOLE_TEXTMODE_BUFFER: DWORD = 1;
            pub const DELETE: DWORD = 0x00010000;
            pub const READ_CONTROL: DWORD = 0x00020000;
            pub const WRITE_DAC: DWORD = 0x00040000;
            pub const WRITE_OWNER: DWORD = 0x00080000;
            pub const SYNCHRONIZE: DWORD = 0x00100000;
            pub const STANDARD_RIGHTS_REQUIRED: DWORD = 0x000F0000;
            pub const STANDARD_RIGHTS_READ: DWORD = READ_CONTROL;
            pub const STANDARD_RIGHTS_WRITE: DWORD = READ_CONTROL;
            pub const STANDARD_RIGHTS_EXECUTE: DWORD = READ_CONTROL;
            pub const STANDARD_RIGHTS_ALL: DWORD = 0x001F0000;
            pub const SPECIFIC_RIGHTS_ALL: DWORD = 0x0000FFFF;
            pub const ACCESS_SYSTEM_SECURITY: DWORD = 0x01000000;
            pub const MAXIMUM_ALLOWED: DWORD = 0x02000000;
            pub const GENERIC_READ: DWORD = 0x80000000;
            pub const GENERIC_WRITE: DWORD = 0x40000000;
            pub const GENERIC_EXECUTE: DWORD = 0x20000000;
            pub const GENERIC_ALL: DWORD = 0x10000000;
            pub const STD_INPUT_HANDLE: DWORD = -10i32 as u32;
            pub const STD_OUTPUT_HANDLE: DWORD = -11i32 as u32;
            pub const STD_ERROR_HANDLE: DWORD = -12i32 as u32;
            pub const FROM_LEFT_1ST_BUTTON_PRESSED: DWORD = 0x0001;
            pub const RIGHTMOST_BUTTON_PRESSED: DWORD = 0x0002;
            pub const FROM_LEFT_2ND_BUTTON_PRESSED: DWORD = 0x0004;
            pub const FROM_LEFT_3RD_BUTTON_PRESSED: DWORD = 0x0008;
            pub const FROM_LEFT_4TH_BUTTON_PRESSED: DWORD = 0x0010;
            pub const MOUSE_MOVED: DWORD = 0x0001;
            pub const DOUBLE_CLICK: DWORD = 0x0002;
            pub const MOUSE_WHEELED: DWORD = 0x0004;
            pub const MOUSE_HWHEELED: DWORD = 0x0008;
            pub const VK_LBUTTON: c_int = 0x01;
            pub const VK_RBUTTON: c_int = 0x02;
            pub const VK_CANCEL: c_int = 0x03;
            pub const VK_MBUTTON: c_int = 0x04;
            pub const VK_XBUTTON1: c_int = 0x05;
            pub const VK_XBUTTON2: c_int = 0x06;
            pub const VK_BACK: c_int = 0x08;
            pub const VK_TAB: c_int = 0x09;
            pub const VK_CLEAR: c_int = 0x0C;
            pub const VK_RETURN: c_int = 0x0D;
            pub const VK_SHIFT: c_int = 0x10;
            pub const VK_CONTROL: c_int = 0x11;
            pub const VK_MENU: c_int = 0x12;
            pub const VK_PAUSE: c_int = 0x13;
            pub const VK_CAPITAL: c_int = 0x14;
            pub const VK_KANA: c_int = 0x15;
            pub const VK_HANGEUL: c_int = 0x15;
            pub const VK_HANGUL: c_int = 0x15;
            pub const VK_JUNJA: c_int = 0x17;
            pub const VK_FINAL: c_int = 0x18;
            pub const VK_HANJA: c_int = 0x19;
            pub const VK_KANJI: c_int = 0x19;
            pub const VK_ESCAPE: c_int = 0x1B;
            pub const VK_CONVERT: c_int = 0x1C;
            pub const VK_NONCONVERT: c_int = 0x1D;
            pub const VK_ACCEPT: c_int = 0x1E;
            pub const VK_MODECHANGE: c_int = 0x1F;
            pub const VK_SPACE: c_int = 0x20;
            pub const VK_PRIOR: c_int = 0x21;
            pub const VK_NEXT: c_int = 0x22;
            pub const VK_END: c_int = 0x23;
            pub const VK_HOME: c_int = 0x24;
            pub const VK_LEFT: c_int = 0x25;
            pub const VK_UP: c_int = 0x26;
            pub const VK_RIGHT: c_int = 0x27;
            pub const VK_DOWN: c_int = 0x28;
            pub const VK_SELECT: c_int = 0x29;
            pub const VK_PRINT: c_int = 0x2A;
            pub const VK_EXECUTE: c_int = 0x2B;
            pub const VK_SNAPSHOT: c_int = 0x2C;
            pub const VK_INSERT: c_int = 0x2D;
            pub const VK_DELETE: c_int = 0x2E;
            pub const VK_HELP: c_int = 0x2F;
            pub const VK_LWIN: c_int = 0x5B;
            pub const VK_RWIN: c_int = 0x5C;
            pub const VK_APPS: c_int = 0x5D;
            pub const VK_SLEEP: c_int = 0x5F;
            pub const FOREGROUND_BLUE: WORD = 0x0001;
            pub const FOREGROUND_GREEN: WORD = 0x0002;
            pub const FOREGROUND_RED: WORD = 0x0004;
            pub const FOREGROUND_INTENSITY: WORD = 0x0008;
            pub const BACKGROUND_BLUE: WORD = 0x0010;
            pub const BACKGROUND_GREEN: WORD = 0x0020;
            pub const BACKGROUND_RED: WORD = 0x0040;
            pub const BACKGROUND_INTENSITY: WORD = 0x0080;
            pub const COMMON_LVB_LEADING_BYTE: WORD = 0x0100;
            pub const COMMON_LVB_TRAILING_BYTE: WORD = 0x0200;
            pub const COMMON_LVB_GRID_HORIZONTAL: WORD = 0x0400;
            pub const COMMON_LVB_GRID_LVERTICAL: WORD = 0x0800;
            pub const COMMON_LVB_GRID_RVERTICAL: WORD = 0x1000;
            pub const COMMON_LVB_REVERSE_VIDEO: WORD = 0x4000;
            pub const COMMON_LVB_UNDERSCORE: WORD = 0x8000;
            pub const COMMON_LVB_SBCSDBCS: WORD = 0x0300;
            pub const KEY_EVENT: WORD = 0x0001;
            pub const MOUSE_EVENT: WORD = 0x0002;
            pub const WINDOW_BUFFER_SIZE_EVENT: WORD = 0x0004;
            pub const MENU_EVENT: WORD = 0x0008;
            pub const FOCUS_EVENT: WORD = 0x0010;
            pub const ATTACH_PARENT_PROCESS: DWORD = 0xFFFFFFFF;
            pub const STATUS_USER_APC: NTSTATUS = 0x000000C0;
            pub const STATUS_WAIT_0: NTSTATUS = 0x00000000;
            pub const STATUS_ABANDONED_WAIT_0: NTSTATUS = 0x00000080;
            pub const WAIT_FAILED: DWORD = 0xFFFFFFFF;
            pub const WAIT_OBJECT_0: DWORD = STATUS_WAIT_0 as u32;
            pub const WAIT_ABANDONED: DWORD = STATUS_ABANDONED_WAIT_0 as u32;
            pub const WAIT_ABANDONED_0: DWORD = STATUS_ABANDONED_WAIT_0 as u32;
            pub const WAIT_IO_COMPLETION: DWORD = STATUS_USER_APC as u32;
            pub const FOLDERID_Profile:GUID = GUID::create( 0x5E6C858F, 0x0E22, 0x4760, [ 0x9A, 0xFE, 0xEA, 0x33, 0x17, 0xB6, 0x71, 0x73 ] );
            pub const FOLDERID_RoamingAppData:GUID = GUID::create( 0x3EB685DB, 0x65F9, 0x4CF6, [ 0xA0, 0x3A, 0xE3, 0xEF, 0x65, 0x72, 0x9F, 0x3D ] );
            pub const FOLDERID_LocalAppData:GUID = GUID::create( 0xF1B32785, 0x6FBA, 0x4FCF, [ 0x9D, 0x55, 0x7B, 0x8E, 0x7F, 0x15, 0x70, 0x91 ] );
            pub const FOLDERID_Music:GUID = GUID::create( 0x4BD8D571, 0x6D19, 0x48D3, [ 0xBE, 0x97, 0x42, 0x22, 0x20, 0x08, 0x0E, 0x43 ] );
            pub const FOLDERID_Desktop:GUID = GUID::create( 0xB4BFCC3A, 0xDB2C, 0x424C, [ 0xB0, 0x29, 0x7F, 0xE9, 0x9A, 0x87, 0xC6, 0x41 ] );
            pub const FOLDERID_Documents:GUID = GUID::create( 0xFDD39AD0, 0x238F, 0x46AF, [ 0xAD, 0xB4, 0x6C, 0x85, 0x48, 0x03, 0x69, 0xC7 ] );
            pub const FOLDERID_Downloads:GUID = GUID::create( 0x374de290, 0x123f, 0x4565, [ 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b ] );
            pub const FOLDERID_Pictures:GUID = GUID::create( 0xa990ae9f, 0xa03b, 0x4e80, [ 0x94, 0xbc, 0x99, 0x12, 0xd7, 0x50, 0x41, 0x4 ] );
            pub const FOLDERID_Public:GUID = GUID::create( 0xDFDF76A2, 0xC82A, 0x4D63, [ 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 ] );
            pub const FOLDERID_Templates:GUID = GUID::create( 0xA63293E8, 0x664E, 0x48DB, [ 0xA0, 0x79, 0xDF, 0x75, 0x9E, 0x05, 0x09, 0xF7 ] );
            pub const FOLDERID_Videos:GUID = GUID::create( 0x18989B1D, 0x99B5, 0x455B, [ 0xA0, 0x79, 0xDF, 0x75, 0x9E, 0x05, 0x09, 0xF7 ] );
            pub const MAXLONGLONG: LONGLONG = 0x7fffffffffffffff;
            pub const UTF8_REPLACEMENT_CHARACTER: &str = "\u{FFFD}";
            pub const FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;
            pub const FORMAT_MESSAGE_FROM_STRING: DWORD = 0x00000400;
            pub const FORMAT_MESSAGE_FROM_HMODULE: DWORD = 0x00000800;
            pub const FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;
            pub const FORMAT_MESSAGE_ARGUMENT_ARRAY: DWORD = 0x00002000;
            pub const FORMAT_MESSAGE_MAX_WIDTH_MASK: DWORD = 0x000000FF;
            pub const FORMAT_MESSAGE_ALLOCATE_BUFFER: DWORD = 0x00000100;
            
        } pub use self::constants::{ * };
        
        pub mod structs
        {
            use borrow::Cow;
            use sync::Arc;
            use rc::Rc;
            use ::hash::Hasher;
            use ::hash::Hash;
            use ::system::AsInner;
            use super::{ * };

            #[repr( C )]
            pub struct GROUP_AFFINITY 
            {
                Mask: KAFFINITY,
                Group: USHORT,
                Reserved: [USHORT; 3],
            }
            
            #[repr(C)] #[derive( Clone, Copy )]
            pub struct GUID
            {
                pub Data1: c_ulong,
                pub Data2: c_ushort,
                pub Data3: c_ushort,
                pub Data4: [c_uchar; 8],
            }

            impl GUID
            {
                pub const fn create( Data1:c_ulong, Data2:c_ushort, Data3:c_ushort, Data4:[c_uchar; 8] ) -> Self
                {
                    Self
                    {
                        Data1,
                        Data2,
                        Data3,
                        Data4,
                    }
                }

                pub fn folder_id_profile() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Profile )
                    }
                }

                pub fn folder_id_roaming_app_data() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_RoamingAppData )
                    }
                }

                pub fn folder_id_local_app_data() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_LocalAppData )
                    }
                }
                
                pub fn folder_id_music() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Music )
                    }
                }
                
                pub fn folder_id_desktop() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Desktop )
                    }
                }
                
                pub fn folder_id_documents() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Documents )
                    }
                }
                
                pub fn folder_id_downloads() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Downloads )
                    }
                }
                
                pub fn folder_id_pictures() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Pictures )
                    }
                }
                
                pub fn folder_id_public() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Public )
                    }
                }
                
                pub fn folder_id_templates() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Templates )
                    }
                }
                
                pub fn folder_id_videos() -> *const Self
                {
                    unsafe
                    {
                        ::mem::transmute( &FOLDERID_Videos )
                    }
                }
            }

            #[repr( C )] #[derive( Clone, Copy )]
            pub struct FLOAT128
            {
                pub LowPart: __int64,
                pub HighPart: __int64,
            }
            
            #[repr( C )] #[derive( Clone, Copy )]
            pub struct CONTEXT_u( () );

            #[repr( C )] #[derive( Clone, Copy )]
            pub struct M128A 
            {
                pub Low: ULONGLONG,
                pub High: LONGLONG,
            }

            #[repr( C )] #[derive( Clone, Copy )]
            pub struct CONTEXT 
            {
                pub P1Home: DWORD64,
                pub P2Home: DWORD64,
                pub P3Home: DWORD64,
                pub P4Home: DWORD64,
                pub P5Home: DWORD64,
                pub P6Home: DWORD64,
                pub ContextFlags: DWORD,
                pub MxCsr: DWORD,
                pub SegCs: WORD,
                pub SegDs: WORD,
                pub SegEs: WORD,
                pub SegFs: WORD,
                pub SegGs: WORD,
                pub SegSs: WORD,
                pub EFlags: DWORD,
                pub Dr0: DWORD64,
                pub Dr1: DWORD64,
                pub Dr2: DWORD64,
                pub Dr3: DWORD64,
                pub Dr6: DWORD64,
                pub Dr7: DWORD64,
                pub Rax: DWORD64,
                pub Rcx: DWORD64,
                pub Rdx: DWORD64,
                pub Rbx: DWORD64,
                pub Rsp: DWORD64,
                pub Rbp: DWORD64,
                pub Rsi: DWORD64,
                pub Rdi: DWORD64,
                pub R8: DWORD64,
                pub R9: DWORD64,
                pub R10: DWORD64,
                pub R11: DWORD64,
                pub R12: DWORD64,
                pub R13: DWORD64,
                pub R14: DWORD64,
                pub R15: DWORD64,
                pub Rip: DWORD64,
                pub u: CONTEXT_u,
                pub VectorRegister: [M128A; 26],
                pub VectorControl: DWORD64,
                pub DebugControl: DWORD64,
                pub LastBranchToRip: DWORD64,
                pub LastBranchFromRip: DWORD64,
                pub LastExceptionToRip: DWORD64,
                pub LastExceptionFromRip: DWORD64,
            }
            
            #[repr( C )] #[derive( Clone, Copy )]
            pub struct EXCEPTION_RECORD {
                pub ExceptionCode: DWORD,
                pub ExceptionFlags: DWORD,
                pub ExceptionRecord: *mut EXCEPTION_RECORD,
                pub ExceptionAddress: PVOID,
                pub NumberParameters: DWORD,
                pub ExceptionInformation: [ULONG_PTR; 15],
            }

            #[repr( C )] #[derive( Clone, Copy )]
            pub struct EXCEPTION_POINTERS {
                pub ExceptionRecord: PEXCEPTION_RECORD,
                pub ContextRecord: PCONTEXT,
            }

            #[repr( C )] #[derive( Clone, Copy )]
            pub struct CONSOLE_READCONSOLE_CONTROL
            {
                pub nLength: ULONG,
                pub nInitialChars: ULONG,
                pub dwCtrlWakeupMask: ULONG,
                pub dwControlKeyState: ULONG,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct WINDOW_BUFFER_SIZE_RECORD
            {
                pub dwSize: COORD,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct SECURITY_ATTRIBUTES
            {
                pub nLength: DWORD,
                pub lpSecurityDescriptor: LPVOID,
                pub bInheritHandle: BOOL,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CHAR_INFO_Char(()); 

            impl CHAR_INFO_Char
            {
                pub unsafe fn UnicodeChar_mut(&mut self) -> &mut WCHAR
                {
                    unsafe
                    {
                        mem::transmute( ptr::null_mut::<&mut WCHAR>() )
                    }
                }
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_FONT_INFO
            {
                pub nFont: DWORD,
                pub dwFontSize: COORD,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_FONT_INFOEX
            {
                pub cbSize: ULONG,
                pub nFont: DWORD,
                pub dwFontSize: COORD,
                pub FontFamily: UINT,
                pub FontWeight: UINT,
                pub FaceName: [WCHAR; 32],
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_SCREEN_BUFFER_INFOEX
            {
                pub cbSize: ULONG,
                pub dwSize: COORD,
                pub dwCursorPosition: COORD,
                pub wAttributes: WORD,
                pub srWindow: SMALL_RECT,
                pub dwMaximumWindowSize: COORD,
                pub wPopupAttributes: WORD,
                pub bFullscreenSupported: BOOL,
                pub ColorTable: [COLORREF; 16],
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct MOUSE_EVENT_RECORD
            {
                pub dwMousePosition: COORD,
                pub dwButtonState: DWORD,
                pub dwControlKeyState: DWORD,
                pub dwEventFlags: DWORD,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_HISTORY_INFO 
            {
                pub cbSize: UINT,
                pub HistoryBufferSize: UINT,
                pub NumberOfHistoryBuffers: UINT,
                pub dwFlags: DWORD,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_SELECTION_INFO
            {
                pub dwFlags: DWORD,
                pub dwSelectionAnchor: COORD,
                pub srSelection: SMALL_RECT,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_CURSOR_INFO
            {
                pub dwSize: DWORD,
                pub bVisible: BOOL,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct INPUT_RECORD_Event( () );

            impl INPUT_RECORD_Event
            {
                pub unsafe fn WindowBufferSizeEvent(&self) -> &WINDOW_BUFFER_SIZE_RECORD
                {
                    unsafe
                    {
                        mem::transmute( ptr::null::<&WINDOW_BUFFER_SIZE_RECORD>() )
                    }
                }
                
                pub unsafe fn KeyEvent(&self) -> &KEY_EVENT_RECORD
                {
                    unsafe
                    {
                        mem::transmute( ptr::null::<&KEY_EVENT_RECORD>() )
                    }
                }
                
                pub unsafe fn MouseEvent(&self) -> &MOUSE_EVENT_RECORD
                {
                    unsafe
                    {
                        mem::transmute( ptr::null::<&MOUSE_EVENT_RECORD>() )
                    }
                }
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct INPUT_RECORD 
            {
                pub EventType: WORD,
                pub Event: INPUT_RECORD_Event,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CHAR_INFO 
            {
                pub Char: CHAR_INFO_Char,
                pub Attributes: WORD,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct COORD
            {
                pub X: SHORT,
                pub Y: SHORT,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct SMALL_RECT
            {
                pub Left: SHORT,
                pub Top: SHORT,
                pub Right: SHORT,
                pub Bottom: SHORT,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct CONSOLE_SCREEN_BUFFER_INFO 
            {
                pub dwSize: COORD,
                pub dwCursorPosition: COORD,
                pub wAttributes: WORD,
                pub srWindow: SMALL_RECT,
                pub dwMaximumWindowSize: COORD,
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct KEY_EVENT_RECORD_uChar( () );

            impl KEY_EVENT_RECORD_uChar
            {
                pub unsafe fn UnicodeChar(&self) -> &WCHAR
                {
                    unsafe
                    {
                        mem::transmute( ptr::null::<&WCHAR>() )
                    }
                }
            }

            #[repr(C)] #[derive( Clone, Copy )]
            pub struct KEY_EVENT_RECORD
            {
                pub bKeyDown: BOOL,
                pub wRepeatCount: WORD,
                pub wVirtualKeyCode: WORD,
                pub wVirtualScanCode: WORD,
                pub uChar: KEY_EVENT_RECORD_uChar,
                pub dwControlKeyState: DWORD,
            }

            impl KEY_EVENT_RECORD
            {
                pub unsafe fn UnicodeChar(&self) -> &WCHAR
                {
                    unsafe
                    {
                        mem::transmute( ptr::null::<&WCHAR>() )
                    }
                }
            }
            /// A Unicode code point: from U+0000 to U+10FFFF.
            #[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]
            pub struct CodePoint
            {
                value: u32,
            }

            impl ::hash::Hash for CodePoint
            {
                #[inline] fn hash<H: ::hash::Hasher>(&self, state: &mut H) { self.value.hash(state) }
            }
            /// Iterator for the code points of a WTF-8 string.
            #[derive(Clone)]
            pub struct Wtf8CodePoints<'a>
            {
                pub bytes: slice::Iter<'a, u8>,
            }

            impl Iterator for Wtf8CodePoints<'_> 
            {
                type Item = CodePoint;

                #[inline] fn next(&mut self) -> Option<CodePoint>
                {
                    unsafe { str::next_code_point(&mut self.bytes).map(|c| CodePoint { value: c }) }
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>)
                {
                    let len = self.bytes.len();
                    (len.saturating_add(3) / 4, Some(len))
                }
            }
            /// Generates a wide character sequence for potentially ill-formed UTF-16.
            #[derive(Clone)]
            pub struct EncodeWide<'a>
            {
                pub code_points: Wtf8CodePoints<'a>,
                pub extra: u16,
            }

            impl Iterator for EncodeWide<'_>
            {
                type Item = u16;

                #[inline] fn next(&mut self) -> Option<u16> 
                {
                    if self.extra != 0 {
                        let tmp = self.extra;
                        self.extra = 0;
                        return Some(tmp);
                    }

                    let mut buf = [0; 2];
                    self.code_points.next().map(|code_point|
                    {
                        self.extra = buf[1];
                        buf[0]
                    })
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) 
                {
                    let (low, high) = self.code_points.size_hint();
                    let ext = (self.extra != 0) as usize;
                    (low + ext, high.and_then(|n| n.checked_mul(2)).and_then(|n| n.checked_add(ext)))
                }
            }
            
            impl ::iter::FusedIterator for EncodeWide<'_> {}
            /// An owned, growable string of well-formed WTF-8 data.
            #[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]
            pub struct Wtf8Buf
            {
                bytes: Vec<u8>,
                is_known_utf8: bool,
            }
            
            impl Hash for Wtf8Buf 
            {
                #[inline] fn hash<H:Hasher>( &self, state:&mut H )
                {
                    state.write(&self.bytes);
                    0xfeu8.hash(state)
                }
            }
            /// A borrowed slice of well-formed WTF-8 data.
            #[repr( transparent )] #[derive( Eq, Ord, PartialEq, PartialOrd )]
            pub struct Wtf8
            {
                pub bytes: [u8],
            }

            impl AsInner<[u8]> for Wtf8
            {
                #[inline] fn as_inner(&self) -> &[u8] { &self.bytes }
            }
            /// Formats the string in double quotes, with characters escaped according to [`char::escape_debug`]
            /// and unpaired surrogates represented as `\u{xxxx}`, where each `x` is a hexadecimal digit.
            impl fmt::Debug for Wtf8
            {
                fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fn write_str_escaped(f: &mut fmt::Formatter<'_>, s: &str) -> fmt::Result {
                        use crate::fmt::Write;
                        for c in s.chars().flat_map(|c| c.escape_debug()) {
                            f.write_char(c)?
                        }
                        Ok(())
                    }

                    formatter.write_str("\"")?;
                    let mut pos = 0;
                    while let Some((surrogate_pos, surrogate)) = self.next_surrogate(pos) {
                        write_str_escaped(formatter, unsafe {
                            str::from_utf8_unchecked(&self.bytes[pos..surrogate_pos])
                        })?;
                        write!(formatter, "\\u{{{:x}}}", surrogate)?;
                        pos = surrogate_pos + 3;
                    }
                    write_str_escaped(formatter, unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) })?;
                    formatter.write_str("\"")
                }
            }
            /// Formats the string with unpaired surrogates substituted with the replacement character, U+FFFD.
            impl fmt::Display for Wtf8
            {
                fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let wtf8_bytes = &self.bytes;
                    let mut pos = 0;
                    loop {
                        match self.next_surrogate(pos) {
                            Some((surrogate_pos, _)) => {
                                formatter.write_str(unsafe {
                                    str::from_utf8_unchecked(&wtf8_bytes[pos..surrogate_pos])
                                })?;
                                formatter.write_str(UTF8_REPLACEMENT_CHARACTER)?;
                                pos = surrogate_pos + 3;
                            }
                            None => {
                                let s = unsafe { str::from_utf8_unchecked(&wtf8_bytes[pos..]) };
                                if pos == 0 { return s.fmt(formatter) } else { return formatter.write_str(s) }
                            }
                        }
                    }
                }
            }

            impl Wtf8
            {
                /// Creates a WTF-8 slice from a UTF-8 `&str` slice.
                #[inline] pub fn from_str(value: &str) -> &Wtf8 
                {
                    unsafe { Wtf8::from_bytes_unchecked(value.as_bytes()) }
                }
                /// Creates a WTF-8 slice from a WTF-8 byte slice.
                #[inline] pub unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 
                {
                    unsafe { &*(value as *const [u8] as *const Wtf8) }
                }
                /// Creates a mutable WTF-8 slice from a mutable WTF-8 byte slice.
                #[inline] unsafe fn from_mut_bytes_unchecked(value: &mut [u8]) -> &mut Wtf8 
                {
                    unsafe { &mut *(value as *mut [u8] as *mut Wtf8) }
                }
                /// Returns the length, in WTF-8 bytes.
                #[inline] pub fn len(&self) -> usize 
                {
                    self.bytes.len()
                }

                #[inline] pub fn is_empty(&self) -> bool 
                {
                    self.bytes.is_empty()
                }
                /// Returns the code point at `position` if it is in the ASCII range, or `b'\xFF'` otherwise.
                #[inline] pub fn ascii_byte_at(&self, position: usize) -> u8 
                {
                    match self.bytes[position] {
                        ascii_byte @ 0x00..=0x7F => ascii_byte,
                        _ => 0xFF,
                    }
                }
                /// Returns an iterator for the strings code points.
                #[inline] pub fn code_points(&self) -> Wtf8CodePoints<'_> 
                {
                    Wtf8CodePoints { bytes: self.bytes.iter() }
                }
                /// Access raw bytes of WTF-8 data
                #[inline] pub fn as_bytes(&self) -> &[u8]
                {
                    &self.bytes
                }
                /// Tries to convert the string to UTF-8 and return a `&str` slice.
                #[inline] pub fn as_str(&self) -> Result<&str, str::Utf8Error> 
                {
                    str::from_utf8(&self.bytes)
                }
                /// Creates an owned `Wtf8Buf` from a borrowed `Wtf8`.
                pub fn to_owned(&self) -> Wtf8Buf
                {
                    Wtf8Buf { bytes: self.bytes.to_vec(), is_known_utf8: false }
                }
                /// Lossily converts the string to UTF-8.
                pub fn to_string_lossy(&self) -> Cow<'_, str> 
                {
                    let Some((surrogate_pos, _)) = self.next_surrogate(0) else {
                        return Cow::Borrowed(unsafe { str::from_utf8_unchecked(&self.bytes) });
                    };
                    let wtf8_bytes = &self.bytes;
                    let mut utf8_bytes = Vec::with_capacity(self.len());
                    utf8_bytes.extend_from_slice(&wtf8_bytes[..surrogate_pos]);
                    utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());
                    let mut pos = surrogate_pos + 3;
                    loop {
                        match self.next_surrogate(pos) {
                            Some((surrogate_pos, _)) => {
                                utf8_bytes.extend_from_slice(&wtf8_bytes[pos..surrogate_pos]);
                                utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());
                                pos = surrogate_pos + 3;
                            }
                            None => {
                                utf8_bytes.extend_from_slice(&wtf8_bytes[pos..]);
                                return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) });
                            }
                        }
                    }
                }
                /// Converts the WTF-8 string to potentially ill-formed UTF-16
                /// and return an iterator of 16-bit code units.
                #[inline] pub fn encode_wide(&self) -> EncodeWide<'_> 
                {
                    EncodeWide { code_points: self.code_points(), extra: 0 }
                }

                #[inline] fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> 
                {
                    let mut iter = self.bytes[pos..].iter();
                    loop 
                    {
                        let b = *iter.next()?;

                        if b < 0x80 
                        {
                            pos += 1;
                        }
                        
                        else if b < 0xE0 
                        {
                            iter.next();
                            pos += 2;
                        } 

                        else if b == 0xED 
                        {
                            match (iter.next(), iter.next()) {
                                (Some(&b2), Some(&b3)) if b2 >= 0xA0 => {
                                    return Some((pos, decode_surrogate(b2, b3)));
                                }
                                _ => pos += 3,
                            }
                        }

                        else if b < 0xF0 
                        {
                            iter.next();
                            iter.next();
                            pos += 3;
                        } 

                        else 
                        {
                            iter.next();
                            iter.next();
                            iter.next();
                            pos += 4;
                        }
                    }
                }

                #[inline] fn final_lead_surrogate(&self) -> Option<u16> 
                {
                    match self.bytes 
                    {
                        [.., 0xED, b2 @ 0xA0..=0xAF, b3] => Some(decode_surrogate(b2, b3)),
                        _ => None,
                    }
                }

                #[inline] fn initial_trail_surrogate(&self) -> Option<u16> 
                {
                    match self.bytes 
                    {
                        [0xED, b2 @ 0xB0..=0xBF, b3, ..] => Some(decode_surrogate(b2, b3)),
                        _ => None,
                    }
                }

                pub fn clone_into(&self, buf: &mut Wtf8Buf) 
                {
                    buf.is_known_utf8 = false;
                    self.bytes.clone_into(&mut buf.bytes);
                }
                /// Boxes this `Wtf8`.
                #[inline] pub fn into_box(&self) -> Box<Wtf8> 
                {
                    let boxed: Box<[u8]> = self.bytes.into();
                    unsafe { mem::transmute(boxed) }
                }
                /// Creates a boxed, empty `Wtf8`.
                pub fn empty_box() -> Box<Wtf8> 
                {
                    let boxed: Box<[u8]> = Default::default();
                    unsafe { mem::transmute(boxed) }
                }

                #[inline] pub fn into_arc(&self) -> Arc<Wtf8> 
                {
                    let arc: Arc<[u8]> = Arc::from(&self.bytes);
                    unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Wtf8) }
                }

                #[inline] pub fn into_rc(&self) -> Rc<Wtf8> 
                {
                    let rc: Rc<[u8]> = Rc::from(&self.bytes);
                    unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Wtf8) }
                }

                #[inline] pub fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }

                #[inline] pub fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }

                #[inline] pub fn to_ascii_lowercase(&self) -> Wtf8Buf 
                { Wtf8Buf { bytes: self.bytes.to_ascii_lowercase(), is_known_utf8: false } }

                #[inline] pub fn to_ascii_uppercase(&self) -> Wtf8Buf 
                { Wtf8Buf { bytes: self.bytes.to_ascii_uppercase(), is_known_utf8: false } }

                #[inline] pub fn is_ascii(&self) -> bool { self.bytes.is_ascii() }

                #[inline] pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool 
                { self.bytes.eq_ignore_ascii_case(&other.bytes) }
            }
            /// Returns a slice of the given string for the byte range \[`begin`..`end`).
            impl ops::Index<ops::Range<usize>> for Wtf8
            {
                type Output = Wtf8;

                #[inline] fn index(&self, range: ops::Range<usize>) -> &Wtf8
                {
                    if range.start <= range.end
                    && is_code_point_boundary(self, range.start)
                    && is_code_point_boundary(self, range.end)
                    { unsafe { slice_unchecked(self, range.start, range.end) } }
                    else { slice_error_fail(self, range.start, range.end) }
                }
            }
            /// Returns a slice of the given string from byte `begin` to its end.
            impl ops::Index<ops::RangeFrom<usize>> for Wtf8
            {
                type Output = Wtf8;

                #[inline] fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8
                {
                    if is_code_point_boundary(self, range.start) {
                        unsafe { slice_unchecked(self, range.start, self.len()) }
                    } else {
                        slice_error_fail(self, range.start, self.len())
                    }
                }
            }
            /// Returns a slice of the given string from its beginning to byte `end`.
            impl ops::Index<ops::RangeTo<usize>> for Wtf8
            {
                type Output = Wtf8;

                #[inline] fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8
                {
                    if is_code_point_boundary(self, range.end) {
                        unsafe { slice_unchecked(self, 0, range.end) }
                    } else {
                        slice_error_fail(self, 0, range.end)
                    }
                }
            }

            impl ops::Index<ops::RangeFull> for Wtf8
            {
                type Output = Wtf8;
                #[inline] fn index(&self, _range: ops::RangeFull) -> &Wtf8 { self }
            }

            impl Hash for Wtf8 
            {
                #[inline] fn hash<H: Hasher>(&self, state: &mut H) {
                    state.write(&self.bytes);
                    0xfeu8.hash(state)
                }
            }
            #[repr(transparent)]
            pub struct Slice
            {
                pub inner: Wtf8,
            }

            impl fmt::Debug for Slice 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Debug::fmt(&self.inner, f)
                }
            }

            impl fmt::Display for Slice
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Display::fmt(&self.inner, f)
                }
            }

        } pub use self::structs::{ * };

        pub mod traits
        {
            use super::{ * };

            use ::system::common::AsInner;
            
            pub trait OsStrExt
            {
                /// Re-encodes an `OsStr` as a wide character sequence. 
                fn encodes_wide( &self ) -> EncodeWide<'_>;
            }
            
            impl OsStrExt for OsStr
            {
                #[inline] fn encodes_wide(&self) -> EncodeWide<'_> { self.as_inner().inner.encode_wide() }
            }
            
            impl AsInner<Slice> for OsStr 
            {
                #[inline] fn as_inner(&self) -> &Slice { unsafe { ::mem::transmute( self ) } }
            }
        } pub use self::traits::{ * };
        
        pub mod types
        {
            use super::{ * };
            
            pub type c_char = i8;
            pub type c_schar = i8;
            pub type c_uchar = u8;
            pub type c_short = i16;
            pub type c_ushort = u16;
            pub type c_int = i32;
            pub type c_uint = u32;
            pub type c_long = i32;
            pub type c_ulong = u32;
            pub type c_longlong = i64;
            pub type c_ulonglong = u64;
            pub type c_float = f32;
            pub type c_double = f64;
            pub type __int8 = i8;
            pub type __uint8 = u8;
            pub type __int16 = i16;
            pub type __uint16 = u16;
            pub type __int32 = i32;
            pub type __uint32 = u32;
            pub type __int64 = i64;
            pub type __uint64 = u64;
            pub type wchar_t = u16;
            pub type ULONG = c_ulong;
            pub type PULONG = *mut ULONG;
            pub type USHORT = c_ushort;
            pub type PUSHORT = *mut USHORT;
            pub type UCHAR = c_uchar;
            pub type PUCHAR = *mut UCHAR;
            pub type PSZ = *mut c_char;
            pub type DWORD = c_ulong;
            pub type BOOL = c_int;
            pub type BYTE = c_uchar;
            pub type WORD = c_ushort;
            pub type FLOAT = c_float;
            pub type PFLOAT = *mut FLOAT;
            pub type PBOOL = *mut BOOL;
            pub type LPBOOL = *mut BOOL;
            pub type PBYTE = *mut BYTE;
            pub type LPBYTE = *mut BYTE;
            pub type PINT = *mut c_int;
            pub type LPINT = *mut c_int;
            pub type PWORD = *mut WORD;
            pub type LPWORD = *mut WORD;
            pub type LPLONG = *mut c_long;
            pub type PDWORD = *mut DWORD;
            pub type LPDWORD = *mut DWORD;
            pub type LPVOID = *mut c_void;
            pub type LPCVOID = *const c_void;
            pub type INT = c_int;
            pub type UINT = c_uint;
            pub type PUINT = *mut c_uint;
            pub type POINTER_64_INT = usize;
            pub type INT8 = c_schar;
            pub type PINT8 = *mut c_schar;
            pub type INT16 = c_short;
            pub type PINT16 = *mut c_short;
            pub type INT32 = c_int;
            pub type PINT32 = *mut c_int;
            pub type INT64 = __int64;
            pub type PINT64 = *mut __int64;
            pub type UINT8 = c_uchar;
            pub type PUINT8 = *mut c_uchar;
            pub type UINT16 = c_ushort;
            pub type PUINT16 = *mut c_ushort;
            pub type UINT32 = c_uint;
            pub type PUINT32 = *mut c_uint;
            pub type UINT64 = __uint64;
            pub type PUINT64 = *mut __uint64;
            pub type LONG32 = c_int;
            pub type PLONG32 = *mut c_int;
            pub type ULONG32 = c_uint;
            pub type PULONG32 = *mut c_uint;
            pub type DWORD32 = c_uint;
            pub type PDWORD32 = *mut c_uint;
            pub type INT_PTR = isize;
            pub type PINT_PTR = *mut isize;
            pub type UINT_PTR = usize;
            pub type PUINT_PTR = *mut usize;
            pub type LONG_PTR = isize;
            pub type PLONG_PTR = *mut isize;
            pub type ULONG_PTR = usize;
            pub type PULONG_PTR = *mut usize;
            pub type SHANDLE_PTR = isize;
            pub type HANDLE_PTR = usize;
            pub type WPARAM = UINT_PTR;
            pub type LPARAM = LONG_PTR;
            pub type LRESULT = LONG_PTR;
            #[cfg(target_pointer_width = "32")]
            pub type PHALF_PTR = *mut c_short;
            #[cfg(target_pointer_width = "64")]
            pub type PHALF_PTR = *mut c_int;
            pub type SIZE_T = ULONG_PTR;
            pub type PSIZE_T = *mut ULONG_PTR;
            pub type SSIZE_T = LONG_PTR;
            pub type PSSIZE_T = *mut LONG_PTR;
            pub type DWORD_PTR = ULONG_PTR;
            pub type PDWORD_PTR = *mut ULONG_PTR;
            pub type LONG64 = __int64;
            pub type PLONG64 = *mut __int64;
            pub type ULONG64 = __uint64;
            pub type PULONG64 = *mut __uint64;
            pub type DWORD64 = __uint64;
            pub type PDWORD64 = *mut __uint64;
            pub type KAFFINITY = ULONG_PTR;
            pub type PKAFFINITY = *mut KAFFINITY;
            pub type PKEY_EVENT_RECORD = *mut KEY_EVENT_RECORD;
            pub type PGROUP_AFFINITY = *mut GROUP_AFFINITY;
            pub type PLONGLONG = *mut LONGLONG;
            pub type PULONGLONG = *mut ULONGLONG;
            pub type USN = LONGLONG;
            pub type HANDLE = *mut c_void;
            pub type PHANDLE = *mut HANDLE;
            pub type FCHAR = UCHAR;
            pub type FSHORT = USHORT;
            pub type FLONG = ULONG;
            pub type HRESULT = c_long;        
            pub type CCHAR = c_char;
            pub type CSHORT = c_short;
            pub type CLONG = ULONG;
            pub type PCCHAR = *mut CCHAR;
            pub type PCSHORT = *mut CSHORT;
            pub type PCLONG = *mut CLONG;
            pub type LCID = ULONG;
            pub type PLCID = PULONG;
            pub type LANGID = USHORT;        
            pub type PVOID = *mut c_void;
            pub type PVOID64 = u64;
            pub type VOID = c_void;
            pub type CHAR = c_char;
            pub type SHORT = c_short;
            pub type LONG = c_long;
            pub type WCHAR = wchar_t;
            pub type PWCHAR = *mut WCHAR;
            pub type LPWCH = *mut WCHAR;
            pub type PWCH = *mut WCHAR;
            pub type LPCWCH = *const WCHAR;
            pub type PCWCH = *const WCHAR;
            pub type NWPSTR = *mut WCHAR;
            pub type LPWSTR = *mut WCHAR;
            pub type LPTSTR = LPSTR;
            pub type PWSTR = *mut WCHAR;
            pub type PZPWSTR = *mut PWSTR;
            pub type PCZPWSTR = *const PWSTR;
            pub type LPUWSTR = *mut WCHAR;
            pub type PUWSTR = *mut WCHAR;
            pub type LPCWSTR = *const WCHAR;
            pub type PCWSTR = *const WCHAR;
            pub type PZPCWSTR = *mut PCWSTR;
            pub type PCZPCWSTR = *const PCWSTR;
            pub type LPCUWSTR = *const WCHAR;
            pub type PCUWSTR = *const WCHAR;
            pub type PZZWSTR = *mut WCHAR;
            pub type PCZZWSTR = *const WCHAR;
            pub type PUZZWSTR = *mut WCHAR;
            pub type PCUZZWSTR = *const WCHAR;
            pub type PNZWCH = *mut WCHAR;
            pub type PCNZWCH = *const WCHAR;
            pub type PUNZWCH = *mut WCHAR;
            pub type PCUNZWCH = *const WCHAR;
            pub type LPCWCHAR = *const WCHAR;
            pub type PCWCHAR = *const WCHAR;
            pub type LPCUWCHAR = *const WCHAR;
            pub type PCUWCHAR = *const WCHAR;
            pub type UCSCHAR = c_ulong;
            pub type PUCSCHAR = *mut UCSCHAR;
            pub type PCUCSCHAR = *const UCSCHAR;
            pub type PUCSSTR = *mut UCSCHAR;
            pub type PUUCSSTR = *mut UCSCHAR;
            pub type PCUCSSTR = *const UCSCHAR;
            pub type PCUUCSSTR = *const UCSCHAR;
            pub type PUUCSCHAR = *mut UCSCHAR;
            pub type PCUUCSCHAR = *const UCSCHAR;
            pub type PCHAR = *mut CHAR;
            pub type LPCH = *mut CHAR;
            pub type PCH = *mut CHAR;
            pub type LPCCH = *const CHAR;
            pub type PCCH = *const CHAR;
            pub type NPSTR = *mut CHAR;
            pub type LPSTR = *mut CHAR;
            pub type PSTR = *mut CHAR;
            pub type PZPSTR = *mut PSTR;
            pub type PCZPSTR = *const PSTR;
            pub type LPCSTR = *const CHAR;
            pub type PCSTR = *const CHAR;
            pub type PZPCSTR = *mut PCSTR;
            pub type PCZPCSTR = *const PCSTR;
            pub type PZZSTR = *mut CHAR;
            pub type PCZZSTR = *const CHAR;
            pub type PNZCH = *mut CHAR;
            pub type PCNZCH = *const CHAR;
            pub type DOUBLE = c_double;
            pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;
            pub type PEXCEPTION_POINTERS = *mut EXCEPTION_POINTERS;
            pub type PACCESS_TOKEN = PVOID;
            pub type PSECURITY_DESCRIPTOR = PVOID;
            pub type PSID = PVOID;
            pub type PCLAIMS_BLOB = PVOID;
            pub type ACCESS_MASK = DWORD;
            pub type PACCESS_MASK = *mut ACCESS_MASK;
            pub type PMOUSE_EVENT_RECORD = *mut MOUSE_EVENT_RECORD;
            pub type PCONTEXT = *mut CONTEXT;
            pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
            pub type KNOWNFOLDERID = GUID;
            pub type REFKNOWNFOLDERID = *const KNOWNFOLDERID;
            pub type PHANDLER_ROUTINE = Option<unsafe extern "system" fn(CtrlType: DWORD) -> BOOL>;
            pub type NTSTATUS = LONG;
            pub type PCONSOLE_FONT_INFO = *mut CONSOLE_FONT_INFO;
            pub type PCONSOLE_FONT_INFOEX = *mut CONSOLE_FONT_INFOEX;
            pub type PCONSOLE_CURSOR_INFO = *mut CONSOLE_CURSOR_INFO;
            pub type PCONSOLE_SELECTION_INFO = *mut CONSOLE_SELECTION_INFO;
            pub type PCONSOLE_HISTORY_INFO = *mut CONSOLE_HISTORY_INFO;
            pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut CONSOLE_SCREEN_BUFFER_INFO;
            pub type PCONSOLE_SCREEN_BUFFER_INFOEX = *mut CONSOLE_SCREEN_BUFFER_INFOEX;
            pub type COLORREF = DWORD;
            pub type PINPUT_RECORD = *mut INPUT_RECORD;
            pub type PFLOAT128 = *mut FLOAT128;
            pub type LONGLONG = __int64;
            pub type ULONGLONG = __uint64;
            pub type va_list = *mut c_char;
            pub type WIN32_ERROR = u32;

        } pub use self::types::{ * };
        
        extern "system"
        {
            pub fn GetEnvironmentStrings() -> LPCH;
            pub fn GetEnvironmentStringsW() -> LPWCH;
            pub fn SetEnvironmentStringsW( NewEnvironment: LPWCH ) -> BOOL;
            pub fn FreeEnvironmentStringsA( penv: LPCH ) -> BOOL;
            pub fn FreeEnvironmentStringsW( penv: LPWCH ) -> BOOL;
            pub fn GetStdHandle( nStdHandle: DWORD ) -> HANDLE;
            pub fn SetStdHandle( nStdHandle: DWORD, hHandle: HANDLE ) -> BOOL;
            pub fn SetStdHandleEx( nStdHandle: DWORD, hHandle: HANDLE, phPrevValue: PHANDLE ) -> BOOL;
        
            pub fn GetConsoleScreenBufferInfo(
                hConsoleOutput: HANDLE,
                lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,
            ) -> BOOL;
            pub fn GetConsoleScreenBufferInfoEx(
                hConsoleOutput: HANDLE,
                lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
            ) -> BOOL;
            pub fn SetConsoleScreenBufferInfoEx(
                hConsoleOutput: HANDLE,
                lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
            ) -> BOOL;
            pub fn GetLargestConsoleWindowSize(
                hConsoleOutput: HANDLE,
            ) -> COORD;
            pub fn GetConsoleCursorInfo(
                hConsoleOutput: HANDLE,
                lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO,
            ) -> BOOL;
            pub fn GetCurrentConsoleFont(
                hConsoleOutput: HANDLE,
                bMaximumWindow: BOOL,
                lpConsoleCurrentFont: PCONSOLE_FONT_INFO,
            ) -> BOOL;
            pub fn GetCurrentConsoleFontEx(
                hConsoleOutput: HANDLE,
                bMaximumWindow: BOOL,
                lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
            ) -> BOOL;
            pub fn SetCurrentConsoleFontEx(
                hConsoleOutput: HANDLE,
                bMaximumWindow: BOOL,
                lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
            ) -> BOOL;
            pub fn GetConsoleHistoryInfo(
                lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO,
            ) -> BOOL;
            pub fn SetConsoleHistoryInfo(
                lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO,
            ) -> BOOL;
            pub fn GetConsoleFontSize(
                hConsoleOutput: HANDLE,
                nFont: DWORD,
            ) -> COORD;
            pub fn GetConsoleSelectionInfo(
                lpConsoleSelectionInfo: PCONSOLE_SELECTION_INFO,
            ) -> BOOL;
            pub fn GetNumberOfConsoleMouseButtons(
                lpNumberOfMouseButtons: LPDWORD,
            ) -> BOOL;
            pub fn SetConsoleActiveScreenBuffer(
                hConsoleOutput: HANDLE,
            ) -> BOOL;
            pub fn FlushConsoleInputBuffer(
                hConsoleInput: HANDLE,
            ) -> BOOL;
            pub fn SetConsoleScreenBufferSize(
                hConsoleOutput: HANDLE,
                dwSize: COORD,
            ) -> BOOL;
            pub fn SetConsoleCursorPosition(
                hConsoleOutput: HANDLE,
                dwCursorPosition: COORD,
            ) -> BOOL;
            pub fn SetConsoleCursorInfo(
                hConsoleOutput: HANDLE,
                lpConsoleCursorInfo: *const CONSOLE_CURSOR_INFO,
            ) -> BOOL;
            pub fn ScrollConsoleScreenBufferA(
                hConsoleOutput: HANDLE,
                lpScrollRectangle: *const SMALL_RECT,
                lpClipRectangle: *const SMALL_RECT,
                dwDestinationOrigin: COORD,
                lpFill: *const CHAR_INFO,
            ) -> BOOL;
            pub fn ScrollConsoleScreenBufferW(
                hConsoleOutput: HANDLE,
                lpScrollRectangle: *const SMALL_RECT,
                lpClipRectangle: *const SMALL_RECT,
                dwDestinationOrigin: COORD,
                lpFill: *const CHAR_INFO,
            ) -> BOOL;
            pub fn SetConsoleWindowInfo(
                hConsoleOutput: HANDLE,
                bAbsolute: BOOL,
                lpConsoleWindow: *const SMALL_RECT,
            ) -> BOOL;
            pub fn SetConsoleTextAttribute(
                hConsoleOutput: HANDLE,
                wAttributes: WORD,
            ) -> BOOL;
            pub fn GenerateConsoleCtrlEvent(
                dwCtrlEvent: DWORD,
                dwProcessGroupId: DWORD,
            ) -> BOOL;
            pub fn FreeConsole() -> BOOL;
            pub fn AttachConsole(
                dwProcessId: DWORD,
            ) -> BOOL;
            
            pub fn GetConsoleTitleA(
                lpConsoleTitle: LPSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn GetConsoleTitleW(
                lpConsoleTitle: LPWSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn GetConsoleOriginalTitleA(
                lpConsoleTitle: LPSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn GetConsoleOriginalTitleW(
                lpConsoleTitle: LPWSTR,
                nSize: DWORD,
            ) -> DWORD;
            pub fn SetConsoleTitleA(
                lpConsoleTitle: LPCSTR,
            ) -> BOOL;

            pub fn WriteConsoleInputW
            (
                hConsoleInput: HANDLE,
                lpBuffer: *const INPUT_RECORD,
                nLength: DWORD,
                lpNumberOfEventsWritten: LPDWORD,
            ) -> BOOL;

            pub fn CloseHandle(
                hObject: HANDLE,
            ) -> BOOL;

            pub fn CreateConsoleScreenBuffer(
                dwDesiredAccess: DWORD,
                dwShareMode: DWORD,
                lpSecurityAttributes: *const SECURITY_ATTRIBUTES,
                dwFlags: DWORD,
                lpScreenBufferData: LPVOID,
            ) -> HANDLE;

            pub fn SetConsoleMode
            (
                hConsoleHandle: HANDLE,
                dwMode: DWORD,
            ) -> BOOL;

            pub fn AllocConsole() -> BOOL;
            pub fn GetConsoleCP() -> UINT;
            pub fn GetConsoleMode
            (
                hConsoleHandle: HANDLE,
                lpMode: LPDWORD,
            ) -> BOOL;

            
            pub fn FillConsoleOutputCharacterA
            (
                hConsoleOutput: HANDLE,
                cCharacter: CHAR,
                nLength: DWORD,
                dwWriteCoord: COORD,
                lpNumberOfCharsWritten: LPDWORD,
            ) -> BOOL;

            pub fn FillConsoleOutputCharacterW
            (
                hConsoleOutput: HANDLE,
                cCharacter: WCHAR,
                nLength: DWORD,
                dwWriteCoord: COORD,
                lpNumberOfCharsWritten: LPDWORD,
            ) -> BOOL;

            pub fn FillConsoleOutputAttribute
            (
                hConsoleOutput: HANDLE,
                wAttribute: WORD,
                nLength: DWORD,
                dwWriteCoord: COORD,
                lpNumberOfAttrsWritten: LPDWORD,
            ) -> BOOL;

            pub fn ReadConsoleInputW
            (
                hConsoleInput: HANDLE,
                lpBuffer: PINPUT_RECORD,
                nLength: DWORD,
                lpNumberOfEventsRead: LPDWORD,
            ) -> BOOL;

            pub fn ReadConsoleW
            (
                hConsoleInput: HANDLE,
                lpBuffer: LPVOID,
                nNumberOfCharsToRead: DWORD,
                lpNumberOfCharsRead: LPDWORD,
                pInputControl: PCONSOLE_READCONSOLE_CONTROL,
            ) -> BOOL;

            pub fn WaitForSingleObject(
                hHandle: HANDLE,
                dwMilliseconds: DWORD,
            ) -> DWORD;

            pub fn SetConsoleCtrlHandler(
                HandlerRoutine: PHANDLER_ROUTINE,
                Add: BOOL,
            ) -> BOOL;
            
            pub fn CoTaskMemFree(
                pv: LPVOID,
            );

            pub fn SHGetKnownFolderPath
            (
                rfid: REFKNOWNFOLDERID,
                dwFlags: DWORD,
                hToken: HANDLE,
                pszPath: *mut PWSTR,
            ) -> HRESULT;

            pub fn lstrlenW( lpString: LPCWSTR ) -> c_int;

            pub fn WriteConsoleA
            (
                hConsoleOutput: HANDLE,
                lpBuffer: *const VOID,
                nNumberOfCharsToWrite: DWORD,
                lpNumberOfCharsWritten: LPDWORD,
                lpReserved: LPVOID,
            ) -> BOOL;

            pub fn WriteConsoleW
            (
                hConsoleOutput: HANDLE,
                lpBuffer: *const VOID,
                nNumberOfCharsToWrite: DWORD,
                lpNumberOfCharsWritten: LPDWORD,
                lpReserved: LPVOID,
            ) -> BOOL;

            pub fn FormatMessageW
            (
                dwFlags: DWORD,
                lpSource: LPCVOID,
                dwMessageId: DWORD,
                dwLanguageId: DWORD,
                lpBuffer: LPWSTR,
                nSize: DWORD,
                Arguments: *mut va_list,
            ) -> DWORD;
            pub fn GetLastError() -> DWORD;
            pub fn SetLastError( dwErrCode: DWORD, );
            pub fn GetErrorMode() -> UINT;
            pub fn SetErrorMode( uMode: UINT, ) -> UINT;
        }
        
        #[inline] pub fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16
        { 0xD800 | (second_byte as u16 & 0x3F) << 6 | third_byte as u16 & 0x3F }

        #[inline] pub fn decode_surrogate_pair(lead: u16, trail: u16) -> char
        {
            let code_point = 0x10000 + ((((lead - 0xD800) as u32) << 10) | (trail - 0xDC00) as u32);
            unsafe { char::from_u32_unchecked(code_point) }
        }
        
        #[inline] pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool
        {
            if index == 0 { return true; }

            match slice.bytes.get(index)
            {
                None => index == slice.len(),
                Some(&b) => (b as i8) >= -0x40,
            }
        }
        /// Verify that `index` is at the edge of either a valid UTF-8 codepoint or of the whole string.
        #[inline] #[track_caller] pub fn check_utf8_boundary(slice: &Wtf8, index: usize)
        {
            if index == 0 { return; }

            match slice.bytes.get(index)
            {
                Some(0xED) => (),
                Some(&b) if (b as i8) >= -0x40 => return,
                Some(_) => panic!("byte index {index} is not a codepoint boundary"),
                None if index == slice.len() => return,
                None => panic!("byte index {index} is out of bounds"),
            }

            if slice.bytes[index + 1] >= 0xA0
            {
                if index >= 3 && slice.bytes[index - 3] == 0xED && slice.bytes[index - 2] >= 0xA0
                { panic!("byte index {index} lies between surrogate codepoints"); }
            }
        }
        
        #[inline] pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 
        {
            unsafe 
            {
                let len = end - begin;
                let start = s.as_bytes().as_ptr().add(begin);
                Wtf8::from_bytes_unchecked(slice::from_raw_parts(start, len))
            }
        }
        
        #[inline(never)] pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! 
        {
            assert!(begin <= end);
            panic!("index {begin} and/or {end} in `{s:?}` do not lie on character boundary");
        }
    } #[cfg(windows)] pub use self::windows::*;
}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
    
    use ::
    {
        cmp::min,
        iter::repeat,
        sync::{Arc, Mutex, MutexGuard},
        system::{ * },
        time::Duration,
        *,
    };
    
    /*
    use linefeed::terminal::
    {
        CursorMode, RawRead, SignalSet, Size,
        Terminal, TerminalReader, TerminalWriter,
    }; */

    /// Default size of a `MemoryTerminal` buffer
    pub const DEFAULT_SIZE: Size = Size
    {
        columns: 80,
        lines: 24,
    };
    /// Implements an in-memory `Terminal` interface
    #[derive(Clone, Debug)]
    pub struct MemoryTerminal 
    {
        write: Arc<Mutex<Writer>>,
        read: Arc<Mutex<Reader>>,
    }

    #[derive(Debug)]
    struct Writer 
    {
        memory: Vec<char>,
        input: Vec<u8>,
        col: usize,
        line: usize,
        cursor_mode: CursorMode,
        size: Size,
    }

    #[derive(Debug)]
    struct Reader 
    {
        input: Vec<u8>,
        resize: Option<Size>,
    }

    /// Holds the lock on read operations of a `MemoryTerminal`.
    pub struct MemoryReadGuard<'a>(MutexGuard<'a, Reader>);
    /// Holds the lock on write operations of a `MemoryTerminal`.
    pub struct MemoryWriteGuard<'a>(MutexGuard<'a, Writer>);

    impl MemoryTerminal 
    {
        /// Returns a new `MemoryTerminal` with the default buffer size.
        pub fn new() -> MemoryTerminal {
            MemoryTerminal::default()
        }
        /// Returns a new `MemoryTerminal` with the given buffer size.
        pub fn with_size(size: Size) -> MemoryTerminal {
            MemoryTerminal{
                read: Arc::new(Mutex::new(Reader::new())),
                write: Arc::new(Mutex::new(Writer::new(size))),
            }
        }
        /// Clears the terminal buffer and places the cursor at `(0, 0)`.
        pub fn clear_all(&self) {
            self.lock_writer().clear_all();
        }
        /// Clears all characters beginning at the cursor and ending at buffer end.
        pub fn clear_to_end(&self) {
            self.lock_writer().clear_to_end();
        }
        /// Clears the input buffer.
        pub fn clear_input(&self) {
            self.lock_reader().clear_input();
        }
        /// Returns whether any input remains to be read.
        pub fn has_input(&self) -> bool {
            self.lock_reader().has_input()
        }
        /// Returns an iterator over lines in the buffer.
        pub fn lines(&self) -> Lines 
        {
            Lines
            {
                writer: self.lock_writer(),
                line: 0,
            }
        }
        /// Moves the cursor up `n` cells.
        pub fn move_up(&self, n: usize) {
            self.lock_writer().move_up(n);
        }
        /// Moves the cursor down `n` cells.
        pub fn move_down(&self, n: usize) {
            self.lock_writer().move_down(n);
        }
        /// Moves the cursor left `n` cells.
        pub fn move_left(&self, n: usize) {
            self.lock_writer().move_left(n);
        }
        /// Moves the cursor right `n` cells.
        pub fn move_right(&self, n: usize) {
            self.lock_writer().move_right(n);
        }
        /// Moves the cursor to the first column of the current line.
        pub fn move_to_first_column(&self) {
            self.lock_writer().move_to_first_column()
        }
        /// Pushes a character sequence to the back of the input queue.
        pub fn push_input(&self, s: &str) {
            self.lock_reader().push_input(s.as_bytes());
        }
        /// Reads some input from the input buffer.
        pub fn read_input(&self, buf: &mut [u8]) -> usize {
            self.lock_reader().read_input(buf)
        }
        /// Changes the size of the terminal buffer.
        pub fn resize(&self, new_size: Size) {
            self.lock_writer().resize(new_size);
            self.lock_reader().resize(new_size);
        }
        /// Moves the contents of the buffer up `n` lines.
        pub fn scroll_up(&self, n: usize) {
            self.lock_writer().scroll_up(n);
        }
        /// Returns the `(line, column)` position of the cursor.
        pub fn cursor(&self) -> (usize, usize) {
            let r = self.lock_writer();
            (r.line, r.col)
        }
        /// Sets the cursor mode.
        pub fn set_cursor_mode(&self, mode: CursorMode) {
            self.lock_writer().set_cursor_mode(mode);
        }
        /// Returns the cursor mode.
        pub fn cursor_mode(&self) -> CursorMode {
            self.lock_writer().cursor_mode()
        }
        /// Returns the size of the terminal buffer.
        pub fn size(&self) -> Size {
            self.lock_writer().size
        }
        /// Writes some text into the buffer.
        pub fn write(&self, s: &str) {
            self.lock_writer().write(s);
        }

        fn lock_reader(&self) -> MutexGuard<Reader> {
            self.read.lock().unwrap()
        }

        fn lock_writer(&self) -> MutexGuard<Writer> {
            self.write.lock().unwrap()
        }
    }

    impl Default for MemoryTerminal 
    {
        fn default() -> MemoryTerminal {
            MemoryTerminal::with_size(DEFAULT_SIZE)
        }
    }

    impl Reader 
    {
        fn new() -> Reader {
            Reader{
                input: Vec::new(),
                resize: None,
            }
        }

        fn has_input(&mut self) -> bool {
            self.resize.is_some() || !self.input.is_empty()
        }

        fn clear_input(&mut self) {
            self.input.clear();
        }

        fn push_input(&mut self, bytes: &[u8]) {
            self.input.extend(bytes);
        }

        fn read_input(&mut self, buf: &mut [u8]) -> usize {
            let n = min(buf.len(), self.input.len());

            buf[..n].copy_from_slice(&self.input[..n]);
            let _ = self.input.drain(..n);
            n
        }

        fn resize(&mut self, size: Size) {
            self.resize = Some(size);
        }
    }

    impl Writer 
    {
        fn new(size: Size) -> Writer {
            assert!(size.lines != 0 && size.columns != 0,
                "zero-area terminal buffer: {:?}", size);

            let n_chars = size.lines * size.columns;

            Writer{
                memory: vec![' '; n_chars],
                input: Vec::new(),
                col: 0,
                line: 0,
                cursor_mode: CursorMode::Normal,
                size: size,
            }
        }

        fn clear_all(&mut self) {
            for ch in &mut self.memory {
                *ch = ' ';
            }
            self.col = 0;
            self.line = 0;
        }

        fn clear_to_end(&mut self) {
            let idx = self.index();

            for ch in &mut self.memory[idx..] {
                *ch = ' ';
            }
        }

        fn move_up(&mut self, n: usize) {
            self.line = self.line.saturating_sub(n);
        }

        fn move_down(&mut self, n: usize) {
            self.line = min(self.size.lines - 1, self.line + n);
        }

        fn move_left(&mut self, n: usize) {
            self.col = self.col.saturating_sub(n);
        }

        fn move_right(&mut self, n: usize) {
            self.col = min(self.size.columns - 1, self.col + n);
        }

        fn move_to_first_column(&mut self) {
            self.col = 0;
        }

        fn resize(&mut self, new_size: Size) {
            if self.size != new_size {
                let n_chars = new_size.lines.checked_mul(new_size.columns)
                    .unwrap_or_else(|| panic!("terminal size too large: {:?}", new_size));

                assert!(n_chars != 0, "zero-area terminal buffer: {:?}", new_size);

                let mut new_buf = Vec::with_capacity(n_chars);

                let (n_copy, n_extra) = if new_size.columns > self.size.columns {
                    (self.size.columns, new_size.columns - self.size.columns)
                } else {
                    (new_size.columns, 0)
                };

                for line in self.memory.chunks(self.size.columns).take(new_size.lines) {
                    new_buf.extend(&line[..n_copy]);
                    new_buf.extend(repeat(' ').take(n_extra));
                }

                if new_size.lines > self.size.lines {
                    let n_lines = new_size.lines - self.size.lines;
                    new_buf.extend(repeat(' ').take(n_lines * new_size.columns));
                }

                debug_assert_eq!(new_buf.len(), n_chars);

                self.col = min(self.col, new_size.columns);
                self.line = min(self.line, new_size.lines);
                self.size = new_size;
                self.memory = new_buf;
            }
        }

        fn scroll_up(&mut self, n: usize) {
            let chars = min(self.memory.len(), self.size.columns * n);
            self.memory.drain(..chars);
            self.memory.extend(repeat(' ').take(chars));
            self.line = self.line.saturating_sub(n);
        }

        fn set_cursor_mode(&mut self, mode: CursorMode) {
            self.cursor_mode = mode;
        }

        fn cursor_mode(&self) -> CursorMode {
            self.cursor_mode
        }

        fn write(&mut self, s: &str) {
            for ch in s.chars() {
                if ch == '\n' {
                    self.advance_line();
                } else if ch == '\r' {
                    self.col = 0;
                } else {
                    self.write_char(ch);
                }
            }
        }

        fn advance_line(&mut self) {
            self.line += 1;
            self.col = 0;
            if self.line == self.size.lines {
                self.scroll_up(1);
            }
        }

        fn write_char(&mut self, ch: char) {
            if self.col >= self.size.columns {
                self.advance_line();
            }

            let idx = self.index();
            self.memory[idx] = ch;
            self.col += 1;
        }

        fn index(&self) -> usize {
            self.line * self.size.columns + self.col
        }
    }
    /// Iterator over lines in a `MemoryTerminal` buffer.
    pub struct Lines<'a> {
        writer: MutexGuard<'a, Writer>,
        line: usize,
    }

    impl<'a> Lines<'a> 
    {
        /// Returns the next line in the buffer.
        pub fn next(&mut self) -> Option<&[char]> 
        {
            if self.line >= self.writer.size.lines {
                None
            } else {
                let start = self.writer.size.columns * self.line;
                self.line += 1;
                let end = self.writer.size.columns * self.line;

                Some(&self.writer.memory[start..end])
            }
        }
        /// Returns the number of lines remaining in the iterator.
        pub fn lines_remaining(&self) -> usize 
        {
            self.writer.size.lines - self.line
        }
    }

    impl Terminals for MemoryTerminal 
    {
        type PrepareState = ();
        //type Reader = MemoryReadGuard;
        //type Writer = MemoryWriteGuard;
        fn name(&self) -> &str { "memory-terminal" }

        fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> 
        {
            Box::new(MemoryReadGuard(self.lock_reader()))
        }

        fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> 
        {
            Box::new(MemoryWriteGuard(self.lock_writer()))
        }
    }

    impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a> 
    {
        fn wait_for_input(&mut self, _timeout: Option<Duration>) -> io::Result<bool> {
            Ok(!self.0.input.is_empty())
        }

        fn prepare(&mut self, _block_signals: bool, _report_signals: SignalSet)
                -> io::Result<()> { Ok(()) }

        unsafe fn prepare_with_lock(&mut self,
                _lock: &mut dyn TerminalWriter<MemoryTerminal>,
                _block_signals: bool, _report_signals: SignalSet)
                -> io::Result<()> { Ok(()) }

        fn restore(&mut self, _state: ()) -> io::Result<()> { Ok(()) }

        unsafe fn restore_with_lock(&mut self,
                _lock: &mut dyn TerminalWriter<MemoryTerminal>, _state: ())
                -> io::Result<()> { Ok(()) }

        fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> {
            if let Some(size) = self.0.resize.take() {
                return Ok(RawRead::Resize(size));
            }

            buf.reserve(16);

            let cap = buf.capacity();
            let len = buf.len();
            let n;

            unsafe {
                buf.set_len(cap);
                n = self.0.read_input(&mut buf[len..]);
                buf.set_len(len + n);
            }

            Ok(RawRead::Bytes(n))
        }
    }

    impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a> 
    {
        fn size(&self) -> io::Result<Size> {
            Ok(self.0.size)
        }

        fn clear_screen(&mut self) -> io::Result<()> {
            self.0.clear_all();
            Ok(())
        }

        fn clear_to_screen_end(&mut self) -> io::Result<()> {
            self.0.clear_to_end();
            Ok(())
        }

        fn move_up(&mut self, n: usize) -> io::Result<()> {
            self.0.move_up(n);
            Ok(())
        }

        fn move_down(&mut self, n: usize) -> io::Result<()> {
            self.0.move_down(n);
            Ok(())
        }

        fn move_left(&mut self, n: usize) -> io::Result<()> {
            self.0.move_left(n);
            Ok(())
        }

        fn move_right(&mut self, n: usize) -> io::Result<()> {
            self.0.move_right(n);
            Ok(())
        }

        fn move_to_first_column(&mut self) -> io::Result<()> {
            self.0.move_to_first_column();
            Ok(())
        }

        fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
            self.0.set_cursor_mode(mode);
            Ok(())
        }

        fn write(&mut self, s: &str) -> io::Result<()> {
            self.0.write(s);
            Ok(())
        }

        fn flush(&mut self) -> io::Result<()> { Ok(()) }
    }
}

pub mod mode
{
    //! Standard Terminal Modes.
    use ::
    {
        borrow::{ Cow },
        database::
        {
            error::{ self, * },
            values::{ Value },
        },
        io::{ Write },
        parsers::
        {
            nom::
            {
                branch::alt,
                bytes::complete,
                bytes::streaming::{tag, take, take_while},
                character::streaming::one_of,
                combinator::{map, opt, value},
                error::{make_error, ErrorKind},
                number::{ numeric },
                Err, IResult,
            },
        },
        *,
    };
    /*
    use crate::error;
    use crate::expand::{Context, Expand, Parameter};*/
    /*
    Terminal mode definition macro */
    macro_rules! mode
    {
        (boolean $ident:ident => $mode:expr) => 
        (
            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub struct $ident(pub bool);

            impl<'a> Mode<'a> for $ident 
            {
                #[inline] fn name() -> &'static str { $mode }

                #[inline] fn from(value: Option<&Value>) -> Option<Self>
                {
                    if let Some(&Value::True) = value { Some($ident(true)) }
                    else { Some($ident(false)) }
                }

                #[inline] fn to(self) -> Option<Value>
                {
                    if self.0 { Some(Value::True) }
                    else { None }
                }
            }

            impl From<$ident> for bool
            {
                fn from(cap: $ident) -> Self { cap.0 }
            }
        );

        (number $ident:ident => $mode:expr) => 
        (
            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub struct $ident(pub i32);

            impl<'a> Mode<'a> for $ident
            {
                #[inline] fn name() -> &'static str { $mode }

                #[inline] fn from(value: Option<&Value>) -> Option<Self>
                {
                    if let Some(&Value::Number(value)) = value { Some($ident(value)) }                    
                    else { None }
                }

                #[inline] fn to(self) -> Option<Value> { Some(Value::Number(self.0)) }
            }

            impl From<$ident> for i32
            {
                fn from(cap: $ident) -> Self { cap.0 }
            }
        );

        (string define $ident:ident => $mode:expr) => 
        (
            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct $ident<'a>(Cow<'a, [u8]>);

            impl<'a> Mode<'a> for $ident<'a>
            {
                #[inline] fn name() -> &'static str { $mode }

                #[inline] fn from(value: Option<&'a Value>) -> Option<$ident<'a>>
                {
                    if let Some(&Value::String(ref value)) = value { Some($ident(Cow::Borrowed(value))) }
                    
                    else { None }
                }

                #[inline] fn to(self) -> Option<Value> 
                {
                    Some(Value::String(match self.0 
                    {
                        Cow::Borrowed(value) => value.into(),
                        Cow::Owned(value) => value
                    }))
                }
            }

            impl<'a, T: AsRef<&'a [u8]>> From<T> for $ident<'a> 
            {
                #[inline] fn from(value: T) -> Self { $ident(Cow::Borrowed(value.as_ref())) }
            }

            impl<'a> AsRef<[u8]> for $ident<'a> 
            {
                #[inline] fn as_ref(&self) -> &[u8] { &self.0 }
            }

            impl<'a> $ident<'a> 
            {
                /// Begin expanding the capability.
                #[inline] pub fn expand(&self) -> Expansion<$ident> 
                {
                    Expansion 
                    {
                        string:  self,
                        params:  Default::default(),
                        context: None,
                    }
                }
            }
        );

        (string $ident:ident => $mode:expr) => 
        (
            mode!(string define $ident => $mode);
        );

        (string $ident:ident => $mode:expr; $($rest:tt)+) => 
        (
            mode!(string define $ident => $mode);
            mode!(string parameters $ident; $($rest)+);
            mode!(string builder $ident; 0, $($rest)+, );
        );

        (string parameters $ident:ident; $($name:ident : $ty:ty),+) => 
        (
            impl<'a> Expansion<'a, $ident<'a>> 
            {
                /// Pass all expansion parameters at once.
                #[inline] pub fn parameters(mut self, $($name: $ty),*) -> Self 
                {
                    let mut index = 0;
                    $({
                        self.params[index]  = $name.into();
                        index              += 1;
                    })*;
                    self
                }
            }
        );

        (string builder $ident:ident; $index:expr, ) => ();

        (string builder $ident:ident; $index:expr, $name:ident : u8, $($rest:tt)*) => 
        (
            mode!(string builder direct $ident; $index, $name : u8);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder $ident:ident; $index:expr, $name:ident : i8, $($rest:tt)*) => 
        (
            mode!(string builder direct $ident; $index, $name : i8);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder $ident:ident; $index:expr, $name:ident : u16, $($rest:tt)*) => 
        (
            mode!(string builder direct $ident; $index, $name : u16);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder $ident:ident; $index:expr, $name:ident : i16 $($rest:tt)*) => 
        (
            mode!(string builder direct $ident; $index, $name : i16);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder $ident:ident; $index:expr, $name:ident : u32, $($rest:tt)*) => 
        (
            mode!(string builder direct $ident; $index, $name : u32);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder $ident:ident; $index:expr, $name:ident : i32, $($rest:tt)*) => 
        (
            mode!(string builder direct $ident; $index, $name : i32);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder $ident:ident; $index:expr, $name:ident : $ty:ty, $($rest:tt)*) => 
        (
            mode!(string builder into $ident; $index, $name : $ty);
            mode!(string builder $ident; $index + 1, $($rest)*);
        );

        (string builder direct $ident:ident; $index:expr, $name:ident : $ty:ty) => 
        (
            impl<'a> Expansion<'a, $ident<'a>> 
            {
                /// Set the given parameter.
                #[inline] pub fn $name(mut self, value: $ty) -> Self 
                {
                    self.params[$index] = value.into();
                    self
                }
            }
        );

        (string builder into $ident:ident; $index:expr, $name:ident : $ty:ty) => 
        (
            impl<'a> Expansion<'a, $ident<'a>> 
            {
                /// Set the given parameter.
                #[inline] pub fn $name<T: Into<$ty>>(mut self, value: T) -> Self 
                {
                    self.params[$index] = value.into().into();
                    self
                }
            }
        );
    }
    /// Trait for items that can be expanded.
    pub trait Expands
    {
        fn expand<W: Write>
        (
            &self,
            output: W,
            parameters: &[Parameter],
            context: &mut Context,
        ) -> OverResult<()>;
    }
    /// A trait for any object that will represent a terminal mode.
    pub trait Mode<'a>: Sized
    {
        /// Returns the name of the mode in its long form.
        fn name() -> &'static str;
        /// Parse the mode from its raw value.
        fn from(value: Option<&'a Value>) -> Option<Self>;
        /// Convert the mode into its raw value.
        fn to(self) -> Option<Value>;
    }
    /// An expansion parameter.
    #[derive(Eq, PartialEq, Clone, Debug)]
    pub enum Parameter
    {
        /// A number.
        Number(i32),
        /// An ASCII string.
        String(Vec<u8>),
    }
    
    impl Default for Parameter
    {
        fn default() -> Self { Parameter::Number(0) }
    }

    impl From<bool> for Parameter 
    {
        fn from( value:bool ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl From<u8> for Parameter 
    {
        fn from( value:u8 ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl From<i8> for Parameter 
    {
        fn from( value:i8 ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl From<u16> for Parameter 
    {
        fn from( value:u16 ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl From<i16> for Parameter 
    {
        fn from( value:i16 ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl From<u32> for Parameter 
    {
        fn from( value:u32 ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl From<i32> for Parameter 
    {
        fn from( value:i32 ) -> Self { Parameter::Number( value as i32 ) }
    }
    
    impl<'a> From<&'a str> for Parameter 
    {
        fn from( value:&'a str ) -> Self { Parameter::String( value.into() ) }
    }
    
    impl<'a> From<&'a [u8]> for Parameter 
    {
        fn from( value:&'a [u8] ) -> Self { Parameter::String( value.into() ) }
    }
    
    impl From<String> for Parameter
    {
        fn from( value:String ) -> Self { Parameter::String(value.into()) }
    }
    
    impl From<Vec<u8>> for Parameter
    {
        fn from( value:Vec<u8> ) -> Self { Parameter::String(value.into()) }
    }
    /// The same context should be passed around through every expansion for the same `Database`.
    #[derive( Eq, PartialEq, Default, Debug )]
    pub struct Context
    {
        pub fixed: [Parameter; 26],
        pub dynamic: [Parameter; 26],
    }
    /// Expansion helper struct.
    #[derive(Debug)]
    pub struct Expansion<'a, T: 'a + AsRef<[u8]>> 
    {
        string: &'a T,
        params: [Parameter; 9],
        context: Option<&'a mut Context>,
    }

    impl<'a, T: AsRef<[u8]>> Expansion<'a, T> 
    {
        /// Expand using the given context.
        pub fn with<'c: 'a>(mut self, context: &'c mut Context) -> Self 
        {
            self.context = Some(context);
            self
        }
        /// Expand to the given output.
        pub fn from<W: Write>(self, output: W) -> error::OverResult<()> 
        {
            /*
            TODO
            self.string.as_ref().expand
            (
                output,
                &self.params,
                self.context.unwrap_or(&mut Default::default()),
            )*/
            Ok(())
        }
        /// Expand into a vector.
        pub fn to_vec(self) -> error::OverResult<Vec<u8>> 
        {
            let mut result = Vec::with_capacity(self.string.as_ref().len());
            self.from(&mut result)?;
            Ok(result)
        }
    }
    
    #[derive(Eq, PartialEq, Copy, Clone, Debug)]
    pub enum Constant 
    {
        Character(u8),
        Integer(i32),
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Variable 
    {
        Length,
        Push(u8),
        Set(bool, u8),
        Get(bool, u8),
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Conditional
    {
        If,
        Then,
        Else,
        End,
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Unary 
    {
        Not,
        NOT,
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Binary 
    {
        Add,
        Subtract,
        Multiply,
        Divide,
        Remainder,

        AND,
        OR,
        XOR,

        And,
        Or,

        Equal,
        Greater,
        Lesser,
    }
    
    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Operation
    {
        Increment,
        Unary(Unary),
        Binary(Binary),
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Format
    {
        Chr,
        Uni,
        Str,
        Dec,
        Oct,
        Hex,
        HEX,
    }

    #[derive( Eq, PartialEq, Copy, Clone, Default, Debug )]
    pub struct Flags
    {
        pub width: usize,
        pub precision: usize,
        pub alternate: bool,
        pub left: bool,
        pub sign: bool,
        pub space: bool,
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub struct Print
    {
        pub flags: Flags,
        pub format: Format,
    }

    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
    pub enum Item<'a>
    {
        String(&'a [u8]),
        Constant(Constant),
        Variable(Variable),
        Operation(Operation),
        Conditional(Conditional),
        Print(Print),
    }

    mode!( boolean AutoLeftMargin => "auto_left_margin" );
    mode!(boolean AutoRightMargin => "auto_right_margin");
    mode!(boolean NoEscCtlc => "no_esc_ctlc");
    mode!(boolean CeolStandoutGlitch => "ceol_standout_glitch");
    mode!(boolean EatNewlineGlitch => "eat_newline_glitch");
    mode!(boolean EraseOverstrike => "erase_overstrike");
    mode!(boolean GenericType => "generic_type");
    mode!(boolean HardCopy => "hard_copy");
    mode!(boolean HasMetaKey => "has_meta_key");
    mode!(boolean HasStatusLine => "has_status_line");
    mode!(boolean InsertNullGlitch => "insert_null_glitch");
    mode!(boolean MemoryAbove => "memory_above");
    mode!(boolean MemoryBelow => "memory_below");
    mode!(boolean MoveInsertMode => "move_insert_mode");
    mode!(boolean MoveStandoutMode => "move_standout_mode");
    mode!(boolean OverStrike => "over_strike");
    mode!(boolean StatusLineEscOk => "status_line_esc_ok");
    mode!(boolean DestTabsMagicSmso => "dest_tabs_magic_smso");
    mode!(boolean TildeGlitch => "tilde_glitch");
    mode!(boolean TransparentUnderline => "transparent_underline");
    mode!(boolean XonXoff => "xon_xoff");
    mode!(boolean NeedsXonXoff => "needs_xon_xoff");
    mode!(boolean PrtrSilent => "prtr_silent");
    mode!(boolean HardCursor => "hard_cursor");
    mode!(boolean NonRevRmcup => "non_rev_rmcup");
    mode!(boolean NoPadChar => "no_pad_char");
    mode!(boolean NonDestScrollRegion => "non_dest_scroll_region");
    mode!(boolean CanChange => "can_change");
    mode!(boolean BackColorErase => "back_color_erase");
    mode!(boolean HueLightnessSaturation => "hue_lightness_saturation");
    mode!(boolean ColAddrGlitch => "col_addr_glitch");
    mode!(boolean CrCancelsMicroMode => "cr_cancels_micro_mode");
    mode!(boolean HasPrintWheel => "has_print_wheel");
    mode!(boolean RowAddrGlitch => "row_addr_glitch");
    mode!(boolean SemiAutoRightMargin => "semi_auto_right_margin");
    mode!(boolean CpiChangesRes => "cpi_changes_res");
    mode!(boolean LpiChangesRes => "lpi_changes_res");
    mode!(boolean BackspacesWithBs => "backspaces_with_bs");
    mode!(boolean CrtNoScrolling => "crt_no_scrolling");
    mode!(boolean NoCorrectlyWorkingCr => "no_correctly_working_cr");
    mode!(boolean GnuHasMetaKey => "gnu_has_meta_key");
    mode!(boolean LinefeedIsNewline => "linefeed_is_newline");
    mode!(boolean HasHardwareTabs => "has_hardware_tabs");
    mode!(boolean ReturnDoesClrEol => "return_does_clr_eol");

    mode!(number Columns => "columns");
    mode!(number InitTabs => "init_tabs");
    mode!(number Lines => "lines");
    mode!(number LinesOfMemory => "lines_of_memory");
    mode!(number MagicCookieGlitch => "magic_cookie_glitch");
    mode!(number PaddingBaudRate => "padding_baud_rate");
    mode!(number VirtualTerminal => "virtual_terminal");
    mode!(number WidthStatusLine => "width_status_line");
    mode!(number NumLabels => "num_labels");
    mode!(number LabelHeight => "label_height");
    mode!(number LabelWidth => "label_width");
    mode!(number MaxAttributes => "max_attributes");
    mode!(number MaximumWindows => "maximum_windows");
    mode!(number MaxColors => "max_colors");
    mode!(number MaxPairs => "max_pairs");
    mode!(number NoColorVideo => "no_color_video");
    mode!(number BufferCapacity => "buffer_capacity");
    mode!(number DotVertSpacing => "dot_vert_spacing");
    mode!(number DotHorzSpacing => "dot_horz_spacing");
    mode!(number MaxMicroAddress => "max_micro_address");
    mode!(number MaxMicroJump => "max_micro_jump");
    mode!(number MicroColSize => "micro_col_size");
    mode!(number MicroLineSize => "micro_line_size");
    mode!(number NumberOfPins => "number_of_pins");
    mode!(number OutputResChar => "output_res_char");
    mode!(number OutputResLine => "output_res_line");
    mode!(number OutputResHorzInch => "output_res_horz_inch");
    mode!(number OutputResVertInch => "output_res_vert_inch");
    mode!(number PrintRate => "print_rate");
    mode!(number WideCharSize => "wide_char_size");
    mode!(number Buttons => "buttons");
    mode!(number BitImageEntwining => "bit_image_entwining");
    mode!(number BitImageType => "bit_image_type");
    mode!(number MagicCookieGlitchUl => "magic_cookie_glitch_ul");
    mode!(number CarriageReturnDelay => "carriage_return_delay");
    mode!(number NewLineDelay => "new_line_delay");
    mode!(number BackspaceDelay => "backspace_delay");
    mode!(number HorizontalTabDelay => "horizontal_tab_delay");
    mode!(number NumberOfFunctionKeys => "number_of_function_keys");

    mode!(string BackTab => "back_tab");
    mode!(string Bell => "bell");
    mode!(string CarriageReturn => "carriage_return");
    mode!(string ClearAllTabs => "clear_all_tabs");
    mode!(string ClearScreen => "clear_screen");
    mode!(string ClrEol => "clr_eol");
    mode!(string ClrEos => "clr_eos");
    mode!(string CommandCharacter => "command_character");
    mode!(string CursorDown => "cursor_down");
    mode!(string CursorHome => "cursor_home");
    mode!(string CursorInvisible => "cursor_invisible");
    mode!(string CursorLeft => "cursor_left");
    mode!(string CursorMemAddress => "cursor_mem_address");
    mode!(string CursorNormal => "cursor_normal");
    mode!(string CursorRight => "cursor_right");
    mode!(string CursorToLl => "cursor_to_ll");
    mode!(string CursorUp => "cursor_up");
    mode!(string CursorVisible => "cursor_visible");
    mode!(string DeleteCharacter => "delete_character");
    mode!(string DeleteLine => "delete_line");
    mode!(string DisStatusLine => "dis_status_line");
    mode!(string DownHalfLine => "down_half_line");
    mode!(string EnterAltCharsetMode => "enter_alt_charset_mode");
    mode!(string EnterBlinkMode => "enter_blink_mode");
    mode!(string EnterBoldMode => "enter_bold_mode");
    mode!(string EnterCaMode => "enter_ca_mode");
    mode!(string EnterDeleteMode => "enter_delete_mode");
    mode!(string EnterDimMode => "enter_dim_mode");
    mode!(string EnterInsertMode => "enter_insert_mode");
    mode!(string EnterSecureMode => "enter_secure_mode");
    mode!(string EnterProtectedMode => "enter_protected_mode");
    mode!(string EnterReverseMode => "enter_reverse_mode");
    mode!(string EnterStandoutMode => "enter_standout_mode");
    mode!(string EnterUnderlineMode => "enter_underline_mode");
    mode!(string ExitAltCharsetMode => "exit_alt_charset_mode");
    mode!(string ExitAttributeMode => "exit_attribute_mode");
    mode!(string ExitCaMode => "exit_ca_mode");
    mode!(string ExitDeleteMode => "exit_delete_mode");
    mode!(string ExitInsertMode => "exit_insert_mode");
    mode!(string ExitStandoutMode => "exit_standout_mode");
    mode!(string ExitUnderlineMode => "exit_underline_mode");
    mode!(string FlashScreen => "flash_screen");
    mode!(string FormFeed => "form_feed");
    mode!(string FromStatusLine => "from_status_line");
    mode!(string Init1String => "init_1string");
    mode!(string Init2String => "init_2string");
    mode!(string Init3String => "init_3string");
    mode!(string InitFile => "init_file");
    mode!(string InsertCharacter => "insert_character");
    mode!(string InsertLine => "insert_line");
    mode!(string InsertPadding => "insert_padding");
    mode!(string KeyBackspace => "key_backspace");
    mode!(string KeyCATab => "key_catab");
    mode!(string KeyClear => "key_clear");
    mode!(string KeyCTab => "key_ctab");
    mode!(string KeyDc => "key_dc");
    mode!(string KeyDl => "key_dl");
    mode!(string KeyDown => "key_down");
    mode!(string KeyEic => "key_eic");
    mode!(string KeyEol => "key_eol");
    mode!(string KeyEos => "key_eos");
    mode!(string KeyF0 => "key_f0");
    mode!(string KeyF1 => "key_f1");
    mode!(string KeyF10 => "key_f10");
    mode!(string KeyF2 => "key_f2");
    mode!(string KeyF3 => "key_f3");
    mode!(string KeyF4 => "key_f4");
    mode!(string KeyF5 => "key_f5");
    mode!(string KeyF6 => "key_f6");
    mode!(string KeyF7 => "key_f7");
    mode!(string KeyF8 => "key_f8");
    mode!(string KeyF9 => "key_f9");
    mode!(string KeyHome => "key_home");
    mode!(string KeyIc => "key_ic");
    mode!(string KeyIl => "key_il");
    mode!(string KeyLeft => "key_left");
    mode!(string KeyLl => "key_ll");
    mode!(string KeyNPage => "key_npage");
    mode!(string KeyPPage => "key_ppage");
    mode!(string KeyRight => "key_right");
    mode!(string KeySf => "key_sf");
    mode!(string KeySr => "key_sr");
    mode!(string KeySTab => "key_stab");
    mode!(string KeyUp => "key_up");
    mode!(string KeypadLocal => "keypad_local");
    mode!(string KeypadXmit => "keypad_xmit");
    mode!(string LabF0 => "lab_f0");
    mode!(string LabF1 => "lab_f1");
    mode!(string LabF10 => "lab_f10");
    mode!(string LabF2 => "lab_f2");
    mode!(string LabF3 => "lab_f3");
    mode!(string LabF4 => "lab_f4");
    mode!(string LabF5 => "lab_f5");
    mode!(string LabF6 => "lab_f6");
    mode!(string LabF7 => "lab_f7");
    mode!(string LabF8 => "lab_f8");
    mode!(string LabF9 => "lab_f9");
    mode!(string MetaOff => "meta_off");
    mode!(string MetaOn => "meta_on");
    mode!(string Newline => "newline");
    mode!(string PadChar => "pad_char");
    mode!(string PKeyKey => "pkey_key");
    mode!(string PKeyLocal => "pkey_local");
    mode!(string PKeyXmit => "pkey_xmit");
    mode!(string PrintScreen => "print_screen");
    mode!(string PrtrOff => "prtr_off");
    mode!(string PrtrOn => "prtr_on");
    mode!(string RepeatChar => "repeat_char");
    mode!(string Reset1String => "reset_1string");
    mode!(string Reset2String => "reset_2string");
    mode!(string Reset3String => "reset_3string");
    mode!(string ResetFile => "reset_file");
    mode!(string RestoreCursor => "restore_cursor");
    mode!(string SaveCursor => "save_cursor");
    mode!(string ScrollForward => "scroll_forward");
    mode!(string ScrollReverse => "scroll_reverse");
    mode!(string SetTab => "set_tab");
    mode!(string SetWindow => "set_window");
    mode!(string Tab => "tab");
    mode!(string ToStatusLine => "to_status_line");
    mode!(string UnderlineChar => "underline_char");
    mode!(string UpHalfLine => "up_half_line");
    mode!(string InitProg => "init_prog");
    mode!(string KeyA1 => "key_a1");
    mode!(string KeyA3 => "key_a3");
    mode!(string KeyB2 => "key_b2");
    mode!(string KeyC1 => "key_c1");
    mode!(string KeyC3 => "key_c3");
    mode!(string PrtrNon => "prtr_non");
    mode!(string CharPadding => "char_padding");
    mode!(string AcsChars => "acs_chars");
    mode!(string PlabNorm => "plab_norm");
    mode!(string KeyBTab => "key_btab");
    mode!(string EnterXonMode => "enter_xon_mode");
    mode!(string ExitXonMode => "exit_xon_mode");
    mode!(string EnterAmMode => "enter_am_mode");
    mode!(string ExitAmMode => "exit_am_mode");
    mode!(string XonCharacter => "xon_character");
    mode!(string XoffCharacter => "xoff_character");
    mode!(string EnaAcs => "ena_acs");
    mode!(string LabelOn => "label_on");
    mode!(string LabelOff => "label_off");
    mode!(string KeyBeg => "key_beg");
    mode!(string KeyCancel => "key_cancel");
    mode!(string KeyClose => "key_close");
    mode!(string KeyCommand => "key_command");
    mode!(string KeyCopy => "key_copy");
    mode!(string KeyCreate => "key_create");
    mode!(string KeyEnd => "key_end");
    mode!(string KeyEnter => "key_enter");
    mode!(string KeyExit => "key_exit");
    mode!(string KeyFind => "key_find");
    mode!(string KeyHelp => "key_help");
    mode!(string KeyMark => "key_mark");
    mode!(string KeyMessage => "key_message");
    mode!(string KeyMove => "key_move");
    mode!(string KeyNext => "key_next");
    mode!(string KeyOpen => "key_open");
    mode!(string KeyOptions => "key_options");
    mode!(string KeyPrevious => "key_previous");
    mode!(string KeyPrint => "key_print");
    mode!(string KeyRedo => "key_redo");
    mode!(string KeyReference => "key_reference");
    mode!(string KeyRefresh => "key_refresh");
    mode!(string KeyReplace => "key_replace");
    mode!(string KeyRestart => "key_restart");
    mode!(string KeyResume => "key_resume");
    mode!(string KeySave => "key_save");
    mode!(string KeySuspend => "key_suspend");
    mode!(string KeyUndo => "key_undo");
    mode!(string KeySBeg => "key_sbeg");
    mode!(string KeySCancel => "key_scancel");
    mode!(string KeySCommand => "key_scommand");
    mode!(string KeySCopy => "key_scopy");
    mode!(string KeySCreate => "key_screate");
    mode!(string KeySDc => "key_sdc");
    mode!(string KeySDl => "key_sdl");
    mode!(string KeySelect => "key_select");
    mode!(string KeySEnd => "key_send");
    mode!(string KeySEol => "key_seol");
    mode!(string KeySExit => "key_sexit");
    mode!(string KeySFind => "key_sfind");
    mode!(string KeySHelp => "key_shelp");
    mode!(string KeySHome => "key_shome");
    mode!(string KeySIc => "key_sic");
    mode!(string KeySLeft => "key_sleft");
    mode!(string KeySMessage => "key_smessage");
    mode!(string KeySMove => "key_smove");
    mode!(string KeySNext => "key_snext");
    mode!(string KeySOptions => "key_soptions");
    mode!(string KeySPrevious => "key_sprevious");
    mode!(string KeySPrint => "key_sprint");
    mode!(string KeySRedo => "key_sredo");
    mode!(string KeySReplace => "key_sreplace");
    mode!(string KeySRight => "key_sright");
    mode!(string KeySRsume => "key_srsume");
    mode!(string KeySSave => "key_ssave");
    mode!(string KeySSuspend => "key_ssuspend");
    mode!(string KeySUndo => "key_sundo");
    mode!(string ReqForInput => "req_for_input");
    mode!(string KeyF11 => "key_f11");
    mode!(string KeyF12 => "key_f12");
    mode!(string KeyF13 => "key_f13");
    mode!(string KeyF14 => "key_f14");
    mode!(string KeyF15 => "key_f15");
    mode!(string KeyF16 => "key_f16");
    mode!(string KeyF17 => "key_f17");
    mode!(string KeyF18 => "key_f18");
    mode!(string KeyF19 => "key_f19");
    mode!(string KeyF20 => "key_f20");
    mode!(string KeyF21 => "key_f21");
    mode!(string KeyF22 => "key_f22");
    mode!(string KeyF23 => "key_f23");
    mode!(string KeyF24 => "key_f24");
    mode!(string KeyF25 => "key_f25");
    mode!(string KeyF26 => "key_f26");
    mode!(string KeyF27 => "key_f27");
    mode!(string KeyF28 => "key_f28");
    mode!(string KeyF29 => "key_f29");
    mode!(string KeyF30 => "key_f30");
    mode!(string KeyF31 => "key_f31");
    mode!(string KeyF32 => "key_f32");
    mode!(string KeyF33 => "key_f33");
    mode!(string KeyF34 => "key_f34");
    mode!(string KeyF35 => "key_f35");
    mode!(string KeyF36 => "key_f36");
    mode!(string KeyF37 => "key_f37");
    mode!(string KeyF38 => "key_f38");
    mode!(string KeyF39 => "key_f39");
    mode!(string KeyF40 => "key_f40");
    mode!(string KeyF41 => "key_f41");
    mode!(string KeyF42 => "key_f42");
    mode!(string KeyF43 => "key_f43");
    mode!(string KeyF44 => "key_f44");
    mode!(string KeyF45 => "key_f45");
    mode!(string KeyF46 => "key_f46");
    mode!(string KeyF47 => "key_f47");
    mode!(string KeyF48 => "key_f48");
    mode!(string KeyF49 => "key_f49");
    mode!(string KeyF50 => "key_f50");
    mode!(string KeyF51 => "key_f51");
    mode!(string KeyF52 => "key_f52");
    mode!(string KeyF53 => "key_f53");
    mode!(string KeyF54 => "key_f54");
    mode!(string KeyF55 => "key_f55");
    mode!(string KeyF56 => "key_f56");
    mode!(string KeyF57 => "key_f57");
    mode!(string KeyF58 => "key_f58");
    mode!(string KeyF59 => "key_f59");
    mode!(string KeyF60 => "key_f60");
    mode!(string KeyF61 => "key_f61");
    mode!(string KeyF62 => "key_f62");
    mode!(string KeyF63 => "key_f63");
    mode!(string ClrBol => "clr_bol");
    mode!(string ClearMargins => "clear_margins");
    mode!(string SetLeftMargin => "set_left_margin");
    mode!(string SetRightMargin => "set_right_margin");
    mode!(string LabelFormat => "label_format");
    mode!(string SetClock => "set_clock");
    mode!(string DisplayClock => "display_clock");
    mode!(string RemoveClock => "remove_clock");
    mode!(string CreateWindow => "create_window");
    mode!(string GotoWindow => "goto_window");
    mode!(string Hangup => "hangup");
    mode!(string DialPhone => "dial_phone");
    mode!(string QuickDial => "quick_dial");
    mode!(string Tone => "tone");
    mode!(string Pulse => "pulse");
    mode!(string FlashHook => "flash_hook");
    mode!(string FixedPause => "fixed_pause");
    mode!(string WaitTone => "wait_tone");
    mode!(string User0 => "user0");
    mode!(string User1 => "user1");
    mode!(string User2 => "user2");
    mode!(string User3 => "user3");
    mode!(string User4 => "user4");
    mode!(string User5 => "user5");
    mode!(string User6 => "user6");
    mode!(string User7 => "user7");
    mode!(string User8 => "user8");
    mode!(string User9 => "user9");
    mode!(string OrigPair => "orig_pair");
    mode!(string OrigColors => "orig_colors");
    mode!(string InitializeColor => "initialize_color");
    mode!(string InitializePair => "initialize_pair");
    mode!(string SetColorPair => "set_color_pair");
    mode!(string ChangeCharPitch => "change_char_pitch");
    mode!(string ChangeLinePitch => "change_line_pitch");
    mode!(string ChangeResHorz => "change_res_horz");
    mode!(string ChangeResVert => "change_res_vert");
    mode!(string DefineChar => "define_char");
    mode!(string EnterDoublewideMode => "enter_doublewide_mode");
    mode!(string EnterDraftQuality => "enter_draft_quality");
    mode!(string EnterItalicsMode => "enter_italics_mode");
    mode!(string EnterLeftwardMode => "enter_leftward_mode");
    mode!(string EnterMicroMode => "enter_micro_mode");
    mode!(string EnterNearLetterQuality => "enter_near_letter_quality");
    mode!(string EnterNormalQuality => "enter_normal_quality");
    mode!(string EnterShadowMode => "enter_shadow_mode");
    mode!(string EnterSubscriptMode => "enter_subscript_mode");
    mode!(string EnterSuperscriptMode => "enter_superscript_mode");
    mode!(string EnterUpwardMode => "enter_upward_mode");
    mode!(string ExitDoublewideMode => "exit_doublewide_mode");
    mode!(string ExitItalicsMode => "exit_italics_mode");
    mode!(string ExitLeftwardMode => "exit_leftward_mode");
    mode!(string ExitMicroMode => "exit_micro_mode");
    mode!(string ExitShadowMode => "exit_shadow_mode");
    mode!(string ExitSubscriptMode => "exit_subscript_mode");
    mode!(string ExitSuperscriptMode => "exit_superscript_mode");
    mode!(string ExitUpwardMode => "exit_upward_mode");
    mode!(string MicroColumnAddress => "micro_column_address");
    mode!(string MicroDown => "micro_down");
    mode!(string MicroLeft => "micro_left");
    mode!(string MicroRight => "micro_right");
    mode!(string MicroRowAddress => "micro_row_address");
    mode!(string MicroUp => "micro_up");
    mode!(string OrderOfPins => "order_of_pins");
    mode!(string SelectCharSet => "select_char_set");
    mode!(string SetBottomMargin => "set_bottom_margin");
    mode!(string SetBottomMarginParm => "set_bottom_margin_parm");
    mode!(string SetLeftMarginParm => "set_left_margin_parm");
    mode!(string SetRightMarginParm => "set_right_margin_parm");
    mode!(string SetTopMargin => "set_top_margin");
    mode!(string SetTopMarginParm => "set_top_margin_parm");
    mode!(string StartBitImage => "start_bit_image");
    mode!(string StartCharSetDef => "start_char_set_def");
    mode!(string StopBitImage => "stop_bit_image");
    mode!(string StopCharSetDef => "stop_char_set_def");
    mode!(string SubscriptCharacters => "subscript_characters");
    mode!(string SuperscriptCharacters => "superscript_characters");
    mode!(string TheseCauseCr => "these_cause_cr");
    mode!(string ZeroMotion => "zero_motion");
    mode!(string CharSetNames => "char_set_names");
    mode!(string KeyMouse => "key_mouse");
    mode!(string MouseInfo => "mouse_info");
    mode!(string ReqMousePos => "req_mouse_pos");
    mode!(string GetMouse => "get_mouse");
    mode!(string PkeyPlab => "pkey_plab");
    mode!(string DeviceType => "device_type");
    mode!(string CodeSetInit => "code_set_init");
    mode!(string Set0DesSeq => "set0_des_seq");
    mode!(string Set1DesSeq => "set1_des_seq");
    mode!(string Set2DesSeq => "set2_des_seq");
    mode!(string Set3DesSeq => "set3_des_seq");
    mode!(string SetLrMargin => "set_lr_margin");
    mode!(string SetTbMargin => "set_tb_margin");
    mode!(string BitImageRepeat => "bit_image_repeat");
    mode!(string BitImageNewline => "bit_image_newline");
    mode!(string BitImageCarriageReturn => "bit_image_carriage_return");
    mode!(string ColorNames => "color_names");
    mode!(string DefineBitImageRegion => "define_bit_image_region");
    mode!(string EndBitImageRegion => "end_bit_image_region");
    mode!(string SetColorBand => "set_color_band");
    mode!(string SetPageLength => "set_page_length");
    mode!(string DisplayPcChar => "display_pc_char");
    mode!(string EnterPcCharsetMode => "enter_pc_charset_mode");
    mode!(string ExitPcCharsetMode => "exit_pc_charset_mode");
    mode!(string EnterScancodeMode => "enter_scancode_mode");
    mode!(string ExitScancodeMode => "exit_scancode_mode");
    mode!(string PcTermOptions => "pc_term_options");
    mode!(string ScancodeEscape => "scancode_escape");
    mode!(string AltScancodeEsc => "alt_scancode_esc");
    mode!(string EnterHorizontalHlMode => "enter_horizontal_hl_mode");
    mode!(string EnterLeftHlMode => "enter_left_hl_mode");
    mode!(string EnterLowHlMode => "enter_low_hl_mode");
    mode!(string EnterRightHlMode => "enter_right_hl_mode");
    mode!(string EnterTopHlMode => "enter_top_hl_mode");
    mode!(string EnterVerticalHlMode => "enter_vertical_hl_mode");
    mode!(string SetAAttributes => "set_a_attributes");
    mode!(string SetPglenInch => "set_pglen_inch");
    mode!(string TermcapInit2 => "termcap_init2");
    mode!(string TermcapReset => "termcap_reset");
    mode!(string LinefeedIfNotLf => "linefeed_if_not_lf");
    mode!(string BackspaceIfNotBs => "backspace_if_not_bs");
    mode!(string OtherNonFunctionKeys => "other_non_function_keys");
    mode!(string ArrowKeyMap => "arrow_key_map");
    mode!(string AcsULcorner => "acs_ulcorner");
    mode!(string AcsLLcorner => "acs_llcorner");
    mode!(string AcsURcorner => "acs_urcorner");
    mode!(string AcsLRcorner => "acs_lrcorner");
    mode!(string AcsLTee => "acs_ltee");
    mode!(string AcsRTee => "acs_rtee");
    mode!(string AcsBTee => "acs_btee");
    mode!(string AcsTTee => "acs_ttee");
    mode!(string AcsHLine => "acs_hline");
    mode!(string AcsVLine => "acs_vline");
    mode!(string AcsPlus => "acs_plus");
    mode!(string MemoryLock => "memory_lock");
    mode!(string MemoryUnlock => "memory_unlock");
    mode!(string BoxChars1 => "box_chars_1");

    mode!(string ChangeScrollRegion => "change_scroll_region";
        top:    u32,
        bottom: u32);

    mode!(string ColumnAddress => "column_address";
        x: u32);

    mode!(string CursorAddress => "cursor_address";
        y: u32,
        x: u32);

    mode!(string EraseChars => "erase_chars";
        count: u32);

    mode!(string ParmDch => "parm_dch";
        count: u32);

    mode!(string ParmDeleteLine => "parm_delete_line";
        count: u32);

    mode!(string ParmDownCursor => "parm_down_cursor";
        count: u32);

    mode!(string ParmIch => "parm_ich";
        count: u32);

    mode!(string ParmIndex => "parm_index";
        count: u32);

    mode!(string ParmInsertLine => "parm_insert_line";
        count: u32);

    mode!(string ParmLeftCursor => "parm_left_cursor";
        count: u32);

    mode!(string ParmRightCursor => "parm_right_cursor";
        count: u32);

    mode!(string ParmRindex => "parm_rindex";
        count: u32);

    mode!(string ParmUpCursor => "parm_up_cursor";
        count: u32);

    mode!(string ParmDownMicro => "parm_down_micro";
        count: u32);

    mode!(string ParmLeftMicro => "parm_left_micro";
        count: u32);

    mode!(string ParmRightMicro => "parm_right_micro";
        count: u32);

    mode!(string ParmUpMicro => "parm_up_micro";
        count: u32);

    mode!(string RowAddress => "row_address";
        y: u32);

    mode!(string SetAttributes => "set_attributes";
        standout:    bool,
        underline:   bool,
        reverse:     bool,
        blink:       bool,
        dim:         bool,
        bold:        bool,
        invisible:   bool,
        protected:   bool,
        alt_charset: bool);

    mode!(string SetAForeground => "set_a_foreground";
        color: u8);

    mode!(string SetABackground => "set_a_background";
        color: u8);

    mode!(string SetForeground => "set_foreground";
        color: u8);

    mode!(string SetBackground => "set_background";
        color: u8);

    // Extended capabilities from screen.
    mode!(boolean XTermTitle => "XT");
    mode!(boolean BrightAttribute => "AX");
    mode!(boolean XTermMouse => "XM");
    // Extended capabilities from tmux.
    mode!(boolean TrueColor => "Tc");
    mode!(string SetClipboard => "Ms";
        selection: String,
        content:   Vec<u8>);

    mode!(string SetCursorStyle => "Ss";
        kind: u8);

    mode!(string ResetCursorStyle => "Se");
    // True color extended capabilities from vim.
    mode!(string SetTrueColorForeground => "8f";
        r: u8,
        g: u8,
        b: u8);

    mode!(string SetTrueColorBackground => "8b";
        r: u8,
        g: u8,
        b: u8);

    mode!(string ResetCursorColor => "Cr");

    mode!(string SetCursorColor => "Cs";
        color: String);


    pub fn parse(input: &[u8]) -> IResult<&[u8], Item> { alt((expansion, string))(input) }

    pub fn string(input: &[u8]) -> IResult<&[u8], Item> { map(complete::take_till(|b| b == b'%'), Item::String)(input) }

    pub fn expansion(input: &[u8]) -> IResult<&[u8], Item>
    {
        let (input, _) = tag("%")(input)?;
        let (input, item) = alt((percent, constant, variable, operation, conditional, print))(input)?;
        Ok((input, item))
    }

    pub fn percent(input: &[u8]) -> IResult<&[u8], Item> { value(Item::String(b"%"), tag("%"))(input) }

    pub fn constant(input: &[u8]) -> IResult<&[u8], Item> { alt((constant_char, constant_integer))(input) }

    pub fn constant_char(input: &[u8]) -> IResult<&[u8], Item>
    {
        let (input, _) = tag("'")(input)?;
        let (input, ch) = take(1_usize)(input)?;
        let (input, _) = tag("'")(input)?;
        Ok((input, Item::Constant(Constant::Character(ch[0]))))
    }

    pub fn constant_integer(input: &[u8]) -> IResult<&[u8], Item>
    {
        let (input, _) = tag("{")(input)?;
        let (input, digit) = take_while(is::digit)(input)?;
        let (input, _) = tag("}")(input)?;
        Ok((input, Item::Constant(Constant::Integer(numeric(digit)))))
    }

    pub fn variable(input: &[u8]) -> IResult<&[u8], Item>
    {
        let (input, c) = take(1_usize)(input)?;
        match c
        {
            b"l" => Ok((input, Item::Variable(Variable::Length))),

            b"p" => map(one_of("123456789"), |n| Item::Variable(Variable::Push(n as u8 - b'1')))(input),

            b"P" => alt
            ((
                map(one_of("abcdefghijklmnopqrstuvwxyz"), |n|
                { Item::Variable(Variable::Set(true, n as u8 - b'a')) }),
                
                map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| 
                { Item::Variable(Variable::Set(false, n as u8 - b'A')) }),
            ))(input),

            b"g" => alt
            ((
                map(one_of("abcdefghijklmnopqrstuvwxyz"), |n|
                { Item::Variable(Variable::Get(true, n as u8 - b'a')) }),
                
                map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n|
                { Item::Variable(Variable::Get(false, n as u8 - b'A')) }),
            ))(input),

            _ => Err(Err::Error(make_error(input, ErrorKind::Switch))),
        }
    }

    pub fn operation(input: &[u8]) -> IResult<&[u8], Item> 
    {
        let (input, c) = take(1_usize)(input)?;
        match c 
        {
            b"+" => Ok((input, Item::Operation(Operation::Binary(Binary::Add)))),
            b"-" => Ok((input, Item::Operation(Operation::Binary(Binary::Subtract)))),
            b"*" => Ok((input, Item::Operation(Operation::Binary(Binary::Multiply)))),
            b"/" => Ok((input, Item::Operation(Operation::Binary(Binary::Divide)))),
            b"m" => Ok((input, Item::Operation(Operation::Binary(Binary::Remainder)))),
            b"i" => Ok((input, Item::Operation(Operation::Increment))),
            b"&" => Ok((input, Item::Operation(Operation::Binary(Binary::AND)))),
            b"|" => Ok((input, Item::Operation(Operation::Binary(Binary::OR)))),
            b"^" => Ok((input, Item::Operation(Operation::Binary(Binary::XOR)))),
            b"~" => Ok((input, Item::Operation(Operation::Unary(Unary::NOT)))),
            b"A" => Ok((input, Item::Operation(Operation::Binary(Binary::And)))),
            b"O" => Ok((input, Item::Operation(Operation::Binary(Binary::Or)))),
            b"!" => Ok((input, Item::Operation(Operation::Unary(Unary::Not)))),
            b"=" => Ok((input, Item::Operation(Operation::Binary(Binary::Equal)))),
            b">" => Ok((input, Item::Operation(Operation::Binary(Binary::Greater)))),
            b"<" => Ok((input, Item::Operation(Operation::Binary(Binary::Lesser)))),
            _ => Err( Err::Error( make_error( input, ErrorKind::Switch ) ) ),
        }
    }

    pub fn conditional(input: &[u8]) -> IResult<&[u8], Item> 
    {
        let (input, c) = take(1_usize)(input)?;
        match c 
        {
            b"?" => Ok((input, Item::Conditional(Conditional::If))),
            b"t" => Ok((input, Item::Conditional(Conditional::Then))),
            b"e" => Ok((input, Item::Conditional(Conditional::Else))),
            b";" => Ok((input, Item::Conditional(Conditional::End))),
            _ => Err( Err::Error( make_error( input, ErrorKind::Switch ) ) ),
        }
    }

    pub fn print(input: &[u8]) -> IResult<&[u8], Item> 
    {
        let (input, _) = opt(tag(":"))(input)?;
        let (input, flags) = take_while(is::flag)(input)?;
        let (input, width) = opt(take_while(is::digit))(input)?;
        let (input, precision) = opt(| input | 
        {
            let (input, _) = tag(".")(input)?;
            let (input, amount) = take_while(is::digit)(input)?;
            Ok((input, amount))
        })(input)?;
        let (input, format) = one_of("doxXsc")(input)?;
        Ok
        ((
            input,
            Item::Print(Print 
            {
                flags: Flags 
                {
                    width: numeric(width.unwrap_or(b"0")) as usize,
                    precision: numeric(precision.unwrap_or(b"0")) as usize,
                    alternate: flags.contains(&b'#'),
                    left: flags.contains(&b'-'),
                    sign: flags.contains(&b'+'),
                    space: flags.contains(&b' '),
                },

                format: match format 
                {
                    'd' => Format::Dec,
                    'o' => Format::Oct,
                    'x' => Format::Hex,
                    'X' => Format::HEX,
                    's' => Format::Str,
                    'c' => Format::Chr,
                    'u' => Format::Uni,
                    _ => unreachable!(),
                },
            }),
        ))
    }
}

pub mod net
{
    pub use std::net::{ * };
}

pub mod now
{
    use ::
    {
        collections::{ HashMap }, 
        io::{ self, Read, Write },
        regex::{ contains, Regex },
        shell::{ self, Shell },
        types::{ * },
        *,
    };
    /// Entry point for non-ttys (e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty(sh: &mut Shell)
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();

        match handle.read_to_string(&mut buffer)
        {
            Ok(_) =>
            {
                log!("run non tty command: {}", &buffer);
                run_command_line(sh, &buffer, false, false);
            }

            Err(e) => { println!("cicada: stdin.read_to_string() failed: {:?}", e); }
        }
    }

    pub fn run_command_line(sh:&mut Shell, line: &str, tty: bool, capture: bool) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::line::line_to_cmds(line)
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }
            
            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = run_proc(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }

        cr_list
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String>
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let ptn_env_exp = r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$";
        let re = Regex::new(ptn_env_exp).unwrap();
        
        for (sep, text) in tokens.iter()
        {
            if !sep.is_empty() || !contains(text, ptn_env_exp) { break; }

            for cap in re.captures_iter(text)
            {
                let name = cap[1].to_string();
                let value = parsers::line::unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }

        if n > 0 { tokens.drain(0..n); }

        envs
    }

    fn line_to_tokens(sh:&mut Shell, line: &str) -> (Tokens, HashMap<String, String>)
    {
        let linfo = parsers::line::parse(line);
        let mut tokens = linfo.tokens;
        shell::do_expansion(sh, &mut tokens);
        let envs = drain_env_tokens(&mut tokens);
        (tokens, envs)
    }

    fn set_shell_vars(sh:&mut Shell, envs: &HashMap<String, String>)
    {
        for (name, value) in envs.iter()
        {
            sh.set_env(name, value);
        }
    }
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    fn run_proc(sh:&mut Shell, line: &str, tty: bool, capture: bool) -> CommandResult
    {
        let log_cmd = !sh.cmd.starts_with(' ');

        match CommandLine::from_line(line, sh)
        {
            Ok(cl) =>
            {
                if cl.is_empty()
                {
                    if !cl.envs.is_empty() { set_shell_vars(sh, &cl.envs); }
                    return CommandResult::new();
                }

                let (term_given, cr) = core::run_pipeline(sh, &cl, tty, capture, log_cmd);

                if term_given
                {
                    unsafe
                    {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }

                cr
            }
            
            Err(e) =>
            {
                println_stderr!("cicada: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }

    fn run_with_shell(sh:&mut Shell, line: &str) -> CommandResult
    {
        let (tokens, envs) = line_to_tokens(sh, line);
        
        if tokens.is_empty()
        {
            set_shell_vars(sh, &envs);
            return CommandResult::new();
        }

        match CommandLine::from_line(line, sh)
        {
            Ok(c) =>
            {
                let (term_given, cr) = core::run_pipeline(sh, &c, false, true, false);
                if term_given
                {
                    unsafe
                    {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }

                cr
            }

            Err(e) =>
            {
                println_stderr!("cicada: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }

    pub fn run(line: &str) -> CommandResult
    {
        let mut sh = Shell::new();
        run_with_shell(&mut sh, line)
    }
}

pub mod num
{
    pub use std::num::{ * };
    
    pub mod big
    {
        //! Big Integer Types for Rust
        use ::
        {
            *,
        };

        #[macro_use]
        pub mod macros
        {
            use ::
            {
                *,
            };

            macro_rules! cfg_32 
            {
                ($($any:tt)+) => 
                {
                    #[cfg(not(target_pointer_width = "64"))] $($any)+
                }
            }

            macro_rules! cfg_32_or_test 
            {
                ($($any:tt)+) => 
                {
                    #[cfg(any(not(target_pointer_width = "64"), test))] $($any)+
                }
            }

            macro_rules! cfg_64 
            {
                ($($any:tt)+) => 
                {
                    #[cfg(target_pointer_width = "64")] $($any)+
                }
            }

            macro_rules! cfg_digit 
            {
                ($item32:item $item64:item) => 
                {
                    cfg_32!($item32);
                    cfg_64!($item64);
                };
            }

            macro_rules! cfg_digit_expr 
            {
                ($expr32:expr, $expr64:expr) => 
                {
                    cfg_32!($expr32);
                    cfg_64!($expr64);
                };
            }

            macro_rules! forward_val_val_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_val_val_binop_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $res {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                           
                            if self.capacity() >= other.capacity() 
                            {
                                $imp::$method(self, &other)
                            } else 
                            {
                                $imp::$method(other, &self)
                            }
                        }
                    }
                };
            }

            macro_rules! forward_ref_val_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                           
                            $imp::$method(self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_val_binop_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for &$res {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(other, self)
                        }
                    }
                };
            }

            macro_rules! forward_val_ref_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<&$res> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                           
                            $imp::$method(&self, other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_ref_binop 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<&$res> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                           
                            $imp::$method(self.clone(), other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_ref_binop_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<&$res> for &$res {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                           
                            if self.len() >= other.len() 
                            {
                                $imp::$method(self.clone(), other)
                            } else 
                            {
                                $imp::$method(other.clone(), self)
                            }
                        }
                    }
                };
            }

            macro_rules! forward_val_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $res 
                    {
                        #[inline] fn $method(&mut self, other: $res) 
                        {
                            self.$method(&other);
                        }
                    }
                };
            }

            macro_rules! forward_val_assign_scalar 
            {
                (impl $imp:ident for $res:ty, $scalar:ty, $method:ident) => 
                {
                    impl $imp<$res> for $scalar 
                    {
                        #[inline] fn $method(&mut self, other: $res) 
                        {
                            self.$method(&other);
                        }
                    }
                };
            }
            /// use this if val_val_binop is already implemented and the reversed order is required
            macro_rules! forward_scalar_val_val_binop_commutative 
            {
                (impl $imp:ident < $scalar:ty > for $res:ty, $method:ident) => 
                {
                    impl $imp<$res> for $scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(other, self)
                        }
                    }
                };
            }
            
            macro_rules! forward_scalar_val_val_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<$scalar> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $scalar) -> $res 
                        {
                            $imp::$method(&self, other)
                        }
                    }

                    impl $imp<$res> for $scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_ref_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(self, *other)
                        }
                    }

                    impl $imp<&$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            $imp::$method(*self, other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_val_ref_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for $res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(&self, *other)
                        }
                    }

                    impl $imp<$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(*self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_val_ref_binop_to_val_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for $res {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(self, *other)
                        }
                    }

                    impl $imp<$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $res) -> $res 
                        {
                            $imp::$method(*self, other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_val_binop_to_val_val 
            {
                (impl $imp:ident < $scalar:ty > for $res:ty, $method:ident) => 
                {
                    impl $imp<$scalar> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: $scalar) -> $res 
                        {
                            $imp::$method(self.clone(), other)
                        }
                    }

                    impl $imp<&$res> for $scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            $imp::$method(self, other.clone())
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_ref_binop_to_val_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    impl $imp<&$scalar> for &$res 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$scalar) -> $res 
                        {
                            $imp::$method(self.clone(), *other)
                        }
                    }

                    impl $imp<&$res> for &$scalar 
                    {
                        type Output = $res;

                        #[inline] fn $method(self, other: &$res) -> $res 
                        {
                            $imp::$method(*self, other.clone())
                        }
                    }
                };
            }

            macro_rules! promote_scalars 
            {
                (impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),*) => 
                {
                    $(
                        forward_all_scalar_binop_to_val_val!(impl $imp<$scalar> for $res, $method);

                        impl $imp<$scalar> for $res 
                        {
                            type Output = $res;

                            #[allow(clippy::cast_lossless)]
                            #[inline]
                            fn $method(self, other: $scalar) -> $res 
                            {
                                $imp::$method(self, other as $promo)
                            }
                        }

                        impl $imp<$res> for $scalar 
                        {
                            type Output = $res;

                            #[allow(clippy::cast_lossless)]
                            #[inline]
                            fn $method(self, other: $res) -> $res 
                            {
                                $imp::$method(self as $promo, other)
                            }
                        }
                    )*
                }
            }
            macro_rules! promote_scalars_assign 
            {
                (impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),*) => 
                {
                    $(
                        impl $imp<$scalar> for $res 
                        {
                            #[allow(clippy::cast_lossless)]
                            #[inline]
                            fn $method(&mut self, other: $scalar) 
                            {
                                self.$method(other as $promo);
                            }
                        }
                    )*
                }
            }

            macro_rules! promote_unsigned_scalars 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars!(impl $imp<u32> for $res, $method, u8, u16);
                    promote_scalars!(impl $imp<UsizePromotion> for $res, $method, usize);
                }
            }

            macro_rules! promote_unsigned_scalars_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars_assign!(impl $imp<u32> for $res, $method, u8, u16);
                    promote_scalars_assign!(impl $imp<UsizePromotion> for $res, $method, usize);
                }
            }

            macro_rules! promote_signed_scalars 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars!(impl $imp<i32> for $res, $method, i8, i16);
                    promote_scalars!(impl $imp<IsizePromotion> for $res, $method, isize);
                }
            }

            macro_rules! promote_signed_scalars_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_scalars_assign!(impl $imp<i32> for $res, $method, i8, i16);
                    promote_scalars_assign!(impl $imp<IsizePromotion> for $res, $method, isize);
                }
            }
            
            macro_rules! forward_all_binop_to_ref_ref 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    forward_val_val_binop!(impl $imp for $res, $method);
                    forward_val_ref_binop!(impl $imp for $res, $method);
                    forward_ref_val_binop!(impl $imp for $res, $method);
                };
            }
            
            macro_rules! forward_all_binop_to_val_ref 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    forward_val_val_binop!(impl $imp for $res, $method);
                    forward_ref_val_binop!(impl $imp for $res, $method);
                    forward_ref_ref_binop!(impl $imp for $res, $method);
                };
            }
            
            macro_rules! forward_all_binop_to_val_ref_commutative 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    forward_val_val_binop_commutative!(impl $imp for $res, $method);
                    forward_ref_val_binop_commutative!(impl $imp for $res, $method);
                    forward_ref_ref_binop_commutative!(impl $imp for $res, $method);
                };
            }

            macro_rules! forward_all_scalar_binop_to_ref_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    forward_scalar_val_val_binop_to_ref_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_val_ref_binop_to_ref_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_ref_ref_binop_to_ref_val!(impl $imp<$scalar> for $res, $method);
                }
            }

            macro_rules! forward_all_scalar_binop_to_val_val 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    forward_scalar_val_ref_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_ref_val_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                    forward_scalar_ref_ref_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                }
            }

            macro_rules! forward_all_scalar_binop_to_val_val_commutative 
            {
                (impl $imp:ident<$scalar:ty> for $res:ty, $method:ident) => 
                {
                    forward_scalar_val_val_binop_commutative!(impl $imp<$scalar> for $res, $method);
                    forward_all_scalar_binop_to_val_val!(impl $imp<$scalar> for $res, $method);
                }
            }

            macro_rules! promote_all_scalars 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_unsigned_scalars!(impl $imp for $res, $method);
                    promote_signed_scalars!(impl $imp for $res, $method);
                }
            }

            macro_rules! promote_all_scalars_assign 
            {
                (impl $imp:ident for $res:ty, $method:ident) => 
                {
                    promote_unsigned_scalars_assign!(impl $imp for $res, $method);
                    promote_signed_scalars_assign!(impl $imp for $res, $method);
                }
            }

            macro_rules! impl_sum_iter_type 
            {
                ($res:ty) => 
                {
                    impl<T> Sum<T> for $res
                    where
                        $res: Add<T, Output = $res>,
                    {
                        fn sum<I>(iter: I) -> Self
                        where
                            I: Iterator<Item = T>,
                        {
                            iter.fold(Self::ZERO, <$res>::add)
                        }
                    }
                };
            }

            macro_rules! impl_product_iter_type 
            {
                ($res:ty) => 
                {
                    impl<T> Product<T> for $res
                    where
                        $res: Mul<T, Output = $res>,
                    {
                        fn product<I>(iter: I) -> Self
                        where
                            I: Iterator<Item = T>,
                        {
                            iter.fold(One::one(), <$res>::mul)
                        }
                    }
                };
            }
        }
        
        pub mod bigint
        {
            use ::
            {
                cmp::Ordering::{self, Equal},
                default::{ Default },
                num::
                {
                    big::
                    {
                        big_digit::{ self, BigDigit },
                        Sign::{Minus, NoSign, Plus},
                        biguint::{to_str_radix_reversed, BigUint, IntDigits, U32Digits, U64Digits}
                    },
                    integers::{ Integer, Roots },
                    traits::{ConstZero, Num, One, Pow, Signed, Zero},
                },
                ops::{ Neg, Not },
                string::{ String },
                vec::{ Vec },
                *,
            };

            pub mod addition
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            bigint::{ UnsignedAbs, CheckedUnsignedAbs::{ self, Negative, Positive } },
                            BigInt, Sign::{Minus, NoSign, Plus}, IsizePromotion, UsizePromotion,
                        },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                
                macro_rules! bigint_add
                {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => $b_owned,
                            (Plus, Plus) | (Minus, Minus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                            (Plus, Minus) | (Minus, Plus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint($b.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Add<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: &BigInt) -> BigInt
                    {
                        bigint_add!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Add<BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Add<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: &BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Add<BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other, other.data)
                    }
                }

                impl AddAssign<&BigInt> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: &BigInt) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }
                forward_val_assign!(impl AddAssign for BigInt, add_assign);

                promote_all_scalars!(impl Add for BigInt, add);
                promote_all_scalars_assign!(impl AddAssign for BigInt, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigInt, add);

                impl Add<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u32> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: u32) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u64> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: u64) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => BigInt::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }
                impl AddAssign<u128> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: u128) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i128> for BigInt, add);

                impl Add<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i32> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i64> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i128> for BigInt 
                {
                    #[inline] fn add_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl CheckedAdd for BigInt 
                {
                    #[inline] fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigInt);

            } pub use self::addition::{ * };

            pub mod division
            
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self, * },
                                BigInt, UnsignedAbs,
                            },
                            IsizePromotion, UsizePromotion,
                        },
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, Signed, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };
                
                forward_all_binop_to_ref_ref!(impl Div for BigInt, div);

                impl Div<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: &BigInt) -> BigInt {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }

                impl DivAssign<&BigInt> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: &BigInt) {
                        *self = &*self / other;
                    }
                }
                forward_val_assign!(impl DivAssign for BigInt, div_assign);

                promote_all_scalars!(impl Div for BigInt, div);
                promote_all_scalars_assign!(impl DivAssign for BigInt, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigInt, div);

                impl Div<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u32> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: u32) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u32 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u64> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: u64) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u64 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u128> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: u128) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u128 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Div<i32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i128> for BigInt, div);

                impl Div<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i32> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i32 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i64> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i64 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i128> for BigInt 
                {
                    #[inline] fn div_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i128 
                {
                    type Output = BigInt;

                    #[inline] fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                forward_all_binop_to_ref_ref!(impl Rem for BigInt, rem);

                impl Rem<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: &BigInt) -> BigInt {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else if let Some(other) = other.to_i32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }

                impl RemAssign<&BigInt> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: &BigInt) {
                        *self = &*self % other;
                    }
                }
                forward_val_assign!(impl RemAssign for BigInt, rem_assign);

                promote_all_scalars!(impl Rem for BigInt, rem);
                promote_all_scalars_assign!(impl RemAssign for BigInt, rem_assign);
                forward_all_scalar_binop_to_val_val!(impl Rem<u32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigInt, rem);

                impl Rem<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u32> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: u32) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u32 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u64> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: u64) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u64 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u128> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: u128) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u128 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Rem<i32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i128> for BigInt, rem);

                impl Rem<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: i32) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i32> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: i32) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i32 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: i64) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i64> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: i64) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i64 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: i128) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i128> for BigInt 
                {
                    #[inline] fn rem_assign(&mut self, other: i128) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i128 
                {
                    type Output = BigInt;

                    #[inline] fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl CheckedDiv for BigInt 
                {
                    #[inline] fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigInt 
                {
                    #[inline] fn checked_div_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline] fn checked_rem_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigInt 
                {
                    #[inline] fn div_euclid(&self, v: &BigInt) -> BigInt {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                q - 1
                            } else {
                                q + 1
                            }
                        } else {
                            q
                        }
                    }

                    #[inline] fn rem_euclid(&self, v: &BigInt) -> BigInt {
                        let r = self % v;
                        if r.is_negative() {
                            if v.is_positive() {
                                r + v
                            } else {
                                r - v
                            }
                        } else {
                            r
                        }
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) 
                    {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                (q - 1, r + v)
                            } else {
                                (q + 1, r - v)
                            }
                        } else {
                            (q, r)
                        }
                    }
                }

            } pub use self::division::{ * };

            pub mod multiplication
            {
                use ::
                {
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self,* },
                                BigInt, UnsignedAbs
                            },
                            IsizePromotion, UsizePromotion,
                        },
                        traits::{CheckedMul, One, Zero},
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                
                impl Mul<Sign> for Sign
                {
                    type Output = Sign;

                    #[inline] fn mul(self, other: Sign) -> Sign {
                        match (self, other) {
                            (NoSign, _) | (_, NoSign) => NoSign,
                            (Plus, Plus) | (Minus, Minus) => Plus,
                            (Plus, Minus) | (Minus, Plus) => Minus,
                        }
                    }
                }

                macro_rules! impl_mul 
                {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigInt;

                            #[inline]
                            fn mul(self, other: $Other) -> BigInt {
                                let BigInt { data: x, .. } = self;
                                let BigInt { data: y, .. } = other;
                                BigInt::from_biguint(self.sign * other.sign, x * y)
                            }
                        }
                    )*}
                }
                impl_mul! 
                {
                    impl Mul<BigInt> for BigInt;
                    impl Mul<BigInt> for &BigInt;
                    impl Mul<&BigInt> for BigInt;
                    impl Mul<&BigInt> for &BigInt;
                }

                macro_rules! impl_mul_assign 
                {
                    ($(impl MulAssign<$Other:ty> for BigInt;)*) => {$(
                        impl MulAssign<$Other> for BigInt {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                                let BigInt { data: y, .. } = other;
                                self.data *= y;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                } else {
                                    self.sign = self.sign * other.sign;
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! 
                {
                    impl MulAssign<BigInt> for BigInt;
                    impl MulAssign<&BigInt> for BigInt;
                }

                promote_all_scalars!(impl Mul for BigInt, mul);
                promote_all_scalars_assign!(impl MulAssign for BigInt, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigInt, mul);

                impl Mul<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u32> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: u32) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u64> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: u64) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u128> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: u128) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i128> for BigInt, mul);

                impl Mul<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i32> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i64> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn mul(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i128> for BigInt 
                {
                    #[inline] fn mul_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl CheckedMul for BigInt 
                {
                    #[inline] fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigInt);

            } pub use self::multiplication::{ * };

            pub mod subtraction
            {
                
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self,* },
                                BigInt, UnsignedAbs
                            },
                            IsizePromotion, UsizePromotion,
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                macro_rules! bigint_sub 
                {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => -$b_owned,
                            (Plus, Minus) | (Minus, Plus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                            (Plus, Plus) | (Minus, Minus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint(-$a.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Sub<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Sub<BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Sub<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Sub<BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other, other.data)
                    }
                }

                impl SubAssign<&BigInt> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: &BigInt) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }
                forward_val_assign!(impl SubAssign for BigInt, sub_assign);

                promote_all_scalars!(impl Sub for BigInt, sub);
                promote_all_scalars_assign!(impl SubAssign for BigInt, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigInt, sub);

                impl Sub<u32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }
                impl SubAssign<u32> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: u32) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<BigInt> for u32 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u64 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u128 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<u64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u64> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: u64) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<u128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u128> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: u128) 
                    {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Sub<i32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i128> for BigInt, sub);

                impl Sub<i32> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i32> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i32 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i64> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i64> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i64 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i128> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }

                impl SubAssign<i128> for BigInt 
                {
                    #[inline] fn sub_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i128 
                {
                    type Output = BigInt;

                    #[inline] fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl CheckedSub for BigInt 
                {
                    #[inline] fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.sub(v))
                    }
                }

            } pub use self::subtraction::{ * };

            pub mod bits
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                CheckedUnsignedAbs::{ Negative, Positive },
                                Sign::{ self,* },
                                BigInt, UnsignedAbs
                            },
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::IntDigits,
                            IsizePromotion, UsizePromotion,
                        },
                        traits::{ ToPrimitive, Zero },
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    vec::{ Vec },
                    *,
                };

                #[inline] fn negate_carry(a: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit 
                {
                    *acc += DoubleBigDigit::from(!a);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }
                
                fn bitand_pos_neg(a: &mut [BigDigit], b: &[BigDigit]) 
                {
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai &= twos_b;
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                }
                
                fn bitand_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_a = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = twos_a & bi;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => a.truncate(b.len()),
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().cloned());
                        }
                    }
                }
                
                fn bitand_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_and = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a & twos_b, &mut carry_and);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_and);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| 
                    {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_and)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_and != 0 {
                        a.push(1);
                    }
                }

                forward_val_val_binop!(impl BitAnd for BigInt, bitand);
                forward_ref_val_binop!(impl BitAnd for BigInt, bitand);
                
                impl BitAnd<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn bitand(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) | (_, NoSign) => BigInt::ZERO,
                            (Plus, Plus) => BigInt::from(&self.data & &other.data),
                            (Plus, Minus) => self.clone() & other,
                            (Minus, Plus) => other.clone() & self,
                            (Minus, Minus) => {
                               
                                if self.len() >= other.len() {
                                    self.clone() & other
                                } else {
                                    other.clone() & self
                                }
                            }
                        }
                    }
                }

                impl BitAnd<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn bitand(mut self, other: &BigInt) -> BigInt {
                        self &= other;
                        self
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigInt, bitand_assign);

                impl BitAndAssign<&BigInt> for BigInt 
                {
                    fn bitand_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (NoSign, _) => {}
                            (_, NoSign) => self.set_zero(),
                            (Plus, Plus) => {
                                self.data &= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitand_pos_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitand_neg_pos(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitand_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }
                
                fn bitor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai | twos_b, &mut carry_or);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            a.truncate(b.len());
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| 
                    {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_or)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }

                    debug_assert!(carry_or == 0);
                }
                
                fn bitor_neg_pos(a: &mut [BigDigit], b: &[BigDigit]) 
                {
                    let mut carry_a = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a | bi, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    if a.len() > b.len() {
                        for ai in a[b.len()..].iter_mut() {
                            let twos_a = negate_carry(*ai, &mut carry_a);
                            *ai = negate_carry(twos_a, &mut carry_or);
                        }
                        debug_assert!(carry_a == 0);
                    }
                    
                    debug_assert!(carry_or == 0);
                }
                
                fn bitor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a | twos_b, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    if a.len() > b.len() {
                        a.truncate(b.len());
                    }
                    
                    debug_assert!(carry_or == 0);
                }

                forward_val_val_binop!(impl BitOr for BigInt, bitor);
                forward_ref_val_binop!(impl BitOr for BigInt, bitor);
                
                impl BitOr<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn bitor(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) => other.clone(),
                            (_, NoSign) => self.clone(),
                            (Plus, Plus) => BigInt::from(&self.data | &other.data),
                            (Plus, Minus) => other.clone() | self,
                            (Minus, Plus) => self.clone() | other,
                            (Minus, Minus) => {
                               
                                if self.len() <= other.len() {
                                    self.clone() | other
                                } else {
                                    other.clone() | self
                                }
                            }
                        }
                    }
                }

                impl BitOr<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn bitor(mut self, other: &BigInt) -> BigInt {
                        self |= other;
                        self
                    }
                }

                forward_val_assign!(impl BitOrAssign for BigInt, bitor_assign);

                impl BitOrAssign<&BigInt> for BigInt 
                {
                    fn bitor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => self.data |= &other.data,
                            (Plus, Minus) => {
                                bitor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitor_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }
                
                fn bitxor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_b = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_b = !0;
                                *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                            }
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| 
                    {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_xor)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }
                
                fn bitxor_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_a = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a ^ bi, &mut carry_xor);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_xor);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| 
                    {
                                let twos_a = !0;
                                negate_carry(twos_a ^ bi, &mut carry_xor)
                            }));
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }
                
                fn bitxor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) 
                    {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = twos_a ^ twos_b;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                let twos_b = !0;
                                *ai = twos_a ^ twos_b;
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| 
                    {
                                let twos_a = !0;
                                let twos_b = negate_carry(bi, &mut carry_b);
                                twos_a ^ twos_b
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigInt, bitxor);

                impl BitXor<&BigInt> for BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn bitxor(mut self, other: &BigInt) -> BigInt {
                        self ^= other;
                        self
                    }
                }

                forward_val_assign!(impl BitXorAssign for BigInt, bitxor_assign);

                impl BitXorAssign<&BigInt> for BigInt 
                {
                    fn bitxor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => {
                                self.data ^= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitxor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitxor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitxor_neg_neg(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                        }
                    }
                }

                pub fn set_negative_bit(x: &mut BigInt, bit: u64, value: bool) 
                {
                    debug_assert_eq!(x.sign, Minus);
                    let data = &mut x.data;

                    let bits_per_digit = u64::from(big_digit::BITS);
                    if bit >= bits_per_digit * data.len() as u64 {
                        if !value {
                            data.set_bit(bit, true);
                        }
                    } else {
                        let trailing_zeros = data.trailing_zeros().unwrap();
                        if bit > trailing_zeros {
                            data.set_bit(bit, !value);
                        } else if bit == trailing_zeros && !value {
                            let bit_index = (bit / bits_per_digit).to_usize().unwrap();
                            let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                            let mut digit_iter = data.digits_mut().iter_mut().skip(bit_index);
                            let mut carry_in = 1;
                            let mut carry_out = 1;

                            let digit = digit_iter.next().unwrap();
                            let twos_in = negate_carry(*digit, &mut carry_in);
                            let twos_out = twos_in & !bit_mask;
                            *digit = negate_carry(twos_out, &mut carry_out);

                            for digit in digit_iter {
                                if carry_in == 0 && carry_out == 0 {
                                    break;
                                }
                                let twos = negate_carry(*digit, &mut carry_in);
                                *digit = negate_carry(twos, &mut carry_out);
                            }

                            if carry_out != 0 {
                                debug_assert_eq!(carry_in, 0);
                                data.digits_mut().push(1);
                            }
                        } else if bit < trailing_zeros && value {
                            let index_lo = (bit / bits_per_digit).to_usize().unwrap();
                            let index_hi = (trailing_zeros / bits_per_digit).to_usize().unwrap();
                            let bit_mask_lo = big_digit::MAX << (bit % bits_per_digit);
                            let bit_mask_hi =
                                big_digit::MAX >> (bits_per_digit - 1 - (trailing_zeros % bits_per_digit));
                            let digits = data.digits_mut();

                            if index_lo == index_hi {
                                digits[index_lo] ^= bit_mask_lo & bit_mask_hi;
                            } else {
                                digits[index_lo] = bit_mask_lo;
                                for digit in &mut digits[index_lo + 1..index_hi] {
                                    *digit = big_digit::MAX;
                                }
                                digits[index_hi] ^= bit_mask_hi;
                            }
                        } else {
                        }
                    }
                }
            } pub use self::bits::{ * };

            pub mod convert
            {
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    convert::{ TryFrom },
                    num::
                    {
                        big::
                        {
                            bigint::
                            {
                                Sign::{ self,* },
                                BigInt, ToBigInt
                            },
                            TryFromBigIntError, BigUint, ParseBigIntError, ToBigUint,
                        },
                        traits::{ FromPrimitive, Num, One, ToPrimitive, Zero },
                    },
                    str::{ self, FromStr },
                    vec::{ Vec },
                    *,
                };

                impl FromStr for BigInt {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
                        BigInt::from_str_radix(s, 10)
                    }
                }

                impl Num for BigInt {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a [`BigInt`].
                    #[inline] fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
                        let sign = if let Some(tail) = s.strip_prefix('-') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                            Minus
                        } else {
                            Plus
                        };
                        let bu = BigUint::from_str_radix(s, radix)?;
                        Ok(BigInt::from_biguint(sign, bu))
                    }
                }

                impl ToPrimitive for BigInt {
                    #[inline] fn to_i64(&self) -> Option<i64> {
                        match self.sign {
                            Plus => self.data.to_i64(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u64()?;
                                let m: u64 = 1 << 63;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i64)),
                                    Equal => Some(i64::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline] fn to_i128(&self) -> Option<i128> {
                        match self.sign {
                            Plus => self.data.to_i128(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u128()?;
                                let m: u128 = 1 << 127;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i128)),
                                    Equal => Some(i128::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline] fn to_u64(&self) -> Option<u64> {
                        match self.sign {
                            Plus => self.data.to_u64(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline] fn to_u128(&self) -> Option<u128> {
                        match self.sign {
                            Plus => self.data.to_u128(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline] fn to_f32(&self) -> Option<f32> {
                        let n = self.data.to_f32()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }

                    #[inline] fn to_f64(&self) -> Option<f64> {
                        let n = self.data.to_f64()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }
                }

                macro_rules! impl_try_from_bigint {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigInt> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigInt) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigInt> for $T {
                            type Error = TryFromBigIntError<BigInt>;

                            #[inline]
                            fn try_from(value: BigInt) -> Result<$T, TryFromBigIntError<BigInt>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_bigint!(u8, ToPrimitive::to_u8);
                impl_try_from_bigint!(u16, ToPrimitive::to_u16);
                impl_try_from_bigint!(u32, ToPrimitive::to_u32);
                impl_try_from_bigint!(u64, ToPrimitive::to_u64);
                impl_try_from_bigint!(usize, ToPrimitive::to_usize);
                impl_try_from_bigint!(u128, ToPrimitive::to_u128);

                impl_try_from_bigint!(i8, ToPrimitive::to_i8);
                impl_try_from_bigint!(i16, ToPrimitive::to_i16);
                impl_try_from_bigint!(i32, ToPrimitive::to_i32);
                impl_try_from_bigint!(i64, ToPrimitive::to_i64);
                impl_try_from_bigint!(isize, ToPrimitive::to_isize);
                impl_try_from_bigint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigInt {
                    #[inline] fn from_i64(n: i64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_i128(n: i128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_u64(n: u64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_u128(n: u128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline] fn from_f64(n: f64) -> Option<BigInt> {
                        if n >= 0.0 {
                            BigUint::from_f64(n).map(BigInt::from)
                        } else {
                            let x = BigUint::from_f64(-n)?;
                            Some(-BigInt::from(x))
                        }
                    }
                }

                impl From<i64> for BigInt {
                    #[inline] fn from(n: i64) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u64)
                        } else {
                            let u = u64::MAX - (n as u64) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                impl From<i128> for BigInt {
                    #[inline] fn from(n: i128) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u128)
                        } else {
                            let u = u128::MAX - (n as u128) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                macro_rules! impl_bigint_from_int {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as i64)
                            }
                        }
                    };
                }

                impl_bigint_from_int!(i8);
                impl_bigint_from_int!(i16);
                impl_bigint_from_int!(i32);
                impl_bigint_from_int!(isize);

                impl From<u64> for BigInt {
                    #[inline] fn from(n: u64) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                impl From<u128> for BigInt {
                    #[inline] fn from(n: u128) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                macro_rules! impl_bigint_from_uint {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as u64)
                            }
                        }
                    };
                }

                impl_bigint_from_uint!(u8);
                impl_bigint_from_uint!(u16);
                impl_bigint_from_uint!(u32);
                impl_bigint_from_uint!(usize);

                impl From<BigUint> for BigInt {
                    #[inline] fn from(n: BigUint) -> Self {
                        if n.is_zero() {
                            Self::ZERO
                        } else {
                            BigInt {
                                sign: Plus,
                                data: n,
                            }
                        }
                    }
                }

                impl ToBigInt for BigInt {
                    #[inline] fn to_bigint(&self) -> Option<BigInt> {
                        Some(self.clone())
                    }
                }

                impl ToBigInt for BigUint {
                    #[inline] fn to_bigint(&self) -> Option<BigInt> {
                        if self.is_zero() {
                            Some(BigInt::ZERO)
                        } else {
                            Some(BigInt {
                                sign: Plus,
                                data: self.clone(),
                            })
                        }
                    }
                }

                impl ToBigUint for BigInt {
                    #[inline] fn to_biguint(&self) -> Option<BigUint> {
                        match self.sign() {
                            Plus => Some(self.data.clone()),
                            NoSign => Some(BigUint::ZERO),
                            Minus => None,
                        }
                    }
                }

                impl TryFrom<&BigInt> for BigUint {
                    type Error = TryFromBigIntError<()>;

                    #[inline] fn try_from(value: &BigInt) -> Result<BigUint, TryFromBigIntError<()>> {
                        value
                            .to_biguint()
                            .ok_or_else(|| TryFromBigIntError::new(()))
                    }
                }

                impl TryFrom<BigInt> for BigUint {
                    type Error = TryFromBigIntError<BigInt>;

                    #[inline] fn try_from(value: BigInt) -> Result<BigUint, TryFromBigIntError<BigInt>> {
                        if value.sign() == Sign::Minus {
                            Err(TryFromBigIntError::new(value))
                        } else {
                            Ok(value.data)
                        }
                    }
                }

                macro_rules! impl_to_bigint {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigInt for $T {
                            #[inline]
                            fn to_bigint(&self) -> Option<BigInt> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_bigint!(isize, FromPrimitive::from_isize);
                impl_to_bigint!(i8, FromPrimitive::from_i8);
                impl_to_bigint!(i16, FromPrimitive::from_i16);
                impl_to_bigint!(i32, FromPrimitive::from_i32);
                impl_to_bigint!(i64, FromPrimitive::from_i64);
                impl_to_bigint!(i128, FromPrimitive::from_i128);

                impl_to_bigint!(usize, FromPrimitive::from_usize);
                impl_to_bigint!(u8, FromPrimitive::from_u8);
                impl_to_bigint!(u16, FromPrimitive::from_u16);
                impl_to_bigint!(u32, FromPrimitive::from_u32);
                impl_to_bigint!(u64, FromPrimitive::from_u64);
                impl_to_bigint!(u128, FromPrimitive::from_u128);

                impl_to_bigint!(f32, FromPrimitive::from_f32);
                impl_to_bigint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigInt {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

                #[inline] pub fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    let sign = match digits.first() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                        let mut digits = Vec::from(digits);
                        twos_complement_be(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(digits))
                    }
                }

                #[inline] pub fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    let sign = match digits.last() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                        let mut digits = Vec::from(digits);
                        twos_complement_le(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(digits))
                    }
                }

                #[inline] pub fn to_signed_bytes_be(x: &BigInt) -> Vec<u8>
                {
                    let mut bytes = x.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or(0);
                    if first_byte > 0x7f
                        && !(first_byte == 0x80 && bytes.iter().skip(1).all(Zero::is_zero) && x.sign == Sign::Minus)
                    {
                        bytes.insert(0, 0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_be(&mut bytes);
                    }
                    bytes
                }

                #[inline] pub fn to_signed_bytes_le(x: &BigInt) -> Vec<u8>
                {
                    let mut bytes = x.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or(0);
                    if last_byte > 0x7f
                        && !(last_byte == 0x80
                            && bytes.iter().rev().skip(1).all(Zero::is_zero)
                            && x.sign == Sign::Minus)
                    {
                        bytes.push(0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_le(&mut bytes);
                    }
                    bytes
                }
                /// Perform in-place two's complement of the given binary representation,
                /// in little-endian byte order.
                #[inline] fn twos_complement_le(digits: &mut [u8]) {
                    twos_complement(digits)
                }
                /// Perform in-place two's complement of the given binary representation
                /// in big-endian byte order.
                #[inline] fn twos_complement_be(digits: &mut [u8]) {
                    twos_complement(digits.iter_mut().rev())
                }
                /// Perform in-place two's complement of the given digit iterator
                /// starting from the least significant byte.
                #[inline] fn twos_complement<'a, I>(digits: I)
                where
                    I: IntoIterator<Item = &'a mut u8>,
                {
                    let mut carry = true;
                    for d in digits {
                        *d = !*d;
                        if carry {
                            *d = d.wrapping_add(1);
                            carry = d.is_zero();
                        }
                    }
                }
            } pub use self::convert::{ * };

            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            bigint::{ BigInt, Sign::{self, * }, },
                            BigUint,
                        },
                        integers::{ Integer },
                        traits::{ Pow, Signed, Zero },
                    },
                    *,
                };
                /// Computes pow, the effect of the exponent on the sign.
                #[inline] fn powsign<T: Integer>(sign: Sign, other: &T) -> Sign {
                    if other.is_zero() {
                        Plus
                    } else if sign != Minus || other.is_odd() {
                        sign
                    } else {
                        -sign
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<&$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), Pow::pow(&self.data, rhs))
                            }
                        }

                        impl Pow<&$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), Pow::pow(&self.data, rhs))
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);
                pow_impl!(BigUint);

                pub fn modpow(x: &BigInt, exponent: &BigInt, modulus: &BigInt) -> BigInt {
                    assert!(
                        !exponent.is_negative(),
                        "negative exponentiation is not supported!"
                    );
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let result = x.data.modpow(&exponent.data, &modulus.data);
                    if result.is_zero() {
                        return BigInt::ZERO;
                    }
                    
                    let (sign, mag) = match (x.is_negative() && exponent.is_odd(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    BigInt::from_biguint(sign, mag)
                }

            } pub use self::power::{ * };

            pub mod shift
            {
                use ::
                {
                    num::
                    {
                        big::{ BigInt, Sign::{ self, * }, },
                        traits::{ PrimInt, Signed, Zero },
                    },
                    ops::{Shl, ShlAssign, Shr, ShrAssign},
                    *,
                };
                
                macro_rules! impl_shift
                {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigInt {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, self.data << rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, &self.data << rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigInt {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                self.data <<= rhs
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(&self, rhs);
                                let data = self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl Shr<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(self, rhs);
                                let data = &self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl ShrAssign<$rhs> for BigInt {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let round_down = shr_round_down(self, rhs);
                                self.data >>= rhs;
                                if round_down {
                                    self.data += 1u8;
                                } else if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
                
                fn shr_round_down<T: PrimInt>(i: &BigInt, shift: T) -> bool 
                {
                    if i.is_negative() 
                    {
                        let zeros = i.trailing_zeros().expect("negative values are non-zero");
                        shift > T::zero() && shift.to_u64().map(|shift| zeros < shift).unwrap_or(true)
                    } else {
                        false
                    }
                }
            } pub use self::shift::{ * };
            /// A `Sign` is a [`BigInt`]'s composing element.
            #[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
            pub enum Sign 
            {
                Minus,
                NoSign,
                Plus,
            }

            impl Neg for Sign 
            {
                type Output = Sign;
                /// Negate `Sign` value.
                #[inline] fn neg(self) -> Sign {
                    match self {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }
            /// A big signed integer type.
            pub struct BigInt 
            {
                sign: Sign,
                data: BigUint,
            }
            
            impl Clone for BigInt 
            {
                #[inline] fn clone(&self) -> Self {
                    BigInt {
                        sign: self.sign,
                        data: self.data.clone(),
                    }
                }

                #[inline] fn clone_from(&mut self, other: &Self) {
                    self.sign = other.sign;
                    self.data.clone_from(&other.data);
                }
            }

            impl hash::Hash for BigInt 
            {
                #[inline] fn hash<H: hash::Hasher>(&self, state: &mut H) {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    self.sign.hash(state);
                    if self.sign != NoSign {
                        self.data.hash(state);
                    }
                }
            }

            impl PartialEq for BigInt 
            {
                #[inline] fn eq(&self, other: &BigInt) -> bool {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    self.sign == other.sign && (self.sign == NoSign || self.data == other.data)
                }
            }

            impl Eq for BigInt {}

            impl PartialOrd for BigInt 
            {
                #[inline] fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Ord for BigInt 
            {
                #[inline] fn cmp(&self, other: &BigInt) -> Ordering {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    let scmp = self.sign.cmp(&other.sign);
                    if scmp != Equal {
                        return scmp;
                    }

                    match self.sign {
                        NoSign => Equal,
                        Plus => self.data.cmp(&other.data),
                        Minus => other.data.cmp(&self.data),
                    }
                }
            }

            impl Default for BigInt 
            {
                #[inline] fn default() -> BigInt {
                    Self::ZERO
                }
            }

            impl fmt::Debug for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(self, f)
                }
            }

            impl fmt::Display for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "", &self.data.to_str_radix(10))
                }
            }

            impl fmt::Binary for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0b", &self.data.to_str_radix(2))
                }
            }

            impl fmt::Octal for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0o", &self.data.to_str_radix(8))
                }
            }

            impl fmt::LowerHex for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0x", &self.data.to_str_radix(16))
                }
            }

            impl fmt::UpperHex for BigInt 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut s = self.data.to_str_radix(16);
                    s.make_ascii_uppercase();
                    f.pad_integral(!self.is_negative(), "0x", &s)
                }
            }
            
            impl Not for BigInt 
            {
                type Output = BigInt;

                fn not(mut self) -> BigInt {
                    match self.sign {
                        NoSign | Plus => {
                            self.data += 1u32;
                            self.sign = Minus;
                        }
                        Minus => {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }
                    self
                }
            }

            impl Not for &BigInt 
            {
                type Output = BigInt;

                fn not(self) -> BigInt {
                    match self.sign {
                        NoSign => -BigInt::one(),
                        Plus => -BigInt::from(&self.data + 1u32),
                        Minus => BigInt::from(&self.data - 1u32),
                    }
                }
            }

            impl Zero for BigInt 
            {
                #[inline] fn zero() -> BigInt {
                    Self::ZERO
                }

                #[inline] fn set_zero(&mut self) {
                    self.data.set_zero();
                    self.sign = NoSign;
                }

                #[inline] fn is_zero(&self) -> bool {
                    self.sign == NoSign
                }
            }

            impl ConstZero for BigInt 
            {
               
                const ZERO: Self = Self::ZERO;
            }

            impl One for BigInt 
            {
                #[inline] fn one() -> BigInt {
                    BigInt {
                        sign: Plus,
                        data: BigUint::one(),
                    }
                }

                #[inline] fn set_one(&mut self) {
                    self.data.set_one();
                    self.sign = Plus;
                }

                #[inline] fn is_one(&self) -> bool {
                    self.sign == Plus && self.data.is_one()
                }
            }

            impl Signed for BigInt 
            {
                #[inline] fn abs(&self) -> BigInt {
                    match self.sign {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from(self.data.clone()),
                    }
                }

                #[inline] fn abs_sub(&self, other: &BigInt) -> BigInt {
                    if *self <= *other {
                        Self::ZERO
                    } else {
                        self - other
                    }
                }

                #[inline] fn signum(&self) -> BigInt {
                    match self.sign {
                        Plus => BigInt::one(),
                        Minus => -BigInt::one(),
                        NoSign => Self::ZERO,
                    }
                }

                #[inline] fn is_positive(&self) -> bool {
                    self.sign == Plus
                }

                #[inline] fn is_negative(&self) -> bool {
                    self.sign == Minus
                }
            }

            trait UnsignedAbs 
            {
                type Unsigned;

                fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned>;
            }

            enum CheckedUnsignedAbs<T> 
            {
                Positive(T),
                Negative(T),
            }
            use self::CheckedUnsignedAbs::{Negative, Positive};

            macro_rules! impl_unsigned_abs 
            {
                ($Signed:ty, $Unsigned:ty) => {
                    impl UnsignedAbs for $Signed {
                        type Unsigned = $Unsigned;

                        #[inline] fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned> {
                            if self >= 0 {
                                Positive(self as $Unsigned)
                            } else {
                                Negative(self.wrapping_neg() as $Unsigned)
                            }
                        }
                    }
                };
            }

            impl_unsigned_abs!(i8, u8);
            impl_unsigned_abs!(i16, u16);
            impl_unsigned_abs!(i32, u32);
            impl_unsigned_abs!(i64, u64);
            impl_unsigned_abs!(i128, u128);
            impl_unsigned_abs!(isize, usize);

            impl Neg for BigInt 
            {
                type Output = BigInt;

                #[inline] fn neg(mut self) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }

            impl Neg for &BigInt 
            {
                type Output = BigInt;

                #[inline] fn neg(self) -> BigInt {
                    -self.clone()
                }
            }

            impl Integer for BigInt 
            {
                #[inline] fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
                    let (d_ui, r_ui) = self.data.div_rem(&other.data);
                    let d = BigInt::from_biguint(self.sign, d_ui);
                    let r = BigInt::from_biguint(self.sign, r_ui);
                    if other.is_negative() {
                        (-d, r)
                    } else {
                        (d, r)
                    }
                }

                #[inline] fn div_floor(&self, other: &BigInt) -> BigInt {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => d,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                -d
                            } else {
                                -d - 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline] fn mod_floor(&self, other: &BigInt) -> BigInt {
                    let m_ui = self.data.mod_floor(&other.data);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => m,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                m
                            } else {
                                other - m
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {
                    let (d_ui, m_ui) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => (d, m),
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                (-d, m)
                            } else {
                                (-d - 1u32, other - m)
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline] fn div_ceil(&self, other: &Self) -> Self {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => -d,
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => {
                            if m.is_zero() {
                                d
                            } else {
                                d + 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }
                /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
                #[inline] fn gcd(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.gcd(&other.data))
                }
                /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                #[inline] fn lcm(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.lcm(&other.data))
                }
                /// Calculates the Greatest Common Divisor (GCD) and
                /// Lowest Common Multiple (LCM) together.
                #[inline] fn gcd_lcm(&self, other: &BigInt) -> (BigInt, BigInt) {
                    let (gcd, lcm) = self.data.gcd_lcm(&other.data);
                    (BigInt::from(gcd), BigInt::from(lcm))
                }
                /// Greatest common divisor, least common multiple, and Bzout coefficients.
                #[inline] fn extended_gcd_lcm(&self, other: &BigInt) -> ( ::num::integers::ExtendedGcd<BigInt>, BigInt) {
                    let egcd = self.extended_gcd(other);
                    let lcm = if egcd.gcd.is_zero() {
                        Self::ZERO
                    } else {
                        BigInt::from(&self.data / &egcd.gcd.data * &other.data)
                    };
                    (egcd, lcm)
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides(&self, other: &BigInt) -> bool {
                    self.is_multiple_of(other)
                }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of(&self, other: &BigInt) -> bool {
                    self.data.is_multiple_of(&other.data)
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even(&self) -> bool {
                    self.data.is_even()
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd(&self) -> bool {
                    self.data.is_odd()
                }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of(&self, other: &Self) -> Self {
                    let m = self.mod_floor(other);
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + (other - m)
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of(&self, other: &Self) -> Self {
                    self - self.mod_floor(other)
                }

                fn dec(&mut self) {
                    *self -= 1u32;
                }

                fn inc(&mut self) {
                    *self += 1u32;
                }
            }

            impl Roots for BigInt 
            {
                fn nth_root(&self, n: u32) -> Self {
                    assert!(
                        !(self.is_negative() && n.is_even()),
                        "root of degree {} is imaginary",
                        n
                    );

                    BigInt::from_biguint(self.sign, self.data.nth_root(n))
                }

                fn sqrt(&self) -> Self {
                    assert!(!self.is_negative(), "square root is imaginary");

                    BigInt::from_biguint(self.sign, self.data.sqrt())
                }

                fn cbrt(&self) -> Self {
                    BigInt::from_biguint(self.sign, self.data.cbrt())
                }
            }

            impl IntDigits for BigInt 
            {
                #[inline] fn digits(&self) -> &[BigDigit] {
                    self.data.digits()
                }
                #[inline] fn digits_mut(&mut self) -> &mut Vec<BigDigit> {
                    self.data.digits_mut()
                }
                #[inline] fn normalize(&mut self) {
                    self.data.normalize();
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
                #[inline] fn capacity(&self) -> usize {
                    self.data.capacity()
                }
                #[inline] fn len(&self) -> usize {
                    self.data.len()
                }
            }
            /// A generic trait for converting a value to a [`BigInt`].
            pub trait ToBigInt 
            {
                /// Converts the value of `self` to a [`BigInt`].
                fn to_bigint(&self) -> Option<BigInt>;
            }

            impl BigInt 
            {
                /// A constant `BigInt` with value 0, useful for static initialization.
                pub const ZERO: Self = BigInt {
                    sign: NoSign,
                    data: BigUint::ZERO,
                };
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn new(sign: Sign, digits: Vec<u32>) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::new(digits))
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
                    if sign == NoSign {
                        data.assign_from_slice(&[]);
                    } else if data.is_zero() {
                        sign = NoSign;
                    }

                    BigInt { sign, data }
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_slice(sign: Sign, slice: &[u32]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_slice(slice))
                }
                /// Reinitializes a [`BigInt`].
                #[inline] pub fn assign_from_slice(&mut self, sign: Sign, slice: &[u32]) {
                    if sign == NoSign {
                        self.set_zero();
                    } else {
                        self.data.assign_from_slice(slice);
                        self.sign = if self.data.is_zero() { NoSign } else { sign };
                    }
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_bytes_be(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_be(bytes))
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_bytes_le(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_le(bytes))
                }
                /// Creates and initializes a `BigInt` from an array of bytes in 2's complement binary representation.
                #[inline] pub fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_be(digits)
                }
                /// Creates and initializes a [`BigInt`] from an array of bytes in two's complement.
                #[inline] pub fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_le(digits)
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigInt>
                {
                    let s = str::from_utf8(buf).ok()?;
                    BigInt::from_str_radix(s, radix).ok()
                }
                /// Creates and initializes a [`BigInt`].
                pub fn from_radix_be(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt>
                {
                    let u = BigUint::from_radix_be(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }
                /// Creates and initializes a [`BigInt`].
                pub fn from_radix_le(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt>
                {
                    let u = BigUint::from_radix_le(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }
                /// Returns the sign and the byte representation of the [`BigInt`] in big-endian byte order.
                #[inline] pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_be())
                }
                /// Returns the sign and the byte representation of the [`BigInt`] in little-endian byte order.
                #[inline] pub fn to_bytes_le(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_le())
                }
                /// Returns the sign and the `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn to_u32_digits(&self) -> (Sign, Vec<u32>) {
                    (self.sign, self.data.to_u32_digits())
                }
                /// Returns the sign and the `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn to_u64_digits(&self) -> (Sign, Vec<u64>) {
                    (self.sign, self.data.to_u64_digits())
                }
                /// Returns an iterator of `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u32_digits(&self) -> U32Digits<'_> {
                    self.data.iter_u32_digits()
                }
                /// Returns an iterator of `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u64_digits(&self) -> U64Digits<'_> {
                    self.data.iter_u64_digits()
                }
                /// Returns the two's-complement byte representation of the [`BigInt`] in big-endian byte order.
                #[inline] pub fn to_signed_bytes_be(&self) -> Vec<u8> {
                    convert::to_signed_bytes_be(self)
                }
                /// Returns the two's-complement byte representation of the [`BigInt`] in little-endian byte order.
                #[inline] pub fn to_signed_bytes_le(&self) -> Vec<u8> {
                    convert::to_signed_bytes_le(self)
                }
                /// Returns the integer formatted as a string in the given radix.
                /// `radix` must be in the range `2...36`.
                #[inline] pub fn to_str_radix(&self, radix: u32) -> String {
                    let mut v = to_str_radix_reversed(&self.data, radix);

                    if self.is_negative() {
                        v.push(b'-');
                    }

                    v.reverse();
                    unsafe { String::from_utf8_unchecked(v) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_be(radix))
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_le(radix))
                }
                /// Returns the sign of the [`BigInt`] as a [`Sign`].
                #[inline] pub fn sign(&self) -> Sign {
                    self.sign
                }
                /// Returns the magnitude of the [`BigInt`] as a [`BigUint`].
                #[inline] pub fn magnitude(&self) -> &BigUint {
                    &self.data
                }
                /// Convert this [`BigInt`] into its [`Sign`] and [`BigUint`] magnitude,
                /// the reverse of [`BigInt::from_biguint()`].
                #[inline] pub fn into_parts(self) -> (Sign, BigUint) {
                    (self.sign, self.data)
                }
                /// Determines the fewest bits necessary to express the [`BigInt`], not including the sign.
                #[inline] pub fn bits(&self) -> u64 {
                    self.data.bits()
                }
                /// Converts this [`BigInt`] into a [`BigUint`], if it's not negative.
                #[inline] pub fn to_biguint(&self) -> Option<BigUint> {
                    match self.sign {
                        Plus => Some(self.data.clone()),
                        NoSign => Some(BigUint::ZERO),
                        Minus => None,
                    }
                }

                #[inline] pub fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self + v)
                }

                #[inline] pub fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self - v)
                }

                #[inline] pub fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self * v)
                }

                #[inline] pub fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some(self / v)
                }
                /// Returns `self ^ exponent`.
                pub fn pow(&self, exponent: u32) -> Self {
                    Pow::pow(self, exponent)
                }
                /// Returns `(self ^ exponent) mod modulus`
                pub fn modpow(&self, exponent: &Self, modulus: &Self) -> Self {
                    power::modpow(self, exponent, modulus)
                }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv(&self, modulus: &Self) -> Option<Self>
                {
                    let result = self.data.modinv(&modulus.data)?;
                    let (sign, mag) = match (self.is_negative(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    Some(BigInt::from_biguint(sign, mag))
                }
                /// Returns the truncated principal square root of `self`
                pub fn sqrt(&self) -> Self {
                    Roots::sqrt(self)
                }
                /// Returns the truncated principal cube root of `self`
                pub fn cbrt(&self) -> Self {
                    Roots::cbrt(self)
                }
                /// Returns the truncated principal `n`th root of `self`
                pub fn nth_root(&self, n: u32) -> Self {
                    Roots::nth_root(self, n)
                }
                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros(&self) -> Option<u64> {
                    self.data.trailing_zeros()
                }
                /// Returns if the bit in position `bit` is set, using the two's complement for negative numbers
                pub fn bit(&self, bit: u64) -> bool {
                    if self.is_negative() {
                        if bit >= u64::from( big_digit::BITS ) * self.len() as u64 {
                            true
                        } else {
                            let trailing_zeros = self.data.trailing_zeros().unwrap();
                            match Ord::cmp(&bit, &trailing_zeros) {
                                Ordering::Less => false,
                                Ordering::Equal => true,
                                Ordering::Greater => !self.data.bit(bit),
                            }
                        }
                    } else {
                        self.data.bit(bit)
                    }
                }
                /// Sets or clears the bit in the given position, using the two's complement for negative numbers
                pub fn set_bit(&mut self, bit: u64, value: bool) {
                    match self.sign {
                        Sign::Plus => self.data.set_bit(bit, value),
                        Sign::Minus => bits::set_negative_bit(self, bit, value),
                        Sign::NoSign => {
                            if value {
                                self.data.set_bit(bit, true);
                                self.sign = Sign::Plus;
                            } else {
                            }
                        }
                    }
                    
                    self.normalize();
                }
            }

            impl ::num::traits::FromBytes for BigInt 
            {
                type Bytes = [u8];

                fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_be(bytes)
                }

                fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_le(bytes)
                }
            }

            impl ::num::traits::ToBytes for BigInt 
            {
                type Bytes = Vec<u8>;

                fn to_be_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_be()
                }

                fn to_le_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_le()
                }
            }
        }

        pub mod bigrand
        {
            use ::
            {
                rand::
                {
                    distributions::uniform::{ SampleBorrow, SampleUniform, UniformSampler },
                    prelude::{ * },
                },
                num::
                {
                    big::
                    {
                        BigInt, BigUint, Sign::{ self, * },
                        biguint::{ biguint_from_vec },
                    },
                    integers::{ Integer },
                    traits::{ ToPrimitive, Zero },
                },
                *,
            };
            /// A trait for sampling random big integers.
            pub trait RandBigInt {
                /// Generate a random [`BigUint`] of the given bit size.
                fn gen_biguint(&mut self, bit_size: u64) -> BigUint;
                /// Generate a random [ BigInt`] of the given bit size.
                fn gen_bigint(&mut self, bit_size: u64) -> BigInt;
                /// Generate a random [`BigUint`] less than the given bound. Fails
                /// when the bound is zero.
                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;
                /// Generate a random [`BigUint`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;
                /// Generate a random [`BigInt`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;
            }

            fn gen_bits<R: Rng + ?Sized>(rng: &mut R, data: &mut [u32], rem: u64) {
                rng.fill(data);
                if rem > 0 {
                    let last = data.len() - 1;
                    data[last] >>= 32 - rem;
                }
            }

            impl<R: Rng + ?Sized> RandBigInt for R
            {
                fn gen_biguint(&mut self, bit_size: u64) -> BigUint
                {

                    let (digits, rem) = bit_size.div_rem(&32);
                    let len = (digits + (rem > 0) as u64)
                        .to_usize()
                        .expect("capacity overflow");
                    let native_digits = Integer::div_ceil(&bit_size, &64);
                    let native_len = native_digits.to_usize().expect("capacity overflow");
                    let mut data = vec![0u64; native_len];
                    unsafe {
                       
                        let ptr = data.as_mut_ptr() as *mut u32;
                        debug_assert!(native_len * 2 >= len);
                        let data = slice::from_raw_parts_mut(ptr, len);
                        gen_bits(self, data, rem);
                    }
                    #[cfg(target_endian = "big")]
                    for digit in &mut data {
                        *digit = (*digit << 32) | (*digit >> 32);
                    }
                    biguint_from_vec(data)
                }

                fn gen_bigint(&mut self, bit_size: u64) -> BigInt {
                    loop {
                       
                        let biguint = self.gen_biguint(bit_size);
                        let sign = if biguint.is_zero() {
                            if self.gen() {
                                continue;
                            } else {
                                NoSign
                            }
                        } else if self.gen() {
                            Plus
                        } else {
                            Minus
                        };
                        return BigInt::from_biguint(sign, biguint);
                    }
                }

                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {
                    assert!(!bound.is_zero());
                    let bits = bound.bits();
                    loop {
                        let n = self.gen_biguint(bits);
                        if n < *bound {
                            return n;
                        }
                    }
                }

                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        self.gen_biguint_below(ubound)
                    } else {
                        lbound + self.gen_biguint_below(&(ubound - lbound))
                    }
                }

                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        BigInt::from(self.gen_biguint_below(ubound.magnitude()))
                    } else if ubound.is_zero() {
                        lbound + BigInt::from(self.gen_biguint_below(lbound.magnitude()))
                    } else {
                        let delta = ubound - lbound;
                        lbound + BigInt::from(self.gen_biguint_below(delta.magnitude()))
                    }
                }
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigUint`].
            #[derive(Clone, Debug)]
            pub struct UniformBigUint {
                base: BigUint,
                len: BigUint,
            }

            impl UniformSampler for UniformBigUint {
                type X = BigUint;

                #[inline] fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigUint {
                        len: high - low,
                        base: low.clone(),
                    }
                }

                #[inline] fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + rng.gen_biguint_below(&self.len)
                }

                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_biguint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigUint {
                type Sampler = UniformBigUint;
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigInt`].
            #[derive(Clone, Debug)]
            pub struct UniformBigInt {
                base: BigInt,
                len: BigUint,
            }

            impl UniformSampler for UniformBigInt {
                type X = BigInt;

                #[inline] fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigInt {
                        len: (high - low).into_parts().1,
                        base: low.clone(),
                    }
                }

                #[inline] fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + BigInt::from(rng.gen_biguint_below(&self.len))
                }

                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_bigint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigInt {
                type Sampler = UniformBigInt;
            }
            /// A random distribution for [`BigUint`] and [`BigInt`] values of a particular bit size.
            #[derive(Clone, Copy, Debug)]
            pub struct RandomBits {
                bits: u64,
            }

            impl RandomBits {
                #[inline] pub fn new(bits: u64) -> RandomBits {
                    RandomBits { bits }
                }
            }

            impl Distribution<BigUint> for RandomBits {
                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigUint {
                    rng.gen_biguint(self.bits)
                }
            }

            impl Distribution<BigInt> for RandomBits {
                #[inline] fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigInt {
                    rng.gen_bigint(self.bits)
                }
            }

        }

        pub mod biguint
        {
            use ::
            {
                cmp::{ self, Ordering },
                default::{ Default },
                num::
                {
                    integers::{ Integer, Roots },
                    traits::{ ConstZero, Num, One, Pow, FromPrimitive, ToPrimitive, Unsigned, Zero },
                },
                string::{ String },
                vec::{ Vec },
                *,
            }; use super::big_digit::{self, BigDigit};

            pub mod addition
            {
                use ::
                {
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::{ BigUint, IntDigits },
                            UsizePromotion,
                        },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                
                #[inline] fn adc(carry: u8, a: u64, b: u64, out: &mut u64) -> u8 
                {
                    unsafe { arch::_addcarry_u64(carry, a, b, out) }
                }
                

                /// Two argument addition of raw slices, `a += b`, returning the carry.
                #[inline] pub fn __add2(a: &mut [BigDigit], b: &[BigDigit]) -> BigDigit {
                    debug_assert!(a.len() >= b.len());

                    let mut carry = 0;
                    let (a_lo, a_hi) = a.split_at_mut(b.len());

                    for (a, b) in a_lo.iter_mut().zip(b) {
                        carry = adc(carry, *a, *b, a);
                    }

                    if carry != 0 {
                        for a in a_hi {
                            carry = adc(carry, *a, 0, a);
                            if carry == 0 {
                                break;
                            }
                        }
                    }

                    carry as BigDigit
                }
                /// Two argument addition of raw slices | a += b
                pub fn add2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let carry = __add2(a, b);

                    debug_assert!(carry == 0);
                }

                forward_all_binop_to_val_ref_commutative!(impl Add for BigUint, add);
                forward_val_assign!(impl AddAssign for BigUint, add_assign);

                impl Add<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn add(mut self, other: &BigUint) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<&BigUint> for BigUint {
                    #[inline] fn add_assign(&mut self, other: &BigUint) 
                    {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len() {
                            let lo_carry = __add2(&mut self.data[..], &other.data[..self_len]);
                            self.data.extend_from_slice(&other.data[self_len..]);
                            __add2(&mut self.data[self_len..], &[lo_carry])
                        } else {
                            __add2(&mut self.data[..], &other.data[..])
                        };
                        if carry != 0 {
                            self.data.push(carry);
                        }
                    }
                }

                promote_unsigned_scalars!(impl Add for BigUint, add);
                promote_unsigned_scalars_assign!(impl AddAssign for BigUint, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigUint, add);

                impl Add<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn add(mut self, other: u32) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u32> for BigUint {
                    #[inline] fn add_assign(&mut self, other: u32) {
                        if other != 0 {
                            if self.data.is_empty() {
                                self.data.push(0);
                            }

                            let carry = __add2(&mut self.data, &[other as BigDigit]);
                            if carry != 0 {
                                self.data.push(carry);
                            }
                        }
                    }
                }

                impl Add<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn add(mut self, other: u64) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline] fn add_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline] fn add_assign(&mut self, other: u64) {
                            if other != 0 {
                                if self.data.is_empty() {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[other as BigDigit]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl Add<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn add(mut self, other: u128) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline] fn add_assign(&mut self, other: u128) {
                            if other <= u128::from(u64::MAX) {
                                *self += other as u64
                            } else {
                                let (a, b, c, d) = super::u32_from_u128(other);
                                let carry = if a > 0 {
                                    while self.data.len() < 4 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b, a])
                                } else {
                                    debug_assert!(b > 0);
                                    while self.data.len() < 3 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b])
                                };

                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline] fn add_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl CheckedAdd for BigUint {
                    #[inline] fn checked_add(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigUint);
            }

            pub mod division
            {
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::{ addition::__add2, cmp_slice, BigUint },
                            UsizePromotion,
                        },
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };

                pub(super) const FAST_DIV_WIDE: bool = true;
                /// Divide a two digit numerator by a one digit divisor, returns quotient and remainder.
                #[inline] fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) 
                {
                    debug_assert!(hi < divisor);
                    unsafe
                    {
                        let (div, rem);
                        macro_rules! div {
                            () => {
                                "div {0:r}"
                            };
                        }

                        ::arch::asm!(
                            div!(),
                            in(reg) divisor,
                            inout("dx") hi => rem,
                            inout("ax") lo => div,
                            options(pure, nomem, nostack),
                        );

                        (div, rem)
                    }
                }
                /// For small divisors, we can divide without promoting to `DoubleBigDigit` by
                /// using half-size pieces of digit, like long-division.
                #[inline] fn div_half(rem: BigDigit, digit: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    use ::num::big::big_digit::{HALF, HALF_BITS};

                    debug_assert!(rem < divisor && divisor <= HALF);
                    let (hi, rem) = ((rem << HALF_BITS) | (digit >> HALF_BITS)).div_rem(&divisor);
                    let (lo, rem) = ((rem << HALF_BITS) | (digit & HALF)).div_rem(&divisor);
                    ((hi << HALF_BITS) | lo, rem)
                }

                #[inline] pub fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_half(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_wide(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    }

                    (a.normalized(), rem)
                }

                #[inline] fn rem_digit(a: &BigUint, b: BigDigit) -> BigDigit {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_half(rem, digit, b);
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_wide(rem, digit, b);
                            rem = r;
                        }
                    }

                    rem
                }
                /// Subtract a multiple.
                fn sub_mul_digit_same_len(a: &mut [BigDigit], b: &[BigDigit], c: BigDigit) -> BigDigit {
                    debug_assert!(a.len() == b.len());
                    
                    let mut offset_carry = big_digit::MAX;

                    for (x, y) in a.iter_mut().zip(b) {
                        let offset_sum = big_digit::to_doublebigdigit(big_digit::MAX, *x)
                            - big_digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let (new_offset_carry, new_x) = big_digit::from_doublebigdigit(offset_sum);
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }
                    
                    big_digit::MAX - offset_carry
                }

                fn div_rem(mut u: BigUint, mut d: BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u, BigUint::ZERO);
                        }
                        let (div, rem) = div_rem_digit(u, d.data[0]);
                        d.data.clear();
                        d += rem;
                        return (div, d);
                    }
                    
                    match u.cmp(&d) {
                        Less => return (BigUint::ZERO, u),
                        Equal => {
                            u.set_one();
                            return (u, BigUint::ZERO);
                        }
                        Greater => {}
                    }
                    
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                        div_rem_core(u, &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                        (q, r >> shift)
                    }
                }

                pub fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u.clone(), BigUint::ZERO);
                        }

                        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
                        return (div, rem.into());
                    }
                    
                    match u.cmp(d) {
                        Less => return (BigUint::ZERO, u.clone()),
                        Equal => return (One::one(), BigUint::ZERO),
                        Greater => {}
                    }
                    
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                        div_rem_core(u.clone(), &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                        (q, r >> shift)
                    }
                }
                /// An implementation of the base division algorithm.
                fn div_rem_core(mut a: BigUint, b: &[BigDigit]) -> (BigUint, BigUint) {
                    debug_assert!(a.data.len() >= b.len() && b.len() > 1);
                    debug_assert!(b.last().unwrap().leading_zeros() == 0);
                    
                    let mut a0 = 0;
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in (0..q_len).rev() {
                        debug_assert!(a.data.len() == b.len() + j);

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];
                        
                        let (mut q0, mut r) = if a0 < b0 {
                            let (q0, r) = div_wide(a0, a1, b0);
                            (q0, r as DoubleBigDigit)
                        } else {
                            debug_assert!(a0 == b0);
                            
                            (big_digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit)
                        };
                        
                        while r <= big_digit::MAX as DoubleBigDigit
                            && big_digit::to_doublebigdigit(r as BigDigit, a2)
                                < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }

                        let mut borrow = sub_mul_digit_same_len(&mut a.data[j..], b, q0);
                        if borrow > a0 {
                            q0 -= 1;
                            borrow -= __add2(&mut a.data[j..], b);
                        }
                        
                        debug_assert!(borrow == a0);

                        q.data[j] = q0;
                        
                        a0 = a.data.pop().unwrap();
                    }

                    a.data.push(a0);
                    a.normalize();

                    debug_assert_eq!(cmp_slice(&a.data, b), Less);

                    (q.normalized(), a)
                }

                forward_val_ref_binop!(impl Div for BigUint, div);
                forward_ref_val_binop!(impl Div for BigUint, div);
                forward_val_assign!(impl DivAssign for BigUint, div_assign);

                impl Div<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: BigUint) -> BigUint {
                        let (q, _) = div_rem(self, other);
                        q
                    }
                }

                impl Div<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: &BigUint) -> BigUint {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint {
                    #[inline] fn div_assign(&mut self, other: &BigUint) {
                        *self = &*self / other;
                    }
                }

                promote_unsigned_scalars!(impl Div for BigUint, div);
                promote_unsigned_scalars_assign!(impl DivAssign for BigUint, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigUint, div);

                impl Div<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u32) -> BigUint {
                        let (q, _) = div_rem_digit(self, other as BigDigit);
                        q
                    }
                }
                impl DivAssign<u32> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u32) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn div(self, other: BigUint) -> BigUint {
                        match other.data.len() {
                            0 => panic!("attempt to divide by zero"),
                            1 => From::from(self as BigDigit / other.data[0]),
                            _ => BigUint::ZERO,
                        }
                    }
                }

                impl Div<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u64) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }
                impl DivAssign<u64> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u64) {
                        let temp = mem::replace(self, Self::ZERO);
                        *self = temp / other;
                    }
                }

                impl Div<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u64::from(other.data[0])),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0]),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                impl Div<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u128) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }

                impl DivAssign<u128> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u128) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            use super::u32_to_u128;
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u128::from(other.data[0])),
                                2 => From::from(
                                    self / u128::from(big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                ),
                                3 => From::from(self / u32_to_u128(0, other.data[2], other.data[1], other.data[0])),
                                4 => From::from(
                                    self / u32_to_u128(other.data[3], other.data[2], other.data[1], other.data[0]),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0] as u128),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                forward_val_ref_binop!(impl Rem for BigUint, rem);
                forward_ref_val_binop!(impl Rem for BigUint, rem);
                forward_val_assign!(impl RemAssign for BigUint, rem_assign);

                impl Rem<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            &self % other
                        } else {
                            let (_, r) = div_rem(self, other);
                            r
                        }
                    }
                }

                impl Rem<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: &BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: &BigUint) {
                        *self = &*self % other;
                    }
                }

                promote_unsigned_scalars!(impl Rem for BigUint, rem);
                promote_unsigned_scalars_assign!(impl RemAssign for BigUint, rem_assign);
                forward_all_scalar_binop_to_ref_val!(impl Rem<u32> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigUint, rem);

                impl Rem<u32> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u32) -> BigUint {
                        rem_digit(self, other as BigDigit).into()
                    }
                }
                impl RemAssign<u32> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: u32) {
                        *self = &*self % other;
                    }
                }

                impl Rem<&BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: &BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                macro_rules! impl_rem_assign_scalar {
                    ($scalar:ty, $to_scalar:ident) => {
                        forward_val_assign_scalar!(impl RemAssign for BigUint, $scalar, rem_assign);
                        impl RemAssign<&BigUint> for $scalar {
                            #[inline]
                            fn rem_assign(&mut self, other: &BigUint) {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some(0) => panic!("attempt to divide by zero"),
                                    Some(v) => *self % v
                                };
                            }
                        }
                    }
                }
                
                impl_rem_assign_scalar!(u128, to_u128);
                impl_rem_assign_scalar!(usize, to_usize);
                impl_rem_assign_scalar!(u64, to_u64);
                impl_rem_assign_scalar!(u32, to_u32);
                impl_rem_assign_scalar!(u16, to_u16);
                impl_rem_assign_scalar!(u8, to_u8);
                impl_rem_assign_scalar!(i128, to_i128);
                impl_rem_assign_scalar!(isize, to_isize);
                impl_rem_assign_scalar!(i64, to_i64);
                impl_rem_assign_scalar!(i32, to_i32);
                impl_rem_assign_scalar!(i16, to_i16);
                impl_rem_assign_scalar!(i8, to_i8);

                impl Rem<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u64) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }
                impl RemAssign<u64> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: u64) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u64 {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl Rem<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u128) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }

                impl RemAssign<u128> for BigUint {
                    #[inline] fn rem_assign(&mut self, other: u128) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u128 {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl CheckedDiv for BigUint {
                    #[inline] fn checked_div(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigUint {
                    #[inline] fn checked_div_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline] fn checked_rem_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigUint {
                    #[inline] fn div_euclid(&self, v: &BigUint) -> BigUint {
                        self / v
                    }

                    #[inline] fn rem_euclid(&self, v: &BigUint) -> BigUint {
                        self % v
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        self.div_rem(v)
                    }
                }
            }

            pub mod multiplication
            {
                use ::
                {
                    cmp::{ Ordering },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::
                            {
                                addition::{ __add2, add2 },
                                subtraction::{ sub2 },
                                biguint_from_vec, cmp_slice, BigUint, IntDigits,
                            },
                            BigInt, Sign::{ self, * }, UsizePromotion,
                        },
                        traits::{ CheckedMul, FromPrimitive, One, Zero },
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                
                #[inline] pub fn mac_with_carry(
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc: &mut DoubleBigDigit,
                ) -> BigDigit {
                    *acc += DoubleBigDigit::from(a);
                    *acc += DoubleBigDigit::from(b) * DoubleBigDigit::from(c);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                #[inline] fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }
                /// Three argument multiply accumulate: acc += b * c
                fn mac_digit(acc: &mut [BigDigit], b: &[BigDigit], c: BigDigit) 
                {
                    if c == 0 {
                        return;
                    }

                    let mut carry = 0;
                    let (a_lo, a_hi) = acc.split_at_mut(b.len());

                    for (a, &b) in a_lo.iter_mut().zip(b) {
                        *a = mac_with_carry(*a, b, c, &mut carry);
                    }

                    let (carry_hi, carry_lo) = big_digit::from_doublebigdigit(carry);

                    let final_carry = if carry_hi == 0 {
                        __add2(a_hi, &[carry_lo])
                    } else {
                        __add2(a_hi, &[carry_hi, carry_lo])
                    };
                    assert_eq!(final_carry, 0, "carry overflow during multiplication!");
                }

                fn bigint_from_slice(slice: &[BigDigit]) -> BigInt 
                {
                    BigInt::from(biguint_from_vec(slice.to_vec()))
                }
                /// Three argument multiply accumulate: acc += b * c
                fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) 
                {
                    if let Some(&0) = b.first() {
                        if let Some(nz) = b.iter().position(|&d| d != 0) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    if let Some(&0) = c.first() {
                        if let Some(nz) = c.iter().position(|&d| d != 0) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }

                    let acc = acc;
                    let (x, y) = if b.len() < c.len() { (b, c) } else { (c, b) };
                    
                    if x.len() <= 32 {
                        for (i, xi) in x.iter().enumerate() {
                            mac_digit(&mut acc[i..], y, *xi);
                        }
                    } else if x.len() * 2 <= y.len() 
                    {
                        let m2 = y.len() / 2;
                        let (low2, high2) = y.split_at(m2);
                        
                        mac3(acc, x, low2);
                        mac3(&mut acc[m2..], x, high2);
                    } else if x.len() <= 256 {
                        let b = x.len() / 2;
                        let (x0, x1) = x.split_at(b);
                        let (y0, y1) = y.split_at(b);
                        
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };
                        mac3(&mut p.data, x1, y1);
                        p.normalize();

                        add2(&mut acc[b..], &p.data);
                        add2(&mut acc[b * 2..], &p.data);
                        p.data.truncate(0);
                        p.data.resize(len, 0);
                        mac3(&mut p.data, x0, y0);
                        p.normalize();

                        add2(acc, &p.data);
                        add2(&mut acc[b..], &p.data);
                        
                        let (j0_sign, j0) = sub_sign(x1, x0);
                        let (j1_sign, j1) = sub_sign(y1, y0);

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate(0);
                                p.data.resize(len, 0);

                                mac3(&mut p.data, &j0.data, &j1.data);
                                p.normalize();

                                sub2(&mut acc[b..], &p.data);
                            }
                            Minus => {
                                mac3(&mut acc[b..], &j0.data, &j1.data);
                            }
                            NoSign => (),
                        }
                    } else {
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min(x.len(), i);
                        let x1_len = Ord::min(x.len() - x0_len, i);

                        let y0_len = i;
                        let y1_len = Ord::min(y.len() - y0_len, i);
                        
                        let x0 = bigint_from_slice(&x[..x0_len]);
                        let x1 = bigint_from_slice(&x[x0_len..x0_len + x1_len]);
                        let x2 = bigint_from_slice(&x[x0_len + x1_len..]);
                        let y0 = bigint_from_slice(&y[..y0_len]);
                        let y1 = bigint_from_slice(&y[y0_len..y0_len + y1_len]);
                        let y2 = bigint_from_slice(&y[y0_len + y1_len..]);
                        
                        let p = &x0 + &x2;
                        let q = &y0 + &y2;
                        let p2 = &p - &x1;
                        let q2 = &q - &y1;
                        let r0 = &x0 * &y0;
                        let r4 = &x2 * &y2;
                        let r1 = (p + x1) * (q + y1);
                        let r2 = &p2 * &q2;
                        let r3 = ((p2 + x2) * 2 - x0) * ((q2 + y2) * 2 - y0);
                        
                        let mut comp3: BigInt = (r3 - &r1) / 3u32;
                        let mut comp1: BigInt = (r1 - &r2) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = ((&comp2 - comp3) >> 1) + (&r4 << 1);
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;
                        
                        for (j, result) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2(&mut acc[i * j..], result.digits()),
                                Minus => sub2(&mut acc[i * j..], result.digits()),
                                NoSign => {}
                            }
                        }
                    }
                }

                fn mul3(x: &[BigDigit], y: &[BigDigit]) -> BigUint {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3(&mut prod.data, x, y);
                    prod.normalized()
                }

                fn scalar_mul(a: &mut BigUint, b: BigDigit) {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry(*a, b, &mut carry);
                                }
                                if carry != 0 {
                                    a.data.push(carry as BigDigit);
                                }
                            }
                        }
                    }
                }

                fn sub_sign(mut a: &[BigDigit], mut b: &[BigDigit]) -> (Sign, BigUint) 
                {
                    if let Some(&0) = a.last() {
                        a = &a[..a.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }
                    if let Some(&0) = b.last() {
                        b = &b[..b.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }

                    match cmp_slice(a, b) {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2(&mut a, b);
                            (Plus, biguint_from_vec(a))
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2(&mut b, a);
                            (Minus, biguint_from_vec(b))
                        }
                        Ordering::Equal => (NoSign, BigUint::ZERO),
                    }
                }

                macro_rules! impl_mul {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul(self, other: $Other) -> BigUint {
                                match (&*self.data, &*other.data) {
                                    (&[], _) | (_, &[]) => BigUint::ZERO,
                                    (_, &[digit]) => self * digit,
                                    (&[digit], _) => other * digit,
                                    (x, y) => mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }

                macro_rules! impl_mul_assign {
                    ($(impl MulAssign<$Other:ty> for BigUint;)*) => {$(
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                                match (&*self.data, &*other.data) {
                                    (&[], _) => {},
                                    (_, &[]) => self.set_zero(),
                                    (_, &[digit]) => *self *= digit,
                                    (&[digit], _) => *self = other * digit,
                                    (x, y) => *self = mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }

                promote_unsigned_scalars!(impl Mul for BigUint, mul);
                promote_unsigned_scalars_assign!(impl MulAssign for BigUint, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigUint, mul);

                impl Mul<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn mul(mut self, other: u32) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u32> for BigUint {
                    #[inline] fn mul_assign(&mut self, other: u32) {
                        scalar_mul(self, other as BigDigit);
                    }
                }

                impl Mul<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn mul(mut self, other: u64) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline] fn mul_assign(&mut self, other: u64) {
                            if let Some(other) = BigDigit::from_u64(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }

                        #[inline] fn mul_assign(&mut self, other: u64) {
                            scalar_mul(self, other);
                        }
                    );
                }

                impl Mul<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn mul(mut self, other: u128) -> BigUint {
                        self *= other;
                        self
                    }
                }

                impl MulAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline] fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                *self = match super::u32_from_u128(other) {
                                    (0, 0, c, d) => mul3(&self.data, &[d, c]),
                                    (0, b, c, d) => mul3(&self.data, &[d, c, b]),
                                    (a, b, c, d) => mul3(&self.data, &[d, c, b, a]),
                                };
                            }
                        }

                        #[inline] fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }
                    );
                }

                impl CheckedMul for BigUint {
                    #[inline] fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigUint);
            }

            pub mod subtraction
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::{ BigUint },
                            UsizePromotion
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                
                #[inline] fn sbb(borrow: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                    unsafe { ::arch::_subborrow_u64(borrow, a, b, out) }
                }
                
                pub fn sub2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut borrow = 0;

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at_mut(len);
                    let (b_lo, b_hi) = b.split_at(len);

                    for (a, b) in a_lo.iter_mut().zip(b_lo) {
                        borrow = sbb(borrow, *a, *b, a);
                    }

                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb(borrow, *a, 0, a);
                            if borrow == 0 {
                                break;
                            }
                        }
                    }
                    
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }
                
                #[inline] fn __sub2rev(a: &[BigDigit], b: &mut [BigDigit]) -> u8 {
                    debug_assert!(b.len() == a.len());

                    let mut borrow = 0;

                    for (ai, bi) in a.iter().zip(b) {
                        borrow = sbb(borrow, *ai, *bi, bi);
                    }

                    borrow
                }

                fn sub2rev(a: &[BigDigit], b: &mut [BigDigit]) {
                    debug_assert!(b.len() >= a.len());

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at(len);
                    let (b_lo, b_hi) = b.split_at_mut(len);

                    let borrow = __sub2rev(a_lo, b_lo);

                    assert!(a_hi.is_empty());
                    
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

                forward_val_val_binop!(impl Sub for BigUint, sub);
                forward_ref_ref_binop!(impl Sub for BigUint, sub);
                forward_val_assign!(impl SubAssign for BigUint, sub_assign);

                impl Sub<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn sub(mut self, other: &BigUint) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<&BigUint> for BigUint {
                    fn sub_assign(&mut self, other: &BigUint) {
                        sub2(&mut self.data[..], &other.data[..]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for &BigUint {
                    type Output = BigUint;

                    fn sub(self, mut other: BigUint) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev(&self.data[..other_len], &mut other.data);
                            other.data.extend_from_slice(&self.data[other_len..]);
                            if lo_borrow != 0 {
                                sub2(&mut other.data[other_len..], &[1])
                            }
                        } else {
                            sub2rev(&self.data[..], &mut other.data[..]);
                        }
                        other.normalized()
                    }
                }

                promote_unsigned_scalars!(impl Sub for BigUint, sub);
                promote_unsigned_scalars_assign!(impl SubAssign for BigUint, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigUint, sub);

                impl Sub<u32> for BigUint {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u32) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u32> for BigUint {
                    fn sub_assign(&mut self, other: u32) {
                        sub2(&mut self.data[..], &[other as BigDigit]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for u32 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self as BigDigit);
                            } else {
                                sub2rev(&[self as BigDigit], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u64> for BigUint {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u64) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline] fn sub_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }

                        #[inline] fn sub_assign(&mut self, other: u64) {
                            sub2(&mut self.data[..], &[other as BigDigit]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u128> for BigUint {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u128) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline] fn sub_assign(&mut self, other: u128) {
                            let (a, b, c, d) = super::u32_from_u128(other);
                            sub2(&mut self.data[..], &[d, c, b, a]);
                            self.normalize();
                        }

                        #[inline] fn sub_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 4 {
                                other.data.push(0);
                            }

                            let (a, b, c, d) = super::u32_from_u128(self);
                            sub2rev(&[d, c, b, a], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }
                    );
                }

                impl CheckedSub for BigUint {
                    #[inline] fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {
                        match self.cmp(v) {
                            Less => None,
                            Equal => Some(Self::ZERO),
                            Greater => Some(self.sub(v)),
                        }
                    }
                }
            }

            pub mod bits
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            biguint::{ BigUint, IntDigits }
                        },
                        traits::{},
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    *,
                };

                forward_val_val_binop!(impl BitAnd for BigUint, bitand);
                forward_ref_val_binop!(impl BitAnd for BigUint, bitand);
                
                impl BitAnd<&BigUint> for &BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn bitand(self, other: &BigUint) -> BigUint {
                        if self.data.len() <= other.data.len() {
                            self.clone() & other
                        } else {
                            other.clone() & self
                        }
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigUint, bitand_assign);

                impl BitAnd<&BigUint> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn bitand(mut self, other: &BigUint) -> BigUint {
                        self &= other;
                        self
                    }
                }

                impl BitAndAssign<&BigUint> for BigUint 
                {
                    #[inline] fn bitand_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai &= bi;
                        }
                        self.data.truncate(other.data.len());
                        self.normalize();
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitOr for BigUint, bitor);
                forward_val_assign!(impl BitOrAssign for BigUint, bitor_assign);

                impl BitOr<&BigUint> for BigUint 
                {
                    type Output = BigUint;

                    fn bitor(mut self, other: &BigUint) -> BigUint {
                        self |= other;
                        self
                    }
                }
                impl BitOrAssign<&BigUint> for BigUint 
                {
                    #[inline] fn bitor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigUint, bitxor);
                forward_val_assign!(impl BitXorAssign for BigUint, bitxor_assign);

                impl BitXor<&BigUint> for BigUint 
                {
                    type Output = BigUint;

                    fn bitxor(mut self, other: &BigUint) -> BigUint {
                        self ^= other;
                        self
                    }
                }
                impl BitXorAssign<&BigUint> for BigUint 
                {
                    #[inline] fn bitxor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                        self.normalize();
                    }
                }
            }

            pub mod convert
            {
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    convert::TryFrom,
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::
                            {
                                addition::add2,
                                division::{div_rem_digit, FAST_DIV_WIDE},
                                multiplication::mac_with_carry,
                                biguint_from_vec, BigUint, ToBigUint ,
                            },
                            TryFromBigIntError, ParseBigIntError,
                        },
                        integers::{Integer, Roots},
                        traits::{ float::FloatCore, FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero },
                    },
                    str::FromStr,
                    vec::{ Vec },
                    *,
                };
                
                /// Find last set bit
                /// fls(0) == 0, fls(u32::MAX) == 32
                fn fls<T: PrimInt>(v: T) -> u8 
                {
                    mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8
                }

                fn ilog2<T: PrimInt>(v: T) -> u8 
                {
                    fls(v) - 1
                }

                impl FromStr for BigUint
                {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str(s: &str) -> Result<BigUint, ParseBigIntError>
                    {
                        BigUint::from_str_radix(s, 10)
                    }
                }
                /// Convert from a power of two radix where bits evenly divides BigDigit::BITS
                pub fn from_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits == 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let digits_per_big_digit = big_digit::BITS / bits;

                    let data = v
                        .chunks(digits_per_big_digit.into())
                        .map(|chunk| 
                    {
                            chunk
                                .iter()
                                .rev()
                                .fold(0, |acc, &c| (acc << bits) | BigDigit::from(c))
                        })
                        .collect();

                    biguint_from_vec(data)
                }
                
                fn from_inexact_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits != 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let total_bits = (v.len() as u64).saturating_mul(bits.into());
                    let big_digits = Integer::div_ceil(&total_bits, &big_digit::BITS.into())
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut data = Vec::with_capacity(big_digits);

                    let mut d = 0;
                    let mut dbits = 0;
                    
                    for &c in v {
                        d |= BigDigit::from(c) << dbits;
                        dbits += bits;

                        if dbits >= big_digit::BITS {
                            data.push(d);
                            dbits -= big_digit::BITS;
                            d = BigDigit::from(c) >> (bits - dbits);
                        }
                    }

                    if dbits > 0 {
                        debug_assert!(dbits < big_digit::BITS);
                        data.push(d as BigDigit);
                    }

                    biguint_from_vec(data)
                }
                
                fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
                    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
                    
                    let big_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        let bits = radix_log2 * v.len() as f64;
                        (bits / big_digit::BITS as f64).ceil()
                    };

                    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));

                    let (base, power) = get_radix_base(radix);
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let (head, tail) = v.split_at(i);

                    let first = head
                        .iter()
                        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                    data.push(first);

                    debug_assert!(tail.len() % power == 0);
                    for chunk in tail.chunks(power) {
                        if data.last() != Some(&0) {
                            data.push(0);
                        }

                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry(0, *d, base, &mut carry);
                        }
                        debug_assert!(carry == 0);

                        let n = chunk
                            .iter()
                            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                        add2(&mut data, &[n]);
                    }

                    biguint_from_vec(data)
                }

                pub fn from_radix_be(buf: &[u8], radix: u32) -> Option<BigUint> 
                {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                        let bits = ilog2(radix);
                        let mut v = Vec::from(buf);
                        v.reverse();
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(&v, bits)
                        } else {
                            from_inexact_bitwise_digits_le(&v, bits)
                        }
                    } else {
                        from_radix_digits_be(buf, radix)
                    };

                    Some(res)
                }

                pub fn from_radix_le(buf: &[u8], radix: u32) -> Option<BigUint> 
                {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(buf, bits)
                        } else {
                            from_inexact_bitwise_digits_le(buf, bits)
                        }
                    } else {
                        let mut v = Vec::from(buf);
                        v.reverse();
                        from_radix_digits_be(&v, radix)
                    };

                    Some(res)
                }

                impl Num for BigUint 
                {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a `BigUint`.
                    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
                        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
                        let mut s = s;
                        if let Some(tail) = s.strip_prefix('+') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                        }

                        if s.is_empty() {
                            return Err(ParseBigIntError::empty());
                        }

                        if s.starts_with('_') {
                            return Err(ParseBigIntError::invalid());
                        }
                        
                        let mut v = Vec::with_capacity(s.len());
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push(d);
                            } else {
                                return Err(ParseBigIntError::invalid());
                            }
                        }

                        let res = if radix.is_power_of_two() {
                            let bits = ilog2(radix);
                            v.reverse();
                            if big_digit::BITS % bits == 0 {
                                from_bitwise_digits_le(&v, bits)
                            } else {
                                from_inexact_bitwise_digits_le(&v, bits)
                            }
                        } else {
                            from_radix_digits_be(&v, radix)
                        };
                        Ok(res)
                    }
                }

                fn high_bits_to_u64(v: &BigUint) -> u64 
                {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                            let v0 = u64::from(v.data[0]);
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = (bits - 1) % u64::from(big_digit::BITS) + 1;
                                let bits_want = Ord::min(64 - ret_bits, digit_bits);

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                    let d0 = u64::from(*d) >> (digit_bits - bits_want);
                                    ret |= d0;
                                }
                                
                                if digit_bits - bits_want != 0 {
                                    let masked = u64::from(*d) << (64 - (digit_bits - bits_want) as u32);
                                    ret |= (masked != 0) as u64;
                                }

                                ret_bits += bits_want;
                                bits -= bits_want;
                            }

                            ret
                        }
                    }
                }

                impl ToPrimitive for BigUint 
                {
                    #[inline] fn to_i64(&self) -> Option<i64> {
                        self.to_u64().as_ref().and_then(u64::to_i64)
                    }

                    #[inline] fn to_i128(&self) -> Option<i128> {
                        self.to_u128().as_ref().and_then(u128::to_i128)
                    }

                    #[allow(clippy::useless_conversion)]
                    #[inline] fn to_u64(&self) -> Option<u64> {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }
                            
                            ret += u64::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline] fn to_u128(&self) -> Option<u128> {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }

                            ret |= u128::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline] fn to_f32(&self) -> Option<f32> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f32::MAX_EXP as u64 {
                            Some(f32::INFINITY)
                        } else {
                            Some((mantissa as f32) * 2.0f32.powi(exponent as i32))
                        }
                    }

                    #[inline] fn to_f64(&self) -> Option<f64> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f64::MAX_EXP as u64 {
                            Some(f64::INFINITY)
                        } else {
                            Some((mantissa as f64) * 2.0f64.powi(exponent as i32))
                        }
                    }
                }

                macro_rules! impl_try_from_biguint 
                {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigUint) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from(value: BigUint) -> Result<$T, TryFromBigIntError<BigUint>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_biguint!(u8, ToPrimitive::to_u8);
                impl_try_from_biguint!(u16, ToPrimitive::to_u16);
                impl_try_from_biguint!(u32, ToPrimitive::to_u32);
                impl_try_from_biguint!(u64, ToPrimitive::to_u64);
                impl_try_from_biguint!(usize, ToPrimitive::to_usize);
                impl_try_from_biguint!(u128, ToPrimitive::to_u128);

                impl_try_from_biguint!(i8, ToPrimitive::to_i8);
                impl_try_from_biguint!(i16, ToPrimitive::to_i16);
                impl_try_from_biguint!(i32, ToPrimitive::to_i32);
                impl_try_from_biguint!(i64, ToPrimitive::to_i64);
                impl_try_from_biguint!(isize, ToPrimitive::to_isize);
                impl_try_from_biguint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigUint
                {
                    #[inline] fn from_i64(n: i64) -> Option<BigUint> 
                    {
                        if n >= 0 {
                            Some(BigUint::from(n as u64))
                        } else {
                            None
                        }
                    }

                    #[inline] fn from_i128(n: i128) -> Option<BigUint> 
                    {
                        if n >= 0 {
                            Some(BigUint::from(n as u128))
                        } else {
                            None
                        }
                    }

                    #[inline] fn from_u64(n: u64) -> Option<BigUint> 
                    {
                        Some(BigUint::from(n))
                    }

                    #[inline] fn from_u128(n: u128) -> Option<BigUint> 
                    {
                        Some(BigUint::from(n))
                    }

                    #[inline] fn from_f64(mut n: f64) -> Option<BigUint> 
                    {
                        if !n.is_finite() {
                            return None;
                        }
                        
                        n = n.trunc();
                        
                        if n.is_zero() {
                            return Some(Self::ZERO);
                        }

                        let (mantissa, exponent, sign) = FloatCore::integer_decode(n);

                        if sign == -1 {
                            return None;
                        }

                        let mut ret = BigUint::from(mantissa);
                        match exponent.cmp(&0) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= (-exponent) as usize,
                        }
                        Some(ret)
                    }
                }

                impl From<u64> for BigUint 
                {
                    #[inline] fn from(mut n: u64) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n = (n >> 1) >> (big_digit::BITS - 1);
                        }

                        ret
                    }
                }

                impl From<u128> for BigUint 
                {
                    #[inline] fn from(mut n: u128) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n >>= big_digit::BITS;
                        }

                        ret
                    }
                }

                macro_rules! impl_biguint_from_uint 
                {
                    ($T:ty) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigUint::from(n as u64)
                            }
                        }
                    };
                }

                impl_biguint_from_uint!(u8);
                impl_biguint_from_uint!(u16);
                impl_biguint_from_uint!(u32);
                impl_biguint_from_uint!(usize);

                macro_rules! impl_biguint_try_from_int 
                {
                    ($T:ty, $from_ty:path) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: $T) -> Result<BigUint, TryFromBigIntError<()>> {
                                $from_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }
                    };
                }

                impl_biguint_try_from_int!(i8, FromPrimitive::from_i8);
                impl_biguint_try_from_int!(i16, FromPrimitive::from_i16);
                impl_biguint_try_from_int!(i32, FromPrimitive::from_i32);
                impl_biguint_try_from_int!(i64, FromPrimitive::from_i64);
                impl_biguint_try_from_int!(isize, FromPrimitive::from_isize);
                impl_biguint_try_from_int!(i128, FromPrimitive::from_i128);

                impl ToBigUint for BigUint 
                {
                    #[inline] fn to_biguint(&self) -> Option<BigUint> {
                        Some(self.clone())
                    }
                }

                macro_rules! impl_to_biguint 
                {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint(&self) -> Option<BigUint> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_biguint!(isize, FromPrimitive::from_isize);
                impl_to_biguint!(i8, FromPrimitive::from_i8);
                impl_to_biguint!(i16, FromPrimitive::from_i16);
                impl_to_biguint!(i32, FromPrimitive::from_i32);
                impl_to_biguint!(i64, FromPrimitive::from_i64);
                impl_to_biguint!(i128, FromPrimitive::from_i128);

                impl_to_biguint!(usize, FromPrimitive::from_usize);
                impl_to_biguint!(u8, FromPrimitive::from_u8);
                impl_to_biguint!(u16, FromPrimitive::from_u16);
                impl_to_biguint!(u32, FromPrimitive::from_u32);
                impl_to_biguint!(u64, FromPrimitive::from_u64);
                impl_to_biguint!(u128, FromPrimitive::from_u128);

                impl_to_biguint!(f32, FromPrimitive::from_f32);
                impl_to_biguint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigUint 
                {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }
                /// Extract bitwise digits that evenly divide BigDigit
                pub fn to_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits == 0);

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = (1 << bits) - 1;
                    let digits_per_big_digit = big_digit::BITS / bits;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push((r & mask) as u8);
                            r >>= bits;
                        }
                    }

                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push((r & mask) as u8);
                        r >>= bits;
                    }

                    res
                }
                /// Extract bitwise digits that don't evenly divide BigDigit
                pub fn to_inexact_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits != 0);

                    let mask: BigDigit = (1 << bits) - 1;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += big_digit::BITS;

                        while rbits >= bits {
                            res.push((r & mask) as u8);
                            r >>= bits;
                            
                            if rbits > big_digit::BITS {
                                r = *c >> (big_digit::BITS - (rbits - bits));
                            }

                            rbits -= bits;
                        }
                    }

                    if rbits != 0 {
                        res.push(r as u8);
                    }

                    while let Some(&0) = res.last() {
                        res.pop();
                    }

                    res
                }
                /// Extract little-endian radix digits
                #[inline(always)]
                pub fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && !radix.is_power_of_two());

                    let radix_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        ((u.bits() as f64) / radix_log2).ceil()
                    };
                    
                    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));

                    let mut digits = u.clone();
                    
                    let (base, power) = if FAST_DIV_WIDE {
                        get_radix_base(radix)
                    } else {
                        get_half_radix_base(radix)
                    };
                    let radix = radix as BigDigit;
                    
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from(base);
                        let mut big_power = 1usize;
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }
                        
                        while digits > big_base 
                        {
                            let (q, mut big_r) = digits.div_rem(&big_base);
                            digits = q;
                            
                            for _ in 0..big_power {
                                let (q, mut r) = div_rem_digit(big_r, base);
                                big_r = q;
                                for _ in 0..power {
                                    res.push((r % radix) as u8);
                                    r /= radix;
                                }
                            }
                        }
                    }

                    while digits.data.len() > 1 {
                        let (q, mut r) = div_rem_digit(digits, base);
                        for _ in 0..power {
                            res.push((r % radix) as u8);
                            r /= radix;
                        }
                        digits = q;
                    }

                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push((r % radix) as u8);
                        r /= radix;
                    }

                    res
                }

                pub fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> 
                {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            to_bitwise_digits_le(u, bits)
                        } else {
                            to_inexact_bitwise_digits_le(u, bits)
                        }
                    } else if radix == 10 {
                        to_radix_digits_le(u, 10)
                    } else {
                        to_radix_digits_le(u, radix)
                    }
                }

                pub fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> 
                {
                    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");

                    if u.is_zero() {
                        return vec![b'0'];
                    }

                    let mut res = to_radix_le(u, radix);
                    
                    for r in &mut res {
                        debug_assert!(u32::from(*r) < radix);
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }
                /// Returns the greatest power of the radix for the `BigDigit` bit size
                #[inline] fn get_radix_base(radix: u32) -> (BigDigit, usize) 
                {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::MAX);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }
                /// Returns the greatest power of the radix for half the `BigDigit` bit size
                #[inline] fn get_half_radix_base(radix: u32) -> (BigDigit, usize) 
                {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::HALF);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }
                /// Generate tables of the greatest power of each radix that is less that the given maximum.
                const fn generate_radix_bases(max: BigDigit) -> [(BigDigit, usize); 257] 
                {
                    let mut bases = [(0, 0); 257];

                    let mut radix: BigDigit = 3;
                    while radix < 256 {
                        if !radix.is_power_of_two() {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some(b) = base.checked_mul(radix) {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = (base, power)
                        }
                        radix += 1;
                    }

                    bases
                }
            }

            pub mod iter
            {
                use ::
                {
                    iter::{ FusedIterator },
                    num::
                    {
                        big::
                        {
                            big_digit::{},
                            biguint::{}
                        },
                        traits::{},
                    },
                    *,
                };
                /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                /// ordered least significant digit first.
                pub struct U32Digits<'a> 
                {
                    data: &'a [u64],
                    next_is_lo: bool,
                    last_hi_is_zero: bool,
                }                
                
                impl<'a> U32Digits<'a> {
                    #[inline]
                    pub fn new(data: &'a [u64]) -> Self {
                        let last_hi_is_zero = data
                            .last()
                            .map(|&last| 
                    {
                                let last_hi = (last >> 32) as u32;
                                last_hi == 0
                            })
                            .unwrap_or(false);
                        U32Digits {
                            data,
                            next_is_lo: true,
                            last_hi_is_zero,
                        }
                    }
                }

                impl Iterator for U32Digits<'_> {
                    type Item = u32;
                    #[inline] fn next(&mut self) -> Option<u32> {
                        match self.data.split_first() {
                            Some((&first, data)) => {
                                let next_is_lo = self.next_is_lo;
                                self.next_is_lo = !next_is_lo;
                                if next_is_lo {
                                    Some(first as u32)
                                } else {
                                    self.data = data;
                                    if data.is_empty() && self.last_hi_is_zero {
                                        self.last_hi_is_zero = false;
                                        None
                                    } else {
                                        Some((first >> 32) as u32)
                                    }
                                }
                            }
                            None => None,
                        }
                    }

                    #[inline] fn size_hint(&self) -> (usize, Option<usize>) 
                    {
                        let len = self.len();
                        (len, Some(len))
                    }

                    #[inline] fn last(self) -> Option<u32> {
                        self.data.last().map(|&last| 
                    {
                            if self.last_hi_is_zero {
                                last as u32
                            } else {
                                (last >> 32) as u32
                            }
                        })
                    }

                    #[inline] fn count(self) -> usize {
                        self.len()
                    }
                }

                impl DoubleEndedIterator for U32Digits<'_>
                {
                    fn next_back(&mut self) -> Option<Self::Item> {
                        match self.data.split_last() {
                            Some((&last, data)) => {
                                let last_is_lo = self.last_hi_is_zero;
                                self.last_hi_is_zero = !last_is_lo;
                                if last_is_lo {
                                    self.data = data;
                                    if data.is_empty() && !self.next_is_lo {
                                        self.next_is_lo = true;
                                        None
                                    } else {
                                        Some(last as u32)
                                    }
                                } else {
                                    Some((last >> 32) as u32)
                                }
                            }
                            None => None,
                        }
                    }
                }

                impl ExactSizeIterator for U32Digits<'_> {
                    #[inline] fn len(&self) -> usize {
                        self.data.len() * 2
                            - usize::from(self.last_hi_is_zero)
                            - usize::from(!self.next_is_lo)
                    }
                }

                impl FusedIterator for U32Digits<'_> {}

                cfg_digit!(
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Chunks<'a, u32>,
                    }

                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Iter<'a, u64>,
                    }
                );

                
                impl<'a> U64Digits<'a> {
                    #[inline]
                    pub fn new(data: &'a [u64]) -> Self {
                        Self { it: data.iter() }
                    }
                }

                impl Iterator for U64Digits<'_> {
                    type Item = u64;
                    #[inline] fn next(&mut self) -> Option<u64> {
                        self.it.next().cloned()
                    }

                    #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                        self.it.size_hint()
                    }

                    #[inline] fn nth(&mut self, n: usize) -> Option<u64> {
                        self.it.nth(n).cloned()
                    }

                    #[inline] fn last(self) -> Option<u64> {
                        self.it.last().cloned()
                    }

                    #[inline] fn count(self) -> usize {
                        self.it.count()
                    }
                }

                impl DoubleEndedIterator for U64Digits<'_>
                {
                    fn next_back(&mut self) -> Option<Self::Item> {
                        self.it.next_back().cloned()
                    }
                }

                impl ExactSizeIterator for U64Digits<'_> {
                    #[inline] fn len(&self) -> usize {
                        self.it.len()
                    }
                }

                impl FusedIterator for U64Digits<'_> {}
            }

            pub mod monty
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit, DoubleBigDigit },
                            biguint::{ BigUint },
                        },
                        traits::{ One },
                    },
                    ops::{ Shl },
                    vec::{ Vec },
                    *,
                };
                
                struct MontyReducer 
                {
                    n0inv: BigDigit,
                }
                
                fn inv_mod_alt(b: BigDigit) -> BigDigit 
                {
                    assert_ne!(b & 1, 0);

                    let mut k0 = BigDigit::wrapping_sub(2, b);
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < big_digit::BITS {
                        t = t.wrapping_mul(t);
                        k0 = k0.wrapping_mul(t + 1);

                        i <<= 1;
                    }
                    debug_assert_eq!(k0.wrapping_mul(b), 1);
                    k0.wrapping_neg()
                }

                impl MontyReducer 
                {
                    fn new(n: &BigUint) -> Self {
                        let n0inv = inv_mod_alt(n.data[0]);
                        MontyReducer { n0inv }
                    }
                }
                /// Computes z mod m = x * y * 2 ** (-n*_W) mod m, assuming k = -1/m mod 2**_W
                fn montgomery(x: &BigUint, y: &BigUint, m: &BigUint, k: BigDigit, n: usize) -> BigUint 
                {
                    assert!(
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                    );

                    let mut z = BigUint::ZERO;
                    z.data.resize(n * 2, 0);

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw(&mut z.data[i..n + i], &x.data, y.data[i]);
                        let t = z.data[i].wrapping_mul(k);
                        let c3 = add_mul_vvw(&mut z.data[i..n + i], &m.data, t);
                        let cx = c.wrapping_add(c2);
                        let cy = cx.wrapping_add(c3);
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }

                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let (first, second) = z.data.split_at_mut(n);
                            sub_vv(first, second, &m.data);
                        }
                        z.data = z.data[..n].to_vec();
                    }

                    z
                }

                #[inline( always )] fn add_mul_vvw(z: &mut [BigDigit], x: &[BigDigit], y: BigDigit) -> BigDigit 
                {
                    let mut c = 0;
                    for (zi, xi) in z.iter_mut().zip(x.iter()) 
                    {
                        let (z1, z0) = mul_add_www(*xi, y, *zi);
                        let (c_, zi_) = add_ww(z0, c, 0);
                        *zi = zi_;
                        c = c_ + z1;
                    }

                    c
                }
                /// The resulting carry c is either 0 or 1.
                #[inline( always )] fn sub_vv(z: &mut [BigDigit], x: &[BigDigit], y: &[BigDigit]) -> BigDigit 
                {
                    let mut c = 0;
                    for (i, (xi, yi)) in x.iter().zip(y.iter()).enumerate().take(z.len()) 
                    {
                        let zi = xi.wrapping_sub(*yi).wrapping_sub(c);
                        z[i] = zi;
                        c = ((yi & !xi) | ((yi | !xi) & zi)) >> (big_digit::BITS - 1)
                    }

                    c
                }
                /// z1<<_W + z0 = x+y+c, with c == 0 or 1
                #[inline( always )] fn add_ww(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) 
                {
                    let yc = y.wrapping_add(c);
                    let z0 = x.wrapping_add(yc);
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    (z1, z0)
                }
                /// z1 << _W + z0 = x * y + c
                #[inline( always )] fn mul_add_www(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) 
                {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ((z >> big_digit::BITS) as BigDigit, z as BigDigit)
                }
                /// Calculates x ** y mod m using a fixed, 4-bit window.
                #[allow(clippy::many_single_char_names)]
                pub fn monty_modpow(x: &BigUint, y: &BigUint, m: &BigUint) -> BigUint 
                {
                    assert!(m.data[0] & 1 == 1);
                    let mr = MontyReducer::new(m);
                    let num_words = m.data.len();

                    let mut x = x.clone();
                    
                    if x.data.len() > num_words {
                        x %= m;
                    }
                    if x.data.len() < num_words {
                        x.data.resize(num_words, 0);
                    }
                    
                    let mut rr = BigUint::one();
                    rr = (rr.shl(2 * num_words as u64 * u64::from(big_digit::BITS))) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize(num_words, 0);
                    }
                    
                    let mut one = BigUint::one();
                    one.data.resize(num_words, 0);

                    let n = 4;
                    let mut powers = Vec::with_capacity(1 << n);
                    powers.push(montgomery(&one, &rr, m, mr.n0inv, num_words));
                    powers.push(montgomery(&x, &rr, m, mr.n0inv, num_words));
                    for i in 2..1 << n {
                        let r = montgomery(&powers[i - 1], &powers[1], m, mr.n0inv, num_words);
                        powers.push(r);
                    }
                    
                    let mut z = powers[0].clone();
                    z.data.resize(num_words, 0);
                    let mut zz = BigUint::ZERO;
                    zz.data.resize(num_words, 0);
                    
                    for i in (0..y.data.len()).rev() 
                    {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < big_digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                            }
                            zz = montgomery(
                                &z,
                                &powers[(yi >> (big_digit::BITS - n)) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                            );
                            mem::swap(&mut z, &mut zz);
                            yi <<= n;
                            j += n;
                        }
                    }
                    
                    zz = montgomery(&z, &one, m, mr.n0inv, num_words);

                    zz.normalize();
                    if zz >= *m {
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }

                    zz.normalize();
                    zz
                }
            }

            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            big_digit::{ self, BigDigit },
                            biguint::
                            {
                                monty::{ monty_modpow },
                                BigUint,
                            },
                        },
                        integers::{ Integer },
                        traits::{ One, Pow, ToPrimitive, Zero },
                    },
                    *,
                };
                
                impl Pow<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some(exp) = exp.to_u64() {
                            self.pow(exp)
                        } else if let Some(exp) = exp.to_u128() {
                            self.pow(exp)
                        } else {
                            panic!("memory overflow")
                        }
                    }
                }

                impl Pow<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                impl Pow<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow(exp)
                        }
                    }
                }

                impl Pow<BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow(self, mut exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }

                                if exp == 1 {
                                    return base;
                                }

                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }

                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }

                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow(self.clone(), exp)
                            }
                        }

                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);

                pub fn modpow(x: &BigUint, exponent: &BigUint, modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    if modulus.is_odd() {
                        monty_modpow(x, exponent, modulus)
                    } else {
                        plain_modpow(x, &exponent.data, modulus)
                    }
                }

                fn plain_modpow(base: &BigUint, exp_data: &[BigDigit], modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let i = match exp_data.iter().position(|&r| r != 0) {
                        None => return BigUint::one(),
                        Some(i) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..big_digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }

                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }

                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }

                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| 
                    {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some(&last) = exp_iter.next_back() {
                            for _ in b..big_digit::BITS {
                                unit(r.is_odd());
                                r >>= 1;
                            }
                            
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..big_digit::BITS {
                                    unit(r.is_odd());
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }

                        debug_assert_ne!(r, 0);
                        while !r.is_zero() {
                            unit(r.is_odd());
                            r >>= 1;
                        }
                    }
                    acc
                }
            }

            pub mod shift
            {
                use ::
                {
                    borrow::{ Cow },
                    num::
                    {
                        big::
                        {
                            big_digit::{ self },
                            biguint::{ biguint_from_vec, BigUint },
                        },
                        traits::{ PrimInt, Zero },
                    },
                    ops::{ Shl, ShlAssign, Shr, ShrAssign },
                    vec::{ Vec },
                    *,
                };

                #[inline] fn biguint_shl<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift left with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().expect("capacity overflow");
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shl2(n, digits, shift)
                }

                fn biguint_shl2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add(n.data.len() + 1);
                            let mut data = Vec::with_capacity(len);
                            data.resize(digits, 0);
                            data.extend(n.data.iter());
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = big_digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = (*elem << shift) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push(carry);
                        }
                    }

                    biguint_from_vec(data)
                }

                #[inline] fn biguint_shr<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift right with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().unwrap_or(usize::MAX);
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shr2(n, digits, shift)
                }

                fn biguint_shr2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    if digits >= n.data.len() 
                    {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed(n) => n.data[digits..].to_vec(),
                        Cow::Owned(mut n) => {
                            n.data.drain(..digits);
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = big_digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = (*elem >> shift) | borrow;
                            borrow = new_borrow;
                        }
                    }

                    biguint_from_vec(data)
                }

                macro_rules! impl_shift {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
            }

            pub use self::convert::to_str_radix_reversed;
            pub use self::iter::{U32Digits, U64Digits};
            /// A big unsigned integer type.
            pub struct BigUint
            {
                data: Vec<BigDigit>,
            }
            
            impl Clone for BigUint {
                #[inline] fn clone(&self) -> Self {
                    BigUint {
                        data: self.data.clone(),
                    }
                }

                #[inline] fn clone_from(&mut self, other: &Self) {
                    self.data.clone_from(&other.data);
                }
            }

            impl hash::Hash for BigUint {
                #[inline] fn hash<H: hash::Hasher>(&self, state: &mut H) {
                    debug_assert!(self.data.last() != Some(&0));
                    self.data.hash(state);
                }
            }

            impl PartialEq for BigUint {
                #[inline] fn eq(&self, other: &BigUint) -> bool {
                    debug_assert!(self.data.last() != Some(&0));
                    debug_assert!(other.data.last() != Some(&0));
                    self.data == other.data
                }
            }
            impl Eq for BigUint {}

            impl PartialOrd for BigUint {
                #[inline] fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Ord for BigUint {
                #[inline] fn cmp(&self, other: &BigUint) -> Ordering {
                    cmp_slice(&self.data[..], &other.data[..])
                }
            }

            #[inline] fn cmp_slice(a: &[BigDigit], b: &[BigDigit]) -> Ordering {
                debug_assert!(a.last() != Some(&0));
                debug_assert!(b.last() != Some(&0));

                match Ord::cmp(&a.len(), &b.len()) {
                    Ordering::Equal => Iterator::cmp(a.iter().rev(), b.iter().rev()),
                    other => other,
                }
            }

            impl Default for BigUint {
                #[inline] fn default() -> BigUint {
                    Self::ZERO
                }
            }

            impl fmt::Debug for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(self, f)
                }
            }

            impl fmt::Display for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "", &self.to_str_radix(10))
                }
            }

            impl fmt::LowerHex for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "0x", &self.to_str_radix(16))
                }
            }

            impl fmt::UpperHex for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut s = self.to_str_radix(16);
                    s.make_ascii_uppercase();
                    f.pad_integral(true, "0x", &s)
                }
            }

            impl fmt::Binary for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "0b", &self.to_str_radix(2))
                }
            }

            impl fmt::Octal for BigUint {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(true, "0o", &self.to_str_radix(8))
                }
            }

            impl Zero for BigUint {
                #[inline] fn zero() -> BigUint {
                    Self::ZERO
                }

                #[inline] fn set_zero(&mut self) {
                    self.data.clear();
                }

                #[inline] fn is_zero(&self) -> bool {
                    self.data.is_empty()
                }
            }

            impl ConstZero for BigUint {
                const ZERO: Self = Self::ZERO;
            }

            impl One for BigUint {
                #[inline] fn one() -> BigUint {
                    BigUint { data: vec![1] }
                }

                #[inline] fn set_one(&mut self) {
                    self.data.clear();
                    self.data.push(1);
                }

                #[inline] fn is_one(&self) -> bool {
                    self.data[..] == [1]
                }
            }

            impl Unsigned for BigUint {}

            impl Integer for BigUint {
                #[inline] fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {
                    division::div_rem_ref(self, other)
                }

                #[inline] fn div_floor(&self, other: &BigUint) -> BigUint {
                    let (d, _) = division::div_rem_ref(self, other);
                    d
                }

                #[inline] fn mod_floor(&self, other: &BigUint) -> BigUint {
                    let (_, m) = division::div_rem_ref(self, other);
                    m
                }

                #[inline] fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {
                    division::div_rem_ref(self, other)
                }

                #[inline] fn div_ceil(&self, other: &BigUint) -> BigUint {
                    let (d, m) = division::div_rem_ref(self, other);
                    if m.is_zero() {
                        d
                    } else {
                        d + 1u32
                    }
                }
                /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
                #[inline] fn gcd(&self, other: &Self) -> Self {
                    #[inline] fn twos(x: &BigUint) -> u64 {
                        x.trailing_zeros().unwrap_or(0)
                    }
                    
                    if self.is_zero() {
                        return other.clone();
                    }
                    if other.is_zero() {
                        return self.clone();
                    }
                    let mut m = self.clone();
                    let mut n = other.clone();
                    let shift = cmp::min(twos(&n), twos(&m));
                    
                    n >>= twos(&n);

                    while !m.is_zero() {
                        m >>= twos(&m);
                        if n > m {
                            mem::swap(&mut n, &mut m)
                        }
                        m -= &n;
                    }

                    n << shift
                }
                /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                #[inline] fn lcm(&self, other: &BigUint) -> BigUint {
                    if self.is_zero() && other.is_zero() {
                        Self::ZERO
                    } else {
                        self / self.gcd(other) * other
                    }
                }
                /// Calculates the Greatest Common Divisor (GCD) and
                /// Lowest Common Multiple (LCM) together.
                #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                    let gcd = self.gcd(other);
                    let lcm = if gcd.is_zero() {
                        Self::ZERO
                    } else {
                        self / &gcd * other
                    };
                    (gcd, lcm)
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides(&self, other: &BigUint) -> bool {
                    self.is_multiple_of(other)
                }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of(&self, other: &BigUint) -> bool {
                    if other.is_zero() {
                        return self.is_zero();
                    }
                    (self % other).is_zero()
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even(&self) -> bool {
                    match self.data.first() {
                        Some(x) => x.is_even(),
                        None => true,
                    }
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd(&self) -> bool {
                    !self.is_even()
                }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of(&self, other: &Self) -> Self {
                    let m = self.mod_floor(other);
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + (other - m)
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of(&self, other: &Self) -> Self {
                    self - self.mod_floor(other)
                }

                fn dec(&mut self) {
                    *self -= 1u32;
                }

                fn inc(&mut self) {
                    *self += 1u32;
                }
            }

            #[inline] fn fixpoint<F>(mut x: BigUint, max_bits: u64, f: F) -> BigUint
            where
                F: Fn(&BigUint) -> BigUint,
            {
                let mut xn = f(&x);

                while x < xn {
                    x = if xn.bits() > max_bits {
                        BigUint::one() << max_bits
                    } else {
                        xn
                    };
                    xn = f(&x);
                }
                
                while x > xn {
                    x = xn;
                    xn = f(&x);
                }
                x
            }

            impl Roots for BigUint 
            {
                fn nth_root(&self, n: u32) -> Self 
                {
                    assert!(n > 0, "root degree n must be at least 1");

                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }

                    match n {
                        1 => return self.clone(),
                        2 => return self.sqrt(),
                        3 => return self.cbrt(),
                        _ => (),
                    }
                    
                    let bits = self.bits();
                    let n64 = u64::from(n);
                    if bits <= n64 {
                        return BigUint::one();
                    }
                    
                    if let Some(x) = self.to_u64() {
                        return x.nth_root(n).into();
                    }

                    let max_bits = bits / n64 + 1;
                    
                    let guess = match self.to_f64() {
                        Some(f) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;
                            
                            BigUint::from_f64((f.ln() / f64::from(n)).exp()).unwrap()
                        }
                        _ => {
                            let extra_bits = bits - (f64::MAX_EXP as u64 - 1);
                            let root_scale = Integer::div_ceil(&extra_bits, &n64);
                            let scale = root_scale * n64;
                            if scale < bits && bits - scale > n64 {
                                (self >> scale).nth_root(n) << root_scale
                            } else {
                                BigUint::one() << max_bits
                            }
                        }
                    };

                    let n_min_1 = n - 1;
                    fixpoint(guess, max_bits, move |s| 
                    {
                        let q = self / s.pow(n_min_1);
                        let t = n_min_1 * s + q;
                        t / n
                    })
                }
                
                fn sqrt(&self) -> Self 
                {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                    
                    if let Some(x) = self.to_u64() {
                        return x.sqrt().into();
                    }

                    let bits = self.bits();
                    let max_bits = bits / 2 + 1;                    
                    let guess = match self.to_f64() {
                        Some(f) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;
                            BigUint::from_f64(f.sqrt()).unwrap()
                        }
                        _ => {
                            let extra_bits = bits - (f64::MAX_EXP as u64 - 1);
                            let root_scale = (extra_bits + 1) / 2;
                            let scale = root_scale * 2;
                            (self >> scale).sqrt() << root_scale
                        }
                    };

                    fixpoint(guess, max_bits, move |s| 
                    {
                        let q = self / s;
                        let t = s + q;
                        t >> 1
                    })
                }

                fn cbrt(&self) -> Self 
                {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                    
                    if let Some(x) = self.to_u64() {
                        return x.cbrt().into();
                    }

                    let bits = self.bits();
                    let max_bits = bits / 3 + 1;
                    
                    let guess = match self.to_f64() {
                        Some(f) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;
                            
                            BigUint::from_f64(f.cbrt()).unwrap()
                        }
                        _ => {
                            let extra_bits = bits - (f64::MAX_EXP as u64 - 1);
                            let root_scale = (extra_bits + 2) / 3;
                            let scale = root_scale * 3;
                            (self >> scale).cbrt() << root_scale
                        }
                    };
                    
                    fixpoint(guess, max_bits, move |s| 
                    {
                        let q = self / (s * s);
                        let t = (s << 1) + q;
                        t / 3u32
                    })
                }
            }
            /// A generic trait for converting a value to a [`BigUint`].
            pub trait ToBigUint {
                /// Converts the value of `self` to a [`BigUint`].
                fn to_biguint(&self) -> Option<BigUint>;
            }
            /// Creates and initializes a [`BigUint`].
            #[inline] pub fn biguint_from_vec(digits: Vec<BigDigit>) -> BigUint {
                BigUint { data: digits }.normalized()
            }

            impl BigUint 
            {
                /// A constant `BigUint` with value 0, useful for static initialization.
                pub const ZERO: Self = BigUint { data: Vec::new() };
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn new(digits: Vec<u32>) -> BigUint {
                    let mut big = Self::ZERO;

                    cfg_digit_expr!(
                        {
                            big.data = digits;
                            big.normalize();
                        },
                        big.assign_from_slice(&digits)
                    );

                    big
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_slice(slice: &[u32]) -> BigUint {
                    let mut big = Self::ZERO;
                    big.assign_from_slice(slice);
                    big
                }
                /// Assign a value to a [`BigUint`].
                #[inline] pub fn assign_from_slice(&mut self, slice: &[u32]) {
                    self.data.clear();

                    cfg_digit_expr!(
                        self.data.extend_from_slice(slice),
                        self.data.extend(slice.chunks(2).map(u32_chunk_to_u64))
                    );

                    self.normalize();
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_be(bytes: &[u8]) -> BigUint {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        let mut v = bytes.to_vec();
                        v.reverse();
                        BigUint::from_bytes_le(&v)
                    }
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_le(bytes: &[u8]) -> BigUint {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        convert::from_bitwise_digits_le(bytes, 8)
                    }
                }
                /// Creates and initializes a [`BigUint`]
                #[inline] pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigUint>
                {
                    let s = str::from_utf8(buf).ok()?;
                    BigUint::from_str_radix(s, radix).ok()
                }
                /// Creates and initializes a [`BigUint`].
                pub fn from_radix_be(buf: &[u8], radix: u32) -> Option<BigUint> {
                    convert::from_radix_be(buf, radix)
                }
                /// Creates and initializes a [`BigUint`].
                pub fn from_radix_le(buf: &[u8], radix: u32) -> Option<BigUint> {
                    convert::from_radix_le(buf, radix)
                }
                /// Returns the byte representation of the [`BigUint`] in big-endian byte order.
                #[inline] pub fn to_bytes_be(&self) -> Vec<u8>
                {
                    let mut v = self.to_bytes_le();
                    v.reverse();
                    v
                }
                /// Returns the byte representation of the [`BigUint`] in little-endian byte order.
                #[inline] pub fn to_bytes_le(&self) -> Vec<u8> {
                    if self.is_zero() {
                        vec![0]
                    } else {
                        convert::to_bitwise_digits_le(self, 8)
                    }
                }
                /// Returns the `u32` digits representation of the [`BigUint`] ordered least significant digit
                /// first.
                #[inline] pub fn to_u32_digits(&self) -> Vec<u32> {
                    self.iter_u32_digits().collect()
                }
                /// Returns the `u64` digits representation of the [`BigUint`] ordered least significant digit
                /// first.
                #[inline] pub fn to_u64_digits(&self) -> Vec<u64> {
                    self.iter_u64_digits().collect()
                }
                /// Returns an iterator of `u32` digits representation of the [`BigUint`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u32_digits(&self) -> U32Digits<'_> {
                    U32Digits::new(self.data.as_slice())
                }
                /// Returns an iterator of `u64` digits representation of the [`BigUint`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u64_digits(&self) -> U64Digits<'_> {
                    U64Digits::new(self.data.as_slice())
                }
                /// Returns the integer formatted as a string in the given radix.
                /// `radix` must be in the range `2...36`.
                #[inline] pub fn to_str_radix(&self, radix: u32) -> String {
                    let mut v = to_str_radix_reversed(self, radix);
                    v.reverse();
                    unsafe { String::from_utf8_unchecked(v) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be(&self, radix: u32) -> Vec<u8>
                {
                    let mut v = convert::to_radix_le(self, radix);
                    v.reverse();
                    v
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le(&self, radix: u32) -> Vec<u8> {
                    convert::to_radix_le(self, radix)
                }
                /// Determines the fewest bits necessary to express the [`BigUint`].
                #[inline] pub fn bits(&self) -> u64 {
                    if self.is_zero() {
                        return 0;
                    }
                    let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
                    self.data.len() as u64 * u64::from(big_digit::BITS) - zeros
                }
                /// Strips off trailing zero bigdigit
                #[inline] fn normalize(&mut self) {
                    if let Some(&0) = self.data.last() 
                    {
                        let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
                        self.data.truncate(len);
                    }
                    if self.data.len() < self.data.capacity() / 4 {
                        self.data.shrink_to_fit();
                    }
                }
                /// Returns a normalized [`BigUint`].
                #[inline] fn normalized(mut self) -> BigUint {
                    self.normalize();
                    self
                }
                /// Returns `self ^ exponent`.
                pub fn pow(&self, exponent: u32) -> Self {
                    Pow::pow(self, exponent)
                }
                /// Returns `(self ^ exponent) % modulus`.
                pub fn modpow(&self, exponent: &Self, modulus: &Self) -> Self {
                    power::modpow(self, exponent, modulus)
                }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv(&self, modulus: &Self) -> Option<Self> {

                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );
                    if modulus.is_one() {
                        return Some(Self::zero());
                    }

                    let mut r0;
                    let mut r1 = self % modulus;
                    let mut t0;
                    let mut t1;
                    
                    if r1.is_zero() {
                        return None;
                    } else if r1.is_one() {
                        return Some(r1);
                    } else {
                        let (q, r2) = modulus.div_rem(&r1);
                        if r2.is_zero() {
                            return None;
                        }
                        r0 = r1;
                        r1 = r2;
                        t0 = Self::one();
                        t1 = modulus - q;
                    }

                    while !r1.is_zero() 
                    {
                        let (q, r2) = r0.div_rem(&r1);
                        r0 = r1;
                        r1 = r2;
                        
                        let qt1 = q * &t1 % modulus;
                        let t2 = if t0 < qt1 {
                            t0 + (modulus - qt1)
                        } else {
                            t0 - qt1
                        };
                        t0 = t1;
                        t1 = t2;
                    }

                    if r0.is_one() {
                        Some(t0)
                    } else {
                        None
                    }
                }
                /// Returns the truncated principal square root of `self`
                pub fn sqrt(&self) -> Self {
                    Roots::sqrt(self)
                }
                /// Returns the truncated principal cube root of `self`
                pub fn cbrt(&self) -> Self {
                    Roots::cbrt(self)
                }
                /// Returns the truncated principal `n`th root of `self`
                pub fn nth_root(&self, n: u32) -> Self {
                    Roots::nth_root(self, n)
                }
                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros(&self) -> Option<u64>
                {
                    let i = self.data.iter().position(|&digit| digit != 0)?;
                    let zeros: u64 = self.data[i].trailing_zeros().into();
                    Some(i as u64 * u64::from(big_digit::BITS) + zeros)
                }
                /// Returns the number of least-significant bits that are ones.
                pub fn trailing_ones(&self) -> u64 {
                    if let Some(i) = self.data.iter().position(|&digit| !digit != 0) 
                    {
                        let ones: u64 = self.data[i].trailing_ones().into();
                        i as u64 * u64::from(big_digit::BITS) + ones
                    } else {
                        self.data.len() as u64 * u64::from(big_digit::BITS)
                    }
                }
                /// Returns the number of one bits.
                pub fn count_ones(&self) -> u64 {
                    self.data.iter().map(|&d| u64::from(d.count_ones())).sum()
                }
                /// Returns whether the bit in the given position is set
                pub fn bit(&self, bit: u64) -> bool {
                    let bits_per_digit = u64::from(big_digit::BITS);
                    if let Some(digit_index) = (bit / bits_per_digit).to_usize() {
                        if let Some(digit) = self.data.get(digit_index) {
                            let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                            return (digit & bit_mask) != 0;
                        }
                    }
                    false
                }
                /// Sets or clears the bit in the given position.
                pub fn set_bit(&mut self, bit: u64, value: bool)
                {
                    let bits_per_digit = u64::from(big_digit::BITS);
                    let digit_index = (bit / bits_per_digit).to_usize().unwrap_or(usize::MAX);
                    let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                    if value
                    {
                        if digit_index >= self.data.len()
                        {
                            let new_len = digit_index.saturating_add(1);
                            self.data.resize(new_len, 0);
                        }
                        self.data[digit_index] |= bit_mask;
                    }
                    else if digit_index < self.data.len()
                    {
                        self.data[digit_index] &= !bit_mask;
                        self.normalize();
                    }
                }
            }

            impl ::num::traits::FromBytes for BigUint
            {
                type Bytes = [u8];
                fn from_be_bytes(bytes: &Self::Bytes) -> Self { Self::from_bytes_be(bytes) }
                fn from_le_bytes(bytes: &Self::Bytes) -> Self { Self::from_bytes_le(bytes) }
            }

            impl ::num::traits::ToBytes for BigUint
            {
                type Bytes = Vec<u8>;
                fn to_be_bytes(&self) -> Self::Bytes { self.to_bytes_be() }
                fn to_le_bytes(&self) -> Self::Bytes { self.to_bytes_le() }
            }

           pub trait IntDigits
           {
                fn digits(&self) -> &[BigDigit];
                fn digits_mut(&mut self) -> &mut Vec<BigDigit>;
                fn normalize(&mut self);
                fn capacity(&self) -> usize;
                fn len(&self) -> usize;
            }

            impl IntDigits for BigUint
            {
                #[inline] fn digits(&self) -> &[BigDigit] {
                    &self.data
                }
                #[inline] fn digits_mut(&mut self) -> &mut Vec<BigDigit> {
                    &mut self.data
                }
                #[inline] fn normalize(&mut self) {
                    self.normalize();
                }
                #[inline] fn capacity(&self) -> usize {
                    self.data.capacity()
                }
                #[inline] fn len(&self) -> usize {
                    self.data.len()
                }
            }
            /// Convert a `u32` chunk (len is either 1 or 2) to a single `u64` digit
            #[inline] fn u32_chunk_to_u64(chunk: &[u32]) -> u64 {
                let mut digit = chunk[0] as u64;
                if let Some(&hi) = chunk.get(1) {
                    digit |= (hi as u64) << 32;
                }
                digit
            }
        }
        
        type UsizePromotion = u64;
        type IsizePromotion = i64;

        #[derive( Debug, Clone, PartialEq, Eq )]
        pub struct ParseBigIntError 
        {
            kind: BigIntErrorKind,
        }

        #[derive( Debug, Clone, PartialEq, Eq )]
        enum BigIntErrorKind 
        {
            Empty,
            InvalidDigit,
        }

        impl ParseBigIntError 
        
        {
            fn __description(&self) -> &str 
            {
                use self::BigIntErrorKind::*;
                match self.kind {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }

            fn empty() -> Self 
            {
                ParseBigIntError {
                    kind: BigIntErrorKind::Empty,
                }
            }

            fn invalid() -> Self 
            {
                ParseBigIntError {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
            {
                self.__description().fmt(f)
            }
        }
        
        impl ::error::Error for ParseBigIntError 
        
        {
            fn description(&self) -> &str 
            {
                self.__description()
            }
        }
        /// The error type returned when a checked conversion regarding big integer fails.
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TryFromBigIntError<T> 
        {
            original: T,
        }

        impl<T> TryFromBigIntError<T> 
        
        {
            fn new(original: T) -> Self {
                TryFromBigIntError { original }
            }

            fn __description(&self) -> &str {
                "out of range conversion regarding big integer attempted"
            }
            /// Extract the original value, if available. The value will be available
            /// if the type before conversion was either [`BigInt`] or [`BigUint`].
            pub fn into_original(self) -> T {
                self.original
            }
        }
        
        impl<T> std::error::Error for TryFromBigIntError<T> where
        T: fmt::Debug
        
        {
            fn description(&self) -> &str 
            {
                self.__description()
            }
        }

        impl<T> fmt::Display for TryFromBigIntError<T> 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
            {
                self.__description().fmt(f)
            }
        }

        pub use self::biguint::BigUint;
        pub use self::biguint::ToBigUint;
        pub use self::biguint::U32Digits;
        pub use self::biguint::U64Digits;
        pub use self::bigint::BigInt;
        pub use self::bigint::Sign;
        pub use self::bigint::ToBigInt;
        
        pub use self::bigrand::{RandBigInt, RandomBits, UniformBigInt, UniformBigUint};

        mod big_digit 
        {
            /// A [`BigDigit`] is a [`BigUint`]'s composing element.
            pub type BigDigit = u64;
            /// A [`DoubleBigDigit`] is the internal type used to do the computations.
            pub type DoubleBigDigit = u128;

            pub const BITS: u8 = BigDigit::BITS as u8;
            pub const HALF_BITS: u8 = BITS / 2;
            pub const HALF: BigDigit = (1 << HALF_BITS) - 1;
            pub const MAX: BigDigit = BigDigit::MAX;
            pub const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline] fn get_hi(n: DoubleBigDigit) -> BigDigit 
            {
                (n >> BITS) as BigDigit
            }
            #[inline] fn get_lo(n: DoubleBigDigit) -> BigDigit 
            {
                (n & LO_MASK) as BigDigit
            }
            /// Split one [`DoubleBigDigit`] into two [`BigDigit`]s.
            #[inline] pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) 
            {
                (get_hi(n), get_lo(n))
            }
            /// Join two [`BigDigit`]s into one [`DoubleBigDigit`].
            #[inline] pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit 
            {
                DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
            }
        }
    }
    
    pub mod complex
    {
        //! Complex Numbers
        use ::
        {
            error::Error,
            iter::{ Product, Sum },
            num::traits::{ ConstOne, ConstZero, float::{ Float, FloatConst, FloatCore }, Inv, MulAdd, Num, One, Pow, Signed, Zero },
            ops::{ Add, Div, Mul, Neg, Rem, Sub },
            str::FromStr,
            *,
        };
        
        pub mod cast
        {
            use ::
            {
                num::traits::{ AsPrimitive, FromPrimitive, Num, NumCast, ToPrimitive },
                *,
            }; use super::Complex;

            macro_rules! impl_to_primitive
            {
                ($ty:ty, $to:ident) => {
                    #[inline] fn $to(&self) -> Option<$ty> {
                        if self.im.is_zero() {
                            self.re.$to()
                        } else {
                            None
                        }
                    }
                };
            }
            
            impl<T: ToPrimitive + Num> ToPrimitive for Complex<T> {
                impl_to_primitive!(usize, to_usize);
                impl_to_primitive!(isize, to_isize);
                impl_to_primitive!(u8, to_u8);
                impl_to_primitive!(u16, to_u16);
                impl_to_primitive!(u32, to_u32);
                impl_to_primitive!(u64, to_u64);
                impl_to_primitive!(i8, to_i8);
                impl_to_primitive!(i16, to_i16);
                impl_to_primitive!(i32, to_i32);
                impl_to_primitive!(i64, to_i64);
                impl_to_primitive!(u128, to_u128);
                impl_to_primitive!(i128, to_i128);
                impl_to_primitive!(f32, to_f32);
                impl_to_primitive!(f64, to_f64);
            }

            macro_rules! impl_from_primitive {
                ($ty:ty, $from_xx:ident) => {
                    #[inline] fn $from_xx(n: $ty) -> Option<Self> {
                        Some(Complex {
                            re: T::$from_xx(n)?,
                            im: T::zero(),
                        })
                    }
                };
            }

            impl<T: FromPrimitive + Num> FromPrimitive for Complex<T> {
                impl_from_primitive!(usize, from_usize);
                impl_from_primitive!(isize, from_isize);
                impl_from_primitive!(u8, from_u8);
                impl_from_primitive!(u16, from_u16);
                impl_from_primitive!(u32, from_u32);
                impl_from_primitive!(u64, from_u64);
                impl_from_primitive!(i8, from_i8);
                impl_from_primitive!(i16, from_i16);
                impl_from_primitive!(i32, from_i32);
                impl_from_primitive!(i64, from_i64);
                impl_from_primitive!(u128, from_u128);
                impl_from_primitive!(i128, from_i128);
                impl_from_primitive!(f32, from_f32);
                impl_from_primitive!(f64, from_f64);
            }

            impl<T: NumCast + Num> NumCast for Complex<T> {
                fn from<U: ToPrimitive>(n: U) -> Option<Self> {
                    Some(Complex {
                        re: T::from(n)?,
                        im: T::zero(),
                    })
                }
            }

            impl<T, U> AsPrimitive<U> for Complex<T>
            where
                T: AsPrimitive<U>,
                U: 'static + Copy,
            {
                fn as_(self) -> U {
                    self.re.as_()
                }
            }
        }

        pub mod pow
        {
            use ::
            {
                num::traits::{ Float, Num, One, Pow },
                ops::Neg,
                *,
            }; use super::Complex;

            macro_rules! pow_impl
            {
                ($U:ty, $S:ty) => {
                    impl<'a, T: Clone + Num> Pow<$U> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, mut exp: $U) -> Self::Output {
                            if exp == 0 {
                                return Complex::one();
                            }
                            let mut base = self.clone();

                            while exp & 1 == 0 {
                                base = base.clone() * base;
                                exp >>= 1;
                            }

                            if exp == 1 {
                                return base;
                            }

                            let mut acc = base.clone();
                            while exp > 1 {
                                exp >>= 1;
                                base = base.clone() * base;
                                if exp & 1 == 1 {
                                    acc = acc * base.clone();
                                }
                            }
                            acc
                        }
                    }

                    impl<'a, 'b, T: Clone + Num> Pow<&'b $U> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, exp: &$U) -> Self::Output {
                            self.pow(*exp)
                        }
                    }

                    impl<'a, T: Clone + Num + Neg<Output = T>> Pow<$S> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, exp: $S) -> Self::Output {
                            if exp < 0 {
                                Pow::pow(&self.inv(), exp.wrapping_neg() as $U)
                            } else {
                                Pow::pow(self, exp as $U)
                            }
                        }
                    }

                    impl<'a, 'b, T: Clone + Num + Neg<Output = T>> Pow<&'b $S> for &'a Complex<T> {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, exp: &$S) -> Self::Output {
                            self.pow(*exp)
                        }
                    }
                };
            }

            pow_impl!(u8, i8);
            pow_impl!(u16, i16);
            pow_impl!(u32, i32);
            pow_impl!(u64, i64);
            pow_impl!(usize, isize);
            pow_impl!(u128, i128);

            macro_rules! powf_impl {
                ($F:ty) => {
                    impl<'a, T: Float> Pow<$F> for &'a Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, exp: $F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                    
                    impl<'a, 'b, T: Float> Pow<&'b $F> for &'a Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, &exp: &$F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                    
                    impl<T: Float> Pow<$F> for Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, exp: $F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                    
                    impl<'b, T: Float> Pow<&'b $F> for Complex<T>
                    where
                        $F: Into<T>,
                    {
                        type Output = Complex<T>;

                        #[inline] fn pow(self, &exp: &$F) -> Self::Output {
                            self.powf(exp.into())
                        }
                    }
                };
            }

            powf_impl!(f32);
            powf_impl!(f64);
            
            impl<'a, T: Float> Pow<Complex<T>> for &'a Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, exp: Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }

            
            impl<'a, 'b, T: Float> Pow<&'b Complex<T>> for &'a Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, &exp: &'b Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }

            
            impl<T: Float> Pow<Complex<T>> for Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, exp: Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }

            
            impl<'b, T: Float> Pow<&'b Complex<T>> for Complex<T> {
                type Output = Complex<T>;

                #[inline] fn pow(self, &exp: &'b Complex<T>) -> Self::Output {
                    self.powc(exp)
                }
            }
        }

        pub mod complex_float
        {
            use ::
            {
                num::traits::{ Float, FloatConst, Num, NumCast },
                ops::Neg,
                *,
            }; use super::Complex;
            
            mod private
            {
                use ::num::traits::{Float, FloatConst};

                use super::super::Complex;

                pub trait Seal {}

                impl<T> Seal for T where T: Float + FloatConst {}
                impl<T: Float + FloatConst> Seal for Complex<T> {}
            }
            /// Generic trait for floating point complex numbers.
            pub trait ComplexFloat: Num + NumCast + Copy + Neg<Output = Self> + private::Seal 
            {
                /// The type used to represent the real coefficients of this complex number.
                type Real: Float + FloatConst;
                /// Returns `true` if this value is `NaN` and false otherwise.
                fn is_nan(self) -> bool;
                /// Returns `true` if this value is positive infinity or negative infinity and false otherwise.
                fn is_infinite(self) -> bool;
                /// Returns `true` if this number is neither infinite nor `NaN`.
                fn is_finite(self) -> bool;
                /// Returns `true` if the number is neither zero, infinite, or `NaN`.
                fn is_normal(self) -> bool;
                /// Take the reciprocal (inverse) of a number, `1/x`. See also [Complex::finv].
                fn recip(self) -> Self;
                /// Raises `self` to a signed integer power.
                fn powi(self, exp: i32) -> Self;
                /// Raises `self` to a real power.
                fn powf(self, exp: Self::Real) -> Self;
                /// Raises `self` to a complex power.
                fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
                /// Take the square root of a number.
                fn sqrt(self) -> Self;
                /// Returns `e^(self)`, (the exponential function).
                fn exp(self) -> Self;
                /// Returns `2^(self)`.
                fn exp2(self) -> Self;
                /// Returns `base^(self)`.
                fn expf(self, base: Self::Real) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln(self) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log(self, base: Self::Real) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2(self) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10(self) -> Self;
                /// Take the cubic root of a number.
                fn cbrt(self) -> Self;
                /// Computes the sine of a number (in radians).
                fn sin(self) -> Self;
                /// Computes the cosine of a number (in radians).
                fn cos(self) -> Self;
                /// Computes the tangent of a number (in radians).
                fn tan(self) -> Self;
                /// Computes the arcsine of a number.
                fn asin(self) -> Self;
                /// Computes the arccosine of a number.
                fn acos(self) -> Self;
                /// Computes the arctangent of a number.
                fn atan(self) -> Self;
                /// Hyperbolic sine function.
                fn sinh(self) -> Self;
                /// Hyperbolic cosine function.
                fn cosh(self) -> Self;
                /// Hyperbolic tangent function.
                fn tanh(self) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh(self) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh(self) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh(self) -> Self;
                /// Returns the real part of the number.
                fn re(self) -> Self::Real;
                /// Returns the imaginary part of the number.
                fn im(self) -> Self::Real;
                /// Returns the absolute value of the number. See also [Complex::norm]
                fn abs(self) -> Self::Real;
                /// Returns the L1 norm `|re| + |im|` -- the [Manhattan distance] from the origin.
                fn l1_norm(&self) -> Self::Real;
                /// Computes the argument of the number.
                fn arg(self) -> Self::Real;
                /// Computes the complex conjugate of the number.
                fn conj(self) -> Self;
            }

            macro_rules! forward 
            {
                ($( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            $base::$method(self $( , $arg )* )
                        }
                    )*};
            }

            macro_rules! forward_ref 
            {
                ($( Self :: $method:ident ( & self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            Self::$method(&self $( , $arg )* )
                        }
                    )*};
            }

            impl<T> ComplexFloat for T where
            T: Float + FloatConst
            {
                type Real = T;

                fn re(self) -> Self::Real {
                    self
                }

                fn im(self) -> Self::Real {
                    T::zero()
                }

                fn l1_norm(&self) -> Self::Real {
                    self.abs()
                }

                fn arg(self) -> Self::Real {
                    if self.is_nan() {
                        self
                    } else if self.is_sign_negative() {
                        T::PI()
                    } else {
                        T::zero()
                    }
                }

                fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real> {
                    Complex::new(self, T::zero()).powc(exp)
                }

                fn conj(self) -> Self {
                    self
                }

                fn expf(self, base: Self::Real) -> Self {
                    base.powf(self)
                }

                forward! {
                    Float::is_normal(self) -> bool;
                    Float::is_infinite(self) -> bool;
                    Float::is_finite(self) -> bool;
                    Float::is_nan(self) -> bool;
                    Float::recip(self) -> Self;
                    Float::powi(self, n: i32) -> Self;
                    Float::powf(self, f: Self) -> Self;
                    Float::sqrt(self) -> Self;
                    Float::cbrt(self) -> Self;
                    Float::exp(self) -> Self;
                    Float::exp2(self) -> Self;
                    Float::ln(self) -> Self;
                    Float::log(self, base: Self) -> Self;
                    Float::log2(self) -> Self;
                    Float::log10(self) -> Self;
                    Float::sin(self) -> Self;
                    Float::cos(self) -> Self;
                    Float::tan(self) -> Self;
                    Float::asin(self) -> Self;
                    Float::acos(self) -> Self;
                    Float::atan(self) -> Self;
                    Float::sinh(self) -> Self;
                    Float::cosh(self) -> Self;
                    Float::tanh(self) -> Self;
                    Float::asinh(self) -> Self;
                    Float::acosh(self) -> Self;
                    Float::atanh(self) -> Self;
                    Float::abs(self) -> Self;
                }
            }

            impl<T: Float + FloatConst> ComplexFloat for Complex<T> 
            {
                type Real = T;

                fn re(self) -> Self::Real 
                {
                    self.re
                }

                fn im(self) -> Self::Real 
                {
                    self.im
                }

                fn abs(self) -> Self::Real 
                {
                    self.norm()
                }

                fn recip(self) -> Self 
                {
                    self.finv()
                }
                
                fn l1_norm(&self) -> Self::Real 
                {
                    self.re.abs() + self.im.abs()
                }
                
                fn is_nan(self) -> bool 
                {
                    self.re.is_nan() || self.im.is_nan()
                }

                fn is_infinite(self) -> bool 
                {
                    !self.is_nan() && (self.re.is_infinite() || self.im.is_infinite())
                }

                fn is_finite(self) -> bool 
                {
                    self.re.is_finite() && self.im.is_finite()
                }

                fn is_normal(self) -> bool 
                {
                    self.re.is_normal() && self.im.is_normal()
                }

                forward! 
                {
                    Complex::arg(self) -> Self::Real;
                    Complex::powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
                    Complex::exp2(self) -> Self;
                    Complex::log(self, base: Self::Real) -> Self;
                    Complex::log2(self) -> Self;
                    Complex::log10(self) -> Self;
                    Complex::powf(self, f: Self::Real) -> Self;
                    Complex::sqrt(self) -> Self;
                    Complex::cbrt(self) -> Self;
                    Complex::exp(self) -> Self;
                    Complex::expf(self, base: Self::Real) -> Self;
                    Complex::ln(self) -> Self;
                    Complex::sin(self) -> Self;
                    Complex::cos(self) -> Self;
                    Complex::tan(self) -> Self;
                    Complex::asin(self) -> Self;
                    Complex::acos(self) -> Self;
                    Complex::atan(self) -> Self;
                    Complex::sinh(self) -> Self;
                    Complex::cosh(self) -> Self;
                    Complex::tanh(self) -> Self;
                    Complex::asinh(self) -> Self;
                    Complex::acosh(self) -> Self;
                    Complex::atanh(self) -> Self;
                }

                forward_ref! 
                {
                    Self::powi(&self, n: i32) -> Self;
                    Self::conj(&self) -> Self;
                }
            }

        } pub use self::complex_float::ComplexFloat;

        pub mod crand
        {
            //! Rand implementations for complex numbers
            use ::
            {
                num::traits::{ Num },
                rand::{ distributions::Standard, prelude::* },
                *,
            }; use super::Complex;

            impl<T> Distribution<Complex<T>> for Standard
            where
                T: Num + Clone,
                Standard: Distribution<T>,
            {
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Complex<T> {
                    Complex::new(self.sample(rng), self.sample(rng))
                }
            }
            /// A generic random value distribution for complex numbers.
            #[derive(Clone, Copy, Debug)]
            pub struct ComplexDistribution<Re, Im = Re> {
                re: Re,
                im: Im,
            }

            impl<Re, Im> ComplexDistribution<Re, Im> {
                /// Creates a complex distribution from independent
                /// distributions of the real and imaginary parts.
                pub fn new(re: Re, im: Im) -> Self {
                    ComplexDistribution { re, im }
                }
            }

            impl<T, Re, Im> Distribution<Complex<T>> for ComplexDistribution<Re, Im>
            where
                T: Num + Clone,
                Re: Distribution<T>,
                Im: Distribution<T>,
            {
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Complex<T> {
                    Complex::new(self.re.sample(rng), self.im.sample(rng))
                }
            }

        } pub use self::crand::ComplexDistribution;
        /// A complex number in Cartesian form.
        #[repr( C )] #[derive( PartialEq, Eq, Copy, Clone, Hash, Debug, Default )]
        pub struct Complex<T> 
        {
            /// Real portion of the complex number
            pub re: T,
            /// Imaginary portion of the complex number
            pub im: T,
        }
        /// Alias for a [`Complex<f32>`]
        pub type Complex32 = Complex<f32>;
        /// Create a new [`Complex<f32>`] with arguments that can convert [`Into<f32>`].
        #[inline] pub fn c32<T: Into<f32>>(re: T, im: T) -> Complex32 
        {
            Complex::new(re.into(), im.into())
        }
        /// Alias for a [`Complex<f64>`]
        pub type Complex64 = Complex<f64>;
        /// Create a new [`Complex<f64>`] with arguments that can convert [`Into<f64>`].
        #[inline] pub fn c64<T: Into<f64>>(re: T, im: T) -> Complex64 
        {
            Complex::new(re.into(), im.into())
        }

        impl<T> Complex<T> 
        {
            /// Create a new `Complex`
            #[inline] pub const fn new(re: T, im: T) -> Self 
            {
                Complex { re, im }
            }
        }

        impl<T: Clone + Num> Complex<T> 
        {
            /// Returns the imaginary unit.
            #[inline] pub fn i() -> Self 
            {
                Self::new(T::zero(), T::one())
            }
            /// Returns the square of the norm, i.e. `re^2 + im^2`.
            #[inline] pub fn norm_sqr(&self) -> T 
            {
                self.re.clone() * self.re.clone() + self.im.clone() * self.im.clone()
            }
            /// Multiplies `self` by the scalar `t`.
            #[inline] pub fn scale(&self, t: T) -> Self 
            {
                Self::new(self.re.clone() * t.clone(), self.im.clone() * t)
            }
            /// Divides `self` by the scalar `t`.
            #[inline] pub fn unscale(&self, t: T) -> Self 
            {
                Self::new(self.re.clone() / t.clone(), self.im.clone() / t)
            }
            /// Raises `self` to an unsigned integer power.
            #[inline] pub fn powu(&self, exp: u32) -> Self 
            {
                Pow::pow(self, exp)
            }
        }

        impl<T: Clone + Num + Neg<Output = T>> Complex<T> 
        {
            /// Returns the complex conjugate. i.e. `re - i im`
            #[inline] pub fn conj(&self) -> Self 
            {
                Self::new(self.re.clone(), -self.im.clone())
            }
            /// Returns `1/self`
            #[inline] pub fn inv(&self) -> Self 
            {
                let norm_sqr = self.norm_sqr();
                Self::new(
                    self.re.clone() / norm_sqr.clone(),
                    -self.im.clone() / norm_sqr,
                )
            }
            /// Raises `self` to a signed integer power.
            #[inline] pub fn powi(&self, exp: i32) -> Self 
            {
                Pow::pow(self, exp)
            }
        }

        impl<T: Clone + Signed> Complex<T> 
        {
            /// Returns the L1 norm `|re| + |im|` -- the [Manhattan distance] from the origin.
            #[inline] pub fn l1_norm(&self) -> T 
            {
                self.re.abs() + self.im.abs()
            }
        }
        
        impl<T: Float> Complex<T> 
        {
            /// Create a new Complex with a given phase: `exp(i * phase)`.
            #[inline] pub fn cis(phase: T) -> Self 
            {
                Self::new(phase.cos(), phase.sin())
            }
            /// Calculate |self|
            #[inline] pub fn norm(self) -> T 
            {
                self.re.hypot(self.im)
            }
            /// Calculate the principal Arg of self.
            #[inline] pub fn arg(self) -> T 
            {
                self.im.atan2(self.re)
            }
            /// Convert to polar form (r, theta), such that
            /// `self = r * exp(i * theta)`
            #[inline] pub fn to_polar(self) -> (T, T) 
            {
                (self.norm(), self.arg())
            }
            /// Convert a polar representation into a complex number.
            #[inline] pub fn from_polar(r: T, theta: T) -> Self 
            {
                Self::new(r * theta.cos(), r * theta.sin())
            }
            /// Computes `e^(self)`, where `e` is the base of the natural logarithm.
            #[inline] pub fn exp(self) -> Self 
            {
                let Complex { re, mut im } = self;
                if re.is_infinite() {
                    if re < T::zero() {
                        if !im.is_finite() {
                            return Self::new(T::zero(), T::zero());
                        }
                    } else if im == T::zero() || !im.is_finite() {
                        if im.is_infinite() {
                            im = T::nan();
                        }
                        return Self::new(re, im);
                    }
                } else if re.is_nan() && im == T::zero() {
                    return self;
                }

                Self::from_polar(re.exp(), im)
            }
            /// Computes the principal value of natural logarithm of `self`.
            #[inline] pub fn ln(self) -> Self 
            {
                let (r, theta) = self.to_polar();
                Self::new(r.ln(), theta)
            }
            /// Computes the principal value of the square root of `self`.
            #[inline] pub fn sqrt(self) -> Self 
            {
                if self.im.is_zero() {
                    if self.re.is_sign_positive() {
                        Self::new(self.re.sqrt(), self.im)
                    } else {
                        let re = T::zero();
                        let im = (-self.re).sqrt();
                        if self.im.is_sign_positive() {
                            Self::new(re, im)
                        } else {
                            Self::new(re, -im)
                        }
                    }
                } else if self.re.is_zero() {
                    let one = T::one();
                    let two = one + one;
                    let x = (self.im.abs() / two).sqrt();
                    if self.im.is_sign_positive() {
                        Self::new(x, x)
                    } else {
                        Self::new(x, -x)
                    }
                } else {
                    let one = T::one();
                    let two = one + one;
                    let (r, theta) = self.to_polar();
                    Self::from_polar(r.sqrt(), theta / two)
                }
            }
            /// Computes the principal value of the cube root of `self`.
            #[inline] pub fn cbrt(self) -> Self 
            {
                if self.im.is_zero() {
                    if self.re.is_sign_positive() {
                        Self::new(self.re.cbrt(), self.im)
                    } else {
                        let one = T::one();
                        let two = one + one;
                        let three = two + one;
                        let re = (-self.re).cbrt() / two;
                        let im = three.sqrt() * re;
                        if self.im.is_sign_positive() {
                            Self::new(re, im)
                        } else {
                            Self::new(re, -im)
                        }
                    }
                } else if self.re.is_zero() {
                    let one = T::one();
                    let two = one + one;
                    let three = two + one;
                    let im = self.im.abs().cbrt() / two;
                    let re = three.sqrt() * im;
                    if self.im.is_sign_positive() {
                        Self::new(re, im)
                    } else {
                        Self::new(re, -im)
                    }
                } else {
                    let one = T::one();
                    let three = one + one + one;
                    let (r, theta) = self.to_polar();
                    Self::from_polar(r.cbrt(), theta / three)
                }
            }
            /// Raises `self` to a floating point power.
            #[inline] pub fn powf(self, exp: T) -> Self 
            {
                if exp.is_zero() {
                    return Self::one();
                }
                
                let (r, theta) = self.to_polar();
                Self::from_polar(r.powf(exp), theta * exp)
            }
            /// Returns the logarithm of `self` with respect to an arbitrary base.
            #[inline] pub fn log(self, base: T) -> Self 
            {
                let (r, theta) = self.to_polar();
                Self::new(r.log(base), theta / base.ln())
            }
            /// Raises `self` to a complex power.
            #[inline] pub fn powc(self, exp: Self) -> Self 
            {
                if exp.is_zero() {
                    return Self::one();
                }
                
                (exp * self.ln()).exp()
            }
            /// Raises a floating point number to the complex power `self`.
            #[inline] pub fn expf(self, base: T) -> Self 
            {
                Self::from_polar(base.powf(self.re), self.im * base.ln())
            }
            /// Computes the sine of `self`.
            #[inline] pub fn sin(self) -> Self 
            {
                Self::new(
                    self.re.sin() * self.im.cosh(),
                    self.re.cos() * self.im.sinh(),
                )
            }
            /// Computes the cosine of `self`.
            #[inline] pub fn cos(self) -> Self 
            {
                Self::new(
                    self.re.cos() * self.im.cosh(),
                    -self.re.sin() * self.im.sinh(),
                )
            }
            /// Computes the tangent of `self`.
            #[inline] pub fn tan(self) -> Self 
            {
                let (two_re, two_im) = (self.re + self.re, self.im + self.im);
                Self::new(two_re.sin(), two_im.sinh()).unscale(two_re.cos() + two_im.cosh())
            }
            /// Computes the principal value of the inverse sine of `self`.
            #[inline] pub fn asin(self) -> Self 
            {
                let i = Self::i();
                -i * ((Self::one() - self * self).sqrt() + i * self).ln()
            }
            /// Computes the principal value of the inverse cosine of `self`.
            #[inline] pub fn acos(self) -> Self 
            {
                let i = Self::i();
                -i * (i * (Self::one() - self * self).sqrt() + self).ln()
            }
            /// Computes the principal value of the inverse tangent of `self`.
            #[inline] pub fn atan(self) -> Self 
            {
               
                let i = Self::i();
                let one = Self::one();
                let two = one + one;
                if self == i {
                    return Self::new(T::zero(), T::infinity());
                } else if self == -i {
                    return Self::new(T::zero(), -T::infinity());
                }
                ((one + i * self).ln() - (one - i * self).ln()) / (two * i)
            }
            /// Computes the hyperbolic sine of `self`.
            #[inline] pub fn sinh(self) -> Self 
            {
               
                Self::new(
                    self.re.sinh() * self.im.cos(),
                    self.re.cosh() * self.im.sin(),
                )
            }
            /// Computes the hyperbolic cosine of `self`.
            #[inline] pub fn cosh(self) -> Self 
            {
               
                Self::new(
                    self.re.cosh() * self.im.cos(),
                    self.re.sinh() * self.im.sin(),
                )
            }
            /// Computes the hyperbolic tangent of `self`.
            #[inline] pub fn tanh(self) -> Self 
            {
               
                let (two_re, two_im) = (self.re + self.re, self.im + self.im);
                Self::new(two_re.sinh(), two_im.sin()).unscale(two_re.cosh() + two_im.cos())
            }
            /// Computes the principal value of inverse hyperbolic sine of `self`.
            #[inline] pub fn asinh(self) -> Self 
            {
               
                let one = Self::one();
                (self + (one + self * self).sqrt()).ln()
            }
            /// Computes the principal value of inverse hyperbolic cosine of `self`.
            #[inline] pub fn acosh(self) -> Self 
            {
               
                let one = Self::one();
                let two = one + one;
                two * (((self + one) / two).sqrt() + ((self - one) / two).sqrt()).ln()
            }
            /// Computes the principal value of inverse hyperbolic tangent of `self`.
            #[inline] pub fn atanh(self) -> Self 
            {
               
                let one = Self::one();
                let two = one + one;
                if self == one {
                    return Self::new(T::infinity(), T::zero());
                } else if self == -one {
                    return Self::new(-T::infinity(), T::zero());
                }
                ((one + self).ln() - (one - self).ln()) / two
            }
            /// Returns `1/self` using floating-point operations.
            #[inline] pub fn finv(self) -> Complex<T> 
            {
                let norm = self.norm();
                self.conj() / norm / norm
            }
            /// Returns `self/other` using floating-point operations.
            #[inline] pub fn fdiv(self, other: Complex<T>) -> Complex<T> 
            {
                self * other.finv()
            }
        }
        
        impl<T: Float + FloatConst> Complex<T> 
        {
            /// Computes `2^(self)`.
            #[inline] pub fn exp2(self) -> Self 
            {
                Self::from_polar(self.re.exp2(), self.im * T::LN_2())
            }
            /// Computes the principal value of log base 2 of `self`.
            #[inline] pub fn log2(self) -> Self 
            {
                Self::ln(self) / T::LN_2()
            }
            /// Computes the principal value of log base 10 of `self`.
            #[inline] pub fn log10(self) -> Self 
            {
                Self::ln(self) / T::LN_10()
            }
        }

        impl<T: FloatCore> Complex<T> 
        {
            /// Checks if the given complex number is NaN
            #[inline] pub fn is_nan(self) -> bool {
                self.re.is_nan() || self.im.is_nan()
            }
            /// Checks if the given complex number is infinite
            #[inline] pub fn is_infinite(self) -> bool {
                !self.is_nan() && (self.re.is_infinite() || self.im.is_infinite())
            }
            /// Checks if the given complex number is finite
            #[inline] pub fn is_finite(self) -> bool {
                self.re.is_finite() && self.im.is_finite()
            }
            /// Checks if the given complex number is normal
            #[inline] pub fn is_normal(self) -> bool {
                self.re.is_normal() && self.im.is_normal()
            }
        }

        impl<T: Clone + Num> From<T> for Complex<T> 
        {
            #[inline] fn from(re: T) -> Self {
                Self::new(re, T::zero())
            }
        }

        impl<'a, T: Clone + Num> From<&'a T> for Complex<T> 
        {
            #[inline] fn from(re: &T) -> Self {
                From::from(re.clone())
            }
        }

        macro_rules! forward_ref_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, 'b, T: Clone + Num> $imp<&'b Complex<T>> for &'a Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &Complex<T>) -> Self::Output {
                        self.clone().$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_ref_val_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T: Clone + Num> $imp<Complex<T>> for &'a Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: Complex<T>) -> Self::Output {
                        self.clone().$method(other)
                    }
                }
            };
        }

        macro_rules! forward_val_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T: Clone + Num> $imp<&'a Complex<T>> for Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &Complex<T>) -> Self::Output {
                        self.$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_all_binop 
        {
            (impl $imp:ident, $method:ident) => {
                forward_ref_ref_binop!(impl $imp, $method);
                forward_ref_val_binop!(impl $imp, $method);
                forward_val_ref_binop!(impl $imp, $method);
            };
        }

        forward_all_binop!(impl Add, add);
        
        impl<T: Clone + Num> Add<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn add(self, other: Self) -> Self::Output {
                Self::Output::new(self.re + other.re, self.im + other.im)
            }
        }

        forward_all_binop!(impl Sub, sub);
        
        impl<T: Clone + Num> Sub<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn sub(self, other: Self) -> Self::Output {
                Self::Output::new(self.re - other.re, self.im - other.im)
            }
        }

        forward_all_binop!(impl Mul, mul);
        
        impl<T: Clone + Num> Mul<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn mul(self, other: Self) -> Self::Output {
                let re = self.re.clone() * other.re.clone() - self.im.clone() * other.im.clone();
                let im = self.re * other.im + self.im * other.re;
                Self::Output::new(re, im)
            }
        }
        
        impl<T: Clone + Num + MulAdd<Output = T>> MulAdd<Complex<T>> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn mul_add(self, other: Complex<T>, add: Complex<T>) -> Complex<T>
            {
                let re = self.re.clone().mul_add(other.re.clone(), add.re)
                    - (self.im.clone() * other.im.clone());
                let im = self.re.mul_add(other.im, self.im.mul_add(other.re, add.im));
                Complex::new(re, im)
            }
        }

        impl<'a, 'b, T: Clone + Num + MulAdd<Output = T>> MulAdd<&'b Complex<T>> for &'a Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn mul_add(self, other: &Complex<T>, add: &Complex<T>) -> Complex<T> 
            {
                self.clone().mul_add(other.clone(), add.clone())
            }
        }

        forward_all_binop!(impl Div, div);
        
        impl<T: Clone + Num> Div<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn div(self, other: Self) -> Self::Output {
                let norm_sqr = other.norm_sqr();
                let re = self.re.clone() * other.re.clone() + self.im.clone() * other.im.clone();
                let im = self.im * other.re - self.re * other.im;
                Self::Output::new(re / norm_sqr.clone(), im / norm_sqr)
            }
        }

        forward_all_binop!(impl Rem, rem);

        impl<T: Clone + Num> Complex<T> 
        {
            /// Find the gaussian integer corresponding to the true ratio rounded towards zero.
            fn div_trunc(&self, divisor: &Self) -> Self {
                let Complex { re, im } = self / divisor;
                Complex::new(re.clone() - re % T::one(), im.clone() - im % T::one())
            }
        }

        impl<T: Clone + Num> Rem<Complex<T>> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn rem(self, modulus: Self) -> Self::Output {
                let gaussian = self.div_trunc(&modulus);
                self - modulus * gaussian
            }
        }
        
        mod opassign 
        {
            use ::
            {
                num::traits::{ MulAddAssign, NumAssign },
                ops::{ AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
                *,
            }; use super::Complex;

            impl<T: Clone + NumAssign> AddAssign for Complex<T> 
            {
                fn add_assign(&mut self, other: Self) {
                    self.re += other.re;
                    self.im += other.im;
                }
            }

            impl<T: Clone + NumAssign> SubAssign for Complex<T> 
            {
                fn sub_assign(&mut self, other: Self) {
                    self.re -= other.re;
                    self.im -= other.im;
                }
            }

           
            impl<T: Clone + NumAssign> MulAssign for Complex<T> 
            {
                fn mul_assign(&mut self, other: Self) {
                    let a = self.re.clone();

                    self.re *= other.re.clone();
                    self.re -= self.im.clone() * other.im.clone();

                    self.im *= other.re;
                    self.im += a * other.im;
                }
            }

           
            impl<T: Clone + NumAssign + MulAddAssign> MulAddAssign for Complex<T> 
            {
                fn mul_add_assign(&mut self, other: Complex<T>, add: Complex<T>) {
                    let a = self.re.clone();

                    self.re.mul_add_assign(other.re.clone(), add.re);
                    self.re -= self.im.clone() * other.im.clone();

                    let mut adf = a;
                    adf.mul_add_assign(other.im, add.im);
                    self.im.mul_add_assign(other.re, adf);
                }
            }

            impl<'a, 'b, T: Clone + NumAssign + MulAddAssign> MulAddAssign<&'a Complex<T>, &'b Complex<T>>
                for Complex<T>
            {
                fn mul_add_assign(&mut self, other: &Complex<T>, add: &Complex<T>) {
                    self.mul_add_assign(other.clone(), add.clone());
                }
            }
            
            impl<T: Clone + NumAssign> DivAssign for Complex<T> 
            {
                fn div_assign(&mut self, other: Self) {
                    let a = self.re.clone();
                    let norm_sqr = other.norm_sqr();

                    self.re *= other.re.clone();
                    self.re += self.im.clone() * other.im.clone();
                    self.re /= norm_sqr.clone();

                    self.im *= other.re;
                    self.im -= a * other.im;
                    self.im /= norm_sqr;
                }
            }

            impl<T: Clone + NumAssign> RemAssign for Complex<T> 
            {
                fn rem_assign(&mut self, modulus: Self) {
                    let gaussian = self.div_trunc(&modulus);
                    *self -= modulus * gaussian;
                }
            }

            impl<T: Clone + NumAssign> AddAssign<T> for Complex<T> 
            {
                fn add_assign(&mut self, other: T) {
                    self.re += other;
                }
            }

            impl<T: Clone + NumAssign> SubAssign<T> for Complex<T> 
            {
                fn sub_assign(&mut self, other: T) {
                    self.re -= other;
                }
            }

            impl<T: Clone + NumAssign> MulAssign<T> for Complex<T> 
            {
                fn mul_assign(&mut self, other: T) {
                    self.re *= other.clone();
                    self.im *= other;
                }
            }

            impl<T: Clone + NumAssign> DivAssign<T> for Complex<T> 
            {
                fn div_assign(&mut self, other: T) {
                    self.re /= other.clone();
                    self.im /= other;
                }
            }

            impl<T: Clone + NumAssign> RemAssign<T> for Complex<T> 
            {
                fn rem_assign(&mut self, other: T) {
                    self.re %= other.clone();
                    self.im %= other;
                }
            }

            macro_rules! forward_op_assign 
            {
                (impl $imp:ident, $method:ident) => {
                    impl<'a, T: Clone + NumAssign> $imp<&'a Complex<T>> for Complex<T> {
                        #[inline] fn $method(&mut self, other: &Self) {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a, T: Clone + NumAssign> $imp<&'a T> for Complex<T> {
                        #[inline] fn $method(&mut self, other: &T) {
                            self.$method(other.clone())
                        }
                    }
                };
            }

            forward_op_assign!(impl AddAssign, add_assign);
            forward_op_assign!(impl SubAssign, sub_assign);
            forward_op_assign!(impl MulAssign, mul_assign);
            forward_op_assign!(impl DivAssign, div_assign);
            forward_op_assign!(impl RemAssign, rem_assign);
        }

        impl<T: Clone + Num + Neg<Output = T>> Neg for Complex<T> 
        {
            type Output = Self;

            #[inline] fn neg(self) -> Self::Output {
                Self::Output::new(-self.re, -self.im)
            }
        }

        impl<'a, T: Clone + Num + Neg<Output = T>> Neg for &'a Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn neg(self) -> Self::Output {
                -self.clone()
            }
        }

        impl<T: Clone + Num + Neg<Output = T>> Inv for Complex<T> 
        {
            type Output = Self;

            #[inline] fn inv(self) -> Self::Output {
                Complex::inv(&self)
            }
        }

        impl<'a, T: Clone + Num + Neg<Output = T>> Inv for &'a Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn inv(self) -> Self::Output {
                Complex::inv(self)
            }
        }

        macro_rules! real_arithmetic 
        {
            (@forward $imp:ident::$method:ident for $($real:ident),*) => (
                impl<'a, T: Clone + Num> $imp<&'a T> for Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &T) -> Self::Output {
                        self.$method(other.clone())
                    }
                }
                impl<'a, T: Clone + Num> $imp<T> for &'a Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: T) -> Self::Output {
                        self.clone().$method(other)
                    }
                }
                impl<'a, 'b, T: Clone + Num> $imp<&'a T> for &'b Complex<T> {
                    type Output = Complex<T>;

                    #[inline] fn $method(self, other: &T) -> Self::Output {
                        self.clone().$method(other.clone())
                    }
                }
                $(
                    impl<'a> $imp<&'a Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline] fn $method(self, other: &Complex<$real>) -> Complex<$real> {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a> $imp<Complex<$real>> for &'a $real {
                        type Output = Complex<$real>;

                        #[inline] fn $method(self, other: Complex<$real>) -> Complex<$real> {
                            self.clone().$method(other)
                        }
                    }
                    impl<'a, 'b> $imp<&'a Complex<$real>> for &'b $real {
                        type Output = Complex<$real>;

                        #[inline] fn $method(self, other: &Complex<$real>) -> Complex<$real> {
                            self.clone().$method(other.clone())
                        }
                    }
                )*
            );
            ($($real:ident),*) => (
                real_arithmetic!(@forward Add::add for $($real),*);
                real_arithmetic!(@forward Sub::sub for $($real),*);
                real_arithmetic!(@forward Mul::mul for $($real),*);
                real_arithmetic!(@forward Div::div for $($real),*);
                real_arithmetic!(@forward Rem::rem for $($real),*);

                $(
                    impl Add<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline] fn add(self, other: Complex<$real>) -> Self::Output {
                            Self::Output::new(self + other.re, other.im)
                        }
                    }

                    impl Sub<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline] fn sub(self, other: Complex<$real>) -> Self::Output  {
                            Self::Output::new(self - other.re, $real::zero() - other.im)
                        }
                    }

                    impl Mul<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline] fn mul(self, other: Complex<$real>) -> Self::Output {
                            Self::Output::new(self * other.re, self * other.im)
                        }
                    }

                    impl Div<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline] fn div(self, other: Complex<$real>) -> Self::Output {
                            let norm_sqr = other.norm_sqr();
                            Self::Output::new(self * other.re / norm_sqr.clone(),
                                            $real::zero() - self * other.im / norm_sqr)
                        }
                    }

                    impl Rem<Complex<$real>> for $real {
                        type Output = Complex<$real>;

                        #[inline] fn rem(self, other: Complex<$real>) -> Self::Output {
                            Self::Output::new(self, Self::zero()) % other
                        }
                    }
                )*
            );
        }

        impl<T: Clone + Num> Add<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn add(self, other: T) -> Self::Output {
                Self::Output::new(self.re + other, self.im)
            }
        }

        impl<T: Clone + Num> Sub<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn sub(self, other: T) -> Self::Output {
                Self::Output::new(self.re - other, self.im)
            }
        }

        impl<T: Clone + Num> Mul<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn mul(self, other: T) -> Self::Output {
                Self::Output::new(self.re * other.clone(), self.im * other)
            }
        }

        impl<T: Clone + Num> Div<T> for Complex<T> 
        {
            type Output = Self;

            #[inline] fn div(self, other: T) -> Self::Output {
                Self::Output::new(self.re / other.clone(), self.im / other)
            }
        }

        impl<T: Clone + Num> Rem<T> for Complex<T> 
        {
            type Output = Complex<T>;

            #[inline] fn rem(self, other: T) -> Self::Output {
                Self::Output::new(self.re % other.clone(), self.im % other)
            }
        }

        real_arithmetic!(usize, u8, u16, u32, u64, u128, isize, i8, i16, i32, i64, i128, f32, f64);
        
        impl<T: ConstZero> Complex<T> 
        {
            /// A constant `Complex` 0.
            pub const ZERO: Self = Self::new(T::ZERO, T::ZERO);
        }

        impl<T: Clone + Num + ConstZero> ConstZero for Complex<T> 
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Num> Zero for Complex<T> 
        {
            #[inline] fn zero() -> Self {
                Self::new(Zero::zero(), Zero::zero())
            }

            #[inline] fn is_zero(&self) -> bool {
                self.re.is_zero() && self.im.is_zero()
            }

            #[inline] fn set_zero(&mut self) {
                self.re.set_zero();
                self.im.set_zero();
            }
        }

        impl<T: ConstOne + ConstZero> Complex<T> 
        {
            /// A constant `Complex` 1.
            pub const ONE: Self = Self::new(T::ONE, T::ZERO);
            /// A constant `Complex` _i_, the imaginary unit.
            pub const I: Self = Self::new(T::ZERO, T::ONE);
        }

        impl<T: Clone + Num + ConstOne + ConstZero> ConstOne for Complex<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Num> One for Complex<T> 
        {
            #[inline] fn one() -> Self {
                Self::new(One::one(), Zero::zero())
            }

            #[inline] fn is_one(&self) -> bool {
                self.re.is_one() && self.im.is_zero()
            }

            #[inline] fn set_one(&mut self) {
                self.re.set_one();
                self.im.set_zero();
            }
        }

        macro_rules! write_complex 
        {
            ($f:ident, $t:expr, $prefix:expr, $re:expr, $im:expr, $T:ident) => {{
                let abs_re = if $re < Zero::zero() {
                    $T::zero() - $re.clone()
                } else {
                    $re.clone()
                };
                let abs_im = if $im < Zero::zero() {
                    $T::zero() - $im.clone()
                } else {
                    $im.clone()
                };

                return if let Some(prec) = $f.precision() {
                    fmt_re_im(
                        $f,
                        $re < $T::zero(),
                        $im < $T::zero(),
                        format_args!(concat!("{:.1$", $t, "}"), abs_re, prec),
                        format_args!(concat!("{:.1$", $t, "}"), abs_im, prec),
                    )
                } else {
                    fmt_re_im(
                        $f,
                        $re < $T::zero(),
                        $im < $T::zero(),
                        format_args!(concat!("{:", $t, "}"), abs_re),
                        format_args!(concat!("{:", $t, "}"), abs_im),
                    )
                };

                fn fmt_re_im(
                    f: &mut fmt::Formatter<'_>,
                    re_neg: bool,
                    im_neg: bool,
                    real: fmt::Arguments<'_>,
                    imag: fmt::Arguments<'_>,
                ) -> fmt::Result {
                    let prefix = if f.alternate() { $prefix } else { "" };
                    let sign = if re_neg {
                        "-"
                    } else if f.sign_plus() {
                        "+"
                    } else {
                        ""
                    };

                    if im_neg {
                        fmt_complex(
                            f,
                            format_args!(
                                "{}{pre}{re}-{pre}{im}i",
                                sign,
                                re = real,
                                im = imag,
                                pre = prefix
                            ),
                        )
                    } else {
                        fmt_complex(
                            f,
                            format_args!(
                                "{}{pre}{re}+{pre}{im}i",
                                sign,
                                re = real,
                                im = imag,
                                pre = prefix
                            ),
                        )
                    }
                }
                
                fn fmt_complex(f: &mut fmt::Formatter<'_>, complex: fmt::Arguments<'_>) -> fmt::Result {
                    use std::string::ToString;
                    if let Some(width) = f.width() {
                        write!(f, "{0: >1$}", complex.to_string(), width)
                    } else {
                        write!(f, "{}", complex)
                    }
                }
            }};
        }
        
        impl<T> fmt::Display for Complex<T> where
        T: fmt::Display + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "", "", self.re, self.im, T)
            }
        }

        impl<T> fmt::LowerExp for Complex<T> where
            T: fmt::LowerExp + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "e", "", self.re, self.im, T)
            }
        }

        impl<T> fmt::UpperExp for Complex<T> where
            T: fmt::UpperExp + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "E", "", self.re, self.im, T)
            }
        }

        impl<T> fmt::LowerHex for Complex<T> where
            T: fmt::LowerHex + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "x", "0x", self.re, self.im, T)
            }
        }

        impl<T> fmt::UpperHex for Complex<T> where
            T: fmt::UpperHex + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "X", "0x", self.re, self.im, T)
            }
        }

        impl<T> fmt::Octal for Complex<T> where
            T: fmt::Octal + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "o", "0o", self.re, self.im, T)
            }
        }

        impl<T> fmt::Binary for Complex<T> where
            T: fmt::Binary + Num + PartialOrd + Clone,
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write_complex!(f, "b", "0b", self.re, self.im, T)
            }
        }

        fn from_str_generic<T, E, F>(s: &str, from: F) -> Result<Complex<T>, ParseComplexError<E>> where
            F: Fn(&str) -> Result<T, E>,
            T: Clone + Num,
        {
            let imag = match s.rfind('j') {
                None => 'i',
                _ => 'j',
            };

            let mut neg_b = false;
            let mut a = s;
            let mut b = "";

            for (i, w) in s.as_bytes().windows(2).enumerate() {
                let p = w[0];
                let c = w[1];
                
                if (c == b'+' || c == b'-') && !(p == b'e' || p == b'E') {
                    a = s[..=i].trim_end_matches(char::is_whitespace);
                    b = s[i + 2..].trim_start_matches(char::is_whitespace);
                    neg_b = c == b'-';

                    if b.is_empty() || (neg_b && b.starts_with('-')) {
                        return Err(ParseComplexError::expr_error());
                    }
                    break;
                }
            }
            
            if b.is_empty() {
                b = if a.ends_with(imag) { "0" } else { "0i" };
            }

            let re;
            let neg_re;
            let im;
            let neg_im;
            if a.ends_with(imag) {
                im = a;
                neg_im = false;
                re = b;
                neg_re = neg_b;
            } else if b.ends_with(imag) {
                re = a;
                neg_re = false;
                im = b;
                neg_im = neg_b;
            } else {
                return Err(ParseComplexError::expr_error());
            }
            
            let re = from(re).map_err(ParseComplexError::from_error)?;
            let re = if neg_re { T::zero() - re } else { re };
            
            let mut im = &im[..im.len() - 1];
            if im.is_empty() || im == "+" {
                im = "1";
            } else if im == "-" {
                im = "-1";
            }
            
            let im = from(im).map_err(ParseComplexError::from_error)?;
            let im = if neg_im { T::zero() - im } else { im };

            Ok(Complex::new(re, im))
        }

        impl<T> FromStr for Complex<T> where
            T: FromStr + Num + Clone,
        {
            type Err = ParseComplexError<T::Err>;
            /// Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                from_str_generic(s, T::from_str)
            }
        }

        impl<T: Num + Clone> Num for Complex<T> 
        {
            type FromStrRadixErr = ParseComplexError<T::FromStrRadixErr>;
            /// Parses `a +/- bi`; `ai +/- b`; `a`; or `bi` where `a` and `b` are of type `T`
            fn from_str_radix(s: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> 
            {
                assert!(
                    radix <= 36,
                    "from_str_radix: radix is too high (maximum 36)"
                );
                
                if radix > 18 {
                    return Err(ParseComplexError::unsupported_radix());
                }

                from_str_generic(s, |x| -> Result<T, T::FromStrRadixErr> {
                    T::from_str_radix(x, radix)
                })
            }
        }

        impl<T: Num + Clone> Sum for Complex<T> 
        
        {
            fn sum<I>(iter: I) -> Self where
                I: Iterator<Item = Self>,
            {
                iter.fold(Self::zero(), |acc, c| acc + c)
            }
        }

        impl<'a, T: 'a + Num + Clone> Sum<&'a Complex<T>> for Complex<T> 
        
        {
            fn sum<I>(iter: I) -> Self where
                I: Iterator<Item = &'a Complex<T>>,
            {
                iter.fold(Self::zero(), |acc, c| acc + c)
            }
        }

        impl<T: Num + Clone> Product for Complex<T> 
        
        {
            fn product<I>(iter: I) -> Self where
                I: Iterator<Item = Self>,
            {
                iter.fold(Self::one(), |acc, c| acc * c)
            }
        }

        impl<'a, T: 'a + Num + Clone> Product<&'a Complex<T>> for Complex<T> 
        
        {
            fn product<I>(iter: I) -> Self where
                I: Iterator<Item = &'a Complex<T>>,
            {
                iter.fold(Self::one(), |acc, c| acc * c)
            }
        }

        #[derive(Debug, PartialEq)]
        pub struct ParseComplexError<E> 
        {
            kind: ComplexErrorKind<E>,
        }

        #[derive(Debug, PartialEq)]
        enum ComplexErrorKind<E> 
        {
            ParseError(E),
            ExprError,
            UnsupportedRadix,
        }

        impl<E> ParseComplexError<E> 
        
        {
            fn expr_error() -> Self 
            {
                ParseComplexError {
                    kind: ComplexErrorKind::ExprError,
                }
            }

            fn unsupported_radix() -> Self 
            {
                ParseComplexError {
                    kind: ComplexErrorKind::UnsupportedRadix,
                }
            }

            fn from_error(error: E) -> Self 
            {
                ParseComplexError {
                    kind: ComplexErrorKind::ParseError(error),
                }
            }
        }
        
        impl<E: Error> Error for ParseComplexError<E> 
        
        {
            fn description(&self) -> &str 
            {
                match self.kind {
                    ComplexErrorKind::ParseError(ref e) => e.description(),
                    ComplexErrorKind::ExprError => "invalid or unsupported complex expression",
                    ComplexErrorKind::UnsupportedRadix => "unsupported radix for conversion",
                }
            }
        }

        impl<E: fmt::Display> fmt::Display for ParseComplexError<E> 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
            {
                match self.kind {
                    ComplexErrorKind::ParseError(ref e) => e.fmt(f),
                    ComplexErrorKind::ExprError => "invalid or unsupported complex expression".fmt(f),
                    ComplexErrorKind::UnsupportedRadix => "unsupported radix for conversion".fmt(f),
                }
            }
        }
    }

    pub mod fractional
    {
        use ::
        {
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ FromPrimitive, pow },
            },
            *,
        };

        pub fn frac_from_whole_and_dec(whole: BigInt, decimal: BigInt, dec_len: usize) -> BigRational
        {
            let denom = pow(BigInt::from_u8(10).unwrap(), dec_len);
            BigRational::new(whole, 1.into()) + BigRational::new(decimal, denom)
        }
    }
    
    pub mod integers
    {
        //! Integer trait and functions.
        use ::
        {
            ops::{ Add },
            num::traits::{ Num, Signed, Zero },
            *,
        };

        mod roots
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    traits::{checked_pow, PrimInt},
                },
                *,
            };
            /// Provides methods to compute an integer's square root, cube root,
            /// and arbitrary `n`th root.
            pub trait Roots: Integer
            {
                /// Returns the truncated principal `n`th root of an integer | `if x >= 0 { x } else { x }`
                fn nth_root(&self, n: u32) -> Self;
                /// Returns the truncated principal square root of an integer -- `x`
                #[inline] fn sqrt(&self) -> Self {
                    self.nth_root(2)
                }
                /// Returns the truncated principal cube root of an integer | `if x >= 0 { x } else { x }`
                #[inline] fn cbrt(&self) -> Self {
                    self.nth_root(3)
                }
            }
            /// Returns the truncated principal square root of an integer
            #[inline] pub fn sqrt<T: Roots>(x: T) -> T
                {    x.sqrt()
            }
            /// Returns the truncated principal cube root of an integer
            #[inline] pub fn cbrt<T: Roots>(x: T) -> T
                {    x.cbrt()
            }
            /// Returns the truncated principal `n`th root of an integer
            #[inline] pub fn nth_root<T: Roots>(x: T, n: u32) -> T
                {    x.nth_root(n)
            }

            macro_rules! signed_roots {
                ($T:ty, $U:ty) => {
                    impl Roots for $T {
                        #[inline] fn nth_root(&self, n: u32) -> Self {
                            if *self >= 0 {
                                (*self as $U).nth_root(n) as Self
                            } else {
                                assert!(n.is_odd(), "even roots of a negative are imaginary");
                                -((self.wrapping_neg() as $U).nth_root(n) as Self)
                            }
                        }

                        #[inline] fn sqrt(&self) -> Self {
                            assert!(*self >= 0, "the square root of a negative is imaginary");
                            (*self as $U).sqrt() as Self
                        }

                        #[inline] fn cbrt(&self) -> Self {
                            if *self >= 0 {
                                (*self as $U).cbrt() as Self
                            } else {
                                -((self.wrapping_neg() as $U).cbrt() as Self)
                            }
                        }
                    }
                };
            }

            signed_roots!(i8, u8);
            signed_roots!(i16, u16);
            signed_roots!(i32, u32);
            signed_roots!(i64, u64);
            signed_roots!(i128, u128);
            signed_roots!(isize, usize);

            #[inline] fn fixpoint<T, F>(mut x: T, f: F) -> T where
                T: Integer + Copy,
                F: Fn(T) -> T,
            {
                let mut xn = f(x);
                while x < xn {
                    x = xn;
                    xn = f(x);
                }
                while x > xn {
                    x = xn;
                    xn = f(x);
                }
                x
            }

            #[inline] fn bits<T>() -> u32 {
                8 * mem::size_of::<T>() as u32
            }

            #[inline] fn log2<T: PrimInt>(x: T) -> u32 {
                debug_assert!(x > T::zero());
                bits::<T>() - 1 - x.leading_zeros()
            }

            macro_rules! unsigned_roots {
                ($T:ident) => {
                    impl Roots for $T {
                        #[inline] fn nth_root(&self, n: u32) -> Self {
                            fn go(a: $T, n: u32) -> $T {
                                match n {
                                    0 => panic!("can't find a root of degree 0!"),
                                    1 => return a,
                                    2 => return a.sqrt(),
                                    3 => return a.cbrt(),
                                    _ => (),
                                }
                                
                                if bits::<$T>() <= n || a < (1 << n) {
                                    return (a > 0) as $T;
                                }

                                if bits::<$T>() > 64 {
                                    return if a <= std::u64::MAX as $T {
                                        (a as u64).nth_root(n) as $T
                                    } else {
                                        let lo = (a >> n).nth_root(n) << 1;
                                        let hi = lo + 1;
                                        
                                        if hi.next_power_of_two().trailing_zeros() * n >= bits::<$T>() {
                                            match checked_pow(hi, n as usize) {
                                                Some(x) if x <= a => hi,
                                                _ => lo,
                                            }
                                        } else {
                                            if hi.pow(n) <= a {
                                                hi
                                            } else {
                                                lo
                                            }
                                        }
                                    };
                                }
                                
                                #[inline] fn guess(x: $T, n: u32) -> $T {
                                    if bits::<$T>() <= 32 || x <= std::u32::MAX as $T {
                                        1 << ((log2(x) + n - 1) / n)
                                    } else {
                                        ((x as f64).ln() / f64::from(n)).exp() as $T
                                    }
                                }
                                
                                let n1 = n - 1;
                                let next = |x: $T| 
                    {
                                    let y = match checked_pow(x, n1 as usize) {
                                        Some(ax) => a / ax,
                                        None => 0,
                                    };
                                    (y + x * n1 as $T) / n as $T
                                };
                                fixpoint(guess(a, n), next)
                            }
                            go(*self, n)
                        }

                        #[inline] fn sqrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                    return if a <= std::u64::MAX as $T {
                                        (a as u64).sqrt() as $T
                                    } else {
                                        let lo = (a >> 2u32).sqrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if a < 4 {
                                    return (a > 0) as $T;
                                }

                                #[inline] fn guess(x: $T) -> $T {
                                    (x as f64).sqrt() as $T
                                }
                                
                                let next = |x: $T| (a / x + x) >> 1;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }

                        #[inline] fn cbrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                    return if a <= std::u64::MAX as $T {
                                        (a as u64).cbrt() as $T
                                    } else {
                                        let lo = (a >> 3u32).cbrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if bits::<$T>() <= 32 {
                                    let mut x = a;
                                    let mut y2 = 0;
                                    let mut y = 0;
                                    let smax = bits::<$T>() / 3;
                                    for s in (0..smax + 1).rev() {
                                        let s = s * 3;
                                        y2 *= 4;
                                        y *= 2;
                                        let b = 3 * (y2 + y) + 1;
                                        if x >> s >= b {
                                            x -= b << s;
                                            y2 += 2 * y + 1;
                                            y += 1;
                                        }
                                    }
                                    return y;
                                }

                                if a < 8 {
                                    return (a > 0) as $T;
                                }
                                if a <= std::u32::MAX as $T {
                                    return (a as u32).cbrt() as $T;
                                }

                                #[inline] fn guess(x: $T) -> $T {
                                    (x as f64).cbrt() as $T
                                }
                                
                                let next = |x: $T| (a / (x * x) + x * 2) / 3;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }
                    }
                };
            }

            unsigned_roots!(u8);
            unsigned_roots!(u16);
            unsigned_roots!(u32);
            unsigned_roots!(u64);
            unsigned_roots!(u128);
            unsigned_roots!(usize);
        }
        pub use self::roots::Roots;
        pub use self::roots::{cbrt, nth_root, sqrt};

        mod average
        {
            use ::
            {
                num::integers::Integer,
                ops::{BitAnd, BitOr, BitXor, Shr},
                *,
            };
            /// Provides methods to compute the average of two integers, without overflows.
            pub trait Average: Integer
            {
                /// Returns the ceiling value of the average of `self` and `other`.
                fn average_ceil(&self, other: &Self) -> Self;
                /// Returns the floor value of the average of `self` and `other`.
                fn average_floor(&self, other: &Self) -> Self;
            }

            impl<I> Average for I where
                I: Integer + Shr<usize, Output = I>,
                for<'a, 'b> &'a I:
                    BitAnd<&'b I, Output = I> + BitOr<&'b I, Output = I> + BitXor<&'b I, Output = I>,
            {
                /// Returns the floor value of the average of `self` and `other`.
                #[inline] fn average_floor(&self, other: &I) -> I 
                {
                    (self & other) + ((self ^ other) >> 1)
                }
                /// Returns the ceil value of the average of `self` and `other`.
                #[inline] fn average_ceil(&self, other: &I) -> I 
                {
                    (self | other) - ((self ^ other) >> 1)
                }
            }
            /// Returns the floor value of the average of `x` and `y` --
            /// see [Average::average_floor](trait.Average.html#tymethod.average_floor).
            #[inline] pub fn average_floor<T: Average>(x: T, y: T) -> T
                {    x.average_floor(&y)
            }
            /// Returns the ceiling value of the average of `x` and `y` --
            /// see [Average::average_ceil](trait.Average.html#tymethod.average_ceil).
            #[inline] pub fn average_ceil<T: Average>(x: T, y: T) -> T
                {    x.average_ceil(&y)
            }
        }
        pub use self::average::Average;
        pub use self::average::{average_ceil, average_floor};

        pub trait Integer: Sized + Num + PartialOrd + Ord + Eq 
        {
            /// Floored integer division.
            fn div_floor(&self, other: &Self) -> Self;
            /// Floored integer modulo
            fn mod_floor(&self, other: &Self) -> Self;
            /// Ceiled integer division.
            fn div_ceil(&self, other: &Self) -> Self {
                let (q, r) = self.div_mod_floor(other);
                if r.is_zero() {
                    q
                } else {
                    q + Self::one()
                }
            }
            /// Greatest Common Divisor (GCD).
            fn gcd(&self, other: &Self) -> Self;
            /// Lowest Common Multiple (LCM).
            fn lcm(&self, other: &Self) -> Self;
            /// Greatest Common Divisor (GCD) and
            /// Lowest Common Multiple (LCM) together.
            #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                (self.gcd(other), self.lcm(other))
            }
            /// Greatest common divisor and Bzout coefficients.
            #[inline] fn extended_gcd(&self, other: &Self) -> ExtendedGcd<Self> where
                Self: Clone,
            {
                let mut s = (Self::zero(), Self::one());
                let mut t = (Self::one(), Self::zero());
                let mut r = (other.clone(), self.clone());

                while !r.0.is_zero() {
                    let q = r.1.clone() / r.0.clone();
                    let f = |mut r: (Self, Self)| 
                    {
                        mem::swap(&mut r.0, &mut r.1);
                        r.0 = r.0 - q.clone() * r.1.clone();
                        r
                    };
                    r = f(r);
                    s = f(s);
                    t = f(t);
                }

                if r.1 >= Self::zero() {
                    ExtendedGcd {
                        gcd: r.1,
                        x: s.1,
                        y: t.1,
                    }
                } else {
                    ExtendedGcd {
                        gcd: Self::zero() - r.1,
                        x: Self::zero() - s.1,
                        y: Self::zero() - t.1,
                    }
                }
            }
            /// Greatest common divisor, least common multiple, and Bzout coefficients.
            #[inline] fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) where
                Self: Clone + Signed,
            {
                (self.extended_gcd(other), self.lcm(other))
            }
            /// Deprecated, use `is_multiple_of` instead.
            #[deprecated(note = "Please use is_multiple_of instead")]
            #[inline] fn divides(&self, other: &Self) -> bool {
                self.is_multiple_of(other)
            }
            /// Returns `true` if `self` is a multiple of `other`.
            fn is_multiple_of(&self, other: &Self) -> bool;
            /// Returns `true` if the number is even.
            fn is_even(&self) -> bool;
            /// Returns `true` if the number is odd.
            fn is_odd(&self) -> bool;
            /// Simultaneous truncated integer division and modulus.
            fn div_rem(&self, other: &Self) -> (Self, Self);
            /// Simultaneous floored integer division and modulus.
            fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                (self.div_floor(other), self.mod_floor(other))
            }
            /// Rounds up to nearest multiple of argument.
            #[inline] fn next_multiple_of(&self, other: &Self) -> Self where
                Self: Clone,
            {
                let m = self.mod_floor(other);
                self.clone()
                    + if m.is_zero() {
                        Self::zero()
                    } else {
                        other.clone() - m
                    }
            }
            /// Rounds down to nearest multiple of argument.
            #[inline] fn prev_multiple_of(&self, other: &Self) -> Self where
                Self: Clone,
            {
                self.clone() - self.mod_floor(other)
            }
            /// Decrements self by one.
            fn dec(&mut self) where
                Self: Clone,
            {
                *self = self.clone() - Self::one()
            }
            /// Increments self by one.
            fn inc(&mut self) where
                Self: Clone,
            {
                *self = self.clone() + Self::one()
            }
        }
        /// Greatest common divisor and Bzout coefficients
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        pub struct ExtendedGcd<A> {
            pub gcd: A,
            pub x: A,
            pub y: A,
        }
        /// Simultaneous integer division and modulus
        #[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) {
            x.div_rem(&y)
        }
        /// Floored integer division
        #[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T
                {x.div_floor(&y)
        }
        /// Floored integer modulus
        #[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T
                {x.mod_floor(&y)
        }
        /// Simultaneous floored integer division and modulus
        #[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) {
            x.div_mod_floor(&y)
        }
        /// Ceiled integer division
        #[inline] pub fn div_ceil<T: Integer>(x: T, y: T) -> T
                {x.div_ceil(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The
        /// result is always non-negative.
        #[inline( always )] pub fn gcd<T: Integer>(x: T, y: T) -> T
                {x.gcd(&y)
        }
        /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
        #[inline( always )] pub fn lcm<T: Integer>(x: T, y: T) -> T
                {x.lcm(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) and
        /// Lowest Common Multiple (LCM) of the number and `other`.
        #[inline( always )] pub fn gcd_lcm<T: Integer>(x: T, y: T) -> (T, T) {
            x.gcd_lcm(&y)
        }

        macro_rules! impl_integer_for_isize {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Floored integer division
                    #[inline] fn div_floor(&self, other: &Self) -> Self {
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            d - 1
                        } else {
                            d
                        }
                    }

                    /// Floored integer modulo
                    #[inline] fn mod_floor(&self, other: &Self) -> Self {
                        let r = *self % *other;
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            r + *other
                        } else {
                            r
                        }
                    }

                    /// Calculates `div_floor` and `mod_floor` simultaneously
                    #[inline] fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            (d - 1, r + *other)
                        } else {
                            (d, r)
                        }
                    }

                    #[inline] fn div_ceil(&self, other: &Self) -> Self {
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other > 0) || (r < 0 && *other < 0) {
                            d + 1
                        } else {
                            d
                        }
                    }
                    /// Calculates the Greatest Common Divisor (GCD) of the number and
                    /// `other`. The result is always non-negative.
                    #[inline] fn gcd(&self, other: &Self) -> Self {
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return (m | n).abs();
                        }
                        
                        let shift = (m | n).trailing_zeros();
                        
                        if m == Self::min_value() || n == Self::min_value() {
                            return (1 << shift).abs();
                        }
                        
                        m = m.abs();
                        n = n.abs();
                        
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline] fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) 
                    {
                        let egcd = self.extended_gcd(other);
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            (*self * (*other / egcd.gcd)).abs()
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and
                    /// `other`.
                    #[inline] fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                        let lcm = (*self * (*other / gcd)).abs();
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline] fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`
                    #[inline] fn is_even(&self) -> bool {
                        (*self) & 1 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`
                    #[inline] fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline] fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }

                    /// Rounds up to nearest multiple of argument.
                    #[inline] fn next_multiple_of(&self, other: &Self) -> Self {
                        if *other == -1 {
                            return *self;
                        }

                        let m = Integer::mod_floor(self, other);
                        *self + if m == 0 { 0 } else { other - m }
                    }

                    /// Rounds down to nearest multiple of argument.
                    #[inline] fn prev_multiple_of(&self, other: &Self) -> Self {
                        if *other == -1 {
                            return *self;
                        }

                        *self - Integer::mod_floor(self, other)
                    }
                }
            };
        }

        impl_integer_for_isize!(i8, test_integer_i8);
        impl_integer_for_isize!(i16, test_integer_i16);
        impl_integer_for_isize!(i32, test_integer_i32);
        impl_integer_for_isize!(i64, test_integer_i64);
        impl_integer_for_isize!(i128, test_integer_i128);
        impl_integer_for_isize!(isize, test_integer_isize);

        macro_rules! impl_integer_for_usize {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Unsigned integer division. Returns the same result as `div` (`/`).
                    #[inline] fn div_floor(&self, other: &Self) -> Self {
                        *self / *other
                    }

                    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).
                    #[inline] fn mod_floor(&self, other: &Self) -> Self {
                        *self % *other
                    }

                    #[inline] fn div_ceil(&self, other: &Self) -> Self {
                        *self / *other + (0 != *self % *other) as Self
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`
                    #[inline] fn gcd(&self, other: &Self) -> Self {
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return m | n;
                        }
                        
                        let shift = (m | n).trailing_zeros();
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline] fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) 
                    {
                        let egcd = self.extended_gcd(other);
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            *self * (*other / egcd.gcd)
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline] fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline] fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                        let lcm = *self * (*other / gcd);
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline] fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`.
                    #[inline] fn is_even(&self) -> bool {
                        *self % 2 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`.
                    #[inline] fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline] fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }
                }
            };
        }

        impl_integer_for_usize!(u8, test_integer_u8);
        impl_integer_for_usize!(u16, test_integer_u16);
        impl_integer_for_usize!(u32, test_integer_u32);
        impl_integer_for_usize!(u64, test_integer_u64);
        impl_integer_for_usize!(u128, test_integer_u128);
        impl_integer_for_usize!(usize, test_integer_usize);
        /// An iterator over binomial coefficients.
        pub struct IterBinomial<T> {
            a: T,
            n: T,
            k: T,
        }

        impl<T> IterBinomial<T> where
            T: Integer,
        {
            /// For n, iterate over all binomial coefficients binomial(n, k), for k=0...n.
            pub fn new(n: T) -> IterBinomial<T> {
                IterBinomial {
                    k: T::zero(),
                    a: T::one(),
                    n,
                }
            }
        }

        impl<T> Iterator for IterBinomial<T> where
            T: Integer + Clone,
        {
            type Item = T;

            fn next(&mut self) -> Option<T> {
                if self.k > self.n {
                    return None;
                }
                self.a = if !self.k.is_zero() {
                    multiply_and_divide(
                        self.a.clone(),
                        self.n.clone() - self.k.clone() + T::one(),
                        self.k.clone(),
                    )
                } else {
                    T::one()
                };
                self.k = self.k.clone() + T::one();
                Some(self.a.clone())
            }
        }
        /// Calculate r * a / b, avoiding overflows and fractions.
        fn multiply_and_divide<T: Integer + Clone>(r: T, a: T, b: T) -> T
                {// See http://blog.plover.com/math/choose-2.html for the idea.
            let g = gcd(r.clone(), b.clone());
            r / g.clone() * (a / (b / g))
        }
        /// Calculate the binomial coefficient.
        pub fn binomial<T: Integer + Clone>(mut n: T, k: T) -> T
                {// See http://blog.plover.com/math/choose.html for the idea.
            if k > n {
                return T::zero();
            }
            if k > n.clone() - k.clone() {
                return binomial(n.clone(), n - k);
            }
            let mut r = T::one();
            let mut d = T::one();
            loop {
                if d > k {
                    break;
                }
                r = multiply_and_divide(r, n.clone(), d.clone());
                n = n - T::one();
                d = d + T::one();
            }
            r
        }
        /// Calculate the multinomial coefficient.
        pub fn multinomial<T: Integer + Clone>(k: &[T]) -> T where
            for<'a> T: Add<&'a T, Output = T>,
        {
            let mut r = T::one();
            let mut p = T::zero();
            for i in k {
                p = p + i;
                r = r * binomial(p.clone(), i.clone());
            }
            r
        }
    }
    
    pub mod rational
    {
        //! Rational numbers
        use ::
        {
            error::{ Error },
            fmt::{ self, Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex },
            hash::{ Hash, Hasher },
            num::
            {
                big::{ BigInt, BigUint, Sign, ToBigInt },
                integers::Integer,
                traits::
                {
                    Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, ConstOne, ConstZero, FromPrimitive, 
                    Inv, Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero, FloatCore
                },
            },
            ops::{ Add, Div, Mul, Neg, Rem, ShlAssign, Sub },
            str::FromStr,
            *,
        };
        
        mod pow
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    traits::{ One, Pow },
                },
                *,
            };

            use super::Ratio;

            macro_rules! pow_unsigned_impl
            {
                (@ $exp:ty) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: $exp) -> Ratio<T> {
                        Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))
                    }
                };
                ($exp:ty) => {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline] fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline] fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_unsigned_impl!(u8);
            pow_unsigned_impl!(u16);
            pow_unsigned_impl!(u32);
            pow_unsigned_impl!(u64);
            pow_unsigned_impl!(u128);
            pow_unsigned_impl!(usize);

            macro_rules! pow_signed_impl {
                (@ &'b BigInt, BigUint) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: &'b BigInt) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => {
                                Pow::pow(self, expon.magnitude()).into_recip()
                            }
                            Sign::Plus => Pow::pow(self, expon.magnitude()),
                        }
                    }
                };
                (@ $exp:ty, $unsigned:ty) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: $exp) -> Ratio<T> {
                        match expon.cmp(&0) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow(self, expon).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),
                        }
                    }
                };
                ($exp:ty, $unsigned:ty) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline] fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline] fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_signed_impl!(i8, u8);
            pow_signed_impl!(i16, u16);
            pow_signed_impl!(i32, u32);
            pow_signed_impl!(i64, u64);
            pow_signed_impl!(i128, u128);
            pow_signed_impl!(isize, usize);

            #[cfg(feature = "num-bigint")]
            mod bigint {
                use super::*;
                use num_bigint::{BigInt, BigUint, Sign};

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T>
                where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> {
                    pow_unsigned_impl!(@ &'b BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T>
                where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_unsigned_impl!(@ &'b BigUint);
                }

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T>
                where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T>
                where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
            }
        }
        /// Represents the ratio between two numbers.
        #[derive(Copy, Clone, Debug)]
        pub struct Ratio<T> 
        {
            /// Numerator.
            numer: T,
            /// Denominator.
            denom: T,
        }
        /// Alias for a `Ratio` of machine-sized integers.
        #[deprecated(
            since = "0.4.0",
            note = "it's better to use a specific size, like `Rational32` or `Rational64`"
        )]
        pub type Rational = Ratio<isize>;
        /// Alias for a `Ratio` of 32-bit-sized integers.
        pub type Rational32 = Ratio<i32>;
        /// Alias for a `Ratio` of 64-bit-sized integers.
        pub type Rational64 = Ratio<i64>;
        
        /// Alias for arbitrary precision rationals.
        pub type BigRational = Ratio<BigInt>;
        /// These method are `const`.
        impl<T> Ratio<T> 
        {
            /// Creates a `Ratio` without checking for `denom == 0` or reducing.
            #[inline] pub const fn new_raw(numer: T, denom: T) -> Ratio<T> {
                Ratio { numer, denom }
            }
            /// Deconstructs a `Ratio` into its numerator and denominator.
            #[inline] pub fn into_raw(self) -> (T, T) {
                (self.numer, self.denom)
            }
            /// Gets an immutable reference to the numerator.
            #[inline] pub const fn numer(&self) -> &T {
                &self.numer
            }
            /// Gets an immutable reference to the denominator.
            #[inline] pub const fn denom(&self) -> &T {
                &self.denom
            }
        }

        impl<T: Clone + Integer> Ratio<T>
        {
            /// Creates a new `Ratio`.
            #[inline] pub fn new(numer: T, denom: T) -> Ratio<T>
            {
                let mut ret = Ratio::new_raw(numer, denom);
                ret.reduce();
                ret
            }
            /// Creates a `Ratio` representing the integer `t`.
            #[inline] pub fn from_integer(t: T) -> Ratio<T> {
                Ratio::new_raw(t, One::one())
            }
            /// Converts to an integer, rounding towards zero.
            #[inline] pub fn to_integer(&self) -> T {
                self.trunc().numer
            }
            /// Returns true if the rational number is an integer (denominator is 1).
            #[inline] pub fn is_integer(&self) -> bool {
                self.denom.is_one()
            }
            /// Puts self into lowest terms, with `denom` > 0.
            fn reduce(&mut self) {
                if self.denom.is_zero() {
                    panic!("denominator == 0");
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd(&self.denom);
                
                #[inline] fn replace_with<T: Zero>(x: &mut T, f: impl FnOnce(T) -> T) {
                    let y = ::mem::replace(x, T::zero());
                    *x = f(y);
                }
                
                replace_with(&mut self.numer, |x| x / g.clone());
                
                replace_with(&mut self.denom, |x| x / g);
                
                if self.denom < T::zero() {
                    replace_with(&mut self.numer, |x| T::zero() - x);
                    replace_with(&mut self.denom, |x| T::zero() - x);
                }
            }
            /// Returns a reduced copy of self.
            pub fn reduced(&self) -> Ratio<T>
            {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }
            /// Returns the reciprocal.
            #[inline] pub fn recip(&self) -> Ratio<T> 
            {
                self.clone().into_recip()
            }

            #[inline] fn into_recip(self) -> Ratio<T> {
                match self.numer.cmp(&T::zero()) {
                    cmp::Ordering::Equal => panic!("division by zero"),
                    cmp::Ordering::Greater => Ratio::new_raw(self.denom, self.numer),
                    cmp::Ordering::Less => Ratio::new_raw(T::zero() - self.denom, T::zero() - self.numer),
                }
            }
            /// Rounds towards minus infinity.
            #[inline] pub fn floor(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() - self.denom.clone() + one) / self.denom.clone(),
                    )
                } else {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                }
            }
            /// Rounds towards plus infinity.
            #[inline] pub fn ceil(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                } else {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() + self.denom.clone() - one) / self.denom.clone(),
                    )
                }
            }
            /// Rounds to the nearest integer. Rounds half-way cases away from zero.
            #[inline] pub fn round(&self) -> Ratio<T>
            {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();
                let mut fractional = self.fract();
                if fractional < zero 
                {
                    fractional = zero - fractional
                };
                
                let half_or_larger = if fractional.denom.is_even() 
                {
                    fractional.numer >= fractional.denom / two
                } 
                
                else 
                {
                    fractional.numer >= (fractional.denom / two) + one
                };

                if half_or_larger {
                    let one: Ratio<T> = One::one();
                    if *self >= Zero::zero() {
                        self.trunc() + one
                    } else {
                        self.trunc() - one
                    }
                } else {
                    self.trunc()
                }
            }
            /// Rounds towards zero.
            #[inline] pub fn trunc(&self) -> Ratio<T> {
                Ratio::from_integer(self.numer.clone() / self.denom.clone())
            }
            /// Returns the fractional part of a number, with division rounded towards zero.
            #[inline] pub fn fract(&self) -> Ratio<T> {
                Ratio::new_raw(self.numer.clone() % self.denom.clone(), self.denom.clone())
            }
            /// Raises the `Ratio` to the power of an exponent.
            #[inline] pub fn pow(&self, expon: i32) -> Ratio<T> where
            for<'a> &'a T: Pow<u32, Output = T>
            {
                Pow::pow(self, expon)
            }
        }
        
        impl Ratio<BigInt> 
        {
            /// Converts a float into a rational number.
            pub fn from_float<T: FloatCore>(f: T) -> Option<BigRational> 
            {
                if !f.is_finite() {
                    return None;
                }
                let (mantissa, exponent, sign) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                if exponent < 0 {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ((-exponent) as usize);
                    let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))
                } else {
                    let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    numer <<= exponent as usize;
                    Some(Ratio::from_integer(BigInt::from_biguint(
                        bigint_sign,
                        numer,
                    )))
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T> 
        {
            /// Returns zero
            fn default() -> Self {
                Ratio::zero()
            }
        }
        
        impl<T> From<T> for Ratio<T> where
            T: Clone + Integer,
        
        {
            fn from(x: T) -> Ratio<T> {
                Ratio::from_integer(x)
            }
        }
        
        impl<T> From<(T, T)> for Ratio<T> where
            T: Clone + Integer,
        
        {
            fn from(pair: (T, T)) -> Ratio<T> {
                Ratio::new(pair.0, pair.1)
            }
        }
        
        impl<T: Clone + Integer> Ord for Ratio<T> 
        {
            #[inline] fn cmp(&self, other: &Self) -> cmp::Ordering 
            {
                if self.denom == other.denom 
                {
                    let ord = self.numer.cmp(&other.numer);
                    return if self.denom < T::zero() {
                        ord.reverse()
                    } else {
                        ord
                    };
                }
                
                if self.numer == other.numer 
                {
                    if self.numer.is_zero() {
                        return cmp::Ordering::Equal;
                    }
                    let ord = self.denom.cmp(&other.denom);
                    return if self.numer < T::zero() {
                        ord
                    } else {
                        ord.reverse()
                    };
                }
                
                let (self_int, self_rem) = self.numer.div_mod_floor(&self.denom);
                let (other_int, other_rem) = other.numer.div_mod_floor(&other.denom);

                match self_int.cmp(&other_int) 
                {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal => {
                        match (self_rem.is_zero(), other_rem.is_zero()) {
                            (true, true) => cmp::Ordering::Equal,
                            (true, false) => cmp::Ordering::Less,
                            (false, true) => cmp::Ordering::Greater,
                            (false, false) => {
                                let self_recip = Ratio::new_raw(self.denom.clone(), self_rem);
                                let other_recip = Ratio::new_raw(other.denom.clone(), other_rem);
                                self_recip.cmp(&other_recip).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T> 
        {
            #[inline] fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
                Some(self.cmp(other))
            }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T> 
        {
            #[inline] fn eq(&self, other: &Self) -> bool {
                self.cmp(other) == cmp::Ordering::Equal
            }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}
        
        impl<T: Clone + Integer + Hash> Hash for Ratio<T> 
        
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                recurse(&self.numer, &self.denom, state);

                fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H) {
                    if !denom.is_zero() 
                    {
                        let (int, rem) = numer.div_mod_floor(denom);
                        int.hash(state);
                        recurse(denom, &rem, state);
                    } else {
                        denom.hash(state);
                    }
                }
            }
        }

        mod iter_sum_product
        {
            use ::
            {
                iter::{ Product, Sum },
                num::
                {
                    integers::{ Integer },
                    traits::{ One, Zero },
                },
                *,
            }; use super::Ratio;

            impl<T: Integer + Clone> Sum for Ratio<T> {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T> {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<T: Integer + Clone> Product for Ratio<T> {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }

            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T> {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }
        }

        mod opassign
        {
            use ::
            {
                ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign},
                num::
                {
                    integers::{ Integer },
                    traits::{ NumAssign },
                },
                *,
            }; use super::Ratio;

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T> {
                fn add_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer += other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

           
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T> {
                fn div_assign(&mut self, other: Ratio<T>) {
                    let gcd_ac = self.numer.gcd(&other.numer);
                    let gcd_bd = self.denom.gcd(&other.denom);
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T> {
                fn mul_assign(&mut self, other: Ratio<T>) {
                    let gcd_ad = self.numer.gcd(&other.denom);
                    let gcd_bc = self.denom.gcd(&other.numer);
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T> 
            {
                fn rem_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer %= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T> 
            {
                fn sub_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer -= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T> 
            {
                fn add_assign(&mut self, other: T) {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T> 
            {
                fn div_assign(&mut self, other: T) {
                    let gcd = self.numer.gcd(&other);
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T> 
            {
                fn mul_assign(&mut self, other: T) {
                    let gcd = self.denom.gcd(&other);
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce();
                }
            }

           
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T> 
            {
                fn rem_assign(&mut self, other: T) {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }

           
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T> 
            {
                fn sub_assign(&mut self, other: T) {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }

            macro_rules! forward_op_assign 
            {
                (impl $imp:ident, $method:ident) => {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {
                        #[inline] fn $method(&mut self, other: &Ratio<T>) {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {
                        #[inline] fn $method(&mut self, other: &T) {
                            self.$method(other.clone())
                        }
                    }
                };
            }

            forward_op_assign!(impl AddAssign, add_assign);
            forward_op_assign!(impl DivAssign, div_assign);
            forward_op_assign!(impl MulAssign, mul_assign);
            forward_op_assign!(impl RemAssign, rem_assign);
            forward_op_assign!(impl SubAssign, sub_assign);
        }

        macro_rules! forward_ref_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T> {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &'b Ratio<T>) -> Ratio<T> {
                        self.clone().$method(other.clone())
                    }
                }
                impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T> {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &'b T) -> Ratio<T> {
                        self.clone().$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_ref_val_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: Ratio<T>) -> Ratio<T> {
                        self.clone().$method(other)
                    }
                }
                impl<'a, T> $imp<T> for &'a Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: T) -> Ratio<T> {
                        self.clone().$method(other)
                    }
                }
            };
        }

        macro_rules! forward_val_ref_binop 
        {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &Ratio<T>) -> Ratio<T> {
                        self.$method(other.clone())
                    }
                }
                impl<'a, T> $imp<&'a T> for Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline] fn $method(self, other: &T) -> Ratio<T> {
                        self.$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_all_binop 
        {
            (impl $imp:ident, $method:ident) => {
                forward_ref_ref_binop!(impl $imp, $method);
                forward_ref_val_binop!(impl $imp, $method);
                forward_val_ref_binop!(impl $imp, $method);
            };
        }
        
        forward_all_binop!(impl Mul, mul);
       
        impl<T> Mul<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul(self, rhs: Ratio<T>) -> Ratio<T>
            {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Ratio::new(
                    self.numer / gcd_ad.clone() * (rhs.numer / gcd_bc.clone()),
                    self.denom / gcd_bc * (rhs.denom / gcd_ad),
                )
            }
        }
       
        impl<T> Mul<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul(self, rhs: T) -> Ratio<T>
            {
                let gcd = self.denom.gcd(&rhs);
                Ratio::new(self.numer * (rhs / gcd.clone()), self.denom / gcd)
            }
        }

        forward_all_binop!(impl Div, div);
       
        impl<T> Div<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div(self, rhs: Ratio<T>) -> Ratio<T>
            {
                let gcd_ac = self.numer.gcd(&rhs.numer);
                let gcd_bd = self.denom.gcd(&rhs.denom);
                Ratio::new(
                    self.numer / gcd_ac.clone() * (rhs.denom / gcd_bd.clone()),
                    self.denom / gcd_bd * (rhs.numer / gcd_ac),
                )
            }
        }
       
        impl<T> Div<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div(self, rhs: T) -> Ratio<T>
            {
                let gcd = self.numer.gcd(&rhs);
                Ratio::new(self.numer / gcd.clone(), self.denom * (rhs / gcd))
            }
        }

        macro_rules! arith_impl 
        {
            (impl $imp:ident, $method:ident) => {
                forward_all_binop!(impl $imp, $method);
               
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method(self, rhs: Ratio<T>) -> Ratio<T> {
                        if self.denom == rhs.denom {
                            return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);
                        }
                        let lcm = self.denom.lcm(&rhs.denom);
                        let lhs_numer = self.numer * (lcm.clone() / self.denom);
                        let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);
                        Ratio::new(lhs_numer.$method(rhs_numer), lcm)
                    }
                }
               
                impl<T: Clone + Integer> $imp<T> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method(self, rhs: T) -> Ratio<T> {
                        Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)
                    }
                }
            };
        }

        arith_impl!(impl Add, add);
        arith_impl!(impl Sub, sub);
        arith_impl!(impl Rem, rem);

       
        impl<T> CheckedMul for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_mul(&self, rhs: &Ratio<T>) -> Option<Ratio<T>>
            {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Some(Ratio::new(
                    (self.numer.clone() / gcd_ad.clone())
                        .checked_mul(&(rhs.numer.clone() / gcd_bc.clone()))?,
                    (self.denom.clone() / gcd_bc).checked_mul(&(rhs.denom.clone() / gcd_ad))?,
                ))
            }
        }

       
        impl<T> CheckedDiv for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_div(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                if rhs.is_zero() {
                    return None;
                }
                let (numer, denom) = if self.denom == rhs.denom {
                    (self.numer.clone(), rhs.numer.clone())
                } else if self.numer == rhs.numer {
                    (rhs.denom.clone(), self.denom.clone())
                } else {
                    let gcd_ac = self.numer.gcd(&rhs.numer);
                    let gcd_bd = self.denom.gcd(&rhs.denom);
                    (
                        (self.numer.clone() / gcd_ac.clone())
                            .checked_mul(&(rhs.denom.clone() / gcd_bd.clone()))?,
                        (self.denom.clone() / gcd_bd).checked_mul(&(rhs.numer.clone() / gcd_ac))?,
                    )
                };
                
                if denom.is_zero() {
                    None
                } else if numer.is_zero() {
                    Some(Self::zero())
                } else if numer == denom {
                    Some(Self::one())
                } else {
                    let g = numer.gcd(&denom);
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero() {
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw(numer.checked_mul(&n1)?, denom.checked_mul(&n1)?)
                    } else {
                        Ratio::new_raw(numer, denom)
                    };
                    Some(raw)
                }
            }
        }
        
        macro_rules! checked_arith_impl {
            (impl $imp:ident, $method:ident) => {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {
                    #[inline] fn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                        let gcd = self.denom.clone().gcd(&rhs.denom);
                        let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;
                        let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;
                        let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;
                        Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))
                    }
                }
            };
        }

       
        checked_arith_impl!(impl CheckedAdd, checked_add);

       
        checked_arith_impl!(impl CheckedSub, checked_sub);

        impl<T> Neg for Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg(self) -> Ratio<T> {
                Ratio::new_raw(-self.numer, self.denom)
            }
        }

        impl<'a, T> Neg for &'a Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg(self) -> Ratio<T> {
                -self.clone()
            }
        }

        impl<T> Inv for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv(self) -> Ratio<T> 
            {
                self.recip()
            }
        }

        impl<'a, T> Inv for &'a Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv(self) -> Ratio<T> 
            {
                self.recip()
            }
        }
        
        impl<T: ConstZero + ConstOne> Ratio<T> 
        {
            /// A constant `Ratio` 0/1.
            pub const ZERO: Self = Self::new_raw(T::ZERO, T::ONE);
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T> 
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T> 
        {
            #[inline] fn zero() -> Ratio<T> {
                Ratio::new_raw(Zero::zero(), One::one())
            }

            #[inline] fn is_zero(&self) -> bool {
                self.numer.is_zero()
            }

            #[inline] fn set_zero(&mut self) {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T> 
        {
            /// A constant `Ratio` 1/1.
            pub const ONE: Self = Self::new_raw(T::ONE, T::ONE);
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T> 
        {
            #[inline] fn one() -> Ratio<T> {
                Ratio::new_raw(One::one(), One::one())
            }

            #[inline] fn is_one(&self) -> bool {
                self.numer == self.denom
            }

            #[inline] fn set_one(&mut self) {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T> 
        {
            type FromStrRadixErr = ParseRatioError;
            /// Parses `numer/denom` where the numbers are in base `radix`.
            fn from_str_radix(s: &str, radix: u32) -> Result<Ratio<T>, ParseRatioError> {
                if s.splitn(2, '/').count() == 2 {
                    let mut parts = s.splitn(2, '/').map(|ss| 
                    {
                        T::from_str_radix(ss, radix).map_err(|_| ParseRatioError {
                            kind: RatioErrorKind::ParseError,
                        })
                    });
                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero() {
                        Err(ParseRatioError {
                            kind: RatioErrorKind::ZeroDenominator,
                        })
                    } else {
                        Ok(Ratio::new(numer, denom))
                    }
                } else {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ParseError,
                    })
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T> 
        {
            #[inline] fn abs(&self) -> Ratio<T> {
                if self.is_negative() {
                    -self.clone()
                } else {
                    self.clone()
                }
            }

            #[inline] fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {
                if *self <= *other {
                    Zero::zero()
                } else {
                    self - other
                }
            }

            #[inline] fn signum(&self) -> Ratio<T> {
                if self.is_positive() {
                    Self::one()
                } else if self.is_zero() {
                    Self::zero()
                } else {
                    -Self::one()
                }
            }

            #[inline] fn is_positive(&self) -> bool {
                (self.numer.is_positive() && self.denom.is_positive())
                    || (self.numer.is_negative() && self.denom.is_negative())
            }

            #[inline] fn is_negative(&self) -> bool {
                (self.numer.is_negative() && self.denom.is_positive())
                    || (self.numer.is_positive() && self.denom.is_negative())
            }
        }
        
        macro_rules! impl_formatting 
        {
            ($fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr) => {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T>
                {
                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                        let pre_pad = if self.denom.is_one() {
                            format!($fmt_str, self.numer)
                        } else {
                            if f.alternate() {
                                format!(concat!($fmt_str, "/", $fmt_alt), self.numer, self.denom)
                            } else {
                                format!(concat!($fmt_str, "/", $fmt_str), self.numer, self.denom)
                            }
                        };
                        if let Some(pre_pad) = pre_pad.strip_prefix("-") {
                            f.pad_integral(false, $prefix, pre_pad)
                        } else {
                            f.pad_integral(true, $prefix, &pre_pad)
                        }
                    }
                }
            };
        }

        impl_formatting!(Display, "", "{}", "{:#}");
        impl_formatting!(Octal, "0o", "{:o}", "{:#o}");
        impl_formatting!(Binary, "0b", "{:b}", "{:#b}");
        impl_formatting!(LowerHex, "0x", "{:x}", "{:#x}");
        impl_formatting!(UpperHex, "0x", "{:X}", "{:#X}");
        impl_formatting!(LowerExp, "", "{:e}", "{:#e}");
        impl_formatting!(UpperExp, "", "{:E}", "{:#E}");

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T> 
        {
            type Err = ParseRatioError;
            /// Parses `numer/denom` or just `numer`.
            fn from_str(s: &str) -> Result<Ratio<T>, ParseRatioError>
            {
                let mut split = s.splitn(2, '/');

                let n = split.next().ok_or(ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;
                let num = FromStr::from_str(n).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                let d = split.next().unwrap_or("1");
                let den = FromStr::from_str(d).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                if Zero::is_zero(&den) {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ZeroDenominator,
                    })
                } else {
                    Ok(Ratio::new(num, den))
                }
            }
        }

        impl<T> From<Ratio<T>> for (T, T)
        {
            fn from(val: Ratio<T>) -> Self {
                (val.numer, val.denom)
            }
        }
        
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct ParseRatioError 
        {
            kind: RatioErrorKind,
        }

        #[derive(Copy, Clone, Debug, PartialEq)]
        enum RatioErrorKind 
        {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError 
        
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                self.kind.description().fmt(f)
            }
        }
        
        impl Error for ParseRatioError 
        
        {
            fn description(&self) -> &str {
                self.kind.description()
            }
        }

        impl RatioErrorKind 
        
        {
            fn description(&self) -> &'static str {
                match *self {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }
        
        impl FromPrimitive for Ratio<BigInt> 
        
        {
            fn from_i64(n: i64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_i128(n: i128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u64(n: u64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u128(n: u128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_f32(n: f32) -> Option<Self> {
                Ratio::from_float(n)
            }

            fn from_f64(n: f64) -> Option<Self> {
                Ratio::from_float(n)
            }
        }

        macro_rules! from_primitive_integer 
        {
            ($typ:ty, $approx:ident) => {
                impl FromPrimitive for Ratio<$typ>
                {
                    fn from_i64(n: i64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)
                    }

                    fn from_i128(n: i128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)
                    }

                    fn from_u64(n: u64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)
                    }

                    fn from_u128(n: u128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)
                    }

                    fn from_f32(n: f32) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }

                    fn from_f64(n: f64) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }
                }
            };
        }

        from_primitive_integer!(i8, approximate_float);
        from_primitive_integer!(i16, approximate_float);
        from_primitive_integer!(i32, approximate_float);
        from_primitive_integer!(i64, approximate_float);
        from_primitive_integer!(i128, approximate_float);
        from_primitive_integer!(isize, approximate_float);

        from_primitive_integer!(u8, approximate_float_unsigned);
        from_primitive_integer!(u16, approximate_float_unsigned);
        from_primitive_integer!(u32, approximate_float_unsigned);
        from_primitive_integer!(u64, approximate_float_unsigned);
        from_primitive_integer!(u128, approximate_float_unsigned);
        from_primitive_integer!(usize, approximate_float_unsigned);

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T> 
        {
            pub fn approximate_float<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> 
            {
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float(f, epsilon, 30)
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T> 
        {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float_unsigned(f, epsilon, 30)
            }
        }

        fn approximate_float<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>> where
            T: Integer + Signed + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();

            let r = approximate_float_unsigned(abs_val, max_error, max_iterations)?;
            
            Some(if negative { r.neg() } else { r })
        }
        
        fn approximate_float_unsigned<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>> where
            T: Integer + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            if val < F::zero() || val.is_nan() {
                return None;
            }

            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();

            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from(t_max.clone())?;
            
            let epsilon = t_max_f.recip();
            
            if q > t_max_f {
                return None;
            }

            for _ in 0..max_iterations 
            {
                let a = match <T as NumCast>::from(q) 
                {
                    None => break,
                    Some(a) => a,
                };

                let a_f = match <F as NumCast>::from(a.clone()) 
                {
                    None => break,
                    Some(a_f) => a_f,
                };
                let f = q - a_f;
                
                if !a.is_zero()
                    && (n1 > t_max.clone() / a.clone()
                        || d1 > t_max.clone() / a.clone()
                        || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                        || a.clone() * d1.clone() > t_max.clone() - d0.clone())
                {
                    break;
                }

                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();
                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();                
                let g = Integer::gcd(&n1, &d1);
                
                if !g.is_zero() {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }
                
                let (n_f, d_f) = match (<F as NumCast>::from(n), <F as NumCast>::from(d)) {
                    (Some(n_f), Some(d_f)) => (n_f, d_f),
                    _ => break,
                };

                if (n_f / d_f - val).abs() < max_error {
                    break;
                }
                
                if f < epsilon {
                    break;
                }

                q = f.recip();
            }
            
            if d1.is_zero() {
                return None;
            }

            Some(Ratio::new(n1, d1))
        }
        
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T> 
        
        {
            fn to_i64(&self) -> Option<i64> 
            {
                self.to_integer().to_i64()
            }

            fn to_i128(&self) -> Option<i128> 
            {
                self.to_integer().to_i128()
            }

            fn to_u64(&self) -> Option<u64> 
            {
                self.to_integer().to_u64()
            }

            fn to_u128(&self) -> Option<u128> 
            {
                self.to_integer().to_u128()
            }

            fn to_f64(&self) -> Option<f64>
            {
                let float = match (self.numer.to_i64(), self.denom.to_i64()) {
                    (Some(numer), Some(denom)) => ratio_to_f64(
                        <i128 as From<_>>::from(numer),
                        <i128 as From<_>>::from(denom),
                    ),
                    _ => {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64(numer, denom)
                    }
                };
                if float.is_nan() {
                    None
                } else {
                    Some(float)
                }
            }
        }

        trait Bits 
        
        {
            fn bits(&self) -> u64;
        }
        
        impl Bits for BigInt 
        
        {
            fn bits(&self) -> u64 {
                self.bits()
            }
        }

        impl Bits for i128 
        
        {
            fn bits(&self) -> u64 {
                (128 - self.wrapping_abs().leading_zeros()).into()
            }
        }
        /// Converts a ratio of `T` to an f64.
        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>( numer: T, denom: T, ) ->
        f64 
        {
            use std::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );
            
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() {
                return flo_sign;
            }
            
            if let (Some(n), Some(d)) = (numer.to_i64(), denom.to_i64()) {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                if exact.contains(&n) && exact.contains(&d) {
                    return n.to_f64().unwrap() / d.to_f64().unwrap();
                }
            }
            
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let (is_diff_positive, absolute_diff) = match numer.bits().checked_sub(denom.bits()) {
                Some(diff) => (true, diff),
                None => (false, denom.bits() - numer.bits()),
            };
            
            if is_diff_positive && absolute_diff > MAX_EXP as u64 {
                return INFINITY * flo_sign;
            }
            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 {
                return 0.0 * flo_sign;
            }
            let diff = if is_diff_positive {
                absolute_diff.to_isize().unwrap()
            } else {
                -absolute_diff.to_isize().unwrap()
            };
            
            let shift: isize = diff.max(MIN_EXP as isize) - MANTISSA_DIGITS as isize - 2;
            if shift >= 0 {
                denom <<= shift as usize
            } else {
                numer <<= -shift as usize
            };

            let (quotient, remainder) = numer.div_rem(&denom);
            
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits = {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max(subnormal_bits) - MANTISSA_DIGITS as isize
            } as usize;
            debug_assert!(n_rounding_bits == 2 || n_rounding_bits == 3);
            let rounding_bit_mask = (1u64 << n_rounding_bits) - 1;
            
            let ls_bit = quotient & (1u64 << n_rounding_bits) != 0;
            let ms_rounding_bit = quotient & (1u64 << (n_rounding_bits - 1)) != 0;
            let ls_rounding_bits = quotient & (rounding_bit_mask >> 1) != 0;
            if ms_rounding_bit && (ls_bit || ls_rounding_bits || !remainder.is_zero()) {
                quotient += 1u64 << n_rounding_bits;
            }
            quotient &= !rounding_bit_mask;
            
            let q_float = quotient as f64 * flo_sign;
            ldexp(q_float, shift as i32)
        }
        /// Multiply `x` by 2 to the power of `exp`. Returns an accurate result even if `2^exp` is not representable.
        fn ldexp(x: f64, exp: i32) -> f64 
        {
            use std::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() {
                return x;
            }
            
            if exp > 3 * MAX_EXP {
                return INFINITY * x.signum();
            } else if exp < -3 * MAX_EXP {
                return 0.0 * x.signum();
            }
            
            let (bits, curr_exp) = if !x.is_normal() 
            {
                let normal_x = x * 2f64.powi(MIN_SUBNORMAL_POWER);
                let bits = normal_x.to_bits();
                (
                    bits,
                    ((bits & EXPONENT_MASK) >> 52) as i32 - MIN_SUBNORMAL_POWER,
                )
            } else {
                let bits = x.to_bits();
                let curr_exp = (bits & EXPONENT_MASK) >> 52;
                (bits, curr_exp as i32)
            };
            
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT {
                INFINITY * x.signum()
            } else if new_exp > 0 {
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits)
            } else if new_exp >= -(MANTISSA_DIGITS as i32) {
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!(new_exp >= 0);
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits) * 2f64.powi(-MIN_SUBNORMAL_POWER)
            } else {
                return 0.0 * x.signum();
            }
        }
    }
    
    pub mod traits
    {
        //! Numeric traits for generic mathematics
        use ::
        {
            cmp::{ Ordering },
            hash::{ Hash, Hasher },
            num::
            {
                Wrapping 
            },
            ops::{ Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Sub, SubAssign },
            *,
        };
        
        #[macro_use] pub mod macros
        {
            use ::
            {
                *,
            };
            /// Forward a method to an inherent method or a base trait method.
            macro_rules! forward
            {
                ($( Self :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            Self::$method(self $( , $arg )* )
                        }
                    )*};
                ($( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            <Self as $base>::$method(self $( , $arg )* )
                        }
                    )*};
                ($( $base:ident :: $method:ident ( $( $arg:ident : $ty:ty ),* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method( $( $arg : $ty ),* ) -> $ret {
                            <Self as $base>::$method( $( $arg ),* )
                        }
                    )*};
                ($( $imp:path as $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
                    => {$(
                        #[inline] fn $method(self $( , $arg : $ty )* ) -> $ret {
                            $imp(self $( , $arg )* )
                        }
                    )*};
            }

            macro_rules! constant
            {
                ($( $method:ident () -> $ret:expr ; )*) => 
                {$(
                        #[inline] fn $method() -> Self
                        {
                            $ret
                        }
                )*};
            }
        }

        pub mod bounds
        {
            use ::
            {
                num::{ Wrapping },
                *,
            };
            /// Numbers which have upper and lower bounds
            pub trait Bounded 
            {
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
            /// Numbers which have lower bounds
            pub trait LowerBounded 
            {
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
            }
            
            impl<T: Bounded> LowerBounded for T 
            {
                fn min_value() -> T
                {
                    Bounded::min_value()
                }
            }
            /// Numbers which have upper bounds
            pub trait UpperBounded 
            {
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }

            impl<T: Bounded> UpperBounded for T 
            {
                fn max_value() -> T
                {        Bounded::max_value()
                }
            }

            macro_rules! bounded_impl 
            {
                ($t:ty, $min:expr, $max:expr) => {
                    impl Bounded for $t {
                        #[inline] fn min_value() -> $t {
                            $min
                        }

                        #[inline] fn max_value() -> $t {
                            $max
                        }
                    }
                };
            }

            bounded_impl!(usize, usize::MIN, usize::MAX);
            bounded_impl!(u8, u8::MIN, u8::MAX);
            bounded_impl!(u16, u16::MIN, u16::MAX);
            bounded_impl!(u32, u32::MIN, u32::MAX);
            bounded_impl!(u64, u64::MIN, u64::MAX);
            bounded_impl!(u128, u128::MIN, u128::MAX);

            bounded_impl!(isize, isize::MIN, isize::MAX);
            bounded_impl!(i8, i8::MIN, i8::MAX);
            bounded_impl!(i16, i16::MIN, i16::MAX);
            bounded_impl!(i32, i32::MIN, i32::MAX);
            bounded_impl!(i64, i64::MIN, i64::MAX);
            bounded_impl!(i128, i128::MIN, i128::MAX);

            impl<T: Bounded> Bounded for Wrapping<T> 
            {
                fn min_value() -> Self {
                    Wrapping(T::min_value())
                }
                fn max_value() -> Self {
                    Wrapping(T::max_value())
                }
            }

            bounded_impl!(f32, f32::MIN, f32::MAX);

            macro_rules! for_each_tuple_ 
            {
                ( $m:ident !! ) => (
                    $m! { }
                );
                ( $m:ident !! $h:ident, $($t:ident,)* ) => (
                    $m! { $h $($t)* }
                    for_each_tuple_! { $m !! $($t,)* }
                );
            }
            macro_rules! for_each_tuple 
            {
                ($m:ident) => {
                    for_each_tuple_! { $m !! A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, }
                };
            }

            macro_rules! bounded_tuple 
            {
                ( $($name:ident)* ) => (
                    impl<$($name: Bounded,)*> Bounded for ($($name,)*) {
                        #[inline] fn min_value() -> Self {
                            ($($name::min_value(),)*)
                        }
                        #[inline] fn max_value() -> Self {
                            ($($name::max_value(),)*)
                        }
                    }
                );
            }

            for_each_tuple!(bounded_tuple);
            bounded_impl!(f64, f64::MIN, f64::MAX);
        } pub use self::bounds::{ * };

        pub mod cast
        {
            use ::
            {
                num::
                {
                    Wrapping 
                },
                mem::size_of,
                *,
            };
            /// A generic trait for converting a value to a number.
            pub trait ToPrimitive {
                /// Converts the value of `self` to an `isize`.
                #[inline] fn to_isize(&self) -> Option<isize> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_isize)
                }
                /// Converts the value of `self` to an `i8`.
                #[inline] fn to_i8(&self) -> Option<i8> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i8)
                }
                /// Converts the value of `self` to an `i16`.
                #[inline] fn to_i16(&self) -> Option<i16> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i16)
                }
                /// Converts the value of `self` to an `i32`.
                #[inline] fn to_i32(&self) -> Option<i32> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i32)
                }
                /// Converts the value of `self` to an `i64`.
                fn to_i64(&self) -> Option<i64>;
                /// Converts the value of `self` to an `i128`.
                #[inline] fn to_i128(&self) -> Option<i128> {
                    self.to_i64().map(From::from)
                }
                /// Converts the value of `self` to a `usize`.
                #[inline] fn to_usize(&self) -> Option<usize> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_usize)
                }
                /// Converts the value of `self` to a `u8`.
                #[inline] fn to_u8(&self) -> Option<u8> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u8)
                }
                /// Converts the value of `self` to a `u16`.
                #[inline] fn to_u16(&self) -> Option<u16> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u16)
                }
                /// Converts the value of `self` to a `u32`.
                #[inline] fn to_u32(&self) -> Option<u32> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u32)
                }
                /// Converts the value of `self` to a `u64`.
                fn to_u64(&self) -> Option<u64>;
                /// Converts the value of `self` to a `u128`.
                #[inline] fn to_u128(&self) -> Option<u128> {
                    self.to_u64().map(From::from)
                }
                /// Converts the value of `self` to an `f32`.
                #[inline] fn to_f32(&self) -> Option<f32> {
                    self.to_f64().as_ref().and_then(ToPrimitive::to_f32)
                }
                /// Converts the value of `self` to an `f64`.
                #[inline] fn to_f64(&self) -> Option<f64> {
                    match self.to_i64() {
                        Some(i) => i.to_f64(),
                        None => self.to_u64().as_ref().and_then(ToPrimitive::to_f64),
                    }
                }
            }

            macro_rules! impl_to_primitive_int_to_int {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let min = $DstT::MIN as $SrcT;
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int_to_uint {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_int_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_int_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline] fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline] fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_int!(isize);
            impl_to_primitive_int!(i8);
            impl_to_primitive_int!(i16);
            impl_to_primitive_int!(i32);
            impl_to_primitive_int!(i64);
            impl_to_primitive_int!(i128);

            macro_rules! impl_to_primitive_uint_to_int {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint_to_uint {
                ($SrcT:ident : $( $(#[$cfg:meta])* fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_uint_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_uint_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline] fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline] fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_uint!(usize);
            impl_to_primitive_uint!(u8);
            impl_to_primitive_uint!(u16);
            impl_to_primitive_uint!(u32);
            impl_to_primitive_uint!(u64);
            impl_to_primitive_uint!(u128);

            macro_rules! impl_to_primitive_float_to_float {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline] fn $method(&self) -> Option<$DstT> {
                        Some(*self as $DstT)
                    }
                )*}
            }

            macro_rules! float_to_int_unchecked {
                ($float:expr => $int:ty) => {
                    unsafe { $float.to_int_unchecked::<$int>() }
                };
            }

            macro_rules! impl_to_primitive_float_to_signed_int {
                ($f:ident : $( $(#[$cfg:meta])* fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$i> {
                        if size_of::<$f>() > size_of::<$i>() {
                            const MIN_M1: $f = $i::MIN as $f - 1.0;
                            const MAX_P1: $f = $i::MAX as $f + 1.0;
                            if *self > MIN_M1 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        } else {
                            const MIN: $f = $i::MIN as $f;
                            const MAX_P1: $f = $i::MAX as $f;
                            if *self >= MIN && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float_to_unsigned_int {
                ($f:ident : $( $(#[$cfg:meta])* fn $method:ident -> $u:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$u> {
                        if size_of::<$f>() > size_of::<$u>() {
                            const MAX_P1: $f = $u::MAX as $f + 1.0;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        } else {
                            const MAX_P1: $f = $u::MAX as $f;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_float_to_signed_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_float_to_unsigned_int! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        impl_to_primitive_float_to_float! { $T:
                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }

            impl_to_primitive_float!(f32);
            impl_to_primitive_float!(f64);
            /// A generic trait for converting a number to a value.
            pub trait FromPrimitive: Sized {
                /// Converts an `isize` to return an optional value of this type.
                #[inline] fn from_isize(n: isize) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }
                /// Converts an `i8` to return an optional value of this type.
                #[inline] fn from_i8(n: i8) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }
                /// Converts an `i16` to return an optional value of this type.
                #[inline] fn from_i16(n: i16) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }
                /// Converts an `i32` to return an optional value of this type.
                #[inline] fn from_i32( n:i32 ) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }
                /// Converts an `i64` to return an optional value of this type.
                fn from_i64(n: i64) -> Option<Self>;
                /// Converts an `i128` to return an optional value of this type.
                #[inline] fn from_i128(n: i128) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }
                /// Converts a `usize` to return an optional value of this type.
                #[inline] fn from_usize(n: usize) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }
                /// Converts an `u8` to return an optional value of this type.
                #[inline] fn from_u8(n: u8) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }
                /// Converts an `u16` to return an optional value of this type.
                #[inline] fn from_u16(n: u16) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }
                /// Converts an `u32` to return an optional value of this type.
                #[inline] fn from_u32(n: u32) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }
                /// Converts an `u64` to return an optional value of this type.
                fn from_u64(n: u64) -> Option<Self>;
                /// Converts an `u128` to return an optional value of this type.
                #[inline] fn from_u128(n: u128) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }
                /// Converts a `f32` to return an optional value of this type.
                #[inline] fn from_f32(n: f32) -> Option<Self> {
                    FromPrimitive::from_f64(From::from(n))
                }
                /// Converts a `f64` to return an optional value of this type.
                #[inline] fn from_f64(n: f64) -> Option<Self> {
                    match n.to_i64() {
                        Some(i) => FromPrimitive::from_i64(i),
                        None => n.to_u64().and_then(FromPrimitive::from_u64),
                    }
                }
            }

            macro_rules! impl_from_primitive {
                ($T:ty, $to_ty:ident) => {
                    #[allow(deprecated)]
                    impl FromPrimitive for $T {
                        #[inline] fn from_isize(n: isize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i8(n: i8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i16(n: i16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i32( n:i32 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i64(n: i64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_i128(n: i128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline] fn from_usize(n: usize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u8(n: u8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u16(n: u16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u32(n: u32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u64(n: u64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_u128(n: u128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline] fn from_f32(n: f32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline] fn from_f64(n: f64) -> Option<$T> {
                            n.$to_ty()
                        }
                    }
                };
            }

            impl_from_primitive!(isize, to_isize);
            impl_from_primitive!(i8, to_i8);
            impl_from_primitive!(i16, to_i16);
            impl_from_primitive!(i32, to_i32);
            impl_from_primitive!(i64, to_i64);
            impl_from_primitive!(i128, to_i128);
            impl_from_primitive!(usize, to_usize);
            impl_from_primitive!(u8, to_u8);
            impl_from_primitive!(u16, to_u16);
            impl_from_primitive!(u32, to_u32);
            impl_from_primitive!(u64, to_u64);
            impl_from_primitive!(u128, to_u128);
            impl_from_primitive!(f32, to_f32);
            impl_from_primitive!(f64, to_f64);

            macro_rules! impl_to_primitive_wrapping {
                ($( $(#[$cfg:meta])* fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(&self) -> Option<$i> {
                        (self.0).$method()
                    }
                )*}
            }

            impl<T: ToPrimitive> ToPrimitive for Wrapping<T> {
                impl_to_primitive_wrapping! {
                    fn to_isize -> isize;
                    fn to_i8 -> i8;
                    fn to_i16 -> i16;
                    fn to_i32 -> i32;
                    fn to_i64 -> i64;
                    fn to_i128 -> i128;

                    fn to_usize -> usize;
                    fn to_u8 -> u8;
                    fn to_u16 -> u16;
                    fn to_u32 -> u32;
                    fn to_u64 -> u64;
                    fn to_u128 -> u128;

                    fn to_f32 -> f32;
                    fn to_f64 -> f64;
                }
            }

            macro_rules! impl_from_primitive_wrapping {
                ($( $(#[$cfg:meta])* fn $method:ident ( $i:ident ); )*) => {$(
                    #[inline]
                    $(#[$cfg])*
                    fn $method(n: $i) -> Option<Self> {
                        T::$method(n).map(Wrapping)
                    }
                )*}
            }

            impl<T: FromPrimitive> FromPrimitive for Wrapping<T> {
                impl_from_primitive_wrapping! {
                    fn from_isize(isize);
                    fn from_i8(i8);
                    fn from_i16(i16);
                    fn from_i32(i32);
                    fn from_i64(i64);
                    fn from_i128(i128);

                    fn from_usize(usize);
                    fn from_u8(u8);
                    fn from_u16(u16);
                    fn from_u32(u32);
                    fn from_u64(u64);
                    fn from_u128(u128);

                    fn from_f32(f32);
                    fn from_f64(f64);
                }
            }
            /// Cast from one machine scalar to another.
            #[inline] pub fn cast<T: NumCast, U: NumCast>(n: T) -> Option<U> {
                NumCast::from(n)
            }
            /// An interface for casting between machine scalars.
            pub trait NumCast: Sized + ToPrimitive {
                /// Creates a number from another value that can be converted into
                /// a primitive via the `ToPrimitive` trait.
                fn from<T: ToPrimitive>(n: T) -> Option<Self>;
            }

            macro_rules! impl_num_cast {
                ($T:ty, $conv:ident) => {
                    impl NumCast for $T {
                        #[inline]
                        #[allow(deprecated)]
                        fn from<N: ToPrimitive>(n: N) -> Option<$T> {
                            n.$conv()
                        }
                    }
                };
            }

            impl_num_cast!(u8, to_u8);
            impl_num_cast!(u16, to_u16);
            impl_num_cast!(u32, to_u32);
            impl_num_cast!(u64, to_u64);
            impl_num_cast!(u128, to_u128);
            impl_num_cast!(usize, to_usize);
            impl_num_cast!(i8, to_i8);
            impl_num_cast!(i16, to_i16);
            impl_num_cast!(i32, to_i32);
            impl_num_cast!(i64, to_i64);
            impl_num_cast!(i128, to_i128);
            impl_num_cast!(isize, to_isize);
            impl_num_cast!(f32, to_f32);
            impl_num_cast!(f64, to_f64);

            impl<T: NumCast> NumCast for Wrapping<T> {
                fn from<U: ToPrimitive>(n: U) -> Option<Self> {
                    T::from(n).map(Wrapping)
                }
            }
            /// A generic interface for casting between machine scalars with the
            /// `as` operator, which admits narrowing and precision loss.
            pub trait AsPrimitive<T>: 'static + Copy where
                T: 'static + Copy,
            {
                /// Convert a value to another, using the `as` operator.
                fn as_(self) -> T;
            }

            macro_rules! impl_as_primitive {
                (@ $T: ty => $(#[$cfg:meta])* impl $U: ty ) => {
                    $(#[$cfg])*
                    impl AsPrimitive<$U> for $T {
                        #[inline] fn as_(self) -> $U { self as $U }
                    }
                };
                (@ $T: ty => { $( $U: ty ),* } ) => {$(
                    impl_as_primitive!(@ $T => impl $U);
                )*};
                ($T: ty => { $( $U: ty ),* } ) => {
                    impl_as_primitive!(@ $T => { $( $U ),* });
                    impl_as_primitive!(@ $T => { u8, u16, u32, u64, u128, usize });
                    impl_as_primitive!(@ $T => { i8, i16, i32, i64, i128, isize });
                };
            }

            impl_as_primitive!(u8 => { char, f32, f64 });
            impl_as_primitive!(i8 => { f32, f64 });
            impl_as_primitive!(u16 => { f32, f64 });
            impl_as_primitive!(i16 => { f32, f64 });
            impl_as_primitive!(u32 => { f32, f64 });
            impl_as_primitive!(i32 => { f32, f64 });
            impl_as_primitive!(u64 => { f32, f64 });
            impl_as_primitive!(i64 => { f32, f64 });
            impl_as_primitive!(u128 => { f32, f64 });
            impl_as_primitive!(i128 => { f32, f64 });
            impl_as_primitive!(usize => { f32, f64 });
            impl_as_primitive!(isize => { f32, f64 });
            impl_as_primitive!(f32 => { f32, f64 });
            impl_as_primitive!(f64 => { f32, f64 });
            impl_as_primitive!(char => { char });
            impl_as_primitive!(bool => {});
        } pub use self::cast::{ * };

        pub mod float
        {
            use ::
            {
                cmp::Ordering,
                num::
                { 
                    traits::
                    {
                        Num, NumCast, ToPrimitive
                    },
                    FpCategory 
                },
                ops::{ Add, Div, Neg },
                *,
            };
            /// Generic trait for floating point numbers that works with `no_std`.
            pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy 
            {
                /// Returns positive infinity.
                fn infinity() -> Self;
                /// Returns negative infinity.
                fn neg_infinity() -> Self;
                /// Returns NaN.
                fn nan() -> Self;
                /// Returns `-0.0`.
                fn neg_zero() -> Self;
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self;
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns `true` if the number is NaN.
                #[inline] fn is_nan(self) -> bool
                {
                    self != self
                }
                /// Returns `true` if the number is infinite.
                #[inline] fn is_infinite(self) -> bool {
                    self == Self::infinity() || self == Self::neg_infinity()
                }
                /// Returns `true` if the number is neither infinite or NaN.
                #[inline] fn is_finite(self) -> bool {
                    !(self.is_nan() || self.is_infinite())
                }
                /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.
                #[inline] fn is_normal(self) -> bool {
                    self.classify() == FpCategory::Normal
                }
                /// Returns `true` if the number is [subnormal].
                #[inline] fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }
                /// Returns the floating point category of the number.
                fn classify(self) -> FpCategory;
                /// Returns the largest integer less than or equal to a number.
                #[inline] fn floor(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self < Self::zero() {
                        self - f - Self::one()
                    } else {
                        self - f
                    }
                }
                /// Returns the smallest integer greater than or equal to a number.
                #[inline] fn ceil(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        self - f + Self::one()
                    } else {
                        self - f
                    }
                }
                /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.
                #[inline] fn round(self) -> Self {
                    let one = Self::one();
                    let h = Self::from(0.5).expect("Unable to cast from 0.5");
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        if f < h {
                            self - f
                        } else {
                            self - f + one
                        }
                    } else if -f < h {
                        self - f
                    } else {
                        self - f - one
                    }
                }
                /// Return the integer part of a number.
                #[inline] fn trunc(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() {
                        self
                    } else {
                        self - f
                    }
                }
                /// Returns the fractional part of a number.
                #[inline] fn fract(self) -> Self {
                    if self.is_zero() {
                        Self::zero()
                    } else {
                        self % Self::one()
                    }
                }
                /// Computes the absolute value of `self`.
                #[inline] fn abs(self) -> Self {
                    if self.is_sign_positive() {
                        return self;
                    }
                    if self.is_sign_negative() {
                        return -self;
                    }
                    Self::nan()
                }
                /// Returns a number that represents the sign of `self`.
                #[inline] fn signum(self) -> Self {
                    if self.is_nan() {
                        Self::nan()
                    } else if self.is_sign_negative() {
                        -Self::one()
                    } else {
                        Self::one()
                    }
                }
                /// Returns `true` if `self` is positive, including `+0.0` and
                /// `FloatCore::infinity()`, and `FloatCore::nan()`.
                #[inline] fn is_sign_positive(self) -> bool {
                    !self.is_sign_negative()
                }
                /// Returns `true` if `self` is negative, including `-0.0` and
                /// `FloatCore::neg_infinity()`, and `-FloatCore::nan()`.
                #[inline] fn is_sign_negative(self) -> bool {
                    let (_, _, sign) = self.integer_decode();
                    sign < 0
                }
                /// Returns the minimum of the two numbers.
                #[inline] fn min(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self < other {
                        self
                    } else {
                        other
                    }
                }
                /// Returns the maximum of the two numbers.
                #[inline] fn max(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self > other {
                        self
                    } else {
                        other
                    }
                }
                /// A value bounded by a minimum and a maximum
                fn clamp(self, min: Self, max: Self) -> Self {
                    ::num::traits::clamp(self, min, max)
                }
                /// Returns the reciprocal (multiplicative inverse) of the number.
                #[inline] fn recip(self) -> Self {
                    Self::one() / self
                }
                /// Raise a number to an integer power.
                #[inline] fn powi(mut self, mut exp: i32) -> Self {
                    if exp < 0 {
                        exp = exp.wrapping_neg();
                        self = self.recip();
                    }
                    
                    super::pow(self, (exp as u32).to_usize().unwrap())
                }
                /// Converts to degrees, assuming the number is in radians.
                fn to_degrees(self) -> Self;
                /// Converts to radians, assuming the number is in degrees.
                fn to_radians(self) -> Self;
                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.
                fn integer_decode(self) -> (u64, i16, i8);
            }

            impl FloatCore for f32 {
                constant! {
                    infinity() -> f32::INFINITY;
                    neg_infinity() -> f32::NEG_INFINITY;
                    nan() -> f32::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f32::MIN;
                    min_positive_value() -> f32::MIN_POSITIVE;
                    epsilon() -> f32::EPSILON;
                    max_value() -> f32::MAX;
                }

                #[inline] fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f32(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }
                
                forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }
            }

            impl FloatCore for f64 {
                constant! {
                    infinity() -> f64::INFINITY;
                    neg_infinity() -> f64::NEG_INFINITY;
                    nan() -> f64::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f64::MIN;
                    min_positive_value() -> f64::MIN_POSITIVE;
                    epsilon() -> f64::EPSILON;
                    max_value() -> f64::MAX;
                }

                #[inline] fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f64(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }
                
                forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }
            }
            /// Generic trait for floating point numbers
            pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> 
            {
                /// Returns the `NaN` value.
                fn infinity() -> Self;
                /// Returns NaN.
                fn nan() -> Self;
                /// Returns the negative infinite value.
                fn neg_infinity() -> Self;
                /// Returns `-0.0`.
                fn neg_zero() -> Self;
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self {
                    Self::from(f32::EPSILON).expect("Unable to cast from f32::EPSILON")
                }
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns `true` if this value is `NaN` and false otherwise.
                fn is_nan(self) -> bool;
                /// `true` if this value is positive infinity or negative infinity and
                /// `false` otherwise.
                fn is_infinite(self) -> bool;
                /// Returns `true` if this number is neither infinite nor `NaN`.
                fn is_finite(self) -> bool;
                /// Returns `true` if the number is neither zero, infinite,
                /// [subnormal][subnormal], or `NaN`.
                fn is_normal(self) -> bool;
                /// Returns `true` if the number is [subnormal].
                #[inline] fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }
                /// Returns the floating point category of the number.
                fn classify(self) -> FpCategory;
                /// Returns the largest integer less than or equal to a number.
                fn floor(self) -> Self;
                /// Returns the smallest integer greater than or equal to a number.
                fn ceil(self) -> Self;
                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                fn round(self) -> Self;
                /// Return the integer part of a number.
                fn trunc(self) -> Self;
                /// Returns the fractional part of a number.
                fn fract(self) -> Self;
                /// Computes the absolute value of `self`.
                fn abs(self) -> Self;
                /// Returns a number that represents the sign of `self`.
                fn signum(self) -> Self;
                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and `Float::nan()`.
                fn is_sign_positive(self) -> bool;
                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and `-Float::nan()`.
                fn is_sign_negative(self) -> bool;
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                fn mul_add(self, a: Self, b: Self) -> Self;
                /// Take the reciprocal (inverse) of a number, `1/x`.
                fn recip(self) -> Self;
                /// Raise a number to an integer power.
                fn powi(self, n: i32) -> Self;
                /// Raise a number to a floating point power.
                fn powf(self, n: Self) -> Self;
                /// Take the square root of a number.
                fn sqrt(self) -> Self;
                /// Returns `e^(self)`, (the exponential function).
                fn exp(self) -> Self;
                /// Returns `2^(self)`.
                fn exp2(self) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln(self) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log(self, base: Self) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2(self) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10(self) -> Self;
                /// Converts radians to degrees.
                #[inline] fn to_degrees(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * ninety / halfpi
                }
                /// Converts degrees to radians.
                #[inline] fn to_radians(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * halfpi / ninety
                }
                /// Returns the maximum of the two numbers.
                fn max(self, other: Self) -> Self;
                /// Returns the minimum of the two numbers.
                fn min(self, other: Self) -> Self;
                /// Clamps a value between a min and max.
                fn clamp(self, min: Self, max: Self) -> Self {
                    ::num::traits::clamp(self, min, max)
                }
                /// The positive difference of two numbers.
                fn abs_sub(self, other: Self) -> Self;
                /// Take the cubic root of a number.
                fn cbrt(self) -> Self;
                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                fn hypot(self, other: Self) -> Self;
                /// Computes the sine of a number (in radians).
                fn sin(self) -> Self;
                /// Computes the cosine of a number (in radians).
                fn cos(self) -> Self;
                /// Computes the tangent of a number (in radians).
                fn tan(self) -> Self;
                /// Computes the arcsine of a number.
                fn asin(self) -> Self;
                /// Computes the arccosine of a number.
                fn acos(self) -> Self;
                /// Computes the arctangent of a number.
                fn atan(self) -> Self;
                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                fn atan2(self, other: Self) -> Self;
                /// Simultaneously computes the sine and cosine of the number, `x`.
                fn sin_cos(self) -> (Self, Self);
                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                fn exp_m1(self) -> Self;
                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                fn ln_1p(self) -> Self;
                /// Hyperbolic sine function.
                fn sinh(self) -> Self;
                /// Hyperbolic cosine function.
                fn cosh(self) -> Self;
                /// Hyperbolic tangent function.
                fn tanh(self) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh(self) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh(self) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh(self) -> Self;
                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                fn integer_decode(self) -> (u64, i16, i8);
                /// Returns a number composed of the magnitude of `self` and the sign of
                /// `sign`.
                fn copysign(self, sign: Self) -> Self {
                    if self.is_sign_negative() == sign.is_sign_negative() {
                        self
                    } else {
                        self.neg()
                    }
                }
            }
            
            macro_rules! float_impl_std {
                ($T:ident $decode:ident) => {
                    impl Float for $T {
                        constant! {
                            nan() -> $T::NAN;
                            infinity() -> $T::INFINITY;
                            neg_infinity() -> $T::NEG_INFINITY;
                            neg_zero() -> -0.0;
                            min_value() -> $T::MIN;
                            min_positive_value() -> $T::MIN_POSITIVE;
                            epsilon() -> $T::EPSILON;
                            max_value() -> $T::MAX;
                        }

                        #[inline]
                        #[allow(deprecated)]
                        fn abs_sub(self, other: Self) -> Self {
                            <$T>::abs_sub(self, other)
                        }

                        #[inline] fn integer_decode(self) -> (u64, i16, i8) {
                            $decode(self)
                        }

                        forward! {
                            Self::is_nan(self) -> bool;
                            Self::is_infinite(self) -> bool;
                            Self::is_finite(self) -> bool;
                            Self::is_normal(self) -> bool;
                            Self::is_subnormal(self) -> bool;
                            Self::classify(self) -> FpCategory;
                            Self::clamp(self, min: Self, max: Self) -> Self;
                            Self::floor(self) -> Self;
                            Self::ceil(self) -> Self;
                            Self::round(self) -> Self;
                            Self::trunc(self) -> Self;
                            Self::fract(self) -> Self;
                            Self::abs(self) -> Self;
                            Self::signum(self) -> Self;
                            Self::is_sign_positive(self) -> bool;
                            Self::is_sign_negative(self) -> bool;
                            Self::mul_add(self, a: Self, b: Self) -> Self;
                            Self::recip(self) -> Self;
                            Self::powi(self, n: i32) -> Self;
                            Self::powf(self, n: Self) -> Self;
                            Self::sqrt(self) -> Self;
                            Self::exp(self) -> Self;
                            Self::exp2(self) -> Self;
                            Self::ln(self) -> Self;
                            Self::log(self, base: Self) -> Self;
                            Self::log2(self) -> Self;
                            Self::log10(self) -> Self;
                            Self::to_degrees(self) -> Self;
                            Self::to_radians(self) -> Self;
                            Self::max(self, other: Self) -> Self;
                            Self::min(self, other: Self) -> Self;
                            Self::cbrt(self) -> Self;
                            Self::hypot(self, other: Self) -> Self;
                            Self::sin(self) -> Self;
                            Self::cos(self) -> Self;
                            Self::tan(self) -> Self;
                            Self::asin(self) -> Self;
                            Self::acos(self) -> Self;
                            Self::atan(self) -> Self;
                            Self::atan2(self, other: Self) -> Self;
                            Self::sin_cos(self) -> (Self, Self);
                            Self::exp_m1(self) -> Self;
                            Self::ln_1p(self) -> Self;
                            Self::sinh(self) -> Self;
                            Self::cosh(self) -> Self;
                            Self::tanh(self) -> Self;
                            Self::asinh(self) -> Self;
                            Self::acosh(self) -> Self;
                            Self::atanh(self) -> Self;
                            Self::copysign(self, sign: Self) -> Self;
                        }
                    }
                };
            }
            
            fn integer_decode_f32(f: f32) -> (u64, i16, i8) {
                let bits: u32 = f.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0x7fffff) << 1
                } else {
                    (bits & 0x7fffff) | 0x800000
                };
                
                exponent -= 127 + 23;
                (mantissa as u64, exponent, sign)
            }

            fn integer_decode_f64(f: f64) -> (u64, i16, i8) {
                let bits: u64 = f.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0xfffffffffffff) << 1
                } else {
                    (bits & 0xfffffffffffff) | 0x10000000000000
                };
                
                exponent -= 1023 + 52;
                (mantissa, exponent, sign)
            }
            
            float_impl_std!(f32 integer_decode_f32);
            
            float_impl_std!(f64 integer_decode_f64);

            macro_rules! float_const_impl
            {
                ($(#[$doc:meta] $constant:ident,)+) => (
                    #[allow(non_snake_case)]
                    pub trait FloatConst {
                        $(#[$doc] fn $constant() -> Self;)+
                        #[doc = "Return the full circle constant ``."]
                        #[inline] fn TAU() -> Self where Self: Sized + Add<Self, Output = Self> {
                            Self::PI() + Self::PI()
                        }
                        #[doc = "Return `log10(2.0)`."]
                        #[inline] fn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_2() / Self::LN_10()
                        }
                        #[doc = "Return `log2(10.0)`."]
                        #[inline] fn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_10() / Self::LN_2()
                        }
                    }
                    float_const_impl! { @float f32, $($constant,)+ }
                    float_const_impl! { @float f64, $($constant,)+ }
                );
                (@float $T:ident, $($constant:ident,)+) => (
                    impl FloatConst for $T {
                        constant! {
                            $( $constant() -> std::$T::consts::$constant; )+
                            TAU() -> 6.28318530717958647692528676655900577;
                            LOG10_2() -> 0.301029995663981195213738894724493027;
                            LOG2_10() -> 3.32192809488736234787031942948939018;
                        }
                    }
                );
            }

            float_const_impl! {
                #[doc = "Return Eulers number."]
                E,
                #[doc = "Return `1.0 / `."]
                FRAC_1_PI,
                #[doc = "Return `1.0 / sqrt(2.0)`."]
                FRAC_1_SQRT_2,
                #[doc = "Return `2.0 / `."]
                FRAC_2_PI,
                #[doc = "Return `2.0 / sqrt()`."]
                FRAC_2_SQRT_PI,
                #[doc = "Return ` / 2.0`."]
                FRAC_PI_2,
                #[doc = "Return ` / 3.0`."]
                FRAC_PI_3,
                #[doc = "Return ` / 4.0`."]
                FRAC_PI_4,
                #[doc = "Return ` / 6.0`."]
                FRAC_PI_6,
                #[doc = "Return ` / 8.0`."]
                FRAC_PI_8,
                #[doc = "Return `ln(10.0)`."]
                LN_10,
                #[doc = "Return `ln(2.0)`."]
                LN_2,
                #[doc = "Return `log10(e)`."]
                LOG10_E,
                #[doc = "Return `log2(e)`."]
                LOG2_E,
                #[doc = "Return Archimedes constant ``."]
                PI,
                #[doc = "Return `sqrt(2.0)`."]
                SQRT_2,
            }
            /// Trait for floating point numbers that provide an implementation
            /// of the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
            /// floating point standard.
            pub trait TotalOrder 
            {
                /// Return the ordering between `self` and `other`.
                fn total_cmp(&self, other: &Self) -> Ordering;
            }

            macro_rules! totalorder_impl {
                ($T:ident, $I:ident, $U:ident, $bits:expr) => {
                    impl TotalOrder for $T {
                        #[inline]
                        #[cfg(has_total_cmp)]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                            Self::total_cmp(&self, other)
                        }
                        #[inline]
                        #[cfg(not(has_total_cmp))]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                            let mut left = self.to_bits() as $I;
                            let mut right = other.to_bits() as $I;

                            left ^= (((left >> ($bits - 1)) as $U) >> 1) as $I;
                            right ^= (((right >> ($bits - 1)) as $U) >> 1) as $I;

                            left.cmp(&right)
                        }
                    }
                };
            }
            totalorder_impl!(f64, i64, u64, 64);
            totalorder_impl!(f32, i32, u32, 32);
        } pub use self::float::{ * };

        pub mod identities
        {
            use ::
            {
                num::
                {
                    Wrapping 
                },
                ops::{ Add, Mul },
                *,
            };
            /// Defines an additive identity element for `Self`.
            pub trait Zero: Sized + Add<Self, Output = Self> {
                /// Returns the additive identity element of `Self`, `0`.
                fn zero() -> Self;
                /// Sets `self` to the additive identity element of `Self`, `0`.
                fn set_zero(&mut self) {
                    *self = Zero::zero();
                }
                /// Returns `true` if `self` is equal to the additive identity.
                fn is_zero(&self) -> bool;
            }
            /// Defines an associated constant representing the additive identity element
            /// for `Self`.
            pub trait ConstZero: Zero {
                /// The additive identity element of `Self`, `0`.
                const ZERO: Self;
            }

            macro_rules! zero_impl {
                ($t:ty, $v:expr) => {
                    impl Zero for $t {
                        #[inline] fn zero() -> $t {
                            $v
                        }
                        #[inline] fn is_zero(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstZero for $t {
                        const ZERO: Self = $v;
                    }
                };
            }

            zero_impl!(usize, 0);
            zero_impl!(u8, 0);
            zero_impl!(u16, 0);
            zero_impl!(u32, 0);
            zero_impl!(u64, 0);
            zero_impl!(u128, 0);

            zero_impl!(isize, 0);
            zero_impl!(i8, 0);
            zero_impl!(i16, 0);
            zero_impl!(i32, 0);
            zero_impl!(i64, 0);
            zero_impl!(i128, 0);

            zero_impl!(f32, 0.0);
            zero_impl!(f64, 0.0);

            impl<T: Zero> Zero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                fn is_zero(&self) -> bool {
                    self.0.is_zero()
                }

                fn set_zero(&mut self) {
                    self.0.set_zero();
                }

                fn zero() -> Self {
                    Wrapping(T::zero())
                }
            }

            impl<T: ConstZero> ConstZero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                const ZERO: Self = Wrapping(T::ZERO);
            }
            /// Defines a multiplicative identity element for `Self`.
            pub trait One: Sized + Mul<Self, Output = Self> {
                /// Returns the multiplicative identity element of `Self`, `1`.
                fn one() -> Self;
                /// Sets `self` to the multiplicative identity element of `Self`, `1`.
                fn set_one(&mut self) {
                    *self = One::one();
                }
                /// Returns `true` if `self` is equal to the multiplicative identity.
                #[inline] fn is_one(&self) -> bool
                where
                    Self: PartialEq,
                {
                    *self == Self::one()
                }
            }
            /// Defines an associated constant representing the multiplicative identity
            /// element for `Self`.
            pub trait ConstOne: One {
                /// The multiplicative identity element of `Self`, `1`.
                const ONE: Self;
            }

            macro_rules! one_impl {
                ($t:ty, $v:expr) => {
                    impl One for $t {
                        #[inline] fn one() -> $t {
                            $v
                        }
                        #[inline] fn is_one(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstOne for $t {
                        const ONE: Self = $v;
                    }
                };
            }

            one_impl!(usize, 1);
            one_impl!(u8, 1);
            one_impl!(u16, 1);
            one_impl!(u32, 1);
            one_impl!(u64, 1);
            one_impl!(u128, 1);

            one_impl!(isize, 1);
            one_impl!(i8, 1);
            one_impl!(i16, 1);
            one_impl!(i32, 1);
            one_impl!(i64, 1);
            one_impl!(i128, 1);

            one_impl!(f32, 1.0);
            one_impl!(f64, 1.0);

            impl<T: One> One for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                fn set_one(&mut self) {
                    self.0.set_one();
                }

                fn one() -> Self {
                    Wrapping(T::one())
                }
            }

            impl<T: ConstOne> ConstOne for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                const ONE: Self = Wrapping(T::ONE);
            }
            /// Returns the additive identity, `0`.
            #[inline( always )] pub fn zero<T: Zero>() -> T
                {    Zero::zero()
            }
            /// Returns the multiplicative identity, `1`.
            #[inline( always )] pub fn one<T: One>() -> T
                {    One::one()
            }
        } pub use self::identities::{ * };

        pub mod int
        {
            use ::
            {
                num::
                { 
                    traits::
                    {
                        bounds::Bounded,
                        ops::checked::*,
                        ops::saturating::Saturating,
                        Num, NumCast,
                    },
                    Wrapping 
                },
                ops::{ BitAnd, BitOr, BitXor, Not, Shl, Shr },
                *,
            };
            /// Generic trait for primitive integers.
            pub trait PrimInt:
                Sized
                + Copy
                + Num
                + NumCast
                + Bounded
                + PartialOrd
                + Ord
                + Eq
                + Not<Output = Self>
                + BitAnd<Output = Self>
                + BitOr<Output = Self>
                + BitXor<Output = Self>
                + Shl<usize, Output = Self>
                + Shr<usize, Output = Self>
                + CheckedAdd<Output = Self>
                + CheckedSub<Output = Self>
                + CheckedMul<Output = Self>
                + CheckedDiv<Output = Self>
                + Saturating
            {
                /// Returns the number of ones in the binary representation of `self`.
                fn count_ones(self) -> u32;
                /// Returns the number of zeros in the binary representation of `self`.
                fn count_zeros(self) -> u32;
                /// Returns the number of leading ones in the binary representation
                /// of `self`.
                fn leading_ones(self) -> u32 {
                    (!self).leading_zeros()
                }
                /// Returns the number of leading zeros in the binary representation
                /// of `self`.
                fn leading_zeros(self) -> u32;
                /// Returns the number of trailing ones in the binary representation
                /// of `self`.
                fn trailing_ones(self) -> u32 {
                    (!self).trailing_zeros()
                }
                /// Returns the number of trailing zeros in the binary representation
                /// of `self`.
                fn trailing_zeros(self) -> u32;
                /// Shifts the bits to the left by a specified amount, `n`, wrapping
                /// the truncated bits to the end of the resulting integer.
                fn rotate_left(self, n: u32) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, wrapping
                /// the truncated bits to the beginning of the resulting integer.
                fn rotate_right(self, n: u32) -> Self;
                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                fn signed_shl(self, n: u32) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, copying
                /// the "sign bit" in the most significant bits even for unsigned types.
                fn signed_shr(self, n: u32) -> Self;
                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                fn unsigned_shl(self, n: u32) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, filling
                /// zeros in the most significant bits.
                fn unsigned_shr(self, n: u32) -> Self;
                /// Reverses the byte order of the integer.
                fn swap_bytes(self) -> Self;
                /// Reverses the order of bits in the integer.
                fn reverse_bits(self) -> Self {
                    reverse_bits_fallback(self)
                }
                /// Convert an integer from big endian to the target's endianness.
                fn from_be(x: Self) -> Self;
                /// Convert an integer from little endian to the target's endianness.
                fn from_le(x: Self) -> Self;
                /// Convert `self` to big endian from the target's endianness.
                fn to_be(self) -> Self;
                /// Convert `self` to little endian from the target's endianness. 
                fn to_le(self) -> Self;
                /// Raises self to the power of `exp`, using exponentiation by squaring.
                fn pow(self, exp: u32) -> Self;
            }

            fn one_per_byte<P: PrimInt>() -> P {
                let mut ret = P::one();
                let mut shift = 8;
                let mut b = ret.count_zeros() >> 3;
                while b != 0 {
                    ret = (ret << shift) | ret;
                    shift <<= 1;
                    b >>= 1;
                }
                ret
            }

            fn reverse_bits_fallback<P: PrimInt>(i: P) -> P {
                let rep_01: P = one_per_byte();
                let rep_03 = (rep_01 << 1) | rep_01;
                let rep_05 = (rep_01 << 2) | rep_01;
                let rep_0f = (rep_03 << 2) | rep_03;
                let rep_33 = (rep_03 << 4) | rep_03;
                let rep_55 = (rep_05 << 4) | rep_05;
                let mut ret = i.swap_bytes();
                ret = ((ret & rep_0f) << 4) | ((ret >> 4) & rep_0f);
                ret = ((ret & rep_33) << 2) | ((ret >> 2) & rep_33);
                ret = ((ret & rep_55) << 1) | ((ret >> 1) & rep_55);
                ret
            }

            macro_rules! prim_int_impl {
                ($T:ty, $S:ty, $U:ty) => {
                    impl PrimInt for $T {
                        #[inline] fn count_ones(self) -> u32 {
                            <$T>::count_ones(self)
                        }

                        #[inline] fn count_zeros(self) -> u32 {
                            <$T>::count_zeros(self)
                        }

                        #[inline] fn leading_ones(self) -> u32 {
                            <$T>::leading_ones(self)
                        }

                        #[inline] fn leading_zeros(self) -> u32 {
                            <$T>::leading_zeros(self)
                        }

                        #[inline] fn trailing_ones(self) -> u32 {
                            <$T>::trailing_ones(self)
                        }

                        #[inline] fn trailing_zeros(self) -> u32 {
                            <$T>::trailing_zeros(self)
                        }

                        #[inline] fn rotate_left(self, n: u32) -> Self {
                            <$T>::rotate_left(self, n)
                        }

                        #[inline] fn rotate_right(self, n: u32) -> Self {
                            <$T>::rotate_right(self, n)
                        }

                        #[inline] fn signed_shl(self, n: u32) -> Self {
                            ((self as $S) << n) as $T
                        }

                        #[inline] fn signed_shr(self, n: u32) -> Self {
                            ((self as $S) >> n) as $T
                        }

                        #[inline] fn unsigned_shl(self, n: u32) -> Self {
                            ((self as $U) << n) as $T
                        }

                        #[inline] fn unsigned_shr(self, n: u32) -> Self {
                            ((self as $U) >> n) as $T
                        }

                        #[inline] fn swap_bytes(self) -> Self {
                            <$T>::swap_bytes(self)
                        }

                        #[inline] fn reverse_bits(self) -> Self {
                            <$T>::reverse_bits(self)
                        }

                        #[inline] fn from_be(x: Self) -> Self {
                            <$T>::from_be(x)
                        }

                        #[inline] fn from_le(x: Self) -> Self {
                            <$T>::from_le(x)
                        }

                        #[inline] fn to_be(self) -> Self {
                            <$T>::to_be(self)
                        }

                        #[inline] fn to_le(self) -> Self {
                            <$T>::to_le(self)
                        }

                        #[inline] fn pow(self, exp: u32) -> Self {
                            <$T>::pow(self, exp)
                        }
                    }
                };
            }

            prim_int_impl!(u8, i8, u8);
            prim_int_impl!(u16, i16, u16);
            prim_int_impl!(u32, i32, u32);
            prim_int_impl!(u64, i64, u64);
            prim_int_impl!(u128, i128, u128);
            prim_int_impl!(usize, isize, usize);
            prim_int_impl!(i8, i8, u8);
            prim_int_impl!(i16, i16, u16);
            prim_int_impl!(i32, i32, u32);
            prim_int_impl!(i64, i64, u64);
            prim_int_impl!(i128, i128, u128);
            prim_int_impl!(isize, isize, usize);
        } pub use self::int::{ * };

        pub mod ops
        {
            pub mod bytes
            {
                use ::
                {
                    borrow::{Borrow, BorrowMut},
                    cmp::{Eq, Ord, PartialEq, PartialOrd},
                    fmt::Debug,
                    hash::Hash,
                    *,
                };
                
                pub trait NumBytes:
                    Debug
                    + AsRef<[u8]>
                    + AsMut<[u8]>
                    + PartialEq
                    + Eq
                    + PartialOrd
                    + Ord
                    + Hash
                    + Borrow<[u8]>
                    + BorrowMut<[u8]>
                {
                }

                impl<T> NumBytes for T where
                    T: Debug
                        + AsRef<[u8]>
                        + AsMut<[u8]>
                        + PartialEq
                        + Eq
                        + PartialOrd
                        + Ord
                        + Hash
                        + Borrow<[u8]>
                        + BorrowMut<[u8]>
                        + ?Sized
                {
                }

                pub trait ToBytes {
                    type Bytes: NumBytes;

                    /// Return the memory representation of this number as a byte array in big-endian byte order.
                    fn to_be_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in little-endian byte order.
                    fn to_le_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in native byte order.
                    fn to_ne_bytes(&self) -> Self::Bytes {
                        #[cfg(target_endian = "big")]
                        let bytes = self.to_be_bytes();
                        #[cfg(target_endian = "little")]
                        let bytes = self.to_le_bytes();
                        bytes
                    }
                }

                pub trait FromBytes: Sized {
                    type Bytes: NumBytes + ?Sized;

                    /// Create a number from its representation as a byte array in big endian.
                    fn from_be_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its representation as a byte array in little endian.
                    fn from_le_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its memory representation as a byte array in native endianness.
                    fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                        #[cfg(target_endian = "big")]
                        let this = Self::from_be_bytes(bytes);
                        #[cfg(target_endian = "little")]
                        let this = Self::from_le_bytes(bytes);
                        this
                    }
                }

                macro_rules! float_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                macro_rules! int_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                int_to_from_bytes_impl!(u8, 1);
                int_to_from_bytes_impl!(u16, 2);
                int_to_from_bytes_impl!(u32, 4);
                int_to_from_bytes_impl!(u64, 8);
                int_to_from_bytes_impl!(u128, 16);
                int_to_from_bytes_impl!(usize, 8);

                int_to_from_bytes_impl!(i8, 1);
                int_to_from_bytes_impl!(i16, 2);
                int_to_from_bytes_impl!(i32, 4);
                int_to_from_bytes_impl!(i64, 8);
                int_to_from_bytes_impl!(i128, 16);
                int_to_from_bytes_impl!(isize, 8);

                float_to_from_bytes_impl!(f32, 4);
                float_to_from_bytes_impl!(f64, 8);
            } pub use self::bytes::{ * };
            
            pub mod checked
            {
                use ::
                {
                    ops::{Add, Div, Mul, Rem, Shl, Shr, Sub},
                    *,
                };
                /// Performs addition, returning `None` if overflow occurred.
                pub trait CheckedAdd: Sized + Add<Self, Output = Self> {
                    /// Adds two numbers, checking for overflow. If overflow happens, `None` is
                    /// returned.
                    fn checked_add(&self, v: &Self) -> Option<Self>;
                }

                macro_rules! checked_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &$t) -> Option<$t> {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                checked_impl!(CheckedAdd, checked_add, u8);
                checked_impl!(CheckedAdd, checked_add, u16);
                checked_impl!(CheckedAdd, checked_add, u32);
                checked_impl!(CheckedAdd, checked_add, u64);
                checked_impl!(CheckedAdd, checked_add, usize);
                checked_impl!(CheckedAdd, checked_add, u128);

                checked_impl!(CheckedAdd, checked_add, i8);
                checked_impl!(CheckedAdd, checked_add, i16);
                checked_impl!(CheckedAdd, checked_add, i32);
                checked_impl!(CheckedAdd, checked_add, i64);
                checked_impl!(CheckedAdd, checked_add, isize);
                checked_impl!(CheckedAdd, checked_add, i128);
                /// Performs subtraction, returning `None` if overflow occurred.
                pub trait CheckedSub: Sized + Sub<Self, Output = Self> {
                    /// Subtracts two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_sub(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedSub, checked_sub, u8);
                checked_impl!(CheckedSub, checked_sub, u16);
                checked_impl!(CheckedSub, checked_sub, u32);
                checked_impl!(CheckedSub, checked_sub, u64);
                checked_impl!(CheckedSub, checked_sub, usize);
                checked_impl!(CheckedSub, checked_sub, u128);

                checked_impl!(CheckedSub, checked_sub, i8);
                checked_impl!(CheckedSub, checked_sub, i16);
                checked_impl!(CheckedSub, checked_sub, i32);
                checked_impl!(CheckedSub, checked_sub, i64);
                checked_impl!(CheckedSub, checked_sub, isize);
                checked_impl!(CheckedSub, checked_sub, i128);
                /// Performs multiplication, returning `None` if overflow occurred.
                pub trait CheckedMul: Sized + Mul<Self, Output = Self> {
                    /// Multiplies two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_mul(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedMul, checked_mul, u8);
                checked_impl!(CheckedMul, checked_mul, u16);
                checked_impl!(CheckedMul, checked_mul, u32);
                checked_impl!(CheckedMul, checked_mul, u64);
                checked_impl!(CheckedMul, checked_mul, usize);
                checked_impl!(CheckedMul, checked_mul, u128);

                checked_impl!(CheckedMul, checked_mul, i8);
                checked_impl!(CheckedMul, checked_mul, i16);
                checked_impl!(CheckedMul, checked_mul, i32);
                checked_impl!(CheckedMul, checked_mul, i64);
                checked_impl!(CheckedMul, checked_mul, isize);
                checked_impl!(CheckedMul, checked_mul, i128);
                /// Performs division, returning `None` on division by zero or if overflow
                /// occurred.
                pub trait CheckedDiv: Sized + Div<Self, Output = Self> {
                    /// Divides two numbers, checking for overflow and division by
                    /// zero. If any of that happens, `None` is returned.
                    fn checked_div(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedDiv, checked_div, u8);
                checked_impl!(CheckedDiv, checked_div, u16);
                checked_impl!(CheckedDiv, checked_div, u32);
                checked_impl!(CheckedDiv, checked_div, u64);
                checked_impl!(CheckedDiv, checked_div, usize);
                checked_impl!(CheckedDiv, checked_div, u128);

                checked_impl!(CheckedDiv, checked_div, i8);
                checked_impl!(CheckedDiv, checked_div, i16);
                checked_impl!(CheckedDiv, checked_div, i32);
                checked_impl!(CheckedDiv, checked_div, i64);
                checked_impl!(CheckedDiv, checked_div, isize);
                checked_impl!(CheckedDiv, checked_div, i128);
                /// Performs integral remainder, returning `None` on division by zero or if
                /// overflow occurred.
                pub trait CheckedRem: Sized + Rem<Self, Output = Self> {
                    /// Finds the remainder of dividing two numbers, checking for overflow and
                    /// division by zero. If any of that happens, `None` is returned.
                    fn checked_rem(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedRem, checked_rem, u8);
                checked_impl!(CheckedRem, checked_rem, u16);
                checked_impl!(CheckedRem, checked_rem, u32);
                checked_impl!(CheckedRem, checked_rem, u64);
                checked_impl!(CheckedRem, checked_rem, usize);
                checked_impl!(CheckedRem, checked_rem, u128);

                checked_impl!(CheckedRem, checked_rem, i8);
                checked_impl!(CheckedRem, checked_rem, i16);
                checked_impl!(CheckedRem, checked_rem, i32);
                checked_impl!(CheckedRem, checked_rem, i64);
                checked_impl!(CheckedRem, checked_rem, isize);
                checked_impl!(CheckedRem, checked_rem, i128);

                macro_rules! checked_impl_unary {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> Option<$t> {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }
                /// Performs negation, returning `None` if the result can't be represented.
                pub trait CheckedNeg: Sized {
                    /// Negates a number, returning `None` for results that can't be represented, like signed `MIN`
                    /// values that can't be positive, or non-zero unsigned values that can't be negative.
                    fn checked_neg(&self) -> Option<Self>;
                }

                checked_impl_unary!(CheckedNeg, checked_neg, u8);
                checked_impl_unary!(CheckedNeg, checked_neg, u16);
                checked_impl_unary!(CheckedNeg, checked_neg, u32);
                checked_impl_unary!(CheckedNeg, checked_neg, u64);
                checked_impl_unary!(CheckedNeg, checked_neg, usize);
                checked_impl_unary!(CheckedNeg, checked_neg, u128);

                checked_impl_unary!(CheckedNeg, checked_neg, i8);
                checked_impl_unary!(CheckedNeg, checked_neg, i16);
                checked_impl_unary!(CheckedNeg, checked_neg, i32);
                checked_impl_unary!(CheckedNeg, checked_neg, i64);
                checked_impl_unary!(CheckedNeg, checked_neg, isize);
                checked_impl_unary!(CheckedNeg, checked_neg, i128);
                /// Performs shift left, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShl: Sized + Shl<u32, Output = Self> {
                    /// Checked shift left. Computes `self << rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    fn checked_shl(&self, rhs: u32) -> Option<Self>;
                }

                macro_rules! checked_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> Option<$t> {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }

                checked_shift_impl!(CheckedShl, checked_shl, u8);
                checked_shift_impl!(CheckedShl, checked_shl, u16);
                checked_shift_impl!(CheckedShl, checked_shl, u32);
                checked_shift_impl!(CheckedShl, checked_shl, u64);
                checked_shift_impl!(CheckedShl, checked_shl, usize);
                checked_shift_impl!(CheckedShl, checked_shl, u128);

                checked_shift_impl!(CheckedShl, checked_shl, i8);
                checked_shift_impl!(CheckedShl, checked_shl, i16);
                checked_shift_impl!(CheckedShl, checked_shl, i32);
                checked_shift_impl!(CheckedShl, checked_shl, i64);
                checked_shift_impl!(CheckedShl, checked_shl, isize);
                checked_shift_impl!(CheckedShl, checked_shl, i128);
                /// Performs shift right, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShr: Sized + Shr<u32, Output = Self> {
                    /// Checked shift right. Computes `self >> rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    fn checked_shr(&self, rhs: u32) -> Option<Self>;
                }

                checked_shift_impl!(CheckedShr, checked_shr, u8);
                checked_shift_impl!(CheckedShr, checked_shr, u16);
                checked_shift_impl!(CheckedShr, checked_shr, u32);
                checked_shift_impl!(CheckedShr, checked_shr, u64);
                checked_shift_impl!(CheckedShr, checked_shr, usize);
                checked_shift_impl!(CheckedShr, checked_shr, u128);

                checked_shift_impl!(CheckedShr, checked_shr, i8);
                checked_shift_impl!(CheckedShr, checked_shr, i16);
                checked_shift_impl!(CheckedShr, checked_shr, i32);
                checked_shift_impl!(CheckedShr, checked_shr, i64);
                checked_shift_impl!(CheckedShr, checked_shr, isize);
                checked_shift_impl!(CheckedShr, checked_shr, i128);
            } pub use self::checked::{ * };
            
            pub mod euclid
            {
                use ::
                {
                    ops::{Div, Rem},
                    *,
                };
                
                pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {
                    /// Calculates Euclidean division, the matching method for `rem_euclid`.
                    fn div_euclid(&self, v: &Self) -> Self;

                    /// Calculates the least nonnegative remainder of `self (mod v)`.
                    fn rem_euclid(&self, v: &Self) -> Self;

                    /// Returns both the quotient and remainder from Euclidean division.
                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        (self.div_euclid(v), self.rem_euclid(v))
                    }
                }

                macro_rules! euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl Euclid for $t {
                            #[inline]
                            fn div_euclid(&self, v: &$t) -> Self {
                                <$t>::div_euclid(*self, *v)
                            }

                            #[inline]
                            fn rem_euclid(&self, v: &$t) -> Self {
                                <$t>::rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                euclid_forward_impl!(usize u8 u16 u32 u64 u128);
                euclid_forward_impl!(f32 f64);

                pub trait CheckedEuclid: Euclid {
                    /// Performs euclid division, returning `None` on division by zero or if
                    /// overflow occurred.
                    fn checked_div_euclid(&self, v: &Self) -> Option<Self>;

                    /// Finds the euclid remainder of dividing two numbers, returning `None` on
                    /// division by zero or if overflow occurred.
                    fn checked_rem_euclid(&self, v: &Self) -> Option<Self>;

                    /// Returns both the quotient and remainder from checked Euclidean division,
                    /// returning `None` on division by zero or if overflow occurred.
                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some((self.checked_div_euclid(v)?, self.checked_rem_euclid(v)?))
                    }
                }

                macro_rules! checked_euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl CheckedEuclid for $t {
                            #[inline]
                            fn checked_div_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_div_euclid(*self, *v)
                            }

                            #[inline]
                            fn checked_rem_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                checked_euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                checked_euclid_forward_impl!(usize u8 u16 u32 u64 u128);
            } pub use self::euclid::{ * };
            
            pub mod inv
            {
                use ::
                {
                    *,
                };
                /// Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.
                pub trait Inv {
                    /// The result after applying the operator.
                    type Output;

                    /// Returns the multiplicative inverse of `self`.
                    fn inv(self) -> Self::Output;
                }

                impl Inv for f32 {
                    type Output = f32;
                    #[inline] fn inv(self) -> f32 {
                        1.0 / self
                    }
                }
                impl Inv for f64 {
                    type Output = f64;
                    #[inline] fn inv(self) -> f64 {
                        1.0 / self
                    }
                }
                impl<'a> Inv for &'a f32 {
                    type Output = f32;
                    #[inline] fn inv(self) -> f32 {
                        1.0 / *self
                    }
                }
                impl<'a> Inv for &'a f64 {
                    type Output = f64;
                    #[inline] fn inv(self) -> f64 {
                        1.0 / *self
                    }
                }
            } pub use self::inv::{ * };
            
            pub mod mul_add
            {
                use ::
                {
                    *,
                };
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                pub trait MulAdd<A = Self, B = Self> {
                    /// The resulting type after applying the fused multiply-add.
                    type Output;

                    /// Performs the fused multiply-add operation `(self * a) + b`
                    fn mul_add(self, a: A, b: B) -> Self::Output;
                }
                /// The fused multiply-add assignment operation `*self = (*self * a) + b`
                pub trait MulAddAssign<A = Self, B = Self> {
                    /// Performs the fused multiply-add assignment operation `*self = (*self * a) + b`
                    fn mul_add_assign(&mut self, a: A, b: B);
                }
                
                impl MulAdd<f32, f32> for f32 {
                    type Output = Self;

                    #[inline] fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add(self, a, b)
                    }
                }
                
                impl MulAdd<f64, f64> for f64 {
                    type Output = Self;

                    #[inline] fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add(self, a, b)
                    }
                }

                macro_rules! mul_add_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            type Output = Self;

                            #[inline]
                            fn mul_add(self, a: Self, b: Self) -> Self::Output {
                                (self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_impl!(MulAdd for isize i8 i16 i32 i64 i128);
                mul_add_impl!(MulAdd for usize u8 u16 u32 u64 u128);
                
                impl MulAddAssign<f32, f32> for f32 {
                    #[inline] fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as ::num::traits::Float>::mul_add(*self, a, b)
                    }
                }
                
                impl MulAddAssign<f64, f64> for f64 {
                    #[inline] fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as ::num::traits::Float>::mul_add(*self, a, b)
                    }
                }

                macro_rules! mul_add_assign_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn mul_add_assign(&mut self, a: Self, b: Self) {
                                *self = (*self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_assign_impl!(MulAddAssign for isize i8 i16 i32 i64 i128);
                mul_add_assign_impl!(MulAddAssign for usize u8 u16 u32 u64 u128);
            } pub use self::mul_add::{ * };
            
            pub mod overflowing
            {
                use ::
                {
                    ops::{ Add, Mul, Sub },
                    *,
                };

                macro_rules! overflowing_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> (Self, bool) {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }
                /// Performs addition with a flag for overflow.
                pub trait OverflowingAdd: Sized + Add<Self, Output = Self> {
                    /// Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_add(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingAdd, overflowing_add, u8);
                overflowing_impl!(OverflowingAdd, overflowing_add, u16);
                overflowing_impl!(OverflowingAdd, overflowing_add, u32);
                overflowing_impl!(OverflowingAdd, overflowing_add, u64);
                overflowing_impl!(OverflowingAdd, overflowing_add, usize);
                overflowing_impl!(OverflowingAdd, overflowing_add, u128);

                overflowing_impl!(OverflowingAdd, overflowing_add, i8);
                overflowing_impl!(OverflowingAdd, overflowing_add, i16);
                overflowing_impl!(OverflowingAdd, overflowing_add, i32);
                overflowing_impl!(OverflowingAdd, overflowing_add, i64);
                overflowing_impl!(OverflowingAdd, overflowing_add, isize);
                overflowing_impl!(OverflowingAdd, overflowing_add, i128);
                /// Performs substraction with a flag for overflow.
                pub trait OverflowingSub: Sized + Sub<Self, Output = Self> {
                    /// Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_sub(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingSub, overflowing_sub, u8);
                overflowing_impl!(OverflowingSub, overflowing_sub, u16);
                overflowing_impl!(OverflowingSub, overflowing_sub, u32);
                overflowing_impl!(OverflowingSub, overflowing_sub, u64);
                overflowing_impl!(OverflowingSub, overflowing_sub, usize);
                overflowing_impl!(OverflowingSub, overflowing_sub, u128);

                overflowing_impl!(OverflowingSub, overflowing_sub, i8);
                overflowing_impl!(OverflowingSub, overflowing_sub, i16);
                overflowing_impl!(OverflowingSub, overflowing_sub, i32);
                overflowing_impl!(OverflowingSub, overflowing_sub, i64);
                overflowing_impl!(OverflowingSub, overflowing_sub, isize);
                overflowing_impl!(OverflowingSub, overflowing_sub, i128);
                /// Performs multiplication with a flag for overflow.
                pub trait OverflowingMul: Sized + Mul<Self, Output = Self> {
                    /// Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_mul(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingMul, overflowing_mul, u8);
                overflowing_impl!(OverflowingMul, overflowing_mul, u16);
                overflowing_impl!(OverflowingMul, overflowing_mul, u32);
                overflowing_impl!(OverflowingMul, overflowing_mul, u64);
                overflowing_impl!(OverflowingMul, overflowing_mul, usize);
                overflowing_impl!(OverflowingMul, overflowing_mul, u128);

                overflowing_impl!(OverflowingMul, overflowing_mul, i8);
                overflowing_impl!(OverflowingMul, overflowing_mul, i16);
                overflowing_impl!(OverflowingMul, overflowing_mul, i32);
                overflowing_impl!(OverflowingMul, overflowing_mul, i64);
                overflowing_impl!(OverflowingMul, overflowing_mul, isize);
                overflowing_impl!(OverflowingMul, overflowing_mul, i128);
            } pub use self::overflowing::{ * };
            
            pub mod saturating
            {
                use ::
                {
                    ops::{Add, Mul, Sub},
                    *,
                };
                /// Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and
                /// `SaturatingMul` instead.
                pub trait Saturating {
                    /// Saturating addition operator.
                    /// Returns a+b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_add(self, v: Self) -> Self;

                    /// Saturating subtraction operator.
                    /// Returns a-b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_sub(self, v: Self) -> Self;
                }

                macro_rules! deprecated_saturating_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn saturating_add(self, v: Self) -> Self {
                                Self::saturating_add(self, v)
                            }

                            #[inline]
                            fn saturating_sub(self, v: Self) -> Self {
                                Self::saturating_sub(self, v)
                            }
                        }
                    )*}
                }

                deprecated_saturating_impl!(Saturating for isize i8 i16 i32 i64 i128);
                deprecated_saturating_impl!(Saturating for usize u8 u16 u32 u64 u128);

                macro_rules! saturating_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }
                /// Performs addition that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingAdd: Sized + Add<Self, Output = Self> {
                    /// Saturating addition. Computes `self + other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_add(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingAdd, saturating_add, u8);
                saturating_impl!(SaturatingAdd, saturating_add, u16);
                saturating_impl!(SaturatingAdd, saturating_add, u32);
                saturating_impl!(SaturatingAdd, saturating_add, u64);
                saturating_impl!(SaturatingAdd, saturating_add, usize);
                saturating_impl!(SaturatingAdd, saturating_add, u128);

                saturating_impl!(SaturatingAdd, saturating_add, i8);
                saturating_impl!(SaturatingAdd, saturating_add, i16);
                saturating_impl!(SaturatingAdd, saturating_add, i32);
                saturating_impl!(SaturatingAdd, saturating_add, i64);
                saturating_impl!(SaturatingAdd, saturating_add, isize);
                saturating_impl!(SaturatingAdd, saturating_add, i128);
                /// Performs subtraction that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingSub: Sized + Sub<Self, Output = Self> {
                    /// Saturating subtraction. Computes `self - other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_sub(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingSub, saturating_sub, u8);
                saturating_impl!(SaturatingSub, saturating_sub, u16);
                saturating_impl!(SaturatingSub, saturating_sub, u32);
                saturating_impl!(SaturatingSub, saturating_sub, u64);
                saturating_impl!(SaturatingSub, saturating_sub, usize);
                saturating_impl!(SaturatingSub, saturating_sub, u128);

                saturating_impl!(SaturatingSub, saturating_sub, i8);
                saturating_impl!(SaturatingSub, saturating_sub, i16);
                saturating_impl!(SaturatingSub, saturating_sub, i32);
                saturating_impl!(SaturatingSub, saturating_sub, i64);
                saturating_impl!(SaturatingSub, saturating_sub, isize);
                saturating_impl!(SaturatingSub, saturating_sub, i128);
                /// Performs multiplication that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingMul: Sized + Mul<Self, Output = Self> {
                    /// Saturating multiplication. Computes `self * other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_mul(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingMul, saturating_mul, u8);
                saturating_impl!(SaturatingMul, saturating_mul, u16);
                saturating_impl!(SaturatingMul, saturating_mul, u32);
                saturating_impl!(SaturatingMul, saturating_mul, u64);
                saturating_impl!(SaturatingMul, saturating_mul, usize);
                saturating_impl!(SaturatingMul, saturating_mul, u128);

                saturating_impl!(SaturatingMul, saturating_mul, i8);
                saturating_impl!(SaturatingMul, saturating_mul, i16);
                saturating_impl!(SaturatingMul, saturating_mul, i32);
                saturating_impl!(SaturatingMul, saturating_mul, i64);
                saturating_impl!(SaturatingMul, saturating_mul, isize);
                saturating_impl!(SaturatingMul, saturating_mul, i128);
            } pub use self::saturating::{ * };
            
            pub mod wrapping
            {
                use ::
                {
                    num::{ Wrapping },
                    ops::{Add, Mul, Neg, Shl, Shr, Sub},
                    *,
                };
                
                macro_rules! wrapping_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                    ($trait_name:ident, $method:ident, $t:ty, $rhs:ty) => {
                        impl $trait_name<$rhs> for $t {
                            #[inline]
                            fn $method(&self, v: &$rhs) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }
                /// Performs addition that wraps around on overflow.
                pub trait WrappingAdd: Sized + Add<Self, Output = Self> {
                    /// Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of
                    /// the type.
                    fn wrapping_add(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingAdd, wrapping_add, u8);
                wrapping_impl!(WrappingAdd, wrapping_add, u16);
                wrapping_impl!(WrappingAdd, wrapping_add, u32);
                wrapping_impl!(WrappingAdd, wrapping_add, u64);
                wrapping_impl!(WrappingAdd, wrapping_add, usize);
                wrapping_impl!(WrappingAdd, wrapping_add, u128);

                wrapping_impl!(WrappingAdd, wrapping_add, i8);
                wrapping_impl!(WrappingAdd, wrapping_add, i16);
                wrapping_impl!(WrappingAdd, wrapping_add, i32);
                wrapping_impl!(WrappingAdd, wrapping_add, i64);
                wrapping_impl!(WrappingAdd, wrapping_add, isize);
                wrapping_impl!(WrappingAdd, wrapping_add, i128);
                /// Performs subtraction that wraps around on overflow.
                pub trait WrappingSub: Sized + Sub<Self, Output = Self> {
                    /// Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_sub(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingSub, wrapping_sub, u8);
                wrapping_impl!(WrappingSub, wrapping_sub, u16);
                wrapping_impl!(WrappingSub, wrapping_sub, u32);
                wrapping_impl!(WrappingSub, wrapping_sub, u64);
                wrapping_impl!(WrappingSub, wrapping_sub, usize);
                wrapping_impl!(WrappingSub, wrapping_sub, u128);

                wrapping_impl!(WrappingSub, wrapping_sub, i8);
                wrapping_impl!(WrappingSub, wrapping_sub, i16);
                wrapping_impl!(WrappingSub, wrapping_sub, i32);
                wrapping_impl!(WrappingSub, wrapping_sub, i64);
                wrapping_impl!(WrappingSub, wrapping_sub, isize);
                wrapping_impl!(WrappingSub, wrapping_sub, i128);
                /// Performs multiplication that wraps around on overflow.
                pub trait WrappingMul: Sized + Mul<Self, Output = Self> {
                    /// Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_mul(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingMul, wrapping_mul, u8);
                wrapping_impl!(WrappingMul, wrapping_mul, u16);
                wrapping_impl!(WrappingMul, wrapping_mul, u32);
                wrapping_impl!(WrappingMul, wrapping_mul, u64);
                wrapping_impl!(WrappingMul, wrapping_mul, usize);
                wrapping_impl!(WrappingMul, wrapping_mul, u128);

                wrapping_impl!(WrappingMul, wrapping_mul, i8);
                wrapping_impl!(WrappingMul, wrapping_mul, i16);
                wrapping_impl!(WrappingMul, wrapping_mul, i32);
                wrapping_impl!(WrappingMul, wrapping_mul, i64);
                wrapping_impl!(WrappingMul, wrapping_mul, isize);
                wrapping_impl!(WrappingMul, wrapping_mul, i128);

                macro_rules! wrapping_unary_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> $t {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }
                /// Performs a negation that does not panic.
                pub trait WrappingNeg: Sized {
                    /// Wrapping (modular) negation. Computes `-self`,
                    /// wrapping around at the boundary of the type.
                    fn wrapping_neg(&self) -> Self;
                }

                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, usize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u128);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, isize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i128);

                macro_rules! wrapping_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> $t {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }
                /// Performs a left shift that does not panic.
                pub trait WrappingShl: Sized + Shl<usize, Output = Self> {
                    /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    fn wrapping_shl(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShl, wrapping_shl, u8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, usize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u128);

                wrapping_shift_impl!(WrappingShl, wrapping_shl, i8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, isize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i128);
                /// Performs a right shift that does not panic.
                pub trait WrappingShr: Sized + Shr<usize, Output = Self> {
                    /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    fn wrapping_shr(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShr, wrapping_shr, u8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, usize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u128);

                wrapping_shift_impl!(WrappingShr, wrapping_shr, i8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, isize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i128);
                
                impl<T: WrappingAdd> WrappingAdd for Wrapping<T>
                where
                    Wrapping<T>: Add<Output = Wrapping<T>>,
                {
                    fn wrapping_add(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_add(&v.0))
                    }
                }
                impl<T: WrappingSub> WrappingSub for Wrapping<T>
                where
                    Wrapping<T>: Sub<Output = Wrapping<T>>,
                {
                    fn wrapping_sub(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_sub(&v.0))
                    }
                }
                impl<T: WrappingMul> WrappingMul for Wrapping<T>
                where
                    Wrapping<T>: Mul<Output = Wrapping<T>>,
                {
                    fn wrapping_mul(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_mul(&v.0))
                    }
                }
                impl<T: WrappingNeg> WrappingNeg for Wrapping<T>
                where
                    Wrapping<T>: Neg<Output = Wrapping<T>>,
                {
                    fn wrapping_neg(&self) -> Self {
                        Wrapping(self.0.wrapping_neg())
                    }
                }
                impl<T: WrappingShl> WrappingShl for Wrapping<T>
                where
                    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shl(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shl(rhs))
                    }
                }
                impl<T: WrappingShr> WrappingShr for Wrapping<T>
                where
                    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shr(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shr(rhs))
                    }
                }
            } pub use self::wrapping::{ * };
        } pub use self::ops::{ * };

        pub mod pow
        {
            use ::
            {
                num::
                { 
                    traits::
                    {
                        CheckedMul, One,
                    },
                    Wrapping 
                },
                ops::{ Mul },
                *,
            };
            /// Binary operator for raising a value to a power.
            pub trait Pow<RHS> 
            {
                /// The result after applying the operator.
                type Output;
                /// Returns `self` to the power `rhs`.
                fn pow(self, rhs: RHS) -> Self::Output;
            }

            macro_rules! pow_impl 
            {
                ($t:ty) => {
                    pow_impl!($t, u8);
                    pow_impl!($t, usize);
                };
                ($t:ty, $rhs:ty) => {
                    pow_impl!($t, $rhs, usize, pow);
                };
                ($t:ty, $rhs:ty, $desired_rhs:ty, $method:expr) => {
                    impl Pow<$rhs> for $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a> Pow<&'a $rhs> for $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(*rhs))
                        }
                    }

                    impl<'a> Pow<$rhs> for &'a $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a, 'b> Pow<&'a $rhs> for &'b $t {
                        type Output = $t;
                        #[inline] fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(*rhs))
                        }
                    }
                };
            }

            pow_impl!(u8, u8, u32, u8::pow);
            pow_impl!(u8, u16, u32, u8::pow);
            pow_impl!(u8, u32, u32, u8::pow);
            pow_impl!(u8, usize);
            pow_impl!(i8, u8, u32, i8::pow);
            pow_impl!(i8, u16, u32, i8::pow);
            pow_impl!(i8, u32, u32, i8::pow);
            pow_impl!(i8, usize);
            pow_impl!(u16, u8, u32, u16::pow);
            pow_impl!(u16, u16, u32, u16::pow);
            pow_impl!(u16, u32, u32, u16::pow);
            pow_impl!(u16, usize);
            pow_impl!(i16, u8, u32, i16::pow);
            pow_impl!(i16, u16, u32, i16::pow);
            pow_impl!(i16, u32, u32, i16::pow);
            pow_impl!(i16, usize);
            pow_impl!(u32, u8, u32, u32::pow);
            pow_impl!(u32, u16, u32, u32::pow);
            pow_impl!(u32, u32, u32, u32::pow);
            pow_impl!(u32, usize);
            pow_impl!(i32, u8, u32, i32::pow);
            pow_impl!(i32, u16, u32, i32::pow);
            pow_impl!(i32, u32, u32, i32::pow);
            pow_impl!(i32, usize);
            pow_impl!(u64, u8, u32, u64::pow);
            pow_impl!(u64, u16, u32, u64::pow);
            pow_impl!(u64, u32, u32, u64::pow);
            pow_impl!(u64, usize);
            pow_impl!(i64, u8, u32, i64::pow);
            pow_impl!(i64, u16, u32, i64::pow);
            pow_impl!(i64, u32, u32, i64::pow);
            pow_impl!(i64, usize);

            pow_impl!(u128, u8, u32, u128::pow);
            pow_impl!(u128, u16, u32, u128::pow);
            pow_impl!(u128, u32, u32, u128::pow);
            pow_impl!(u128, usize);

            pow_impl!(i128, u8, u32, i128::pow);
            pow_impl!(i128, u16, u32, i128::pow);
            pow_impl!(i128, u32, u32, i128::pow);
            pow_impl!(i128, usize);

            pow_impl!(usize, u8, u32, usize::pow);
            pow_impl!(usize, u16, u32, usize::pow);
            pow_impl!(usize, u32, u32, usize::pow);
            pow_impl!(usize, usize);
            pow_impl!(isize, u8, u32, isize::pow);
            pow_impl!(isize, u16, u32, isize::pow);
            pow_impl!(isize, u32, u32, isize::pow);
            pow_impl!(isize, usize);
            pow_impl!(Wrapping<u8>);
            pow_impl!(Wrapping<i8>);
            pow_impl!(Wrapping<u16>);
            pow_impl!(Wrapping<i16>);
            pow_impl!(Wrapping<u32>);
            pow_impl!(Wrapping<i32>);
            pow_impl!(Wrapping<u64>);
            pow_impl!(Wrapping<i64>);
            pow_impl!(Wrapping<u128>);
            pow_impl!(Wrapping<i128>);
            pow_impl!(Wrapping<usize>);
            pow_impl!(Wrapping<isize>);
            
            mod float_impls 
            {
                use super::Pow;
                use ::num::traits::Float;

                pow_impl!(f32, i8, i32, <f32 as Float>::powi);
                pow_impl!(f32, u8, i32, <f32 as Float>::powi);
                pow_impl!(f32, i16, i32, <f32 as Float>::powi);
                pow_impl!(f32, u16, i32, <f32 as Float>::powi);
                pow_impl!(f32, i32, i32, <f32 as Float>::powi);
                pow_impl!(f64, i8, i32, <f64 as Float>::powi);
                pow_impl!(f64, u8, i32, <f64 as Float>::powi);
                pow_impl!(f64, i16, i32, <f64 as Float>::powi);
                pow_impl!(f64, u16, i32, <f64 as Float>::powi);
                pow_impl!(f64, i32, i32, <f64 as Float>::powi);
                pow_impl!(f32, f32, f32, <f32 as Float>::powf);
                pow_impl!(f64, f32, f64, <f64 as Float>::powf);
                pow_impl!(f64, f64, f64, <f64 as Float>::powf);
            }
            /// Raises a value to the power of exp, using exponentiation by squaring.
            #[inline] pub fn pow<T: Clone + One + Mul<T, Output = T>>(mut base: T, mut exp: usize) -> T 
            {
                if exp == 0 {
                    return T::one();
                }

                while exp & 1 == 0 {
                    base = base.clone() * base;
                    exp >>= 1;
                }
                if exp == 1 {
                    return base;
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.clone() * base;
                    if exp & 1 == 1 {
                        acc = acc * base.clone();
                    }
                }
                acc
            }
            /// Raises a value to the power of exp, returning `None` if an overflow occurred.
            #[inline] pub fn checked_pow<T: Clone + One + CheckedMul>(mut base: T, mut exp: usize) -> Option<T> 
            {
                if exp == 0 {
                    return Some(T::one());
                }

                while exp & 1 == 0 {
                    base = base.checked_mul(&base)?;
                    exp >>= 1;
                }
                if exp == 1 {
                    return Some(base);
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.checked_mul(&base)?;
                    if exp & 1 == 1 {
                        acc = acc.checked_mul(&base)?;
                    }
                }
                Some(acc)
            }
        } pub use self::pow::{ * };

        pub mod real
        {
            use ::
            {
                num::
                {
                    traits::{ Float, Num, NumCast },
                },
                ops::{ Neg },
                *,
            };
            /// A trait for real number types that do not necessarily have
            /// floating-point-specific characteristics such as NaN and infinity.
            pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self>
            {
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self;
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns the largest integer less than or equal to a number.
                fn floor(self) -> Self;
                /// Returns the smallest integer greater than or equal to a number.
                fn ceil(self) -> Self;
                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                fn round(self) -> Self;
                /// Return the integer part of a number.
                fn trunc(self) -> Self;
                /// Returns the fractional part of a number.
                fn fract(self) -> Self;
                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                fn abs(self) -> Self;
                /// Returns a number that represents the sign of `self`.
                fn signum(self) -> Self;
                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and with newer versions of Rust `f64::NAN`.
                fn is_sign_positive(self) -> bool;
                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.
                fn is_sign_negative(self) -> bool;
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                fn mul_add(self, a: Self, b: Self) -> Self;
                /// Take the reciprocal (inverse) of a number, `1/x`.
                fn recip(self) -> Self;
                /// Raise a number to an integer power.
                fn powi(self, n: i32) -> Self;
                /// Raise a number to a real number power.
                fn powf(self, n: Self) -> Self;
                /// Take the square root of a number.
                fn sqrt(self) -> Self;
                /// Returns `e^(self)`, (the exponential function).
                fn exp(self) -> Self;
                /// Returns `2^(self)`.
                fn exp2(self) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln(self) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log(self, base: Self) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2(self) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10(self) -> Self;
                /// Converts radians to degrees.
                fn to_degrees(self) -> Self;
                /// Converts degrees to radians.
                fn to_radians(self) -> Self;
                /// Returns the maximum of the two numbers.
                fn max(self, other: Self) -> Self;
                /// Returns the minimum of the two numbers.
                fn min(self, other: Self) -> Self;
                /// The positive difference of two numbers.
                fn abs_sub(self, other: Self) -> Self;
                /// Take the cubic root of a number.
                fn cbrt(self) -> Self;
                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                fn hypot(self, other: Self) -> Self;
                /// Computes the sine of a number (in radians).
                fn sin(self) -> Self;
                /// Computes the cosine of a number (in radians).
                fn cos(self) -> Self;
                /// Computes the tangent of a number (in radians).
                fn tan(self) -> Self;
                /// Computes the arcsine of a number. Return value is in radians in
                /// the range [-pi/2, pi/2] or NaN if the number is outside the range
                /// [-1, 1].
                fn asin(self) -> Self;
                /// Computes the arccosine of a number. Return value is in radians in
                /// the range [0, pi] or NaN if the number is outside the range
                /// [-1, 1].
                fn acos(self) -> Self;
                /// Computes the arctangent of a number. Return value is in radians in the
                /// range [-pi/2, pi/2];
                fn atan(self) -> Self;
                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                fn atan2(self, other: Self) -> Self;
                /// Simultaneously computes the sine and cosine of the number, `x`. Returns
                /// `(sin(x), cos(x))`.
                fn sin_cos(self) -> (Self, Self);
                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                fn exp_m1(self) -> Self;
                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                fn ln_1p(self) -> Self;
                /// Hyperbolic sine function.
                fn sinh(self) -> Self;
                /// Hyperbolic cosine function.
                fn cosh(self) -> Self;
                /// Hyperbolic tangent function.
                fn tanh(self) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh(self) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh(self) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh(self) -> Self;
            }

            impl<T: Float> Real for T
            {
                forward! {
                    Float::min_value() -> Self;
                    Float::min_positive_value() -> Self;
                    Float::epsilon() -> Self;
                    Float::max_value() -> Self;
                }
                forward! {
                    Float::floor(self) -> Self;
                    Float::ceil(self) -> Self;
                    Float::round(self) -> Self;
                    Float::trunc(self) -> Self;
                    Float::fract(self) -> Self;
                    Float::abs(self) -> Self;
                    Float::signum(self) -> Self;
                    Float::is_sign_positive(self) -> bool;
                    Float::is_sign_negative(self) -> bool;
                    Float::mul_add(self, a: Self, b: Self) -> Self;
                    Float::recip(self) -> Self;
                    Float::powi(self, n: i32) -> Self;
                    Float::powf(self, n: Self) -> Self;
                    Float::sqrt(self) -> Self;
                    Float::exp(self) -> Self;
                    Float::exp2(self) -> Self;
                    Float::ln(self) -> Self;
                    Float::log(self, base: Self) -> Self;
                    Float::log2(self) -> Self;
                    Float::log10(self) -> Self;
                    Float::to_degrees(self) -> Self;
                    Float::to_radians(self) -> Self;
                    Float::max(self, other: Self) -> Self;
                    Float::min(self, other: Self) -> Self;
                    Float::abs_sub(self, other: Self) -> Self;
                    Float::cbrt(self) -> Self;
                    Float::hypot(self, other: Self) -> Self;
                    Float::sin(self) -> Self;
                    Float::cos(self) -> Self;
                    Float::tan(self) -> Self;
                    Float::asin(self) -> Self;
                    Float::acos(self) -> Self;
                    Float::atan(self) -> Self;
                    Float::atan2(self, other: Self) -> Self;
                    Float::sin_cos(self) -> (Self, Self);
                    Float::exp_m1(self) -> Self;
                    Float::ln_1p(self) -> Self;
                    Float::sinh(self) -> Self;
                    Float::cosh(self) -> Self;
                    Float::tanh(self) -> Self;
                    Float::asinh(self) -> Self;
                    Float::acosh(self) -> Self;
                    Float::atanh(self) -> Self;
                }
            }
        } pub use self::real::{ * };

        pub mod sign
        {
            use ::
            {
                num::
                { 
                    traits::
                    {
                        float::{ FloatCore },
                        Num,
                    },
                    Wrapping 
                },
                ops::{ Neg },
                *,
            };
            /// Useful functions for signed numbers (i.e. numbers that can be negative).
            pub trait Signed: Sized + Num + Neg<Output = Self> 
            {
                /// Computes the absolute value.
                fn abs(&self) -> Self;
                /// The positive difference of two numbers.
                fn abs_sub(&self, other: &Self) -> Self;
                /// Returns the sign of the number.
                fn signum(&self) -> Self;
                /// Returns true if the number is positive and false if the number is zero or negative.
                fn is_positive(&self) -> bool;
                /// Returns true if the number is negative and false if the number is zero or positive.
                fn is_negative(&self) -> bool;
            }

            macro_rules! signed_impl 
            {
                ($($t:ty)*) => ($(
                    impl Signed for $t {
                        #[inline] fn abs(&self) -> $t {
                            if self.is_negative() { -*self } else { *self }
                        }

                        #[inline] fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other { 0 } else { *self - *other }
                        }

                        #[inline] fn signum(&self) -> $t {
                            match *self {
                                n if n > 0 => 1,
                                0 => 0,
                                _ => -1,
                            }
                        }

                        #[inline] fn is_positive(&self) -> bool { *self > 0 }

                        #[inline] fn is_negative(&self) -> bool { *self < 0 }
                    }
                )*)
            }

            signed_impl!(isize i8 i16 i32 i64 i128);

            impl<T: Signed> Signed for Wrapping<T> where
                Wrapping<T>: Num + Neg<Output = Wrapping<T>>,
            {
                #[inline] fn abs(&self) -> Self {
                    Wrapping(self.0.abs())
                }

                #[inline] fn abs_sub(&self, other: &Self) -> Self {
                    Wrapping(self.0.abs_sub(&other.0))
                }

                #[inline] fn signum(&self) -> Self {
                    Wrapping(self.0.signum())
                }

                #[inline] fn is_positive(&self) -> bool {
                    self.0.is_positive()
                }

                #[inline] fn is_negative(&self) -> bool {
                    self.0.is_negative()
                }
            }

            macro_rules! signed_float_impl 
            {
                ($t:ty) => {
                    impl Signed for $t {
                        /// Computes the absolute value. Returns `NAN` if the number is `NAN`.
                        #[inline] fn abs(&self) -> $t {
                            FloatCore::abs(*self)
                        }

                        /// The positive difference of two numbers. Returns `0.0` if the number is
                        /// less than or equal to `other`, otherwise the difference between`self`
                        /// and `other` is returned.
                        #[inline] fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other {
                                0.
                            } else {
                                *self - *other
                            }
                        }

                        /// # Returns
                        ///
                        /// - `1.0` if the number is positive, `+0.0` or `INFINITY`
                        /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                        /// - `NAN` if the number is NaN
                        #[inline] fn signum(&self) -> $t {
                            FloatCore::signum(*self)
                        }

                        /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`
                        #[inline] fn is_positive(&self) -> bool {
                            FloatCore::is_sign_positive(*self)
                        }

                        /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`
                        #[inline] fn is_negative(&self) -> bool {
                            FloatCore::is_sign_negative(*self)
                        }
                    }
                };
            }

            signed_float_impl!(f32);
            signed_float_impl!(f64);
            /// Computes the absolute value.
            #[inline( always )] pub fn abs<T: Signed>(value: T) -> T
                {    value.abs()
            }
            /// The positive difference of two numbers.
            #[inline( always )] pub fn abs_sub<T: Signed>(x: T, y: T) -> T
                {    x.abs_sub(&y)
            }
            /// Returns the sign of the number.
            #[inline( always )] pub fn signum<T: Signed>(value: T) -> T
                {    value.signum()
            }
            /// A trait for values which cannot be negative
            pub trait Unsigned: Num {}

            macro_rules! empty_trait_impl {
                ($name:ident for $($t:ty)*) => ($(
                    impl $name for $t {}
                )*)
            }

            empty_trait_impl!(Unsigned for usize u8 u16 u32 u64 u128);

            impl<T: Unsigned> Unsigned for Wrapping<T> where Wrapping<T>: Num {}
        } pub use self::sign::{ * };
        /// The base trait for numeric types, covering `0` and `1` values, 
        /// comparisons, basic numeric operations, and string conversion.
        pub trait Num: PartialEq + Zero + One + NumOps
        {
            type FromStrRadixErr;
            /// Convert from a string and radix (typically `2..=36`).
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>;
        }
        /// Generic trait for types implementing basic numeric operations
        pub trait NumOps<Rhs = Self, Output = Self>:
        Add<Rhs, Output = Output>
        + Sub<Rhs, Output = Output>
        + Mul<Rhs, Output = Output>
        + Div<Rhs, Output = Output>
        + Rem<Rhs, Output = Output>
        {
        }

        impl<T, Rhs, Output> NumOps<Rhs, Output> for T where
        T: Add<Rhs, Output = Output>
                + Sub<Rhs, Output = Output>
                + Mul<Rhs, Output = Output>
                + Div<Rhs, Output = Output>
                + Rem<Rhs, Output = Output>
        {
        }
        /// The trait for `Num` types which also implement numeric operations taking
        /// the second operand by reference.
        pub trait NumRef: Num + for<'r> NumOps<&'r Self> {}
        impl<T> NumRef for T where T: Num + for<'r> NumOps<&'r T> {}
        /// The trait for `Num` references which implement numeric operations, taking the
        /// second operand either by value or by reference.
        pub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        impl<T, Base> RefNum<Base> for T where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        /// Generic trait for types implementing numeric assignment operators (like `+=`).
        pub trait NumAssignOps<Rhs = Self>:
            AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        impl<T, Rhs> NumAssignOps<Rhs> for T where
            T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }
        /// The trait for `Num` types which also implement assignment operators.
        pub trait NumAssign: Num + NumAssignOps {}
        impl<T> NumAssign for T where T: Num + NumAssignOps {}
        /// The trait for `NumAssign` types which also implement assignment operations
        /// taking the second operand by reference.
        pub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}
        impl<T> NumAssignRef for T where T: NumAssign + for<'r> NumAssignOps<&'r T> {}

        macro_rules! int_trait_impl 
        {
            ($name:ident for $($t:ty)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ::num::ParseIntError;
                    #[inline] fn from_str_radix(s: &str, radix: u32)
                                    -> Result<Self, ::num::ParseIntError>
                    {
                        <$t>::from_str_radix(s, radix)
                    }
                }
            )*)
        }
        int_trait_impl!(Num for usize u8 u16 u32 u64 u128);
        int_trait_impl!(Num for isize i8 i16 i32 i64 i128);

        impl<T: Num> Num for Wrapping<T> where
        Wrapping<T>: NumOps
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix(str, radix).map(Wrapping)
            }
        }

        #[derive( Debug )]
        pub enum FloatErrorKind 
        {
            Empty,
            Invalid,
        }
        
        #[derive( Debug )]
        pub struct ParseFloatError 
        {
            pub kind: FloatErrorKind,
        }

        impl fmt::Display for ParseFloatError
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let description = match self.kind {
                    FloatErrorKind::Empty => "cannot parse float from empty string",
                    FloatErrorKind::Invalid => "invalid float literal",
                };

                description.fmt(f)
            }
        }

        fn str_to_ascii_lower_eq_str(a: &str, b: &str) -> bool 
        {
            a.len() == b.len()
                && a.bytes().zip(b.bytes()).all(|(a, b)| 
                    {
                    let a_to_ascii_lower = a | (((b'A' <= a && a <= b'Z') as u8) << 5);
                    a_to_ascii_lower == b
                })
        }
        
        macro_rules! float_trait_impl 
        {
            ($name:ident for $($t:ident)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ParseFloatError;

                    fn from_str_radix(src: &str, radix: u32)
                                    -> Result<Self, Self::FromStrRadixErr>
                    {
                        use self::FloatErrorKind::*;
                        use self::ParseFloatError as PFE;
                        
                        if radix == 10 {
                            return src.parse().map_err(|_| PFE {
                                kind: if src.is_empty() { Empty } else { Invalid },
                            });
                        }
                        
                        if str_to_ascii_lower_eq_str(src, "inf")
                            || str_to_ascii_lower_eq_str(src, "infinity")
                        {
                            return Ok(std::$t::INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "-inf")
                            || str_to_ascii_lower_eq_str(src, "-infinity")
                        {
                            return Ok(std::$t::NEG_INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "nan") {
                            return Ok(std::$t::NAN);
                        } else if str_to_ascii_lower_eq_str(src, "-nan") {
                            return Ok(-std::$t::NAN);
                        }

                        fn slice_shift_char(src: &str) -> Option<(char, &str)> {
                            let mut chars = src.chars();
                            Some((chars.next()?, chars.as_str()))
                        }

                        let (is_positive, src) =  match slice_shift_char(src) {
                            None             => return Err(PFE { kind: Empty }),
                            Some(('-', ""))  => return Err(PFE { kind: Empty }),
                            Some(('-', src)) => (false, src),
                            Some((_, _))     => (true,  src),
                        };
                        
                        let mut sig = if is_positive { 0.0 } else { -0.0 };
                        let mut prev_sig = sig;
                        let mut cs = src.chars().enumerate();
                        let mut exp_info = None::<(char, usize)>;
                        
                        for (i, c) in cs.by_ref() {
                            match c.to_digit(radix) {
                                Some(digit) => {
                                    sig *= radix as $t;
                                    if is_positive {
                                        sig += (digit as isize) as $t;
                                    } else {
                                        sig -= (digit as isize) as $t;
                                    }
                                    if prev_sig != 0.0 {
                                        if is_positive && sig <= prev_sig
                                            { return Ok(std::$t::INFINITY); }
                                        if !is_positive && sig >= prev_sig
                                            { return Ok(std::$t::NEG_INFINITY); }

                                       
                                        if is_positive && (prev_sig != (sig - digit as $t) / radix as $t)
                                            { return Ok(std::$t::INFINITY); }
                                        if !is_positive && (prev_sig != (sig + digit as $t) / radix as $t)
                                            { return Ok(std::$t::NEG_INFINITY); }
                                    }
                                    prev_sig = sig;
                                },
                                None => match c {
                                    'e' | 'E' | 'p' | 'P' => {
                                        exp_info = Some((c, i + 1));
                                        break;
                                    },
                                    '.' => {
                                        break;
                                    },
                                    _ => {
                                        return Err(PFE { kind: Invalid });
                                    },
                                },
                            }
                        }

                        if exp_info.is_none() {
                            let mut power = 1.0;
                            for (i, c) in cs.by_ref() {
                                match c.to_digit(radix) {
                                    Some(digit) => {
                                        power /= radix as $t;
                                        sig = if is_positive {
                                            sig + (digit as $t) * power
                                        } else {
                                            sig - (digit as $t) * power
                                        };
                                       
                                        if is_positive && sig < prev_sig
                                            { return Ok(std::$t::INFINITY); }
                                        if !is_positive && sig > prev_sig
                                            { return Ok(std::$t::NEG_INFINITY); }
                                        prev_sig = sig;
                                    },
                                    None => match c {
                                        'e' | 'E' | 'p' | 'P' => {
                                            exp_info = Some((c, i + 1));
                                            break;
                                        },
                                        _ => {
                                            return Err(PFE { kind: Invalid });
                                        },
                                    },
                                }
                            }
                        }
                        
                        let exp = match exp_info {
                            Some((c, offset)) => {
                                let base = match c {
                                    'E' | 'e' if radix == 10 => 10.0,
                                    'P' | 'p' if radix == 16 => 2.0,
                                    _ => return Err(PFE { kind: Invalid }),
                                };
                                
                                let src = &src[offset..];
                                let (is_positive, exp) = match slice_shift_char(src) {
                                    Some(('-', src)) => (false, src.parse::<usize>()),
                                    Some(('+', src)) => (true,  src.parse::<usize>()),
                                    Some((_, _))     => (true,  src.parse::<usize>()),
                                    None             => return Err(PFE { kind: Invalid }),
                                };
                                
                                fn pow(base: $t, exp: usize) -> $t {
                                    Float::powi(base, exp as i32)
                                }

                                match (is_positive, exp) {
                                    (true,  Ok(exp)) => pow(base, exp),
                                    (false, Ok(exp)) => 1.0 / pow(base, exp),
                                    (_, Err(_))      => return Err(PFE { kind: Invalid }),
                                }
                            },
                            None => 1.0,
                        };

                        Ok(sig * exp)
                    }
                }
            )*)
        }
        float_trait_impl!(Num for f32 f64);
        /// A value bounded by a minimum and a maximum
        #[inline] pub fn clamp<T: PartialOrd>( input:T, min:T, max:T ) -> T
        {
            debug_assert!(min <= max, "min must be less than or equal to max");
            if input < min {
                min
            } else if input > max {
                max
            } else {
                input
            }
        }
        /// A value bounded by a minimum value
        #[inline] pub fn clamp_min<T: PartialOrd>( input:T, min:T ) -> T
        {
            debug_assert!(min == min, "min must not be NAN");
            if input < min {
                min
            } else {
                input
            }
        }
        /// A value bounded by a maximum value
        #[inline] pub fn clamp_max<T: PartialOrd>( input:T, max:T ) -> T
        {
            debug_assert!(max == max, "max must not be NAN");
            if input > max {
                max
            } else {
                input
            }
        }
        
        macro_rules! define_valid_range_type 
        {
            ($(
                $(#[$m:meta])*
                $vis:vis struct $name:ident($int:ident as $uint:ident in $low:literal..=$high:literal);
            )+) => 
            {$(
                #[derive(Clone, Copy, Eq)]
                #[repr(transparent)]
                $(#[$m])*
                $vis struct $name($int);

                const _: () = 
                {
                    assert!(<$uint>::MIN == 0);
                    let ulow: $uint = $low;
                    let uhigh: $uint = $high;
                    assert!(ulow <= uhigh);
                    assert!(size_of::<$int>() == size_of::<$uint>());
                };

                impl $name 
                {
                    #[inline] pub const fn new(val: $int) -> Option<Self>
                    {
                        if (val as $uint) >= ($low as $uint) && (val as $uint) <= ($high as $uint)
                        { Some(unsafe { $name(val) }) } 
                        
                        else { None }
                    }

                    /// Constructs an instance of this type from the underlying integer primitive without checking whether its zero.
                    #[inline] pub const unsafe fn new_unchecked(val: $int) -> Self { unsafe { $name(val) } }
                    #[inline] pub const fn as_inner(self) -> $int { unsafe { ::mem::transmute(self) } }
                }
                
                /* impl StructuralPartialEq for $name {} */

                impl PartialEq for $name
                {
                    #[inline] fn eq(&self, other: &Self) -> bool { self.as_inner() == other.as_inner() }
                }

                impl Ord for $name
                {
                    #[inline] fn cmp(&self, other: &Self) -> Ordering { Ord::cmp(&self.as_inner(), &other.as_inner()) }
                }

                impl PartialOrd for $name
                {
                    #[inline] fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ord::cmp(self, other)) }
                }

                impl Hash for $name
                {
                    fn hash<H: Hasher>(&self, state: &mut H) { Hash::hash(&self.as_inner(), state); }
                }

                impl fmt::Debug for $name
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                    { <$int as fmt::Debug>::fmt(&self.as_inner(), f) }
                }
            )+};
        }

        define_valid_range_type! { pub struct Nanoseconds(u32 as u32 in 0..=999_999_999); }

        impl Nanoseconds
        { 
            pub const ZERO: Self = unsafe { Nanoseconds::new_unchecked(0) };
        }

        impl Default for Nanoseconds
        {
            #[inline] fn default() -> Self { Self::ZERO }
        }

        define_valid_range_type! 
        {
            pub struct NonZeroU8Inner(u8 as u8 in 1..=0xff);
            pub struct NonZeroU16Inner(u16 as u16 in 1..=0xff_ff);
            pub struct NonZeroU32Inner(u32 as u32 in 1..=0xffff_ffff);
            pub struct NonZeroU64Inner(u64 as u64 in 1..=0xffffffff_ffffffff);
            pub struct NonZeroU128Inner(u128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);

            pub struct NonZeroI8Inner(i8 as u8 in 1..=0xff);
            pub struct NonZeroI16Inner(i16 as u16 in 1..=0xff_ff);
            pub struct NonZeroI32Inner(i32 as u32 in 1..=0xffff_ffff);
            pub struct NonZeroI64Inner(i64 as u64 in 1..=0xffffffff_ffffffff);
            pub struct NonZeroI128Inner(i128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);
        }
        
        define_valid_range_type! 
        {
            pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff_ffff_ffff);
            pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff_ffff_ffff);
            pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff_ffff_ffff);
        }

        define_valid_range_type! 
        {
            pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);
            pub struct I32NotAllOnes(i32 as u32 in 0..=0xffff_fffe);

            pub struct U64NotAllOnes(u64 as u64 in 0..=0xffff_ffff_ffff_fffe);
            pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);
        }

        pub trait NotAllOnesHelper
        {
            type Type;
        }

        pub type NotAllOnes<T> = <T as NotAllOnesHelper>::Type;
        impl NotAllOnesHelper for u32 { type Type = U32NotAllOnes; }
        impl NotAllOnesHelper for i32 { type Type = I32NotAllOnes; }
        impl NotAllOnesHelper for u64 { type Type = U64NotAllOnes; }
        impl NotAllOnesHelper for i64 { type Type = I64NotAllOnes; }
    }
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod option
{
    pub use std::option::{ * };

    pub mod implementation
    {
        use ::
        {
            option::{ OptionExt },
            *,
        };

        impl<T> OptionExt<T> for Option<T>
        {
            fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T>
            {
                match *self
                {
                    Some(ref y) => x == y,
                    None => false,
                }
            }

            #[inline] fn map_or2<U, F: FnOnce(T) -> U>(self, f: F, default: U) -> U { self.map_or(default, f) }

            #[inline] fn map_or_else2<U, F: FnOnce(T) -> U, D: FnOnce() -> U>(self, f: F, default: D) -> U
            { self.map_or_else(default, f) }
        }
    }
    /// Extension trait providing additional methods for `Option`.
    pub trait OptionExt<T>
    {
        /// Returns `true` if the option is a [`Some`] value containing the given value.
        #[must_use] fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T>;
        /// Returns the result from applying the function `f` to the contained value if the option is [`Some`],
        /// or returns provided `default` value if the option is [`None`].
        #[must_use] fn map_or2<U, F: FnOnce(T) -> U>(self, f: F, default: U) -> U;
        /// Returns the result from applying the function `f` to the contained value if the option is [`Some`],
        /// or returns the result from evaluating the provided function `default` if the option is [`None`].
        #[must_use] fn map_or_else2<U, F: FnOnce(T) -> U, D: FnOnce() -> U>(self, f: F, default: D) -> U;
    }
}

pub mod os
{
    use ::
    {  
        *,
    };

    pub mod fd
    {
        //! Owned and borrowed Unix-like file descriptors.
        pub use std::os::fd::{ * };
        // pub fn create_raw_fd_from_file(file_name: &str, append: bool) -> Result<i32, String>
        pub fn create_raw_from_file( file_name:&str, append:bool ) -> Result<i32, String>
        {
            let mut oos = ::fs::OpenOptions::new();

            if append { oos.append(true); }
            else
            {
                oos.write(true);
                oos.truncate(true);
            }
            
            match oos
            .create(true)
            .open(file_name)
            {
                Ok(x) =>
                {
                    let fd = x.into_raw_fd();
                    Ok(fd)
                }

                Err(e) => Err(format!("{}", e)),
            }
        }
        // pub fn get_fd_from_file(file_name: &str) -> i32
        pub fn get_from_file( file_name:&str ) -> i32
        {
            let path = ::path::Path::new(file_name);
            let display = path.display();
            let file = match ::fs::File::open(path)
            {
                Err(why) =>
                {
                    println_stderr!("cicada: {}: {}", display, why);
                    return -1;
                }

                Ok(file) => file,
            };

            file.into_raw_fd()
        }
    }

    pub mod raw
    {
        //! Compatibility module for C platform-specific types. Use [`core::ffi`] instead.
        pub use std::os::raw::{ * };
    }

    pub mod unix
    {
        //! Platform-specific extensions to `std` for Unix platforms.
        #[cfg( unix )] pub use std::os::unix::{ * };
    } #[cfg( unix )] pub use self::unix::{ * };

    pub mod windows
    {
        //! Platform-specific extensions to `std` for Windows.
        #[cfg( windows )] pub use std::os::windows::{ * };

    } #[cfg( windows )] pub use self::windows::{ * };
    // pub fn get_os_name() -> String
    pub fn get_name() -> String
    {
        let uname = get_uname();
        if uname.to_lowercase() == "darwin" {
            get_macos_name()
        } else {
            get_other_name()
        }
    }
    // fn get_other_os_name() -> String
    pub fn get_other_name() -> String
    {
        let mut name = get_release_value("PRETTY_NAME");
        if !name.is_empty() {
            return name;
        }
        name = get_release_value("DISTRIB_DESCRIPTION");
        if !name.is_empty() {
            return name;
        }
        name = get_release_value("IMAGE_DESCRIPTION");
        if !name.is_empty() {
            return name;
        }
        get_uname_mo()
    }

    pub fn get_release_value(ptn: &str) -> String
    {
        let line = format!(
            "grep -i '{}' /etc/*release* 2>&1 | grep -o '=.*' | tr '\"=' ' '",
            ptn
        );
        let cr = now::run(&line);
        return cr.stdout.trim().to_string();
    }

    pub fn get_uname() -> String
    {
        let cr = now::run("uname");
        return cr.stdout.trim().to_string();
    }

    pub fn get_uname_mo() -> String
    {
        let cr = now::run("uname -m -o");
        return cr.stdout.trim().to_string();
    }

    pub fn get_macos_name() -> String
    {
        let mut os_name = get_osx_codename();
        let ver = get_osx_version();
        if !ver.is_empty() {
            os_name.push(' ');
            os_name.push_str(&ver);
        }
        os_name
    }

    pub fn get_osx_codename() -> String
    {
        let cr = now::run("grep -o 'SOFTWARE LICENSE AGREEMENT FOR .*[a-zA-Z]' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | sed 's/SOFTWARE LICENSE AGREEMENT FOR *//'");
        return cr.stdout.trim().to_string();
    }

    pub fn get_osx_version() -> String
    {
        let cr = now::run("sw_vers -productVersion");
        return cr.stdout.trim().to_string();
    }

    pub use std::os::{ * };
}

pub mod parsers
{
    pub mod line
    {
        use ::
        {
            regex::{ contains },
            types::{ * },
            *,
        };
        // pub fn line_to_plain_tokens(line: &str) -> Vec<String>
        pub fn to_plain_tokens(line: &str) -> Vec<String>
        {
            let mut result = Vec::new();
            let linfo = parse(line);
            
            for (_, r) in linfo.tokens
            {
                result.push(r.clone());
            }

            result
        }
        /// parse command line to tokens
        /// >>> parse_line("echo 'hi yoo' | grep \"hi\"");
        /// LineInfo {
        ///    tokens: vec![
        ///        ("", "echo"),
        ///        ("'", "hi yoo"),
        ///        ("", "|"),
        ///        ("", "grep"),
        ///        ("\"", "hi"),
        ///    ],
        ///    is_complete: true
        /// }
        // pub fn parse_line(line: &str) -> LineInfo
        pub fn parse(line: &str) -> LineInfo
        {
            let mut result = Vec::new();

            if is::arithmetic(line)
            {
                for x in line.split(' ')
                {
                    result.push((String::from(""), x.to_string()));
                }

                return LineInfo::new(result);
            }

            let mut sep = String::new();
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;
            let mut sep_made = String::new();
            let mut semi_ok = false;
            let count_chars = line.chars().count();

            for (i, c) in line.chars().enumerate()
            {
                if skip_next
                {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && (c == '>' || c == '<') 
                {
                    sep_made = String::from("'");
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"' 
                {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if has_backslash 
                {
                    if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty() 
                    {
                        sep = String::from("\\");
                        token = format!("{}", c);
                    }
                    else { token.push(c); }

                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' { has_dollar = true; }
                
                if c == '(' && sep.is_empty() 
                {
                    if !has_dollar && token.is_empty() 
                    {
                        parens_left_ignored = true;
                        continue;
                    }

                    met_parenthesis = true;
                }

                if c == ')' 
                {
                    if parens_left_ignored && !has_dollar
                    {
                        if i == count_chars - 1 || (i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == ' ') 
                        { continue; }
                    }

                    if sep.is_empty() { met_parenthesis = false; }
                }

                if c == '\\'
                {
                    if sep == "'" || !sep_second.is_empty() { token.push(c) }
                    else { has_backslash = true; }

                    continue;
                }

                if new_round
                {
                    if c == ' ' { continue; }
                    else if c == '"' || c == '\'' || c == '`'
                    {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' { break; }

                    if c == '|'
                    {
                        if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|'
                        {
                            result.push((String::from(""), "||".to_string()));
                            skip_next = true;
                        }
                        else { result.push((String::from(""), "|".to_string())); }

                        new_round = true;
                        continue;
                    }

                    token.push(c);
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }
                    
                    else if !met_parenthesis && sep_second.is_empty() && sep.is_empty()
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((String::from(""), token)); }

                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' '
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash
                    {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if met_parenthesis
                    {
                        token.push(c);
                        continue;
                    }

                    if sep == "\\"
                    {
                        result.push((String::from("\\"), token));
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty()
                    {
                        if sep_second.is_empty()
                        {
                            if sep.is_empty() && !sep_made.is_empty()
                            {
                                result.push((sep_made.clone(), token));
                                sep_made = String::new();
                            }
                            else { result.push((String::from(""), token)); }

                            token = String::new();
                            new_round = true;
                            continue;
                        }
                        else
                        {
                            token.push(c);
                            continue;
                        }
                    }

                    else
                    {
                        token.push(c);
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`'
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }

                    if sep != c.to_string() && semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        }
                        else { result.push((sep.to_string(), token)); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                    }

                    if sep != c.to_string() && met_parenthesis
                    {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string()
                    {
                        token.push(c);
                        continue;
                    }

                    if sep.is_empty()
                    {
                        let is_an_env = contains(&token, r"^[a-zA-Z0-9_]+=.*$");
                        if !is_an_env && (c == '\'' || c == '"')
                        {
                            sep = c.to_string();
                            continue;
                        }

                        token.push(c);
                        if sep_second.is_empty() {
                            sep_second = c.to_string();
                        } else if sep_second == c.to_string() {
                            sep_second = String::new();
                        }
                        continue;
                    }
                    
                    else if sep == c.to_string()
                    {
                        semi_ok = true;
                        continue;
                    }
                    
                    else { token.push(c); }
                }
                
                else
                {
                    if has_backslash
                    {
                        has_backslash = false;

                        if sep == "\"" || sep == "'" { token.push('\\'); }
                    }

                    token.push(c);
                }
            }

            if !token.is_empty() || semi_ok
            {
                if sep.is_empty() && !sep_made.is_empty() { result.push((sep_made.clone(), token)); }
                else { result.push((sep.clone(), token)); }
            }

            let mut is_line_complete = true;
            
            if !result.is_empty()
            {
                let token_last = result[result.len() - 1].clone();

                if token_last.0.is_empty() && token_last.1 == "|" { is_line_complete = false; }
            }

            if !sep.is_empty() { is_line_complete = semi_ok; }

            if has_backslash { is_line_complete = false; }

            LineInfo { tokens: result, is_complete: is_line_complete }
        }

        pub fn tokens_to_args(tokens: &Tokens) -> Vec<String>
        {
            let mut result = Vec::new();
            
            for s in tokens
            {
                result.push(s.1.clone());
            }

            result
        }
        // pub fn tokens_to_line(tokens: &Tokens) -> String
        pub fn from_tokens(tokens: &Tokens) -> String
        {
            let mut result = String::new();
            for t in tokens {
                if t.0.is_empty() {
                    result.push_str(&t.1);
                } else {
                    let s = wrap_sep_string(&t.0, &t.1);
                    result.push_str(&s);
                }
                result.push(' ');
            }
            if result.ends_with(' ') {
                let len = result.len();
                result.truncate(len - 1);
            }
            result
        }
        /// Parse command line for multiple commands.
        // pub fn line_to_cmds(line: &str) -> Vec<String>
        pub fn to_cmds(line: &str) -> Vec<String>
        {
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();

            for (i, c) in line.chars().enumerate()
            {
                if has_backslash
                {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'"
                {
                    has_backslash = true;
                    continue;
                }

                if c == '#'
                {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push(c);
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`'
                {
                    if sep.is_empty()
                    {
                        sep.push(c);
                        token.push(c);
                        continue;
                    }
                    
                    else if sep == c.to_string()
                    {
                        token.push(c);
                        sep = String::new();
                        continue;
                    }
                    
                    else
                    {
                        token.push(c);
                        continue;
                    }
                }

                if c == '&' || c == '|'
                {
                    if sep.is_empty()
                    {
                        if i + 1 == len
                        {
                            token.push(c);
                            continue;
                        }
                        
                        else
                        {
                            let c_next = match line.chars().nth(i + 1)
                            
                            {
                                Some(x) => x,
                                None =>
                                {
                                    println!("chars nth error - should never happen");
                                    continue;
                                }
                            };

                            if c_next != c
                            {
                                token.push(c);
                                continue;
                            }
                        }
                    }

                    if sep.is_empty() {
                        sep.push(c);
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        token = String::new();
                        result.push(format!("{}{}", sep, sep));
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        result.push(String::from(";"));
                        token = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                token.push(c);
            }

            if !token.is_empty()
            {
                result.push(token.trim().to_string());
            }

            result
        }
    }
    /*
    nom 7.1.3*/
    pub mod nom
    {
        //! # nom, eating data byte by byte
        #[macro_use] pub mod macros
        {
            use ::
            {
                *,
            };

            #[macro_export] macro_rules! succ 
            (
                (0, $submac:ident ! ($($rest:tt)*)) => ($submac!(1, $($rest)*));
                (1, $submac:ident ! ($($rest:tt)*)) => ($submac!(2, $($rest)*));
                (2, $submac:ident ! ($($rest:tt)*)) => ($submac!(3, $($rest)*));
                (3, $submac:ident ! ($($rest:tt)*)) => ($submac!(4, $($rest)*));
                (4, $submac:ident ! ($($rest:tt)*)) => ($submac!(5, $($rest)*));
                (5, $submac:ident ! ($($rest:tt)*)) => ($submac!(6, $($rest)*));
                (6, $submac:ident ! ($($rest:tt)*)) => ($submac!(7, $($rest)*));
                (7, $submac:ident ! ($($rest:tt)*)) => ($submac!(8, $($rest)*));
                (8, $submac:ident ! ($($rest:tt)*)) => ($submac!(9, $($rest)*));
                (9, $submac:ident ! ($($rest:tt)*)) => ($submac!(10, $($rest)*));
                (10, $submac:ident ! ($($rest:tt)*)) => ($submac!(11, $($rest)*));
                (11, $submac:ident ! ($($rest:tt)*)) => ($submac!(12, $($rest)*));
                (12, $submac:ident ! ($($rest:tt)*)) => ($submac!(13, $($rest)*));
                (13, $submac:ident ! ($($rest:tt)*)) => ($submac!(14, $($rest)*));
                (14, $submac:ident ! ($($rest:tt)*)) => ($submac!(15, $($rest)*));
                (15, $submac:ident ! ($($rest:tt)*)) => ($submac!(16, $($rest)*));
                (16, $submac:ident ! ($($rest:tt)*)) => ($submac!(17, $($rest)*));
                (17, $submac:ident ! ($($rest:tt)*)) => ($submac!(18, $($rest)*));
                (18, $submac:ident ! ($($rest:tt)*)) => ($submac!(19, $($rest)*));
                (19, $submac:ident ! ($($rest:tt)*)) => ($submac!(20, $($rest)*));
                (20, $submac:ident ! ($($rest:tt)*)) => ($submac!(21, $($rest)*));
            );
        }

        #[macro_use] pub mod error
        {
            //! Error management
            use ::
            {
                collections::{ HashMap },
                fmt::{ self, Write},
                hash::{ Hash, Hasher },
                parsers::nom::
                {
                    HexDisplay,
                    internal::Parser,
                    traits::Offset,
                },
                *,
            };
            /// Creates a parse error from a `nom::ErrorKind` and the position in the input
            #[macro_export(local_inner_macros)]
            macro_rules! error_position
            (
                ($input:expr, $code:expr) => 
                ({
                    ::parsers::nom::error::make_error($input, $code)
                });
            );
            /// Creates a parse error from a `nom::ErrorKind`, 
            /// the position in the input and the next error in the parsing tree.
            #[macro_export(local_inner_macros)] macro_rules! error_node_position
            (
                ($input:expr, $code:expr, $next:expr) => 
                ({
                    ::parsers::nom::error::append_error($input, $code, $next)
                });
            );
            /// This trait must be implemented by the error type of a nom parser.
            pub trait ParseError<I>: Sized 
            {
                /// Creates an error from the input position and an [ErrorKind]
                fn from_error_kind(input: I, kind: ErrorKind) -> Self;
                /// Combines an existing error with a new one created from the input position and an [ErrorKind].
                fn append(input: I, kind: ErrorKind, other: Self) -> Self;
                /// Creates an error from an input position and an expected character
                fn from_char(input: I, _: char) -> Self { Self::from_error_kind(input, ErrorKind::Char) }
                /// Combines two existing errors.
                fn or(self, other: Self) -> Self { other }
            }
            /// This trait is required by the `context` combinator to add a static string to an existing error.
            pub trait ContextError<I>: Sized 
            {
                /// Creates a new error from an input position, a static string and an existing error.
                fn add_context(_input: I, _ctx: &'static str, other: Self) -> Self { other }
            }
            /// Required by the `map_res` combinator to integrate error types from external functions.
            pub trait FromExternalError<I, E>
            {
                /// Creates a new error from an input position, 
                /// an [ErrorKind] indicating the wrapping parser, and an external error
                fn from_external_error(input: I, kind: ErrorKind, e: E) -> Self;
            }
            /// default error type, only contains the error' location and code
            #[derive(Debug, PartialEq)]
            pub struct Error<I>
            {
                /// position of the error in the input data
                pub input: I,
                /// nom error code
                pub code: ErrorKind,
            }

            impl<I> Error<I>
            {
                /// creates a new basic error
                pub fn new(input: I, code: ErrorKind) -> Error<I> { Error { input, code } }
            }

            impl<I> ParseError<I> for Error<I>
            {
                fn from_error_kind(input: I, kind: ErrorKind) -> Self { Error { input, code: kind } }

                fn append(_: I, _: ErrorKind, other: Self) -> Self { other }
            }

            impl<I> ContextError<I> for Error<I> {}

            impl<I, E> FromExternalError<I, E> for Error<I>
            {
                /// Create a new error from an input position and an external error
                fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self
                {
                    Error { input, code: kind }
                }
            }
            /// The Display implementation allows the ::error::Error implementation
            impl<I: fmt::Display> fmt::Display for Error<I>
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    write!(f, "error {:?} at: {}", self.code, self.input)
                }
            }
            
            impl<I: fmt::Debug + fmt::Display> ::error::Error for Error<I> {}
            
            impl<I> ParseError<I> for (I, ErrorKind)
            {
                fn from_error_kind(input: I, kind: ErrorKind) -> Self { (input, kind) }
                fn append(_: I, _: ErrorKind, other: Self) -> Self { other }
            }

            impl<I> ContextError<I> for (I, ErrorKind) {}

            impl<I, E> FromExternalError<I, E> for (I, ErrorKind)
            {
                fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self { (input, kind) }
            }

            impl<I> ParseError<I> for ()
            {
                fn from_error_kind(_: I, _: ErrorKind) -> Self {}
                fn append(_: I, _: ErrorKind, _: Self) -> Self {}
            }

            impl<I> ContextError<I> for () {}

            impl<I, E> FromExternalError<I, E> for ()
            {
                fn from_external_error(_input: I, _kind: ErrorKind, _e: E) -> Self {}
            }
            /// Creates an error from the input position and an [ErrorKind]
            pub fn make_error<I, E: ParseError<I>>(input: I, kind: ErrorKind) -> E
            {
                E::from_error_kind(input, kind)
            }
            /// Combines an existing error with a new one created from the input position and an [ErrorKind].
            pub fn append_error<I, E: ParseError<I>>(input: I, kind: ErrorKind, other: E) -> E
            {
                E::append(input, kind, other)
            }
            /// This error type accumulates errors and their position when backtracking through a parse tree.
            #[derive(Clone, Debug, PartialEq)]
            pub struct VerboseError<I> 
        {
            /// List of errors accumulated by `VerboseError`, containing the affected
            /// part of input data, and some context
            pub errors: ::vec::Vec<(I, VerboseErrorKind)>,
            }
            /// Error context for `VerboseError`
            #[derive(Clone, Debug, PartialEq)]
            pub enum VerboseErrorKind
            {
                /// Static string added by the `context` function
                Context(&'static str),
                /// Indicates which character was expected by the `char` function
                Char(char),
                /// Error kind given by various nom parsers
                Nom(ErrorKind),
            }

            impl<I> ParseError<I> for VerboseError<I>
            {
                fn from_error_kind(input: I, kind: ErrorKind) -> Self
                {
                    VerboseError
                    {
                        errors: vec![(input, VerboseErrorKind::Nom(kind))],
                    }
                }

                fn append(input: I, kind: ErrorKind, mut other: Self) -> Self
                {
                    other.errors.push((input, VerboseErrorKind::Nom(kind)));
                    other
                }

                fn from_char(input: I, c: char) -> Self
                {
                    VerboseError
                    {
                        errors: vec![(input, VerboseErrorKind::Char(c))],
                    }
                }
            }

            impl<I> ContextError<I> for VerboseError<I>
            {
                fn add_context(input: I, ctx: &'static str, mut other: Self) -> Self
                {
                    other.errors.push((input, VerboseErrorKind::Context(ctx)));
                    other
                }
            }

            impl<I, E> FromExternalError<I, E> for VerboseError<I>
            {
                /// Create a new error from an input position and an external error
                fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self { Self::from_error_kind(input, kind) }
            }

            impl<I: fmt::Display> fmt::Display for VerboseError<I>
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    writeln!(f, "Parse error:")?;
                    for (input, error) in &self.errors
                    {
                        match error
                        {
                            VerboseErrorKind::Nom(e) => writeln!(f, "{:?} at: {}", e, input)?,
                            VerboseErrorKind::Char(c) => writeln!(f, "expected '{}' at: {}", c, input)?,
                            VerboseErrorKind::Context(s) => writeln!(f, "in section '{}', at: {}", s, input)?,
                        }
                    }

                    Ok(())
                }
            }
            
            impl<I: fmt::Debug + fmt::Display> ::error::Error for VerboseError<I> {}

            use super::internal::{Err, IResult};
            /// Create a new error from an input position, a static string and an existing error.
            pub fn context<I: Clone, E: ContextError<I>, F, O>( context: &'static str, mut f: F ) 
            -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>
            {
                move |i: I| match f.parse(i.clone())
                {
                    Ok(o) => Ok(o),
                    Err(Err::Incomplete(i)) => Err(Err::Incomplete(i)),
                    Err(Err::Error(e)) => Err(Err::Error(E::add_context(i, context, e))),
                    Err(Err::Failure(e)) => Err(Err::Failure(E::add_context(i, context, e))),
                }
            }
            /// Transforms a `VerboseError` into a trace with input position information
            pub fn convert_error<I: ::ops::Deref<Target = str>>( input: I, e: VerboseError<I> ) 
            -> ::string::String 
            {
                let mut result = ::string::String::new();

                for (i, (substring, kind)) in e.errors.iter().enumerate()
                {
                    let offset = input.offset(substring);

                    if input.is_empty()
                    {
                        match kind
                        {
                            VerboseErrorKind::Char(c) => { write!(&mut result, "{}: expected '{}', got empty input\n\n", i, c) }
                            VerboseErrorKind::Context(s) => write!(&mut result, "{}: in {}, got empty input\n\n", i, s),
                            VerboseErrorKind::Nom(e) => write!(&mut result, "{}: in {:?}, got empty input\n\n", i, e),
                        }
                    }
                    
                    else
                    {
                        let prefix = &input.as_bytes()[..offset];
                        let line_number = prefix.iter().filter(|&&b| b == b'\n').count() + 1;
                        let line_begin = prefix
                        .iter()
                        .rev()
                        .position(|&b| b == b'\n')
                        .map(|pos| offset - pos)
                        .unwrap_or(0);
                        
                        let line = input[line_begin..]
                        .lines()
                        .next()
                        .unwrap_or(&input[line_begin..])
                        .trim_end();
                        
                        let column_number = line.offset(substring) + 1;

                        match kind 
                        {
                            VerboseErrorKind::Char(c) =>
                            {
                                if let Some(actual) = substring.chars().next()
                                {
                                    write!
                                    (
                                        &mut result,
                                        "{i}: at line {line_number}:\n\
                                        {line}\n\
                                        {caret:>column$}\n\
                                        expected '{expected}', found {actual}\n\n",
                                        i = i,
                                        line_number = line_number,
                                        line = line,
                                        caret = '^',
                                        column = column_number,
                                        expected = c,
                                        actual = actual,
                                    )
                                }

                                else
                                {
                                    write!
                                    (
                                        &mut result,
                                        "{i}: at line {line_number}:\n\
                                        {line}\n\
                                        {caret:>column$}\n\
                                        expected '{expected}', got end of input\n\n",
                                        i = i,
                                        line_number = line_number,
                                        line = line,
                                        caret = '^',
                                        column = column_number,
                                        expected = c,
                                    )
                                }
                            }

                            VerboseErrorKind::Context(s) => write!
                            (
                                &mut result,
                                "{i}: at line {line_number}, in {context}:\n\
                                    {line}\n\
                                    {caret:>column$}\n\n",
                                i = i,
                                line_number = line_number,
                                context = s,
                                line = line,
                                caret = '^',
                                column = column_number,
                            ),

                            VerboseErrorKind::Nom(e) => write!
                            (
                                &mut result,
                                "{i}: at line {line_number}, in {nom_err:?}:\n\
                                    {line}\n\
                                    {caret:>column$}\n\n",
                                i = i,
                                line_number = line_number,
                                nom_err = e,
                                line = line,
                                caret = '^',
                                column = column_number,
                            ),
                        }
                    }.unwrap();
                }

                result
            }
            /// Indicates which parser returned an error
            #[derive( Debug,PartialEq,Eq,Hash,Clone,Copy )]
            pub enum ErrorKind
            {
                Tag,
                MapRes,
                MapOpt,
                Alt,
                IsNot,
                IsA,
                SeparatedList,
                SeparatedNonEmptyList,
                Many0,
                Many1,
                ManyTill,
                Count,
                TakeUntil,
                LengthValue,
                TagClosure,
                Alpha,
                Digit,
                HexDigit,
                OctDigit,
                AlphaNumeric,
                Space,
                MultiSpace,
                LengthValueFn,
                Eof,
                Switch,
                TagBits,
                OneOf,
                NoneOf,
                Char,
                CrLf,
                RegexpMatch,
                RegexpMatches,
                RegexpFind,
                RegexpCapture,
                RegexpCaptures,
                TakeWhile1,
                Complete,
                Fix,
                Escaped,
                EscapedTransform,
                NonEmpty,
                ManyMN,
                Not,
                Permutation,
                Verify,
                TakeTill1,
                TakeWhileMN,
                TooLarge,
                Many0Count,
                Many1Count,
                Float,
                Satisfy,
                Fail,
            }
            /// Converts an ErrorKind to a number
            pub fn error_to_u32(e: &ErrorKind) -> u32 
            {
                match *e
                {
                    ErrorKind::Tag                       => 1,
                    ErrorKind::MapRes                    => 2,
                    ErrorKind::MapOpt                    => 3,
                    ErrorKind::Alt                       => 4,
                    ErrorKind::IsNot                     => 5,
                    ErrorKind::IsA                       => 6,
                    ErrorKind::SeparatedList             => 7,
                    ErrorKind::SeparatedNonEmptyList     => 8,
                    ErrorKind::Many1                     => 9,
                    ErrorKind::Count                     => 10,
                    ErrorKind::TakeUntil                 => 12,
                    ErrorKind::LengthValue               => 15,
                    ErrorKind::TagClosure                => 16,
                    ErrorKind::Alpha                     => 17,
                    ErrorKind::Digit                     => 18,
                    ErrorKind::AlphaNumeric              => 19,
                    ErrorKind::Space                     => 20,
                    ErrorKind::MultiSpace                => 21,
                    ErrorKind::LengthValueFn             => 22,
                    ErrorKind::Eof                       => 23,
                    ErrorKind::Switch                    => 27,
                    ErrorKind::TagBits                   => 28,
                    ErrorKind::OneOf                     => 29,
                    ErrorKind::NoneOf                    => 30,
                    ErrorKind::Char                      => 40,
                    ErrorKind::CrLf                      => 41,
                    ErrorKind::RegexpMatch               => 42,
                    ErrorKind::RegexpMatches             => 43,
                    ErrorKind::RegexpFind                => 44,
                    ErrorKind::RegexpCapture             => 45,
                    ErrorKind::RegexpCaptures            => 46,
                    ErrorKind::TakeWhile1                => 47,
                    ErrorKind::Complete                  => 48,
                    ErrorKind::Fix                       => 49,
                    ErrorKind::Escaped                   => 50,
                    ErrorKind::EscapedTransform          => 51,
                    ErrorKind::NonEmpty                  => 56,
                    ErrorKind::ManyMN                    => 57,
                    ErrorKind::HexDigit                  => 59,
                    ErrorKind::OctDigit                  => 61,
                    ErrorKind::Many0                     => 62,
                    ErrorKind::Not                       => 63,
                    ErrorKind::Permutation               => 64,
                    ErrorKind::ManyTill                  => 65,
                    ErrorKind::Verify                    => 66,
                    ErrorKind::TakeTill1                 => 67,
                    ErrorKind::TakeWhileMN               => 69,
                    ErrorKind::TooLarge                  => 70,
                    ErrorKind::Many0Count                => 71,
                    ErrorKind::Many1Count                => 72,
                    ErrorKind::Float                     => 73,
                    ErrorKind::Satisfy                   => 74,
                    ErrorKind::Fail                      => 75,
                }
            }

            impl ErrorKind 
            {
                /// Converts an ErrorKind to a text description
                pub fn description(&self) -> &str
                {
                    match *self
                    {
                        ErrorKind::Tag                       => "Tag",
                        ErrorKind::MapRes                    => "Map on Result",
                        ErrorKind::MapOpt                    => "Map on Option",
                        ErrorKind::Alt                       => "Alternative",
                        ErrorKind::IsNot                     => "IsNot",
                        ErrorKind::IsA                       => "IsA",
                        ErrorKind::SeparatedList             => "Separated list",
                        ErrorKind::SeparatedNonEmptyList     => "Separated non empty list",
                        ErrorKind::Many0                     => "Many0",
                        ErrorKind::Many1                     => "Many1",
                        ErrorKind::Count                     => "Count",
                        ErrorKind::TakeUntil                 => "Take until",
                        ErrorKind::LengthValue               => "Length followed by value",
                        ErrorKind::TagClosure                => "Tag closure",
                        ErrorKind::Alpha                     => "Alphabetic",
                        ErrorKind::Digit                     => "Digit",
                        ErrorKind::AlphaNumeric              => "AlphaNumeric",
                        ErrorKind::Space                     => "Space",
                        ErrorKind::MultiSpace                => "Multiple spaces",
                        ErrorKind::LengthValueFn             => "LengthValueFn",
                        ErrorKind::Eof                       => "End of file",
                        ErrorKind::Switch                    => "Switch",
                        ErrorKind::TagBits                   => "Tag on bitstream",
                        ErrorKind::OneOf                     => "OneOf",
                        ErrorKind::NoneOf                    => "NoneOf",
                        ErrorKind::Char                      => "Char",
                        ErrorKind::CrLf                      => "CrLf",
                        ErrorKind::RegexpMatch               => "RegexpMatch",
                        ErrorKind::RegexpMatches             => "RegexpMatches",
                        ErrorKind::RegexpFind                => "RegexpFind",
                        ErrorKind::RegexpCapture             => "RegexpCapture",
                        ErrorKind::RegexpCaptures            => "RegexpCaptures",
                        ErrorKind::TakeWhile1                => "TakeWhile1",
                        ErrorKind::Complete                  => "Complete",
                        ErrorKind::Fix                       => "Fix",
                        ErrorKind::Escaped                   => "Escaped",
                        ErrorKind::EscapedTransform          => "EscapedTransform",
                        ErrorKind::NonEmpty                  => "NonEmpty",
                        ErrorKind::ManyMN                    => "Many(m, n)",
                        ErrorKind::HexDigit                  => "Hexadecimal Digit",
                        ErrorKind::OctDigit                  => "Octal digit",
                        ErrorKind::Not                       => "Negation",
                        ErrorKind::Permutation               => "Permutation",
                        ErrorKind::ManyTill                  => "ManyTill",
                        ErrorKind::Verify                    => "predicate verification",
                        ErrorKind::TakeTill1                 => "TakeTill1",
                        ErrorKind::TakeWhileMN               => "TakeWhileMN",
                        ErrorKind::TooLarge                  => "Needed data size is too large",
                        ErrorKind::Many0Count                => "Count occurrence of >=0 patterns",
                        ErrorKind::Many1Count                => "Count occurrence of >=1 patterns",
                        ErrorKind::Float                     => "Float",
                        ErrorKind::Satisfy                   => "Satisfy",
                        ErrorKind::Fail                      => "Fail",
                    }
                }
            }
            /// Prints a message and the input if the parser fails.
            pub fn dbg_dmp<'a, F, O, E: ::fmt::Debug>( f:F, context:&'static str ) 
            -> impl Fn(&'a [u8]) -> IResult<&'a [u8], O, E> where
            F: Fn(&'a [u8]) -> IResult<&'a [u8], O, E>,
            { 
                move |i: &'a [u8]| match f(i) 
                {
                    Err(e) => {
                    println!("{}: Error({:?}) at:\n{}", context, e, i.to_hex(8));
                    Err(e)
                    }
                    a => a,
                }
            }
        }

        pub mod branch
        {
            //! Choice combinators
            use ::
            {
                *,
            };
            use super::error::{ ErrorKind, ParseError };
            use super::internal::{Err, IResult, Parser};
            
            macro_rules! alt_trait
            (
                ($first:ident $second:ident $($id: ident)+) => (
                    alt_trait!(__impl $first $second; $($id)+);
                );
                (__impl $($current:ident)*; $head:ident $($id: ident)+) => (
                    alt_trait_impl!($($current)*);

                    alt_trait!(__impl $($current)* $head; $($id)+);
                );
                (__impl $($current:ident)*; $head:ident) => (
                    alt_trait_impl!($($current)*);
                    alt_trait_impl!($($current)* $head);
                );
            );

            macro_rules! alt_trait_impl
            (
                ($($id:ident)+) => (
                    impl<
                    Input: Clone, Output, Error: ParseError<Input>,
                    $($id: Parser<Input, Output, Error>),+
                    > Alt<Input, Output, Error> for ( $($id),+ ) {

                    fn choice(&mut self, input: Input) -> IResult<Input, Output, Error> {
                        match self.0.parse(input.clone()) {
                        Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),
                        res => res,
                        }
                    }
                    }
                );
            );

            macro_rules! alt_trait_inner
            (
                ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident $($id:ident)+) => (
                    match $self.$it.parse($input.clone()) {
                    Err(Err::Error(e)) => {
                        let err = $err.or(e);
                        succ!($it, alt_trait_inner!($self, $input, err, $($id)+))
                    }
                    res => res,
                    }
                );
                ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident) => (
                    Err(Err::Error(Error::append($input, ErrorKind::Alt, $err)))
                );
            );
            
            macro_rules! permutation_trait
            (
                (
                    $name1:ident $ty1:ident $item1:ident
                    $name2:ident $ty2:ident $item2:ident
                    $($name3:ident $ty3:ident $item3:ident)*
                ) => (
                    permutation_trait!(__impl $name1 $ty1 $item1, $name2 $ty2 $item2; $($name3 $ty3 $item3)*);
                );
                (
                    __impl $($name:ident $ty:ident $item:ident),+;
                    $name1:ident $ty1:ident $item1:ident $($name2:ident $ty2:ident $item2:ident)*
                ) => (
                    permutation_trait_impl!($($name $ty $item),+);
                    permutation_trait!(__impl $($name $ty $item),+ , $name1 $ty1 $item1; $($name2 $ty2 $item2)*);
                );
                (__impl $($name:ident $ty:ident $item:ident),+;) => (
                    permutation_trait_impl!($($name $ty $item),+);
                );
            );

            macro_rules! permutation_trait_impl
            (
                ($($name:ident $ty:ident $item:ident),+) => (
                    impl<
                    Input: Clone, $($ty),+ , Error: ParseError<Input>,
                    $($name: Parser<Input, $ty, Error>),+
                    > Permutation<Input, ( $($ty),+ ), Error> for ( $($name),+ )
                    {

                        fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>
                        {
                            let mut res = ($(Option::<$ty>::None),+);

                            loop
                            {
                                let mut err: Option<Error> = None;
                                permutation_trait_inner!(0, self, input, res, err, $($name)+);
                                
                                if let Some(err) = err
                                {
                                    return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));
                                }
                                
                                match res
                                {
                                    ($(Some($item)),+) => return Ok((input, ($($item),+))),
                                    _ => unreachable!(),
                                }
                            }
                        }
                    }
                );
            );

            macro_rules! permutation_trait_inner
            (
                ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr, $head:ident $($id:ident)*) => (
                    if $res.$it.is_none() {
                    match $self.$it.parse($input.clone()) {
                        Ok((i, o)) => {
                        $input = i;
                        $res.$it = Some(o);
                        continue;
                        }
                        Err(Err::Error(e)) => {
                        $err = Some(match $err {
                            Some(err) => err.or(e),
                            None => e,
                        });
                        }
                        Err(e) => return Err(e),
                    };
                    }
                    succ!($it, permutation_trait_inner!($self, $input, $res, $err, $($id)*));
                );
                ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr,) => ();
            );
            /// Helper trait for the [alt()] combinator.
            pub trait Alt<I, O, E> 
            {
                /// Tests each parser in the tuple and returns the result of the first one that succeeds
                fn choice(&mut self, input: I) -> IResult<I, O, E>;
            }
            /// Tests a list of parsers one by one until one succeeds.
            pub fn alt<I: Clone, O, E: ParseError<I>, List: Alt<I, O, E>>(
            mut l: List,
            ) -> impl FnMut(I) -> IResult<I, O, E>
            {
                move |i: I| l.choice(i)
            }
            /// Helper trait for the [permutation()] combinator.
            pub trait Permutation<I, O, E>
            {
                /// Tries to apply all parsers in the tuple in various orders until all of them succeed
                fn permutation(&mut self, input: I) -> IResult<I, O, E>;
            }
            /// Applies a list of parsers in any order.
            pub fn permutation<I: Clone, O, E: ParseError<I>, List: Permutation<I, O, E>>( mut l: List ) -> 
            impl FnMut(I) -> IResult<I, O, E>
            { move |i: I| l.permutation(i) }

            alt_trait!(A B C D E F G H I J K L M N O P Q R S T U);
            
            impl<Input, Output, Error: ParseError<Input>, A: Parser<Input, Output, Error>>
            Alt<Input, Output, Error> for (A,)
            {
                fn choice(&mut self, input: Input) -> IResult<Input, Output, Error> { self.0.parse(input) }
            }

            permutation_trait!
            (
                FnA A a
                FnB B b
                FnC C c
                FnD D d
                FnE E e
                FnF F f
                FnG G g
                FnH H h
                FnI I i
                FnJ J j
                FnK K k
                FnL L l
                FnM M m
                FnN N n
                FnO O o
                FnP P p
                FnQ Q q
                FnR R r
                FnS S s
                FnT T t
                FnU U u
            );
        }
        
        pub mod combinator
        {
            use ::
            {
                boxed::{ Box },
                borrow::{ Borrow },
                convert::{ Into },
                fmt::{ Debug },
                mem::{ transmute },
                ops::{Range, RangeFrom, RangeTo},
                parsers::nom::
                {
                    error::{ErrorKind, FromExternalError, ParseError},
                    internal::*,
                    traits::{AsChar, Compare, CompareResult, Offset, Slice, InputIter, InputLength, InputTakeAtPosition, ParseTo},
                },
                *,
            };
            /// Return the remaining input.
            #[inline] pub fn rest<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>>,
            T: InputLength,
            {
                Ok((input.slice(input.input_len()..), input))
            }
            /// Return the length of the remaining input.
            #[inline] pub fn rest_len<T, E: ParseError<T>>(input: T) -> IResult<T, usize, E> where
            T: InputLength,
            {
                let len = input.input_len();
                Ok((input, len))
            }
            /// Maps a function on the result of a parser.
            pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> O2,
            {
                move |input: I| 
                    {
                    let (input, o1) = parser.parse(input)?;
                    Ok((input, f(o1)))
                }
            }
            /// Applies a function returning a `Result` over the result of a parser.
            pub fn map_res<I: Clone, O1, O2, E: FromExternalError<I, E2>, E2, F, G>(
            mut parser: F,
            mut f: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> Result<O2, E2>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    let (input, o1) = parser.parse(input)?;
                    match f(o1) {
                    Ok(o2) => Ok((input, o2)),
                    Err(e) => Err(Err::Error(E::from_external_error(i, ErrorKind::MapRes, e))),
                    }
                }
            }
            /// Applies a function returning an `Option` over the result of a parser.
            pub fn map_opt<I: Clone, O1, O2, E: ParseError<I>, F, G>(
            mut parser: F,
            mut f: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> Option<O2>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    let (input, o1) = parser.parse(input)?;
                    match f(o1) {
                    Some(o2) => Ok((input, o2)),
                    None => Err(Err::Error(E::from_error_kind(i, ErrorKind::MapOpt))),
                    }
                }
            }
            /// Applies a parser over the result of another one.
            pub fn map_parser<I, O1, O2, E: ParseError<I>, F, G>(
            mut parser: F,
            mut applied_parser: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: Parser<O1, O2, E>,
            {
                move |input: I| 
                    {
                    let (input, o1) = parser.parse(input)?;
                    let (_, o2) = applied_parser.parse(o1)?;
                    Ok((input, o2))
                }
            }
            /// Creates a new parser from the output of the first parser,
            /// then apply that parser over the rest of the input.
            pub fn flat_map<I, O1, O2, E: ParseError<I>, F, G, H>(
            mut parser: F,
            mut applied_parser: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: FnMut(O1) -> H,
            H: Parser<I, O2, E>,
            {
                move |input: I| 
                    {
                    let (input, o1) = parser.parse(input)?;
                    applied_parser(o1).parse(input)
                }
            }
            /// Optional parser, will return `None` on [`Err::Error`].
            pub fn opt<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    match f.parse(input) {
                    Ok((i, o)) => Ok((i, Some(o))),
                    Err(Err::Error(_)) => Ok((i, None)),
                    Err(e) => Err(e),
                    }
                }
            }
            /// Calls the parser if the condition is met.
            pub fn cond<I, O, E: ParseError<I>, F>(
            b: bool,
            mut f: F,
            ) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    if b {
                    match f.parse(input) {
                        Ok((i, o)) => Ok((i, Some(o))),
                        Err(e) => Err(e),
                    }
                    } else {
                    Ok((input, None))
                    }
                }
            }
            /// Tries to apply its parser without consuming the input.
            pub fn peek<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    match f.parse(input) {
                    Ok((_, o)) => Ok((i, o)),
                    Err(e) => Err(e),
                    }
                }
            }
            /// returns its input if it is at the end of input data.
            pub fn eof<I: InputLength + Clone, E: ParseError<I>>( input:I ) -> IResult<I, I, E>
            {
                if input.input_len() == 0 {
                    let clone = input.clone();
                    Ok((input, clone))
                } else {
                    Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))
                }
            }
            /// Transforms Incomplete into `Error`.
            pub fn complete<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    match f.parse(input) {
                    Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                    rest => rest,
                    }
                }
            }
            /// Succeeds if all the input has been consumed by its child parser.
            pub fn all_consuming<I, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
            I: InputLength,
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let (input, res) = f.parse(input)?;
                    if input.input_len() == 0 {
                    Ok((input, res))
                    } else {
                    Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))
                    }
                }
            }
            /// Returns the result of the child parser if it satisfies a verification function.
            pub fn verify<I: Clone, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            second: G,
            ) -> impl FnMut(I) -> IResult<I, O1, E> where
            F: Parser<I, O1, E>,
            G: Fn(&O2) -> bool,
            O1: Borrow<O2>,
            O2: ?Sized,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    let (input, o) = first.parse(input)?;

                    if second(o.borrow()) {
                    Ok((input, o))
                    } else {
                    Err(Err::Error(E::from_error_kind(i, ErrorKind::Verify)))
                    }
                }
            }
            /// Returns the provided value if the child parser succeeds.
            pub fn value<I, O1: Clone, O2, E: ParseError<I>, F>(
            val: O1,
            mut parser: F,
            ) -> impl FnMut(I) -> IResult<I, O1, E> where
            F: Parser<I, O2, E>,
            {
                move |input: I| parser.parse(input).map(|(i, _)| (i, val.clone()))
            }
            /// Succeeds if the child parser returns an error.
            pub fn not<I: Clone, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, (), E> where
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    match parser.parse(input) {
                    Ok(_) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Not))),
                    Err(Err::Error(_)) => Ok((i, ())),
                    Err(e) => Err(e),
                    }
                }
            }
            /// If the child parser was successful, return the consumed input as produced value.
            pub fn recognize<I: Clone + Offset + Slice<RangeTo<usize>>, O, E: ParseError<I>, F>(
            mut parser: F,
            ) -> impl FnMut(I) -> IResult<I, I, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    match parser.parse(i) {
                    Ok((i, _)) => {
                        let index = input.offset(&i);
                        Ok((i, input.slice(..index)))
                    }
                    Err(e) => Err(e),
                    }
                }
            }
            /// if the child parser was successful, return the consumed input with the output as a tuple.
            pub fn consumed<I, O, F, E>(mut parser: F) -> impl FnMut(I) -> IResult<I, (I, O), E> where
            I: Clone + Offset + Slice<RangeTo<usize>>,
            E: ParseError<I>,
            F: Parser<I, O, E>,
            {
                move |input: I| 
                    {
                    let i = input.clone();
                    match parser.parse(i) {
                    Ok((remaining, result)) => {
                        let index = input.offset(&remaining);
                        let consumed = input.slice(..index);
                        Ok((remaining, (consumed, result)))
                    }
                    Err(e) => Err(e),
                    }
                }
            }
            /// Transforms an [`Err::Error`] (recoverable) to [`Err::Failure`] (unrecoverable)
            pub fn cut<I, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O, E> where
            F: Parser<I, O, E>,
            {
                move |input: I| match parser.parse(input) {
                    Err(Err::Error(e)) => Err(Err::Failure(e)),
                    rest => rest,
                }
            }
            /// automatically converts the child parser's result to another type
            pub fn into<I, O1, O2, E1, E2, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O2, E2> where
            O1: Into<O2>,
            E1: Into<E2>,
            E1: ParseError<I>,
            E2: ParseError<I>,
            F: Parser<I, O1, E1>,
            {
                //map(parser, Into::into)
                move |input: I| match parser.parse(input) {
                    Ok((i, o)) => Ok((i, o.into())),
                    Err(Err::Error(e)) => Err(Err::Error(e.into())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
                }
            }
            /// Creates an iterator from input data and a parser.
            pub fn iterator<Input, Output, Error, F>(input: Input, f: F) -> ParserIterator<Input, Error, F> where
            F: Parser<Input, Output, Error>,
            Error: ParseError<Input>,
            {
                ParserIterator {
                    iterator: f,
                    input,
                    state: Some(State::Running),
                }
            }
            /// Main structure associated to the [iterator] function.
            pub struct ParserIterator<I, E, F>
            {
                iterator: F,
                input: I,
                state: Option<State<E>>,
            }

            impl<I: Clone, E, F> ParserIterator<I, E, F> 
            {
                /// Returns the remaining input if parsing was successful, or the error if we encountered an error.
                pub fn finish(mut self) -> IResult<I, (), E> {
                    match self.state.take().unwrap() {
                    State::Running | State::Done => Ok((self.input, ())),
                    State::Failure(e) => Err(Err::Failure(e)),
                    State::Incomplete(i) => Err(Err::Incomplete(i)),
                    }
                }
            }

            impl<'a, Input, Output, Error, F> ::iter::Iterator for &'a mut ParserIterator<Input, Error, F> where
            F: FnMut(Input) -> IResult<Input, Output, Error>,
            Input: Clone,
            {
                type Item = Output;

                fn next(&mut self) -> Option<Self::Item> {
                    if let State::Running = self.state.take().unwrap() {
                    let input = self.input.clone();

                    match (self.iterator)(input) {
                        Ok((i, o)) => {
                        self.input = i;
                        self.state = Some(State::Running);
                        Some(o)
                        }
                        Err(Err::Error(_)) => {
                        self.state = Some(State::Done);
                        None
                        }
                        Err(Err::Failure(e)) => {
                        self.state = Some(State::Failure(e));
                        None
                        }
                        Err(Err::Incomplete(i)) => {
                        self.state = Some(State::Incomplete(i));
                        None
                        }
                    }
                    } else {
                    None
                    }
                }
            }

            enum State<E>
            {
                Running,
                Done,
                Failure(E),
                Incomplete(Needed),
            }
            /// a parser which always succeeds with given value without consuming any input.
            pub fn success<I, O: Clone, E: ParseError<I>>(val: O) -> impl Fn(I) -> IResult<I, O, E> 
            {
                move |input: I| Ok((input, val.clone()))
            }
            /// A parser which always fails.
            pub fn fail<I, O, E: ParseError<I>>(i: I) -> IResult<I, O, E>
            {
                Err(Err::Error(E::from_error_kind(i, ErrorKind::Fail)))
            }
        }

        pub mod internal
        {
            //! Basic types to build the parsers
            use ::
            {
                borrow::{ ToOwned },
                boxed::{ Box },
                marker::{ PhantomData, Sized },
                num::NonZeroUsize,
                parsers::nom::
                {
                    error::{ self, ErrorKind, ParseError }
                },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /// Holds the result of parsing functions.
            pub type IResult<I, O, E = error::Error<I>> = Result<(I, O), Err<E>>;
            /// Helper trait to convert a parser's result to a more manageable type
            pub trait Finish<I, O, E>
            {
                /// Converts the parser's result to a type that is more consumable by error management libraries.
                fn finish(self) -> Result<(I, O), E>;
            }

            impl<I, O, E> Finish<I, O, E> for IResult<I, O, E> 
            {
                fn finish(self) -> Result<(I, O), E> 
                {
                    match self {
                    Ok(res) => Ok(res),
                    Err(Err::Error(e)) | Err(Err::Failure(e)) => Err(e),
                    Err(Err::Incomplete(_)) => {
                        panic!("Cannot call `finish()` on `Err(Err::Incomplete(_))`: this result means that the parser does not have enough data to decide, you should gather more data and try to reapply  the parser instead")
                    }
                    }
                }
            }
            /// Contains information on needed data if a parser returned `Incomplete`
            #[derive(Debug, PartialEq, Eq, Clone, Copy)]
            pub enum Needed 
            {
                /// Needs more data, but we do not know how much
                Unknown,
                /// Contains the required data size in bytes
                Size(NonZeroUsize),
            }

            impl Needed 
            {
                /// Creates `Needed` instance, returns `Needed::Unknown` if the argument is zero
                pub fn new(s: usize) -> Self 
                {
                    match NonZeroUsize::new(s) {
                    Some(sz) => Needed::Size(sz),
                    None => Needed::Unknown,
                    }
                }
                /// Indicates if we know how many bytes we need
                pub fn is_known(&self) -> bool { *self != Needed::Unknown }
                /// Maps a `Needed` to `Needed` by applying a function to a contained `Size` value.
                #[inline] pub fn map<F: Fn(NonZeroUsize) -> usize>(self, f: F) -> Needed
                {
                    match self 
                    {
                        Needed::Unknown => Needed::Unknown,
                        Needed::Size(n) => Needed::new(f(n)),
                    }
                }
            }
            /// The `Err` enum indicates the parser was not successful.
            #[derive(Debug, Clone, PartialEq)]
            pub enum Err<E>
            {
                /// There was not enough data
                Incomplete(Needed),
                /// The parser had an error (recoverable)
                Error(E),
                /// The parser had an unrecoverable error: we got to the right
                /// branch and we know other branches won't work, so backtrack
                /// as fast as possible
                Failure(E),
            }

            impl<E> Err<E> 
            {
                /// Tests if the result is Incomplete
                pub fn is_incomplete(&self) -> bool {
                    if let Err::Incomplete(_) = self {
                    true
                    } else {
                    false
                    }
                }
                /// Applies the given function to the inner error
                pub fn map<E2, F>(self, f: F) -> Err<E2> where
                    F: FnOnce(E) -> E2,
                {
                    match self {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure(t) => Err::Failure(f(t)),
                    Err::Error(t) => Err::Error(f(t)),
                    }
                }
                /// Automatically converts between errors if the underlying type supports it
                pub fn convert<F>(e: Err<F>) -> Self where
                    E: From<F>,
                {
                    e.map( ::convert::Into::into )
                }
            }

            impl<T> Err<(T, ErrorKind)>
            {
                /// Maps `Err<(T, ErrorKind)>` to `Err<(U, ErrorKind)>` with the given `F: T -> U`
                pub fn map_input<U, F>(self, f: F) -> Err<(U, ErrorKind)> where
                    F: FnOnce(T) -> U,
                {
                    match self {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure((input, k)) => Err::Failure((f(input), k)),
                    Err::Error((input, k)) => Err::Error((f(input), k)),
                    }
                }
            }

            impl<T> Err<error::Error<T>> 
            {
                /// Maps `Err<error::Error<T>>` to `Err<error::Error<U>>` with the given `F: T -> U`
                pub fn map_input<U, F>(self, f: F) -> Err<error::Error<U>> where
                    F: FnOnce(T) -> U,
                {
                    match self {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure(error::Error { input, code }) => Err::Failure(error::Error {
                        input: f(input),
                        code,
                    }),
                    Err::Error(error::Error { input, code }) => Err::Error(error::Error {
                        input: f(input),
                        code,
                    }),
                    }
                }
            }
            
            impl Err<(&[u8], ErrorKind)>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<(Vec<u8>, ErrorKind)> {
                    self.map_input(ToOwned::to_owned)
                }
            }
            
            impl Err<(&str, ErrorKind)>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<(String, ErrorKind)> {
                    self.map_input(ToOwned::to_owned)
                }
            }
            
            impl Err<error::Error<&[u8]>>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<error::Error<Vec<u8>>> {
                    self.map_input(ToOwned::to_owned)
                }
            }
            
            impl Err<error::Error<&str>>
            {
                /// Obtaining ownership
                pub fn to_owned(self) -> Err<error::Error<String>> {
                    self.map_input(ToOwned::to_owned)
                }
            }

            impl<E: Eq> Eq for Err<E> {}

            impl<E> fmt::Display for Err<E> where
            E: fmt::Debug,
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    match self {
                    Err::Incomplete(Needed::Size(u)) => write!(f, "Parsing requires {} bytes/chars", u),
                    Err::Incomplete(Needed::Unknown) => write!(f, "Parsing requires more data"),
                    Err::Failure(c) => write!(f, "Parsing Failure: {:?}", c),
                    Err::Error(c) => write!(f, "Parsing Error: {:?}", c),
                    }
                }
            }
            
            use ::error::Error;
            
            impl<E> Error for Err<E> where
            E: fmt::Debug,
            {
                fn source(&self) -> Option<&(dyn Error + 'static)> {
                    None
                }
            }
            /// All nom parsers implement this trait
            pub trait Parser<I, O, E>
            {
                /// A parser takes in input type, 
                /// and returns a `Result` containing either the remaining input and the output value, or an error.
                fn parse(&mut self, input: I) -> IResult<I, O, E>;
                /// Maps a function over the result of a parser
                fn map<G, O2>(self, g: G) -> Map<Self, G, O> where
                    G: Fn(O) -> O2,
                    Self: Sized,
                {
                    Map {
                    f: self,
                    g,
                    phantom: PhantomData,
                    }
                }
                /// Creates a second parser from the output of the first one, then apply over the rest of the input
                fn flat_map<G, H, O2>(self, g: G) -> FlatMap<Self, G, O> where
                    G: FnMut(O) -> H,
                    H: Parser<I, O2, E>,
                    Self: Sized,
                {
                    FlatMap {
                    f: self,
                    g,
                    phantom: PhantomData,
                    }
                }
                /// Applies a second parser over the output of the first one
                fn and_then<G, O2>(self, g: G) -> AndThen<Self, G, O> where
                    G: Parser<O, O2, E>,
                    Self: Sized,
                {
                    AndThen {
                    f: self,
                    g,
                    phantom: PhantomData,
                    }
                }
                /// Applies a second parser after the first one, return their results as a tuple
                fn and<G, O2>(self, g: G) -> And<Self, G> where
                    G: Parser<I, O2, E>,
                    Self: Sized,
                {
                    And { f: self, g }
                }
                /// Applies a second parser over the input if the first one failed
                fn or<G>(self, g: G) -> Or<Self, G> where
                    G: Parser<I, O, E>,
                    Self: Sized,
                {
                    Or { f: self, g }
                }
                /// automatically converts the parser's output and error values to another type, as long as they
                /// implement the `From` trait
                fn into<O2: From<O>, E2: From<E>>(self) -> Into<Self, O, O2, E, E2> where
                    Self: Sized,
                {
                    Into {
                    f: self,
                    phantom_out1: PhantomData,
                    phantom_err1: PhantomData,
                    phantom_out2: PhantomData,
                    phantom_err2: PhantomData,
                    }
                }
            }

            impl<'a, I, O, E, F> Parser<I, O, E> for F where
            F: FnMut(I) -> IResult<I, O, E> + 'a,
            {
                fn parse(&mut self, i: I) -> IResult<I, O, E> {
                    self(i)
                }
            }
            
            impl<'a, I, O, E> Parser<I, O, E> for Box<dyn Parser<I, O, E> + 'a> 
            {
                fn parse(&mut self, input: I) -> IResult<I, O, E> {
                    (**self).parse(input)
                }
            }
            /// Implementation of `Parser::map`            
            pub struct Map<F, G, O1>
            {
                f: F,
                g: G,
                phantom: PhantomData<O1>,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> O2> Parser<I, O2, E> for Map<F, G, O1>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E> {
                    match self.f.parse(i) {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, (self.g)(o))),
                    }
                }
            }
            /// Implementation of `Parser::flat_map`
            pub struct FlatMap<F, G, O1> 
            {
                f: F,
                g: G,
                phantom: PhantomData<O1>,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> H, H: Parser<I, O2, E>> Parser<I, O2, E>
            for FlatMap<F, G, O1>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E>
                {
                    let (i, o1) = self.f.parse(i)?;
                    (self.g)(o1).parse(i)
                }
            }
            /// Implementation of `Parser::and_then`            
            pub struct AndThen<F, G, O1> 
            {
                f: F,
                g: G,
                phantom: PhantomData<O1>,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<O1, O2, E>> Parser<I, O2, E>
            for AndThen<F, G, O1>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E>
                {
                    let (i, o1) = self.f.parse(i)?;
                    let (_, o2) = self.g.parse(o1)?;
                    Ok((i, o2))
                }
            }
            /// Implementation of `Parser::and`            
            pub struct And<F, G> 
            {
                f: F,
                g: G,
            }

            impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<I, O2, E>> Parser<I, (O1, O2), E>
            for And<F, G>
            {
                fn parse(&mut self, i: I) -> IResult<I, (O1, O2), E>
                {
                    let (i, o1) = self.f.parse(i)?;
                    let (i, o2) = self.g.parse(i)?;
                    Ok((i, (o1, o2)))
                }
            }
            /// Implementation of `Parser::or`            
            pub struct Or<F, G> 
            {
                f: F,
                g: G,
            }

            impl<'a, I: Clone, O, E: ParseError<I>, F: Parser<I, O, E>, G: Parser<I, O, E>>
            Parser<I, O, E> for Or<F, G>
            {
                fn parse(&mut self, i: I) -> IResult<I, O, E> {
                    match self.f.parse(i.clone()) {
                    Err(Err::Error(e1)) => match self.g.parse(i) {
                        Err(Err::Error(e2)) => Err(Err::Error(e1.or(e2))),
                        res => res,
                    },
                    res => res,
                    }
                }
            }
            /// Implementation of `Parser::into`
            pub struct Into<F, O1, O2: From<O1>, E1, E2: From<E1>> 
            {
                f: F,
                phantom_out1: PhantomData<O1>,
                phantom_err1: PhantomData<E1>,
                phantom_out2: PhantomData<O2>,
                phantom_err2: PhantomData<E2>,
            }

            impl<
                'a,
                I: Clone,
                O1,
                O2: From<O1>,
                E1,
                E2: ParseError<I> + From<E1>,
                F: Parser<I, O1, E1>,
            > Parser<I, O2, E2> for Into<F, O1, O2, E1, E2>
            {
                fn parse(&mut self, i: I) -> IResult<I, O2, E2> 
                {
                    match self.f.parse(i) {
                    Ok((i, o)) => Ok((i, o.into())),
                    Err(Err::Error(e)) => Err(Err::Error(e.into())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
                    }
                }
            }

        } pub use self::internal::*;
        
        pub mod multi
        {
            use ::
            {
                mem::{ size_of },
                num::{ NonZeroUsize },
                parsers::nom::
                {
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult, Needed, Parser },
                    traits::{ InputLength, InputTake, ToUsize },
                },
                vec::{ Vec },
                *,
            };
            /// Don't pre-allocate more than 64KiB when calling `Vec::with_capacity`.
            const MAX_INITIAL_CAPACITY_BYTES: usize = 65536;
            /// Repeats the embedded parser, gathering the results in a `Vec`.
            pub fn many0<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |mut i: I| 
                    {
                    let mut acc = Vec::with_capacity(4);
                    loop {
                    let len = i.input_len();
                    match f.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, acc)),
                        Err(e) => return Err(e),
                        Ok((i1, o)) => {
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many0)));
                        }

                        i = i1;
                        acc.push(o);
                        }
                    }
                    }
                }
            }
            /// Runs the embedded parser, gathering the results in a `Vec`.
            pub fn many1<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |mut i: I| match f.parse(i.clone()) {
                    Err(Err::Error(err)) => Err(Err::Error(E::append(i, ErrorKind::Many1, err))),
                    Err(e) => Err(e),
                    Ok((i1, o)) =>
                {
                    let mut acc = Vec::with_capacity(4);
                    acc.push(o);
                    i = i1;

                    loop {
                        let len = i.input_len();
                        match f.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, acc)),
                        Err(e) => return Err(e),
                        Ok((i1, o)) => {
                            if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1)));
                            }

                            i = i1;
                            acc.push(o);
                        }
                        }
                    }
                    }
                }
            }
            /// Applies the parser `f` until the parser `g` produces a result.
            pub fn many_till<I, O, P, E, F, G>(
            mut f: F,
            mut g: G,
            ) -> impl FnMut(I) -> IResult<I, (Vec<O>, P), E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: Parser<I, P, E>,
            E: ParseError<I>,
            {
                move |mut i: I| 
                    {
                    let mut res = Vec::new();
                    loop {
                    let len = i.input_len();
                    match g.parse(i.clone()) {
                        Ok((i1, o)) => return Ok((i1, (res, o))),
                        Err(Err::Error(_)) => {
                        match f.parse(i.clone()) {
                            Err(Err::Error(err)) => return Err(Err::Error(E::append(i, ErrorKind::ManyTill, err))),
                            Err(e) => return Err(e),
                            Ok((i1, o)) => {
                            if i1.input_len() == len {
                                return Err(Err::Error(E::from_error_kind(i1, ErrorKind::ManyTill)));
                            }

                            res.push(o);
                            i = i1;
                            }
                        }
                        }
                        Err(e) => return Err(e),
                    }
                    }
                }
            }
            /// Alternates between two parsers to produce a list of elements.
            pub fn separated_list0<I, O, O2, E, F, G>(
            mut sep: G,
            mut f: F,
            ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: Parser<I, O2, E>,
            E: ParseError<I>,
            {
                move |mut i: I| 
                    {
                    let mut res = Vec::new();

                    match f.parse(i.clone()) {
                    Err(Err::Error(_)) => return Ok((i, res)),
                    Err(e) => return Err(e),
                    Ok((i1, o)) => {
                        res.push(o);
                        i = i1;
                    }
                    }

                    loop {
                    let len = i.input_len();
                    match sep.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i1, _)) => {
                       
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));
                        }

                        match f.parse(i1.clone()) {
                            Err(Err::Error(_)) => return Ok((i, res)),
                            Err(e) => return Err(e),
                            Ok((i2, o)) => {
                            res.push(o);
                            i = i2;
                            }
                        }
                        }
                    }
                    }
                }
            }
            /// Alternates between two parsers to produce a list of elements until [`Err::Error`].
            pub fn separated_list1<I, O, O2, E, F, G>(
            mut sep: G,
            mut f: F,
            ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: Parser<I, O2, E>,
            E: ParseError<I>,
            {
                move |mut i: I| 
                    {
                    let mut res = Vec::new();
                    
                    match f.parse(i.clone()) {
                    Err(e) => return Err(e),
                    Ok((i1, o)) => {
                        res.push(o);
                        i = i1;
                    }
                    }

                    loop {
                    let len = i.input_len();
                    match sep.parse(i.clone()) {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i1, _)) => {
                       
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));
                        }

                        match f.parse(i1.clone()) {
                            Err(Err::Error(_)) => return Ok((i, res)),
                            Err(e) => return Err(e),
                            Ok((i2, o)) => {
                            res.push(o);
                            i = i2;
                            }
                        }
                        }
                    }
                    }
                }
            }
            /// Repeats the embedded parser `m..=n` times.
            pub fn many_m_n<I, O, E, F>(
            min: usize,
            max: usize,
            mut parse: F,
            ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |mut input: I| 
                    {
                    if min > max {
                    return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));
                    }

                    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / size_of::<O>().max(1);
                    let mut res = Vec::with_capacity(min.min(max_initial_capacity));
                    for count in 0..max {
                    let len = input.input_len();
                    match parse.parse(input.clone()) {
                        Ok((tail, value)) => {
                       
                        if tail.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(input, ErrorKind::ManyMN)));
                        }

                        res.push(value);
                        input = tail;
                        }
                        Err(Err::Error(e)) => {
                        if count < min {
                            return Err(Err::Error(E::append(input, ErrorKind::ManyMN, e)));
                        } else {
                            return Ok((input, res));
                        }
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, res))
                }
            }
            /// Repeats the embedded parser, counting the results.
            pub fn many0_count<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let mut input = i;
                    let mut count = 0;

                    loop {
                    let input_ = input.clone();
                    let len = input.input_len();
                    match f.parse(input_) {
                        Ok((i, _)) => {
                       
                        if i.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0Count)));
                        }

                        input = i;
                        count += 1;
                        }

                        Err(Err::Error(_)) => return Ok((input, count)),

                        Err(e) => return Err(e),
                    }
                    }
                }
            }
            /// Runs the embedded parser, counting the results.
            pub fn many1_count<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let i_ = i.clone();
                    match f.parse(i_) {
                    Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count))),
                    Err(i) => Err(i),
                    Ok((i1, _)) => {
                        let mut count = 1;
                        let mut input = i1;

                        loop {
                        let len = input.input_len();
                        let input_ = input.clone();
                        match f.parse(input_) {
                            Err(Err::Error(_)) => return Ok((input, count)),
                            Err(e) => return Err(e),
                            Ok((i, _)) => {
                           
                            if i.input_len() == len {
                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count)));
                            }

                            count += 1;
                            input = i;
                            }
                        }
                        }
                    }
                    }
                }
            }
            /// Runs the embedded parser `count` times, gathering the results in a `Vec`.
            pub fn count<I, O, E, F>(mut f: F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone + PartialEq,
            F: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let mut input = i.clone();
                    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / size_of::<O>().max(1);
                    let mut res = Vec::with_capacity(count.min(max_initial_capacity));

                    for _ in 0..count {
                    let input_ = input.clone();
                    match f.parse(input_) {
                        Ok((i, o)) => {
                        res.push(o);
                        input = i;
                        }
                        Err(Err::Error(e)) => {
                        return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, res))
                }
            }
            /// Runs the embedded parser repeatedly, filling the given slice with results.
            pub fn fill<'a, I, O, E, F>(f: F, buf: &'a mut [O]) -> impl FnMut(I) -> IResult<I, (), E> + 'a where
            I: Clone + PartialEq,
            F: Fn(I) -> IResult<I, O, E> + 'a,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let mut input = i.clone();

                    for elem in buf.iter_mut() {
                    let input_ = input.clone();
                    match f(input_) {
                        Ok((i, o)) => {
                        *elem = o;
                        input = i;
                        }
                        Err(Err::Error(e)) => {
                        return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, ()))
                }
            }
            /// Repeats the embedded parser, calling `g` to gather the results.
            pub fn fold_many0<I, O, E, F, G, H, R>(
            mut f: F,
            mut init: H,
            mut g: G,
            ) -> impl FnMut(I) -> IResult<I, R, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: FnMut(R, O) -> R,
            H: FnMut() -> R,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let mut res = init();
                    let mut input = i;

                    loop {
                    let i_ = input.clone();
                    let len = input.input_len();
                    match f.parse(i_) {
                        Ok((i, o)) => {
                       
                        if i.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0)));
                        }

                        res = g(res, o);
                        input = i;
                        }
                        Err(Err::Error(_)) => {
                        return Ok((input, res));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }
                }
            }
            /// Repeats the embedded parser, calling `g` to gather the results.
            pub fn fold_many1<I, O, E, F, G, H, R>(
            mut f: F,
            mut init: H,
            mut g: G,
            ) -> impl FnMut(I) -> IResult<I, R, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: FnMut(R, O) -> R,
            H: FnMut() -> R,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let _i = i.clone();
                    let init = init();
                    match f.parse(_i) {
                    Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1))),
                    Err(e) => Err(e),
                    Ok((i1, o1)) => {
                        let mut acc = g(init, o1);
                        let mut input = i1;

                        loop {
                        let _input = input.clone();
                        let len = input.input_len();
                        match f.parse(_input) {
                            Err(Err::Error(_)) => {
                            break;
                            }
                            Err(e) => return Err(e),
                            Ok((i, o)) => {
                           
                            if i.input_len() == len {
                                return Err(Err::Failure(E::from_error_kind(i, ErrorKind::Many1)));
                            }

                            acc = g(acc, o);
                            input = i;
                            }
                        }
                        }

                        Ok((input, acc))
                    }
                    }
                }
            }
            /// Repeats the embedded parser `m..=n` times, calling `g` to gather the results.
            pub fn fold_many_m_n<I, O, E, F, G, H, R>(
            min: usize,
            max: usize,
            mut parse: F,
            mut init: H,
            mut fold: G,
            ) -> impl FnMut(I) -> IResult<I, R, E> where
            I: Clone + InputLength,
            F: Parser<I, O, E>,
            G: FnMut(R, O) -> R,
            H: FnMut() -> R,
            E: ParseError<I>,
            {
                move |mut input: I| 
                    {
                    if min > max {
                    return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));
                    }

                    let mut acc = init();
                    for count in 0..max {
                    let len = input.input_len();
                    match parse.parse(input.clone()) {
                        Ok((tail, value)) => {
                        if tail.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(tail, ErrorKind::ManyMN)));
                        }

                        acc = fold(acc, value);
                        input = tail;
                        }
                        Err(Err::Error(err)) => {
                        if count < min {
                            return Err(Err::Error(E::append(input, ErrorKind::ManyMN, err)));
                        } else {
                            break;
                        }
                        }
                        Err(e) => return Err(e),
                    }
                    }

                    Ok((input, acc))
                }
            }
            /// Gets a number from the parser and returns a subslice of the input of that size.
            pub fn length_data<I, N, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, I, E> where
            I: InputLength + InputTake,
            N: ToUsize,
            F: Parser<I, N, E>,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let (i, length) = f.parse(i)?;

                    let length: usize = length.to_usize();

                    if let Some(needed) = length
                    .checked_sub(i.input_len())
                    .and_then(NonZeroUsize::new)
                    {
                    Err(Err::Incomplete(Needed::Size(needed)))
                    } else {
                    Ok(i.take_split(length))
                    }
                }
            }
            /// Gets a number from the first parser, takes a subslice of the input of that size, 
            /// then applies the second parser on that subslice.
            pub fn length_value<I, O, N, E, F, G>(mut f: F, mut g: G) -> impl FnMut(I) -> IResult<I, O, E> where
            I: Clone + InputLength + InputTake,
            N: ToUsize,
            F: Parser<I, N, E>,
            G: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let (i, length) = f.parse(i)?;

                    let length: usize = length.to_usize();

                    if let Some(needed) = length
                    .checked_sub(i.input_len())
                    .and_then(NonZeroUsize::new)
                    {
                    Err(Err::Incomplete(Needed::Size(needed)))
                    } else {
                    let (rest, i) = i.take_split(length);
                    match g.parse(i.clone()) {
                        Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                        Err(e) => Err(e),
                        Ok((_, o)) => Ok((rest, o)),
                    }
                    }
                }
            }
            /// Gets a number from the first parser, then applies the second parser that many times.
            pub fn length_count<I, O, N, E, F, G>(mut f: F, mut g: G) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
            I: Clone,
            N: ToUsize,
            F: Parser<I, N, E>,
            G: Parser<I, O, E>,
            E: ParseError<I>,
            {
                move |i: I| 
                    {
                    let (i, count) = f.parse(i)?;
                    let mut input = i.clone();
                    let mut res = Vec::new();

                    for _ in 0..count.to_usize() {
                    let input_ = input.clone();
                    match g.parse(input_) {
                        Ok((i, o)) => {
                        res.push(o);
                        input = i;
                        }
                        Err(Err::Error(e)) => {
                        return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input, res))
                }
            }
        }
        
        pub mod sequence
        {
            //! Combinators applying parsers in sequence
            use ::
            {                
                parsers::nom::
                {
                    error::ParseError,
                    internal::{IResult, Parser},
                },
                *,
            };            

            macro_rules! tuple_trait
            (
                ($name1:ident $ty1:ident, $name2: ident $ty2:ident, $($name:ident $ty:ident),*) => (
                    tuple_trait!(__impl $name1 $ty1, $name2 $ty2; $($name $ty),*);
                );
                (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident, $($name2:ident $ty2:ident),*) => (
                    tuple_trait_impl!($($name $ty),+);
                    tuple_trait!(__impl $($name $ty),+ , $name1 $ty1; $($name2 $ty2),*);
                );
                (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident) => (
                    tuple_trait_impl!($($name $ty),+);
                    tuple_trait_impl!($($name $ty),+, $name1 $ty1);
                );
            );

            macro_rules! tuple_trait_impl
            (
                ($($name:ident $ty: ident),+) => (
                    impl<
                    Input: Clone, $($ty),+ , Error: ParseError<Input>,
                    $($name: Parser<Input, $ty, Error>),+
                    > Tuple<Input, ( $($ty),+ ), Error> for ( $($name),+ ) {

                    fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error> {
                        tuple_trait_inner!(0, self, input, (), $($name)+)

                    }
                    }
                );
            );

            macro_rules! tuple_trait_inner
            (
                ($it:tt, $self:expr, $input:expr, (), $head:ident $($id:ident)+) => ({
                    let (i, o) = $self.$it.parse($input.clone())?;

                    succ!($it, tuple_trait_inner!($self, i, ( o ), $($id)+))
                });
                ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident $($id:ident)+) => ({
                    let (i, o) = $self.$it.parse($input.clone())?;

                    succ!($it, tuple_trait_inner!($self, i, ($($parsed)* , o), $($id)+))
                });
                ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident) => ({
                    let (i, o) = $self.$it.parse($input.clone())?;

                    Ok((i, ($($parsed)* , o)))
                });
            );
            /// Gets an object from the first parser, then gets another object from the second parser.
            pub fn pair<I, O1, O2, E: ParseError<I>, F, G>
            (
                mut first: F,
                mut second: G,
            ) -> impl FnMut(I) -> IResult<I, (O1, O2), E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            {
                move |input: I| 
                    {
                    let (input, o1) = first.parse(input)?;
                    second.parse(input).map(|(i, o2)| (i, (o1, o2)))
                }
            }
            /// Matches an object from the first parser and discards it,
            /// then gets an object from the second parser.
            pub fn preceded<I, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            mut second: G,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            {
                move |input: I| 
                    {
                    let (input, _) = first.parse(input)?;
                    second.parse(input)
                }
            }
            /// Gets an object from the first parser,
            /// then matches an object from the second parser and discards it.
            pub fn terminated<I, O1, O2, E: ParseError<I>, F, G>(
            mut first: F,
            mut second: G,
            ) -> impl FnMut(I) -> IResult<I, O1, E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            {
                move |input: I| 
                    {
                    let (input, o1) = first.parse(input)?;
                    second.parse(input).map(|(i, _)| (i, o1))
                }
            }
            /// Gets an object from the first parser,
            /// then matches an object from the sep_parser and discards it,
            /// then gets another object from the second parser.
            pub fn separated_pair<I, O1, O2, O3, E: ParseError<I>, F, G, H>(
            mut first: F,
            mut sep: G,
            mut second: H,
            ) -> impl FnMut(I) -> IResult<I, (O1, O3), E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            H: Parser<I, O3, E>,
            {
                move |input: I| 
                    {
                    let (input, o1) = first.parse(input)?;
                    let (input, _) = sep.parse(input)?;
                    second.parse(input).map(|(i, o2)| (i, (o1, o2)))
                }
            }
            /// Matches an object from the first parser and discards it,
            /// then gets an object from the second parser,
            /// and finally matches an object from the third parser and discards it.
            pub fn delimited<I, O1, O2, O3, E: ParseError<I>, F, G, H>(
            mut first: F,
            mut second: G,
            mut third: H,
            ) -> impl FnMut(I) -> IResult<I, O2, E> where
            F: Parser<I, O1, E>,
            G: Parser<I, O2, E>,
            H: Parser<I, O3, E>,
            {
                move |input: I| 
                    {
                    let (input, _) = first.parse(input)?;
                    let (input, o2) = second.parse(input)?;
                    third.parse(input).map(|(i, _)| (i, o2))
                }
            }
            /// Helper trait for the tuple combinator.
            pub trait Tuple<I, O, E>
            {
                /// Parses the input and returns a tuple of results of each parser.
                fn parse(&mut self, input: I) -> IResult<I, O, E>;
            }

            impl<Input, Output, Error: ParseError<Input>, F: Parser<Input, Output, Error>>
            Tuple<Input, (Output,), Error> for (F,)
            {
                fn parse(&mut self, input: Input) -> IResult<Input, (Output,), Error>
                {
                    self.0.parse(input).map(|(i, o)| (i, (o,)))
                }
            }

            tuple_trait!(FnA A, FnB B, FnC C, FnD D, FnE E, FnF F, FnG G, FnH H, FnI I, FnJ J, FnK K, FnL L,
            FnM M, FnN N, FnO O, FnP P, FnQ Q, FnR R, FnS S, FnT T, FnU U);
            
            impl<I, E: ParseError<I>> Tuple<I, (), E> for () 
            {
                fn parse(&mut self, input: I) -> IResult<I, (), E> {
                    Ok((input, ()))
                }
            }
            /// Applies a tuple of parsers one by one and returns their results as a tuple.
            pub fn tuple<I, O, E: ParseError<I>, List: Tuple<I, O, E>>(
            mut l: List,
            ) -> impl FnMut(I) -> IResult<I, O, E> 
            {
                move |i: I| l.parse(i)
            }
        }
        
        pub mod traits
        {
            //! Traits input types have to implement to work with nom combinators            
            use ::
            {
                iter::{Copied, Enumerate},
                ops::{Range, RangeFrom, RangeFull, RangeTo},
                parsers::nom::
                {
                    error::{ self, ErrorKind, ParseError},
                    internal::{Err, IResult, Needed},
                },
                slice::Iter,
                str::{ Chars, CharIndices, FromStr, from_utf8, },
                string::{ String },
                vec::{ Vec },
                *,
            };
            
            macro_rules! as_bytes_array_impls 
            {
                ($($N:expr)+) => {
                    $(
                    impl<'a> AsBytes for &'a [u8; $N] 
                    {
                        #[inline(always)]
                        fn as_bytes(&self) -> &[u8] 
                        {
                        *self
                        }
                    }

                    impl AsBytes for [u8; $N] 
                    {
                        #[inline(always)]
                        fn as_bytes(&self) -> &[u8] 
                        {
                        self
                        }
                    }
                    )+
                };
            }
            
            macro_rules! impl_fn_slice
            {
                ( $ty:ty ) =>
                {
                    fn slice(&self, range: $ty) -> Self {
                    &self[range]
                    }
                };
            }

            macro_rules! slice_range_impl
            {
                ( [ $for_type:ident ], $ty:ty ) => {
                    impl<'a, $for_type> Slice<$ty> for &'a [$for_type] {
                    impl_fn_slice!($ty);
                    }
                };
                ( $for_type:ty, $ty:ty ) => {
                    impl<'a> Slice<$ty> for &'a $for_type {
                    impl_fn_slice!($ty);
                    }
                };
            }

            macro_rules! slice_ranges_impl
            {
                ( [ $for_type:ident ] ) => {
                    slice_range_impl! {[$for_type], Range<usize>}
                    slice_range_impl! {[$for_type], RangeTo<usize>}
                    slice_range_impl! {[$for_type], RangeFrom<usize>}
                    slice_range_impl! {[$for_type], RangeFull}
                };
                ( $for_type:ty ) => {
                    slice_range_impl! {$for_type, Range<usize>}
                    slice_range_impl! {$for_type, RangeTo<usize>}
                    slice_range_impl! {$for_type, RangeFrom<usize>}
                    slice_range_impl! {$for_type, RangeFull}
                };
            }

            macro_rules! array_impls
            {
                ($($N:expr)+) => {
                    $(
                    impl InputLength for [u8; $N] {
                        #[inline] fn input_len(&self) -> usize {
                        self.len()
                        }
                    }

                    impl<'a> InputLength for &'a [u8; $N] {
                        #[inline] fn input_len(&self) -> usize {
                        self.len()
                        }
                    }

                    impl<'a> InputIter for &'a [u8; $N] {
                        type Item = u8;
                        type Iter = Enumerate<Self::IterElem>;
                        type IterElem = Copied<Iter<'a, u8>>;

                        fn iter_indices(&self) -> Self::Iter {
                        (&self[..]).iter_indices()
                        }

                        fn iter_elements(&self) -> Self::IterElem {
                        (&self[..]).iter_elements()
                        }

                        fn position<P>(&self, predicate: P) -> Option<usize>
                        where P: Fn(Self::Item) -> bool {
                        (&self[..]).position(predicate)
                        }

                        fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                        (&self[..]).slice_index(count)
                        }
                    }

                    impl<'a> Compare<[u8; $N]> for &'a [u8] {
                        #[inline(always)]
                        fn compare(&self, t: [u8; $N]) -> CompareResult {
                        self.compare(&t[..])
                        }

                        #[inline(always)]
                        fn compare_no_case(&self, t: [u8;$N]) -> CompareResult {
                        self.compare_no_case(&t[..])
                        }
                    }

                    impl<'a,'b> Compare<&'b [u8; $N]> for &'a [u8] {
                        #[inline(always)]
                        fn compare(&self, t: &'b [u8; $N]) -> CompareResult {
                        self.compare(&t[..])
                        }

                        #[inline(always)]
                        fn compare_no_case(&self, t: &'b [u8;$N]) -> CompareResult {
                        self.compare_no_case(&t[..])
                        }
                    }

                    impl FindToken<u8> for [u8; $N] {
                        fn find_token(&self, token: u8) -> bool {
                        memchr::memchr(token, &self[..]).is_some()
                        }
                    }

                    impl<'a> FindToken<&'a u8> for [u8; $N] {
                        fn find_token(&self, token: &u8) -> bool {
                        self.find_token(*token)
                        }
                    }
                    )+
                };
            }
            /// Abstract method to calculate the input length
            pub trait InputLength 
            {
                /// Calculates the input length, as indicated by its name,
                /// and the name of the trait itself
                fn input_len(&self) -> usize;
            }

            impl<'a, T> InputLength for &'a [T] 
            {
                #[inline] fn input_len(&self) -> usize 
                {
                    self.len()
                }
            }

            impl<'a> InputLength for &'a str 
            {
                #[inline] fn input_len(&self) -> usize 
                {
                    self.len()
                }
            }

            impl<'a> InputLength for (&'a [u8], usize) 
            {
                #[inline] fn input_len(&self) -> usize 
                {
                    //println!("bit input length for ({:?}, {}):", self.0, self.1);
                    //println!("-> {}", self.0.len() * 8 - self.1);
                    self.0.len() * 8 - self.1
                }
            }
            /// Useful functions to calculate the offset between slices and show a hexdump of a slice
            pub trait Offset 
            {
                /// Offset between the first byte of self and the first byte of the argument
                fn offset(&self, second: &Self) -> usize;
            }

            impl Offset for [u8] 
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }

            impl<'a> Offset for &'a [u8]
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }

            impl Offset for str
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }

            impl<'a> Offset for &'a str
            {
                fn offset(&self, second: &Self) -> usize {
                    let fst = self.as_ptr();
                    let snd = second.as_ptr();

                    snd as usize - fst as usize
                }
            }
            /// Helper trait for types that can be viewed as a byte slice
            pub trait AsBytes 
            {
                /// Casts the input type to a byte slice
                fn as_bytes(&self) -> &[u8];
            }

            impl<'a> AsBytes for &'a str
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8] {
                    (*self).as_bytes()
                }
            }

            impl AsBytes for str 
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8]  { self.as_ref() }
            }

            impl<'a> AsBytes for &'a [u8] 
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8] 
                {
                    *self
                }
            }

            impl AsBytes for [u8] 
            {
                #[inline( always )] fn as_bytes(&self) -> &[u8] 
                {
                    self
                }
            }

            as_bytes_array_impls!
            {
                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
                17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
            }
            /// Transforms common types to a char for basic token parsing
            pub trait AsChar 
            {
                /// makes a char from self
                fn as_char(self) -> char;
                /// Tests that self is an alphabetic character
                fn is_alpha(self) -> bool;
                /// Tests that self is an alphabetic character or a decimal digit
                fn is_alphanum(self) -> bool;
                /// Tests that self is a decimal digit
                fn is_dec_digit(self) -> bool;
                /// Tests that self is an hex digit
                fn is_hex_digit(self) -> bool;
                /// Tests that self is an octal digit
                fn is_oct_digit(self) -> bool;
                /// Gets the len in bytes for self
                fn len(self) -> usize;
            }

            impl AsChar for u8 
            {
                #[inline] fn as_char(self) -> char {
                    self as char
                }
                #[inline] fn is_alpha(self) -> bool {
                    (self >= 0x41 && self <= 0x5A) || (self >= 0x61 && self <= 0x7A)
                }
                #[inline] fn is_alphanum(self) -> bool {
                    self.is_alpha() || self.is_dec_digit()
                }
                #[inline] fn is_dec_digit(self) -> bool {
                    self >= 0x30 && self <= 0x39
                }
                #[inline] fn is_hex_digit(self) -> bool {
                    (self >= 0x30 && self <= 0x39)
                    || (self >= 0x41 && self <= 0x46)
                    || (self >= 0x61 && self <= 0x66)
                }
                #[inline] fn is_oct_digit(self) -> bool {
                    self >= 0x30 && self <= 0x37
                }
                #[inline] fn len(self) -> usize {
                    1
                }
            }

            impl<'a> AsChar for &'a u8
            {
                #[inline] fn as_char(self) -> char {
                    *self as char
                }
                #[inline] fn is_alpha(self) -> bool {
                    (*self >= 0x41 && *self <= 0x5A) || (*self >= 0x61 && *self <= 0x7A)
                }
                #[inline] fn is_alphanum(self) -> bool {
                    self.is_alpha() || self.is_dec_digit()
                }
                #[inline] fn is_dec_digit(self) -> bool {
                    *self >= 0x30 && *self <= 0x39
                }
                #[inline] fn is_hex_digit(self) -> bool {
                    (*self >= 0x30 && *self <= 0x39)
                    || (*self >= 0x41 && *self <= 0x46)
                    || (*self >= 0x61 && *self <= 0x66)
                }
                #[inline] fn is_oct_digit(self) -> bool {
                    *self >= 0x30 && *self <= 0x37
                }
                #[inline] fn len(self) -> usize {
                    1
                }
            }

            impl AsChar for char
            {
                #[inline] fn as_char(self) -> char {
                    self
                }
                #[inline] fn is_alpha(self) -> bool {
                    self.is_ascii_alphabetic()
                }
                #[inline] fn is_alphanum(self) -> bool {
                    self.is_alpha() || self.is_dec_digit()
                }
                #[inline] fn is_dec_digit(self) -> bool {
                    self.is_ascii_digit()
                }
                #[inline] fn is_hex_digit(self) -> bool {
                    self.is_ascii_hexdigit()
                }
                #[inline] fn is_oct_digit(self) -> bool {
                    self.is_digit(8)
                }
                #[inline] fn len(self) -> usize {
                    self.len_utf8()
                }
            }

            impl<'a> AsChar for &'a char
            {
                #[inline] fn as_char(self) -> char 
                {
                    *self
                }

                #[inline] fn is_alpha(self) -> bool 
                {
                    self.is_ascii_alphabetic()
                }

                #[inline] fn is_alphanum(self) -> bool 
                {
                    self.is_alpha() || self.is_dec_digit()
                }

                #[inline] fn is_dec_digit(self) -> bool 
                {
                    self.is_ascii_digit()
                }

                #[inline] fn is_hex_digit(self) -> bool 
                {
                    self.is_ascii_hexdigit()
                }

                #[inline] fn is_oct_digit(self) -> bool 
                {
                    self.is_digit(8)
                }

                #[inline] fn len(self) -> usize 
                {
                    self.len_utf8()
                }

            }
            /// Abstracts common iteration operations on the input type
            pub trait InputIter 
            {
                /// The current input type is a sequence of that `Item` type.
                type Item;
                /// An iterator over the input type, producing the item and its position for use with [Slice].
                type Iter: Iterator<Item = (usize, Self::Item)>;
                /// An iterator over the input type, producing the item
                type IterElem: Iterator<Item = Self::Item>;
                /// Returns an iterator over the elements and their byte offsets
                fn iter_indices(&self) -> Self::Iter;
                /// Returns an iterator over the elements
                fn iter_elements(&self) -> Self::IterElem;
                /// Finds the byte position of the element
                fn position<P>(&self, predicate: P) -> Option<usize> where
                    P: Fn(Self::Item) -> bool;
                /// Get the byte offset from the element's position in the stream
                fn slice_index(&self, count: usize) -> Result<usize, Needed>;
            }
            /// Abstracts slicing operations
            pub trait InputTake: Sized
            {
                /// Returns a slice of `count` bytes. panics if count > length
                fn take(&self, count: usize) -> Self;
                /// Split the stream at the `count` byte offset. panics if count > length
                fn take_split(&self, count: usize) -> (Self, Self);
            }

            impl<'a> InputIter for &'a [u8]
            {
                type Item = u8;
                type Iter = Enumerate<Self::IterElem>;
                type IterElem = Copied<Iter<'a, u8>>;

                #[inline] fn iter_indices(&self) -> Self::Iter {
                    self.iter_elements().enumerate()
                }
                #[inline] fn iter_elements(&self) -> Self::IterElem {
                    self.iter().copied()
                }
                #[inline] fn position<P>(&self, predicate: P) -> Option<usize> where
                    P: Fn(Self::Item) -> bool,
                {
                    self.iter().position(|b| predicate(*b))
                }
                #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                    if self.len() >= count {
                    Ok(count)
                    } else {
                    Err(Needed::new(count - self.len()))
                    }
                }
            }

            impl<'a> InputTake for &'a [u8]
            {
                #[inline] fn take(&self, count: usize) -> Self {
                    &self[0..count]
                }
                #[inline] fn take_split(&self, count: usize) -> (Self, Self) {
                    let (prefix, suffix) = self.split_at(count);
                    (suffix, prefix)
                }
            }

            impl<'a> InputIter for &'a str
            {
                type Item = char;
                type Iter = CharIndices<'a>;
                type IterElem = Chars<'a>;
                #[inline] fn iter_indices(&self) -> Self::Iter {
                    self.char_indices()
                }
                #[inline] fn iter_elements(&self) -> Self::IterElem {
                    self.chars()
                }
                fn position<P>(&self, predicate: P) -> Option<usize> where
                    P: Fn(Self::Item) -> bool,
                {
                    for (o, c) in self.char_indices() {
                    if predicate(c) {
                        return Some(o);
                    }
                    }
                    None
                }
                #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed>
                {
                    let mut cnt = 0;
                    for (index, _) in self.char_indices() {
                    if cnt == count {
                        return Ok(index);
                    }
                    cnt += 1;
                    }
                    if cnt == count {
                    return Ok(self.len());
                    }
                    Err(Needed::Unknown)
                }
            }

            impl<'a> InputTake for &'a str
            {
                #[inline] fn take(&self, count: usize) -> Self {
                    &self[..count]
                }
                
                #[inline] fn take_split(&self, count: usize) -> (Self, Self) {
                    let (prefix, suffix) = self.split_at(count);
                    (suffix, prefix)
                }
            }
            /// Dummy trait used for default implementations.
            pub trait UnspecializedInput {}
            /// Methods to take as much input as possible 
            /// until the provided function returns true for the current element.
            pub trait InputTakeAtPosition: Sized 
            {
                /// The current input type is a sequence of that `Item` type.
                type Item;
                /// Looks for the first element of the input type for which the condition returns true,
                /// and returns the input up to this position.
                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
                /// Looks for the first element of the input type for which the condition returns true
                /// and returns the input up to this position.
                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
                /// Looks for the first element of the input type for which the condition returns true,
                /// and returns the input up to this position.
                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
                /// Looks for the first element of the input type for which the condition returns true
                /// and returns the input up to this position.
                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool;
            }

            impl<T: InputLength + InputIter + InputTake + Clone + UnspecializedInput> InputTakeAtPosition
            for T
            {
                type Item = <T as InputIter>::Item;

                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.position(predicate) {
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.position(predicate) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self.clone(), e))),
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.split_at_position(predicate) {
                    Err(Err::Incomplete(_)) => Ok(self.take_split(self.input_len())),
                    res => res,
                    }
                }

                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.split_at_position1(predicate, e) {
                    Err(Err::Incomplete(_)) => {
                        if self.input_len() == 0 {
                        Err(Err::Error(E::from_error_kind(self.clone(), e)))
                        } else {
                        Ok(self.take_split(self.input_len()))
                        }
                    }
                    res => res,
                    }
                }
            }

            impl<'a> InputTakeAtPosition for &'a [u8] 
            {
                type Item = u8;

                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(i) => Ok(self.take_split(i)),
                    None => Ok(self.take_split(self.input_len())),
                    }
                }

                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.iter().position(|c| predicate(*c)) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => {
                        if self.is_empty() {
                        Err(Err::Error(E::from_error_kind(self, e)))
                        } else {
                        Ok(self.take_split(self.input_len()))
                        }
                    }
                    }
                }
            }

            impl<'a> InputTakeAtPosition for &'a str 
            {
                type Item = char;

                fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position1<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                    }
                }

                fn split_at_position_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => unsafe {
                        Ok((
                        self.get_unchecked(self.len()..),
                        self.get_unchecked(..self.len()),
                        ))
                    },
                    }
                }

                fn split_at_position1_complete<P, E: ParseError<Self>>(
                    &self,
                    predicate: P,
                    e: ErrorKind,
                ) -> IResult<Self, Self, E> where
                    P: Fn(Self::Item) -> bool,
                {
                    match self.find(predicate) {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => {
                        if self.is_empty() {
                        Err(Err::Error(E::from_error_kind(self, e)))
                        } else {
                        unsafe {
                            Ok((
                            self.get_unchecked(self.len()..),
                            self.get_unchecked(..self.len()),
                            ))
                        }
                        }
                    }
                    }
                }
            }
            /// Indicates whether a comparison was successful, an error, or if more data was needed
            #[derive(Debug, PartialEq)]
            pub enum CompareResult
            {
                /// Comparison was successful
                Ok,
                /// We need more data to be sure
                Incomplete,
                /// Comparison failed
                Error,
            }
            /// Abstracts comparison operations
            pub trait Compare<T> 
            {
                /// Compares self to another value for equality
                fn compare(&self, t: T) -> CompareResult;
                /// Compares self to another value for equality
                /// independently of the case.
                fn compare_no_case(&self, t: T) -> CompareResult;
            }

            fn lowercase_byte(c: u8) -> u8 
            {
                match c {
                    b'A'..=b'Z' => c - b'A' + b'a',
                    _ => c,
                }
            }

            impl<'a, 'b> Compare<&'b [u8]> for &'a [u8] 
            {
                #[inline( always )] fn compare(&self, t: &'b [u8]) -> CompareResult {
                    let pos = self.iter().zip(t.iter()).position(|(a, b)| a != b);

                    match pos {
                    Some(_) => CompareResult::Error,
                    None => {
                        if self.len() >= t.len() {
                        CompareResult::Ok
                        } else {
                        CompareResult::Incomplete
                        }
                    }
                    }
                }

                #[inline( always )] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult {
                    if self
                    .iter()
                    .zip(t)
                    .any(|(a, b)| lowercase_byte(*a) != lowercase_byte(*b))
                    {
                    CompareResult::Error
                    } else if self.len() < t.len() {
                    CompareResult::Incomplete
                    } else {
                    CompareResult::Ok
                    }
                }
            }

            impl<
                T: InputLength + InputIter<Item = u8> + InputTake + UnspecializedInput,
                O: InputLength + InputIter<Item = u8> + InputTake,
            > Compare<O> for T
            {
                #[inline( always )] fn compare(&self, t: O) -> CompareResult {
                    let pos = self
                    .iter_elements()
                    .zip(t.iter_elements())
                    .position(|(a, b)| a != b);

                    match pos {
                    Some(_) => CompareResult::Error,
                    None => {
                        if self.input_len() >= t.input_len() {
                        CompareResult::Ok
                        } else {
                        CompareResult::Incomplete
                        }
                    }
                    }
                }

                #[inline( always )] fn compare_no_case(&self, t: O) -> CompareResult {
                    if self
                    .iter_elements()
                    .zip(t.iter_elements())
                    .any(|(a, b)| lowercase_byte(a) != lowercase_byte(b))
                    {
                    CompareResult::Error
                    } else if self.input_len() < t.input_len() {
                    CompareResult::Incomplete
                    } else {
                    CompareResult::Ok
                    }
                }
            }

            impl<'a, 'b> Compare<&'b str> for &'a [u8] 
            {
                #[inline( always )] fn compare(&self, t: &'b str) -> CompareResult {
                    self.compare(AsBytes::as_bytes(t))
                }
                #[inline( always )] fn compare_no_case(&self, t: &'b str) -> CompareResult {
                    self.compare_no_case(AsBytes::as_bytes(t))
                }
            }

            impl<'a, 'b> Compare<&'b str> for &'a str 
            {
                #[inline( always )] fn compare(&self, t: &'b str) -> CompareResult {
                    self.as_bytes().compare(t.as_bytes())
                }
                
                #[inline( always )] fn compare_no_case(&self, t: &'b str) -> CompareResult {
                    let pos = self
                    .chars()
                    .zip(t.chars())
                    .position(|(a, b)| a.to_lowercase().ne(b.to_lowercase()));

                    match pos {
                    Some(_) => CompareResult::Error,
                    None => {
                        if self.len() >= t.len() {
                        CompareResult::Ok
                        } else {
                        CompareResult::Incomplete
                        }
                    }
                    }
                }
            }

            impl<'a, 'b> Compare<&'b [u8]> for &'a str 
            {
                #[inline( always )] fn compare(&self, t: &'b [u8]) -> CompareResult {
                    AsBytes::as_bytes(self).compare(t)
                }
                #[inline( always )] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult {
                    AsBytes::as_bytes(self).compare_no_case(t)
                }
            }
            /// Look for a token in self
            pub trait FindToken<T> 
            {
                /// Returns true if self contains the token
                fn find_token(&self, token: T) -> bool;
            }

            impl<'a> FindToken<u8> for &'a [u8] 
            {
                fn find_token(&self, token: u8) -> bool {
                    memchr::memchr(token, self).is_some()
                }
            }

            impl<'a> FindToken<u8> for &'a str 
            {
                fn find_token(&self, token: u8) -> bool {
                    self.as_bytes().find_token(token)
                }
            }

            impl<'a, 'b> FindToken<&'a u8> for &'b [u8] 
            {
                fn find_token(&self, token: &u8) -> bool {
                    self.find_token(*token)
                }
            }

            impl<'a, 'b> FindToken<&'a u8> for &'b str 
            {
                fn find_token(&self, token: &u8) -> bool {
                    self.as_bytes().find_token(token)
                }
            }

            impl<'a> FindToken<char> for &'a [u8] 
            {
                fn find_token(&self, token: char) -> bool {
                    self.iter().any(|i| *i == token as u8)
                }
            }

            impl<'a> FindToken<char> for &'a str 
            {
                fn find_token(&self, token: char) -> bool {
                    self.chars().any(|i| i == token)
                }
            }

            impl<'a> FindToken<char> for &'a [char] 
            {
                fn find_token(&self, token: char) -> bool {
                    self.iter().any(|i| *i == token)
                }
            }

            impl<'a, 'b> FindToken<&'a char> for &'b [char] 
            {
                fn find_token(&self, token: &char) -> bool {
                    self.find_token(*token)
                }
            }
            /// Look for a substring in self
            pub trait FindSubstring<T> 
            {
                /// Returns the byte position of the substring if it is found
                fn find_substring(&self, substr: T) -> Option<usize>;
            }

            impl<'a, 'b> FindSubstring<&'b [u8]> for &'a [u8] 
            {
                fn find_substring(&self, substr: &'b [u8]) -> Option<usize>
                {
                    if substr.len() > self.len() {
                    return None;
                    }

                    let (&substr_first, substr_rest) = match substr.split_first() 
                    {
                        Some(split) => split,
                        None => return Some(0),
                    };

                    if substr_rest.is_empty() {
                    return memchr::memchr(substr_first, self);
                    }

                    let mut offset = 0;
                    let haystack = &self[..self.len() - substr_rest.len()];

                    while let Some(position) = memchr::memchr(substr_first, &haystack[offset..]) {
                    offset += position;
                    let next_offset = offset + 1;
                    if &self[next_offset..][..substr_rest.len()] == substr_rest {
                        return Some(offset);
                    }

                    offset = next_offset;
                    }

                    None
                }
            }

            impl<'a, 'b> FindSubstring<&'b str> for &'a [u8]
            {
                fn find_substring(&self, substr: &'b str) -> Option<usize> {
                    self.find_substring(AsBytes::as_bytes(substr))
                }
            }

            impl<'a, 'b> FindSubstring<&'b str> for &'a str 
            {
                fn find_substring(&self, substr: &'b str) -> Option<usize> {
                    self.find(substr)
                }
            }
            /// Used to integrate `str`'s `parse()` method
            pub trait ParseTo<R> 
            {
                /// Succeeds if `parse()` succeeded. The byte slice implementation
                /// will first convert it to a `&str`, then apply the `parse()` function
                fn parse_to(&self) -> Option<R>;
            }

            impl<'a, R: FromStr> ParseTo<R> for &'a [u8]
            {
                fn parse_to(&self) -> Option<R> {
                    from_utf8(self).ok().and_then(|s| s.parse().ok())
                }
            }

            impl<'a, R: FromStr> ParseTo<R> for &'a str
            {
                fn parse_to(&self) -> Option<R> {
                    self.parse().ok()
                }
            }
            /// Slicing operations using ranges.
            pub trait Slice<R>
            {
                /// Slices self according to the range argument
                fn slice(&self, range: R) -> Self;
            }

            slice_ranges_impl! {str}
            slice_ranges_impl! {[T]}

            array_impls!
            {
                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 
                17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
            }
            /// Abstracts something which can extend an `Extend`.
            pub trait ExtendInto 
            {
                /// The current input type is a sequence of that `Item` type.
                type Item;
                /// The type that will be produced
                type Extender;
                /// Create a new `Extend` of the correct type
                fn new_builder(&self) -> Self::Extender;
                /// Accumulate the input into an accumulator
                fn extend_into(&self, acc: &mut Self::Extender);
            }
            
            impl ExtendInto for [u8] 
            {
                type Item = u8;
                type Extender = Vec<u8>;

                #[inline] fn new_builder(&self) -> Vec<u8> {
                    Vec::new()
                }
                #[inline] fn extend_into(&self, acc: &mut Vec<u8>) {
                    acc.extend(self.iter().cloned());
                }
            }
            
            impl ExtendInto for &[u8] 
            {
                type Item = u8;
                type Extender = Vec<u8>;

                #[inline] fn new_builder(&self) -> Vec<u8> {
                    Vec::new()
                }
                #[inline] fn extend_into(&self, acc: &mut Vec<u8>) {
                    acc.extend_from_slice(self);
                }
            }
            
            impl ExtendInto for str 
            {
                type Item = char;
                type Extender = String;

                #[inline] fn new_builder(&self) -> String {
                    String::new()
                }
                #[inline] fn extend_into(&self, acc: &mut String) {
                    acc.push_str(self);
                }
            }
            
            impl ExtendInto for &str 
            {
                type Item = char;
                type Extender = String;

                #[inline] fn new_builder(&self) -> String {
                    String::new()
                }
                #[inline] fn extend_into(&self, acc: &mut String) {
                    acc.push_str(self);
                }
            }
            
            impl ExtendInto for char 
            {
                type Item = char;
                type Extender = String;

                #[inline] fn new_builder(&self) -> String {
                    String::new()
                }
                #[inline] fn extend_into(&self, acc: &mut String) {
                    acc.push(*self);
                }
            }
            /// Helper trait to convert numbers to usize.
            pub trait ToUsize 
            {
                /// converts self to usize
                fn to_usize(&self) -> usize;
            }

            impl ToUsize for u8 
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }

            impl ToUsize for u16 
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }

            impl ToUsize for usize
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self
                }
            }
            
            impl ToUsize for u32
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }
            
            impl ToUsize for u64
            {
                #[inline] fn to_usize(&self) -> usize {
                    *self as usize
                }
            }
            /// Equivalent From implementation to avoid orphan rules in bits parsers
            pub trait ErrorConvert<E>
            {
                /// Transform to another error type
                fn convert(self) -> E;
            }

            impl<I> ErrorConvert<(I, ErrorKind)> for ((I, usize), ErrorKind) 
            {
                fn convert(self) -> (I, ErrorKind) {
                    ((self.0).0, self.1)
                }
            }

            impl<I> ErrorConvert<((I, usize), ErrorKind)> for (I, ErrorKind)
            {
                fn convert(self) -> ((I, usize), ErrorKind) {
                    ((self.0, 0), self.1)
                }
            }
            
            impl<I> ErrorConvert<error::Error<I>> for error::Error<(I, usize)> 
            {
                fn convert(self) -> error::Error<I> {
                    error::Error {
                    input: self.input.0,
                    code: self.code,
                    }
                }
            }

            impl<I> ErrorConvert<error::Error<(I, usize)>> for error::Error<I> 
            {
                fn convert(self) -> error::Error<(I, usize)> {
                    error::Error {
                    input: (self.input, 0),
                    code: self.code,
                    }
                }
            }
            
            impl<I> ErrorConvert<error::VerboseError<I>> for error::VerboseError<(I, usize)> 
            {
                fn convert(self) -> error::VerboseError<I> {
                    error::VerboseError {
                    errors: self.errors.into_iter().map(|(i, e)| (i.0, e)).collect(),
                    }
                }
            }
            
            impl<I> ErrorConvert<error::VerboseError<(I, usize)>> for error::VerboseError<I>
            {
                fn convert(self) -> error::VerboseError<(I, usize)> {
                    error::VerboseError {
                    errors: self.errors.into_iter().map(|(i, e)| ((i, 0), e)).collect(),
                    }
                }
            }

            impl ErrorConvert<()> for ()
            {
                fn convert(self) {}
            }
            /// Helper trait to show a byte slice as a hex dump
            pub trait HexDisplay
            {
                /// Converts the value of `self` to a hex dump, returning the owned
                /// `String`.
                fn to_hex(&self, chunk_size: usize) -> String;
                /// Converts the value of `self` to a hex dump beginning at `from` address, returning the owned
                /// `String`.
                fn to_hex_from(&self, chunk_size: usize, from: usize) -> String;
            }
            
            static CHARS: &[u8] = b"0123456789abcdef";
            
            impl HexDisplay for [u8]
            {
                #[allow(unused_variables)]
                fn to_hex(&self, chunk_size: usize) -> String {
                    self.to_hex_from(chunk_size, 0)
                }

                #[allow(unused_variables)]
                fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
                    let mut v = Vec::with_capacity(self.len() * 3);
                    let mut i = from;
                    for chunk in self.chunks(chunk_size) {
                    let s = format!("{:08x}", i);
                    for &ch in s.as_bytes().iter() {
                        v.push(ch);
                    }
                    v.push(b'\t');

                    i += chunk_size;

                    for &byte in chunk {
                        v.push(CHARS[(byte >> 4) as usize]);
                        v.push(CHARS[(byte & 0xf) as usize]);
                        v.push(b' ');
                    }
                    if chunk_size > chunk.len() {
                        for j in 0..(chunk_size - chunk.len()) {
                        v.push(b' ');
                        v.push(b' ');
                        v.push(b' ');
                        }
                    }
                    v.push(b'\t');

                    for &byte in chunk {
                        if (byte >= 32 && byte <= 126) || byte >= 128 {
                        v.push(byte);
                        } else {
                        v.push(b'.');
                        }
                    }
                    v.push(b'\n');
                    }

                    String::from_utf8_lossy(&v[..]).into_owned()
                }
            }
            
            impl HexDisplay for str
            {
                #[allow(unused_variables)]
                fn to_hex(&self, chunk_size: usize) -> String {
                    self.to_hex_from(chunk_size, 0)
                }

                #[allow(unused_variables)]
                fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
                    self.as_bytes().to_hex_from(chunk_size, from)
                }
            }
        } pub use self::traits::*;
        
        pub mod bits
        {
            use ::
            {
                ops::RangeFrom,
                parsers::nom::
                {
                    error::{ErrorKind, ParseError},
                    internal::{Err, IResult, Needed, Parser},
                    traits::{ErrorConvert, Slice},
                },
                *,
            };

            pub mod complete
            {
                //! Bit level parsers
                use ::
                {
                    ops::{AddAssign, Div, RangeFrom, Shl, Shr},
                    parsers::nom::
                    {
                        error::{ErrorKind, ParseError},
                        internal::{Err, IResult},
                        traits::{InputIter, InputLength, Slice, ToUsize},
                    },
                    *
                };
                /// Generates a parser taking `count` bits
                pub fn take<I, O, C, E: ParseError<(I, usize)>>(
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,
                {
                    let count = count.to_usize();
                    move |(input, bit_offset): (I, usize)| 
                    {
                        if count == 0 {
                        Ok(((input, bit_offset), 0u8.into()))
                        } else {
                        let cnt = (count + bit_offset).div(8);
                        if input.input_len() * 8 < count + bit_offset {
                            Err(Err::Error(E::from_error_kind(
                            (input, bit_offset),
                            ErrorKind::Eof,
                            )))
                        } else {
                            let mut acc: O = 0_u8.into();
                            let mut offset: usize = bit_offset;
                            let mut remaining: usize = count;
                            let mut end_offset: usize = 0;

                            for byte in input.iter_elements().take(cnt + 1) {
                            if remaining == 0 {
                                break;
                            }
                            let val: O = if offset == 0 {
                                byte.into()
                            } else {
                                ((byte << offset) as u8 >> offset).into()
                            };

                            if remaining < 8 - offset {
                                acc += val >> (8 - offset - remaining);
                                end_offset = remaining + offset;
                                break;
                            } else {
                                acc += val << (remaining - (8 - offset));
                                remaining -= 8 - offset;
                                offset = 0;
                            }
                            }
                            Ok(((input.slice(cnt..), end_offset), acc))
                        }
                        }
                    }
                }
                /// Generates a parser taking `count` bits and comparing them to `pattern`
                pub fn tag<I, O, C, E: ParseError<(I, usize)>>(
                pattern: O,
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,
                {
                    let count = count.to_usize();
                    move |input: (I, usize)| 
                    {
                        let inp = input.clone();

                        take(count)(input).and_then(|(i, o)| 
                    {
                        if pattern == o {
                            Ok((i, o))
                        } else {
                            Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                        }
                        })
                    }
                }
                /// Parses one specific bit as a bool.
                pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let (res, bit): (_, u32) = take(1usize)(input)?;
                    Ok((res, bit != 0))
                }
            }

            pub mod streaming
            {
                use ::
                {
                    ops::{AddAssign, Div, RangeFrom, Shl, Shr},
                    parsers::nom::
                    {
                        error::{ErrorKind, ParseError},
                        internal::{Err, IResult, Needed},
                        traits::{InputIter, InputLength, Slice, ToUsize},
                    },
                    *
                };
                /// Generates a parser taking `count` bits
                pub fn take<I, O, C, E: ParseError<(I, usize)>>(
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,
                {
                    let count = count.to_usize();
                    move |(input, bit_offset): (I, usize)| 
                    {
                        if count == 0 {
                        Ok(((input, bit_offset), 0u8.into()))
                        } else {
                        let cnt = (count + bit_offset).div(8);
                        if input.input_len() * 8 < count + bit_offset {
                            Err(Err::Incomplete(Needed::new(count as usize)))
                        } else {
                            let mut acc: O = 0_u8.into();
                            let mut offset: usize = bit_offset;
                            let mut remaining: usize = count;
                            let mut end_offset: usize = 0;

                            for byte in input.iter_elements().take(cnt + 1) {
                            if remaining == 0 {
                                break;
                            }
                            let val: O = if offset == 0 {
                                byte.into()
                            } else {
                                ((byte << offset) as u8 >> offset).into()
                            };

                            if remaining < 8 - offset {
                                acc += val >> (8 - offset - remaining);
                                end_offset = remaining + offset;
                                break;
                            } else {
                                acc += val << (remaining - (8 - offset));
                                remaining -= 8 - offset;
                                offset = 0;
                            }
                            }
                            Ok(((input.slice(cnt..), end_offset), acc))
                        }
                        }
                    }
                }
                /// Generates a parser taking `count` bits and comparing them to `pattern`
                pub fn tag<I, O, C, E: ParseError<(I, usize)>>(
                pattern: O,
                count: C,
                ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
                C: ToUsize,
                O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,
                {
                    let count = count.to_usize();
                    move |input: (I, usize)| 
                    {
                        let inp = input.clone();

                        take(count)(input).and_then(|(i, o)| 
                    {
                        if pattern == o {
                            Ok((i, o))
                        } else {
                            Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                        }
                        })
                    }
                }
                /// Parses one specific bit as a bool.
                pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let (res, bit): (_, u32) = take(1usize)(input)?;
                    Ok((res, bit != 0))
                }
            }
            /// Converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.
            pub fn bits<I, O, E1, E2, P>(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2> where
            E1: ParseError<(I, usize)> + ErrorConvert<E2>,
            E2: ParseError<I>,
            I: Slice<RangeFrom<usize>>,
            P: Parser<(I, usize), O, E1>,
            {
                move |input: I| match parser.parse((input, 0)) {
                    Ok(((rest, offset), result)) =>
                {
                    let remaining_bytes_index = offset / 8 + if offset % 8 == 0 { 0 } else { 1 };
                    Ok((rest.slice(remaining_bytes_index..), result))
                    }
                    Err(Err::Incomplete(n)) => Err(Err::Incomplete(n.map(|u| u.get() / 8 + 1))),
                    Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
                }
            }
            /// Counterpart to `bits`, `bytes` transforms its bit stream input into a byte slice for the underlying
            /// parser, allowing byte-slice parsers to work on bit streams.
            pub fn bytes<I, O, E1, E2, P>(mut parser: P) -> impl FnMut((I, usize)) -> IResult<(I, usize), O, E2> where
            E1: ParseError<I> + ErrorConvert<E2>,
            E2: ParseError<(I, usize)>,
            I: Slice<RangeFrom<usize>> + Clone,
            P: Parser<I, O, E1>,
            {
                move |(input, offset): (I, usize)| 
                    {
                    let inner = if offset % 8 != 0 {
                    input.slice((1 + offset / 8)..)
                    } else {
                    input.slice((offset / 8)..)
                    };
                    let i = (input, offset);
                    match parser.parse(inner) {
                    Ok((rest, res)) => Ok(((rest, 0), res)),
                    Err(Err::Incomplete(Needed::Unknown)) => Err(Err::Incomplete(Needed::Unknown)),
                    Err(Err::Incomplete(Needed::Size(sz))) => Err(match sz.get().checked_mul(8) {
                        Some(v) => Err::Incomplete(Needed::new(v)),
                        None => Err::Failure(E2::from_error_kind(i, ErrorKind::TooLarge)),
                    }),
                    Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
                    }
                }
            }
        }
    
        pub mod bytes
        {
            //! Parsers recognizing bytes streams
            use ::
            {
                *,
            };

            pub mod complete
            {
                use ::
                {
                    ops::RangeFrom,
                    parsers::nom::
                    {
                        error::{ ErrorKind, ParseError },
                        internal::{ Err, IResult, Parser },
                        traits::
                        {
                            AsChar, Compare, CompareResult, ExtendInto, FindSubstring, FindToken, InputIter, InputLength, InputTake,
                            InputTakeAtPosition, Offset, Slice, ToUsize,
                        },
                    },
                    result::Result::*,
                    *
                };
                /// Recognizes a pattern.
                pub fn tag<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| 
                    {
                        let tag_len = tag.input_len();
                        let t = tag.clone();
                        let res: IResult<_, _, Error> = match i.compare(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        _ => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Recognizes a case insensitive pattern.
                pub fn tag_no_case<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| 
                    {
                        let tag_len = tag.input_len();
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match (i).compare_no_case(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        _ => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Parse till certain characters are met.
                pub fn is_not<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::IsNot;
                        i.split_at_position1_complete(|c| arr.find_token(c), e)
                    }
                }
                /// Returns the longest slice of the matches the pattern.
                pub fn is_a<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::IsA;
                        i.split_at_position1_complete(|c| !arr.find_token(c), e)
                    }
                }
                /// Returns the longest input slice (if any) that matches the predicate.
                pub fn take_while<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position_complete(|c| !cond(c))
                }
                /// Returns the longest (at least 1) input slice that matches the predicate.
                pub fn take_while1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::TakeWhile1;
                        i.split_at_position1_complete(|c| !cond(c), e)
                    }
                }
                /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
                pub fn take_while_m_n<F, Input, Error: ParseError<Input>>(
                m: usize,
                n: usize,
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputIter + InputLength + Slice<RangeFrom<usize>>,
                F: Fn(<Input as InputIter>::Item) -> bool,
                {
                    move |i: Input| 
                    {
                        let input = i;

                        match input.position(|c| !cond(c)) {
                        Some(idx) => {
                            if idx >= m {
                            if idx <= n {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            } else {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            }
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                        None => {
                            let len = input.input_len();
                            if len >= n {
                            match input.slice_index(n) {
                                Ok(index) => Ok(input.take_split(index)),
                                Err(_needed) => Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                                ))),
                            }
                            } else if len >= m && len <= n {
                            let res: IResult<_, _, Error> = Ok((input.slice(len..), input));
                            res
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                        }
                    }
                }
                /// Returns the longest input slice (if any) till a predicate is met.
                pub fn take_till<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position_complete(|c| cond(c))
                }
                /// Returns the longest (at least 1) input slice till a predicate is met.
                pub fn take_till1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::TakeTill1;
                        i.split_at_position1_complete(|c| cond(c), e)
                    }
                }
                /// Returns an input slice containing the first N input elements (Input[..N]).
                pub fn take<C, Input, Error: ParseError<Input>>(
                count: C,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputIter + InputTake,
                C: ToUsize,
                {
                    let c = count.to_usize();
                    move |i: Input| match i.slice_index(c) {
                        Err(_needed) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Eof))),
                        Ok(index) => Ok(i.take_split(index)),
                    }
                }
                /// Returns the input slice up to the first occurrence of the pattern.
                pub fn take_until<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + FindSubstring<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| 
                    {
                        let t = tag.clone();
                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Returns the non empty input slice up to the first occurrence of the pattern.
                pub fn take_until1<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + FindSubstring<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| 
                    {
                        let t = tag.clone();
                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped<'a, Input: 'a, Error, F, G, O1, O2>(
                mut normal: F,
                control_char: char,
                mut escapable: G,
                ) -> impl FnMut(Input) -> IResult<Input, Input, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move |input: Input|
                    {
                        let mut i = input.clone();

                        while i.input_len() > 0 {
                        let current_len = i.input_len();

                        match normal.parse(i.clone()) {
                            Ok((i2, _)) => {
                            if i2.input_len() == 0 {
                                return Ok((input.slice(input.input_len()..), input));
                            } else if i2.input_len() == current_len {
                                let index = input.offset(&i2);
                                return Ok(input.take_split(index));
                            } else {
                                i = i2;
                            }
                            }
                            Err(Err::Error(_)) => {
                            if i.iter_elements().next().unwrap().as_char() == control_char {
                                let next = control_char.len_utf8();
                                if next >= i.input_len() {
                                return Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::Escaped,
                                )));
                                } else {
                                match escapable.parse(i.slice(next..)) {
                                    Ok((i2, _)) => {
                                    if i2.input_len() == 0 {
                                        return Ok((input.slice(input.input_len()..), input));
                                    } else {
                                        i = i2;
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                let index = input.offset(&i);
                                if index == 0 {
                                return Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::Escaped,
                                )));
                                }
                                return Ok(input.take_split(index));
                            }
                            }
                            Err(e) => {
                            return Err(e);
                            }
                        }
                        }

                        Ok((input.slice(input.input_len()..), input))
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>(
                mut normal: F,
                control_char: char,
                mut transform: G,
                ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                Input: ExtendInto<Item = ExtendItem, Extender = Output>,
                O1: ExtendInto<Item = ExtendItem, Extender = Output>,
                O2: ExtendInto<Item = ExtendItem, Extender = Output>,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move | input:Input |
                    {
                        let mut index = 0;
                        let mut res = input.new_builder();

                        let i = input.clone();

                        while index < i.input_len() 
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone()) {
                            Ok((i2, o)) => {
                            o.extend_into(&mut res);
                            if i2.input_len() == 0 {
                                return Ok((i.slice(i.input_len()..), res));
                            } else if i2.input_len() == current_len {
                                return Ok((remainder, res));
                            } else {
                                index = input.offset(&i2);
                            }
                            }
                            Err(Err::Error(_)) => {
                            if remainder.iter_elements().next().unwrap().as_char() == control_char {
                                let next = index + control_char.len_utf8();
                                let input_len = input.input_len();

                                if next >= input_len {
                                return Err(Err::Error(Error::from_error_kind(
                                    remainder,
                                    ErrorKind::EscapedTransform,
                                )));
                                } else {
                                match transform.parse(i.slice(next..)) {
                                    Ok((i2, o)) => {
                                    o.extend_into(&mut res);
                                    if i2.input_len() == 0 {
                                        return Ok((i.slice(i.input_len()..), res));
                                    } else {
                                        index = input.offset(&i2);
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                if index == 0 {
                                return Err(Err::Error(Error::from_error_kind(
                                    remainder,
                                    ErrorKind::EscapedTransform,
                                )));
                                }
                                return Ok((remainder, res));
                            }
                            }
                            Err(e) => return Err(e),
                        }
                        }
                        Ok((input.slice(index..), res))
                    }
                }
            }

            pub mod streaming
            {
                use ::
                {
                    ops::RangeFrom,
                    parsers::nom::
                    {
                        error::{ ErrorKind, ParseError },
                        internal::{Err, IResult, Needed, Parser},
                        traits::
                        {
                            AsChar, Compare, CompareResult, ExtendInto, FindSubstring, FindToken, InputIter, InputLength, InputTake,
                            InputTakeAtPosition, Offset, Slice, ToUsize,
                        },
                    },
                    result::Result::*,
                    *
                };
                /// Recognizes a pattern.
                pub fn tag<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| 
                    {
                        let tag_len = tag.input_len();
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match i.compare(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Recognizes a case insensitive pattern.
                pub fn tag_no_case<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + Compare<T>,
                T: InputLength + Clone,
                {
                    move |i: Input| 
                    {
                        let tag_len = tag.input_len();
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match (i).compare_no_case(t) {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                        };
                        res
                    }
                }
                /// Parse till certain characters are met.
                pub fn is_not<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::IsNot;
                        i.split_at_position1(|c| arr.find_token(c), e)
                    }
                }
                /// Returns the longest slice of the matches the pattern.
                pub fn is_a<T, Input, Error: ParseError<Input>>(
                arr: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                T: FindToken<<Input as InputTakeAtPosition>::Item>,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::IsA;
                        i.split_at_position1(|c| !arr.find_token(c), e)
                    }
                }
                /// Returns the longest input slice (if any) that matches the predicate.
                pub fn take_while<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position(|c| !cond(c))
                }
                /// Returns the longest (at least 1) input slice that matches the predicate.
                pub fn take_while1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::TakeWhile1;
                        i.split_at_position1(|c| !cond(c), e)
                    }
                }
                /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
                pub fn take_while_m_n<F, Input, Error: ParseError<Input>>(
                m: usize,
                n: usize,
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputIter + InputLength,
                F: Fn(<Input as InputIter>::Item) -> bool,
                {
                    move |i: Input| 
                    {
                        let input = i;

                        match input.position(|c| !cond(c)) {
                        Some(idx) => {
                            if idx >= m {
                            if idx <= n {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            } else {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            }
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                        None => {
                            let len = input.input_len();
                            if len >= n {
                            match input.slice_index(n) {
                                Ok(index) => Ok(input.take_split(index)),
                                Err(_needed) => Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                                ))),
                            }
                            } else {
                            let needed = if m > len { m - len } else { 1 };
                            Err(Err::Incomplete(Needed::new(needed)))
                            }
                        }
                        }
                    }
                }
                /// Returns the longest input slice (if any) till a predicate is met.
                pub fn take_till<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| i.split_at_position(|c| cond(c))
                }
                /// Returns the longest (at least 1) input slice till a predicate is met.
                pub fn take_till1<F, Input, Error: ParseError<Input>>(
                cond: F,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTakeAtPosition,
                F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
                {
                    move |i: Input| 
                    {
                        let e: ErrorKind = ErrorKind::TakeTill1;
                        i.split_at_position1(|c| cond(c), e)
                    }
                }
                /// Returns an input slice containing the first N input elements (Input[..N]).
                pub fn take<C, Input, Error: ParseError<Input>>(
                count: C,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputIter + InputTake + InputLength,
                C: ToUsize,
                {
                    let c = count.to_usize();
                    move |i: Input| match i.slice_index(c) {
                        Err(i) => Err(Err::Incomplete(i)),
                        Ok(index) => Ok(i.take_split(index)),
                    }
                }
                /// Returns the input slice up to the first occurrence of the pattern.
                pub fn take_until<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + FindSubstring<T>,
                T: Clone,
                {
                    move |i: Input| 
                    {
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Returns the non empty input slice up to the first occurrence of the pattern.
                pub fn take_until1<T, Input, Error: ParseError<Input>>(
                tag: T,
                ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
                Input: InputTake + InputLength + FindSubstring<T>,
                T: Clone,
                {
                    move |i: Input| 
                    {
                        let t = tag.clone();

                        let res: IResult<_, _, Error> = match i.find_substring(t) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                        };
                        res
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped<Input, Error, F, G, O1, O2>(
                mut normal: F,
                control_char: char,
                mut escapable: G,
                ) -> impl FnMut(Input) -> IResult<Input, Input, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move | input:Input |
                    {
                        let mut i = input.clone();

                        while i.input_len() > 0 {
                        let current_len = i.input_len();

                        match normal.parse(i.clone()) {
                            Ok((i2, _)) => {
                            if i2.input_len() == 0 {
                                return Err(Err::Incomplete(Needed::Unknown));
                            } else if i2.input_len() == current_len {
                                let index = input.offset(&i2);
                                return Ok(input.take_split(index));
                            } else {
                                i = i2;
                            }
                            }
                            Err(Err::Error(_)) => {
                            if i.iter_elements().next().unwrap().as_char() == control_char {
                                let next = control_char.len_utf8();
                                if next >= i.input_len() {
                                return Err(Err::Incomplete(Needed::new(1)));
                                } else {
                                match escapable.parse(i.slice(next..)) {
                                    Ok((i2, _)) => {
                                    if i2.input_len() == 0 {
                                        return Err(Err::Incomplete(Needed::Unknown));
                                    } else {
                                        i = i2;
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                let index = input.offset(&i);
                                return Ok(input.take_split(index));
                            }
                            }
                            Err(e) => {
                            return Err(e);
                            }
                        }
                        }

                        Err(Err::Incomplete(Needed::Unknown))
                    }
                }
                /// Matches a byte string with escaped characters.
                pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>(
                mut normal: F,
                control_char: char,
                mut transform: G,
                ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
                Input: Clone
                    + Offset
                    + InputLength
                    + InputTake
                    + InputTakeAtPosition
                    + Slice<RangeFrom<usize>>
                    + InputIter,
                Input: ExtendInto<Item = ExtendItem, Extender = Output>,
                O1: ExtendInto<Item = ExtendItem, Extender = Output>,
                O2:  ExtendInto<Item = ExtendItem, Extender = Output>,
                <Input as InputIter>::Item: AsChar,
                F: Parser<Input, O1, Error>,
                G: Parser<Input, O2, Error>,
                Error: ParseError<Input>,
                {
                    move | input:Input |
                    {
                        let mut index = 0;
                        let mut res = input.new_builder();

                        let i = input.clone();

                        while index < i.input_len() 
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone()) {
                            Ok((i2, o)) => {
                            o.extend_into(&mut res);
                            if i2.input_len() == 0 {
                                return Err(Err::Incomplete(Needed::Unknown));
                            } else if i2.input_len() == current_len {
                                return Ok((remainder, res));
                            } else {
                                index = input.offset(&i2);
                            }
                            }
                            Err(Err::Error(_)) => {
                            if remainder.iter_elements().next().unwrap().as_char() == control_char {
                                let next = index + control_char.len_utf8();
                                let input_len = input.input_len();

                                if next >= input_len {
                                return Err(Err::Incomplete(Needed::Unknown));
                                } else {
                                match transform.parse(i.slice(next..)) {
                                    Ok((i2, o)) => {
                                    o.extend_into(&mut res);
                                    if i2.input_len() == 0 {
                                        return Err(Err::Incomplete(Needed::Unknown));
                                    } else {
                                        index = input.offset(&i2);
                                    }
                                    }
                                    Err(e) => return Err(e),
                                }
                                }
                            } else {
                                return Ok((remainder, res));
                            }
                            }
                            Err(e) => return Err(e),
                        }
                        }
                        Err(Err::Incomplete(Needed::Unknown))
                    }
                }
            }

        } pub use self::bytes::*;
        
        pub mod character
        {
            use ::
            {
                *,
            };

            pub mod complete
            {
                //! Character specific parsers and combinators, complete input version.
                //! Functions recognizing specific characters.
                use ::
                {
                    ops::{ Range, RangeFrom, RangeTo },
                    parsers::nom::
                    {
                        branch::alt,
                        bytes::complete::tag,
                        combinator::{ opt, value },
                        error::{ ErrorKind, ParseError },
                        internal::{Err, IResult},
                        traits::{ AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition, Slice, },
                    },
                    *
                };
                
                macro_rules! ints 
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                            <T as InputIter>::Item: AsChar,
                            T: for <'a> Compare<&'a[u8]>,
                            {
                                let (i, sign) = sign(input.clone())?;

                                if i.input_len() == 0 {
                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                }

                                let mut value: $t = 0;
                                if sign {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                } else {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                }

                                Ok((i.slice(i.input_len()..), value))
                            }
                        )+
                    }
                }
                
                macro_rules! uints
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                            <T as InputIter>::Item: AsChar,
                            {
                                let i = input;

                                if i.input_len() == 0 {
                                    return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                }

                                let mut value: $t = 0;
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }

                                Ok((i.slice(i.input_len()..), value))
                            }
                        )+
                    }
                }
                /// Recognizes one character.
                pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| 
                    {
                        let b = t.as_char() == c;
                        (&c, b)
                    }) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                        _ => Err(Err::Error(Error::from_char(i, c))),
                    }
                }
                /// Recognizes one character and checks that it satisfies a predicate
                pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                F: Fn(char) -> bool,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| 
                    {
                        let c = t.as_char();
                        let b = cond(c);
                        (c, b)
                    }) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c)),
                        _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                    }
                }
                /// Recognizes one of the provided characters.
                pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                        _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                    }
                }
                /// Recognizes a character that is not in the provided characters.
                pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                        _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                    }
                }
                /// Recognizes the string "\r\n".
                pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>>,
                T: InputIter,
                T: Compare<&'static str>,
                {
                    match input.compare("\r\n") {
                        //FIXME: is this the right index?
                        CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                        _ => {
                        let e: ErrorKind = ErrorKind::CrLf;
                        Err(Err::Error(E::from_error_kind(input, e)))
                        }
                    }
                }
                /// Recognizes a string of any char except '\r\n' or '\n'.
                pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::Item: AsChar,
                {
                    match input.position(|item| 
                    {
                        let c = item.as_char();
                        c == '\r' || c == '\n'
                    }) {
                        None => Ok((input.slice(input.input_len()..), input)),
                        Some(index) => {
                        let mut it = input.slice(index..).iter_elements();
                        let nth = it.next().unwrap().as_char();
                        if nth == '\r' {
                            let sliced = input.slice(index..);
                            let comp = sliced.compare("\r\n");
                            match comp {
                            //FIXME: calculate the right index
                            CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                            _ => {
                                let e: ErrorKind = ErrorKind::Tag;
                                Err(Err::Error(E::from_error_kind(input, e)))
                            }
                            }
                        } else {
                            Ok((input.slice(index..), input.slice(..index)))
                        }
                        }
                    }
                }
                /// Recognizes an end of line (both '\n' and '\r\n').
                pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                {
                    match input.compare("\n") {
                        CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                        CompareResult::Incomplete => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        CompareResult::Error => {
                        match input.compare("\r\n") {
                            //FIXME: is this the right index?
                            CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                            _ => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        }
                        }
                    }
                }
                /// Matches a newline character '\n'.
                pub fn newline<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                {
                    char('\n')(input)
                }
                /// Matches a tab character '\t'.
                pub fn tab<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                {
                    char('\t')(input)
                }
                /// Matches one byte as a character. Note that the input type will
                /// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.
                pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E> where
                T: InputIter + InputLength + Slice<RangeFrom<usize>>,
                <T as InputIter>::Item: AsChar,
                {
                    let mut it = input.iter_indices();
                    match it.next() {
                        None => Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof))),
                        Some((_, c)) => match it.next() {
                        None => Ok((input.slice(input.input_len()..), c.as_char())),
                        Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                        },
                    }
                }
                /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_alpha())
                }
                /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_alpha(), ErrorKind::Alpha)
                }
                /// Recognizes zero or more ASCII numerical characters: 0-9
                pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_dec_digit())
                }
                /// Recognizes one or more ASCII numerical characters: 0-9
                pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_dec_digit(), ErrorKind::Digit)
                }
                /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
                pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_hex_digit())
                }
                /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
                pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_hex_digit(), ErrorKind::HexDigit)
                }
                /// Recognizes zero or more octal characters: 0-7
                pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_oct_digit())
                }
                /// Recognizes one or more octal characters: 0-7
                pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_oct_digit(), ErrorKind::OctDigit)
                }
                /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z
                pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position_complete(|item| !item.is_alphanum())
                }
                /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z
                pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1_complete(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)
                }
                /// Recognizes zero or more spaces and tabs.
                pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position_complete(|item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                    })
                }
                /// Recognizes one or more spaces and tabs.
                pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1_complete(
                        |item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                        },
                        ErrorKind::Space,
                    )
                }
                /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position_complete(|item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    })
                }
                /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1_complete(
                        |item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                        },
                        ErrorKind::MultiSpace,
                    )
                }

                pub fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E> where
                T: Clone + InputTake,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, opt_sign) = opt(alt((
                        value(false, tag(&b"-"[..])),
                        value(true, tag(&b"+"[..])),
                    )))(input)?;
                    let sign = opt_sign.unwrap_or(true);

                    Ok((i, sign))
                }

                ints! { i8 i16 i32 i64 i128 }

                uints! { u8 u16 u32 u64 u128 }
            }

            pub mod streaming
            {
                use ::
                {
                    ops::{Range, RangeFrom, RangeTo},
                    parsers::nom::
                    {
                       branch::alt,
                       bytes::streaming::tag,
                       combinator::{ opt, value },
                       error::ErrorKind,
                       error::ParseError,
                       internal::{Err, IResult, Needed},
                       traits::{ AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition, Slice, },
                    },
                    *
                };
                
                macro_rules! ints 
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                            <T as InputIter>::Item: AsChar,
                            T: for <'a> Compare<&'a[u8]>,
                            {
                            let (i, sign) = sign(input.clone())?;

                                if i.input_len() == 0 {
                                    return Err(Err::Incomplete(Needed::new(1)));
                                }

                                let mut value: $t = 0;
                                if sign {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                } else {
                                    for (pos, c) in i.iter_indices() {
                                        match c.as_char().to_digit(10) {
                                            None => {
                                                if pos == 0 {
                                                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                                } else {
                                                    return Ok((i.slice(pos..), value));
                                                }
                                            },
                                            Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {
                                                None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                                Some(v) => value = v,
                                            }
                                        }
                                    }
                                }

                                Err(Err::Incomplete(Needed::new(1)))
                            }
                        )+
                    }
                }
                
                macro_rules! uints
                {
                    ($($t:tt)+) => {
                        $(
                        /// will parse a number in text form to a number
                        ///
                        /// *Complete version*: can parse until the end of input.
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                            where
                            T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                            <T as InputIter>::Item: AsChar,
                            {
                                let i = input;

                                if i.input_len() == 0 {
                                    return Err(Err::Incomplete(Needed::new(1)));
                                }

                                let mut value: $t = 0;
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }

                                Err(Err::Incomplete(Needed::new(1)))
                            }
                        )+
                    }
                }
                /// Recognizes one character.
                pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter + InputLength,
                <I as InputIter>::Item: AsChar,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| 
                    {
                        let b = t.as_char() == c;
                        (&c, b)
                    }) {
                        None => Err(Err::Incomplete(Needed::new(c.len() - i.input_len()))),
                        Some((_, false)) => Err(Err::Error(Error::from_char(i, c))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    }
                }
                /// Recognizes one character and checks that it satisfies a predicate.
                pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar,
                F: Fn(char) -> bool,
                {
                    move |i: I| match (i).iter_elements().next().map(|t| 
                    {
                        let c = t.as_char();
                        let b = cond(c);
                        (c, b)
                    }) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c)),
                    }
                }
                /// Recognizes one of the provided characters.
                pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {
                        None => Err(Err::Incomplete(Needed::new(1))),
                        Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    }
                }
                /// Recognizes a character that is not in the provided characters.
                pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter,
                <I as InputIter>::Item: AsChar + Copy,
                T: FindToken<<I as InputIter>::Item>,
                {
                    move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {
                        None => Err(Err::Incomplete(Needed::new(1))),
                        Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                        Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    }
                }
                /// Recognizes the string "\r\n".
                pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter,
                T: Compare<&'static str>,
                {
                    match input.compare("\r\n") {
                        CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                        CompareResult::Error => {
                        let e: ErrorKind = ErrorKind::CrLf;
                        Err(Err::Error(E::from_error_kind(input, e)))
                        }
                    }
                }
                /// Recognizes a string of any char except '\r\n' or '\n'.
                pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::Item: AsChar,
                {
                    match input.position(|item| 
                    {
                        let c = item.as_char();
                        c == '\r' || c == '\n'
                    }) {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(index) => {
                        let mut it = input.slice(index..).iter_elements();
                        let nth = it.next().unwrap().as_char();
                        if nth == '\r' {
                            let sliced = input.slice(index..);
                            let comp = sliced.compare("\r\n");
                            match comp {
                            //FIXME: calculate the right index
                            CompareResult::Incomplete => Err(Err::Incomplete(Needed::Unknown)),
                            CompareResult::Error => {
                                let e: ErrorKind = ErrorKind::Tag;
                                Err(Err::Error(E::from_error_kind(input, e)))
                            }
                            CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                            }
                        } else {
                            Ok((input.slice(index..), input.slice(..index)))
                        }
                        }
                    }
                }
                /// Recognizes an end of line (both '\n' and '\r\n').
                pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: InputIter + InputLength,
                T: Compare<&'static str>,
                {
                    match input.compare("\n") {
                        CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(1))),
                        CompareResult::Error => {
                        match input.compare("\r\n") {
                            //FIXME: is this the right index?
                            CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                            CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                            CompareResult::Error => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        }
                        }
                    }
                }
                /// Matches a newline character '\\n'.
                pub fn newline<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter + InputLength,
                <I as InputIter>::Item: AsChar,
                {
                    char('\n')(input)
                }
                /// Matches a tab character '\t'.
                pub fn tab<I, Error: ParseError<I>>( input:I ) -> IResult<I, char, Error> where
                I: Slice<RangeFrom<usize>> + InputIter + InputLength,
                <I as InputIter>::Item: AsChar,
                {
                    char('\t')(input)
                }
                /// Matches one byte as a character. Note that the input type will
                /// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.
                pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E> where
                T: InputIter + InputLength + Slice<RangeFrom<usize>>,
                <T as InputIter>::Item: AsChar,
                {
                    let mut it = input.iter_indices();
                    match it.next() {
                        None => Err(Err::Incomplete(Needed::new(1))),
                        Some((_, c)) => match it.next() {
                        None => Ok((input.slice(input.input_len()..), c.as_char())),
                        Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                        },
                    }
                }
                /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_alpha())
                }
                /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
                pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_alpha(), ErrorKind::Alpha)
                }
                /// Recognizes zero or more ASCII numerical characters: 0-9.
                pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_dec_digit())
                }
                /// Recognizes one or more ASCII numerical characters: 0-9.
                pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_dec_digit(), ErrorKind::Digit)
                }
                /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
                pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_hex_digit())
                }
                /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
                pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_hex_digit(), ErrorKind::HexDigit)
                }
                /// Recognizes zero or more octal characters: 0-7.
                pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_oct_digit())
                }
                /// Recognizes one or more octal characters: 0-7.
                pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_oct_digit(), ErrorKind::OctDigit)
                }
                /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
                pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position(|item| !item.is_alphanum())
                }
                /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
                pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    input.split_at_position1(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)
                }
                /// Recognizes zero or more spaces and tabs.
                pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position(|item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                    })
                }
                /// Recognizes one or more spaces and tabs.
                pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1(
                        |item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                        },
                        ErrorKind::Space,
                    )
                }
                /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position(|item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    })
                }
                /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
                pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar + Clone,
                {
                    input.split_at_position1(
                        |item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                        },
                        ErrorKind::MultiSpace,
                    )
                }

                pub fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E> where
                T: Clone + InputTake + InputLength,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, opt_sign) = opt(alt((
                        value(false, tag(&b"-"[..])),
                        value(true, tag(&b"+"[..])),
                    )))(input)?;
                    let sign = opt_sign.unwrap_or(true);

                    Ok((i, sign))
                }

                ints! { i8 i16 i32 i64 i128 }
                uints! { u8 u16 u32 u64 u128 }
            }

        }
        
        pub mod number
        {
            use ::
            {
                parsers::nom::
                {

                },
                *,
            };

            pub mod complete
            {
                use ::
                {
                    ops::{ Range, RangeFrom, RangeTo },
                    parsers::nom::
                    {
                        branch::alt,
                        bytes::complete::{ is_a, tag, tag_no_case },
                        character::complete::{char, digit1, sign},
                        combinator::{cut, map, opt, recognize},
                        error::{ ErrorKind, make_error, ParseError },
                        internal::*,
                        number::{ Endianness },
                        sequence::{pair, tuple},
                        traits::{ AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, Offset, ParseTo, Slice },
                    },
                    *
                };
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn be_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 2 bytes integer.
                #[inline] pub fn be_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u16;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u16;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 3 byte integer.
                #[inline] pub fn be_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 4 bytes integer.
                #[inline] pub fn be_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 8 bytes integer.
                #[inline] pub fn be_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u64;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u64;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 16 bytes integer.
                #[inline] pub fn be_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u128;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u128;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn be_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a big endian signed 2 bytes integer.
                #[inline] pub fn be_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a big endian signed 3 bytes integer.
                #[inline] pub fn be_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u24
                        .map(|x| 
                    {
                        if x & 0x80_00_00 != 0 {
                            (x | 0xff_00_00_00) as i32
                        } else {
                            x as i32
                        }
                        })
                        .parse(input)
                }
                /// Recognizes a big endian signed 4 bytes integer.
                #[inline] pub fn be_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a big endian signed 8 bytes integer.
                #[inline] pub fn be_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a big endian signed 16 bytes integer.
                #[inline] pub fn be_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn le_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 2 bytes integer.
                #[inline] pub fn le_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u16;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u16) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 3 byte integer.
                #[inline] pub fn le_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 4 bytes integer.
                #[inline] pub fn le_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 8 bytes integer.
                #[inline] pub fn le_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u64;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u64) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 16 bytes integer.
                #[inline] pub fn le_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let mut res = 0u128;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u128) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn le_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a little endian signed 2 bytes integer.
                #[inline] pub fn le_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a little endian signed 3 bytes integer.
                #[inline] pub fn le_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u24
                    .map(|x| 
                    {
                    if x & 0x80_00_00 != 0 {
                        (x | 0xff_00_00_00) as i32
                    } else {
                        x as i32
                    }
                    })
                    .parse(input)
                }
                /// Recognizes a little endian signed 4 bytes integer.
                #[inline] pub fn le_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                le_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a little endian signed 8 bytes integer.
                #[inline] pub fn le_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a little endian signed 16 bytes integer.
                #[inline] pub fn le_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer
                #[inline] pub fn u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Error(make_error(input, ErrorKind::Eof)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes an unsigned 2 bytes integer
                #[inline] pub fn u16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u16,
                        Endianness::Little => le_u16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u16,
                    }
                }
                /// Recognizes an unsigned 3 byte integer
                #[inline] pub fn u24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u24,
                        Endianness::Little => le_u24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u24,
                    }
                }
                /// Recognizes an unsigned 4 byte integer
                #[inline] pub fn u32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u32,
                        Endianness::Little => le_u32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u32,
                    }
                }
                /// Recognizes an unsigned 8 byte integer
                #[inline] pub fn u64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u64,
                        Endianness::Little => le_u64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u64,
                    }
                }
                /// Recognizes an unsigned 16 byte integer.
                #[inline] pub fn u128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u128,
                        Endianness::Little => le_u128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u128,
                    }
                }
                /// Recognizes a signed 1 byte integer
                #[inline] pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    u8.map(|x| x as i8).parse(i)
                }
                /// Recognizes a signed 2 byte integer
                #[inline] pub fn i16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i16,
                        Endianness::Little => le_i16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i16,
                    }
                }
                /// Recognizes a signed 3 byte integer.
                #[inline] pub fn i24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i24,
                        Endianness::Little => le_i24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i24,
                    }
                }
                /// Recognizes a signed 4 byte integer.
                #[inline] pub fn i32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i32,
                        Endianness::Little => le_i32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i32,
                    }
                }
                /// Recognizes a signed 8 byte integer
                #[inline] pub fn i64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i64,
                        Endianness::Little => le_i64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i64,
                    }
                }
                /// Recognizes a signed 16 byte integer
                #[inline] pub fn i128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i128,
                        Endianness::Little => le_i128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i128,
                    }
                }
                /// Recognizes a big endian 4 bytes floating point number.
                #[inline] pub fn be_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a big endian 8 bytes floating point number.
                #[inline] pub fn be_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 4 bytes floating point number.
                #[inline] pub fn le_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 8 bytes floating point number.
                #[inline] pub fn le_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a 4 byte floating point number
                #[inline] pub fn f32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f32,
                        Endianness::Little => le_f32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f32,
                    }
                }
                /// Recognizes an 8 byte floating point number
                #[inline] pub fn f64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f64,
                        Endianness::Little => le_f64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f64,
                    }
                }
                /// Recognizes a hex-encoded integer.
                #[inline] pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E>
                {
                    let (i, o) = is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                    
                    let (parsed, remaining) = if o.len() <= 8 {
                        (o, i)
                    } else {
                        (&input[..8], &input[8..])
                    };

                    let res = parsed
                        .iter()
                        .rev()
                        .enumerate()
                        .map(|(k, &v)| 
                    {
                        let digit = v as char;
                        digit.to_digit(16).unwrap_or(0) << (k * 4)
                        })
                        .sum();

                    Ok((remaining, res))
                }
                /// Recognizes floating point number in a byte string and returns the corresponding slice.
                pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    recognize(
                        tuple((
                        opt(alt((char('+'), char('-')))),
                        alt((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt(tuple((
                            alt((char('e'), char('E'))),
                            opt(alt((char('+'), char('-')))),
                            cut(digit1)
                        )))
                        ))
                    )(input)
                }
                
                pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputTake + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    alt((
                        |i: T| 
                    {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e {
                            ::parsers::nom::Err::Error(_) => ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Failure(_) => ::parsers::nom::Err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Incomplete(needed) => ::parsers::nom::Err::Incomplete(needed),
                        })
                        },
                        |i: T| 
                    {
                        tag_no_case::<_, _, E>("nan")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| 
                    {
                        tag_no_case::<_, _, E>("inf")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| 
                    {
                        tag_no_case::<_, _, E>("infinity")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                    ))(input)
                }
                /// Recognizes a floating point number in text format
                pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
                T: Clone + Offset,
                T: InputIter + InputTake,
                <T as InputIter>::Item: AsChar + Copy,
                T: InputTakeAtPosition + InputLength,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: for<'a> Compare<&'a [u8]>,
                T: AsBytes,
                {
                    let (i, sign) = sign(input.clone())?;
                    let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };
                    
                    let (i, mut integer) = match i
                        .as_bytes()
                        .iter()
                        .position(|c| !(*c >= b'0' && *c <= b'9'))
                    {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };

                    if integer.input_len() == 0 && zeroes.input_len() > 0 {
                        integer = zeroes.slice(zeroes.input_len() - 1..);
                    }

                    let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                    let (i, fraction) = if opt_dot.is_none() 
                    {
                        let i2 = i.clone();
                        (i2, i.slice(..0))
                    } else {
                        let mut zero_count = 0usize;
                        let mut position = None;
                        for (pos, c) in i.as_bytes().iter().enumerate() {
                        if *c >= b'0' && *c <= b'9' {
                            if *c == b'0' {
                            zero_count += 1;
                            } else {
                            zero_count = 0;
                            }
                        } else {
                            position = Some(pos);
                            break;
                        }
                        }

                        let position = position.unwrap_or(i.input_len());

                        let index = if zero_count == 0 {
                        position
                        } else if zero_count == position {
                        position - zero_count + 1
                        } else {
                        position - zero_count
                        };

                        (i.slice(position..), i.slice(..index))
                    };

                    if integer.input_len() == 0 && fraction.input_len() == 0 {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));
                    }

                    let i2 = i.clone();
                    let (i, e) = match i.as_bytes().iter().next() {
                        Some(b'e') => (i.slice(1..), true),
                        Some(b'E') => (i.slice(1..), true),
                        _ => (i, false),
                    };

                    let (i, exp) = if e {
                        cut( ::parsers::nom::character::complete::i32)(i)?
                    } else {
                        (i2, 0)
                    };

                    Ok((i, (sign, integer, fraction, exp)))
                }
                /// Recognizes floating point number in text format and returns a f32.
                pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
                T: Clone + Offset + ParseTo<f32> + Compare<&'static str>,
                T: InputIter + InputLength + InputTake,
                <T as InputIter>::Item: AsChar + Copy,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err(::parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }
                /// Recognizes floating point number in text format and returns a f64.
                pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
                T: Clone + Offset + ParseTo<f64> + Compare<&'static str>,
                T: InputIter + InputLength + InputTake,
                <T as InputIter>::Item: AsChar + Copy,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err( ::parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }

            }

            pub mod streaming
            {
                //! Parsers recognizing numbers, streaming version
                use ::
                {
                    ops::{RangeFrom, RangeTo},
                    parsers::nom::
                    {
                        branch::alt,
                        bytes::streaming::{ is_a, tag, tag_no_case },
                        character::streaming::{char, digit1, sign},
                        combinator::{cut, map, opt, recognize},
                        error::{ErrorKind, ParseError},
                        internal::*,
                        number::{ Endianness },
                        sequence::{pair, tuple},
                        traits::{ AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, Offset, ParseTo, Slice },

                    },
                    *
                };
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn be_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(1)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 2 bytes integer.
                #[inline] pub fn be_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u16;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u16;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 3 byte integer.
                #[inline] pub fn be_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 4 bytes integer.
                #[inline] pub fn be_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u32;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 8 bytes integer.
                #[inline] pub fn be_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u64;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u64;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a big endian unsigned 16 bytes integer.
                #[inline] pub fn be_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u128;
                        for byte in input.iter_elements().take(bound) {
                        res = (res << 8) + byte as u128;
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn be_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a big endian signed 2 bytes integer.
                #[inline] pub fn be_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a big endian signed 3 bytes integer.
                #[inline] pub fn be_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u24
                        .map(|x| 
                    {
                        if x & 0x80_00_00 != 0 {
                            (x | 0xff_00_00_00) as i32
                        } else {
                            x as i32
                        }
                        })
                        .parse(input)
                }
                /// Recognizes a big endian signed 4 bytes integer.
                #[inline] pub fn be_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a big endian signed 8 bytes integer.
                #[inline] pub fn be_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a big endian signed 16 bytes integer.
                #[inline] pub fn be_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    be_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer.
                #[inline] pub fn le_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(1)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 2 bytes integer.
                #[inline] pub fn le_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 2;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u16;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u16) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 3 bytes integer.
                #[inline] pub fn le_u24<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 3;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 4 bytes integer.
                #[inline] pub fn le_u32<I, E: ParseError<I>>( input:I ) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 4;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u32;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u32) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 8 bytes integer.
                #[inline] pub fn le_u64<I, E: ParseError<I>>( input:I ) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 8;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u64;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u64) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a little endian unsigned 16 bytes integer.
                #[inline] pub fn le_u128<I, E: ParseError<I>>( input:I ) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 16;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                    } else {
                        let mut res = 0u128;
                        for (index, byte) in input.iter_indices().take(bound) {
                        res += (byte as u128) << (8 * index);
                        }

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes a signed 1 byte integer.
                #[inline] pub fn le_i8<I, E: ParseError<I>>( input:I ) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u8.map(|x| x as i8).parse(input)
                }
                /// Recognizes a little endian signed 2 bytes integer.
                #[inline] pub fn le_i16<I, E: ParseError<I>>( input:I ) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u16.map(|x| x as i16).parse(input)
                }
                /// Recognizes a little endian signed 3 bytes integer.
                #[inline] pub fn le_i24<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u24
                        .map(|x| 
                    {
                        if x & 0x80_00_00 != 0 {
                            (x | 0xff_00_00_00) as i32
                        } else {
                            x as i32
                        }
                        })
                        .parse(input)
                }
                /// Recognizes a little endian signed 4 bytes integer.
                #[inline] pub fn le_i32<I, E: ParseError<I>>( input:I ) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u32.map(|x| x as i32).parse(input)
                }
                /// Recognizes a little endian signed 8 bytes integer.
                #[inline] pub fn le_i64<I, E: ParseError<I>>( input:I ) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u64.map(|x| x as i64).parse(input)
                }
                /// Recognizes a little endian signed 16 bytes integer.
                #[inline] pub fn le_i128<I, E: ParseError<I>>( input:I ) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    le_u128.map(|x| x as i128).parse(input)
                }
                /// Recognizes an unsigned 1 byte integer
                #[inline] pub fn u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    let bound: usize = 1;
                    if input.input_len() < bound {
                        Err(Err::Incomplete(Needed::new(1)))
                    } else {
                        let res = input.iter_elements().next().unwrap();

                        Ok((input.slice(bound..), res))
                    }
                }
                /// Recognizes an unsigned 2 bytes integer
                #[inline] pub fn u16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u16,
                        Endianness::Little => le_u16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u16,
                    }
                }
                /// Recognizes an unsigned 3 byte integer
                #[inline] pub fn u24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u24,
                        Endianness::Little => le_u24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u24,
                    }
                }
                /// Recognizes an unsigned 4 byte integer.
                #[inline] pub fn u32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u32,
                        Endianness::Little => le_u32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u32,
                    }
                }
                /// Recognizes an unsigned 8 byte integer
                #[inline] pub fn u64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u64,
                        Endianness::Little => le_u64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u64,
                    }
                }
                /// Recognizes an unsigned 16 byte integer
                #[inline] pub fn u128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, u128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_u128,
                        Endianness::Little => le_u128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_u128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_u128,
                    }
                }
                /// Recognizes a signed 1 byte integer
                #[inline] pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    u8.map(|x| x as i8).parse(i)
                }
                /// Recognizes a signed 2 byte integer
                #[inline] pub fn i16<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i16, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i16,
                        Endianness::Little => le_i16,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i16,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i16,
                    }
                }
                /// Recognizes a signed 3 byte integer.
                #[inline] pub fn i24<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i24,
                        Endianness::Little => le_i24,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i24,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i24,
                    }
                }
                /// Recognizes a signed 4 byte integer
                #[inline] pub fn i32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i32,
                        Endianness::Little => le_i32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i32,
                    }
                }
                /// Recognizes a signed 8 byte integer
                #[inline] pub fn i64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i64,
                        Endianness::Little => le_i64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i64,
                    }
                }
                /// Recognizes a signed 16 byte integer.
                #[inline] pub fn i128<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, i128, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_i128,
                        Endianness::Little => le_i128,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_i128,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_i128,
                    }
                }
                /// Recognizes a big endian 4 bytes floating point number.
                #[inline] pub fn be_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a big endian 8 bytes floating point number.
                #[inline] pub fn be_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match be_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 4 bytes floating point number.
                #[inline] pub fn le_f32<I, E: ParseError<I>>( input:I ) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u32(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f32::from_bits(o))),
                    }
                }
                /// Recognizes a little endian 8 bytes floating point number.
                #[inline] pub fn le_f64<I, E: ParseError<I>>( input:I ) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match le_u64(input) {
                        Err(e) => Err(e),
                        Ok((i, o)) => Ok((i, f64::from_bits(o))),
                    }
                }
                /// Recognizes a 4 byte floating point number
                #[inline] pub fn f32<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f32, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f32,
                        Endianness::Little => le_f32,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f32,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f32,
                    }
                }
                /// Recognizes an 8 byte floating point number
                #[inline] pub fn f64<I, E: ParseError<I>>(endian: Endianness) -> fn(I) -> IResult<I, f64, E> where
                I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
                {
                    match endian {
                        Endianness::Big => be_f64,
                        Endianness::Little => le_f64,
                        #[cfg(target_endian = "big")]
                        Endianness::Native => be_f64,
                        #[cfg(target_endian = "little")]
                        Endianness::Native => le_f64,
                    }
                }
                /// Recognizes a hex-encoded integer.
                #[inline] pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E>
                {
                    let (i, o) = is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                    
                    let (parsed, remaining) = if o.len() <= 8 {
                        (o, i)
                    } else {
                        (&input[..8], &input[8..])
                    };

                    let res = parsed
                        .iter()
                        .rev()
                        .enumerate()
                        .map(|(k, &v)| 
                    {
                        let digit = v as char;
                        digit.to_digit(16).unwrap_or(0) << (k * 4)
                        })
                        .sum();

                    Ok((remaining, res))
                }
                /// Recognizes a floating point number in text format and returns the corresponding part of the input.
                pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition + InputLength,
                <T as InputTakeAtPosition>::Item: AsChar
                {
                    recognize(
                        tuple((
                        opt(alt((char('+'), char('-')))),
                        alt((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt(tuple((
                            alt((char('e'), char('E'))),
                            opt(alt((char('+'), char('-')))),
                            cut(digit1)
                        )))
                        ))
                    )(input)
                }
                
                pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputTake + InputLength + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                {
                    alt((
                        |i: T| 
                    {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e {
                            ::parsers::nom::Err::Error(_) => ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Failure(_) => ::parsers::nom::Err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                            ::parsers::nom::Err::Incomplete(needed) => ::parsers::nom::Err::Incomplete(needed),
                        })
                        },
                        |i: T| 
                    {
                        tag_no_case::<_, _, E>("nan")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| 
                    {
                        tag_no_case::<_, _, E>("inf")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                        |i: T| 
                    {
                        tag_no_case::<_, _, E>("infinity")(i.clone())
                            .map_err(|_| ::parsers::nom::Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                        },
                    ))(input)
                }
                /// Recognizes a floating point number in text format
                pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + ParseTo<i32>,
                <T as InputIter>::Item: AsChar,
                T: InputTakeAtPosition + InputTake + InputLength,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: for<'a> Compare<&'a [u8]>,
                T: AsBytes,
                {
                    let (i, sign) = sign(input.clone())?;

                    //let (i, zeroes) = take_while(|c: <T as InputTakeAtPosition>::Item| c.as_char() == '0')(i)?;
                    let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };

                    //let (i, mut integer) = digit0(i)?;
                    let (i, mut integer) = match i
                        .as_bytes()
                        .iter()
                        .position(|c| !(*c >= b'0' && *c <= b'9'))
                    {
                        Some(index) => i.take_split(index),
                        None => i.take_split(i.input_len()),
                    };

                    if integer.input_len() == 0 && zeroes.input_len() > 0 {
                        integer = zeroes.slice(zeroes.input_len() - 1..);
                    }

                    let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                    let (i, fraction) = if opt_dot.is_none() 
                    {
                        let i2 = i.clone();
                        (i2, i.slice(..0))
                    } else {
                        let mut zero_count = 0usize;
                        let mut position = None;
                        for (pos, c) in i.as_bytes().iter().enumerate() {
                        if *c >= b'0' && *c <= b'9' {
                            if *c == b'0' {
                            zero_count += 1;
                            } else {
                            zero_count = 0;
                            }
                        } else {
                            position = Some(pos);
                            break;
                        }
                        }

                        let position = match position {
                        Some(p) => p,
                        None => return Err(Err::Incomplete(Needed::new(1))),
                        };

                        let index = if zero_count == 0 {
                        position
                        } else if zero_count == position {
                        position - zero_count + 1
                        } else {
                        position - zero_count
                        };

                        (i.slice(position..), i.slice(..index))
                    };

                    if integer.input_len() == 0 && fraction.input_len() == 0 {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));
                    }

                    let i2 = i.clone();
                    let (i, e) = match i.as_bytes().iter().next() {
                        Some(b'e') => (i.slice(1..), true),
                        Some(b'E') => (i.slice(1..), true),
                        _ => (i, false),
                    };

                    let (i, exp) = if e {
                        cut( ::parsers::nom::character::streaming::i32)(i)?
                    } else {
                        (i2, 0)
                    };

                    Ok((i, (sign, integer, fraction, exp)))
                }
                /// Recognizes floating point number in text format and returns a f32.
                pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputLength + InputTake + ParseTo<f32> + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                { 
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err(::parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }
                /// Recognizes floating point number in text format and returns a f64.
                pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
                T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
                T: Clone + Offset,
                T: InputIter + InputLength + InputTake + ParseTo<f64> + Compare<&'static str>,
                <T as InputIter>::Item: AsChar,
                <T as InputIter>::IterElem: Clone,
                T: InputTakeAtPosition,
                <T as InputTakeAtPosition>::Item: AsChar,
                T: AsBytes,
                T: for<'a> Compare<&'a [u8]>,
                {
                    let (i, s) = recognize_float_or_exceptions(input)?;
                    match s.parse_to() {
                        Some(f) => Ok((i, f)),
                        None => Err( parsers::nom::Err::Error(E::from_error_kind(
                        i,
                        ErrorKind::Float,
                        ))),
                    }
                }
            }
            /// Configurable endianness
            #[derive(Debug, PartialEq, Eq, Clone, Copy)]
            pub enum Endianness
            {
                /// Big endian
                Big,
                /// Little endian
                Little,
                /// Will match the host's endianness
                Native,
            }

            #[inline] pub fn numeric(i: &[u8]) -> i32
            {
                let mut n: i32 = 0;

                for &ch in i
                {
                    let d = (ch as i32).wrapping_sub(b'0' as i32);

                    if d <= 9 { n = n.saturating_mul(10).saturating_add(d); }
                }

                n
            }
        }
    }
}

pub mod path
{
    pub use std::path::{ * };

    use ::
    {
        borrow::{ Cow },
        fs::{ read_dir },
        io::{ ErrorKind, Write },
        regex::{ Regex },
        env,
    };
    /*
    dirs-system v6.0.0*/
    pub mod system
    {
        use ::
        {
            *,
        };
        
        pub mod unix
        {
            use ::
            {
                collections::{ HashMap },
                ffi::{ CStr, OsString },
                libc::{ unix::{ * }, * },
                os::unix::ffi::{ OsStringExt },
                path::{ Path, PathBuf },
                *,
            }; 

            fn user_dir_file(home_dir: &Path) -> PathBuf 
            {
                env::var_os("XDG_CONFIG_HOME")
                .and_then(is::absolute_path)
                .unwrap_or_else(|| home_dir.join(".config"))
                .join("user-dirs.dirs")
            }
            
            pub fn user_dir(user_dir_name: &str) -> Option<PathBuf>
            {
                if let Some(home_dir) = home_dir() {
                    single(&home_dir, &user_dir_file(&home_dir), user_dir_name).remove(user_dir_name)
                } else {
                    None
                }
            }

            pub fn user_dirs(home_dir_path: &Path) -> HashMap<String, PathBuf> 
            {
                all(home_dir_path, &user_dir_file(home_dir_path))
            }

            pub fn home_directory() -> Option<PathBuf>
            {
                return env::var_os("HOME")
                    .and_then(|h| if h.is_empty() { None } else { Some(h) })
                    .or_else(|| unsafe { fallback() })
                    .map(PathBuf::from);
                    
                unsafe fn fallback() -> Option<OsString>
                {
                    let amt = match sysconf( _SC_GETPW_R_SIZE_MAX) {
                        n if n < 0 => 512 as usize,
                        n => n as usize,
                    };
                    let mut buf = Vec::with_capacity(amt);
                    let mut passwd:passwd = mem::zeroed();
                    let mut result = ptr::null_mut();
                    match getpwuid_r( getuid(), &mut passwd, buf.as_mut_ptr(), buf.capacity(), &mut result)
                    {
                        0 if !result.is_null() => {
                            let ptr = passwd.pw_dir as *const _;
                            let bytes = CStr::from_ptr(ptr).to_bytes();
                            if bytes.is_empty() {
                                None
                            } else {
                                Some(OsStringExt::from_vec(bytes.to_vec()))
                            }
                        }
                        _ => None,
                    }
                }
            }
            /// Returns all XDG user directories obtained from $(XDG_CONFIG_HOME)/user-dirs.dirs.
            pub fn all(home_dir_path: &Path, user_dir_file_path: &Path) -> HashMap<String, PathBuf>
            {
                let bytes = fs::read(user_dir_file_path).unwrap_or_default();
                parse_user_dirs(home_dir_path, None, &bytes)
            }
            /// Returns a single XDG user directory obtained from $(XDG_CONFIG_HOME)/user-dirs.dirs.
            pub fn single(home_dir_path: &Path, user_dir_file_path: &Path, user_dir_name: &str) -> HashMap<String, PathBuf>
            {
                let bytes = fs::read(user_dir_file_path).unwrap_or_default();
                parse_user_dirs(home_dir_path, Some(user_dir_name), &bytes)
            }

            fn parse_user_dirs(home_dir: &Path, user_dir: Option<&str>, bytes: &[u8]) -> HashMap<String, PathBuf>
            {
                let mut user_dirs = HashMap::new();

                for line in bytes.split(|b| *b == b'\n') {
                    let mut single_dir_found = false;
                    let (key, value) = match split_once(line, b'=') {
                        Some(kv) => kv,
                        None => continue,
                    };

                    let key = trim_blank(key);
                    let key = if key.starts_with(b"XDG_") && key.ends_with(b"_DIR") {
                        match str::from_utf8(&key[4..key.len() - 4]) {
                            Ok(key) => {
                                if user_dir.is_some() && option_contains(user_dir, key) {
                                    single_dir_found = true;
                                    key
                                } else if user_dir.is_none() {
                                    key
                                } else {
                                    continue;
                                }
                            }
                            Err(_) => continue,
                        }
                    } else {
                        continue;
                    };
                    
                    let value = trim_blank(value);
                    let mut value =
                        if value.starts_with(b"\"") && value.ends_with(b"\"") { &value[1..value.len() - 1] } else { continue };

                    let is_relative = if value == b"$HOME/"
                    {
                        continue;
                    } else if value.starts_with(b"$HOME/") {
                        value = &value[b"$HOME/".len()..];
                        true
                    } else if value.starts_with(b"/") {
                        false
                    } else {
                        continue;
                    };

                    let value = OsString::from_vec(shell_unescape(value));

                    let path = if is_relative {
                        let mut path = PathBuf::from(&home_dir);
                        path.push(value);
                        path
                    } else {
                        PathBuf::from(value)
                    };

                    user_dirs.insert(key.to_owned(), path);
                    if single_dir_found {
                        break;
                    }
                }

                user_dirs
            }
            /// Returns bytes before and after first occurrence of separator.
            fn split_once(bytes: &[u8], separator: u8) -> Option<(&[u8], &[u8])>
            {
                bytes.iter().position(|b| *b == separator).map(|i| (&bytes[..i], &bytes[i + 1..]))
            }
            /// Returns a slice with leading and trailing <blank> characters removed.
            fn trim_blank(bytes: &[u8]) -> &[u8]
            {
                let i = bytes.iter().cloned().take_while(|b| *b == b' ' || *b == b'\t').count();
                let bytes = &bytes[i..];
                let i = bytes.iter().cloned().rev().take_while(|b| *b == b' ' || *b == b'\t').count();
                &bytes[..bytes.len() - i]
            }
            /// Unescape bytes escaped with POSIX shell double-quotes rules (as used by xdg-user-dirs-update).
            fn shell_unescape(escaped: &[u8]) -> Vec<u8>
            {
                let mut unescaped: Vec<u8> = Vec::with_capacity(escaped.len());
                let mut i = escaped.iter().cloned();

                while let Some(b) = i.next() {
                    if b == b'\\' {
                        if let Some(b) = i.next() {
                            unescaped.push(b);
                        }
                    } else {
                        unescaped.push(b);
                    }
                }

                unescaped
            }

            fn option_contains<T: PartialEq>(option: Option<T>, value: T) -> bool
            {
                match option
                {
                    Some(val) => val == value,
                    None => false,
                }
            }

            pub fn home_dir() -> Option<PathBuf> { home_directory() }

            pub fn cache_dir() -> Option<PathBuf> 
            {
                env::var_os("XDG_CACHE_HOME")
                    .and_then( is::absolute_path )
                    .or_else(|| home_dir().map(|h| h.join(".cache")))
            }
            
            pub fn config_dir() -> Option<PathBuf>
            {
                env::var_os("XDG_CONFIG_HOME")
                    .and_then( is::absolute_path )
                    .or_else(|| home_dir().map(|h| h.join(".config")))
            }
            
            pub fn data_dir() -> Option<PathBuf>
            {
                env::var_os("XDG_DATA_HOME")
                    .and_then( is::absolute_path )
                    .or_else(|| home_dir().map(|h| h.join(".local/share")))
            }
            
            pub fn data_local_dir() -> Option<PathBuf> { data_dir() }

            pub fn runtime_dir() -> Option<PathBuf> { env::var_os("XDG_RUNTIME_DIR").and_then( is::absolute_path ) }

            pub fn executable_dir() -> Option<PathBuf>
            {
                env::var_os("XDG_BIN_HOME").and_then( is::absolute_path ).or_else(||
                {
                    data_dir().map(|mut e|
                    {
                        e.pop();
                        e.push("bin");
                        e
                    })
                })
            }

            pub fn audio_dir() -> Option<PathBuf> { user_dir("MUSIC") }

            pub fn desktop_dir() -> Option<PathBuf> { user_dir("DESKTOP") }

            pub fn document_dir() -> Option<PathBuf> { user_dir("DOCUMENTS") }

            pub fn download_dir() -> Option<PathBuf> { user_dir("DOWNLOAD") }

            pub fn font_dir() -> Option<PathBuf> { data_dir().map(|d| d.join("fonts")) }

            pub fn picture_dir() -> Option<PathBuf> { user_dir("PICTURES") }

            pub fn public_dir() -> Option<PathBuf> { user_dir("PUBLICSHARE") }

            pub fn template_dir() -> Option<PathBuf> { user_dir("TEMPLATES") }

            pub fn video_dir() -> Option<PathBuf> { user_dir("VIDEOS") }
        } #[cfg( unix )] pub use self::unix::{ * };

        pub mod windows
        {
            use ::
            {
                ffi::{ OsString },
                libc::windows::{ * },
                path::{ PathBuf },
                *,
            };
            
            pub fn known_folder( folder_id: REFKNOWNFOLDERID ) -> Option<PathBuf>
            {
                /*
                unsafe
                {
                    let mut path_ptr: winnt::PWSTR = ptr::null_mut();
                    let result = shlobj::SHGetKnownFolderPath(folder_id, 0, ptr::null_mut(), &mut path_ptr);
                    if result == S_OK
                    {
                        let len = winbase::lstrlenW(path_ptr) as usize;
                        let path = slice::from_raw_parts(path_ptr, len);
                        let ostr: OsString = OsStringExt::from_wide(path);
                        combaseapi::CoTaskMemFree(path_ptr as *mut winapi::ctypes::c_void);
                        Some(PathBuf::from(ostr))
                    } else { None }
                }*/
                None
            }

            pub fn known_folder_profile() -> Option<PathBuf> { known_folder( GUID::folder_id_profile() ) }

            pub fn known_folder_roaming_app_data() -> Option<PathBuf>
            { known_folder( GUID::folder_id_roaming_app_data() ) }

            pub fn known_folder_local_app_data() -> Option<PathBuf>
            { known_folder( GUID::folder_id_local_app_data() ) }

            pub fn known_folder_music() -> Option<PathBuf>
            { known_folder( GUID::folder_id_music() ) }

            pub fn known_folder_desktop() -> Option<PathBuf>
            { known_folder( GUID::folder_id_desktop() ) }

            pub fn known_folder_documents() -> Option<PathBuf>
            { known_folder( GUID::folder_id_documents() ) }

            pub fn known_folder_downloads() -> Option<PathBuf>
            { known_folder( GUID::folder_id_downloads() ) }

            pub fn known_folder_pictures() -> Option<PathBuf>
            { known_folder( GUID::folder_id_pictures() ) }

            pub fn known_folder_public() -> Option<PathBuf>
            { known_folder( GUID::folder_id_pictures() ) }
            
            pub fn known_folder_templates() -> Option<PathBuf>
            { known_folder( GUID::folder_id_templates() ) }
            
            pub fn known_folder_videos() -> Option<PathBuf>
            { known_folder( GUID::folder_id_videos() ) }

            pub fn home_dir() -> Option<PathBuf> { known_folder_profile() }
            pub fn data_dir() -> Option<PathBuf> { known_folder_roaming_app_data() }
            pub fn data_local_dir() -> Option<PathBuf> { known_folder_local_app_data() }
            pub fn cache_dir() -> Option<PathBuf> { data_local_dir() }
            pub fn config_dir() -> Option<PathBuf> { data_dir() }
            pub fn executable_dir() -> Option<PathBuf> { None }
            pub fn runtime_dir() -> Option<PathBuf> { None }
            pub fn audio_dir() -> Option<PathBuf> { known_folder_music() }
            pub fn desktop_dir() -> Option<PathBuf> { known_folder_desktop() }
            pub fn document_dir() -> Option<PathBuf> { known_folder_documents() }
            pub fn download_dir() -> Option<PathBuf> { known_folder_downloads() }
            pub fn font_dir() -> Option<PathBuf> { None }
            pub fn picture_dir() -> Option<PathBuf> { known_folder_pictures() }
            pub fn public_dir() -> Option<PathBuf> { known_folder_public() }
            pub fn template_dir() -> Option<PathBuf> { known_folder_templates() }
            pub fn video_dir() -> Option<PathBuf> { known_folder_videos() }
        } #[cfg( windows )] pub use self::windows::{ * };
    } pub use self::system as sys;
    /*
    dirs v6.0.0*/
    /// Returns the path to the user's home directory.
    pub fn home_dir() -> Option<PathBuf> { sys::home_dir() }
    /// Returns the path to the user's cache directory.
    pub fn cache_dir() -> Option<PathBuf> { sys::cache_dir() }
    /// Returns the path to the user's config directory.
    pub fn config_dir() -> Option<PathBuf> { sys::config_dir() }
    /// Returns the path to the user's data directory.
    pub fn data_dir() -> Option<PathBuf> { sys::data_dir() }
    /// Returns the path to the user's local data directory.
    pub fn data_local_dir() -> Option<PathBuf> { sys::data_local_dir() }
    /// Returns the path to the user's executable directory.
    pub fn executable_dir() -> Option<PathBuf> { sys::executable_dir() }
    /// Returns the path to the user's runtime directory.
    pub fn runtime_dir() -> Option<PathBuf> { sys::runtime_dir() }
    /// Returns the path to the user's audio directory.
    pub fn audio_dir() -> Option<PathBuf> { sys::audio_dir() }
    /// Returns the path to the user's desktop directory.
    pub fn desktop_dir() -> Option<PathBuf> { sys::desktop_dir() }
    /// Returns the path to the user's document directory.
    pub fn document_dir() -> Option<PathBuf> { sys::document_dir() }
    /// Returns the path to the user's download directory.
    pub fn download_dir() -> Option<PathBuf> { sys::download_dir() }
    /// Returns the path to the user's font directory.
    pub fn font_dir() -> Option<PathBuf> { sys::font_dir() }
    /// Returns the path to the user's picture directory.
    pub fn picture_dir() -> Option<PathBuf> { sys::picture_dir() }
    /// Returns the path to the user's public directory.
    pub fn public_dir() -> Option<PathBuf> { sys::public_dir() }
    /// Returns the path to the user's template directory.
    pub fn template_dir() -> Option<PathBuf> { sys::template_dir() }
    /// Returns the path to the user's video directory.
    pub fn video_dir() -> Option<PathBuf> { sys::video_dir() }

    pub fn basename(path: &str) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit('/');
        match pieces.next()
        {
            Some(p) => p.into(),
            None => path.into(),
        }
    }

    pub fn expand_home(text: &str) -> String
    {
        let mut s: String = text.to_string();
        let v = vec!
        [
            r"(?P<head> +)~(?P<tail> +)",
            r"(?P<head> +)~(?P<tail>/)",
            r"^(?P<head> *)~(?P<tail>/)",
            r"(?P<head> +)~(?P<tail> *$)",
        ];
        
        for item in &v
        {
            let re;
            
            if let Ok(x) = Regex::new(item) { re = x; }
            else { return String::new(); }

            let home = env::get_user_home();
            let ss = s.clone();
            let to = format!("$head{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();
        }

        s
    }

    pub fn find_file_in_path( filename: &str, exec: bool ) -> String
    {
        let env_path = match env::var("PATH")
        {
            Ok(x) => x,
            Err(e) =>
            {
                println_stderr!("cicada: error with env PATH: {:?}", e);
                return String::new();
            }
        };

        let vec_path: Vec<&str> = env_path.split(':').collect();

        for p in &vec_path
        {
            match read_dir(p)
            {
                Ok(list) =>
                {
                    for entry in list.flatten()
                    {
                        if let Ok( name) = entry.file_name().into_string()
                        {
                            if name != filename { continue; }

                            if exec
                            {
                                let _mode = match entry.metadata()
                                {
                                    Ok(x) => x,
                                    Err(e) =>
                                    {
                                        println_stderr!("cicada: metadata error: {:?}", e);
                                        continue;
                                    }
                                };

                                let mode = _mode.permissions().mode();

                                if mode & 0o111 == 0 { continue; }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }

                Err(e) =>
                {
                    if e.kind() == ErrorKind::NotFound { continue; }

                    log!("cicada: fs read_dir error: {}: {}", p, e);
                }
            }
        }

        String::new()
    }

    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir()
        {
            Ok(x) => x,
            Err(e) => {
                log!("cicada: PROMPT: env current_dir error: {}", e);
                return String::new();
            }
        };

        let current_dir = match _current_dir.to_str()
        {
            Some(x) => x,
            None =>
            {
                log!("cicada: PROMPT: to_str error");
                return String::new();
            }
        };

        current_dir.to_string()
    }

    pub fn get_current_dir() -> String
    {
        let mut current_dir = PathBuf::new();

        match env::current_dir() 
        {
            Ok(x) => current_dir = x,
            Err(e) => { println_stderr!("env current_dir() failed: {}", e); }
        }

        let mut str_current_dir = "";

        match current_dir.to_str()
        {
            Some(x) => str_current_dir = x,
            None => 
            {
                println_stderr!("current_dir to str failed.");
            }
        }

        str_current_dir.to_string()
    }
}

pub mod process
{
    pub use std::process::{ * };

    use ::
    {
        nix::
        { 
            unistd::{ fork as nix_fork, ForkResult },
            Result as NixResult
        },
        shell::{ Shell },
        types::{ * },
    };
    /**/
    pub fn getpid() -> i32 { unsafe { libc::getpid() } }

    pub fn close(fd: i32) { unsafe { libc::close(fd); } }

    pub fn dup(fd: i32) -> i32 { unsafe { libc::dup(fd) } }

    pub fn dup2(src: i32, dst: i32) { unsafe { libc::dup2(src, dst); } }

    pub fn fork() -> NixResult<ForkResult> { unsafe{ nix_fork() } }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod rc
{
    pub use std::rc::{ * };
}

pub mod regex
{
    pub use ::re::{ * };    

    pub fn match_name(name: &str, value: &str) -> bool
    {
        name == value || (name.starts_with(value) && name.as_bytes()[value.len()] == b'-')
    }

    pub fn find_first_group(ptn: &str, text: &str) -> Option<String>
    {
        let re = match Regex::new(ptn)
        {
            Ok(x) => x,
            Err(_) => return None,
        };

        match re.captures(text)
        {
            Some(caps) =>
            {
                if let Some(x) = caps.get(1) { return Some(x.as_str().to_owned()); }
            }

            None => { return None; }
        }

        None
    }

    pub fn contains(text: &str, ptn: &str) -> bool
    {
        let re = match Regex::new(ptn)
        {
            Ok(x) => x,
            Err(e) =>
            {
                println!("Regex new error: {:?}", e);
                return false;
            }
        };

        re.is_match(text)
    }

    pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String
    {
        let re = Regex::new(ptn).unwrap();
        let result = re.replace_all(text, ptn_to);
        result.to_string()
    }

    pub fn unquote(text: &str) -> String
    {
        let mut new_str = String::from(text);
        for &c in ['"', '\''].iter()
        {
            if text.starts_with(c) && text.ends_with(c)
            {
                new_str.remove(0);
                new_str.pop();
                break;
            }
        }

        new_str
    }
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod run
{
    use ::
    {
        os::
        {
            fd::{ RawFd },
        },
        path::{ Path },
        shell::{ Shell },
        types::{ * },
        *,
    };

    pub fn alias(sh: &mut shell::Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();

        if tokens.len() == 1 {
            return show_alias_list(sh, cmd, cl, capture);
        }

        if tokens.len() > 2 {
            let info = "alias syntax error: usage: alias foo='echo foo'";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let input = &tokens[1].1;
        let re_single_read = Regex::new(r"^[a-zA-Z0-9_\.-]+$").unwrap();
        if re_single_read.is_match(input) {
            return show_single_alias(sh, input, cmd, cl, capture);
        }

        let re_to_add = Regex::new(r"^([a-zA-Z0-9_\.-]+)=(.*)$").unwrap();
        for cap in re_to_add.captures_iter(input) {
            let name = tools::unquote(&cap[1]);
            let value = if cap[2].starts_with('"') || cap[2].starts_with('\'') {
                tools::unquote(&cap[2])
            } else {
                cap[2].to_string()
            };
            sh.add_alias(name.as_str(), value.as_str());
        }

        CommandResult::new()
    }

    pub fn show_alias_list(sh: &shell::Shell, cmd:&Command, cl:&CommandLine, capture: bool) -> CommandResult
    {
        let mut lines = Vec::new();
        for (name, value) in sh.get_alias_list()
        {
            let line = format!("alias {}='{}'", name, value);
            lines.push(line);
        }

        let buffer = lines.join("\n");
        let mut cr = CommandResult::new();
        print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
        cr
    }

    pub fn show_single_alias
    ( 
        sh:&shell::Shell,
        name_to_find: &str,
        cmd:&Command,
        cl:&CommandLine,
        capture: bool
    ) -> CommandResult 
    {
        let mut cr = CommandResult::new();
        if let Some(content) = sh.get_alias_content(name_to_find) {
            let info = format!("alias {}='{}'", name_to_find, content);
            print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
        } else {
            let info = format!("cicada: alias: {}: not found", name_to_find);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
        }
        cr
    }

    pub fn bg(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if sh.jobs.is_empty() {
            let info = "cicada: bg: no job found";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let mut job_id = -1;
        if tokens.len() == 1 {
            if let Some((gid, _)) = sh.jobs.iter().next() {
                job_id = *gid;
            }
        }

        if tokens.len() >= 2 {
            let mut job_str = tokens[1].1.clone();
            if job_str.starts_with("%") {
                job_str = job_str.trim_start_matches('%').to_string();
            }

            match job_str.parse::<i32>() {
                Ok(n) => job_id = n,
                Err(_) => {
                    let info = "cicada: bg: invalid job id";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }
        if job_id == -1 {
            let info = "cicada: bg: not such job";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let gid: i32;
        {
            let mut result = sh.get_job_by_id(job_id);
            
            if result.is_none() {
                result = sh.get_job_by_gid(job_id);
            }

            match result {
                Some(job) => {
                    unsafe {
                        libc::killpg(job.gid, libc::SIGCONT);
                        gid = job.gid;
                        if job.status == "Running" {
                            let info = format!("cicada: bg: job {} already in background", job.id);
                            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                            return cr;
                        }
                    }

                    let info_cmd = format!("[{}]  {} &", job.id, job.cmd);
                    print_stderr_with_capture(&info_cmd, &mut cr, cl, cmd, capture);
                    cr.status = 0;
                }
                None => {
                    let info = "cicada: bg: not such job";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }

        libc::jobs::mark_job_as_running(sh, gid, true);
        cr
    }

    pub fn cd(sh: &mut shell::Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();
        let args = parsers::line::tokens_to_args(&tokens);

        if args.len() > 2 {
            let info = "cicada: cd: too many argument";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let str_current_dir = path::get_current_dir();

        let mut dir_to = if args.len() == 1 {
            let home = env::get_user_home();
            home.to_string()
        } else {
            args[1..].join("")
        };

        if dir_to == "-" {
            if sh.previous_dir.is_empty() {
                let info = "no previous dir";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }
            dir_to = sh.previous_dir.clone();
        } else if !dir_to.starts_with('/') {
            dir_to = format!("{}/{}", str_current_dir, dir_to);
        }

        if !Path::new(&dir_to).exists() {
            let info = format!("cicada: cd: {}: No such file or directory", &args[1]);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            return cr;
        }

        match Path::new(&dir_to).canonicalize() {
            Ok(p) => {
                dir_to = p.as_path().to_string_lossy().to_string();
            }
            Err(e) => {
                let info = format!("cicada: cd: error: {}", e);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
        }

        match env::set_current_dir(&dir_to) {
            Ok(_) => {
                sh.current_dir = dir_to.clone();
                if str_current_dir != dir_to {
                    sh.previous_dir = str_current_dir.clone();
                    env::set_var("PWD", &sh.current_dir);
                };
                cr.status = 0;
                cr
            }
            Err(e) => {
                let info = format!("cicada: cd: {}", e);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                cr
            }
        }
    }
    /*
    pub const VERSION: &str= match option_env!("VERSION")
    {
        Some(v) => v,
        None => "dev",
    };
    */
    pub fn cinfo( _sh: &mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut info = vec![];

        pub const VERSION: &str = match option_env!("VERSION")
        {
            Some( version ) => version,
            None => "1.68",
        }; info.push(("version", VERSION));

        let os_name = os::get_os_name();
        info.push(("os-name", &os_name));

        let hfile = history::get_history_file();
        info.push(("history-file", &hfile));

        let rcf = rcfile::get_rc_file();
        info.push(("rc-file", &rcf));
        
        let git_hash = match option_env!("GIT_HASH")
        {
            Some( hash ) => hash,
            None => "01234567890123456789",
        }; info.push(("git-commit", git_hash ));
        
        let git_branch = match option_env!("GIT_HASH")
        {
            Some( branch ) => branch,
            None => "main",
        }; info.push(("git-branch", git_branch ));
        
        let built_with = match option_env!("BUILD_RUSTC_VERSION")
        {
            Some( version ) => version,
            None => "1.86",
        }; info.push(("built-with", built_with ));
        
        let built_at = match option_env!("BUILD_DATE")
        {
            Some( date ) => date,
            None => "1.86",
        }; info.push(("built-at", built_at ));

        let mut lines = Vec::new();
        
        for (k, v) in &info
        {
            lines.push(format!("{: >12}: {}", k, v));
        }

        let buffer = lines.join("\n");
        let mut cr = CommandResult::new();
        print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
        cr
    }
    
    pub fn exec(_sh: &Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
        let args = parsers::line::tokens_to_args(&tokens);
        let len = args.len();
        if len == 1 {
            print_stderr_with_capture("invalid usage", &mut cr, cl, cmd, capture);
            return cr;
        }

        let mut _cmd = exec::Command::new(&args[1]);
        let err = _cmd.args(&args[2..len]).exec();
        let info = format!("cicada: exec: {}", err);
        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
        cr
    }

    pub fn exit(sh: &Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
        if tokens.len() > 2 {
            let info = "cicada: exit: too many arguments";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        if tokens.len() == 2 {
            let _code = &tokens[1].1;
            match _code.parse::<i32>() {
                Ok(x) => {
                    process::exit(x);
                }
                Err(_) => {
                    let info = format!("cicada: exit: {}: numeric argument required", _code);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    process::exit(255);
                }
            }
        }

        for (_i, job) in sh.jobs.iter() {
            if !job.cmd.starts_with("nohup ") {
                let mut info = String::new();
                info.push_str("There are background jobs.");
                info.push_str("Run `jobs` to see details; `exit 1` to force quit.");
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
        }

        process::exit(0);
        cr
    }
    
    pub fn export(_sh: &Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();

        let re_name_ptn = Regex::new(r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$").unwrap();
        for (_, text) in tokens.iter() {
            if text == "export" {
                continue;
            }

            if !tools::is_env(text) {
                let mut info = String::new();
                info.push_str("export: invalid command\n");
                info.push_str("usage: export XXX=YYY");
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }

            if !re_name_ptn.is_match(text) {
                let mut info = String::new();
                info.push_str("export: invalid command\n");
                info.push_str("usage: export XXX=YYY ZZ=123");
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }

            for cap in re_name_ptn.captures_iter(text) {
                let name = cap[1].to_string();
                let token = parsers::line::unquote(&cap[2]);
                let value = path::expand_home(&token);
                env::set_var(name, &value);
            }
        }
        cr
    }
    
    pub fn fg(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if sh.jobs.is_empty() {
            let info = "cicada: fg: no job found";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let mut job_id = -1;
        if tokens.len() == 1 {
            if let Some((gid, _)) = sh.jobs.iter().next() {
                job_id = *gid;
            }
        }

        if tokens.len() >= 2 {
            let mut job_str = tokens[1].1.clone();
            if job_str.starts_with("%") {
                job_str = job_str.trim_start_matches('%').to_string();
            }

            match job_str.parse::<i32>() {
                Ok(n) => job_id = n,
                Err(_) => {
                    let info = "cicada: fg: invalid job id";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }

        if job_id == -1 {
            let info = "cicada: not job id found";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let gid: i32;
        let pid_list: Vec<i32>;
        {
            let mut result = sh.get_job_by_id(job_id);

            if result.is_none() {
                result = sh.get_job_by_gid(job_id);
            }

            match result {
                Some(job) => {
                    print_stderr_with_capture(&job.cmd, &mut cr, cl, cmd, capture);
                    cr.status = 0;

                    unsafe {
                        if !shell::give_terminal_to(job.gid) {
                            return CommandResult::error();
                        }

                        libc::killpg(job.gid, libc::SIGCONT);
                        pid_list = job.pids.clone();
                        gid = job.gid;
                    }
                }
                None => {
                    let info = "cicada: fg: no such job";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }

        unsafe {
            libc::jobs::mark_job_as_running(sh, gid, false);

            let cr = libc::jobs::wait_fg_job(sh, gid, &pid_list);

            let gid_shell = libc::getpgid(0);
            if !shell::give_terminal_to(gid_shell) {
                log!("failed to give term to back to shell : {}", gid_shell);
            }

            cr
        }
    }

    pub fn history(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let hfile = history::get_file();
        let path = Path::new(hfile.as_str());
        
        if !path.exists()
        {
            let info = "no history file";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let conn = match Connection::open(&hfile)
        {
            Ok(x) => x,
            Err(e) => {
                let info = format!("history: sqlite error: {:?}", e);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
        };

        let tokens = cmd.tokens.clone();
        let args = parsers::line::tokens_to_args(&tokens);

        let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");
        let opt = OptMain::from_iter_safe(args);
        
        match opt
        {
            Ok(opt) =>
            {
                match opt.cmd
                {
                    Some(SubCommand::Delete {rowid: rowids}) =>
                    {
                        let mut _count = 0;

                        for rowid in rowids
                        
                        {
                            let _deleted = history::delete(&conn, rowid);
                            if _deleted { _count += 1; }
                        }

                        if _count > 0
                        {
                            let info = format!("deleted {} items", _count);
                            print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                        }
                        cr
                    }
                    
                    Some(SubCommand::Add {timestamp: ts, input}) => 
                    {
                        let ts = ts.unwrap_or(0 as f64);
                        history::insert(sh, ts, &input);
                        cr
                    }

                    None => {
                        let (str_out, str_err) = list(sh, &conn, &opt);
                        if !str_out.is_empty() {
                            print_stdout_with_capture(&str_out, &mut cr, cl, cmd, capture);
                        }
                        if !str_err.is_empty() {
                            print_stderr_with_capture(&str_err, &mut cr, cl, cmd, capture);
                        }

                        cr
                    }
                }
            }

            Err(e) =>
            {
                let info = format!("{}", e);
                if show_usage {
                    print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                    cr.status = 0;
                } else {
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    cr.status = 1;
                }
                cr
            }
        }
    }

    pub fn jobs(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        if sh.jobs.is_empty() {
            return cr;
        }
        
        libc::jobs::try_wait_bg_jobs(sh, false, false);

        let mut lines = Vec::new();
        let jobs = sh.jobs.clone();
        let no_trim = cmd.tokens.len() >= 2 && cmd.tokens[1].1 == "-f";
        for (_i, job) in jobs.iter() {
            let line = libc::jobs::get_job_line(job, !no_trim);
            lines.push(line);
        }
        let buffer = lines.join("\n");

        print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
        cr
    }

    pub fn minfd(_sh: &mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();

        let fd = nix::fcntl::open(
            "/dev/null",
            nix::fcntl::OFlag::empty(),
            nix::sys::stat::Mode::empty()
        );
        match fd {
            Ok(fd) => {
                let info = format!("{}", fd);
                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                unsafe { libc::close(fd); }
            }
            Err(e) => {
                println_stderr!("cicada: minfd: error: {}", e);
            }
        }

        cr
    }

    pub fn _find_invalid_identifier(name_list: &Vec<String>) -> Option<String>
    {
        for id_ in name_list
        {
            if !contains(id_, r"^[a-zA-Z_][a-zA-Z0-9_]*$")
            {
                return Some(id_.to_string());
            }
        }
        None
    }

    pub fn read(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();

        let name_list: Vec<String>;
        if tokens.len() <= 1 {
            name_list = vec!["REPLY".to_string()];
        } else {
            name_list = tokens[1..].iter().map(|x| x.1.clone()).collect();
            if let Some(id_) = _find_invalid_identifier(&name_list) {
                let info = format!("cicada: read: `{}': not a valid identifier", id_);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
        }

        let mut buffer = String::new();

        if cmd.has_here_string() {
            if let Some(redirect_from) = &cmd.redirect_from {
                buffer.push_str(&redirect_from.1);
                buffer.push('\n');
            }
        } else {
            match io::stdin().read_line(&mut buffer) {
                Ok(_) => {}
                Err(e) => {
                    let info = format!("cicada: read: error in reading stdin: {:?}", e);
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }

        let envs = cl.envs.clone();
        let value_list = tools::split_into_fields(sh, buffer.trim(), &envs);

        let idx_2rd_last = name_list.len() - 1;
        for i in 0..idx_2rd_last {
            let name = name_list.get(i);
            if name.is_none() {
                let info = "cicada: read: name index error";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }
            let name = name.unwrap();

            let value = value_list.get(i).unwrap_or(&String::new()).clone();
            sh.set_env(name, &value);
        }

        let name_last = &name_list[idx_2rd_last];
        let value_left: String = if value_list.len() > idx_2rd_last {
            value_list[idx_2rd_last..].join(" ")
        } else {
            String::new()
        };
        sh.set_env(name_last, &value_left);
        cr
    }

    pub fn set(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        /*
        let tokens = &cmd.tokens;
        let args = parsers::line::tokens_to_args(tokens);
        let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");

        let opt = OptMain::from_iter_safe(args);
        match opt {
            Ok(opt) => {
                if opt.exit_on_error {
                    sh.exit_on_error = true;
                    cr
                } else {
                    let info = "cicada: set: option not implemented";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    cr
                }
            }
            Err(e) => {
                let info = format!("{}", e);
                if show_usage {
                    print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                    cr.status = 0;
                } else {
                    print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                    cr.status = 1;
                }
                cr
            }
        } */
        cr
    }

    pub fn source(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = &cmd.tokens;
        let args = parsers::line::tokens_to_args(tokens);

        if args.len() < 2 {
            let info = "cicada: source: no file specified";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let status = scripts::run_script(sh, &args);
        cr.status = status;
        cr
    }

    pub fn ulimit(_sh: &mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = &cmd.tokens;
        let args = parsers::line::tokens_to_args(tokens);

        if args.contains(&"--help".to_string()) || args.contains(&"-h".to_string()) {
            App::command().print_help().unwrap();
            println!();
            return cr;
        }

        let app = App::parse_from(args);

        if app.H && app.S {
            println!("cicada: ulimit: Cannot both hard and soft.");
            cr.status = 1;
            return cr;
        }

        let mut all_stdout = String::new();
        let mut all_stderr = String::new();

        if app.a {
            report_all(&app, &mut all_stdout, &mut all_stderr);
        } else if handle_limit(app.n, "open_files", app.H, &mut all_stdout, &mut all_stderr)
            || handle_limit(app.c, "core_file_size", app.H, &mut all_stdout, &mut all_stderr) {
        } else {
            report_all(&app, &mut all_stdout, &mut all_stderr);
        }

        if !all_stdout.is_empty() {
            print_stdout_with_capture(&all_stdout, &mut cr, cl, cmd, capture);
        }
        if !all_stderr.is_empty() {
            print_stderr_with_capture(&all_stderr, &mut cr, cl, cmd, capture);
        }

        cr
    }

    pub fn set_limit(limit_name: &str, value: u64, for_hard: bool) -> String
    {
        let limit_id = match limit_name {
            "open_files" => libc::RLIMIT_NOFILE,
            "core_file_size" => libc::RLIMIT_CORE,
            _ => return String::from("invalid limit name"),
        };

        let mut rlp = libc::rlimit { rlim_cur: 0, rlim_max: 0 };

        unsafe {
            if libc::getrlimit(limit_id, &mut rlp) != 0 {
                return format!("cicada: ulimit: error getting limit: {}", Error::last_os_error());
            }
        }
        
        if for_hard {
            #[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
            { rlp.rlim_max = value as u32; }
            #[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
            { rlp.rlim_max = value; }
        } else {
            #[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
            { rlp.rlim_cur = value as u32; }
            #[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
            { rlp.rlim_cur = value; }
        }

        unsafe {
            if libc::setrlimit(limit_id, &rlp) != 0 {
                return format!("cicada: ulimit: error setting limit: {}", Error::last_os_error());
            }
        }

        String::new()
    }

    pub fn get_limit(limit_name: &str, single_print: bool, for_hard: bool) -> (String, String)
    {
        let (desc, limit_id) = match limit_name {
            "open_files" => ("open files", libc::RLIMIT_NOFILE),
            "core_file_size" => ("core file size", libc::RLIMIT_CORE),
            _ => return (String::new(), String::from("ulimit: error: invalid limit name")),
        };

        let mut rlp = libc::rlimit { rlim_cur: 0, rlim_max: 0 };

        let mut result_stdout = String::new();
        let mut result_stderr = String::new();

        unsafe {
            if libc::getrlimit(limit_id, &mut rlp) != 0 {
                result_stderr.push_str(&format!("error getting limit: {}", Error::last_os_error()));
                return (result_stdout, result_stderr);
            }

            let to_print = if for_hard { rlp.rlim_max } else { rlp.rlim_cur };

            let info = if to_print == libc::RLIM_INFINITY {
                if single_print { "unlimited\n".to_string() } else { format!("{}\t\tunlimited\n", desc) }
            } else if single_print {
                format!("{}\n", to_print)
            } else {
                format!("{}\t\t{}\n", desc, to_print)
            };

            result_stdout.push_str(&info);
        }

        (result_stdout, result_stderr)
    }

    pub fn report_all(app: &App, all_stdout: &mut String, all_stderr: &mut String)
    {
        for limit_name in &["open_files", "core_file_size"] {
            let (out, err) = get_limit(limit_name, false, app.H);
            all_stdout.push_str(&out);
            all_stderr.push_str(&err);
        }
    }

    pub fn handle_limit
    (
        limit_option: Option<Option<u64>>,
        limit_name: &str,
        for_hard: bool,
        all_stdout: &mut String,
        all_stderr: &mut String
    ) -> bool
    {
        match limit_option
        {
            None => false,
            Some(None) => {
                let (out, err) = get_limit(limit_name, true, for_hard);
                all_stdout.push_str(&out);
                all_stderr.push_str(&err);
                true
            }
            Some(Some(value)) => {
                let err = set_limit(limit_name, value, for_hard);
                if !err.is_empty() {
                    all_stderr.push_str(&err);
                }
                true
            }
        }
    }
    
    pub fn unalias(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if tokens.len() != 2 {
            let info = "cicada: unalias: syntax error";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let input = &tokens[1].1;
        if !sh.remove_alias(input) {
            let info = format!("cicada: unalias: {}: not found", input);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            return cr;
        }
        cr
    }

    pub fn unpath(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if tokens.len() != 2 {
            let info = "cicada: unpath: syntax error";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let input = &tokens[1].1;
        sh.remove_path(input);
        cr
    }

    pub fn unset(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if tokens.len() != 2 {
            let info = "cicada: unset: syntax error";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }

        let input = &tokens[1].1;
        if !sh.remove_env(input) {
            let info = format!("cicada: unset: invalid varname: {:?}", input);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            return cr;
        }
        cr
    }

    pub fn in_env() -> bool { env::var("VIRTUAL_ENV").map_or(false, |x| !x.is_empty()) }

    pub fn get_envs_home() -> String { env::var("VIRTUALENV_HOME").unwrap_or_default() }

    pub fn get_all_venvs() -> Result<Vec<String>, String>
    {
        let home_envs = get_envs_home();
        if home_envs.is_empty() {
            let info = String::from("you need to set VIRTUALENV_HOME to use vox");
            return Err(info);
        }
        if !Path::new(home_envs.as_str()).exists() {
            match fs::create_dir_all(home_envs.as_str()) {
                Ok(_) => {}
                Err(e) => {
                    let info = format!("fs create_dir_all failed: {:?}", e);
                    return Err(info);
                }
            }
        }

        let mut venvs = Vec::new();
        let pdir = home_envs.clone();
        if let Ok(list) = fs::read_dir(home_envs) {
            for ent in list.flatten() {
                let ent_name = ent.file_name();
                if let Ok(path) = ent_name.into_string() {
                    let full_path = format!("{}/{}/bin/activate", pdir, path);
                    if !Path::new(full_path.as_str()).exists() {
                        continue;
                    }
                    venvs.push(path);
                }
            }
        }

        Ok(venvs)
    }

    pub fn enter_env(sh: &Shell, path: &str) -> String
    {
        if in_env() {
            return "vox: already in env".to_string();
        }

        let home_envs = get_envs_home();
        let full_path = format!("{}/{}/bin/activate", home_envs, path);
        if !Path::new(full_path.as_str()).exists() {
            return format!("no such env: {}", full_path);
        }

        let path_env = format!("{}/{}", home_envs, path);
        env::set_var("VIRTUAL_ENV", &path_env);
        let path_new = String::from("${VIRTUAL_ENV}/bin:$PATH");
        let mut tokens: types::Tokens = Vec::new();
        tokens.push((String::new(), path_new));
        shell::expand_env(sh, &mut tokens);
        env::set_var("PATH", &tokens[0].1);
        String::new()
    }

    pub fn exit_env(sh: &Shell) -> String 
    {
        if !in_env() {
            return String::from("vox: not in an env");
        }

        let env_path = match env::var("PATH") {
            Ok(x) => x,
            Err(_) => {
                return String::from("vox: cannot read PATH env");
            }
        };

        let mut _tokens: Vec<&str> = env_path.split(':').collect();
        let mut path_virtual_env = String::from("${VIRTUAL_ENV}/bin");
        // shell::extend_env(sh, &mut path_virtual_env);
        let mut tokens: types::Tokens = Vec::new();
        tokens.push((String::new(), path_virtual_env));
        shell::expand_env(sh, &mut tokens);
        path_virtual_env = tokens[0].1.clone();
        _tokens
            .iter()
            .position(|&n| n == path_virtual_env)
            .map(|e| _tokens.remove(e));
        let env_path_new = _tokens.join(":");
        env::set_var("PATH", &env_path_new);
        env::set_var("VIRTUAL_ENV", "");

        String::new()
    }

    pub fn vox(sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
        let args = parsers::line::tokens_to_args(&tokens);
        let len = args.len();
        let subcmd = if len > 1 { &args[1] } else { "" };

        if len == 1 || (len == 2 && subcmd == "ls")
        {
            match get_all_venvs() {
                Ok(venvs) => {
                    let info = venvs.join("\n");
                    print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                    return cr;
                }
                Err(reason) => {
                    print_stderr_with_capture(&reason, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }

        if len == 3 && subcmd == "create"
        {
            let pybin = match env::var("VIRTUALENV_PYBIN") {
                Ok(x) => x,
                Err(_) => "python3".to_string(),
            };
            let dir_venv = get_envs_home();
            let venv_name = args[2].to_string();
            let line = format!("{} -m venv \"{}/{}\"", pybin, dir_venv, venv_name);
            print_stderr_with_capture(&line, &mut cr, cl, cmd, capture);
            let cr_list = now::run_command_line(sh, &line, false, false);
            return cr_list[0].clone();
        }

        if len == 3 && subcmd == "enter"
        {
            let _err = enter_env(sh, args[2].as_str());
            if !_err.is_empty() {
                print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
            }
            cr
        }
        
        else if len == 2 && subcmd == "exit"
        {
            let _err = exit_env(sh);
            if !_err.is_empty() {
                print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
            }
            cr
        }
        
        else
        {
            let info = "cicada: vox: invalid option";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            cr
        }
    }
    /// Helper function to get (stdout, stderr) pairs for redirections
    pub fn _get_std_fds( redirects: &[Redirection] ) -> (Option<RawFd>, Option<RawFd>)
    {
        if redirects.is_empty() { return (None, None); }

        let mut fd_out = None;
        let mut fd_err = None;

        for i in 0..redirects.len()
        {
            let item = &redirects[i];

            if item.0 == "1"
            {
                let mut _fd_candidate = None;

                if item.2 == "&2"
                {
                    let (_fd_out, _fd_err) = _get_std_fds(&redirects[i+1..]);

                    if let Some(fd) = _fd_err { _fd_candidate = Some(fd); }
                    else { _fd_candidate = unsafe { Some(libc::dup(2)) }; }
                }

                else
                {
                    let append = item.1 == ">>";
                    if let Ok(fd) = create_raw_from_file(&item.2, append) { _fd_candidate = Some(fd); }
                }
                
                if let Some(fd) = fd_out { unsafe { libc::close(fd); } }
                
                fd_out = _fd_candidate;
            }

            if item.0 == "2"
            {
                let mut _fd_candidate = None;

                if item.2 == "&1"
                {
                    if let Some(fd) = fd_out { _fd_candidate = unsafe { Some(libc::dup(fd)) }; }
                }
                
                else
                {
                    let append = item.1 == ">>";
                    if let Ok(fd) = os::fd::create_raw_from_file(&item.2, append) { _fd_candidate = Some(fd); }
                }

                if let Some(fd) = fd_err { unsafe { libc::close(fd); } }

                fd_err = _fd_candidate;
            }
        }

        (fd_out, fd_err)
    }

    pub fn _get_dupped_stdout_fd( cmd:&Command, cl:&CommandLine ) -> RawFd
    {
        if cl.with_pipeline() { return 1; }

        let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
        
        if let Some(fd) = _fd_err { unsafe { libc::close(fd); } }

        if let Some(fd) = _fd_out { fd }
        else
        {
            let fd = unsafe { libc::dup(1) };
            if fd == -1
            {
                let eno = errno();
                println_stderr!("cicada: dup: {}", eno);
            }
            fd
        }
    }

    pub fn _get_dupped_stderr_fd( cmd:&Command, cl:&CommandLine ) -> RawFd
    {
        if cl.with_pipeline() { return 2; }

        let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
        if let Some(fd) = _fd_out { unsafe { libc::close(fd); } }

        if let Some(fd) = _fd_err
        {
            fd
        }

        else
        {
            let fd = unsafe { libc::dup(2) };
            if fd == -1
            {
                let eno = errno();
                println_stderr!("cicada: dup: {}", eno);
            }

            fd
        }
    }

    pub fn print_stdout( info:&str, cmd:&Command, cl:&CommandLine )
    {
        unsafe
        {
            let fd = _get_dupped_stdout_fd(cmd, cl);
            if fd == -1 { return; }

            let mut f = File::from_raw_fd(fd);
            let info = info.trim_end_matches('\n');
            match f.write_all(info.as_bytes()) {
                Ok(_) => {},
                Err(e) => {
                    println_stderr!("write_all: error: {}", e);
                }
            }
            if !info.is_empty() {
                match f.write_all(b"\n") {
                    Ok(_) => {},
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }
            }
        }
    }

    pub fn print_stderr( info:&str, cmd:&Command, cl:&CommandLine )
    {
        let fd = _get_dupped_stderr_fd(cmd, cl);
        if fd == -1 {
            return;
        }

        unsafe {
            let mut f = File::from_raw_fd(fd);
            let info = info.trim_end_matches('\n');
            match f.write_all(info.as_bytes()) {
                Ok(_) => (),
                Err(e) => {
                    println_stderr!("write_all: error: {}", e);
                }
            }

            if !info.is_empty() {
                match f.write_all(b"\n") {
                    Ok(_) => (),
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }
            }
        }
    }

    pub fn print_stderr_with_capture
    (
        info:&str,
        cr: &mut CommandResult,
        cl:&CommandLine,
        cmd:&Command,
        capture: bool
    )
    {
        cr.status = 1;
        if capture {
            cr.stderr = info.to_string();
        } else {
            print_stderr(info, cmd, cl);
        }
    }

    pub fn print_stdout_with_capture
    (
        info:&str,
        cr: &mut CommandResult,
        cl:&CommandLine,
        cmd:&Command,
        capture: bool
    )
    {
        cr.status = 0;
        if capture { cr.stdout = info.to_string(); }
        else { print_stdout(info, cmd, cl); }
    }
}

pub mod scripts
{
    use ::
    {
        fs::{ File },
        io::{ Read, Write, ErrorKind },
        path::{ Path },
        regex::{ contains, Regex, RegexBuilder },
        types::{ * },
        *,
    };
    // pub fn run_script(sh: &mut shell::Shell, args: &Vec<String>) -> i32
    pub fn run(sh: &mut shell::Shell, args: &Vec<String>) -> i32
    {
        let src_file = &args[1];
        let full_src_file: String;
        if src_file.contains('/') {
            full_src_file = src_file.clone();
        } else {
            let full_path = libs::path::find_file_in_path(src_file, false);
            if full_path.is_empty() {
                // not in PATH and not in current work directory
                if !Path::new(src_file).exists() {
                    println_stderr!("cicada: {}: no such file", src_file);
                    return 1;
                }
                full_src_file = format!("./{}", src_file);
            } else {
                full_src_file = full_path.clone();
            }
        }

        if !Path::new(&full_src_file).exists() {
            println_stderr!("cicada: {}: no such file", src_file);
            return 1;
        }
        if Path::new(&full_src_file).is_dir() {
            println_stderr!("cicada: {}: is a directory", src_file);
            return 1;
        }

        let mut file;
        match File::open(&full_src_file) {
            Ok(x) => file = x,
            Err(e) => {
                println_stderr!("cicada: {}: failed to open file - {:?}", &full_src_file, e.kind());
                return 1;
            }
        }
        let mut text = String::new();
        match file.read_to_string(&mut text) {
            Ok(_) => {}
            Err(e) => {
                match e.kind() {
                    ErrorKind::InvalidData => {
                        println_stderr!("cicada: {}: not a valid script file", &full_src_file);
                    }
                    _ => {
                        println_stderr!("cicada: {}: error: {:?}", &full_src_file, e);
                    }
                }
                return 1;
            }
        }

        if text.contains("\\\n") {
            let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#)
                .multi_line(true).build().unwrap();
            text = re.replace_all(&text, " ").to_string();

            let re = RegexBuilder::new(r#"\\\n"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, "").to_string();
        }

        let re_func_head = Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
        let re_func_tail = Regex::new(r"^\}$").unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();
        for line in text.clone().lines() {
            if re_func_head.is_match(line.trim()) {
                enter_func = true;
                let cap = re_func_head.captures(line.trim()).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }
            if re_func_tail.is_match(line.trim()) {
                sh.set_func(&func_name, &func_body);
                enter_func = false;
                continue;
            }
            if enter_func {
                func_body.push_str(line);
                func_body.push('\n');
            } else {
                text_new.push_str(line);
                text_new.push('\n');
            }
        }

        let mut status = 0;
        let cr_list = run_lines(sh, &text_new, args, false);
        if let Some(last) = cr_list.last() {
            status = last.status;
        }
        
        sh.exit_on_error = false;

        status
    }

    pub fn run_lines
    (
        sh: &mut shell::Shell,
        lines: &str,
        args: &Vec<String>,
        capture: bool
    ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        match parsers::locust::parse_lines(lines)
        {
            Ok(pairs_exp) =>
            {
                for pair in pairs_exp
                {
                    let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, false, capture);
                    cr_list.append(&mut _cr_list);
                }
            }

            Err(e) =>
            {
                println_stderr!("syntax error: {:?}", e);
                return cr_list;
            }
        }
        cr_list
    }

    pub fn expand_args(line: &str, args: &[String]) -> String
    {
        let linfo = parsers::line::parse(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        parsers::line::from_tokens( &tokens )
    }

    pub fn expand_line_to_toknes(line: &str, args: &[String], sh: &mut shell::Shell) -> types::Tokens
    {
        let linfo = parsers::line::parse(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        shell::do_expansion(sh, &mut tokens);
        tokens
    }

    pub fn is_args_in_token(token: &str) -> bool { contains(token, r"\$\{?[0-9@]+\}?") }

    pub fn expand_args_for_single_token(token: &str, args: &[String]) -> String
    {
        let re = Regex::new(r"^(.*?)\$\{?([0-9]+|@)\}?(.*)$").unwrap();

        if !re.is_match(token) { return token.to_string(); }

        let mut result = String::new();
        let mut _token = token.to_string();
        let mut _head = String::new();
        let mut _output = String::new();
        let mut _tail = String::new();

        loop
        {
            if !re.is_match(&_token)
            {
                if !_token.is_empty() { result.push_str(&_token); }

                break;
            }

            for cap in re.captures_iter(&_token)
            {
                _head = cap[1].to_string();
                _tail = cap[3].to_string();
                let _key = cap[2].to_string();

                if _key == "@" { result.push_str(format!("{}{}", _head, args[1..].join(" ")).as_str()); }
                else if let Ok(arg_idx) = _key.parse::<usize>()
                {
                    if arg_idx < args.len() { result.push_str(format!("{}{}", _head, args[arg_idx]).as_str()); }
                    else { result.push_str(&_head); }
                }
                else { result.push_str(&_head); }
            }

            if _tail.is_empty() {
                break;
            }
            _token = _tail.clone();
        }
        result
    }

    fn expand_args_in_tokens(tokens: &mut types::Tokens, args: &[String])
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for (sep, token) in tokens.iter()
        {
            if sep == "`" || sep == "'" || !is_args_in_token(token) {
                idx += 1;
                continue;
            }

            let _token = expand_args_for_single_token(token, args);
            buff.push((idx, _token));
            idx += 1;
        }

        for (i, text) in buff.iter().rev()
        {
            tokens[*i].1 = text.to_string();
        }
    }

    fn run_exp_test_br
    (
        sh: &mut shell::Shell,
        pair_br: Pair<Rule>,
        args: &Vec<String>,
        in_loop: bool,
        capture: bool
    ) -> (Vec<CommandResult>, bool, bool, bool)
    {
        let mut cr_list = Vec::new();
        let pairs = pair_br.into_inner();
        let mut test_pass = false;
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == Rule::IF_HEAD ||
                    rule == Rule::IF_ELSEIF_HEAD ||
                    rule == Rule::WHILE_HEAD {
                let pairs_test: Vec<Pair<Rule>> =
                    pair.into_inner().collect();
                let pair_test = &pairs_test[0];
                let line = pair_test.as_str().trim();
                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = now::run_command_line(sh, &line_new, true, capture);
                if let Some(last) = _cr_list.last() {
                    if last.status == 0 {
                        test_pass = true;
                    }
                }
                continue;
            }

            if rule == Rule::KW_ELSE {
                test_pass = true;
                continue;
            }

            if rule == Rule::EXP_BODY {
                if !test_pass {
                    return (cr_list, false, false, false);
                }
                let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                // branch executed successfully
                return (cr_list, true, _cont, _brk);
            }

            unreachable!();
        }
        (cr_list, test_pass, false, false)
    }

    fn run_exp_if
    (
        sh: &mut shell::Shell,
        pair_if: Pair<Rule>,
        args: &Vec<String>,
        in_loop: bool,
        capture: bool
    ) -> (Vec<CommandResult>, bool, bool
    )
    {
        let mut cr_list = Vec::new();
        let pairs = pair_if.into_inner();
        let mut met_continue = false;
        let mut met_break = false;
        for pair in pairs {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair, args, in_loop, capture);
            met_continue = _cont;
            met_break = _brk;
            cr_list.append(&mut _cr_list);
            // break at first successful branch
            if passed {
                break;
            }
        }
        (cr_list, met_continue, met_break)
    }

    fn get_for_result_from_init
    (
        sh: &mut shell::Shell,
        pair_init: Pair<Rule>,
        args: &[String]
    ) -> Vec<String>
    {
        let mut result: Vec<String> = Vec::new();
        let pairs = pair_init.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == Rule::TEST {
                let line = pair.as_str().trim();
                let tokens = expand_line_to_toknes(line, &args[1..], sh);
                for (sep, token) in tokens {
                    if sep.is_empty() {
                        for x in token.split_whitespace() {
                            result.push(x.to_string());
                        }
                    } else {
                        result.push(token.clone());
                    }
                }
            }
        }
        result
    }

    fn get_for_result_list
    (
        sh: &mut shell::Shell,
        pair_head: Pair<Rule>,
        args: &[String]
    ) -> Vec<String>
    {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == Rule::FOR_INIT {
                return get_for_result_from_init(sh, pair, args);
            }
        }
        Vec::new()
    }

    fn get_for_var_name(pair_head: Pair<Rule>) -> String
    {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == Rule::FOR_INIT {
                let pairs_init = pair.into_inner();
                for pair_init in pairs_init {
                    let rule_init = pair_init.as_rule();
                    if rule_init == Rule::FOR_VAR {
                        let line = pair_init.as_str().trim();
                        return line.to_string();
                    }
                }
            }
        }
        String::new()
    }

    fn run_exp_for
    (
        sh: &mut shell::Shell, 
        pair_for: Pair<Rule>, 
        args: &Vec<String>, 
        capture: bool
    ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let pairs = pair_for.into_inner();
        let mut result_list: Vec<String> = Vec::new();
        let mut var_name: String = String::new();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == Rule::FOR_HEAD {
                var_name = get_for_var_name(pair.clone());
                result_list = get_for_result_list(sh, pair.clone(), args);
                continue;
            }
            if rule == Rule::EXP_BODY {
                for value in &result_list {
                    sh.set_env(&var_name, value);
                    let (mut _cr_list, _cont, _brk) = run_exp(
                        sh, pair.clone(), args, true, capture);
                    cr_list.append(&mut _cr_list);
                    if _brk {
                        break;
                    }
                }
            }
        }
        cr_list
    }

    fn run_exp_while
    (
        sh: &mut shell::Shell, 
        pair_while: Pair<Rule>, 
        args: &Vec<String>, 
        capture: bool
    ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        loop {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair_while.clone(), args, true, capture);
            cr_list.append(&mut _cr_list);
            if !passed || _brk {
                break;
            }
        }
        cr_list
    }

    fn run_exp
    (
        sh: &mut shell::Shell,
        pair_in: Pair<Rule>,
        args: &Vec<String>,
        in_loop: bool,
        capture: bool
    ) -> (Vec<CommandResult>, bool, bool)
    {
        let mut cr_list = Vec::new();
        let pairs = pair_in.into_inner();
        
        for pair in pairs
        {
            let line = pair.as_str().trim();
            if line.is_empty() { continue; }

            let rule = pair.as_rule();
            
            if rule == Rule::CMD
            {
                if line == "continue"
                {
                    if in_loop { return (cr_list, true, false); }
                    
                    else
                    {
                        println_stderr!("cicada: continue: only meaningful in loops");
                        continue;
                    }
                }
                
                if line == "break" {
                    if in_loop {
                        return (cr_list, false, true);
                    } else {
                        println_stderr!("cicada: break: only meaningful in loops");
                        continue;
                    }
                }

                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = now::run_command_line(sh, &line_new, true, capture);
                cr_list.append(&mut _cr_list);
                if let Some(last) = cr_list.last() {
                    let status = last.status;
                    if status != 0 && sh.exit_on_error {
                        return (cr_list, false, false);
                    }
                }
            } else if rule == Rule::EXP_IF {
                let (mut _cr_list, _cont, _brk) = run_exp_if(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                if _cont {
                    return (cr_list, true, false);
                }
                if _brk {
                    return (cr_list, false, true);
                }
            } else if rule == Rule::EXP_FOR {
                let mut _cr_list = run_exp_for(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            } else if rule == Rule::EXP_WHILE {
                let mut _cr_list = run_exp_while(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            }
        }

        (cr_list, false, false)
    }
}

pub mod shell
{
    use ::
    {
        collections::{ HashMap, HashSet },
        error::no::{ errno },
        fs::{ File },
        io::{ Write },
        nix::libc::{ * },
        regex::{ * },
        types::{ * },
        *,
    };

    #[derive(Debug, Clone)]
    pub struct Shell 
    {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }

    impl Shell 
    {
        pub fn new() -> Shell 
        {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = path::get_current_dir();
            let has_terminal = proc_has_terminal();
            let (session_id, _) = uuid.split_at(13);
            Shell
            {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }

        pub fn insert_job(&mut self, gid: i32, pid: i32, cmd: &str, status: &str, bg: bool) 
        {
            let mut i = 1;
            loop {
                let mut indexed_job_missing = false;
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.pids.push(pid);
                        x.cmd = format!("{} | {}", x.cmd, cmd);
                        return;
                    }
                } else {
                    indexed_job_missing = true;
                }

                if indexed_job_missing {
                    self.jobs.insert(
                        i,
                        types::Job {
                            cmd: cmd.to_string(),
                            id: i,
                            gid,
                            pids: vec![pid],
                            pids_stopped: HashSet::new(),
                            status: status.to_string(),
                            is_bg: bg,
                        },
                    );
                    return;
                }
                i += 1;
            }
        }

        pub fn get_job_by_id(&self, job_id: i32) -> Option<&types::Job> { self.jobs.get(&job_id) }

        pub fn mark_job_member_continued(&mut self, pid: i32, gid: i32) -> Option<&types::Job>
        {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.remove(&pid);
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get(&idx_found)
        }

        pub fn mark_job_member_stopped(&mut self, pid: i32, gid: i32) -> Option<&types::Job>
        {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.insert(pid);
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get(&idx_found)
        }

        pub fn get_job_by_gid(&self, gid: i32) -> Option<&types::Job> 
        {
            if self.jobs.is_empty() {
                return None;
            }

            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get(&i) {
                    if x.gid == gid {
                        return Some(x);
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
            None
        }

        pub fn mark_job_as_running(&mut self, gid: i32, bg: bool) 
        {
            if self.jobs.is_empty() {
                return;
            }

            let mut i = 1;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.status = "Running".to_string();
                        job.pids_stopped.clear();
                        job.is_bg = bg;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn mark_job_as_stopped(&mut self, gid: i32) 
        {
            if self.jobs.is_empty() {
                return;
            }

            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.status = "Stopped".to_string();
                        x.is_bg = true;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn remove_pid_from_job(&mut self, gid: i32, pid: i32) -> Option<types::Job> 
        {
            if self.jobs.is_empty() {
                return None;
            }

            let mut empty_pids = false;
            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        if let Ok(i_pid) = x.pids.binary_search(&pid) {
                            x.pids.remove(i_pid);
                        }
                        empty_pids = x.pids.is_empty();
                        break;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            if empty_pids {
                return self.jobs.remove(&i);
            }
            None
        }
        /// Update existing *ENV Variable* if such name exists in ENVs,
        /// otherwise, we define a local *Shell Variable*, which would not be exported into child processes.
        pub fn set_env(&mut self, name: &str, value: &str) 
        {
            if env::var(name).is_ok() {
                env::set_var(name, value);
            } else {
                self.envs.insert(name.to_string(), value.to_string());
            }
        }
        /// get *Shell Variable*, or *ENV Variable*.
        pub fn get_env(&self, name: &str) -> Option<String> 
        {
            match self.envs.get(name) 
            {
                Some(x) => Some(x.to_string()),
                None => {
                    match env::var(name) {
                        Ok(x) => Some(x),
                        Err(_) => None,
                    }
                }
            }
        }
        /// Remove environment variable, function from the environment of the currently running process
        pub fn remove_env(&mut self, name: &str) -> bool
        {
            let ptn_env = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_-]*$").unwrap();
            if !ptn_env.is_match(name) {
                return false;
            }

            env::remove_var(name);
            self.envs.remove(name);
            self.remove_func(name);
            true
        }

        pub fn remove_path(&mut self, path: &str)
        {
            if let Ok(paths) = env::var("PATH")
            {
                let mut paths_new: Vec<&str> = paths.split(":").collect();
                paths_new.retain(|&x| x != path);
                env::set_var("PATH", paths_new.join(":").as_str());
            }
        }

        fn remove_func(&mut self, name: &str)
        { self.funcs.remove(name); }

        pub fn set_func(&mut self, name: &str, value: &str)
        { self.funcs.insert(name.to_string(), value.to_string()); }

        pub fn get_func(&self, name: &str) -> Option<String> { self.funcs.get(name).map(|x| x.to_string()) }

        pub fn get_alias_list(&self) -> Vec<(String, String)>
        {
            let mut result = Vec::new();
            for (name, value) in &self.aliases 
            {
                result.push((name.clone(), value.clone()));
            }
            result
        }

        pub fn add_alias(&mut self, name: &str, value: &str)
        { self.aliases.insert(name.to_string(), value.to_string()); }

        pub fn is_alias(&self, name: &str) -> bool { self.aliases.contains_key(name) }

        pub fn remove_alias(&mut self, name: &str) -> bool 
        {
            let opt = self.aliases.remove(name);
            opt.is_some()
        }

        pub fn get_alias_content(&self, name: &str) -> Option<String> 
        {
            let result = match self.aliases.get(name) {
                Some(x) => x.to_string(),
                None => String::new(),
            };
            if result.is_empty() {
                None
            } else {
                Some(result)
            }
        }
    }

    pub unsafe fn give_terminal_to(gid: i32) -> bool 
    {
        let mut mask: sigset_t = mem::zeroed();
        let mut old_mask: sigset_t = mem::zeroed();
        sigemptyset(&mut mask);
        sigaddset(&mut mask, SIGTSTP);
        sigaddset(&mut mask, SIGTTIN);
        sigaddset(&mut mask, SIGTTOU);
        sigaddset(&mut mask, SIGCHLD);

        let rcode = pthread_sigmask( nix::libc::SIG_BLOCK, &mask, &mut old_mask );
        
        if rcode != 0
        {
            log!("failed to call pthread_sigmask");
        }
        
        let rcode = tcsetpgrp(1, gid);
        let given;
        
        if rcode == -1
        {
            given = false;
            let e = errno();
            let code = e.0;
            log!("error in give_terminal_to() {}: {}", code, e);
        }
        
        else
        {
            given = true;
        }
        
        let rcode = pthread_sigmask( SIG_SETMASK, &old_mask, &mut mask);
        
        if rcode != 0
        {
            log!("failed to call pthread_sigmask");
        }

        given
    }

    pub fn needs_globbing(line: &str) -> bool 
    {
        let re = Regex::new(r"\*+").expect("Invalid regex ptn");
        re.is_match(line)
    }

    pub fn expand_glob(tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !needs_globbing(text) {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();

            if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"') {
                result.push(item.to_string());
            } else {
                let _basename = ::path::basename(item);
                let show_hidden = _basename.starts_with(".*");

                match glob::glob(item) {
                    Ok(paths) => {
                        let mut is_empty = true;
                        for entry in paths {
                            match entry {
                                Ok(path) => {
                                    let file_path = path.to_string_lossy();
                                    let _basename = ::path::basename(&file_path);
                                    if _basename == ".." || _basename == "." {
                                        continue;
                                    }
                                    if _basename.starts_with('.') && !show_hidden {
                                        continue;
                                    }
                                    result.push(file_path.to_string());
                                    is_empty = false;
                                }
                                Err(e) => {
                                    log!("glob error: {:?}", e);
                                }
                            }
                        }
                        if is_empty {
                            result.push(item.to_string());
                        }
                    }
                    Err(e) => {
                        println!("glob error: {:?}", e);
                        result.push(item.to_string());
                        return;
                    }
                }
            }

            buff.push((idx, result));
            idx += 1;
        }

        for (i, result) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in result.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    pub fn expand_one_env(sh: &Shell, token: &str) -> String 
    {
        let re1 = Regex::new(r"^(.*?)\$([A-Za-z0-9_]+|\$|\?)(.*)$").unwrap();
        let re2 = Regex::new(r"(.*?)\$\{([A-Za-z0-9_]+|\$|\?)\}(.*)$").unwrap();
        if !re1.is_match(token) && !re2.is_match(token) {
            return token.to_string();
        }

        let mut result = String::new();
        let match_re1 = re1.is_match(token);
        let match_re2 = re2.is_match(token);
        if !match_re1 && !match_re2 {
            return token.to_string();
        }

        let cap_results = if match_re1 {
            re1.captures_iter(token)
        } else {
            re2.captures_iter(token)
        };

        for cap in cap_results {
            let head = cap[1].to_string();
            let tail = cap[3].to_string();
            let key = cap[2].to_string();
            if key == "?" {
                result.push_str(format!("{}{}", head, sh.previous_status).as_str());
            } else if key == "$" {
                unsafe {
                    let val = libc::getpid();
                    result.push_str(format!("{}{}", head, val).as_str());
                }
            } else if let Ok(val) = env::var(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else if let Some(val) = sh.get_env(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else {
                result.push_str(&head);
            }
            result.push_str(&tail);
        }

        result
    }

    pub fn need_expand_brace(line: &str) -> bool { contains(line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"#) }

    fn brace_getitem(s: &str, depth: i32) -> (Vec<String>, String)
    {
        let mut out: Vec<String> = vec![String::new()];
        let mut ss = s.to_string();
        let mut tmp;
        while !ss.is_empty() {
            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    return (out, ss);
                }
            };
            if depth > 0 && (c == ',' || c == '}') {
                return (out, ss);
            }
            if c == '{' {
                let mut sss = ss.clone();
                sss.remove(0);
                let result_groups = brace_getgroup(&sss, depth + 1);
                if let Some((out_group, s_group)) = result_groups {
                    let mut tmp_out = Vec::new();
                    for x in out.iter() {
                        for y in out_group.iter() {
                            let item = format!("{}{}", x, y);
                            tmp_out.push(item);
                        }
                    }
                    out = tmp_out;
                    ss = s_group.clone();
                    continue;
                }
            }
            
            if c == '\\' && ss.len() > 1 {
                ss.remove(0);
                let c;
                match ss.chars().next() {
                    Some(x) => c = x,
                    None => {
                        return (out, ss)
                    }
                }

                tmp = format!("\\{}", c);
            } else {
                tmp = c.to_string();
            }
            let mut result = Vec::new();
            for x in out.iter() {
                let item = format!("{}{}", x, tmp);
                result.push(item);
            }
            out = result;
            ss.remove(0);
        }
        (out, ss)
    }

    pub fn brace_getgroup(s: &str, depth: i32) -> Option<(Vec<String>, String)> 
    {
        let mut out: Vec<String> = Vec::new();
        let mut comma = false;
        let mut ss = s.to_string();
        while !ss.is_empty() {
            let (g, sss) = brace_getitem(ss.as_str(), depth);
            ss = sss.clone();
            if ss.is_empty() {
                break;
            }
            for x in g.iter() {
                out.push(x.clone());
            }

            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    break;
                }
            };
            if c == '}' {
                let mut sss = ss.clone();
                sss.remove(0);
                if comma {
                    return Some((out, sss));
                }
                let mut result = Vec::new();
                for x in out.iter() {
                    let item = format!("{{{}}}", x);
                    result.push(item);
                }
                return Some((result, ss));
            }
            if c == ',' {
                comma = true;
                ss.remove(0);
            }
        }

        None
    }

    pub fn expand_brace(tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !need_expand_brace(token) {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let items = brace_getitem(token, 0);
            for x in items.0 {
                result.push(x.clone());
            }
            buff.push((idx, result));
            idx += 1;
        }

        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    pub fn expand_brace_range(tokens: &mut Tokens)
    {
        let re;
        if let Ok(x) = Regex::new(r#"\{(-?[0-9]+)\.\.(-?[0-9]+)(\.\.)?([0-9]+)?\}"#) {
            re = x;
        } else {
            println_stderr!("cicada: re new error");
            return;
        }

        let mut idx: usize = 0;
        let mut buff: Vec<(usize, Vec<String>)> = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !re.is_match(token) {
                idx += 1;
                continue;
            }
            
            let caps = re.captures(token).unwrap();

            let start = match caps[1].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: {}", e);
                    return;
                }
            };

            let end = match caps[2].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: {}", e);
                    return;
                }
            };
            
            let mut incr = if caps.get(4).is_none() {
                1
            } else {
                match caps[4].to_string().parse::<i32>() {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        return;
                    }
                }
            };
            if incr <= 1 {
                incr = 1;
            }

            let mut result: Vec<String> = Vec::new();
            let mut n = start;
            if start > end {
                while n >= end {
                    result.push(format!("{}", n));
                    n -= incr;
                }
            } else {
                while n <= end {
                    result.push(format!("{}", n));
                    n += incr;
                }
            }

            buff.push((idx, result));
            idx += 1;
        }

        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }

    pub fn expand_alias(sh: &Shell, tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        let mut is_head = true;
        for (sep, text) in tokens.iter() {
            if sep.is_empty() && text == "|" {
                is_head = true;
                idx += 1;
                continue;
            }
            if is_head && text == "xargs" {
                idx += 1;
                continue;
            }

            if !is_head || !sh.is_alias(text) {
                idx += 1;
                is_head = false;
                continue;
            }

            if let Some(value) = sh.get_alias_content(text) {
                buff.push((idx, value.clone()));
            }

            idx += 1;
            is_head = false;
        }

        for (i, text) in buff.iter().rev() {
            let linfo = parsers::line::parse(text);
            let tokens_ = linfo.tokens;
            tokens.remove(*i);
            for item in tokens_.iter().rev() {
                tokens.insert(*i, item.clone());
            }
        }
    }

    pub fn expand_home(tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !text.starts_with("~") {
                idx += 1;
                continue;
            }

            let mut s: String = text.clone();
            let ptn = r"^~(?P<tail>.*)";
            let re = Regex::new(ptn).expect("invalid re ptn");
            let home = env::get_user_home();
            let ss = s.clone();
            let to = format!("{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();

            buff.push((idx, s.clone()));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    pub fn env_in_token(token: &str) -> bool 
    {
        if contains(token, r"\$\{?[\$\?]\}?") {
            return true;
        }

        let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
        let ptn_env = format!(r"\$\{{?{}\}}?", ptn_env_name);
        if !contains(token, &ptn_env) {
            return false;
        }
        
        let ptn_cmd_sub1 = format!(r"^{}=`.*`$", ptn_env_name);
        let ptn_cmd_sub2 = format!(r"^{}=\$\(.*\)$", ptn_env_name);
        if contains(token, &ptn_cmd_sub1)
            || contains(token, &ptn_cmd_sub2)
            || contains(token, r"^\$\(.+\)$")
        {
            return false;
        }
        
        let ptn_env = format!(r"='.*\$\{{?{}\}}?.*'$", ptn_env_name);
        !contains(token, &ptn_env)
    }

    pub fn expand_env(sh: &Shell, tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" {
                idx += 1;
                continue;
            }

            if !env_in_token(token) {
                idx += 1;
                continue;
            }

            let mut _token = token.clone();
            while env_in_token(&_token) {
                _token = expand_one_env(sh, &_token);
            }
            buff.push((idx, _token));
            idx += 1;
        }

        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }

    pub fn should_do_dollar_command_extension(line: &str) -> bool 
    {
        contains(line, r"\$\([^\)]+\)") &&
        !contains(line, r"='.*\$\([^\)]+\).*'$")
    }

    pub fn do_command_substitution_for_dollar(sh:&mut Shell, tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();

        for (sep, token) in tokens.iter() 
        {
            if sep == "'" || sep == "\\" || !should_do_dollar_command_extension(token) {
                idx += 1;
                continue;
            }

            let mut line = token.to_string();
            loop {
                if !should_do_dollar_command_extension(&line) {
                    break;
                }

                let ptn_cmd = r"\$\((.+)\)";
                let cmd = match find_first_group(ptn_cmd, &line) {
                    Some(x) => x,
                    None => {
                        println_stderr!("cicada: calculator: no first group");
                        return;
                    }
                };

                let cmd_result = match CommandLine::from_line(&cmd, sh) {
                    Ok(c) => {
                        log!("run subcmd dollar: {:?}", &cmd);
                        let (term_given, cr) = core::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }

                        cr
                    }
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        continue;
                    }
                };

                let output_txt = cmd_result.stdout.trim();

                let ptn = r"(?P<head>[^\$]*)\$\(.+\)(?P<tail>.*)";
                let re;
                if let Ok(x) = Regex::new(ptn) {
                    re = x;
                } else {
                    return;
                }

                let to = format!("${{head}}{}${{tail}}", output_txt);
                let line_ = line.clone();
                let result = re.replace(&line_, to.as_str());
                line = result.to_string();
            }

            buff.insert(idx, line.clone());
            idx += 1;
        }

        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }

    pub fn do_command_substitution_for_dot(sh:&mut Shell, tokens: &mut Tokens) 
    {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();
        for (sep, token) in tokens.iter() {
            let new_token: String;
            if sep == "`" {
                log!("run subcmd dot1: {:?}", token);
                let cr = match CommandLine::from_line(token, sh) {
                    Ok(c) => {
                        let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }

                        _cr
                    }
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        continue;
                    }
                };

                new_token = cr.stdout.trim().to_string();
            } else if sep == "\"" || sep.is_empty() {
                let re;
                if let Ok(x) = Regex::new(r"^([^`]*)`([^`]+)`(.*)$") {
                    re = x;
                } else {
                    println_stderr!("cicada: re new error");
                    return;
                }
                if !re.is_match(token) {
                    idx += 1;
                    continue;
                }
                let mut _token = token.clone();
                let mut _item = String::new();
                let mut _head = String::new();
                let mut _output = String::new();
                let mut _tail = String::new();
                loop {
                    if !re.is_match(&_token) {
                        if !_token.is_empty() {
                            _item = format!("{}{}", _item, _token);
                        }
                        break;
                    }
                    for cap in re.captures_iter(&_token) {
                        _head = cap[1].to_string();
                        _tail = cap[3].to_string();
                        log!("run subcmd dot2: {:?}", &cap[2]);

                        let cr = match CommandLine::from_line(&cap[2], sh) {
                            Ok(c) => {
                                let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
                                if term_given {
                                    unsafe {
                                        let gid = libc::getpgid(0);
                                        give_terminal_to(gid);
                                    }
                                }

                                _cr
                            }
                            Err(e) => {
                                println_stderr!("cicada: {}", e);
                                continue;
                            }
                        };

                        _output = cr.stdout.trim().to_string();
                    }
                    _item = format!("{}{}{}", _item, _head, _output);
                    if _tail.is_empty() {
                        break;
                    }
                    _token = _tail.clone();
                }
                new_token = _item;
            } else {
                idx += 1;
                continue;
            }

            buff.insert(idx, new_token.clone());
            idx += 1;
        }

        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }

    pub fn do_command_substitution(sh:&mut Shell, tokens: &mut Tokens) 
    {
        do_command_substitution_for_dot(sh, tokens);
        do_command_substitution_for_dollar(sh, tokens);
    }

    pub fn do_expansion( sh:&mut Shell, tokens: &mut Tokens )
    {
        // let line = parsers::line::tokens_to_line(tokens);
        let line = parsers::line::from_tokens( tokens );
        if is::arithmetic(&line)
        {
            return;
        }

        if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with("PROMPT=") { return; }

        expand_alias(sh, tokens);
        expand_home(tokens);
        expand_env(sh, tokens);
        expand_brace(tokens);
        expand_glob(tokens);
        do_command_substitution(sh, tokens);
        expand_brace_range(tokens);
    }

    pub fn trim_multiline_prompts(line: &str) -> String
    {
        let line_new = replace_all(line, r"\\\n>> ", "");
        let line_new = replace_all(&line_new, r"\| *\n>> ", "| ");
        replace_all(&line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE")
    }

    pub fn proc_has_terminal() -> bool 
    {
        unsafe 
        {
            let tgid = tcgetpgrp(0);
            let pgid = getpgid(0);
            tgid == pgid
        }
    }

    pub fn try_run_builtin_in_subprocess
    (
        sh:&mut Shell,
        cl:&CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<i32>
    {
        if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) { return Some(cr.status); }
        None
    }

    pub fn try_run_builtin
    (
        sh:&mut Shell,
        cl:&CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<CommandResult>
    {
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len()
        {
            println_stderr!("unexpected error in try_run_builtin");
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();

        match true
        {
            true if cname == "alias" =>
            {
                let cr = ::run::alias(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "bg" =>
            {
                let cr = ::run::bg(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "cd" =>
            {
                let cr = ::run::cd(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "cinfo" =>
            {
                let cr = ::run::cinfo(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "exec" =>
            {
                let cr = ::run::exec(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "exit" =>
            {
                let cr = ::run::exit(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "export" =>
            {
                let cr = ::run::export(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "fg" =>
            {
                let cr = ::run::fg(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "history" =>
            {
                let cr = ::run::history(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "jobs" =>
            {
                let cr = ::run::jobs(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "minfd" =>
            {
                let cr = ::run::minfd(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "read" =>
            {
                let cr = ::run::read(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "set" =>
            {
                let cr = ::run::set(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "source" =>
            {
                let cr = ::run::source(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "ulimit" =>
            {
                let cr = ::run::ulimit(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "unalias" =>
            {
                let cr = ::run::unalias(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "unset" =>
            {
                let cr = ::run::unset(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "unpath" =>
            {
                let cr = ::run::unpath(sh, cl, cmd, capture);
                return Some(cr);
            }
            
            true if cname == "vox" =>
            {
                let cr = ::run::vox(sh, cl, cmd, capture);
                return Some(cr);
            }

            unknown => None,
        }
    }
    /// Run a pipeline (e.g. `echo hi | wc -l`) | returns: (is-terminal-given, command-result)
    pub fn pipeline
    (
        sh: &mut shell::Shell,
        cl:&CommandLine,
        tty: bool,
        capture: bool,
        log_cmd: bool,
    ) -> (bool, CommandResult)
    {
        let mut term_given = false;
        if cl.background && capture {
            println_stderr!("cicada: cannot capture output of background cmd");
            return (term_given, CommandResult::error());
        }

        if let Some(cr) = try_run_calculator(&cl.line, capture) {
            return (term_given, cr);
        }
        
        if let Some(cr) = try_run_func(sh, cl, capture, log_cmd) {
            return (term_given, cr);
        }

        if log_cmd {
            log!("run: {}", cl.line);
        }

        let length = cl.commands.len();
        if length == 0 {
            println!("cicada: invalid command: cmds with empty length");
            return (false, CommandResult::error());
        }

        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1 {
            match pipe() {
                Ok(fds) => pipes.push(fds),
                Err(e) => {
                    errored_pipes = true;
                    println_stderr!("cicada: pipeline1: {}", e);
                    break;
                }
            }
        }

        if errored_pipes
        {
            for fds in pipes
            {
                process::close(fds.0);
                process::close(fds.1);
            }

            return (false, CommandResult::error());
        }

        if pipes.len() + 1 != length {
            println!("cicada: invalid command: unmatched pipes count");
            return (false, CommandResult::error());
        }

        let mut pgid: i32 = 0;
        let mut fg_pids: Vec<i32> = Vec::new();

        let isatty = if tty {
            unsafe { libc::isatty(1) == 1 }
        } else {
            false
        };
        let options = CommandOptions {
            isatty,
            capture_output: capture,
            background: cl.background,
            envs: cl.envs.clone(),
        };

        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture {
            match pipe() {
                Ok(fds) => fds_capture_stdout = Some(fds),
                Err(e) => {
                    println_stderr!("cicada: pipeline2: {}", e);
                    return (false, CommandResult::error());
                }
            }
            match pipe() {
                Ok(fds) => fds_capture_stderr = Some(fds),
                Err(e) => {
                    if let Some(fds) = fds_capture_stdout {
                        process::close(fds.0);
                        process::close(fds.1);
                    }
                    println_stderr!("cicada: pipeline3: {}", e);
                    return (false, CommandResult::error());
                }
            }
        }

        let mut cmd_result = CommandResult::new();
        for i in 0..length {
            let child_id: i32 = run_single_program(
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );

            if child_id > 0 && !cl.background {
                fg_pids.push(child_id);
            }
        }

        if cl.is_single_and_builtin() {
            return (false, cmd_result);
        }

        if cl.background {
            if let Some(job) = sh.get_job_by_gid(pgid) {
                println_stderr!("[{}] {}", job.id, job.gid);
            }
        }

        if !fg_pids.is_empty() {
            let _cr = libc::jobs::wait_fg_job(sh, pgid, &fg_pids);
            
            if !capture {
                cmd_result = _cr;
            }
        }
        (term_given, cmd_result)
    }
    /// Run a single command. | `sort -k2` part of `ps ax | sort -k2 | head`
    pub fn run_single_program
    (
        sh: &mut shell::Shell,
        cl:&CommandLine,
        idx_cmd: usize,
        options: &CommandOptions,
        pgid: &mut i32,
        term_given: &mut bool,
        cmd_result: &mut CommandResult,
        pipes: &[(RawFd, RawFd)],
        fds_capture_stdout: &Option<(RawFd, RawFd)>,
        fds_capture_stderr: &Option<(RawFd, RawFd)>,
    ) -> i32
    {
        let capture = options.capture_output;
        
        if cl.is_single_and_builtin()
        {
            if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
                *cmd_result = cr;
                return unsafe { libc::getpid() };
            }

            println_stderr!("cicada: error when run singler builtin");
            log!("error when run singler builtin: {:?}", cl);
            return 1;
        }

        let pipes_count = pipes.len();
        let mut fds_stdin = None;
        let cmd = cl.commands.get(idx_cmd).unwrap();

        if cmd.has_here_string()
        {
            match pipe() {
                Ok(fds) => fds_stdin = Some(fds),
                Err(e) => {
                    println_stderr!("cicada: pipeline4: {}", e);
                    return 1;
                }
            }
        }

        match process::fork()
        {
            Ok(ForkResult::Child) =>
            {
                unsafe
                {
                    libc::signal(libc::SIGTSTP, libc::SIG_DFL);
                    libc::signal(libc::SIGQUIT, libc::SIG_DFL);
                }
                
                if idx_cmd > 0
                {
                    for i in 0..idx_cmd - 1
                    {
                        let fds = pipes[i];
                        process::close(fds.0);
                        process::close(fds.1);
                    }
                }
                
                for i in idx_cmd + 1..pipes_count
                {
                    let fds = pipes[i];
                    process::close(fds.0);
                    process::close(fds.1);
                }
                
                if idx_cmd < pipes_count
                {
                    if let Some(fds) = fds_capture_stdout
                    {
                        process::close(fds.0);
                        process::close(fds.1);
                    }
                    
                    if let Some(fds) = fds_capture_stderr
                    {
                        process::close(fds.0);
                        process::close(fds.1);
                    }
                }

                if idx_cmd == 0
                {
                    unsafe
                    {
                        let pid = libc::getpid();
                        libc::setpgid(0, pid);
                    }
                }

                else
                {
                    unsafe
                    {
                        libc::setpgid(0, *pgid);
                    }
                }
                
                if idx_cmd > 0
                {
                    let fds_prev = pipes[idx_cmd - 1];
                    process::dup2(fds_prev.0, 0);
                    process::close(fds_prev.0);
                    process::close(fds_prev.1);
                }
                
                if idx_cmd < pipes_count
                {
                    let fds = pipes[idx_cmd];
                    process::dup2(fds.1, 1);
                    process::close(fds.1);
                    process::close(fds.0);
                }

                if cmd.has_redirect_from()
                {
                    if let Some(redirect_from) = &cmd.redirect_from
                    {
                        let fd = os::fd::get_from_file(&redirect_from.clone().1);
                        if fd == -1 {
                            process::exit(1);
                        }

                        process::dup2(fd, 0);
                        process::close(fd);
                    }
                }

                if cmd.has_here_string()
                {
                    if let Some(fds) = fds_stdin
                    {
                        process::close(fds.1);
                        process::dup2(fds.0, 0);
                        process::close(fds.0);
                    }
                }

                let mut stdout_redirected = false;
                let mut stderr_redirected = false;
                for item in &cmd.redirects_to
                {
                    let from_ = &item.0;
                    let op_ = &item.1;
                    let to_ = &item.2;

                    if to_ == "&1" && from_ == "2"
                    {
                        if idx_cmd < pipes_count
                        {
                            process::dup2(1, 2);
                        }
                        
                        else if !options.capture_output
                        {
                            let fd = process::dup(1);
                            
                            if fd == -1
                            {
                                println_stderr!("cicada: dup error");
                                process::exit(1);
                            }

                            process::dup2(fd, 2);
                        }
                        else { }
                    }
                    
                    else if to_ == "&2" && from_ == "1"
                    {
                        if idx_cmd < pipes_count || !options.capture_output
                        {
                            let fd = process::dup(2);
                            if fd == -1
                            {
                                println_stderr!("cicada: dup error");
                                process::exit(1);
                            }

                            process::dup2(fd, 1);
                        }
                        else { }
                    }

                    else
                    {
                        let append = op_ == ">>";

                        match os::fd::create_raw_from_file(to_, append)
                        {
                            Ok(fd) =>
                            {
                                if fd == -1
                                {
                                    println_stderr!("cicada: fork: fd error");
                                    process::exit(1);
                                }

                                if from_ == "1"
                                {
                                    process::dup2(fd, 1);
                                    stdout_redirected = true;
                                }
                                
                                else
                                {
                                    process::dup2(fd, 2);
                                    stderr_redirected = true;
                                }
                            }

                            Err(e) =>
                            {
                                println_stderr!("cicada: fork: {}", e);
                                process::exit(1);
                            }
                        }
                    }
                }
                
                if idx_cmd == pipes_count && options.capture_output {
                    if !stdout_redirected {
                        if let Some(fds) = fds_capture_stdout {
                            process::close(fds.0);
                            process::dup2(fds.1, 1);
                            process::close(fds.1);
                        }
                    }
                    if !stderr_redirected {
                        if let Some(fds) = fds_capture_stderr {
                            process::close(fds.0);
                            process::dup2(fds.1, 2);
                            process::close(fds.1);
                        }
                    }
                }

                if cmd.is_builtin() {
                    if let Some(status) = try_run_builtin_in_subprocess(sh, cl, idx_cmd, capture) {
                        process::exit(status);
                    }
                }
                
                let mut c_envs: Vec<_> = env::vars()
                    .map(|(k, v)| {
                        CString::new(format!("{}={}", k, v).as_str()).expect("CString error")
                    })
                    .collect();
                for (key, value) in cl.envs.iter() {
                    c_envs.push(
                        CString::new(format!("{}={}", key, value).as_str()).expect("CString error"),
                    );
                }

                let program = &cmd.tokens[0].1;
                
                let path = if program.contains('/'){ program.clone() } 
                else { path::find_file_in_path(program, true) };

                if path.is_empty()
                {
                    println_stderr!("cicada: {}: command not found", program);
                    process::exit(127);
                }

                let c_program = CString::new(path.as_str()).expect("CString::new failed");
                let c_args: Vec<_> = cmd
                .tokens
                .iter()
                .map(|x| CString::new(x.1.as_str()).expect("CString error"))
                .collect();

                let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str()).collect();
                let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str()).collect();
                match execve(&c_program, &c_args, &c_envs) {
                    Ok(_) => {}
                    Err(e) => match e {
                        nix::Error::ENOEXEC => {
                            println_stderr!("cicada: {}: exec format error (ENOEXEC)", program);
                        }
                        nix::Error::ENOENT => {
                            println_stderr!("cicada: {}: file does not exist", program);
                        }
                        nix::Error::EACCES => {
                            println_stderr!("cicada: {}: Permission denied", program);
                        }
                        _ => {
                            println_stderr!("cicada: {}: {:?}", program, e);
                        }
                    },
                }

                process::exit(1);
            }

            Ok(ForkResult::Parent { child, .. }) =>
            {
                let pid: i32 = child.into();
                if idx_cmd == 0 {
                    *pgid = pid;
                    unsafe {
                        if cfg!(target_os = "macos") {
                            loop {
                                let _pgid = libc::getpgid(pid);
                                if _pgid == pid {
                                    break;
                                }
                            }
                        }

                        if sh.has_terminal
                            && options.isatty
                            && !cl.background
                        {
                            *term_given = shell::give_terminal_to(pid);
                        }
                    }
                }

                if options.isatty && !options.capture_output {
                    let _cmd = parsers::line::tokens_to_line(&cmd.tokens);
                    sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background);
                }

                if let Some(redirect_from) = &cmd.redirect_from {
                    if redirect_from.0 == "<<<" {
                        if let Some(fds) = fds_stdin {
                            unsafe {
                                process::close(fds.0);

                                let mut f = File::from_raw_fd(fds.1);
                                match f.write_all(redirect_from.1.clone().as_bytes()) {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!("cicada: write_all: {}", e),
                                }
                                match f.write_all(b"\n") {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!("cicada: write_all: {}", e),
                                }
                            }
                        }
                    }
                }
                
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    process::close(fds.1);
                }
                if idx_cmd > 0 {
                    let fds = pipes[idx_cmd - 1];
                    process::close(fds.0);
                }

                if idx_cmd == pipes_count && options.capture_output {
                    let mut s_out = String::new();
                    let mut s_err = String::new();

                    unsafe {
                        if let Some(fds) = fds_capture_stdout {
                            process::close(fds.1);

                            let mut f = File::from_raw_fd(fds.0);
                            match f.read_to_string(&mut s_out) {
                                Ok(_) => {}
                                Err(e) => println_stderr!("cicada: readstr: {}", e),
                            }
                        }
                        if let Some(fds) = fds_capture_stderr {
                            process::close(fds.1);
                            let mut f_err = File::from_raw_fd(fds.0);
                            match f_err.read_to_string(&mut s_err) {
                                Ok(_) => {}
                                Err(e) => println_stderr!("cicada: readstr: {}", e),
                            }
                        }
                    }

                    *cmd_result = CommandResult {
                        gid: *pgid,
                        status: 0,
                        stdout: s_out.clone(),
                        stderr: s_err.clone(),
                    };
                }

                pid
            }

            Err(_) =>
            {
                println_stderr!("Fork failed");
                *cmd_result = CommandResult::error();
                0
            }
        }
    }

    pub fn try_run_func
    (
        sh:&mut Shell,
        cl:&CommandLine,
        capture: bool,
        log_cmd: bool,
    ) -> Option<CommandResult> 
    {
        if cl.is_empty() {
            return None;
        }

        let command = &cl.commands[0];
        if let Some(func_body) = sh.get_func(&command.tokens[0].1) {
            let mut args = vec!["cicada".to_string()];
            for token in &command.tokens {
                args.push(token.1.to_string());
            }
            if log_cmd {
                log!("run func: {:?}", &args);
            }
            let cr_list = scripts::run_lines(sh, &func_body, &args, capture);
            let mut stdout = String::new();
            let mut stderr = String::new();
            for cr in cr_list {
                stdout.push_str(cr.stdout.trim());
                stdout.push(' ');
                stderr.push_str(cr.stderr.trim());
                stderr.push(' ');
            }
            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some(cr);
        }
        None
    }

    pub fn try_run_calculator(line: &str, capture: bool) -> Option<CommandResult> 
    {
        /* if tools::is_arithmetic(line) {
            match run_calculator(line) {
                Ok(result) => {
                    let mut cr = CommandResult::new();
                    if capture {
                        cr.stdout = result.clone();
                    } else {
                        println!("{}", result);
                    }
                    return Some(cr);
                }
                Err(e) => {
                    let mut cr = CommandResult::from_status(0, 1);
                    if capture {
                        cr.stderr = e.to_string();
                    } else {
                        println_stderr!("cicada: calculator: {}", e);
                    }
                    return Some(cr);
                }
            }
        } */
        None
    }

    pub fn calculator(line: &str) -> Result<String, &str>
    {
        Ok( String::new() )
        /* let parse_result = calculator::calculate(line);
        match parse_result {
            Ok(mut calc) => {
                let expr = calc.next().unwrap().into_inner();

                if line.contains('.') {
                    Ok(format!("{}", calculator::eval_float(expr)))
                } else {
                    Ok(format!("{}", calculator::eval_int(expr)))
                }
            }
            Err(_) => {
                Err("syntax error")
            }
        } */
    }
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };    
    use ::
    {
        borrow::{ Borrow, BorrowMut, Cow },
        boxed::{ Box },
        cmp::{ Ordering },
        fs::{ File },
        hash::{Hash, Hasher},
        iter::{ FromIterator },
        io::{ self, Read, Write },
        string::{ String },
        vec::{ Array, SmallVec, smallvec },
        *,
    };
    /* smallstr v0.3.0 */
    use std::ffi::{OsStr, OsString};

    pub trait Tokenizes
    {
        fn tokenize( &self ) -> String;
    }

    impl Tokenizes for &str
    {
        fn tokenize( &self ) -> String
        {
            // let args = parsers::line::line_to_plain_tokens(s);
            let args = parsers::line::to_plain_tokens( self.clone() );

            if args.is_empty() { return String::new(); }

            args[0].clone()
        }
    }

    /// A `String`-like container that can store a small number of bytes inline.
    #[derive(Clone, Default)]
    pub struct SmallString<A: Array<Item = u8>>
    {
        data: SmallVec<A>,
    }

    impl<A: Array<Item = u8>> SmallString<A>
    {
        /// Construct an empty string.
        #[inline] pub fn new() -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::new(),
            }
        }
        /// Construct an empty string with enough capacity pre-allocated to store  at least `n` bytes.
        #[inline] pub fn with_capacity(n: usize) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::with_capacity(n),
            }
        }
        /// Construct a `SmallString` by copying data from a `&str`.
        #[inline] pub fn from_str(s: &str) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_slice(s.as_bytes()),
            }
        }
        /// Construct a `SmallString` by using an existing allocation.
        #[inline] pub fn from_string(s: String) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_vec(s.into_bytes()),
            }
        }
        /// Constructs a new `SmallString` on the stack using UTF-8 bytes.
        #[inline] pub fn from_buf(buf: A) -> Result<SmallString<A>, FromUtf8Error<A>>
        {
            let data = SmallVec::from_buf(buf);

            match str::from_utf8(&data)
            {
                Ok(_) => Ok(SmallString { data }),
                Err(error) =>
                {
                    let buf = data.into_inner().ok().unwrap();

                    Err(FromUtf8Error { buf, error })
                }
            }
        }
        /// Constructs a new `SmallString` on the stack using the provided byte array
        /// without checking that the array contains valid UTF-8.
        #[inline] pub unsafe fn from_buf_unchecked(buf: A) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_buf(buf),
            }
        }
        /// The maximum number of bytes this string can hold inline.
        #[inline] pub fn inline_size(&self) -> usize { A::size() }
        /// Returns the length of this string, in bytes.
        #[inline] pub fn len(&self) -> usize { self.data.len() }
        /// Returns `true` if this string is empty.
        #[inline] pub fn is_empty(&self) -> bool { self.data.is_empty() }
        /// Returns the number of bytes this string can hold without reallocating.
        #[inline] pub fn capacity(&self) -> usize { self.data.capacity() }
        /// Returns `true` if the data has spilled into a separate heap-allocated buffer.
        #[inline] pub fn spilled(&self) -> bool { self.data.spilled() }
        /// Empties the string and returns an iterator over its former contents.
        pub fn drain(&mut self) -> Drain
        {
            unsafe
            {
                let len = self.len();
                self.data.set_len(0);
                let ptr = self.as_ptr();
                let slice = slice::from_raw_parts(ptr, len);
                let s = str::from_utf8_unchecked(slice);
                Drain { iter: s.chars() }
            }
        }
        /// Appends the given `char` to the end of this string.
        #[inline] pub fn push(&mut self, ch: char)
        {
            match ch.len_utf8()
            {
                1 => self.data.push(ch as u8),
                _ => self.push_str(ch.encode_utf8(&mut [0; 4])),
            }
        }
        /// Appends the given string slice to the end of this string.
        #[inline] pub fn push_str(&mut self, s: &str)
        {
            self.data.extend_from_slice(s.as_bytes());
        }
        /// Removes the last character from this string and returns it.
        #[inline] pub fn pop(&mut self) -> Option<char>
        {
            match self.chars().next_back()
            {
                Some(ch) => unsafe
                {
                    let new_len = self.len() - ch.len_utf8();
                    self.data.set_len(new_len);
                    Some(ch)
                },
                None => None,
            }
        }
        /// Reallocates to set the new capacity to `new_cap`.
        #[inline] pub fn grow(&mut self, new_cap: usize) { self.data.grow(new_cap); }
        /// Ensures that this string's capacity is at least `additional` bytes larger than its length.
        #[inline] pub fn reserve(&mut self, additional: usize) { self.data.reserve(additional); }
        /// Ensures that this string's capacity is `additional` bytes larger than its length.
        #[inline] pub fn reserve_exact(&mut self, additional: usize) { self.data.reserve(additional); }
        /// Shrink the capacity of the string as much as possible.
        #[inline] pub fn shrink_to_fit(&mut self) { self.data.shrink_to_fit(); }
        /// Shorten the string, keeping the first `len` bytes.
        #[inline] pub fn truncate(&mut self, len: usize)
        {
            assert!(self.is_char_boundary(len));
            self.data.truncate(len);
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_str(&self) -> &str
        {
            self
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_mut_str(&mut self) -> &mut str
        {
            self
        }
        /// Removes all contents of the string.
        #[inline] pub fn clear(&mut self)
        {
            self.data.clear();
        }
        /// Removes a `char` from this string at a byte position and returns it.
        #[inline] pub fn remove(&mut self, idx: usize) -> char
        {
            unsafe
            {
                let ch = match self[idx..].chars().next()
                {
                    Some(ch) => ch,
                    None => panic!("cannot remove a char from the end of a string"),
                };

                let ch_len = ch.len_utf8();
                let next = idx + ch_len;
                let len = self.len();
                ptr::copy
                (
                    self.as_ptr().add(next),
                    self.as_mut_ptr().add(idx),
                    len - next,
                );
                self.data.set_len(len - ch_len);
                ch
            }
        }
        /// Inserts a `char` into this string at the given byte position.
        #[inline] pub fn insert(&mut self, idx: usize, ch: char)
        {
            assert!(self.is_char_boundary(idx));

            match ch.len_utf8()
            {
                1 => self.data.insert(idx, ch as u8),
                _ => self.insert_str(idx, ch.encode_utf8(&mut [0; 4])),
            }
        }
        /// Inserts a `&str` into this string at the given byte position.
        #[inline] pub fn insert_str(&mut self, idx: usize, s: &str)
        {
            unsafe
            {
                assert!(self.is_char_boundary(idx));
                let len = self.len();
                let amt = s.len();
                self.data.reserve(amt);
                ptr::copy
                (
                    self.as_ptr().add(idx),
                    self.as_mut_ptr().add(idx + amt),
                    len - idx,
                );
                ptr::copy_nonoverlapping(s.as_ptr(), self.as_mut_ptr().add(idx), amt);
                self.data.set_len(len + amt);
            }
        }
        /// Returns a mutable reference to the contents of the `SmallString`.
        #[inline] pub unsafe fn as_mut_vec(&mut self) -> &mut SmallVec<A> { &mut self.data }
        /// Converts the `SmallString` into a `String`, without reallocating if the
        /// `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_string(self) -> String { unsafe { String::from_utf8_unchecked(self.data.into_vec()) } }
        /// Converts the `SmallString` into a `Box<str>`, without reallocating if the
        /// `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_boxed_str(self) -> Box<str> { self.into_string().into_boxed_str() }
        /// Convert the `SmallString` into `A`, if possible. Otherwise, return `Err(self)`.
        #[inline] pub fn into_inner(self) -> Result<A, Self> 
        { self.data.into_inner().map_err(|data| SmallString { data }) }
        /// Retains only the characters specified by the predicate.
        #[inline] pub fn retain<F: FnMut(char) -> bool>(&mut self, mut f: F)
        {
            struct SetLenOnDrop<'a, A: Array<Item = u8>>
            {
                s: &'a mut SmallString<A>,
                idx: usize,
                del_bytes: usize,
            }

            impl<'a, A: Array<Item = u8>> Drop for SetLenOnDrop<'a, A>
            {
                fn drop(&mut self)
                {
                    let new_len = self.idx - self.del_bytes;
                    debug_assert!(new_len <= self.s.len());
                    unsafe { self.s.data.set_len(new_len) };
                }
            }

            let len = self.len();
            let mut guard = SetLenOnDrop
            {
            
                s: self,
                idx: 0,
                del_bytes: 0,
            };

            while guard.idx < len
            {
                let ch = unsafe
                {
                    guard
                        .s
                        .get_unchecked(guard.idx..len)
                        .chars()
                        .next()
                        .unwrap()
                };

                let ch_len = ch.len_utf8();

                if !f(ch) { guard.del_bytes += ch_len; }

                else if guard.del_bytes > 0
                {
                    unsafe
                    {
                        ptr::copy
                        (
                            guard.s.data.as_ptr().add(guard.idx),
                            guard.s.data.as_mut_ptr().add(guard.idx - guard.del_bytes),
                            ch_len,
                        );
                    }
                }
                
                guard.idx += ch_len;
            }

            drop(guard);
        }

        fn as_mut_ptr(&mut self) -> *mut u8 { self.as_ptr() as *mut u8 }
    }

    impl<A: Array<Item = u8>> ops::Deref for SmallString<A> 
    {
        type Target = str;
        #[inline] fn deref(&self) -> &str
        {
            let bytes: &[u8] = &self.data;
            unsafe { str::from_utf8_unchecked(bytes) }
        }
    }

    impl<A: Array<Item = u8>> ops::DerefMut for SmallString<A>
    {
        #[inline] fn deref_mut(&mut self) -> &mut str
        {
            let bytes: &mut [u8] = &mut self.data;
            unsafe { str::from_utf8_unchecked_mut(bytes) }
        }
    }

    impl<A: Array<Item = u8>> AsRef<str> for SmallString<A>
    {
        #[inline] fn as_ref(&self) -> &str
        {
            self
        }
    }

    impl<A: Array<Item = u8>> AsMut<str> for SmallString<A>
    {
        #[inline] fn as_mut(&mut self) -> &mut str
        {
            self
        }
    }

    impl<A: Array<Item = u8>> Borrow<str> for SmallString<A>
    {
        #[inline] fn borrow(&self) -> &str { self }
    }

    impl<A: Array<Item = u8>> BorrowMut<str> for SmallString<A>
    {
        #[inline] fn borrow_mut(&mut self) -> &mut str { self }
    }

    impl<A: Array<Item = u8>> AsRef<[u8]> for SmallString<A>
    {
        #[inline] fn as_ref(&self) -> &[u8] { self.data.as_ref() }
    }

    impl<A: Array<Item = u8>> fmt::Write for SmallString<A>
    {
        #[inline] fn write_str(&mut self, s: &str) -> fmt::Result
        {
            self.push_str(s);
            Ok(())
        }

        #[inline] fn write_char(&mut self, ch: char) -> fmt::Result
        {
            self.push(ch);
            Ok(())
        }
    }

    impl<A: Array<Item = u8>> From<char> for SmallString<A>
    {
        #[inline] fn from(ch: char) -> SmallString<A> { SmallString::from_str(ch.encode_utf8(&mut [0; 4])) }
    }

    impl<'a, A: Array<Item = u8>> From<&'a str> for SmallString<A>
    {
        #[inline] fn from(s: &str) -> SmallString<A> { SmallString::from_str(s) }
    }

    impl<A: Array<Item = u8>> From<Box<str>> for SmallString<A>
    {
        #[inline] fn from(s: Box<str>) -> SmallString<A> { SmallString::from_string(s.into()) }
    }

    impl<A: Array<Item = u8>> From<String> for SmallString<A>
    {
        #[inline] fn from(s: String) -> SmallString<A> { SmallString::from_string(s) }
    }

    impl<'a, A: Array<Item = u8>> From<Cow<'a, str>> for SmallString<A>
    {
        fn from(value: Cow<'a, str>) -> Self
        {
            match value
            {
                Cow::Borrowed(s) => Self::from_str(s),
                Cow::Owned(s) => Self::from_string(s),
            }
        }
    }

    macro_rules! impl_index_str
    {
        ($index_type: ty) =>
        {
            impl<A: Array<Item = u8>> ops::Index<$index_type> for SmallString<A>
            {
                type Output = str;
                #[inline] fn index(&self, index: $index_type) -> &str { &self.as_str()[index] }
            }

            impl<A: Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A>
            {
                #[inline] fn index_mut(&mut self, index: $index_type) -> &mut str {  &mut self.as_mut_str()[index] }
            }
        };
    }

    impl_index_str!(ops::Range<usize>);
    impl_index_str!(ops::RangeFrom<usize>);
    impl_index_str!(ops::RangeTo<usize>);
    impl_index_str!(ops::RangeFull);

    impl<A: Array<Item = u8>> FromIterator<char> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a char> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter.into_iter().cloned());
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a str> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<A: Array<Item = u8>> FromIterator<String> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<A: Array<Item = u8>> Extend<char> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I)
        {
            let iter = iter.into_iter();
            let (lo, _) = iter.size_hint();

            self.reserve(lo);

            for ch in iter
            {
                self.push(ch);
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a char> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I)
        {
            self.extend(iter.into_iter().cloned());
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(&s);
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a str> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(s);
            }
        }
    }

    impl<A: Array<Item = u8>> Extend<String> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(&s);
            }
        }
    }

    impl<A: Array<Item = u8>> fmt::Debug for SmallString<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Debug::fmt(&**self, f) }
    }

    impl<A: Array<Item = u8>> fmt::Display for SmallString<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(&**self, f) }
    }

    macro_rules! eq_str
    {
        ( $rhs:ty ) =>
        {
            impl<'a, A: Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
            {
                #[inline] fn eq(&self, rhs: &$rhs) -> bool { &self[..] == &rhs[..] }
                #[inline] fn ne(&self, rhs: &$rhs) -> bool { &self[..] != &rhs[..] }
            }
        };
    }

    eq_str!(str);
    eq_str!(&'a str);
    eq_str!(String);
    eq_str!(Cow<'a, str>);
    
    impl<A: Array<Item = u8>> PartialEq<OsStr> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &OsStr) -> bool
        {
            &self[..] == rhs
        }

        #[inline] fn ne(&self, rhs: &OsStr) -> bool
        {
            &self[..] != rhs
        }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &&OsStr) -> bool { &self[..] == *rhs }
        #[inline] fn ne(&self, rhs: &&OsStr) -> bool { &self[..] != *rhs }
    }
    
    impl<A: Array<Item = u8>> PartialEq<OsString> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &OsString) -> bool { &self[..] == rhs }
        #[inline] fn ne(&self, rhs: &OsString) -> bool { &self[..] != rhs }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &Cow<OsStr>) -> bool { self[..] == **rhs }
        #[inline] fn ne(&self, rhs: &Cow<OsStr>) -> bool { self[..] != **rhs }
    }

    impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
    A: Array<Item = u8>,
    B: Array<Item = u8>
    {
        #[inline] fn eq(&self, rhs: &SmallString<B>) -> bool { &self[..] == &rhs[..] }

        #[inline] fn ne(&self, rhs: &SmallString<B>) -> bool { &self[..] != &rhs[..] }
    }

    impl<A: Array<Item = u8>> Eq for SmallString<A> {}

    impl<A: Array<Item = u8>> PartialOrd for SmallString<A>
    {
        #[inline] fn partial_cmp(&self, rhs: &SmallString<A>) -> Option<Ordering>
        {
            self[..].partial_cmp(&rhs[..])
        }
    }

    impl<A: Array<Item = u8>> Ord for SmallString<A>
    {
        #[inline] fn cmp(&self, rhs: &SmallString<A>) -> Ordering
        {
            self[..].cmp(&rhs[..])
        }
    }

    impl<A: Array<Item = u8>> Hash for SmallString<A>
    {
        #[inline] fn hash<H: Hasher>(&self, state: &mut H)
        {
            self[..].hash(state)
        }
    }
    /// A draining iterator for `SmallString`.
    pub struct Drain<'a>
    {
        iter: Chars<'a>,
    }

    impl<'a> Iterator for Drain<'a>
    {
        type Item = char;

        #[inline] fn next(&mut self) -> Option<char> { self.iter.next() }

        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
    }

    impl<'a> DoubleEndedIterator for Drain<'a>
    {
        #[inline] fn next_back(&mut self) -> Option<char> { self.iter.next_back() }
    }
    /// A possible error value when creating a `SmallString` from a byte array.
    #[derive(Debug)]
    pub struct FromUtf8Error<A: Array<Item = u8>>
    {
        buf: A,
        error: Utf8Error,
    }

    impl<A: Array<Item = u8>> FromUtf8Error<A>
    {
        /// Returns the slice of `[u8]` bytes that were attempted to convert to a `SmallString`.
        #[inline] pub fn as_bytes(&self) -> &[u8] 
        {
            let ptr = &self.buf as *const _ as *const u8;
            unsafe { slice::from_raw_parts(ptr, A::size()) }
        }
        /// Returns the byte array that was attempted to convert into a `SmallString`.
        #[inline] pub fn into_buf(self) -> A  { self.buf }
        /// Returns the `Utf8Error` to get more details about the conversion failure.
        #[inline] pub fn utf8_error(&self) -> Utf8Error  { self.error }
    }

    impl<A: Array<Item = u8>> fmt::Display for FromUtf8Error<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
        {
            fmt::Display::fmt(&self.error, f)
        }
    }
    /*
    pub fn write_file_str(...) -> io::Result<()> */
    /// Writes a strand to a file.
    pub fn write_file(fname: &str, contents: &str) -> io::Result<()>
    {
        let mut file = File::create(fname)?;
        file.write_all(contents.as_bytes())?;
        Ok(())
    }
    /*
    pub fn read_file_str(...) -> io::Result<String> */
    /// Reads a file and returns its contents in a string.
    pub fn read_file(fname: &str) -> io::Result<String>
    {
        let mut file = File::open(fname)?;
        let mut contents = String::new();
        let _ = file.read_to_string(&mut contents)?;
        Ok(contents)
    }
    /// Iterator over string prefixes.
    pub struct Prefixes<'a>
    {
        s: &'a str,
        iter: CharIndices<'a>,
    }
    /// Returns an iterator over all non-empty prefixes of `s`, beginning with the shortest.
    #[inline] pub fn prefixes(s: &str) -> Prefixes
    {
        Prefixes
        {
            s,
            iter: s.char_indices(),
        }
    }

    impl<'a> Iterator for Prefixes<'a>
    {
        type Item = &'a str;
        fn next(&mut self) -> Option<&'a str>
        {
            self.iter.next().map(|(idx, ch)| &self.s[..idx + ch.len_utf8()])
        }
    }    
    /// Mask of the value bits of a continuation byte.
    pub const CONT_MASK: u8 = 0b0011_1111;
    /// Returns the initial codepoint accumulator for the first byte.
    #[inline] pub const fn utf8_first_byte(byte: u8, width: u32) -> u32
    {
        (byte & (0x7F >> width)) as u32
    }
    /// Returns the value of `ch` updated with continuation byte `byte`.
    #[inline] pub const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {
        (ch << 6) | (byte & CONT_MASK) as u32
    }
    /// Reads the next code point out of a byte iterator (assuming a UTF-8-like encoding).
    #[inline] pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32>
    {
        let x = *bytes.next()?;
        if x < 128 { return Some(x as u32); }
        
        let init = utf8_first_byte(x, 2);
        
        let y = unsafe { *bytes.next().unwrap_unchecked() };
        let mut ch = utf8_acc_cont_byte(init, y);
        if x >= 0xE0
        {
            let z = unsafe { *bytes.next().unwrap_unchecked() };
            let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);
            ch = init << 12 | y_z;
            if x >= 0xF0
            {
                let w = unsafe { *bytes.next().unwrap_unchecked() };
                ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);
            }
        }

        Some(ch)
    }
    /// Similar to `std::ffi::CString`, but avoids heap allocating if the string is small enough.
    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
    pub struct SmallCString(SmallVec<[u8; 16]>);

    impl SmallCString
    {
        #[inline] pub fn new(s: &str) -> Result<Self, ::ffi::NulError>
        {
            if s.as_bytes().contains(&0_u8) {
                return Err(Self::fabricate_nul_error(s));
            }
            let mut buf = SmallVec::with_capacity(s.len() + 1);
            buf.extend_from_slice(s.as_bytes());
            buf.push(0);
            let res = Self(buf);
            res.debug_checks();
            Ok(res)
        }

        #[inline] pub fn as_str(&self) -> &str
        {
            unsafe
            {
                self.debug_checks();
                from_utf8_unchecked(self.as_bytes_without_nul())
            }
        }
        /// Get the bytes not including the NUL terminator.
        #[inline] pub fn as_bytes_without_nul(&self) -> &[u8] 
        {
            self.debug_checks();
            &self.0[..self.len()]
        }
        /// Get the bytes behind this str *including* the NUL terminator.
        #[inline] pub fn as_bytes_with_nul(&self) -> &[u8]
        {
            self.debug_checks();
            &self.0
        }

        #[inline] fn debug_checks(&self)
        {
            debug_assert_ne!(self.0.len(), 0);
            debug_assert_eq!(self.0[self.0.len() - 1], 0);
            let strbytes = &self.0[..(self.0.len() - 1)];
            debug_assert!(!strbytes.contains(&0));
            debug_assert!( from_utf8(strbytes).is_ok() );
        }

        #[inline] fn debug_checks(&self) {}

        #[inline] pub fn len(&self) -> usize
        {
            debug_assert_ne!(self.0.len(), 0);
            self.0.len() - 1
        }

        #[inline] pub fn is_empty(&self) -> bool
        {
            self.len() == 0
        }

        #[inline] pub fn as_cstr(&self) -> &::ffi::CStr
        {
            let bytes = self.as_bytes_with_nul();
            debug_assert!( ::ffi::CStr::from_bytes_with_nul(bytes).is_ok() );
            unsafe { ::ffi::CStr::from_bytes_with_nul_unchecked(bytes) }
        }

        #[cold] fn fabricate_nul_error(b: &str) -> ::ffi::NulError
        {
            ::ffi::CString::new(b).unwrap_err()
        }
    }

    impl Default for SmallCString
    {
        #[inline] fn default() -> Self { Self(smallvec![0]) }
    }

    impl ::fmt::Debug for SmallCString
    {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
        {
            f.debug_tuple("SmallCString").field(&self.as_str()).finish()
        }
    }

    impl ::ops::Deref for SmallCString
    {
        type Target = CStr;
        #[inline] fn deref(&self) -> &CStr { self.as_cstr() }
    }

    impl ::borrow::Borrow<str> for SmallCString
    {
        #[inline] fn borrow(&self) -> &str { self.as_str() }
    }

}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };

    pub fn map_lock_result<F, T, U>(res: LockResult<T>, f: F) -> LockResult<U> where F: FnOnce(T) -> U
    {
        match res
        {
            Ok(t) => Ok(f(t)),
            Err(e) => Err(PoisonError::new(f(e.into_inner()))),
        }
    }

    pub fn map_try_lock_result<F, T, U>(res: TryLockResult<T>, f: F) -> TryLockResult<U> where 
    F: FnOnce(T) -> U
    {
        match res
        {
            Ok(t) => Ok(f(t)),
            Err(TryLockError::Poisoned(p)) => Err(TryLockError::Poisoned( PoisonError::new(f(p.into_inner())))),
            Err(TryLockError::WouldBlock) => Err(TryLockError::WouldBlock),
        }
    }

    pub fn map2_lock_result<F, T, U, R>(res: LockResult<T>, res2: LockResult<U>, f: F) -> 
    LockResult<R> where 
    F: FnOnce(T, U) -> R
    {
        match (res, res2)
        {
            (Ok(a), Ok(b)) => Ok(f(a, b)),
            (Ok(a), Err(b)) => Err(PoisonError::new(f(a, b.into_inner()))),
            (Err(a), Ok(b)) => Err(PoisonError::new(f(a.into_inner(), b))),
            (Err(a), Err(b)) => Err(PoisonError::new(f(a.into_inner(), b.into_inner()))),
        }
    }

    pub fn map2_try_lock_result<F, T, U, R>( res: TryLockResult<T>, res2: TryLockResult<U>, f: F) -> 
    TryLockResult<R> where 
    F: FnOnce(T, U) -> R
    {
        match (res, res2)
        {
            (Ok(a), Ok(b)) => Ok(f(a, b)),
            (Err(TryLockError::WouldBlock), _) => Err(TryLockError::WouldBlock),
            (_, Err(TryLockError::WouldBlock)) => Err(TryLockError::WouldBlock),
            (Ok(a), Err(TryLockError::Poisoned(b))) => Err(TryLockError::Poisoned(PoisonError::new(f(a, b.into_inner())))),
            (Err(TryLockError::Poisoned(a)), Ok(b)) => Err(TryLockError::Poisoned(PoisonError::new(f(a.into_inner(), b)))),
            (Err(TryLockError::Poisoned(a)), Err(TryLockError::Poisoned(b))) => Err(TryLockError::Poisoned(PoisonError::new( f(a.into_inner(), b.into_inner())))),
        }
    }
}

pub mod system
{
    //! Provides an interactive input reader for Unix terminals and Windows console.
    use ::
    {
        borrow::Cow,
        ops::{Range, RangeFrom, RangeFull, RangeTo},
        str::{from_utf8, from_utf8_unchecked},
        *,
    };

    pub mod buffer
    {
        use ::
        {
            char::width,
            mem::swap,
            ops::Range,
            str::SmallString,
            system::{ * },
            *,
        };
        
        const TAB_STOP: usize = 8;

        pub struct ScreenBuffer 
        {
            buffer: Vec<Cell>,
            back_buffer: Vec<Cell>,
            size: Size,
            cursor: Cursor,
            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
        }

        impl ScreenBuffer 
        {
            pub fn new(size: Size) -> ScreenBuffer {
                let area = size.area();

                ScreenBuffer{
                    buffer: vec![Cell::default(); area],
                    back_buffer: vec![Cell::default(); area],
                    size: size,
                    cursor: Cursor::default(),

                    fg: None,
                    bg: None,
                    style: Style::empty(),
                }
            }

            pub fn cursor(&self) -> Cursor {
                self.cursor
            }

            pub fn size(&self) -> Size {
                self.size
            }

            pub fn resize(&mut self, new_size: Size) {
                resize_buffer(&mut self.buffer, self.size, new_size);
                new_buffer(&mut self.back_buffer, new_size);
                self.size = new_size;
            }

            pub fn set_cursor(&mut self, pos: Cursor) {
                self.cursor = pos;
            }

            pub fn next_line(&mut self, column: usize) {
                self.cursor.line += 1;
                self.cursor.column = column;
            }

            pub fn clear_attributes(&mut self) {
                self.fg = None;
                self.bg = None;
                self.style = Style::empty();
            }

            pub fn add_style(&mut self, style: Style) {
                self.style |= style;
            }

            pub fn remove_style(&mut self, style: Style) {
                self.style -= style;
            }

            pub fn set_style(&mut self, style: Style) {
                self.style = style;
            }

            pub fn set_fg(&mut self, fg: Option<Color>) {
                self.fg = fg;
            }

            pub fn set_bg(&mut self, bg: Option<Color>) {
                self.bg = bg;
            }

            pub fn set_theme(&mut self, theme: Theme) {
                self.set_fg(theme.fg);
                self.set_bg(theme.bg);
                self.set_style(theme.style);
            }

            pub fn clear_screen(&mut self) {
                for cell in &mut self.buffer {
                    *cell = Cell::default();
                }
            }

            pub fn indices(&self) -> Range<usize> {
                0..self.size.area()
            }
            
            pub fn next_cell(&mut self, indices: &mut Range<usize>) -> Option<(Cursor, Cell)> 
            {
                while let Some(idx) = indices.next() 
                {
                    let first = self.buffer[idx].first_char();
                    let width = char::width(first).unwrap_or(0);
                    
                    if width == 2 { let _ = indices.next(); }

                    if self.buffer[idx] != self.back_buffer[idx] 
                    {
                        let cell = self.buffer[idx].clone();
                        let line = idx / self.size.columns;
                        let column = idx % self.size.columns;
                        self.back_buffer[idx] = cell.clone();
                        return Some((Cursor{line, column}, cell));
                    }
                }

                None
            }

            fn cell_mut(&mut self, pos: Cursor) -> &mut Cell {
                let size = self.size;
                &mut self.buffer[pos.as_index(size)]
            }

            fn set_cell(&mut self, pos: Cursor, ch: char) {
                let fg = self.fg;
                let bg = self.bg;
                let style = self.style;
                let cell = self.cell_mut(pos);
                cell.fg = fg;
                cell.bg = bg;
                cell.style = style;
                cell.text = ch.into();
            }

            pub fn write_char(&mut self, ch: char) -> Result<(), OutOfBounds> 
            {
                if ch == '\t' 
                {
                    self.try_cursor()?;
                    let rem = self.size.columns - self.cursor.column;
                    let n = rem.min(TAB_STOP - (self.cursor.column % TAB_STOP));

                    for _ in 0..n {
                        self.write_char(' ')?;
                    }
                }

                else if ch == '\r' 
                {
                    self.cursor.column = 0;
                } 

                else if ch == '\n' 
                {
                    self.cursor.line += 1;
                    self.cursor.column = 0;
                } 

                else if is::combining_mark(ch) 
                {
                    if let Some(prev) = self.cursor.previous(self.size) 
                    {
                        self.try_cursor_at(prev)?;
                        self.cell_mut(prev).text.push(ch);
                    }
                }

                else if is::visible(ch) 
                {
                    self.try_cursor()?;

                    if let Some(prev) = self.cursor.previous(self.size) 
                    {
                        let cell = self.cell_mut(prev);

                        if cell.is_wide() { *cell = Cell::default(); }
                    }

                    let rem = self.size.columns - self.cursor.column;
                    let width = char::width(ch).unwrap_or(0);
                    
                    if rem < width 
                    {
                        self.try_cursor()?;
                        let mut pos = self.cursor;

                        for _ in 0..rem 
                        {
                            self.set_cell(pos, ch);
                            pos.column += 1;
                        }

                        self.cursor.column = 0;
                        self.cursor.line += 1;
                    }

                    self.try_cursor()?;
                    let mut pos = self.cursor;
                    self.set_cell(pos, ch);

                    for _ in 1..width 
                    {
                        pos.column += 1;
                        self.set_cell(pos, ' ');
                    }

                    self.cursor.column += width;

                    if self.cursor.column >= self.size.columns 
                    {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                }

                Ok(())
            }

            pub fn write_str(&mut self, s: &str) -> Result<(), OutOfBounds> {
                for ch in s.chars() {
                    self.write_char(ch)?;
                }

                Ok(())
            }

            pub fn write_at(&mut self, pos: Cursor, text: &str) -> Result<(), OutOfBounds> {
                self.try_cursor_at(pos)?;
                self.cursor = pos;

                self.write_str(text)
            }

            pub fn write_styled(&mut self,
                    fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                    -> Result<(), OutOfBounds> {
                self.fg = fg;
                self.bg = bg;
                self.style = style;

                self.write_str(text)?;
                self.clear_attributes();

                Ok(())
            }

            pub fn write_styled_at(&mut self, pos: Cursor,
                    fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                    -> Result<(), OutOfBounds> {
                self.try_cursor_at(pos)?;
                self.cursor = pos;

                self.write_styled(fg, bg, style, text)
            }

            fn try_cursor(&self) -> Result<(), OutOfBounds> {
                self.try_cursor_at(self.cursor)
            }

            fn try_cursor_at(&self, pos: Cursor) -> Result<(), OutOfBounds> {
                if pos.line >= self.size.lines || pos.column >= self.size.columns {
                    Err(OutOfBounds(()))
                } else {
                    Ok(())
                }
            }
        }

        #[derive(Debug)]
        pub struct OutOfBounds(());

        #[derive(Clone, Debug, Eq, PartialEq)]
        pub struct Cell 
        {
            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
            text: SmallString<[u8; 8]>,
        }

        impl Cell 
        {
            fn new(fg: Option<Color>, bg: Option<Color>, style: Style, chr: char) -> Cell {
                Cell{
                    fg,
                    bg,
                    style,
                    text: chr.into(),
                }
            }

            fn invalid() -> Cell {
                Cell{
                    fg: None,
                    bg: None,
                    style: Style::empty(),
                    text: SmallString::new(),
                }
            }

            pub fn attrs(&self) -> (Option<Color>, Option<Color>, Style) {
                (self.fg, self.bg, self.style)
            }

            pub fn text(&self) -> &str {
                &self.text
            }

            fn first_char(&self) -> char {
                self.text.chars().next().expect("empty cell text")
            }

            fn is_wide(&self) -> bool {
                self.text.chars().next()
                    .and_then(char::width).unwrap_or(0) == 2
            }
        }

        impl Default for Cell 
        {
            fn default() -> Cell {
                Cell::new(None, None, Style::empty(), ' ')
            }
        }

        fn resize_buffer(buf: &mut Vec<Cell>, old: Size, new: Size) 
        {
            if old != new {
                let mut new_buf = vec![Cell::default(); new.area()];

                if !buf.is_empty() {
                    let n_cols = old.columns.min(new.columns);

                    for (old, new) in buf.chunks_mut(old.columns)
                            .zip(new_buf.chunks_mut(new.columns)) {
                        for i in 0..n_cols {
                            swap(&mut new[i], &mut old[i]);
                        }
                    }
                }

                *buf = new_buf;
            }
        }

        fn new_buffer(buf: &mut Vec<Cell>, new_size: Size) 
        {
            *buf = vec![Cell::invalid(); new_size.area()];
        }
    } pub use self::buffer::{ * };

    pub mod command
    {
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            char::{ escape_sequence },
            *,
        };

        macro_rules! define_commands
        {
            ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => {
                /// Represents a command to modify `Reader` state
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub enum Command {
                    $( #[$meta] $name , )+
                    /// Custom application-defined command
                    Custom(Cow<'static, str>),
                    /// Execute a given key sequence
                    Macro(Cow<'static, str>),
                }
                /// List of all command names
                pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

                impl fmt::Display for Command {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        match *self {
                            $( Command::$name => f.write_str($str) , )+
                            Command::Custom(ref s) => f.write_str(s),
                            Command::Macro(ref s) => write!(f, "\"{}\"",
                                escape_sequence(s))
                        }
                    }
                }

                impl Command {
                    /// Constructs a command from a `'static str` reference.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Borrowed(name))` will be returned.
                    pub fn from_str(name: &'static str) -> Command {
                        Command::opt_from_str(name)
                            .unwrap_or_else(|| Command::Custom(Borrowed(name)))
                    }

                    /// Constructs a command from a non-`'static` string-like type.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Owned(name.into()))` will be returned.
                    pub fn from_string<T>(name: T) -> Command
                            where T: AsRef<str> + Into<String> {
                        Command::opt_from_str(name.as_ref())
                            .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                    }

                    fn opt_from_str(s: &str) -> Option<Command> {
                        match s {
                            $( $str => Some(Command::$name), )+
                            _ => None
                        }
                    }
                }
            }
        }

        define_commands!
        {
            /// Abort history search
            Abort => "abort",
            /// Accepts the current input line
            AcceptLine => "accept-line",
            /// Perform completion
            Complete => "complete",
            /// Insert all completions into the input buffer
            InsertCompletions => "insert-completions",
            /// Show possible completions
            PossibleCompletions => "possible-completions",
            /// Insert the next possible completion
            MenuComplete => "menu-complete",
            /// Insert the previous possible completion
            MenuCompleteBackward => "menu-complete-backward",
            /// Begin numeric argument input
            DigitArgument => "digit-argument",
            /// Insert character or sequence at the cursor
            SelfInsert => "self-insert",
            /// Inserts a tab character
            TabInsert => "tab-insert",
            /// Toggles insert/overwrite mode
            OverwriteMode => "overwrite-mode",
            /// Insert a comment and accept input
            InsertComment => "insert-comment",
            /// Move the cursor backward one character
            BackwardChar => "backward-char",
            /// Move the cursor forward one character
            ForwardChar => "forward-char",
            /// Search for a given character
            CharacterSearch => "character-search",
            /// Search backward for a given character
            CharacterSearchBackward => "character-search-backward",
            /// Move the cursor backward one word
            BackwardWord => "backward-word",
            /// Move the cursor forward one word
            ForwardWord => "forward-word",
            /// Kill all characters before the cursor
            BackwardKillLine => "backward-kill-line",
            /// Kill all characters after the cursor
            KillLine => "kill-line",
            /// Kill a word before the cursor
            BackwardKillWord => "backward-kill-word",
            /// Kill a word after the cursor
            KillWord => "kill-word",
            /// Kill a word before the cursor, delimited by whitespace
            UnixWordRubout => "unix-word-rubout",
            /// Clear the screen
            ClearScreen => "clear-screen",
            /// Move the cursor to the beginning of the line
            BeginningOfLine => "beginning-of-line",
            /// Move the cursor to the end of the line
            EndOfLine => "end-of-line",
            /// Delete one character before the cursor
            BackwardDeleteChar => "backward-delete-char",
            /// Delete one character after the cursor
            DeleteChar => "delete-char",
            /// Drag the character before the cursor forward
            TransposeChars => "transpose-chars",
            /// Drag the word before the cursor forward
            TransposeWords => "transpose-words",
            /// Move to the first line of history
            BeginningOfHistory => "beginning-of-history",
            /// Move to the last line of history
            EndOfHistory => "end-of-history",
            /// Select next line in history
            NextHistory => "next-history",
            /// Select previous line in history
            PreviousHistory => "previous-history",
            /// Incremental search in history
            ForwardSearchHistory => "forward-search-history",
            /// Incremental reverse search in history
            ReverseSearchHistory => "reverse-search-history",
            /// Non-incremental forward history search using input up to the cursor
            HistorySearchForward => "history-search-forward",
            /// Non-incremental backward history search using input up to the cursor
            HistorySearchBackward => "history-search-backward",
            /// Insert literal character
            QuotedInsert => "quoted-insert",
            /// Insert text into buffer from the kill ring
            Yank => "yank",
            /// Rotate the kill ring and yank the new top
            YankPop => "yank-pop",
        }
        /// Describes the category of a command
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Category
        {
            /// Completion command
            Complete,
            /// Kill command
            Kill,
            /// Non-incremental search command
            Search,
            /// Incremental search command
            IncrementalSearch,
            /// Yank command
            Yank,
            /// Digit argument command
            Digit,
            /// Other command
            Other,
        }

        impl Command
        {
            /// Returns the category of the command
            pub fn category(&self) -> Category
            {
                use self::Command::*;
                match *self
                {
                    DigitArgument => Category::Digit,
                    Complete | InsertCompletions | PossibleCompletions | MenuComplete | MenuCompleteBackward => Category::Complete,
                    BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                    ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                    HistorySearchForward | HistorySearchBackward => Category::Search,
                    Yank | YankPop => Category::Yank,
                    _ => Category::Other
                }
            }
        }
    } pub use self::command::{ * };
    
    pub mod common
    {
        //! Platform-independent platform abstraction
        use ::
        {
            *,
        };
        /// A trait for viewing representations from std types
        pub trait AsInner<Inner: ?Sized>
        {
            fn as_inner(&self) -> &Inner;
        }
        /// A trait for viewing representations from std types
        pub trait AsInnerMut<Inner: ?Sized>
        {
            fn as_inner_mut(&mut self) -> &mut Inner;
        }
        /// A trait for extracting representations from std types
        pub trait IntoInner<Inner>
        {
            fn into_inner(self) -> Inner;
        }
        /// A trait for creating std types from internal representations
        pub trait FromInner<Inner>
        {
            fn from_inner(inner: Inner) -> Self;
        }
    } pub use self::common::{ * };

    pub mod complete
    {
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            fs::{ read_dir },
            path::{ is_separator, MAIN_SEPARATOR },
            system::{ * },
            *,
        };
        /*
        use linefeed::prompter::Prompter;
        use linefeed::terminal::Terminal; */
        /// Represents a single possible completion
        #[derive(Clone, Debug)]
        pub struct Completion {
            /// Whole completion text
            pub completion: String,
            /// Listing display string; `None` if matches completion
            pub display: Option<String>,
            /// Completion suffix; replaces append character
            pub suffix: Suffix,
        }
        /// Specifies an optional suffix to override the default value
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Suffix {
            /// Use the default suffix
            Default,
            /// Use no suffix
            None,
            /// Use the given suffix
            Some(char),
        }

        impl Completion {
            /// Returns a simple `Completion` value, with display string matching
            /// completion and using the default completion suffix.
            pub fn simple(s: String) -> Completion {
                Completion{
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }
            /// Returns the full completion string, including suffix, using the given
            /// default suffix if one is not assigned to this completion.
            pub fn completion(&self, def_suffix: Option<char>) -> Cow<str> {
                let mut s = Borrowed(&self.completion[..]);

                if let Some(suffix) = self.suffix.with_default(def_suffix) {
                    s.to_mut().push(suffix);
                }

                s
            }
            /// Returns the display string, including suffix
            pub fn display(&self) -> Cow<str> {
                let mut s = Borrowed(self.display_str());

                if let Suffix::Some(suffix) = self.suffix {
                    s.to_mut().push(suffix);
                }

                s
            }
            /// Returns the number of characters displayed
            pub fn display_chars(&self) -> usize {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str(&self) -> &str {
                match self.display {
                    Some(ref dis) => dis,
                    None => &self.completion
                }
            }
        }

        impl Suffix {
            /// Returns whether the `Suffix` value is the `Default` variant.
            pub fn is_default(&self) -> bool {
                match *self {
                    Suffix::Default => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `Some(_)` variant.
            pub fn is_some(&self) -> bool {
                match *self {
                    Suffix::Some(_) => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `None` variant.
            pub fn is_none(&self) -> bool {
                match *self {
                    Suffix::None => true,
                    _ => false
                }
            }
            /// Returns an `Option<char>`, using the given value in place of `Default`.
            pub fn with_default(self, default: Option<char>) -> Option<char> {
                match self {
                    Suffix::None => None,
                    Suffix::Some(ch) => Some(ch),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix {
            fn default() -> Suffix {
                Suffix::Default
            }
        }
        /// Performs completion for `Prompter` when triggered by a user input sequence
        pub trait Completer<Term: Terminals>: Send + Sync {
            /// Returns the set of possible completions for the prefix `word`.
            fn complete(&self, word: &str, prompter: &Prompter<Term>,
                start: usize, end: usize) -> Option<Vec<Completion>>;
            /// Returns the starting position of the word under the cursor.
            fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize {
                word_break_start(&line[..end], prompter.word_break_chars())
            }
            /// Quotes a possible completion for insertion into input.
            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
            /// Unquotes a piece of user input before searching for completions.
            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
        }
        /// `Completer` type that performs no completion
        pub struct DummyCompleter;

        impl<Term: Terminals> Completer<Term> for DummyCompleter {
            fn complete(&self, _word: &str, _reader: &Prompter<Term>,
                    _start: usize, _end: usize) -> Option<Vec<Completion>> { None }
        }
        /// Performs completion by searching for filenames matching the word prefix.
        pub struct PathCompleter;

        impl<Term: Terminals> Completer<Term> for PathCompleter {
            fn complete(&self, word: &str, _reader: &Prompter<Term>, _start: usize, _end: usize)
                    -> Option<Vec<Completion>> {
                Some(complete_path(word))
            }

            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }

            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }

            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(path: &str) -> Vec<Completion> {
            let (base_dir, fname) = split_path(path);
            let mut res = Vec::new();

            let lookup_dir = base_dir.unwrap_or(".");

            if let Ok(list) = read_dir(lookup_dir) {
                for ent in list {
                    if let Ok(ent) = ent {
                        let ent_name = ent.file_name();                        
                        if let Ok(path) = ent_name.into_string() {
                            if path.starts_with(fname) {
                                let (name, display) = if let Some(dir) = base_dir {
                                    (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                        Some(path))
                                } else {
                                    (path, None)
                                };

                                let is_dir = ent.metadata().ok()
                                    .map_or(false, |m| m.is_dir());

                                let suffix = if is_dir {
                                    Suffix::Some(MAIN_SEPARATOR)
                                } else {
                                    Suffix::Default
                                };

                                res.push(Completion{
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                });
                            }
                        }
                    }
                }
            }

            res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
            res
        }
        /// Returns the start position of the word that ends at the end of the string.
        pub fn word_break_start(s: &str, word_break: &str) -> usize {
            let mut start = s.len();

            for (idx, ch) in s.char_indices().rev() {
                if word_break.contains(ch) {
                    break;
                }
                start = idx;
            }

            start
        }
        /// Returns the start position of a word with non-word characters escaped by
        /// backslash (`\\`).
        pub fn escaped_word_start(s: &str) -> usize {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some((idx, ch)) = chars.next() {
                if needs_escape(ch) {
                    let n = {
                        let mut n = 0;

                        loop {
                            let mut clone = chars.clone();

                            let ch = match clone.next() {
                                Some((_, ch)) => ch,
                                None => break
                            };

                            if ch == '\\' {
                                chars = clone;
                                n += 1;
                            } else {
                                break;
                            }
                        }

                        n
                    };

                    if n % 2 == 0 {
                        break;
                    }
                }

                start = idx;
            }

            start
        }
        /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
        pub fn escape(s: &str) -> Cow<str> {
            let n = s.chars().filter(|&ch| needs_escape(ch)).count();

            if n == 0 {
                Borrowed(s)
            } else {
                let mut res = String::with_capacity(s.len() + n);

                for ch in s.chars() {
                    if needs_escape(ch) {
                        res.push('\\');
                    }
                    res.push(ch);
                }

                Owned(res)
            }
        }
        /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
        pub fn unescape(s: &str) -> Cow<str> {
            if s.contains('\\') {
                let mut res = String::with_capacity(s.len());
                let mut chars = s.chars();

                while let Some(ch) = chars.next() {
                    if ch == '\\' {
                        if let Some(ch) = chars.next() {
                            res.push(ch);
                        }
                    } else {
                        res.push(ch);
                    }
                }

                Owned(res)
            } else {
                Borrowed(s)
            }
        }

        fn needs_escape(ch: char) -> bool {
            match ch {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path(path: &str) -> (Option<&str>, &str) {
            match path.rfind(is_separator) {
                Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
                None => (None, path)
            }
        }
    } pub use self::complete::{ * };

    pub mod function
    {
        use ::
        {
            system::{ * },
            *,
        };
        /*
        use linefeed::command::Category;
        use linefeed::prompter::Prompter;
        use linefeed::terminal::Terminal;*/
        /// Implements custom functionality for a `Prompter` command
        pub trait Function<Term: Terminals>: Send + Sync
        {
            /// Executes the function.
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;
            /// Returns the command category.
            fn category(&self) -> Category { Category::Other }
        }

        impl<F, Term: Terminals> Function<Term> for F where
        F: Send + Sync,
        F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()>
        {
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()> {
                self(prompter, count, ch)
            }
        }
    } pub use self::function::{ * };

    pub mod inputrc
    {
        use ::
        {
            char::{ from_u32, ctrl, meta, parse_name },
            fs::{ File },
            io::{ stderr, Read, Write },
            path::{ Path },
            str::{ Chars, Lines },
            system::{ Command },
            *,
        };
        /// Parsed configuration directive
        #[derive(Clone, Debug)]
        pub enum Directive
        {
            /// Bind construct; `"input-sequence": command-or-macro`
            Bind(String, Command),
            /// Conditional construct;
            Conditional
            {
                /// Value name; if `None`, value refers to application name
                name: Option<String>,
                /// Value to compare
                value: String,
                /// Group of directives evaluated when condition is true
                then_group: Vec<Directive>,
                /// Group of directives evaluated when condition is false
                else_group: Vec<Directive>,
            },
            /// Set variable; `set name value`
            SetVariable(String, String),
        }
        /// Parses the named file and returns contained directives.
        pub fn parse_file<P: ?Sized>(filename: &P) -> Option<Vec<Directive>> where
        P: AsRef<Path>
        {
            let filename = filename.as_ref();
            let mut f = match File::open(filename) 
            {
                Ok(f) => f,
                Err(e) => 
                {
                    let _ = writeln!(stderr(), "linefeed: {}: {}", filename.display(), e);
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err(e) = f.read_to_string(&mut buf) 
            {
                let _ = writeln!(stderr(), "{}: {}", filename.display(), e);
                return None;
            }

            Some(parse_text(filename, &buf))
        }
        /// Parses some text and returns contained directives.
        pub fn parse_text<P: ?Sized>(name: &P, line: &str) -> Vec<Directive> where P: AsRef<Path>
        {
            let mut p = Parser::new(name.as_ref(), line);
            p.parse()
        }

        struct Parser<'a> 
        {
            lines: Lines<'a>,
            filename: &'a Path,
            line_num: usize,
        }

        enum Token<'a> 
        {
            /// Colon; `:`
            Colon,
            /// Equal; `=`
            Equal,
            /// Conditional or other special directive; `$word`
            SpecialWord(&'a str),
            /// Double-quoted string; `"foo"`
            String(String),
            /// Bare word; `foo`
            Word(&'a str),
            /// Invalid token
            Invalid,
        }

        impl<'a> Parser<'a> 
        {
            pub fn new(filename: &'a Path, text: &'a str) -> Parser<'a> 
            {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line(&mut self) -> Option<&'a str> 
            {
                self.lines.next().map(|line| 
                    {
                    self.line_num += 1;
                    line.trim()
                })
            }

            fn parse(&mut self) -> Vec<Directive> 
            {
                let mut dirs = Vec::new();

                while let Some(line) = self.next_line() 
                {
                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    if let Some(Token::SpecialWord("include")) = tokens.next() 
                    {
                        let path = tokens.line;

                        if let Some(d) = parse_file(Path::new(path)) {
                            dirs.extend(d);
                        }

                        continue;
                    }

                    if let Some(dir) = self.parse_line(line) {
                        dirs.push(dir);
                    }
                }

                dirs
            }

            fn parse_conditional(&mut self) -> (Vec<Directive>, Vec<Directive>) 
            {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some(line) => line,
                        None => {
                            self.error("missing $endif directive");
                            break;
                        }
                    };

                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    let start = match tokens.next() {
                        Some(tok) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord("else") => {
                            if parse_else {
                                self.error("duplicate $else directive");
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord("endif") => {
                            break;
                        }
                        _ => {
                            if let Some(dir) = self.parse_line(line) {
                                if parse_else {
                                    else_group.push(dir);
                                } else {
                                    then_group.push(dir);
                                }
                            }
                        }
                    }
                }

                (then_group, else_group)
            }

            fn parse_line(&mut self, line: &str) -> Option<Directive> 
            {
                let mut tokens = Tokens::new(line);

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord("if") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (name, value) = match tokens.next() {
                            Some(Token::Equal) => {
                                let value = match tokens.next() {
                                    Some(Token::Word(w)) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                (Some(name), value)
                            }
                            None => (None, name),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (then_group, else_group) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map(|s| s.to_owned()),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord("else") => {
                        self.error("$else without matching $if directive");
                        return None;
                    }
                    Token::SpecialWord("endif") => {
                        self.error("$endif without matching $if directive");
                        return None;
                    }
                    Token::String(seq) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(out)) =>
                                Directive::Bind(seq, Command::Macro(out.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word("set") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some(Token::String(s)) => s,
                            Some(Token::Word(_)) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable(name.to_owned(), value)
                    }
                    Token::Word(name) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_name(name) {
                            Some(seq) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(macro_seq)) =>
                                Directive::Bind(seq, Command::Macro(macro_seq.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some(dir)
            }

            fn error(&self, msg: &str) {
                let _ = writeln!(stderr(),
                    "linefeed: {} line {}: {}", self.filename.display(), self.line_num, msg);
            }

            fn invalid(&self) {
                self.error("invalid directive");
            }
        }

        struct Tokens<'a> 
        {
            line: &'a str,
        }

        impl<'a> Tokens<'a> 
        {
            fn new(line: &str) -> Tokens {
                Tokens{
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> 
        {
            type Item = Token<'a>;

            fn next(&mut self) -> Option<Token<'a>> {
                let ch = self.line.chars().next()?;

                let tok = match ch {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }
                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }
                    '$' => {
                        let (word, rest) = parse_word(&self.line[1..]);
                        self.line = rest.trim_start();
                        Token::SpecialWord(word)
                    }
                    '"' => {
                        let (tok, rest) = parse_string(self.line);
                        self.line = rest.trim_start();
                        tok
                    }
                    _ => {
                        let (word, rest) = parse_word(self.line);
                        self.line = rest.trim_start();
                        Token::Word(word)
                    }
                };

                Some(tok)
            }
        }

        fn parse_escape(chars: &mut Chars) -> Option<String> 
        {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    ctrl(chars.next()?)
                }
                'M'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    return Some(meta(chars.next()?));
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some('{') => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then(|ch| ch.to_digit(16)) {
                            Some(digit) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some('}') => (),
                        _ => return None
                    }

                    from_u32(n)?
                }
                'v'  => '\x0b',
                'x'  =>
                {
                    let mut n = 0;

                    for _ in 0..2 {
                        let digit = chars.clone().next()?.to_digit(16)? as u8;
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' =>
                {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        let digit = chars.clone().next()?.to_digit(8)? as u8;

                        
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some(esc.to_string())
        }

        fn parse_string(s: &str) -> (Token, &str) 
        {
            let mut chars = s.chars();
            let mut res = String::new();
            chars.next();

            while let Some(ch) = chars.next() {
                match ch {
                    '"' => return (Token::String(res), chars.as_str()),
                    '\\' => {
                        match parse_escape(&mut chars) {
                            Some(esc) => {
                                res.push_str(&esc);
                            }
                            None => break
                        }
                    }
                    ch => res.push(ch)
                }
            }

            (Token::Invalid, "")
        }

        fn parse_word(s: &str) -> (&str, &str) 
        {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some((ind, ch)) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => {
                        return (&s[..ind], &s[ind..]);
                    }
                    None => {
                        return (s, "");
                    }
                    _ => ()
                }

                chars = clone;
            }
        }
    } pub use self::inputrc::{ * };

    pub mod interface
    {
        use ::
        {
            borrow::{ Cow },
            fs::{ File, OpenOptions },
            io::{ self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _, },
            path::{ Path },
            sync::{ Arc, Mutex, MutexGuard },
            system::{ * },
            time::{ Duration },
            *,
        };
        /*
        use linefeed::command::Command;
        use linefeed::complete::{Completer};
        use linefeed::function::Function;
        use linefeed::inputrc::Directive;
        use linefeed::reader::{Read, Reader, ReadLock, ReadResult};
        use linefeed::terminal::{DefaultTerminal, Signal, Terminal};
        use linefeed::variables::Variable;
        use linefeed::writer::{Write, Writer, WriteLock}; */
        /// The main interface to input reading and other terminal operations
        pub struct Interface<Term: Terminals> 
        {
            term: Term,
            write: Mutex<Write>,
            read: Mutex<Read<Term>>,
        }

        impl Interface<DefaultTerminal> 
        {
            /// Creates a new `Interface` with the given application name.
            pub fn new<T>(application: T) -> io::Result<Interface<DefaultTerminal>>
                    where T: Into<Cow<'static, str>> {
                let term = DefaultTerminal::new()?;
                Interface::with_term(application, term)
            }
        }

        impl<Term: Terminals> Interface<Term> 
        {
            /// Creates a new `Interface` instance with a particular terminal implementation.
            pub fn with_term<T>(application: T, term: Term) -> io::Result<Interface<Term>>
                    where T: Into<Cow<'static, str>> {
                let size = term.lock_write().size()?;
                let read = Read::new(&term, application.into());

                Ok(Interface{
                    term: term,
                    write: Mutex::new(Write::new(size)),
                    read: Mutex::new(read),
                })
            }
            /// Acquires the read lock and returns a `Reader` instance.
            pub fn lock_reader(&self) -> Reader<Term> {
                Reader::new(self, self.lock_read())
            }
            /// Acquires the write lock and returns a `Writer` instance.
            pub fn lock_writer_append(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), false)
            }
            /// Acquires the write lock and returns a `Writer` instance.
            pub fn lock_writer_erase(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), true)
            }

            fn lock_read(&self) -> ReadLock<Term> {
                ReadLock::new(
                    self.term.lock_read(),
                    self.read.lock().expect("Interface::lock_read"))
            }

            pub fn lock_write(&self) -> WriteLock<Term> {
                WriteLock::new(
                    self.term.lock_write(),
                    self.write.lock().expect("Interface::lock_write"))
            }

            pub fn lock_write_data(&self) -> MutexGuard<Write> {
                self.write.lock().expect("Interface::lock_write_data")
            }
        }
        /// ## Locking
        /// The following methods internally acquire the read lock.
        impl<Term: Terminals> Interface<Term> 
        {
            /// Interactively reads a line from the terminal device.
            pub fn read_line(&self) -> io::Result<ReadResult> {
                self.lock_reader().read_line()
            }
            /// Performs one step of the interactive `read_line` loop.
            pub fn read_line_step(&self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.lock_reader().read_line_step(timeout)
            }
            /// Cancels an in-progress `read_line` operation.
            pub fn cancel_read_line(&self) -> io::Result<()> {
                self.lock_reader().cancel_read_line()
            }
            /// Returns a clone of the current completer instance.
            pub fn completer(&self) -> Arc<dyn Completer<Term>> {
                self.lock_reader().completer().clone()
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                self.lock_reader().set_completer(completer)
            }
            /// Returns the value of the named variable or `None` if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock_reader().get_variable(name)
            }
            /// Sets the value of the named variable and returns the previous value.
            pub fn set_variable(&self, name: &str, value: &str) -> Option<Variable> {
                self.lock_reader().set_variable(name, value)
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock_reader().ignore_signal(signal)
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_ignore_signal(signal, set)
            }
            /// Returns whether the given `Signal` is reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock_reader().report_signal(signal)
            }
            /// Sets whether the given `Signal` is reported.
            pub fn set_report_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_report_signal(signal, set)
            }
            /// Binds a sequence to a command.
            pub fn bind_sequence<T>(&self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence(seq, cmd)
            }
            /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
            pub fn bind_sequence_if_unbound<T>(&self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence_if_unbound(seq, cmd)
            }
            /// Removes a binding for the given sequence.
            pub fn unbind_sequence(&self, seq: &str) -> Option<Command> {
                self.lock_reader().unbind_sequence(seq)
            }
            /// Defines a named function to which sequences may be bound.
            pub fn define_function<T>(&self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock_reader().define_function(name, cmd)
            }
            /// Removes a function defined with the given name.
            pub fn remove_function(&self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock_reader().remove_function(name)
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&self, dirs: Vec<Directive>) {
                self.lock_reader().evaluate_directives(&self.term, dirs)
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&self, dir: Directive) {
                self.lock_reader().evaluate_directive(&self.term, dir)
            }
        }
        /// ## Locking
        /// The following methods internally acquire the write lock.
        impl<Term: Terminals> Interface<Term> 
        {
            /// Returns the current input buffer.
            pub fn buffer(&self) -> String {
                self.lock_write().buffer.to_owned()
            }
            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.lock_write().history_len()
            }
            /// Returns the maximum number of history entries.
            pub fn history_size(&self) -> usize {
                self.lock_write().history_size()
            }
            /// Save history entries to the specified file.
            pub fn save_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let path = path.as_ref();
                let mut w = self.lock_write();

                if !path.exists() || w.history_size() == !0 {
                    self.append_history(path, &w)?;
                } else {
                    self.rewrite_history(path, &w)?;
                }

                w.reset_new_history();
                Ok(())
            }

            fn append_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                let file = OpenOptions::new()
                    .append(true)
                    .create(true)
                    .open(path.as_ref())?;

                self.append_history_to(&file, w)
            }

            fn append_history_to(&self, file: &File, w: &WriteLock<Term>) -> io::Result<()> {
                let mut wtr = BufWriter::new(file);

                for entry in w.new_history() {
                    wtr.write_all(entry.as_bytes())?;
                    wtr.write_all(b"\n")?;
                }

                wtr.flush()
            }

            fn rewrite_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                fn nth_line(s: &str, n: usize) -> Option<usize>
                {
                    let start = s.as_ptr() as usize;

                    s.lines().nth(n)
                        .map(|s| s.as_ptr() as usize - start)
                }

                let mut file = OpenOptions::new()
                    .create(true)
                    .read(true)
                    .write(true)
                    .open(path.as_ref())?;

                let mut hist = String::new();

                file.read_to_string(&mut hist)?;

                let n_lines = hist.lines().count();
                let n = n_lines.saturating_sub(
                    w.history_size() - w.new_history_entries());

                if n != 0 {
                    if let Some(pos) = nth_line(&hist, n) {
                        file.seek(SeekFrom::Start(0))?;
                        file.write_all(hist[pos..].as_bytes())?;

                        let n = file.seek(SeekFrom::Current(0))?;
                        file.set_len(n)?;
                    }
                }

                self.append_history_to(&file, w)
            }
            /// Load history entries from the specified file.
            pub fn load_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let mut writer = self.lock_write();

                let file = File::open(&path)?;
                let rdr = BufReader::new(file);

                for line in rdr.lines() {
                    writer.add_history(line?);
                }

                writer.reset_new_history();

                Ok(())
            }
            /// Writes formatted text to the terminal display.
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            fn write_str(&self, line: &str) -> io::Result<()> {
                self.lock_writer_erase()?.write_str(line)
            }
        }
        /// ## Locking
        /// The following methods internally acquire both the read and write locks.
        impl<Term: Terminals> Interface<Term> 
        {
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt(&self, prompt: &str) -> io::Result<()> {
                self.lock_reader().set_prompt(prompt)
            }
            /// Sets the input buffer to the given string.
            pub fn set_buffer(&self, buf: &str) -> io::Result<()> {
                self.lock_reader().set_buffer(buf)
            }
            /// Sets the cursor position in the input buffer.
            pub fn set_cursor(&self, pos: usize) -> io::Result<()> {
                self.lock_reader().set_cursor(pos)
            }
            /// Adds a line to history.
            pub fn add_history(&self, line: String) {
                self.lock_reader().add_history(line);
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique(&self, line: String) {
                self.lock_reader().add_history_unique(line);
            }
            /// Removes all history entries.
            pub fn clear_history(&self) {
                self.lock_reader().clear_history();
            }
            /// Removes the history entry at the given index.
            pub fn remove_history(&self, idx: usize) {
                self.lock_reader().remove_history(idx);
            }
            /// Sets the maximum number of history entries.
            pub fn set_history_size(&self, n: usize) {
                self.lock_reader().set_history_size(n);
            }
            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history(&self, n: usize) {
                self.lock_reader().truncate_history(n);
            }
        }
    } pub use self::interface::{ * };

    pub mod prompter
    {
        use ::
        {
            char::{ DELETE, EOF },
            mem::replace,
            ops::Range,
            sync::Arc,
            time::Instant,
            system::
            {
                Command::{ self, * }, *
            },
            *,
        };
        /*
        use mortal::FindResult;
        use linefeed::chars::{is_ctrl, is_printable, DELETE, EOF};
        use linefeed::command::{Category, Command};
        use linefeed::complete::Completion;
        use linefeed::function::Function;
        use linefeed::reader::{BindingIter, InputState, ReadLock, ReadResult};
        use linefeed::table::{format_columns, Line, Table};
        use linefeed::terminal::{CursorMode, Signal, Size, Terminal};
        use linefeed::util::{
            get_open_paren, find_matching_paren, first_word,
            longest_common_prefix, repeat_char,
            back_n_words, forward_n_words,
            backward_char, forward_char, backward_word, forward_word,
            word_start, word_end, RangeArgument,
        };
        use linefeed::variables::VariableIter;
        use linefeed::writer::{
            BLINK_DURATION, display_str,
            Digit, Display, HistoryIter, PromptType, Writer, WriteLock,
        };*/
        /// Provides access to the current state of input while a `read_line` call is in progress.
        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminals> 
        {
            pub read: &'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> Prompter<'a, 'b, Term> 
        {
            pub fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>) -> Prompter<'a, 'b, Term>
            {
                Prompter{read, write}
            }
            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> 
            {
                Writer::with_ref(&mut self.write, false)
            }
            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> 
            {
                Writer::with_ref(&mut self.write, true)
            }
            /// Resets input state at the start of `read_line`
            fn reset_input(&mut self) 
            {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub fn start_read_line(&mut self) -> io::Result<()> 
            {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub fn end_read_line(&mut self) -> io::Result<()> 
            {
                self.write.expire_blink()?;

                if self.read.overwrite_mode {
                    self.write.set_cursor_mode(CursorMode::Normal)?;
                }
                if self.write.is_prompt_drawn {
                    self.write.move_to_end()?;
                    self.write.write_str("\n")?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok(())
            }

            pub fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>> 
            {
                self.write.expire_blink()?;

                match self.read.state 
                {
                    InputState::Inactive => panic!("input received in inactive state"),
                    InputState::NewSequence => {
                        if ch == EOF && self.write.buffer.is_empty() {
                            self.write.write_str("\n")?;
                            self.write.is_prompt_drawn = false;
                            return Ok(Some(ReadResult::Eof));
                        } else {
                            self.read.sequence.push(ch);
                            self.execute_sequence()?;

                            if self.read.input_accepted {
                                let s = replace(&mut self.write.buffer, String::new());
                                return Ok(Some(ReadResult::Input(s)));
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => {
                        self.read.sequence.push(ch);

                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace(&mut self.write.buffer, String::new());
                            return Ok(Some(ReadResult::Input(s)));
                        }
                    }
                    InputState::Number => {
                        if let Some(digit) = ch.to_digit(10) {
                            self.write.input_arg.input(digit as i32);

                            if self.write.input_arg.is_out_of_bounds() {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt(PromptType::Normal)?;
                            } else {
                                self.write.redraw_prompt(PromptType::Number)?;
                            }
                        } else {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt(PromptType::Normal)?;
                            self.read.macro_buffer.insert(0, ch);
                        }
                    }
                    InputState::CharSearch{n, backward} => {
                        if n != 0 {
                            if backward {
                                self.write.backward_search_char(n, ch)?;
                            } else {
                                self.write.forward_search_char(n, ch)?;
                            }
                        }
                        self.read.state = InputState::NewSequence;
                    }
                    InputState::TextSearch => 
                    {
                        if ch == DELETE 
                        {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.pop();
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        } else if self.is_abort(ch) 
                        {
                            self.abort_search_history()?;
                        } else if is::ctrl(ch) 
                        {
                            self.end_search_history()?;
                            self.read.macro_buffer.insert(0, ch);
                        } else {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.push(ch);
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        }
                    }
                    InputState::CompleteIntro => 
                    {
                        match ch
                        {
                            'y' | 'Y' | ' ' => 
                            {
                                self.write.write_str("\n")?;
                                self.show_completions_page(0)?;
                            }
                            '\r' | '\n' => 
                            {
                                self.write.write_str("\n")?;
                                self.show_completions_line(0)?;
                            }
                            'q' | 'Q' | 'n' | 'N' | DELETE => 
                            {
                                self.write.write_str("\n")?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::CompleteMore(offset) =>
                    {
                        match ch
                        {
                            'y' | 'Y' | ' ' => 
                            {
                                self.write.clear_prompt()?;
                                self.show_completions_page(offset)?;
                            }
                            '\r' | '\n' => 
                            {
                                self.write.clear_prompt()?;
                                self.show_completions_line(offset)?;
                            }
                            'q' | 'Q' | 'n' | 'N' | DELETE => 
                            {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::QuotedInsert(n) =>
                    {
                        if n != 0 { self.insert(n, ch)?; }

                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok(None)
            }
            /// Returns the current buffer.
            pub fn buffer(&self) -> &str 
            {
                &self.write.buffer
            }
            /// Returns the "backup" buffer.
            pub fn backup_buffer(&self) -> &str 
            {
                &self.write.backup_buffer
            }
            /// Returns the command `Category` of the most recently executed command.
            pub fn last_command_category(&self) -> Category 
            {
                self.read.last_cmd
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str 
            {
                &self.read.word_break
            }
            /// Sets the buffer to the given value.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> 
            {
                self.write.set_buffer(buf)
            }
            /// Returns the current position of the cursor.
            pub fn cursor(&self) -> usize 
            {
                self.write.cursor
            }
            /// Sets the cursor to the given position within the buffer.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> 
            {
                self.write.set_cursor(pos)
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> 
            {
                self.write.set_prompt(prompt)
            }
            /// Returns the size of the terminal at the last draw operation.
            pub fn screen_size(&self) -> Size {
                self.write.screen_size
            }
            /// Returns whether a numerical argument was explicitly supplied by the user.
            pub fn explicit_arg(&self) -> bool {
                self.write.explicit_arg
            }
            /// Returns the current input sequence.
            pub fn sequence(&self) -> &str {
                &self.read.sequence
            }
            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.read.bindings()
            }
            /// Returns an iterator over variable values.
            pub fn variables(&self) -> VariableIter {
                self.read.variables()
            }
            /// Returns an iterator over history entries
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }
            /// Returns the index into history currently being edited.
            pub fn history_index(&self) -> Option<usize> {
                self.write.history_index
            }
            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.write.history.len()
            }

            fn next_history(&mut self, n: usize) -> io::Result<()> {
                self.write.next_history(n)
            }

            fn prev_history(&mut self, n: usize) -> io::Result<()> {
                self.write.prev_history(n)
            }
            /// Selects the history entry currently being edited by the user.
            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                self.write.select_history_entry(new)
            }
            /// Returns the current set of completions.
            pub fn completions(&self) -> Option<&[Completion]> {
                self.read.completions.as_ref().map(|v| &v[..])
            }
            /// Sets the current set of completions.
            pub fn set_completions(&mut self, completions: Option<Vec<Completion>>) {
                self.read.completions = completions;
            }
            /// Attempts to execute the current sequence.
            fn execute_sequence(&mut self) -> io::Result<()> {
                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided(_) => {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                }

                Ok(())
            }

            fn force_execute_sequence(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;

                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) |
                    FindResult::Undecided(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => unreachable!(),
                }

                Ok(())
            }
            /// Execute the command `SelfInsert` on the first character in the input sequence, if it is printable.
            fn insert_first_char(&mut self) -> io::Result<()> {
                let (first, rest) = {
                    let mut chars = self.read.sequence.chars();

                    (chars.next().unwrap(), chars.as_str().to_owned())
                };

                self.read.sequence.clear();

                if is::printable(first) {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command(Command::SelfInsert, n, first)?;
                }

                if !rest.is_empty() {
                    self.read.queue_input(&rest);
                }

                Ok(())
            }

            fn find_binding(&self, seq: &str) -> FindResult<Command> {
                self.read.bindings.find(seq).cloned()
            }

            fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> {
                self.read.functions.get(name)
            }

            fn is_abort(&self, ch: char) -> bool {
                let mut buf = [0; 4];
                let s = ch.encode_utf8(&mut buf);

                self.find_binding(&s) == FindResult::Found(Command::Abort)
            }

            fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()>
            {
                let mut category = cmd.category();

                if self.read.overwrite_mode 
                {
                    match cmd 
                    {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd 
                {
                    Abort => (),
                    AcceptLine => { self.accept_input()?; }
                    Complete =>
                    {
                        if !self.read.disable_completion { self.complete_word()?; } 
                        else if is::printable(ch) { self.execute_command(SelfInsert, n, ch)?; }
                    }
                    InsertCompletions =>
                    {
                        if self.read.completions.is_none() { self.build_completions(); }

                        if let Some(completions) = self.read.completions.take()
                        {
                            self.insert_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    PossibleCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.show_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    MenuComplete => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.next_completion(n as usize)?;
                        } else {
                            self.prev_completion((-n) as usize)?;
                        }
                    }
                    MenuCompleteBackward => 
                    {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.prev_completion(n as usize)?;
                        } else {
                            self.next_completion((-n) as usize)?;
                        }
                    }
                    DigitArgument => 
                    {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char(ch);
                        self.write.redraw_prompt(PromptType::Number)?;
                    }
                    SelfInsert =>
                    {
                        if n > 0
                        {
                            let n = n as usize;

                            if self.read.overwrite_mode { self.overwrite(n, ch)?; } 
                            else { self.insert(n, ch)?; }

                            if self.read.blink_matching_paren
                            {
                                if let Some(open) = get_open_paren(ch)
                                {
                                    if let Some(pos) = find_matching_paren( &self.write.buffer[..self.write.cursor], &self.read.string_chars, open, ch )
                                    {
                                        self.blink(pos)?;
                                    }
                                }
                            }
                        }
                    }
                    TabInsert => {
                        if n > 0 {
                            self.insert(n as usize, '\t')?;
                        }
                    }
                    InsertComment => {
                        if self.explicit_arg() &&
                                self.write.buffer.starts_with(&self.read.comment_begin[..]) {
                            self.write.move_to(0)?;
                            let n = self.read.comment_begin.len();

                            self.delete_range(..n)?;
                            self.accept_input()?;
                        } else {
                            self.write.move_to(0)?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str(&s)?;
                            self.accept_input()?;
                        }
                    }
                    BackwardChar => {
                        if n > 0 {
                            self.write.backward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.forward_char((-n) as usize)?;
                        }
                    }
                    ForwardChar => {
                        if n > 0 {
                            self.write.forward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.backward_char((-n) as usize)?;
                        }
                    }
                    CharacterSearch => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: false,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: true,
                            };
                        }
                    }
                    CharacterSearchBackward => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: true,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: false,
                            };
                        }
                    }
                    BackwardWord => {
                        if n > 0 {
                            self.backward_word(n as usize)?;
                        } else if n < 0 {
                            self.forward_word((-n) as usize)?;
                        }
                    }
                    ForwardWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        }
                    }
                    BackwardKillLine => {
                        let r = ..self.write.cursor;
                        self.kill_range(r)?;
                    }
                    KillLine => {
                        let r = self.write.cursor..;
                        self.kill_range(r)?;
                    }
                    BackwardKillWord => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    KillWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = backward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        }
                    }
                    UnixWordRubout => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    ClearScreen => {
                        self.write.clear_screen()?;
                    }
                    BeginningOfLine => self.write.move_to(0)?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar => {
                        if n > 0 {
                            if self.read.overwrite_mode {
                                self.overwrite_back(n as usize)?;
                            } else {
                                let pos = backward_char(n as usize,
                                    &self.write.buffer, self.write.cursor);
                                let r = pos..self.write.cursor;
                                self.delete_range(r)?;
                            }
                        } else if n < 0 {
                            let pos = forward_char((-n) as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        }
                    }
                    DeleteChar => {
                        if n > 0 {
                            let pos = forward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        } else if n < 0 {
                            let pos = backward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = pos..self.write.cursor;
                            self.delete_range(r)?;
                        }
                    }
                    TransposeChars => {
                        if n != 0 && self.write.cursor != 0 {
                            let (src, dest);

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                                let end = backward_char(1, &self.write.buffer, self.write.cursor);
                                let start = backward_char(1, &self.write.buffer, end);

                                src = start..end;
                                dest = end..self.write.cursor;
                            } else {
                                let start = backward_char(1, &self.write.buffer, self.write.cursor);
                                let end = self.write.cursor;

                                src = start..end;

                                dest = if n < 0 {
                                    let back = backward_char((-n) as usize, &self.write.buffer, start);
                                    back..start
                                } else {
                                    let fwd = forward_char(n as usize + 1, &self.write.buffer, start);
                                    end..fwd
                                };
                            }

                            self.transpose_range(src, dest)?;
                        }
                    }
                    TransposeWords => {
                        if n != 0 {
                            if let Some(first) = first_word(&self.write.buffer[..self.write.cursor], &self.read.word_break) {
                                let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                                if first != start {
                                    let (src, dest);

                                    if !self.explicit_arg() && start == self.write.buffer.len() {
                                        let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                        let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    } else {
                                        let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;

                                        dest = if n < 0 {
                                            back_n_words((-n) as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        } else {
                                            forward_n_words(n as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        };
                                    }

                                    self.transpose_range(src, dest)?;
                                }
                            }
                        }
                    }
                    BeginningOfHistory => {
                        self.select_history_entry(Some(0))?;
                    }
                    EndOfHistory => {
                        self.select_history_entry(None)?;
                    }
                    NextHistory => {
                        if n > 0 {
                            self.next_history(n as usize)?;
                        } else if n < 0 {
                            self.prev_history((-n) as usize)?;
                        }
                    }
                    PreviousHistory => {
                        if n > 0 {
                            self.prev_history(n as usize)?;
                        } else if n < 0 {
                            self.next_history((-n) as usize)?;
                        }
                    }
                    ForwardSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(false)?;
                        } else {
                            self.write.start_search_history(false)?;
                        }
                    }
                    ReverseSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(true)?;
                        } else {
                            self.write.start_search_history(true)?;
                        }
                    }
                    HistorySearchForward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(false)?;
                        } else {
                            self.write.start_history_search(false)?;
                        }
                    }
                    HistorySearchBackward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(true)?;
                        } else {
                            self.write.start_history_search(true)?;
                        }
                    }
                    QuotedInsert => {
                        self.read.state = InputState::QuotedInsert(
                            if n >= 0 { n as usize } else { 0 });
                    }
                    OverwriteMode => {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode {
                            CursorMode::Overwrite
                        } else {
                            CursorMode::Normal
                        };

                        self.write.set_cursor_mode(mode)?;
                    }
                    Yank => {
                        self.yank()?;
                    }
                    YankPop => {
                        self.yank_pop()?;
                    }
                    Custom(ref name) =>
                    {
                        if let Some(fun) = self.get_function(name).cloned()
                        {
                            fun.execute(self, n, ch)?;
                            category = fun.category();
                        }
                    }
                    Macro(ref seq) => { self.read.queue_input(seq); }
                }

                if category != Category::Digit 
                {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;

                    self.read.last_cmd = category;

                    if category != Category::Complete {
                        self.read.completions = None;
                    }

                    if category != Category::Yank {
                        self.read.last_yank = None;
                    }
                }

                Ok(())
            }
            /// Accepts the current input buffer as user input.
            pub fn accept_input(&mut self) -> io::Result<()> {
                self.write.move_to_end()?;
                self.write.write_str("\n")?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok(())
            }
            /// Moves the cursor to the given position, waits for 500 milliseconds
            /// (or until next user input), then restores the original cursor position.
            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.write.blink(pos)?;

                self.read.max_wait_duration = Some(BLINK_DURATION);

                Ok(())
            }

            fn check_expire_blink(&mut self, now: Instant) -> io::Result<()> {
                if self.write.check_expire_blink(now)? {
                    self.read.max_wait_duration = None;
                }

                Ok(())
            }

            fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()> {
                if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state {
                    if now >= expiry {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok(())
            }

            fn keyseq_expiry(&mut self) -> Option<Instant> {
                if let Some(t) = self.read.keyseq_timeout {
                    self.read.max_wait_duration = Some(t);
                    Some(Instant::now() + t)
                } else {
                    None
                }
            }

            pub fn check_expire_timeout(&mut self) -> io::Result<()> {
                let now = Instant::now();

                self.check_expire_blink(now)?;
                self.check_expire_sequence(now)
            }

            fn expire_blink(&mut self) -> io::Result<()> {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions(&mut self) {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start(&self.write.buffer, end, self);

                if start > end {
                    panic!("Completer::word_start returned invalid index; \
                        start > end ({} > {})", start, end);
                }

                let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();

                let completions = compl.complete(&unquoted, self, start, end);
                let n_completions = completions.as_ref().map_or(0, |c| c.len());

                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word(&mut self) -> io::Result<()> {
                if let Some(completions) = self.read.completions.take() {
                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else {
                        self.show_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                } else {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else if !completions.is_empty() {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;

                        {
                            let pfx = longest_common_prefix(completions.iter()
                                .map(|compl| &compl.completion[..]))
                                .unwrap_or_default();
                            self.replace_str_forward(start..end, &pfx)?;
                        }

                        self.read.completions = Some(completions);
                    }
                }

                Ok(())
            }

            fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()> {
                let mut s = self.read.completer.quote(&compl.completion);

                if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character) {
                    s.to_mut().push(suffix);
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward(start..end, &s)
            }

            fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                let mut words = String::new();

                for compl in completions {
                    words.push_str(&self.read.completer.unquote(&compl.completion));
                    words.push(' ');
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;

                self.replace_str_forward(start..end, &words)
            }

            fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                if completions.is_empty() {
                    return Ok(());
                }

                let eff_width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);

                let completions = completions.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, eff_width,
                    self.read.print_completions_horizontally);
                let table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                self.write.write_str("\n")?;

                let n_completions = completions.len();

                if self.read.page_completions &&
                        n_completions >= self.read.completion_query_items {
                    self.start_page_completions(n_completions)
                } else {
                    self.show_list_completions(table)?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()> {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
            }

            fn end_page_completions(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions(&self) -> bool {
                match self.read.state {
                    InputState::CompleteMore(_) => true,
                    _ => false
                }
            }

            fn show_completions_page(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let n_lines = self.write.screen_size.lines - 1;

                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    for row in table.by_ref().skip(offset).take(n_lines) {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + n_lines);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completions_line(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    if let Some(row) = table.by_ref().skip(offset).next() {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + 1);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()> {
                let mut space = 0;

                for (width, name) in line {
                    self.write.move_right(space)?;
                    self.write.write_str(name)?;
                    space = width - name.chars().count();
                }

                self.write.write_str("\n")
            }

            fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()> {
                for line in table {
                    let mut space = 0;

                    for (width, name) in line {
                        self.write.move_right(space)?;
                        self.write.write_str(name)?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str("\n")?;
                }

                Ok(())
            }

            fn next_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = (old + n) % max;

                if old != new {
                    self.set_completion(new)?;
                }

                Ok(())
            }

            fn prev_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old {
                    max - old - n
                } else {
                    old - n
                };

                self.set_completion(new)
            }

            fn set_completion(&mut self, new: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let old = self.read.completion_index;

                if old != new {
                    self.read.completion_index = new;

                    if new == len {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range(start..end)?;
                    } else {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion(self.read.completion_append_character).into_owned();

                        self.replace_str_forward(start..end, &s)?;
                    }
                }

                Ok(())
            }

            fn abort_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.expire_blink()?;

                if self.is_paging_completions() {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt(p)
            }

            pub fn handle_signal(&mut self, signal: Signal) -> io::Result<()> {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => {
                        self.write.draw_prompt()?;
                    }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters {
                            self.write.write_str("^C")?;
                        }

                        self.write.write_str("\n")?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok(())
            }

            fn backward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }

            fn forward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }
            /// Deletes a range of text from the input buffer.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                self.write.delete_range(range)
            }
            /// Deletes a range from the buffer and adds the removed text to the kill ring.
            pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring(buf);
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring(buf);
                    } else {
                        self.append_kill_ring(buf);
                    }

                    self.delete_range(start..end)?;
                }

                Ok(())
            }

            fn push_kill_ring(&mut self, s: String) {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() {
                    self.read.kill_ring.pop_back();
                }
                self.read.kill_ring.push_front(s);
            }

            fn rotate_kill_ring(&mut self) {
                if let Some(kill) = self.read.kill_ring.pop_front() {
                    self.read.kill_ring.push_back(kill);
                }
            }

            fn append_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.push_str(&s);
                    return;
                }
                self.push_kill_ring(s);
            }

            fn prepend_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.insert_str(0, &s);
                    return;
                }
                self.push_kill_ring(s);
            }
            /// Transposes two regions of the buffer, `src` and `dest`.
            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                self.write.transpose_range(src, dest)
            }
            /// Insert text from the front of the kill ring at the current cursor position.
            pub fn yank(&mut self) -> io::Result<()> {
                if let Some(kill) = self.read.kill_ring.front().cloned() {
                    let start = self.write.cursor;
                    self.read.last_yank = Some((start, start + kill.len()));

                    self.insert_str(&kill)?;
                }

                Ok(())
            }
            /// Rotates the kill ring and replaces yanked text with the new front.
            pub fn yank_pop(&mut self) -> io::Result<()> {
                if let Some((start, end)) = self.read.last_yank {
                    self.rotate_kill_ring();

                    if let Some(kill) = self.read.kill_ring.front().cloned() {
                        self.read.last_yank = Some((start, start + kill.len()));

                        self.write.move_to(start)?;
                        self.replace_str_forward(start..end, &kill)?;
                    }
                }

                Ok(())
            }
            /// Overwrite `n` characters; assumes `n >= 1`
            fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()> {
                let start = self.write.cursor;
                let end = forward_char(n, &self.write.buffer, start);

                {
                    let over = &self.write.buffer[start..end];
                    let n_chars = over.chars().count();

                    if n > n_chars {
                        self.read.overwritten_append += n - n_chars;
                    }

                    if !over.is_empty() {
                        self.read.overwritten_chars.push_str(&over);
                    }
                }

                let s = repeat_char(ch, n);
                self.replace_str_forward(start..end, &s)
            }

            fn overwrite_back(&mut self, mut n: usize) -> io::Result<()> {
                if self.read.overwritten_append != 0 {
                    let n_del = n.min(self.read.overwritten_append);

                    let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                    let r = pos..self.write.cursor;
                    self.delete_range(r)?;

                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty() {
                    let n_repl = n.min(self.read.overwritten_chars.chars().count());

                    let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);

                    let over_pos = backward_char(n_repl,
                        &self.read.overwritten_chars, self.read.overwritten_chars.len());

                    let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();

                    let r = pos..self.write.cursor;
                    self.replace_str_backward(r, &over)?;

                    n -= n_repl;
                }

                if n != 0 {
                    self.write.backward_char(n)?;
                }

                Ok(())
            }
            /// Insert a given character at the current cursor position `n` times.
            pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()> {
                if n != 0 {
                    let s = repeat_char(ch, n);
                    self.insert_str(&s)?;
                }

                Ok(())
            }
            /// Insert a string at the current cursor position.
            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                self.write.insert_str(s)
            }
            /// Replaces a range in the buffer and redraws.
            pub fn replace_str_backward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }
            /// Replaces a range in the buffer and redraws.
            pub fn replace_str_forward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }
            /// Replaces a range in the buffer and redraws.
            fn replace_str_impl<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                self.write.move_to(start)?;

                let _ = self.write.buffer.drain(start..end);
                let cursor = self.write.cursor;
                self.write.buffer.insert_str(cursor, s);

                self.write.draw_buffer(cursor)?;
                self.write.clear_to_screen_end()
            }
        }
    } pub use self::prompter::{ * };

    pub mod reader
    {
        use ::
        {
            borrow::Cow,
            collections::{HashMap, VecDeque},
            mem::replace,
            ops::{Deref, DerefMut},
            path::{Path, PathBuf},
            regex::{ match_name },
            sync::{Arc, MutexGuard},
            system::{ * },
            time::{ Duration, Instant },
            *,
        };
        /*
        use mortal::SequenceMap;
        use linefeed::command::{Category, Command};
        use linefeed::complete::{Completer, Completion, DummyCompleter};
        use linefeed::function::Function;
        use linefeed::inputrc::{parse_file, Directive};
        use linefeed::interface::Interface;
        use linefeed::prompter::Prompter;
        use linefeed::sys::path::{env_init_file, system_init_file, user_init_file};
        use linefeed::terminal::{
            RawRead, Signal, SignalSet, Size, TerminalReader,
        };
        use linefeed::util::{first_char, match_name};
        use linefeed::variables::{Variable, Variables, VariableIter}; */
        /// Default set of string characters
        pub const STRING_CHARS: &str = "\"'";
        /// Default set of word break characters
        pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";
        /// Indicates the start of a series of invisible characters in the prompt
        pub const START_INVISIBLE: char = '\x01';
        /// Indicates the end of a series of invisible characters in the prompt
        pub const END_INVISIBLE: char = '\x02';
        /// Maximum size of kill ring
        const MAX_KILLS: usize = 10;
        /// Provides access to data related to reading and processing user input.
        pub struct Reader<'a, Term: 'a + Terminals> 
        {
            iface: &'a Interface<Term>,
            lock: ReadLock<'a, Term>,
        }

        pub struct Read<Term: Terminals> 
        {
            /// Application name
            pub application: Cow<'static, str>,

            /// Pending input
            pub input_buffer: Vec<u8>,
            /// Pending macro sequence
            pub macro_buffer: String,

            pub bindings: SequenceMap<Cow<'static, str>, Command>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,

            /// Current input sequence
            pub sequence: String,
            /// Whether newline has been received
            pub input_accepted: bool,

            /// Whether overwrite mode is currently active
            pub overwrite_mode: bool,
            /// Characters appended while in overwrite mode
            pub overwritten_append: usize,
            /// Characters overwritten in overwrite mode
            pub overwritten_chars: String,

            /// Configured completer
            pub completer: Arc<dyn Completer<Term>>,
            /// Character appended to completions
            pub completion_append_character: Option<char>,
            /// Current set of possible completions
            pub completions: Option<Vec<Completion>>,
            /// Current "menu-complete" entry being viewed:
            pub completion_index: usize,
            /// Start of the completed word
            pub completion_start: usize,
            /// Start of the inserted prefix of a completed word
            pub completion_prefix: usize,

            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,

            pub last_cmd: Category,
            pub last_yank: Option<(usize, usize)>,
            pub kill_ring: VecDeque<String>,

            pub catch_signals: bool,
            pub ignore_signals: SignalSet,
            pub report_signals: SignalSet,
            pub last_resize: Option<Size>,
            pub last_signal: Option<Signal>,

            variables: Variables,

            pub state: InputState,
            pub max_wait_duration: Option<Duration>,
        }

        pub struct ReadLock<'a, Term: 'a + Terminals> 
        {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }
        /// Returned from [`read_line`] to indicate user input
        #[derive(Debug)]
        pub enum ReadResult 
        {
            /// User issued end-of-file
            Eof,
            /// User input received
            Input(String),
            /// Reported signal was received
            Signal(Signal),
        }

        #[derive(Copy, Clone, Debug)]
        pub enum InputState 
        {
            Inactive,
            NewSequence,
            ContinueSequence{
                expiry: Option<Instant>,
            },
            Number,
            CharSearch{
                n: usize,
                backward: bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore(usize),
            QuotedInsert(usize),
        }

        impl<'a, Term: 'a + Terminals> Reader<'a, Term> 
        {
            pub fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>)
                    -> Reader<'a, Term> {
                Reader{iface, lock}
            }
            /// Interactively reads a line from the terminal device.
            pub fn read_line(&mut self) -> io::Result<ReadResult> {
                loop {
                    if let Some(res) = self.read_line_step(None)? {
                        return Ok(res);
                    }
                }
            }
            /// Performs one step of the interactive `read_line` loop.
            pub fn read_line_step(&mut self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.initialize_read_line()?;

                let state = self.prepare_term()?;
                let res = self.read_line_step_impl(timeout);
                self.lock.term.restore(state)?;

                res
            }
            /// Cancels an in-progress `read_line` operation.
            pub fn cancel_read_line(&mut self) -> io::Result<()> {
                self.end_read_line()
            }

            fn initialize_read_line(&mut self) -> io::Result<()> {
                if !self.lock.is_active() {
                    self.prompter().start_read_line()?;
                }
                Ok(())
            }

            fn read_line_step_impl(&mut self, timeout: Option<Duration>) -> io::Result<Option<ReadResult>>
            {
                let do_read = if self.lock.is_input_available()
                {
                    self.lock.term.wait_for_input(Some(Duration::new(0,0)))?
                } else {
                    let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                    self.lock.term.wait_for_input(timeout)?
                };

                if do_read {
                    self.lock.read_input()?;
                }

                if let Some(size) = self.lock.take_resize() {
                    self.handle_resize(size)?;
                }

                if let Some(sig) = self.lock.take_signal() {
                    if self.lock.report_signals.contains(sig) {
                        return Ok(Some(ReadResult::Signal(sig)));
                    }
                    if !self.lock.ignore_signals.contains(sig) {
                        self.handle_signal(sig)?;
                    }
                }
                // Acquire the write lock and process all available input
                {
                    let mut prompter = self.prompter();

                    prompter.check_expire_timeout()?;
                    let mut macro_len = prompter.read.data.macro_buffer.len();

                    while prompter.read.is_input_available() {
                        if let Some(ch) = prompter.read.read_char()? {
                            if let Some(r) = prompter.handle_input(ch)? {
                                prompter.end_read_line()?;
                                return Ok(Some(r));
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len {
                            break;
                        }

                        macro_len = new_macro_len;
                    }
                }

                Ok(None)
            }

            fn end_read_line(&mut self) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().end_read_line()?;
                }
                Ok(())
            }

            fn prepare_term(&mut self) -> io::Result<Term::PrepareState> {
                if self.read_next_raw() {
                    self.lock.term.prepare(true, SignalSet::new())
                } else {
                    let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);

                    if self.lock.catch_signals {
                        signals.insert(Signal::Interrupt);
                    }

                    let block_signals = !self.lock.catch_signals;

                    self.lock.term.prepare(block_signals, signals)
                }
            }

            fn read_next_raw(&self) -> bool {
                match self.lock.state {
                    InputState::QuotedInsert(_) => true,
                    _ => false
                }
            }
            /// Sets the input buffer to the given string.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_buffer(buf)
                } else {
                    self.iface.lock_write_data().set_buffer(buf);
                    Ok(())
                }
            }
            /// Sets the cursor position in the input buffer.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_cursor(pos)
                } else {
                    self.iface.lock_write_data().set_cursor(pos);
                    Ok(())
                }
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.prompter().set_prompt(prompt)
            }
            /// Adds a line to history.
            pub fn add_history(&self, line: String) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history(line);
                }
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique(&self, line: String) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history_unique(line);
                }
            }
            /// Removes all history entries.
            pub fn clear_history(&self) {
                if !self.lock.is_active() {
                    self.iface.lock_write().clear_history();
                }
            }
            /// Removes the history entry at the given index.
            pub fn remove_history(&self, idx: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().remove_history(idx);
                }
            }
            /// Sets the maximum number of history entries.
            pub fn set_history_size(&self, n: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().set_history_size(n);
                }
            }
            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history(&self, n: usize) {
                if !self.lock.is_active() {
                    self.iface.lock_write().truncate_history(n);
                }
            }
            /// Returns the application name
            pub fn application(&self) -> &str {
                &self.lock.application
            }
            /// Sets the application name
            pub fn set_application<T>(&mut self, application: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.application = application.into();
            }
            /// Returns a reference to the current completer instance.
            pub fn completer(&self) -> &Arc<dyn Completer<Term>> {
                &self.lock.completer
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                replace(&mut self.lock.completer, completer)
            }
            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock.get_variable(name)
            }
            /// Sets the value of the named variable and returns the previous
            /// value.
            pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable> {
                self.lock.set_variable(name, value)
            }
            /// Returns an iterator over stored variables.
            pub fn variables(&self) -> VariableIter {
                self.lock.variables.iter()
            }
            /// Returns whether to "blink" matching opening parenthesis character
            /// when a closing parenthesis character is entered.
            pub fn blink_matching_paren(&self) -> bool {
                self.lock.blink_matching_paren
            }
            /// Sets the `blink-matching-paren` variable.
            pub fn set_blink_matching_paren(&mut self, set: bool) {
                self.lock.blink_matching_paren = set;
            }
            /// Returns whether `linefeed` will catch certain signals.
            pub fn catch_signals(&self) -> bool {
                self.lock.catch_signals
            }
            /// Sets whether `linefeed` will catch certain signals.
            pub fn set_catch_signals(&mut self, enabled: bool) {
                self.lock.catch_signals = enabled;
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock.ignore_signals.contains(signal)
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&mut self, signal: Signal, set: bool) {
                if set {
                    self.lock.ignore_signals.insert(signal);
                    self.lock.report_signals.remove(signal);
                } else {
                    self.lock.ignore_signals.remove(signal);
                }
            }
            /// Returns whether the given `Signal` is to be reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock.report_signals.contains(signal)
            }
            /// Sets whether to report the given `Signal`.
            pub fn set_report_signal(&mut self, signal: Signal, set: bool) {
                if set {
                    self.lock.report_signals.insert(signal);
                    self.lock.ignore_signals.remove(signal);
                } else {
                    self.lock.report_signals.remove(signal);
                }
            }
            /// Returns whether Tab completion is disabled.
            pub fn disable_completion(&self) -> bool {
                self.lock.disable_completion
            }
            /// Sets the `disable-completion` variable.
            pub fn set_disable_completion(&mut self, disable: bool) {
                self.lock.disable_completion = disable;
            }
            /// When certain control characters are pressed, a character sequence
            /// equivalent to this character will be echoed.
            pub fn echo_control_characters(&self) -> bool {
                self.lock.echo_control_characters
            }
            /// Sets the `echo-control-characters` variable.
            pub fn set_echo_control_characters(&mut self, echo: bool) {
                self.lock.echo_control_characters = echo;
            }
            /// Returns the character, if any, that is appended to a successful completion.
            pub fn completion_append_character(&self) -> Option<char> {
                self.lock.completion_append_character
            }
            /// Sets the character, if any, that is appended to a successful completion.
            pub fn set_completion_append_character(&mut self, ch: Option<char>) {
                self.lock.completion_append_character = ch;
            }
            /// Returns the width of completion listing display.
            pub fn completion_display_width(&self) -> usize {
                self.lock.completion_display_width
            }
            /// Sets the `completion-display-width` variable.
            pub fn set_completion_display_width(&mut self, n: usize) {
                self.lock.completion_display_width = n;
            }
            /// Returns the minimum number of completion items that require user
            /// confirmation before listing.
            pub fn completion_query_items(&self) -> usize {
                self.lock.completion_query_items
            }
            /// Sets the `completion-query-items` variable.
            pub fn set_completion_query_items(&mut self, n: usize) {
                self.lock.completion_query_items = n;
            }
            /// Returns the timeout to wait for further user input when an ambiguous
            /// sequence has been entered.
            pub fn keyseq_timeout(&self) -> Option<Duration> {
                self.lock.keyseq_timeout
            }
            /// Sets the `keyseq-timeout` variable.
            pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>) {
                self.lock.keyseq_timeout = timeout;
            }
            /// Returns whether to list possible completions one page at a time.
            pub fn page_completions(&self) -> bool {
                self.lock.page_completions
            }
            /// Sets the `page-completions` variable.
            pub fn set_page_completions(&mut self, set: bool) {
                self.lock.page_completions = set;
            }
            /// Returns whether to list completions horizontally, rather than down
            /// the screen.
            pub fn print_completions_horizontally(&self) -> bool {
                self.lock.print_completions_horizontally
            }
            /// Sets the `print-completions-horizontally` variable.
            pub fn set_print_completions_horizontally(&mut self, set: bool) {
                self.lock.print_completions_horizontally = set;
            }
            /// Returns the set of characters that delimit strings.
            pub fn string_chars(&self) -> &str {
                &self.lock.string_chars
            }
            /// Sets the set of characters that delimit strings.
            pub fn set_string_chars<T>(&mut self, chars: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.string_chars = chars.into();
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str {
                &self.lock.word_break
            }
            /// Sets the set of characters that indicate a word break.
            pub fn set_word_break_chars<T>(&mut self, chars: T)
                    where T: Into<Cow<'static, str>> {
                self.lock.word_break = chars.into();
            }
            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.lock.bindings()
            }
            /// Binds a sequence to a command.
            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence(seq, cmd)
            }
            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence_if_unbound(seq, cmd)
            }
            /// Removes a binding for the given sequence.
            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
                self.lock.unbind_sequence(seq)
            }
            /// Defines a named function to which sequences may be bound.
            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock.define_function(name, cmd)
            }
            /// Removes a function defined with the given name.
            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock.remove_function(name)
            }

            pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
                self.lock.data.evaluate_directives(term, dirs)
            }

            pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
                self.lock.data.evaluate_directive(term, dir)
            }

            fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term> {
                Prompter::new(
                    &mut self.lock,
                    self.iface.lock_write())
            }

            fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.prompter().handle_resize(size)
            }

            fn handle_signal(&mut self, sig: Signal) -> io::Result<()> {
                self.prompter().handle_signal(sig)
            }
        }

        impl<'a, Term: 'a + Terminals> ReadLock<'a, Term> 
        {
            pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>)
                    -> ReadLock<'a, Term> {
                ReadLock{term, data}
            }
            /// Reads the next character of input.
            pub fn read_char(&mut self) -> io::Result<Option<char>> {
                if let Some(ch) = self.macro_pop() {
                    Ok(Some(ch))
                } else if let Some(ch) = self.decode_input()? {
                    Ok(Some(ch))
                } else {
                    Ok(None)
                }
            }

            fn read_input(&mut self) -> io::Result<()> {
                match self.term.read(&mut self.data.input_buffer)? {
                    RawRead::Bytes(_) => (),
                    RawRead::Resize(new_size) => {
                        self.last_resize = Some(new_size);
                    }
                    RawRead::Signal(sig) => {
                        self.last_signal = Some(sig);
                    }
                }

                Ok(())
            }

            fn is_input_available(&self) -> bool {
                !self.data.macro_buffer.is_empty() || match self.peek_input() {
                    Ok(Some(_)) | Err(_) => true,
                    Ok(None) => false
                }
            }

            fn macro_pop(&mut self) -> Option<char> {
                if self.data.macro_buffer.is_empty() {
                    None
                } else {
                    Some(self.data.macro_buffer.remove(0))
                }
            }

            fn decode_input(&mut self) -> io::Result<Option<char>> {
                let res = self.peek_input();

                if let Ok(Some(ch)) = res {
                    self.data.input_buffer.drain(..ch.len_utf8());
                }

                res
            }

            fn peek_input(&self) -> io::Result<Option<char>> {
                if self.data.input_buffer.is_empty() {
                    Ok(None)
                } else {
                    first_char(&self.data.input_buffer)
                }
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminals> Deref for ReadLock<'a, Term> 
        {
            type Target = Read<Term>;

            fn deref(&self) -> &Read<Term> {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminals> DerefMut for ReadLock<'a, Term> 
        {
            fn deref_mut(&mut self) -> &mut Read<Term> {
                &mut self.data
            }
        }

        impl<Term: Terminals> Deref for Read<Term> 
        {
            type Target = Variables;

            fn deref(&self) -> &Variables {
                &self.variables
            }
        }

        impl<Term: Terminals> DerefMut for Read<Term> 
        {
            fn deref_mut(&mut self) -> &mut Variables {
                &mut self.variables
            }
        }

        impl<Term: Terminals> Read<Term> 
        {
            pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term> 
            {
                let mut r = Read{
                    application,

                    bindings: default_bindings(),
                    functions: HashMap::new(),

                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),

                    sequence: String::new(),
                    input_accepted: false,

                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),

                    completer: Arc::new(DummyCompleter),
                    completion_append_character: Some(' '),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,

                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),

                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity(MAX_KILLS),

                    catch_signals: true,
                    ignore_signals: SignalSet::new(),
                    report_signals: SignalSet::new(),
                    last_resize: None,
                    last_signal: None,

                    variables: Variables::default(),

                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init(term);
                r
            }

            pub fn bindings(&self) -> BindingIter 
            {
                BindingIter(self.bindings.sequences().iter())
            }

            pub fn variables(&self) -> VariableIter 
            {
                self.variables.iter()
            }

            fn take_resize(&mut self) -> Option<Size> 
            {
                self.last_resize.take()
            }

            fn take_signal(&mut self) -> Option<Signal> 
            {
                self.last_signal.take()
            }

            pub fn queue_input(&mut self, seq: &str) 
            {
                self.macro_buffer.insert_str(0, seq);
            }

            pub fn is_active(&self) -> bool 
            {
                match self.state 
                {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data(&mut self) 
            {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();

                self.completions = None;

                self.last_cmd = Category::Other;
                self.last_yank = None;

                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.bindings.insert(seq.into(), cmd)
            }

            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool where 
            T:Into<Cow<'static, str>> 
            {
                // use ::sequence::Entry;
                match self.bindings.entry(seq.into())
                {
                    Entry::Occupied(_) => false,
                    Entry::Vacant(ent) =>
                    {
                        ent.insert(cmd);
                        true
                    }
                }
            }

            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> 
            {
                self.bindings.remove(seq)
                    .map(|(_, cmd)| cmd)
            }

            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>) -> Option<Arc<dyn Function<Term>>> where 
            T: Into<Cow<'static, str>>
            { self.functions.insert(name.into(), cmd) }

            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> 
            {
                self.functions.remove(name)
            }

            fn read_init(&mut self, term: &Term) 
            {
                if let Some(path) = sys::env_init_file() { self.read_init_file_if_exists(term, Some(path)); } 
                else { if !self.read_init_file_if_exists(term, sys::user_init_file()) { self.read_init_file_if_exists(term, sys::system_init_file()); } }
            }

            fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool 
            {
                match path {
                    Some(ref path) if path.exists() => {
                        self.read_init_file(term, path);
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file(&mut self, term: &Term, path: &Path) 
            {
                if let Some(dirs) = parse_file(path) {
                    self.evaluate_directives(term, dirs);
                }
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) 
            {
                for dir in dirs {
                    self.evaluate_directive(term, dir);
                }
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&mut self, term: &Term, dir: Directive) 
            {
                match dir 
                {
                    Directive::Bind(seq, cmd) => { self.bind_sequence(seq, cmd); }
                    Directive::Conditional{name, value, then_group, else_group} =>
                    {
                        let name = name.as_ref().map(|s| &s[..]);

                        if self.eval_condition(term, name, &value) { self.evaluate_directives(term, then_group); }
                        else { self.evaluate_directives(term, else_group); }
                    }
                    Directive::SetVariable(name, value) => { self.set_variable(&name, &value); }
                }
            }

            fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool 
            {
                match name 
                {
                    None => self.application == value,
                    Some("lib") => value == "linefeed",
                    Some("mode") => value == "emacs",
                    Some("term") => self.term_matches(term, value),
                    _ => false
                }
            }

            fn term_matches(&self, term: &Term, value: &str) -> bool { match_name( term.name(), value ) }
        }
        /// Iterator over `Reader` bindings
        pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a> 
        {
            type Item = (&'a str, &'a Command);

            #[inline] fn next(&mut self) -> Option<Self::Item> {
                self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline] fn nth(&mut self, n: usize) -> Option<Self::Item> {
                self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a> 
        {
            #[inline] fn next_back(&mut self) -> Option<Self::Item> {
                self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }
        }

        fn default_bindings() -> SequenceMap<Cow<'static, str>, Command> 
        {
            use ::system::Command::{ * };
            SequenceMap::from(vec!
            [
                // Carriage return and line feed
                ("\r".into(), AcceptLine),
                ("\n".into(), AcceptLine),
                // Possible sequences for arrow keys, Home, End
                ("\x1b[A".into(), PreviousHistory),
                ("\x1b[B".into(), NextHistory),
                ("\x1b[C".into(), ForwardChar),
                ("\x1b[D".into(), BackwardChar),
                ("\x1b[H".into(), BeginningOfLine),
                ("\x1b[F".into(), EndOfLine),
                // More possible sequences for arrow keys, Home, End
                ("\x1bOA".into(), PreviousHistory),
                ("\x1bOB".into(), NextHistory),
                ("\x1bOC".into(), ForwardChar),
                ("\x1bOD".into(), BackwardChar),
                ("\x1bOH".into(), BeginningOfLine),
                ("\x1bOF".into(), EndOfLine),
                // Possible sequences for Insert, Delete
                ("\x1b[2~".into(), OverwriteMode),
                ("\x1b[3~".into(), DeleteChar),
                // Basic commands
                ("\x01"    .into(), BeginningOfLine),           // Ctrl-A
                ("\x02"    .into(), BackwardChar),              // Ctrl-B
                ("\x04"    .into(), DeleteChar),                // Ctrl-D
                ("\x05"    .into(), EndOfLine),                 // Ctrl-E
                ("\x06"    .into(), ForwardChar),               // Ctrl-F
                ("\x07"    .into(), Abort),                     // Ctrl-G
                ("\x08"    .into(), BackwardDeleteChar),        // Ctrl-H
                ("\x0b"    .into(), KillLine),                  // Ctrl-K
                ("\x0c"    .into(), ClearScreen),               // Ctrl-L
                ("\x0e"    .into(), NextHistory),               // Ctrl-N
                ("\x10"    .into(), PreviousHistory),           // Ctrl-P
                ("\x12"    .into(), ReverseSearchHistory),      // Ctrl-R
                ("\x14"    .into(), TransposeChars),            // Ctrl-T
                ("\x15"    .into(), BackwardKillLine),          // Ctrl-U
                ("\x16"    .into(), QuotedInsert),              // Ctrl-V
                ("\x17"    .into(), UnixWordRubout),            // Ctrl-W
                ("\x19"    .into(), Yank),                      // Ctrl-Y
                ("\x1d"    .into(), CharacterSearch),           // Ctrl-]
                ("\x7f"    .into(), BackwardDeleteChar),        // Rubout
                ("\x1b\x08".into(), BackwardKillWord),          // Escape, Ctrl-H
                ("\x1b\x1d".into(), CharacterSearchBackward),   // Escape, Ctrl-]
                ("\x1b\x7f".into(), BackwardKillWord),          // Escape, Rubout
                ("\x1bb"   .into(), BackwardWord),              // Escape, b
                ("\x1bd"   .into(), KillWord),                  // Escape, d
                ("\x1bf"   .into(), ForwardWord),               // Escape, f
                ("\x1bt"   .into(), TransposeWords),            // Escape, t
                ("\x1by"   .into(), YankPop),                   // Escape, y
                ("\x1b#"   .into(), InsertComment),             // Escape, #
                ("\x1b<"   .into(), BeginningOfHistory),        // Escape, <
                ("\x1b>"   .into(), EndOfHistory),              // Escape, >
                // Completion commands
                ("\t"   .into(), Complete),             // Tab
                ("\x1b?".into(), PossibleCompletions),  // Escape, ?
                ("\x1b*".into(), InsertCompletions),    // Escape, *
                // Digit commands
                ("\x1b-".into(), DigitArgument),    // Escape, -
                ("\x1b0".into(), DigitArgument),    // Escape, 0
                ("\x1b1".into(), DigitArgument),    // Escape, 1
                ("\x1b2".into(), DigitArgument),    // Escape, 2
                ("\x1b3".into(), DigitArgument),    // Escape, 3
                ("\x1b4".into(), DigitArgument),    // Escape, 4
                ("\x1b5".into(), DigitArgument),    // Escape, 5
                ("\x1b6".into(), DigitArgument),    // Escape, 6
                ("\x1b7".into(), DigitArgument),    // Escape, 7
                ("\x1b8".into(), DigitArgument),    // Escape, 8
                ("\x1b9".into(), DigitArgument),    // Escape, 9
            ])
        }

        fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration> 
        {
            match (dur, max) 
            {
                (dur, None) | (None, dur) => dur,
                (Some(dur), Some(max)) => Some(dur.min(max)),
            }
        }
    } pub use self::reader::{ * };
    
    pub mod screen
    {
        //! Provides a drawable buffer on terminal devices
        use ::
        {
            sync::{ LockResult, map_lock_result, map_try_lock_result, TryLockResult },
            system::{ * },
            time::{ Duration },
            *,
        };
        /*
        use mortal::sys;
        use mortal::terminal::
        {
            Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style, Theme,
            Terminal,
        }
        */
        /// Provides operations on an underlying terminal device in screen mode.
        pub struct Screen(sys::Screen);

        impl Screen 
        {
            /// Opens a new screen interface on `stdout`.
            pub fn new(config: PrepareConfig) -> io::Result<Screen> {
                sys::Screen::stdout(config).map(Screen)
            }
            /// Opens a new screen interface on `stderr`.
            pub fn stderr(config: PrepareConfig) -> io::Result<Screen> {
                sys::Screen::stderr(config).map(Screen)
            }
            /// Begins a new screen session using the given `Terminal` instance.
            pub fn with_terminal(term: Terminal, config: PrepareConfig) -> io::Result<Screen> {
                sys::Screen::new(term.0, config).map(Screen)
            }
            /// Returns the name of the terminal.
            /*#[inline] pub fn name(&self) -> &str
            {
                self.0.name()
            } */
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<ScreenReadGuard> 
            {
                map_lock_result(self.0.lock_read(), ScreenReadGuard)
            }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> {
                map_lock_result(self.0.lock_write(), ScreenWriteGuard)
            }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> {
                map_try_lock_result(self.0.try_lock_read(), ScreenReadGuard)
            }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> {
                map_try_lock_result(self.0.try_lock_write(), ScreenWriteGuard)
            }
        }
        /// # Locking
        /// The following methods internally acquire the read lock.
        impl Screen 
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                self.0.wait_event(timeout)
            }
            /// Reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>  {
                self.0.read_event(timeout)
            }
        }
        /// # Locking
        /// The following methods internally acquire the write lock.
        impl Screen 
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size {
                self.0.size()
            }
            /// Returns the current cursor position.
            #[inline] pub fn cursor(&self) -> Cursor {
                self.0.cursor()
            }
            /// Sets the cursor position.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&self, pos: C) {
                self.0.set_cursor(pos.into());
            }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn next_line(&self, column: usize) {
                self.0.next_line(column);
            }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode)
            }
            /// Clears the internal screen buffer.
            pub fn clear_screen(&self) {
                self.0.clear_screen();
            }
            /// Adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&self, style: Style) {
                self.0.add_style(style);
            }
            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn remove_style(&self, style: Style) {
                self.0.remove_style(style);
            }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&self, style: S) {
                self.0.set_style(style.into().unwrap_or_default());
            }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) {
                self.0.set_fg(fg.into());
            }
            /// Sets or removes background text color.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) {
                self.0.set_bg(bg.into());
            }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&self, theme: Theme) {
                self.0.set_theme(theme)
            }
            /// Removes color and style attributes.
            #[inline] pub fn clear_attributes(&self) {
                self.0.clear_attributes();
            }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&self) {
                self.add_style(Style::BOLD);
            }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&self) {
                self.add_style(Style::ITALIC);
            }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&self) {
                self.add_style(Style::UNDERLINE);
            }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&self) {
                self.add_style(Style::REVERSE);
            }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&self) -> io::Result<()> {
                self.0.refresh()
            }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&self, position: C, text: &str)
                    where C: Into<Cursor> {
                self.0.write_at(position.into(), text);
            }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text);
            }
            /// Writes text with the given attributes at the given position within
            /// the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&self, position: C,
                    fg: F, bg: B, style: S, text: &str) where
                    C: Into<Cursor>,
                    F: Into<Option<Color>>,
                    B: Into<Option<Color>>,
                    S: Into<Option<Style>>,
                    {
                self.0.write_styled_at(position.into(),
                    fg.into(), bg.into(), style.into().unwrap_or_default(), text);
            }
            /// Writes a single character at the cursor position
            /// using the current style and color settings.
            pub fn write_char(&self, ch: char) {
                self.0.write_char(ch);
            }
            /// Writes a string at the cursor position
            /// using the current style and color settings.
            pub fn write_str(&self, s: &str) {
                self.0.write_str(s);
            }
            /// Writes formatted text at the cursor position
            /// using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments) {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)]
            pub fn borrow_term_write_guard(&self) -> ScreenWriteGuard {
                self.lock_write().unwrap()
            }
        }
        /// Holds an exclusive lock for read operations on a `Screen`
        pub struct ScreenReadGuard<'a>(sys::ScreenReadGuard<'a>);
        /// Holds an exclusive lock for write operations on a `Screen`
        pub struct ScreenWriteGuard<'a>(sys::ScreenWriteGuard<'a>);

        impl<'a> ScreenReadGuard<'a> 
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                self.0.wait_event(timeout)
            }
            /// Reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_event(timeout)
            }
        }

        impl<'a> ScreenWriteGuard<'a> 
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size {
                self.0.size()
            }
            /// Sets the cursor position.
            #[inline] pub fn cursor(&self) -> Cursor {
                self.0.cursor()
            }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&mut self, pos: C) {
                self.0.set_cursor(pos.into());
            }
            /// Set the current cursor mode.
            #[inline] pub fn next_line(&mut self, column: usize) {
                self.0.next_line(column);
            }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode)
            }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn clear_screen(&mut self) {
                self.0.clear_screen();
            }
            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&mut self, style: Style) {
                self.0.add_style(style)
            }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn remove_style(&mut self, style: Style) {
                self.0.remove_style(style)
            }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&mut self, style: S) {
                self.0.set_style(style.into().unwrap_or_default())
            }
            /// Sets or removes background text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) {
                self.0.set_fg(fg.into())
            }
            /// Removes color and style attributes.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) {
                self.0.set_bg(bg.into())
            }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&mut self, theme: Theme) {
                self.0.set_theme(theme)
            }
            /// Adds bold to the current style setting.
            #[inline] pub fn clear_attributes(&mut self) {
                self.0.clear_attributes()
            }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&mut self) {
                self.add_style(Style::BOLD)
            }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&mut self) {
                self.add_style(Style::ITALIC);
            }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&mut self) {
                self.add_style(Style::UNDERLINE)
            }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&mut self) {
                self.add_style(Style::REVERSE)
            }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&mut self) -> io::Result<()> {
                self.0.refresh()
            }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&mut self, position: C, text: &str)
                    where C: Into<Cursor> {
                self.0.write_at(position.into(), text)
            }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text)
            }
            /// Writes text with the given attributes at the given position within
            /// the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&mut self, position: C,
                    fg: F, bg: B, style: S, text: &str) where
                    C: Into<Cursor>,
                    F: Into<Option<Color>>,
                    B: Into<Option<Color>>,
                    S: Into<Option<Style>>,
                    {
                self.0.write_styled_at(position.into(),
                    fg.into(), bg.into(), style.into().unwrap_or_default(), text)
            }
            /// Writes a single character at the cursor position
            /// using the current style and color settings.
            pub fn write_char(&mut self, ch: char) {
                self.0.write_char(ch)
            }
            /// Writes a string at the cursor position
            /// using the current style and color settings.
            pub fn write_str(&mut self, s: &str) {
                self.0.write_str(s)
            }
            /// Writes formatted text at the cursor position
            /// using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)]
            pub fn borrow_term_write_guard(&mut self) -> &mut Self {
                self
            }
        }

        #[cfg(unix)] impl super::unix::TerminalExt for Screen 
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            {
                self.0.read_raw(buf, timeout)
            }
        }

        #[cfg(unix)] impl<'a> super::unix::TerminalExt for ScreenReadGuard<'a> 
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }
        }

        #[cfg(windows)] impl super::windows::TerminalExt for Screen 
        {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }

            fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                    timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw_event(events, timeout)
            }
        }

        #[cfg(windows)] impl<'a> super::windows::TerminalExt for ScreenReadGuard<'a> 
        {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }

            fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                    timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw_event(events, timeout)
            }
        }
    } pub use self::screen::{ * };

    pub mod sequence
    {
        use ::
        {
            iter::FromIterator,
            mem::replace,
            *,
        };        
        /// Contains a set of string sequences, mapped to a value.
        #[derive(Clone, Debug, Default)]
        pub struct SequenceMap<K, V> 
        {
            map: Vec<(K, V)>,
        }

        impl<K: AsRef<str>, V> SequenceMap<K, V>
        {
            /// Creates an empty `SequenceMap`.
            pub fn new() -> SequenceMap<K, V> { SequenceMap::with_capacity(0) }
            /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
            pub fn with_capacity(n: usize) -> SequenceMap<K, V>
            {
                SequenceMap
                {
                    map: Vec::with_capacity(n),
                }
            }
            /// Returns a slice of all contained sequences, sorted by key.
            pub fn sequences(&self) -> &[(K, V)] { &self.map }
            /// Returns a mutable slice of all contained sequences, sorted by key.
            pub fn sequences_mut(&mut self) -> &mut [(K, V)] { &mut self.map }
            /// Returns an `Entry` for the given key.
            pub fn entry(&mut self, key: K) -> Entry<K, V>
            {
                match self.search(key.as_ref()) {
                    Ok(n) => Entry::Occupied(OccupiedEntry{
                        map: self,
                        index: n,
                    }),
                    Err(n) => Entry::Vacant(VacantEntry{
                        map: self,
                        key,
                        index: n,
                    })
                }
            }
            /// Performs a search for a partial or complete sequence match.
            pub fn find(&self, key: &str) -> FindResult<&V> {
                let (n, found) = match self.search(key) {
                    Ok(n) => (n, true),
                    Err(n) => (n, false)
                };

                let incomplete = self.map.get(n + (found as usize))
                    .map_or(false, |&(ref next, _)| next.as_ref().starts_with(key));

                match (found, incomplete) {
                    (false, false) => FindResult::NotFound,
                    (false, true) => FindResult::Incomplete,
                    (true, false) => FindResult::Found(&self.map[n].1),
                    (true, true) => FindResult::Undecided(&self.map[n].1),
                }
            }
            /// Returns the corresponding value for the given sequence.
            pub fn get(&self, key: &str) -> Option<&V> {
                match self.search(key) {
                    Ok(n) => Some(&self.map[n].1),
                    Err(_) => None
                }
            }
            /// Returns a mutable reference to the corresponding value for the given sequence.
            pub fn get_mut(&mut self, key: &str) -> Option<&mut V> {
                match self.search(key) {
                    Ok(n) => Some(&mut self.map[n].1),
                    Err(_) => None
                }
            }
            /// Inserts a key-value pair into the map.
            pub fn insert(&mut self, key: K, value: V) -> Option<V> {
                match self.search(key.as_ref()) {
                    Ok(n) => Some(replace(&mut self.map[n], (key, value)).1),
                    Err(n) => {
                        self.map.insert(n, (key, value));
                        None
                    }
                }
            }
            /// Removes a key-value pair from the map.
            pub fn remove(&mut self, key: &str) -> Option<(K, V)> {
                match self.search(key) {
                    Ok(n) => Some(self.map.remove(n)),
                    Err(_) => None
                }
            }

            fn search(&self, key: &str) -> Result<usize, usize> {
                self.map.binary_search_by_key(&key, |&(ref k, _)| &k.as_ref())
            }
        }

        impl<K: AsRef<str>, V> From<Vec<(K, V)>> for SequenceMap<K, V> 
        {
            /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
            fn from(mut map: Vec<(K, V)>) -> SequenceMap<K, V> 
            {
                map.sort_by(|a, b| a.0.as_ref().cmp(b.0.as_ref()));
                map.dedup_by(|a, b| a.0.as_ref() == b.0.as_ref());
                SequenceMap{ map }
            }
        }

        impl<K: AsRef<str>, V> FromIterator<(K, V)> for SequenceMap<K, V> 
        {
            /// Creates a `SequenceMap` from an iterator of key-value pairs.
            fn from_iter<I: IntoIterator<Item=(K, V)>>(iter: I) -> Self {
                let iter = iter.into_iter();
                let mut map = SequenceMap::with_capacity(iter.size_hint().0);

                for (k, v) in iter {
                    map.insert(k, v);
                }

                map
            }
        }
        /// Represents the result of a `SequenceMap::find` operation.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum FindResult<V>
        {
            /// No contained sequences begin with the provided input sequence.
            NotFound,
            /// One or more sequences begin with the provided input sequence,
            /// but the sequence does not represent a complete sequence.
            Incomplete,
            /// A sequence was found exactly matching the input sequence;
            /// additionally, one or more sequences begin with the input sequence.
            Undecided(V),
            /// A sequence was found exactly matching the input sequence;
            /// no additional partially-matching sequences exist.
            Found(V),
        }
        
        impl<'a, V: Clone> FindResult<&'a V> 
        {
            /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents of the result value.
            pub fn cloned(self) -> FindResult<V>
            {
                match self {
                    FindResult::NotFound => FindResult::NotFound,
                    FindResult::Incomplete => FindResult::Incomplete,
                    FindResult::Undecided(v) => FindResult::Undecided(v.clone()),
                    FindResult::Found(v) => FindResult::Found(v.clone()),
                }
            }
        }
        /// A view into a single entry of a `SequenceMap`, which may be either occupied or vacant.
        pub enum Entry<'a, K: 'a, V: 'a> 
        {
            /// An occupied entry
            Occupied(OccupiedEntry<'a, K, V>),
            /// A vacant entry
            Vacant(VacantEntry<'a, K, V>),
        }
        /// A view into an occupied entry in a `SequenceMap`.
        pub struct OccupiedEntry<'a, K: 'a, V: 'a> 
        {
            map: &'a mut SequenceMap<K, V>,
            index: usize,
        }
        /// A view into a vacant entry in a `SequenceMap`.
        pub struct VacantEntry<'a, K: 'a, V: 'a> 
        {
            map: &'a mut SequenceMap<K, V>,
            key: K,
            index: usize,
        }

        impl<'a, K, V> Entry<'a, K, V> 
        {
            /// Provides in-place mutable access to an occupied entry before any
            /// potential inserts into the map.
            pub fn and_modify<F: FnOnce(&mut V)>(self, f: F) -> Self {
                match self {
                    Entry::Occupied(mut ent) => {
                        f(ent.get_mut());
                        Entry::Occupied(ent)
                    }
                    Entry::Vacant(ent) => Entry::Vacant(ent)
                }
            }
            /// Returns a mutable reference to the entry value,
            /// inserting the provided default if the entry is vacant.
            pub fn or_insert(self, default: V) -> &'a mut V {
                match self {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default)
                }
            }
            /// Returns a mutable reference to the entry value,
            /// inserting a value using the provided closure if the entry is vacant.
            pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
                match self {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default())
                }
            }
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K {
                match *self {
                    Entry::Occupied(ref ent) => ent.key(),
                    Entry::Vacant(ref ent) => ent.key(),
                }
            }
        }

        impl<'a, K, V> OccupiedEntry<'a, K, V> 
        {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K { &self.map.map[ self.index ].0 }
            /// Returns a borrowed reference to the entry value.
            pub fn get(&self) -> &V { &self.map.map[ self.index ].1 }
            /// Returns a mutable reference to the entry value.
            pub fn get_mut(&mut self) -> &mut V { &mut self.map.map[ self.index ].1 }
            /// Converts the `OccupiedEntry` into a mutable reference whose lifetime is bound to the `SequenceMap`.
            pub fn into_mut(self) -> &'a mut V { &mut self.map.map[ self.index ].1 }
            /// Replaces the entry value with the given value, returning the previous value.
            pub fn insert(&mut self, value: V) -> V { replace( self.get_mut(), value ) }
            /// Removes the entry and returns the value.
            pub fn remove(self) -> V { self.map.map.remove( self.index ).1 }
            /// Removes the entry and returns the key-value pair.
            pub fn remove_entry(self) -> (K, V) { self.map.map.remove( self.index ) }
        }

        impl<'a, K, V> VacantEntry<'a, K, V> 
        {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K { &self.key }
            /// Consumes the `VacantEntry` and returns ownership of the key.
            pub fn into_key(self) -> K { self.key }
            /// Consumes the `VacantEntry` and inserts a value, 
            /// returning a mutable reference to its place in the `SequenceMap`.
            pub fn insert(self, value: V) -> &'a mut V 
            {
                self.map.map.insert(self.index, (self.key, value));
                &mut self.map.map[self.index].1
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V> 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
            {
                match *self 
                {
                    Entry::Occupied(ref ent) =>
                    f.debug_tuple("Entry")
                    .field(ent)
                    .finish(),

                    Entry::Vacant(ref ent) =>
                    f.debug_tuple("Entry")
                    .field(ent)
                    .finish()
                }
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V> 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_struct("OccupiedEntry")
                    .field("key", self.key())
                    .field("value", self.get())
                    .finish()
            }
        }

        impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V> 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_tuple("VacantEntry")
                    .field(self.key())
                    .finish()
            }
        }

    } pub use self::sequence::{ * };

    pub mod signal
    {
        use ::
        {
            iter::FromIterator,
            *,
        };
        
        /// Signal received through a terminal device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Signal {
            /// Break signal (`CTRL_BREAK_EVENT`); Windows only
            Break,
            /// Continue signal (`SIGCONT`); Unix only
            Continue,
            /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
            Interrupt,
            /// Terminal window resize (`SIGWINCH` on Unix,
            /// `WINDOW_BUFFER_SIZE_EVENT` on Windows)
            Resize,
            /// Suspend signal (`SIGTSTP`); Unix only
            Suspend,
            /// Quit signal (`SIGQUIT`); Unix only
            Quit,
        }

        const NUM_SIGNALS: u8 = 6;

        impl Signal {
            fn as_bit(&self) -> u8 {
                1 << (*self as u8)
            }

            fn all_bits() -> u8 {
                (1 << NUM_SIGNALS) - 1
            }
        }

        impl ops::BitOr for Signal {
            type Output = SignalSet;

            fn bitor(self, rhs: Signal) -> SignalSet {
                let mut set = SignalSet::new();

                set.insert(self);
                set.insert(rhs);
                set
            }
        }

        impl ops::Not for Signal {
            type Output = SignalSet;

            fn not(self) -> SignalSet {
                !SignalSet::from(self)
            }
        }
        /// Represents a set of `Signal` values
        #[derive(Copy, Clone, Default, Eq, PartialEq)]
        pub struct SignalSet(u8);

        impl SignalSet {
            /// Returns an empty `SignalSet`.
            pub fn new() -> SignalSet {
                SignalSet(0)
            }
            /// Returns a `SignalSet` containing all available signals.
            pub fn all() -> SignalSet {
                SignalSet(Signal::all_bits())
            }
            /// Returns whether this set contains the given `Signal`.
            pub fn contains(&self, sig: Signal) -> bool {
                self.0 & sig.as_bit() != 0
            }
            /// Returns whether this set contains all signals present in another set.
            pub fn contains_all(&self, other: SignalSet) -> bool {
                self.0 & other.0 == other.0
            }
            /// Returns whether this set contains any signals present in another set.
            pub fn intersects(&self, other: SignalSet) -> bool {
                self.0 & other.0 != 0
            }
            /// Returns whether this set contains any signals.
            pub fn is_empty(&self) -> bool {
                self.0 == 0
            }
            /// Inserts a `Signal` into this set.
            pub fn insert(&mut self, sig: Signal) {
                self.0 |= sig.as_bit();
            }
            /// Removes a `Signal` from this set.
            pub fn remove(&mut self, sig: Signal) {
                self.0 &= !sig.as_bit();
            }
            /// Sets whether this set contains the given `Signal`.
            pub fn set(&mut self, sig: Signal, set: bool) {
                if set {
                    self.insert(sig);
                } else {
                    self.remove(sig);
                }
            }
            /// Returns the difference of two sets.
            pub fn difference(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 & !other.0)
            }
            /// Returns the symmetric difference of two sets.
            pub fn symmetric_difference(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 ^ other.0)
            }
            /// Returns the intersection of two sets.
            pub fn intersection(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 & other.0)
            }
            /// Returns the union of two sets.
            pub fn union(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 | other.0)
            }
            /// Returns the inverse of the set.
            pub fn inverse(&self) -> SignalSet {
                SignalSet(!self.0 & Signal::all_bits())
            }
        }

        impl fmt::Debug for SignalSet {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                const SIGNALS: &[Signal] = &[
                    Signal::Break,
                    Signal::Continue,
                    Signal::Interrupt,
                    Signal::Resize,
                    Signal::Suspend,
                    Signal::Quit,
                ];

                let mut first = true;

                f.write_str("SignalSet(")?;

                for &sig in SIGNALS {
                    if self.contains(sig) {
                        if !first {
                            f.write_str(" | ")?;
                        }

                        write!(f, "{:?}", sig)?;
                        first = false;
                    }
                }

                f.write_str(")")
            }
        }

        impl From<Signal> for SignalSet {
            fn from(sig: Signal) -> SignalSet {
                let mut set = SignalSet::new();
                set.insert(sig);
                set
            }
        }

        impl Extend<Signal> for SignalSet {
            fn extend<I: IntoIterator<Item=Signal>>(&mut self, iter: I) {
                for sig in iter {
                    self.insert(sig);
                }
            }
        }

        impl FromIterator<Signal> for SignalSet {
            fn from_iter<I: IntoIterator<Item=Signal>>(iter: I) -> SignalSet {
                let mut set = SignalSet::new();

                set.extend(iter);
                set
            }
        }

        macro_rules! impl_op {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self, rhs: SignalSet) -> SignalSet {
                        self.$method(rhs)
                    }
                }
            }
        }

        macro_rules! impl_mut_op {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    fn $tr_meth(&mut self, rhs: SignalSet) {
                        *self = self.$method(rhs);
                    }
                }
            }
        }

        macro_rules! impl_unary_op {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self) -> SignalSet {
                        self.$method()
                    }
                }
            }
        }

        impl_op!{ BitAnd, bitand, intersection }
        impl_op!{ BitOr, bitor, union }
        impl_op!{ BitXor, bitxor, symmetric_difference }
        impl_op!{ Sub, sub, difference }

        impl_unary_op!{ Not, not, inverse }

        impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
        impl_mut_op!{ BitOrAssign, bitor_assign, union }
        impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
        impl_mut_op!{ SubAssign, sub_assign, difference }
    } pub use self::signal::{ * };

    pub mod table
    {
        use ::
        {
            cmp::{ min },
            *,
        };
        const COL_SPACE: usize = 2;

        /// Represents a table of strings, formatted into rows and columns.
        pub struct Table<'a, S: 'a> {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            offset: usize,
            per_col: usize,
            rows: usize,
            horizontal: bool,
        }

        impl<'a, S: 'a + AsRef<str>> Table<'a, S> {
            /// Constructs a new table from the given set of strings, using the given
            /// column sizes.
            pub fn new(strs: &'a [S], mut sizes: Option<&'a [usize]>,
                    horizontal: bool) -> Table<'a, S> {
                if let Some(sz) = sizes {
                    if sz.is_empty() {
                        sizes = None;
                    }
                }

                let n_strs = strs.len();
                let n_cols = sizes.map_or(1, |sz| sz.len());

                let rows = n_strs / n_cols + (n_strs % n_cols != 0) as usize;

                Table{
                    strings: strs,
                    sizes: sizes,
                    offset: 0,
                    per_col: (strs.len() + (n_cols - 1)) / n_cols,
                    rows: rows,
                    horizontal: horizontal,
                }
            }
            /// Returns whether more lines are present in the table.
            pub fn has_more(&self) -> bool {
                self.offset < self.rows
            }

            fn num_cols(&self) -> usize {
                self.sizes.map_or(1, |sz| sz.len())
            }
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S> {
            type Item = Line<'a, S>;

            fn next(&mut self) -> Option<Line<'a, S>> {
                if self.offset == self.rows {
                    return None;
                }

                let n = self.num_cols();

                let (start, end, stride) = if self.horizontal {
                    let start = self.offset * n;
                    let end = min(self.strings.len(), start + n);
                    (start, end, 1)
                } else {
                    let start = self.offset;
                    let end = min(self.strings.len(), start + self.per_col * n);
                    (start, end, self.per_col)
                };

                self.offset += 1;

                Some(Line{
                    strings: &self.strings[start..end],
                    sizes: self.sizes,
                    stride: stride,
                    offset: 0,
                })
            }
        }
        /// Represents a single line of the table
        pub struct Line<'a, S: 'a> {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            stride: usize,
            offset: usize,
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S> {
            type Item = (usize, &'a str);

            fn next(&mut self) -> Option<(usize, &'a str)> {
                let s = self.strings.get(self.offset * self.stride)?.as_ref();

                let width = self.sizes.and_then(|sz| sz.get(self.offset).cloned())
                    .unwrap_or_else(|| s.chars().count());

                self.offset += 1;

                Some((width, s))
            }
        }
        /// Formats a series of strings into columns, fitting within a given screen width.
        pub fn format_columns<S: AsRef<str>>(strs: &[S], screen_width: usize,
                horizontal: bool) -> Option<Vec<usize>> {
            if strs.is_empty() {
                return None;
            }

            let n_strs = strs.len();

            let (mut min_len, mut max_len) = min_max(strs.iter().map(|s| s.as_ref().chars().count()));

            if min_len == 0 { min_len = 1; }
            if max_len == 0 { max_len = 1; }

            let mut min_cols = min(n_strs, screen_width / max_len);
            let max_cols = min(n_strs, screen_width / min_len);

            if min_cols <= 1 {
                min_cols = 2;
            }

            if max_cols <= 1 {
                return None;
            }

            let mut col_sizes = if min_cols == max_cols {
                vec![vec![0; max_cols]]
            } else {
                (min_cols..max_cols + 1)
                    .map(|n| vec![0; n]).collect::<Vec<_>>()
            };

            for (i, s) in strs.iter().enumerate() {
                let len = s.as_ref().chars().count();

                for cols in &mut col_sizes {
                    let n_cols = cols.len();

                    let col = if horizontal {
                        i % n_cols
                    } else {
                        let per_col = (n_strs + (n_cols - 1)) / n_cols;
                        i / per_col
                    };

                    let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                    if real_len > cols[col] {
                        cols[col] = real_len;
                    }
                }
            }

            for cols in col_sizes.into_iter().rev() {
                if cols.iter().fold(0, |a, b| a + b) <= screen_width {
                    return Some(cols);
                }
            }

            None
        }

        fn min_max<I>(iter: I) -> (usize, usize) where I: Iterator<Item=usize> {
            let mut min = usize::max_value();
            let mut max = 0;

            for n in iter {
                if n < min {
                    min = n;
                }
                if n + COL_SPACE > max {
                    max = n + COL_SPACE;
                }
            }

            (min, max)
        }

    } pub use self::table::{ * };

    pub mod terminal
    {
        use ::
        {
            char::{ unctrl_lower },
            sync::{LockResult, map_lock_result, map_try_lock_result, TryLockResult},
            system::{ * },
            time::{ Duration },
            *,
        };
        /*
        use linefeed::sys;
        use mortal::{self, PrepareConfig, PrepareState, TerminalReadGuard, TerminalWriteGuard};
        use mortal::signal::{Signal, SignalSet};
        use mortal::sys;
        pub use mortal::{CursorMode, Signal, SignalSet, Size}; */
        /// Defines a low-level interface to the terminal
        pub trait Terminals: Sized + Send + Sync 
        {
            /// Returned by `prepare`; passed to `restore` to restore state.
            type PrepareState;
            /*
            /// Holds an exclusive read lock and provides read operations
            type Reader: TerminalReader;
            /// Holds an exclusive write lock and provides write operations
            type Writer: TerminalWriter;
            */
            /// Returns the name of the terminal.
            fn name(&self) -> &str;
            /// Acquires a lock on terminal read operations and returns a value holding that lock and granting access to such operations.
            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;
            /// Acquires a lock on terminal write operations and returns a value holding that lock and granting access to such operations.
            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
        }
        /// Represents the result of a `Terminal` read operation
        pub enum RawRead
        {
            /// `n` bytes were read from the device
            Bytes( usize ),
            /// The terminal window was resized
            Resize( Size ),
            /// A signal was received while waiting for input
            Signal( Signal ),
        }
        /// Holds a lock on `Terminal` read operations
        pub trait TerminalReader<Term: Terminals> 
        {
            /// Prepares the terminal for line reading and editing operations.
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet)
                -> io::Result<Term::PrepareState>;
            /// Like `prepare`, but called when the write lock is already held.
            unsafe fn prepare_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>,
                    block_signals: bool, report_signals: SignalSet)
                    -> io::Result<Term::PrepareState>;
            /// Restores the terminal state using the given state data.
            fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;
            /// Like `restore`, but called when the write lock is already held.
            unsafe fn restore_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>,
                    state: Term::PrepareState) -> io::Result<()>;
            /// Reads some input from the terminal and appends it to the given buffer.
            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;
            /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
        }
        /// Holds a lock on `Terminal` write operations
        pub trait TerminalWriter<Term: Terminals> 
        {
            /// Returns the size of the terminal window
            fn size(&self) -> io::Result<Size>;
            /// Presents a clear terminal screen, with cursor at first row, first column.
            fn clear_screen(&mut self) -> io::Result<()>;
            /// Clears characters on the line occupied by the cursor, 
            /// beginning with the cursor and ending at the end of the line.
            fn clear_to_screen_end(&mut self) -> io::Result<()>;
            /// Moves the cursor up `n` cells; `n` may be zero.
            fn move_up(&mut self, n: usize) -> io::Result<()>;
            /// Moves the cursor down `n` cells; `n` may be zero.
            fn move_down(&mut self, n: usize) -> io::Result<()>;
            /// Moves the cursor left `n` cells; `n` may be zero.
            fn move_left(&mut self, n: usize) -> io::Result<()>;
            /// Moves the cursor right `n` cells; `n` may be zero.
            fn move_right(&mut self, n: usize) -> io::Result<()>;
            /// Moves the cursor to the first column of the current line
            fn move_to_first_column(&mut self) -> io::Result<()>;
            /// Set the current cursor mode
            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;
            /// Writes output to the terminal.
            fn write(&mut self, s: &str) -> io::Result<()>;
            /// Flushes any currently buffered output data.
            fn flush(&mut self) -> io::Result<()>;
        }
        /// Default `Terminal` interface
        pub struct DefaultTerminal( pub Terminal );

        impl DefaultTerminal 
        {
            /// Opens access to the terminal device associated with standard output.
            pub fn new() -> io::Result<DefaultTerminal>
            {
                system::Terminal::new().map(DefaultTerminal)
            }
            /// Opens access to the terminal device associated with standard error.
            pub fn stderr() -> io::Result<DefaultTerminal>
            {
                system::Terminal::stderr().map(DefaultTerminal)
            }

            unsafe fn cast_writer<'a>(writer: &'a mut dyn TerminalWriter<Self>) ->
            &'a mut TerminalWriteGuardian<'a>
            {
                &mut *( writer as *mut _ as *mut TerminalWriteGuardian )
            }
        }

        impl Terminals for DefaultTerminal 
        {
            type PrepareState = PrepareState;

            fn name(&self) -> &str 
            {
                /*
                TODO
                self.0.name()*/
                ""
            }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> 
            {
                Box::new(self.0.lock_read().unwrap())
            }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>
            {
                Box::new(self.0.lock_write().unwrap())
            }
        }

        impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuardian<'a> 
        {
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet) -> io::Result<PrepareState>
            {
                self.prepare(PrepareConfig
                {
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                })
            }

            unsafe fn prepare_with_lock
            (
                &mut self,
                lock: &mut dyn TerminalWriter<DefaultTerminal>,
                block_signals: bool, report_signals: SignalSet
            ) -> io::Result<PrepareState>
            {
                let lock = DefaultTerminal::cast_writer(lock);
                self.prepare_with_lock(lock, PrepareConfig
                {
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                })
            }

            fn restore(&mut self, state: PrepareState) -> io::Result<()> { self.restore(state) }

            unsafe fn restore_with_lock
            (
                &mut self,
                lock: &mut dyn TerminalWriter<DefaultTerminal>,
                state: PrepareState
            ) -> io::Result<()>
            {
                let lock = DefaultTerminal::cast_writer(lock);
                self.restore_with_lock(lock, state)
            }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> 
            {
                sys::terminal_read(self, buf)
            }

            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
            {
                self.wait_event(timeout)
            }

        }

        impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuardian<'a> 
        {
            fn size(&self) -> io::Result<Size> 
            {
                self.size()
            }

            fn clear_screen(&mut self) -> io::Result<()> 
            {
                self.clear_screen()
            }

            fn clear_to_screen_end(&mut self) -> io::Result<()> 
            {
                self.clear_to_screen_end()
            }

            fn move_up(&mut self, n: usize) -> io::Result<()> 
            {
                self.move_up(n)
            }

            fn move_down(&mut self, n: usize) -> io::Result<()> 
            {
                self.move_down(n)
            }

            fn move_left(&mut self, n: usize) -> io::Result<()> 
            {
                self.move_left(n)
            }

            fn move_right(&mut self, n: usize) -> io::Result<()> 
            {
                self.move_right(n)
            }

            fn move_to_first_column(&mut self) -> io::Result<()> 
            {
                self.move_to_first_column()
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> 
            {
                self.set_cursor_mode(mode)
            }

            fn write(&mut self, s: &str) -> io::Result<()> 
            {
                self.write_str(s)
            }

            fn flush(&mut self) -> io::Result<()> 
            {
                self.flush()
            }
        }
        /// Represents a color attribute applied to text foreground or background.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Color 
        {
            /// Black
            Black,
            /// Blue
            Blue,
            /// Cyan
            Cyan,
            /// Green
            Green,
            /// Magenta
            Magenta,
            /// Red
            Red,
            /// White
            White,
            /// Yellow
            Yellow,
        }

        bitflags!
        {
            /// Represents a set of style attributes applied to text.
            #[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
            pub struct Style: u8 
            {
                /// Bold
                const BOLD      = 1 << 0;
                /// Italic
                const ITALIC    = 1 << 1;
                /// Reverse; foreground and background color swapped
                const REVERSE   = 1 << 2;
                /// Underline
                const UNDERLINE = 1 << 3;
            }
        }
        /// Represents a terminal output theme.
        #[derive(Copy, Clone, Debug, Default)]
        pub struct Theme 
        {
            /// Foreground color
            pub fg: Option<Color>,
            /// Background color
            pub bg: Option<Color>,
            /// Style
            pub style: Style,
        }

        impl Theme 
        {
            /// Creates a new theme with given values.
            pub fn new<F,B,S>(fg: F, bg: B, style: S) -> Theme
                    where
                        F: Into<Option<Color>>,
                        B: Into<Option<Color>>,
                        S: Into<Option<Style>> {
                Theme {
                    fg: fg.into(),
                    bg: bg.into(),
                    style: style.into().unwrap_or_default(),
                }
            }
            /// Sets the foreground color on the given Theme and returns the new.
            pub fn fg<F>(mut self, fg: F) -> Theme
                    where F: Into<Option<Color>> {
                self.fg = fg.into();
                self
            }
            /// Sets the background color on the given Theme and returns the new.
            pub fn bg<B>(mut self, bg: B) -> Theme
                    where B: Into<Option<Color>> {
                self.bg = bg.into();
                self
            }
            /// Sets the style on the given Theme and returns the new.
            pub fn style<S>(mut self, style: S) -> Theme
                    where S: Into<Option<Style>> {
                self.style = style.into().unwrap_or_default();
                self
            }
        }
        /// Represents the cursor position in a terminal device
        #[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
        pub struct Cursor 
        {
            /// Index of line in terminal, beginning at `0`.
            pub line: usize,
            /// Index of column in terminal, beginning at `0`.
            pub column: usize,
        }

        impl Cursor 
        {
            /// Returns the position of the next cell within a terminal of the given size.
            #[inline] pub fn next(&self, size: Size) -> Option<Cursor> {
                let mut line = self.line;
                let mut column = self.column + 1;

                if column >= size.columns {
                    column = 0;
                    line += 1;
                }

                if line >= size.lines {
                    None
                } else {
                    Some(Cursor{line, column})
                }
            }
            /// Returns the position of the previous cell within a terminal of the given size.
            #[inline] pub fn previous(&self, size: Size) -> Option<Cursor> {
                if self.column == 0 {
                    if self.line == 0 {
                        None
                    } else {
                        Some(Cursor{line: self.line - 1, column: size.columns - 1})
                    }
                } else {
                    Some(Cursor{line: self.line, column: self.column - 1})
                }
            }
            /// Returns a `Cursor` pointing to the first cell, i.e. `(0, 0)`.
            #[inline] pub fn first() -> Cursor {
                Cursor{
                    line: 0,
                    column: 0,
                }
            }
            /// Returns a `Cursor` pointing to the last cell of a screen of the given size.
            #[inline] pub fn last(size: Size) -> Cursor {
                Cursor{
                    line: size.lines - 1,
                    column: size.columns - 1,
                }
            }
            /// Returns whether the cursor is out of bounds of the given size.
            #[inline] pub fn is_out_of_bounds(&self, size: Size) -> bool {
                self.line >= size.lines || self.column >= size.columns
            }
            /// Returns the index of the cursor position within a one-dimensional array of the given size.
            pub fn as_index(&self, size: Size) -> usize {
                self.line * size.columns + self.column
            }
        }

        impl From<(usize, usize)> for Cursor 
        {
            /// Returns a `Cursor` value from a `(line, column)` or `(y, x)` tuple.
            fn from((line, column): (usize, usize)) -> Cursor {
                Cursor{line, column}
            }
        }
        /// Represents the visual appearance of the cursor in the terminal
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum CursorMode 
        {
            /// Normal mode
            Normal,
            /// Invisible mode
            Invisible,
            /// Overwrite mode
            Overwrite,
        }
        /// Represents an event generated from a terminal interface
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Event 
        {
            /// Keyboard event
            Key(Key),
            /// Mouse event
            Mouse(MouseEvent),
            /// Raw data read
            Raw(usize),
            /// Terminal window size changed; contained value is the new size.
            Resize(Size),
            /// Terminal signal received
            Signal(Signal),
            /// No event
            NoEvent,
        }
        /// Represents a keyboard key press event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Key 
        {
            /// Backspace
            Backspace,
            /// Enter
            Enter,
            /// Escape
            Escape,
            /// Tab
            Tab,
            /// Up arrow
            Up,
            /// Down arrow
            Down,
            /// Left arrow
            Left,
            /// Right arrow
            Right,
            /// Delete
            Delete,
            /// Insert
            Insert,
            /// Home
            Home,
            /// End
            End,
            /// PageUp
            PageUp,
            /// PageDown
            PageDown,
            /// Character key
            Char(char),
            /// Control character
            Ctrl(char),
            /// Function `n` key; e.g. F1, F2, ...
            F(u32),
        }

        impl From<char> for Key
        {
            fn from(ch: char) -> Key
            {
                match ch
                {
                    '\x1b' => Key::Escape,
                    '\x7f' => Key::Backspace,
                    '\r' | '\n' => Key::Enter,
                    '\t' => Key::Tab,
                    _ if is::ctrl(ch) => Key::Ctrl(unctrl_lower(ch)),
                    _ => Key::Char(ch),
                }
            }
        }
        /// Represents a mouse event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct MouseEvent 
        {
            /// The position of the mouse within the terminal when the event occurred
            pub position: Cursor,
            /// The input event that occurred
            pub input: MouseInput,
            /// Modifier keys held when the input event occurred
            pub modifiers: ModifierState,
        }
        /// Represents the type of mouse input event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseInput 
        {
            /// The mouse cursor was moved
            Motion,
            /// A mouse button was pressed
            ButtonPressed(MouseButton),
            /// A mouse button was released
            ButtonReleased(MouseButton),
            /// The mouse wheel was scrolled up
            WheelUp,
            /// The mouse wheel was scrolled down
            WheelDown,
        }
        /// Represents a button on a mouse device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseButton 
        {
            /// Left mouse button
            Left,
            /// Right mouse button
            Right,
            /// Middle mouse button
            Middle,
            /// Other mouse button
            Other(u32),
        }

        bitflags!
        {
            /// Represents a set of modifier keys
            #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
            pub struct ModifierState: u8 
            {
                /// Alt key
                const ALT   = 1 << 0;
                /// Ctrl key
                const CTRL  = 1 << 1;
                /// Shift key
                const SHIFT = 1 << 2;
            }
        }
        /// Configures a [`Terminal`] or [`Screen`] instance to read special input.
        #[derive(Copy, Clone, Debug)]
        pub struct PrepareConfig 
        {
            /// Whether to block signals that result from user input.
            pub block_signals: bool,
            /// Whether to enable control flow characters.
            pub enable_control_flow: bool,
            /// If `true`, the terminal will be configured to generate events from
            /// function keys.
            pub enable_keypad: bool,
            /// If `true`, the terminal will be configured to generate events for
            /// mouse input, if supported, and `read_event` may return `Event::Mouse(_)`.
            pub enable_mouse: bool,
            /// If `true`, mouse motion events will always be reported.
            /// If `false`, such events will only be reported while at least one mouse
            /// button is pressed.
            pub always_track_motion: bool,
            /// For each signal in the set, a signal handler will intercept the signal
            /// and report it by returning an `Event::Signal(_)` value.
            pub report_signals: SignalSet,
        }

        impl Default for PrepareConfig 
        {
            fn default() -> PrepareConfig {
                PrepareConfig{
                    block_signals: true,
                    enable_control_flow: false,
                    enable_keypad: true,
                    enable_mouse: false,
                    always_track_motion: false,
                    report_signals: SignalSet::new(),
                }
            }
        }
        /// Represents a previous device state of a [`Terminal`].
        #[must_use = "the result of `terminal.prepare()` should be passed to \
            `terminal.restore()` to restore terminal to its original state"]
        pub struct PrepareState( sys::PrepareState );
        /// Represents the size of a terminal window
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Size 
        {
            /// Number of lines in the terminal
            pub lines: usize,
            /// Number of columns in the terminal
            pub columns: usize,
        }

        impl Size 
        {
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn area(&self) -> usize {
                self.checked_area().unwrap_or_else(
                    || panic!("overflow in Size::area {:?}", self))
            }
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn checked_area(&self) -> Option<usize> {
                self.lines.checked_mul(self.columns)
            }
        }
        /// Provides concurrent read and write access to a terminal device
        pub struct Terminal( pub sys::Terminal );

        impl Terminal 
        {
            /// Opens a new interface to the terminal on `stdout`.
            pub fn new() -> io::Result<Terminal> 
            {
                Ok(Terminal(sys::Terminal::stdout()?))
            }
            /// Opens a new interface to the terminal on `stderr`.
            pub fn stderr() -> io::Result<Terminal> 
            {
                Ok(Terminal(sys::Terminal::stderr()?))
            }
            /*/// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str {
                self.0.name()
            } */
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<TerminalReadGuardian> 
            {
                map_lock_result(self.0.lock_read(), TerminalReadGuardian)
            }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<TerminalWriteGuardian> 
            {
                map_lock_result(self.0.lock_write(), TerminalWriteGuardian )
            }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuardian> 
            {
                map_try_lock_result(self.0.try_lock_read(), TerminalReadGuardian)
            }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuardian> 
            {
                map_try_lock_result( self.0.try_lock_write(), TerminalWriteGuardian )
            }
        }
        /// # Locking
        /// The following methods internally acquire both the read and write locks.
        impl Terminal 
        {
            /// Prepares the terminal to read input.
            pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> {
                self.0.prepare(config).map(PrepareState)
            }
            /// Restores the terminal to its previous state.
            pub fn restore(&self, state: PrepareState) -> io::Result<()> {
                self.0.restore(state.0)
            }
        }
        /// # Locking
        /// The following methods internally acquire the read lock.
        impl Terminal 
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                self.0.wait_event(timeout)
            }
            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>  {
                self.0.read_event(timeout)
            }
        }
        /// # Locking
        /// The following methods internally acquire the write lock.
        impl Terminal 
        {
            /// Returns the size of the terminal.
            #[inline] pub fn size(&self) -> io::Result<Size> 
            {
                self.0.size()
            }
            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&self) -> io::Result<()> 
            {
                self.0.clear_screen()
            }
            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&self) -> io::Result<()> 
            {
                self.0.clear_to_line_end()
            }
            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&self) -> io::Result<()> 
            {
                self.0.clear_to_screen_end()
            }
            /// Moves the cursor up `n` lines.
            pub fn move_up(&self, n: usize) -> io::Result<()> 
            {
                self.0.move_up(n)
            }
            /// Moves the cursor down `n` lines.
            pub fn move_down(&self, n: usize) -> io::Result<()> 
            {
                self.0.move_down(n)
            }
            /// Moves the cursor left `n` columns.
            pub fn move_left(&self, n: usize) -> io::Result<()> 
            {
                self.0.move_left(n)
            }
            /// Moves the cursor right `n` columns.
            pub fn move_right(&self, n: usize) -> io::Result<()> 
            {
                self.0.move_right(n)
            }
            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&self) -> io::Result<()> 
            {
                self.0.move_to_first_column()
            }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> 
            {
                self.0.set_cursor_mode(mode)
            }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&self, style: Style) -> io::Result<()> 
            {
                self.0.add_style(style)
            }
            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&self, style: Style) -> io::Result<()> 
            {
                self.0.remove_style(style)
            }
            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&self, style: S) -> io::Result<()>
                    where S: Into<Option<Style>> {
                self.0.set_style(style.into().unwrap_or_default())
            }
            /// Sets all attributes for the terminal.
            pub fn set_theme(&self, theme: Theme) -> io::Result<()> 
            {
                self.0.set_theme(theme)
            }
            /// Sets the foreground text color.
            pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) -> io::Result<()> 
            {
                self.0.set_fg(fg.into())
            }
            /// Sets the background text color.
            pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) -> io::Result<()> 
            {
                self.0.set_bg(bg.into())
            }
            /// Removes color and style attributes.
            pub fn clear_attributes(&self) -> io::Result<()> 
            {
                self.0.clear_attributes()
            }
            /// Adds bold to the current style setting.
            pub fn bold(&self) -> io::Result<()> 
            {
                self.add_style(Style::BOLD)
            }
            /// Adds italic to the current style setting.
            pub fn italic(&self) -> io::Result<()> 
            {
                self.add_style(Style::ITALIC)
            }
            /// Adds underline to the current style setting.
            pub fn underline(&self) -> io::Result<()> 
            {
                self.add_style(Style::UNDERLINE)
            }
            /// Adds reverse to the current style setting.
            pub fn reverse(&self) -> io::Result<()> 
            {
                self.add_style(Style::REVERSE)
            }
            /// Writes output to the terminal with the given color and style.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, s: &str)
            -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s)
            }
            /// Writes a single character to the terminal using the current style and color settings.
            pub fn write_char(&self, ch: char) -> io::Result<()>
            {
                self.0.write_char(ch)
            }
            /// Writes a string to the terminal using the current style and color settings.
            pub fn write_str(&self, s: &str) -> io::Result<()> 
            {
                self.0.write_str(s)
            }
            /// Writes formatted text to the terminal using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)]
            pub fn borrow_term_write_guard(&self) -> TerminalWriteGuardian {
                self.lock_write().unwrap()
            }
        }
        /// Holds an exclusive lock for read operations on a `Terminal`
        pub struct TerminalReadGuardian<'a>( pub sys::TerminalReadGuard<'a> );

        impl<'a> TerminalReadGuardian<'a> 
        {
            /// Prepares the terminal to read input.
            pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState> {
                self.0.prepare(config).map(PrepareState)
            }
            /// Performs terminal preparation using both [`Terminal`] locks.
            pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuardian,
                    config: PrepareConfig) -> io::Result<PrepareState> {
                self.0.prepare_with_lock(&mut writer.0, config).map(PrepareState)
            }
            /// Restores the terminal to its previous state.
            pub fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                self.0.restore(state.0)
            }
            /// Performs terminal state restoration using both [`Terminal`] locks.
            pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuardian,
                    state: PrepareState) -> io::Result<()> {
                self.0.restore_with_lock(&mut writer.0, state.0)
            }
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                self.0.wait_event(timeout)
            }
            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>  {
                self.0.read_event(timeout)
            }
        }
        /// Holds an exclusive lock for write operations on a `Terminal`
        pub struct TerminalWriteGuardian<'a>( sys::TerminalWriteGuard<'a> );

        impl<'a> TerminalWriteGuardian<'a> 
        {
            /// Flush all output to the terminal device.
            pub fn flush(&mut self) -> io::Result<()> 
            {
                self.0.flush()
            }
            /// Returns the size of the terminal.
            #[inline] pub fn size(&self) -> io::Result<Size> 
            {
                self.0.size()
            }
            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&mut self) -> io::Result<()> 
            {
                self.0.clear_screen()
            }
            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&mut self) -> io::Result<()> 
            {
                self.0.clear_to_line_end()
            }
            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&mut self) -> io::Result<()> 
            {
                self.0.clear_to_screen_end()
            }
            /// Moves the cursor up `n` lines.
            pub fn move_up(&mut self, n: usize) -> io::Result<()> 
            {
                self.0.move_up(n)
            }
            /// Moves the cursor down `n` lines.
            pub fn move_down(&mut self, n: usize) -> io::Result<()> 
            {
                self.0.move_down(n)
            }
            /// Moves the cursor left `n` columns.
            pub fn move_left(&mut self, n: usize) -> io::Result<()> 
            {
                self.0.move_left(n)
            }
            /// Moves the cursor right `n` columns.
            pub fn move_right(&mut self, n: usize) -> io::Result<()> 
            {
                self.0.move_right(n)
            }
            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&mut self) -> io::Result<()> 
            {
                self.0.move_to_first_column()
            }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> 
            {
                self.0.set_cursor_mode(mode)
            }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&mut self, style: Style) -> io::Result<()> 
            {
                self.0.add_style(style)
            }
            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&mut self, style: Style) -> io::Result<()> 
            {
                self.0.remove_style(style)
            }
            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&mut self, style: S) -> io::Result<()> where 
            S: Into<Option<Style>>
            {
                self.0.set_style(style.into().unwrap_or_default())
            }
            /// Sets all attributes for the terminal.
            pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> 
            {
                self.0.set_theme(theme)
            }
            /// Sets the background text color.
            pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) -> io::Result<()> 
            {
                self.0.set_fg(fg.into())
            }
            /// Removes color and style attributes.
            pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) -> io::Result<()> 
            {
                self.0.set_bg(bg.into())
            }
            /// Adds bold to the current style setting.
            pub fn clear_attributes(&mut self) -> io::Result<()> 
            {
                self.0.clear_attributes()
            }
            /// Adds bold to the current style setting.
            pub fn bold(&mut self) -> io::Result<()> 
            {
                self.add_style(Style::BOLD)
            }
            /// Adds italic to the current style setting.
            pub fn italic(&mut self) -> io::Result<()> 
            {
                self.add_style(Style::ITALIC)
            }
            /// Adds underline to the current style setting.
            pub fn underline(&mut self) -> io::Result<()> 
            {
                self.add_style(Style::UNDERLINE)
            }
            /// Adds reverse to the current style setting.
            pub fn reverse(&mut self) -> io::Result<()> 
            {
                self.add_style(Style::REVERSE)
            }
            /// Writes output to the terminal with the given color and style added.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, s: &str) -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s)
            }
            /// Writes a single character to the terminal using the current style and color settings.
            pub fn write_char(&mut self, ch: char) -> io::Result<()> 
            {
                self.0.write_char(ch)
            }
            /// Writes a string to the terminal  using the current style and color settings.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> 
            {
                self.0.write_str(s)
            }
            /// Writes formatted text to the terminal using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> 
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&mut self) -> &mut Self 
            {
                self
            }
        }
        /*
            TODO
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
            fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> io::Result<Option<Event>>

            ...

            Add 
            fn read_raw_unix( ... ) -> io::Result<Option<Event>>
            fn read_raw_windows( ... ) -> io::Result<Option<Event>>
            fn read_raw_event_unix( ... ) -> io::Result<Option<Event>>
            fn read_raw_event_windows( ... ) -> io::Result<Option<Event>>
        */
    } pub use self::terminal::{ * };

    pub mod variables
    {
        use ::
        {
            borrow::Cow,
            convert::TryInto,
            mem::replace,
            time::Duration,
            *,
        };
        
        /// Default `keyseq_timeout`, in milliseconds
        pub const KEYSEQ_TIMEOUT_MS: u64 = 500;

        macro_rules! define_variables 
        {
            ($( $field:ident : $ty:ty => 
                ( $name:expr , $conv:ident , |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , 
            )+) => 
            {
                static VARIABLE_NAMES: &[&str] = &[ $( $name ),+ ];

                pub struct Variables {
                    $( pub $field : $ty ),*
                }

                impl Variables {
                    pub fn get_variable(&self, name: &str) -> Option<Variable> {
                        match name {
                            $( $name => {
                                let $gr = self;
                                Some(Variable::from($getter))
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable(&mut self, name: &str, value: &str)
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some($v) = $conv(value) {
                                    let $sr = self;
                                    Some(Variable::from($setter))
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter(&self) -> VariableIter {
                        VariableIter{vars: self, n: 0}
                    }
                }

                impl<'a> Iterator for VariableIter<'a> {
                    type Item = (&'static str, Variable);

                    fn next(&mut self) -> Option<Self::Item> {
                        let res = match VARIABLE_NAMES.get(self.n).cloned() {
                            $( Some($name) => ($name, {
                                let $gr = self.vars;
                                Variable::from($getter)
                            }) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some(res)
                    }
                }
            }
        }

        /// Iterator over `Reader` variable values
        #[derive(Clone)]
        pub struct VariableIter<'a> 
        {
            vars: &'a Variables,
            n: usize,
        }
        /// Represents a `Reader` variable of a given type
        #[derive(Clone, Debug)]
        pub enum Variable 
        {
            /// Boolean variable
            Boolean(bool),
            /// Integer variable
            Integer(i32),
            /// String variable
            String(Cow<'static, str>),
        }

        impl From<bool> for Variable 
        {
            fn from(b: bool) -> Variable {
                Variable::Boolean(b)
            }
        }

        impl From<i32> for Variable 
        {
            fn from(i: i32) -> Variable {
                Variable::Integer(i)
            }
        }

        impl From<&'static str> for Variable 
        {
            fn from(s: &'static str) -> Variable {
                Variable::String(s.into())
            }
        }

        impl From<Cow<'static, str>> for Variable 
        {
            fn from(s: Cow<'static, str>) -> Variable {
                Variable::String(s)
            }
        }

        impl From<String> for Variable 
        {
            fn from(s: String) -> Variable {
                Variable::String(s.into())
            }
        }

        impl fmt::Display for Variable 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    Variable::Boolean(b) => f.write_str(if b { "on" } else { "off" }),
                    Variable::Integer(n) => fmt::Display::fmt(&n, f),
                    Variable::String(ref s) => fmt::Display::fmt(&s[..], f),
                }
            }
        }

        define_variables!
        {
            blink_matching_paren: bool => ("blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace(&mut r.blink_matching_paren, v)),
            comment_begin: Cow<'static, str> => ("comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace(&mut r.comment_begin, v.into())),
            completion_display_width: usize => ("completion-display-width", parse_usize,
                |r| usize_as_i32(r.completion_display_width),
                |r, v| usize_as_i32(replace(&mut r.completion_display_width, v))),
            completion_query_items: usize => ("completion-query-items", parse_usize,
                |r| usize_as_i32(r.completion_query_items),
                |r, v| usize_as_i32(replace(&mut r.completion_query_items, v))),
            disable_completion: bool => ("disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace(&mut r.disable_completion, v)),
            echo_control_characters: bool => ("echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace(&mut r.echo_control_characters, v)),
            keyseq_timeout: Option<Duration> => ("keyseq-timeout", parse_duration,
                |r| as_millis(r.keyseq_timeout),
                |r, v| as_millis(replace(&mut r.keyseq_timeout, v))),
            page_completions: bool => ("page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace(&mut r.page_completions, v)),
            print_completions_horizontally: bool => ("print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace(&mut r.print_completions_horizontally, v)),
        }

        impl Default for Variables 
        {
            fn default() -> Variables 
            {
                Variables
                {
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    //keyseq_timeout: Some(Duration::milliseconds(KEYSEQ_TIMEOUT_MS)),
                    keyseq_timeout: Some(Duration::milliseconds(KEYSEQ_TIMEOUT_MS.try_into().unwrap())),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool(s: &str) -> Option<bool> 
        {
            match s {
                "0" => Some(false),
                "1" => Some(true),
                s if s.eq_ignore_ascii_case("off") => Some(false),
                s if s.eq_ignore_ascii_case("on") => Some(true),
                _ => None
            }
        }

        fn parse_string(s: &str) -> Option<String> 
        {
            Some(s.to_owned())
        }

        fn as_millis(timeout: Option<Duration>) -> i32 
        {
            match timeout 
            {
                Some(t) => 
                {
                    let s = (t.whole_seconds() * 1_000) as i32;
                    let ms = (t.subsec_nanoseconds() / 1_000_000) as i32;
                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration(s: &str) -> Option<Option<Duration>> 
        {
            match s.parse::<i32>() 
            {
                Ok(n) if n <= 0 => Some(None),
                //Ok(n) => Some(Some(Duration::milliseconds(n as u64))),
                Ok(n) => Some(Some(Duration::milliseconds((n as u64).try_into().unwrap()))),
                Err(_) => Some(None)
            }
        }

        fn usize_as_i32(u: usize) -> i32 
        {
            match u 
            {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize(s: &str) -> Option<usize> 
        {
            match s.parse::<i32>() {
                Ok(n) if n < 0 => Some(usize::max_value()),
                Ok(n) => Some(n as usize),
                Err(_) => None
            }
        }
    } pub use self::variables::{ * };

    pub mod writer
    {
        use ::
        {
            char::{ unctrl },
            borrow::Cow::{self, Borrowed, Owned},
            collections::{vec_deque, VecDeque},
            iter::{repeat, Skip},
            mem::swap,
            ops::{Deref, DerefMut, Range},
            sync::MutexGuard,
            system::{ * },
            time::{Duration, Instant},
            *,
        };
        /*
        use linefeed::chars::{is_ctrl, unctrl, ESCAPE, RUBOUT};
        use linefeed::reader::{START_INVISIBLE, END_INVISIBLE};
        use linefeed::terminal::{CursorMode, Size, Terminal, TerminalWriter};
        use linefeed::util::{
            backward_char, forward_char, backward_search_char, forward_search_char,
            filter_visible, is_combining_mark, is_wide, RangeArgument,
        };
        */
        /// Duration to wait for input when "blinking"
        pub const BLINK_DURATION: Duration = Duration::milliseconds(500);
        const COMPLETE_MORE: &'static str = "--More--";
        /// Default maximum history size
        const MAX_HISTORY: usize = !0;
        /// Tab column interval
        const TAB_STOP: usize = 8;
        // Length of "(arg: "
        const PROMPT_NUM_PREFIX: usize = 6;
        // Length of ") "
        const PROMPT_NUM_SUFFIX: usize = 2;
        // Length of "(i-search)`"
        const PROMPT_SEARCH_PREFIX: usize = 11;
        // Length of "failed "
        const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        // Length of "reverse-"
        const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        // Length of "': "
        const PROMPT_SEARCH_SUFFIX: usize = 3;
        /// Provides an interface to write line-by-line output to the terminal device.
        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminals> 
        {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminals> 
        {
            Mutex(WriteLock<'b, Term>),
            MutRef(&'a mut WriteLock<'b, Term>),
        }

        pub struct Write 
        {
            /// Input buffer
            pub buffer: String,
            /// Original buffer entered before searching through history
            pub backup_buffer: String,
            /// Position of the cursor
            pub cursor: usize,
            /// Position of the cursor if currently performing a blink
            blink: Option<Blink>,

            /// Stored history entries
            pub history: VecDeque<String>,
            /// History entry currently being edited;
            /// `None` if the new buffer is being edited
            pub history_index: Option<usize>,
            /// Maximum size of history
            history_size: usize,
            /// Number of history entries added since last loading history
            history_new_entries: usize,

            /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
            pub is_prompt_drawn: bool,

            /// Portion of prompt up to and including the final newline
            pub prompt_prefix: String,
            prompt_prefix_len: usize,
            /// Portion of prompt after the final newline
            pub prompt_suffix: String,
            prompt_suffix_len: usize,

            /// Current type of prompt
            pub prompt_type: PromptType,

            /// Whether a search in progress is a reverse search
            pub reverse_search: bool,
            /// Whether a search in progress has failed to find a match
            pub search_failed: bool,
            /// Current search string
            pub search_buffer: String,
            /// Last search string
            pub last_search: String,
            /// Selected history entry prior to a history search
            pub prev_history: Option<usize>,
            /// Position of the cursor prior to a history search
            pub prev_cursor: usize,

            /// Numerical argument
            pub input_arg: Digit,
            /// Whether a numerical argument was supplied
            pub explicit_arg: bool,

            /// Terminal size as of last draw operation
            pub screen_size: Size,
        }

        pub struct WriteLock<'a, Term: 'a + Terminals> 
        {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
        }

        impl<'a, Term: Terminals> WriteLock<'a, Term> 
        {
            pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>) -> WriteLock<'a, Term> 
            {
                WriteLock{term, data}
            }

            pub fn size(&self) -> io::Result<Size> 
            {
                self.term.size()
            }

            pub fn flush(&mut self) -> io::Result<()> 
            {
                self.term.flush()
            }

            pub fn update_size(&mut self) -> io::Result<()> 
            {
                let size = self.size()?;
                self.screen_size = size;
                Ok(())
            }

            pub fn blink(&mut self, pos: usize) -> io::Result<()> 
            {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to(pos)?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some(Blink{
                    pos,
                    expiry,
                });

                Ok(())
            }

            pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool> 
            {
                if let Some(blink) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok(self.blink.is_none())
            }

            pub fn expire_blink(&mut self) -> io::Result<()> 
            {
                if let Some(blink) = self.data.blink.take() {
                    self.move_from(blink.pos)?;
                }

                Ok(())
            }

            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> 
            {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt(prompt);

                if redraw {
                    self.draw_prompt()?;
                }

                Ok(())
            }
            /// Draws the prompt and current input, assuming the cursor is at column 0
            pub fn draw_prompt(&mut self) -> io::Result<()> 
            {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix(&mut self) -> io::Result<()> 
            {
                match self.prompt_type {
                    PromptType::CompleteMore => Ok(()),
                    _ => {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt(&pfx)
                    }
                }
            }

            pub fn draw_prompt_suffix(&mut self) -> io::Result<()> 
            {
                match self.prompt_type {
                    PromptType::Normal => {
                        let sfx = self.prompt_suffix.clone();
                        self.draw_raw_prompt(&sfx)?;
                    }
                    PromptType::Number => {
                        let n = self.input_arg.to_i32();
                        let s = format!("(arg: {}) ", n);
                        self.draw_text(0, &s)?;
                    }
                    PromptType::Search => {
                        let pre = match (self.reverse_search, self.search_failed) {
                            (false, false) => "(i-search)",
                            (false, true)  => "(failed i-search)",
                            (true,  false) => "(reverse-i-search)",
                            (true,  true)  => "(failed reverse-i-search)",
                        };

                        let ent = self.get_history(self.history_index).to_owned();
                        let s = format!("{}`{}': {}", pre, self.search_buffer, ent);

                        self.draw_text(0, &s)?;
                        let pos = self.cursor;

                        let (lines, cols) = self.move_delta(ent.len(), pos, &ent);
                        return self.move_rel(lines, cols);
                    }
                    PromptType::CompleteIntro(n) => {
                        return self.term.write(&complete_intro(n));
                    }
                    PromptType::CompleteMore => {
                        return self.term.write(COMPLETE_MORE);
                    }
                }

                self.draw_buffer(0)?;
                let len = self.buffer.len();
                self.move_from(len)
            }

            pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()> 
            {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }
            /// Draws a portion of the buffer, starting from the given cursor position
            pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> 
            {
                let (_, col) = self.line_col(pos);

                let buf = self.buffer[pos..].to_owned();
                self.draw_text(col, &buf)?;
                Ok(())
            }
            /// Draw some text with the cursor beginning at the given column.
            fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()> 
            {
                self.draw_text_impl(start_col, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false)
            }

            fn draw_raw_prompt(&mut self, text: &str) -> io::Result<()> 
            {
                self.draw_text_impl(0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true)
            }

            fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display, handle_invisible: bool) 
            -> io::Result<()>
            {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity(text.len());

                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars() {
                    if handle_invisible && ch == START_INVISIBLE {
                        hidden = true;
                    } else if handle_invisible && ch == END_INVISIBLE {
                        hidden = false;
                    } else if hidden {
                        out.push(ch);
                    } else {
                        for ch in display(ch, disp) {
                            if ch == '\t' {
                                let n = TAB_STOP - (col % TAB_STOP);

                                if col + n > width {
                                    let pre = width - col;
                                    out.extend(repeat(' ').take(pre));
                                    out.push_str(" \r");
                                    out.extend(repeat(' ').take(n - pre));
                                    col = n - pre;
                                } else {
                                    out.extend(repeat(' ').take(n));
                                    col += n;

                                    if col == width {
                                        out.push_str(" \r");
                                        col = 0;
                                    }
                                }
                            } else if ch == '\n' {
                                if !clear {
                                    self.term.write(&out)?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push('\n');
                                col = 0;
                            } else if is::combining_mark(ch) {
                                out.push(ch);
                            } else if is::wide(ch) {
                                if col == width - 1 {
                                    out.push_str("  \r");
                                    out.push(ch);
                                    col = 2;
                                } else {
                                    out.push(ch);
                                    col += 2;
                                }
                            } else {
                                out.push(ch);
                                col += 1;

                                if col == width {
                                    out.push_str(" \r");
                                    col = 0;
                                }
                            }
                        }
                    }
                }

                if col == width {
                    out.push_str(" \r");
                }

                self.term.write(&out)
            }

            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> 
            {
                self.expire_blink()?;

                self.move_to(0)?;
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.new_buffer()
            }

            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> 
            {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.move_to(pos)
            }

            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> 
            {
                self.term.set_cursor_mode(mode)
            }

            pub fn history_len(&self) -> usize 
            {
                self.history.len()
            }

            pub fn history_size(&self) -> usize 
            {
                self.history_size
            }

            pub fn set_history_size(&mut self, n: usize) 
            {
                self.history_size = n;
                self.truncate_history(n);
            }

            pub fn write_str(&mut self, s: &str) -> io::Result<()> 
            {
                self.term.write(s)
            }

            pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()> 
            {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search(reverse)
            }

            pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()> 
            {
                if let Some(idx) = self.find_history_search(reverse) {
                    self.set_history_entry(Some(idx));

                    let pos = self.cursor;
                    let end = self.buffer.len();

                    self.draw_buffer(pos)?;
                    self.clear_to_screen_end()?;
                    self.move_from(end)?;
                }

                Ok(())
            }

            fn find_history_search(&self, reverse: bool) -> Option<usize> 
            {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or(len);

                if reverse {
                    self.history.iter().rev().skip(len - idx)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx - (pos + 1))
                } else {
                    self.history.iter().skip(idx + 1)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx + (pos + 1))
                }
            }

            pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()> 
            {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt(PromptType::Search)
            }

            pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()> 
            {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from(&data.last_search);
                }

                self.search_history_step()
            }

            pub fn end_search_history(&mut self) -> io::Result<()> 
            {
                self.redraw_prompt(PromptType::Normal)
            }

            pub fn abort_search_history(&mut self) -> io::Result<()> 
            {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry(ent);
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>) -> io::Result<()>
            {
                self.clear_prompt()?;

                if let Some((idx, pos)) = next_match {
                    self.search_failed = false;
                    self.set_history_entry(idx);
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }

                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update(&mut self) -> io::Result<()> 
            {
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, true)
                } else {
                    self.search_history_forward(&self.search_buffer, true)
                };

                self.show_search_match(next_match)
            }

            fn search_history_step(&mut self) -> io::Result<()> 
            {
                if self.search_buffer.is_empty() {
                    return self.redraw_prompt(PromptType::Search);
                }
                
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, false)
                } else {
                    self.search_history_forward(&self.search_buffer, false)
                };

                self.show_search_match(next_match)
            }

            fn search_history_backward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
            {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if include_cur && !self.search_failed {
                    if let Some(p) = pos {
                        if self.get_history(idx).is_char_boundary(p + s.len()) {
                            pos = Some(p + s.len());
                        }
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[..pos.unwrap_or(line.len())].rfind(s) {
                        Some(found) => {
                            pos = Some(found);
                            break;
                        }
                        None => {
                            match idx {
                                Some(0) => return None,
                                Some(n) => {
                                    idx = Some(n - 1);
                                    pos = None;
                                }
                                None => {
                                    if self.history.is_empty() {
                                        return None;
                                    } else {
                                        idx = Some(self.history.len() - 1);
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            fn search_history_forward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
            {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if !include_cur {
                    if let Some(p) = pos {
                        pos = Some(forward_char(1, self.get_history(idx), p));
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[pos.unwrap_or(0)..].find(s) {
                        Some(found) => {
                            pos = pos.map(|n| n + found).or(Some(found));
                            break;
                        }
                        None => {
                            if let Some(n) = idx {
                                if n + 1 == self.history.len() {
                                    idx = None;
                                } else {
                                    idx = Some(n + 1);
                                }
                                pos = None;
                            } else {
                                return None;
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            pub fn add_history(&mut self, line: String) 
            {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back(line);
                self.history_new_entries = self.history.len()
                    .min(self.history_new_entries + 1);
            }

            pub fn add_history_unique(&mut self, line: String) 
            {
                let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);

                if !is_duplicate {
                    self.add_history(line);
                }
            }

            pub fn clear_history(&mut self) 
            {
                self.truncate_history(0);
                self.history_new_entries = 0;
            }

            pub fn remove_history(&mut self, n: usize) 
            {
                if n < self.history.len() {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new {
                        self.history_new_entries -= 1;
                    }

                    self.history.remove(n);
                }
            }

            pub fn truncate_history(&mut self, n: usize) 
            {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain(..len - n);
                    self.history_new_entries = self.history_new_entries.max(n);
                }
            }

            pub fn next_history(&mut self, n: usize) -> io::Result<()> 
            {
                if let Some(old) = self.history_index {
                    let new = old.saturating_add(n);

                    if new >= self.history.len() {
                        self.select_history_entry(None)?;
                    } else {
                        self.select_history_entry(Some(new))?;
                    }
                }

                Ok(())
            }

            pub fn prev_history(&mut self, n: usize) -> io::Result<()> 
            {
                if !self.history.is_empty() && self.history_index != Some(0) {
                    let new = if let Some(old) = self.history_index {
                        old.saturating_sub(n)
                    } else {
                        self.history.len().saturating_sub(n)
                    };

                    self.select_history_entry(Some(new))?;
                }

                Ok(())
            }

            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> 
            {
                if new != self.history_index {
                    self.move_to(0)?;
                    self.set_history_entry(new);
                    self.new_buffer()?;
                }

                Ok(())
            }

            pub fn set_history_entry(&mut self, new: Option<usize>) 
            {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some(old) = old {
                        data.history[old].clone_from(&data.buffer);
                    } else {
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }

                    if let Some(new) = new {
                        data.buffer.clone_from(&data.history[new]);
                    } else {
                        data.buffer.clear();
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }
                }
            }

            fn get_history(&self, n: Option<usize>) -> &str 
            {
                if self.history_index == n {
                    &self.buffer
                } else if let Some(n) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char(&mut self, n: usize) -> io::Result<()> 
            {
                let pos = backward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn forward_char(&mut self, n: usize) -> io::Result<()> 
            {
                let pos = forward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> 
            {
                if let Some(pos) = backward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }

            pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> 
            {
                if let Some(pos) = forward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }
            /// Deletes a range from the buffer; the cursor is moved to the end of the given range.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> 
            {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

                self.move_to(start)?;

                let _ = self.buffer.drain(start..end);

                self.draw_buffer(start)?;
                self.term.clear_to_screen_end()?;
                let len = self.buffer.len();
                self.move_from(len)?;

                Ok(())
            }

            pub fn insert_str(&mut self, s: &str) -> io::Result<()> 
            {
                let moves_combining = match self.buffer[self.cursor..].chars().next() {
                    Some(ch) if is::combining_mark(ch) => true,
                    _ => false
                };

                let cursor = self.cursor;
                self.buffer.insert_str(cursor, s);

                if moves_combining && cursor != 0 {
                    let pos = backward_char(1, &self.buffer, self.cursor);
                    let (lines, cols) = self.move_delta(cursor, pos, &self.buffer);
                    self.move_rel(lines, cols)?;
                    self.draw_buffer(pos)?;
                } else {
                    self.draw_buffer(cursor)?;
                }

                self.cursor += s.len();

                let len = self.buffer.len();
                self.move_from(len)
            }

            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>) -> io::Result<()>
            {
                assert!(src.end <= dest.start || src.start >= dest.end);

                let final_cur = if src.start < dest.start { dest.end }
                else { dest.start + (src.end - src.start) };

                let (left, right) = if src.start < dest.start { (src, dest) }
                else { (dest, src) };

                self.move_to(left.start)?;
                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();
                let _ = self.buffer.drain(right.clone());
                self.buffer.insert_str(right.start, &a);
                let _ = self.buffer.drain(left.clone());
                self.buffer.insert_str(left.start, &b);
                let cursor = self.cursor;
                self.draw_buffer(cursor)?;
                self.term.clear_to_screen_end()?;
                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from(len)
            }

            fn prompt_suffix_length(&self) -> usize 
            {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number => {
                        let n = number_len(self.input_arg.to_i32());
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search => {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size(&self.search_buffer, prefix);
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro(n) => complete_intro(n).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col(&self, pos: usize) -> (usize, usize) 
            {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type {
                    PromptType::CompleteIntro(_) |
                    PromptType::CompleteMore => {
                        let width = self.screen_size.columns;
                        (prompt_len / width, prompt_len % width)
                    }
                    _ => self.line_col_with(pos, &self.buffer, prompt_len)
                }
            }

            fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) 
            {
                let width = self.screen_size.columns;
                if width == 0 {
                    return (0, 0);
                }

                let n = start_col + self.display_size(&buf[..pos], start_col);

                (n / width, n % width)
            }

            pub fn clear_screen(&mut self) -> io::Result<()> 
            {
                self.term.clear_screen()?;
                self.draw_prompt()?;

                Ok(())
            }

            pub fn clear_to_screen_end(&mut self) -> io::Result<()> 
            {
                self.term.clear_to_screen_end()
            }
            /// Draws a new buffer on the screen.
            pub fn new_buffer(&mut self) -> io::Result<()> 
            {
                self.draw_buffer(0)?;
                self.cursor = self.buffer.len();

                self.term.clear_to_screen_end()?;

                Ok(())
            }

            pub fn clear_full_prompt(&mut self) -> io::Result<()> 
            {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let (line, _) = self.line_col(self.cursor);
                self.term.move_up(prefix_lines + line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn clear_prompt(&mut self) -> io::Result<()> {
                let (line, _) = self.line_col(self.cursor);

                self.term.move_up(line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }
            /// Move back to true cursor position from some other position
            pub fn move_from(&mut self, pos: usize) -> io::Result<()> 
            {
                let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
                self.move_rel(lines, cols)
            }

            pub fn move_to(&mut self, pos: usize) -> io::Result<()> 
            {
                if pos != self.cursor {
                    let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                    self.move_rel(lines, cols)?;
                    self.cursor = pos;
                }

                Ok(())
            }

            pub fn move_to_end(&mut self) -> io::Result<()> 
            {
                let pos = self.buffer.len();
                self.move_to(pos)
            }

            pub fn move_right(&mut self, n: usize) -> io::Result<()> 
            {
                self.term.move_right(n)
            }
            /// Moves from `old` to `new` cursor position, using the given buffer as current input.
            fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) 
            {
                let prompt_len = self.prompt_suffix_length();
                let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
                let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

                (new_line as isize - old_line as isize,
                new_col as isize - old_col as isize)
            }

            fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> 
            {
                if lines > 0 {
                    self.term.move_down(lines as usize)?;
                } else if lines < 0 {
                    self.term.move_up((-lines) as usize)?;
                }

                if cols > 0 {
                    self.term.move_right(cols as usize)?;
                } else if cols < 0 {
                    self.term.move_left((-cols) as usize)?;
                }

                Ok(())
            }

            pub fn reset_data(&mut self) 
            {
                self.data.reset_data();
            }

            pub fn set_digit_from_char(&mut self, ch: char) 
            {
                let digit = match ch {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from(ch),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive(Copy, Clone)]
        struct Blink 
        {
            pos: usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> Writer<'a, 'b, Term> 
        {
            fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self> {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str("\n")?;
                    }
                }

                Ok(Writer{write})
            }

            pub fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
                Writer::new(WriterImpl::Mutex(write), clear)
            }

            pub fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self> {
                Writer::new(WriterImpl::MutRef(write), clear)
            }
            /// Returns an iterator over history entries.
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }
            /// Writes some text to the terminal device.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.write.write_str(s)
            }
            /// Writes formatted text to the terminal display.
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> Drop for Writer<'a, 'b, Term> 
        {
            fn drop(&mut self) {
                if self.write.is_prompt_drawn {
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminals> Deref for WriteLock<'a, Term> 
        {
            type Target = Write;

            fn deref(&self) -> &Write {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminals> DerefMut for WriteLock<'a, Term> 
        {
            fn deref_mut(&mut self) -> &mut Write {
                &mut self.data
            }
        }

        impl Write 
        {
            pub fn new(screen_size: Size) -> Write 
            {
                Write{
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,

                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,

                    is_prompt_drawn: false,

                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,

                    prompt_type: PromptType::Normal,

                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,

                    input_arg: Digit::None,
                    explicit_arg: false,

                    screen_size,
                }
            }

            pub fn history(&self) -> HistoryIter 
            {
                HistoryIter(self.history.iter())
            }

            pub fn new_history(&self) -> Skip<HistoryIter> 
            {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip(first_new)
            }

            pub fn new_history_entries(&self) -> usize 
            {
                self.history_new_entries
            }

            pub fn reset_data(&mut self) 
            {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;

                self.prompt_type = PromptType::Normal;

                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history(&mut self) 
            {
                self.history_new_entries = 0;
            }

            pub fn set_buffer(&mut self, buf: &str) 
            {
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.cursor = buf.len();
            }

            pub fn set_cursor(&mut self, pos: usize) 
            {
                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.cursor = pos;
            }

            pub fn set_prompt(&mut self, prompt: &str) 
            {
                let (pre, suf) = match prompt.rfind('\n') {
                    Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                    None => (&prompt[..0], prompt)
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();

                let pre_virt = filter_visible(pre);
                self.prompt_prefix_len = self.display_size(&pre_virt, 0);

                let suf_virt = filter_visible(suf);
                self.prompt_suffix_len = self.display_size(&suf_virt, 0);
            }

            pub fn display_size(&self, s: &str, start_col: usize) -> usize 
            {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let disp = Display
                {
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in s.chars().flat_map(|ch| display(ch, disp))
                {
                    let n = match ch
                    {
                        '\n' => width - (col % width),
                        '\t' => TAB_STOP - (col % TAB_STOP),
                        ch if is::combining_mark(ch) => 0,
                        ch if is::wide(ch) =>
                        {
                            if col % width == width - 1 { 3 }
                            else { 2 }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }
        /// Maximum value of digit input
        pub const NUMBER_MAX: i32 = 1_000_000;

        #[derive(Copy, Clone, Debug)]
        pub enum Digit 
        {
            None,
            NegNone,
            Num(i32),
            NegNum(i32),
        }

        impl Digit 
        {
            pub fn input(&mut self, n: i32) {
                match *self {
                    Digit::None => *self = Digit::Num(n),
                    Digit::NegNone => *self = Digit::NegNum(n),
                    Digit::Num(ref mut m) | Digit::NegNum(ref mut m) => {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds(&self) -> bool {
                match *self {
                    Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32(&self) -> i32 {
                match *self {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num(n) => n,
                    Digit::NegNum(n) => -n,
                }
            }
        }

        impl From<char> for Digit 
        {
            /// Convert a decimal digit character to a `Digit` value.
            fn from(ch: char) -> Digit {
                let n = (ch as u8) - b'0';
                Digit::Num(n as i32)
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum PromptType 
        {
            Normal,
            Number,
            Search,
            CompleteIntro(usize),
            CompleteMore,
        }

        impl PromptType 
        {
            pub fn is_normal(&self) -> bool {
                *self == PromptType::Normal
            }
        }

        impl<'a, 'b, Term: 'b + Terminals> Deref for WriterImpl<'a, 'b, Term> 
        {
            type Target = WriteLock<'b, Term>;

            fn deref(&self) -> &WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex(ref m) => m,
                    WriterImpl::MutRef(ref m) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> DerefMut for WriterImpl<'a, 'b, Term> 
        {
            fn deref_mut(&mut self) -> &mut WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex(ref mut m) => m,
                    WriterImpl::MutRef(ref mut m) => m,
                }
            }
        }
        /// Iterator over `Interface` history entries
        pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a> 
        {
            type Item = &'a str;

            #[inline] fn next(&mut self) -> Option<&'a str> {
                self.0.next().map(|s| &s[..])
            }

            #[inline] fn nth(&mut self, n: usize) -> Option<&'a str> {
                self.0.nth(n).map(|s| &s[..])
            }

            #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a> 
        {
            #[inline] fn next_back(&mut self) -> Option<&'a str> {
                self.0.next_back().map(|s| &s[..])
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum DisplaySequence 
        {
            Char(char),
            Escape(char),
            End,
        }

        impl Iterator for DisplaySequence 
        {
            type Item = char;

            fn next(&mut self) -> Option<char> {
                use self::DisplaySequence::*;

                let (res, next) = match *self {
                    Char(ch) => (ch, End),
                    Escape(ch) => ('^', Char(ch)),
                    End => return None
                };

                *self = next;
                Some(res)
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                use self::DisplaySequence::*;

                let n = match *self {
                    Char(_) => 1,
                    Escape(_) => 2,
                    End => 0,
                };

                (n, Some(n))
            }
        }

        #[derive(Copy, Clone, Debug, Default)]
        pub struct Display 
        {
            allow_tab: bool,
            allow_newline: bool,
            allow_escape: bool,
        }

        pub fn display(ch: char, style: Display) -> DisplaySequence 
        {
            match ch 
            {
                '\t' if style.allow_tab => DisplaySequence::Char(ch),
                '\n' if style.allow_newline => DisplaySequence::Char(ch),
                ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
                '\0' => DisplaySequence::Escape('@'),
                RUBOUT => DisplaySequence::Escape('?'),
                ch if is::ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
                ch => DisplaySequence::Char(ch)
            }
        }

        pub fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str> 
        {
            if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch)) { Borrowed(s) }
            else { Owned(s.chars().flat_map(|ch| display(ch, style)).collect()) }
        }

        fn complete_intro(n: usize) -> String { format!("Display all {} possibilities? (y/n)", n) }

        fn number_len( n:i32 ) -> usize
        {
            match n
            {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=        9 => 1,
                        10 ..=       99 => 2,
                    100 ..=      999 => 3,
                    1_000 ..=    9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=  999_999 => 6,
                1_000_000              => 7,
                _ => unreachable!()
            }
        }
    } pub use self::writer::{ * };

    #[cfg( unix )] pub mod unix
    {
        //! Unix platform support
        use ::
        {
            path::{ Path },
            system::{ Event },
            time::{ Duration },
            *,
        };
        /*
        pub use self::screen::{
            Screen, ScreenReadGuard, ScreenWriteGuard,
        };
        pub use self::terminal::{
            PrepareState,
            Terminal, TerminalReadGuard, TerminalWriteGuard,
        };
        pub use self::terminal::terminal_read;
        */
        pub mod ext
        {
            use ::
            {
                path::{ * },
                system::{ Event },
                time::{ Duration },
                *,
            };
            /*
                use mortal::terminal::Event;
            */
            /// Implements Unix-only extensions for terminal interfaces.
            pub trait OpenTerminalExt:Sized
            {
                /// Opens a terminal interface on the device at the given path.
                fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self>;
            }
            /// Implements Unix-only extensions for terminal interfaces.
            pub trait TerminalExt
            {
                /// Reads raw data from the terminal.
                fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>;
            }
        } pub use self::ext::{ * };

        pub mod path
        {
            use ::
            {
                env::{ var_os },
                path::{ * },
                *,
            };

            pub fn env_init_file() -> Option<PathBuf> { var_os("INPUTRC").map(PathBuf::from) }

            pub fn system_init_file() -> Option<PathBuf> { Some(PathBuf::from("/etc/inputrc")) }

            pub fn user_init_file() -> Option<PathBuf> { home_dir().map(|p| p.join(".inputrc")) }
        } pub use self::path::{ * };

        pub mod screen
        {
            use ::
            {
                system::
                {
                    buffer::{ ScreenBuffer },
                    terminal::{ Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig },
                    unix::{ * },
                },
                sync::{ LockResult, map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result, Mutex, MutexGuard, TryLockResult },
                time::{ Duration },
                *,
            };
            
            pub struct Screen 
            {
                term: super::Terminal,
                state: Option<super::PrepareState>,
                writer: Mutex<Writer>,
            }

            impl Screen 
            {
                pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen> 
                {
                    let size = term.size()?;
                    let state = term.prepare(config)?;

                    let screen = Screen
                    {
                        term: term,
                        state: Some(state),

                        writer: Mutex::new(Writer
                        {
                            buffer: ScreenBuffer::new(size),
                            clear_screen: false,
                            real_cursor: Cursor::default(),
                        }),
                    };

                    screen.term.enter_screen()?;
                    Ok(screen)
                }

                pub fn stdout(config: PrepareConfig) -> io::Result<Screen> {
                    Screen::new(Terminal::stdout()?, config)
                }

                pub fn stderr(config: PrepareConfig) -> io::Result<Screen> {
                    Screen::new(Terminal::stderr()?, config)
                }

                forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                pub fn lock_read(&self) -> LockResult<ScreenReadGuard> {
                    map_lock_result(self.term.lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> {
                    map_try_lock_result(self.term.try_lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> {
                    map2_lock_result(self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> {
                    map2_try_lock_result(self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                fn lock_reader(&self) -> ScreenReadGuard { self.lock_read().expect("Screen::lock_reader") }

                fn lock_writer(&self) -> ScreenWriteGuard { self.lock_write().expect("Screen::lock_writer") }

                fn lock_write_data(&self) -> MutexGuard<Writer>
                { self.writer.lock().expect("Screen::lock_write_data") }
                /*
                pub fn name(&self) -> &str { self.term.name() } */
                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> 
                { self.term.set_cursor_mode(mode) }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
                { self.lock_reader().wait_event(timeout) }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                { self.lock_reader().read_event(timeout) }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                { self.lock_reader().read_raw(buf, timeout) }

                pub fn refresh(&self) -> io::Result<()> { self.lock_writer().refresh() }
            }

            impl Drop for Screen 
            {
                fn drop(&mut self) {
                    let res = if let Some(state) = self.state.take() {
                        self.term.restore(state)
                    } else {
                        Ok(())
                    };

                    if let Err(e) = res.and_then(|_| self.term.exit_screen()) {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            pub struct ScreenReadGuard<'a> 
            {
                screen: &'a Screen,
                reader: TerminalReadGuard<'a>,
            }

            pub struct ScreenWriteGuard<'a> 
            {
                writer: TerminalWriteGuard<'a>,
                data: MutexGuard<'a, Writer>,
            }

            struct Writer 
            {
                buffer: ScreenBuffer,
                clear_screen: bool,
                real_cursor: Cursor,
            }

            impl<'a> ScreenReadGuard<'a> 
            {
                fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> {
                    ScreenReadGuard{screen, reader}
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.reader.wait_event(timeout)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_event(timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_raw(buf, timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }
            }

            impl<'a> ScreenWriteGuard<'a> 
            {
                fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>)
                        -> ScreenWriteGuard<'a> {
                    ScreenWriteGuard{writer, data}
                }

                forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                    self.writer.set_cursor_mode(mode)
                }

                pub fn refresh(&mut self) -> io::Result<()> {
                    if self.data.clear_screen {
                        self.writer.clear_screen()?;
                        self.data.clear_screen = false;
                    }

                    self.writer.clear_attributes()?;

                    let mut indices = self.data.buffer.indices();

                    while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices) {
                        self.move_cursor(pos)?;

                        self.apply_attrs(cell.attrs())?;
                        self.writer.write_str(cell.text())?;
                        self.data.real_cursor.column += 1;
                    }

                    self.writer.clear_attributes()?;

                    let size = self.data.buffer.size();
                    let pos = self.data.buffer.cursor();

                    if pos.is_out_of_bounds(size) {
                        self.move_cursor(Cursor::last(size))?;
                    } else {
                        self.move_cursor(pos)?;
                    }

                    self.writer.flush()
                }

                fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    if self.data.real_cursor != pos {
                        self.writer.move_cursor(pos)?;
                        self.data.real_cursor = pos;
                    }

                    Ok(())
                }

                fn apply_attrs(&mut self,
                        (fg, bg, style): (Option<Color>, Option<Color>, Style))
                        -> io::Result<()> {
                    self.writer.set_attrs(fg, bg, style)
                }
            }

            impl<'a> Drop for ScreenWriteGuard<'a> 
            {
                fn drop(&mut self) {
                    if let Err(e) = self.refresh() {
                        eprintln!("failed to refresh screen: {}", e);
                    }
                }
            }

            impl Writer 
            {
                fn update_size(&mut self, new_size: Size) {
                    if self.real_cursor.is_out_of_bounds(new_size) {
                        self.real_cursor = (!0, !0).into();
                    }
                    self.buffer.resize(new_size);
                    self.clear_screen = true;
                }
            }
        } pub use self::screen::{ * };

        pub mod terminal
        {
            use ::
            {
                convert::{ TryFrom, TryInto },
                database::{ Database, OverError },
                fs::{ File },
                libc::{ unix::{ * }, * },
                mem::{ replace, zeroed },
                mode::{ Context, Expansion },
                nix::
                {
                    errno::{ Errno },
                    sys::
                    {
                        select::{ select, FdSet },
                        signal::{ sigaction, SaFlags, SigAction, SigHandler, Signal as NixSignal, SigSet, },
                        termios::{ tcgetattr, tcsetattr, SetArg, InputFlags, LocalFlags },
                        time::{ TimeVal, TimeValLike },
                    },
                    unistd::{ read, write },
                },
                os::unix::io::{ FromRawFd, IntoRawFd, RawFd },
                path::{ Path },
                str::{ from_utf8, prefixes, SmallString },
                sync::{ atomic::{ AtomicUsize, Ordering }, LockResult, map_lock_result, map_try_lock_result, Mutex, MutexGuard, TryLockResult },
                system::{ unix::TerminalExt, * },
                time::{ Duration },
                *,
            };
            /*
            use mortal::{Event, TerminalReadGuard};
            use mortal::unix::TerminalExt;
            use mortal::sequence::{FindResult, SequenceMap};
            use mortal::signal::{Signal, SignalSet};
            use mortal::terminal::
            {
                Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                MouseButton, MouseEvent, MouseInput, ModifierState,
            };            
            use mortal::util::prefixes;
            use linefeed::terminal::RawRead; */            
            pub const OUT_BUFFER_SIZE: usize = 8192;
            pub const XTERM_ENABLE_MOUSE: &str = "\x1b[?1006h\x1b[?1002h";
            pub const XTERM_DISABLE_MOUSE: &str = "\x1b[?1006l\x1b[?1002l";
            pub const XTERM_ENABLE_MOUSE_MOTION: &str = "\x1b[?1003h";
            pub const XTERM_DISABLE_MOUSE_MOTION: &str = "\x1b[?1003l";
            pub const XTERM_MOUSE_INTRO: &str = "\x1b[<";
            pub const XTERM_SHIFT_MASK: u32 = 0x04;
            pub const XTERM_META_MASK: u32  = 0x08;
            pub const XTERM_CTRL_MASK: u32  = 0x10;
            pub const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;

            type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

            macro_rules! expand_opt 
            {
                ( $slf:expr , $cap:path ) => 
                {{
                    if let Some(cap) = $slf.term.info.read::<$cap>()
                    {
                        $slf.expand(cap.expand())
                    }
                    else { Ok(()) }
                }};

                ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => 
                {{
                    if let Some(cap) = $slf.term.info.read::<$cap>()
                    {
                        let $ex = cap.expand();
                        $slf.expand($expansion)
                    }
                    else { Ok(()) }
                }};
            }

            macro_rules! expand_req 
            {
                ( $slf:expr , $cap:path , $name:expr ) => { {
                    $slf.term.info.read::<$cap>()
                        .ok_or_else(|| not_supported($name))
                        .and_then(|cap| $slf.expand(cap.expand()))
                } };
                ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => { {
                    $slf.term.info.read::<$cap>()
                        .ok_or_else(|| not_supported($name))
                        .and_then(|cap| 
                    {
                            let $ex = cap.expand();
                            $slf.expand($expansion)
                        })
                } }
            }

            #[derive(Copy, Clone)]
            enum SeqData 
            {
                XTermMouse,
                Key(Key),
            }

            pub struct Terminal 
            {
                pub info: Database,
                pub out_fd: RawFd,
                pub in_fd: RawFd,
                pub owned_fd: bool,
                pub sequences: SeqMap,
                pub reader: Mutex<Reader>,
                pub writer: Mutex<Writer>,
            }

            impl Terminal 
            {
                fn new(in_fd: RawFd, out_fd: RawFd, owned_fd: bool) -> io::Result<Terminal> 
                {
                    let info = Database::from_env().map_err(ti_to_io)?;
                    let sequences = sequences(&info);

                    Ok(Terminal
                    {
                        info,
                        in_fd,
                        out_fd,
                        owned_fd,
                        sequences,
                        reader: Mutex::new(Reader
                        {
                            in_buffer: Vec::new(),
                            resume: None,
                            report_signals: SignalSet::new(),
                        }),
                        writer: Mutex::new(Writer::new()),
                    })
                }

                pub fn open<P: AsRef<Path>>(path: P) -> io::Result<Terminal>
                {
                    let fd = open_rw(path)?;
                    let r = Terminal::new(fd, fd, true);

                    if r.is_err() { unsafe { close_fd(fd); } }

                    r
                }

                pub fn stdout() -> io::Result<Terminal> { Terminal::new(STDIN_FILENO, STDOUT_FILENO, false) }

                pub fn stderr() -> io::Result<Terminal> { Terminal::new(STDIN_FILENO, STDERR_FILENO, false) }

                // pub fn name(&self) -> &str { self.info.name() }

                // fn is_xterm(&self) -> bool { is_xterm(self.name()) }

                pub fn size(&self) -> io::Result<Size> { self.lock_writer().size() }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.lock_reader().wait_event(timeout) }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> { self.lock_reader().read_event(timeout) }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> { self.lock_reader().read_raw(buf, timeout) }

                pub fn enter_screen(&self) -> io::Result<()> { self.lock_writer().enter_screen() }

                pub fn exit_screen(&self) -> io::Result<()> { self.lock_writer().exit_screen() }

                pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> { self.lock_reader().prepare(config) }

                pub fn restore(&self, state: PrepareState) -> io::Result<()> { self.lock_reader().restore(state) }

                pub fn clear_screen(&self) -> io::Result<()> { self.lock_writer().clear_screen() }

                pub fn clear_to_line_end(&self) -> io::Result<()> { self.lock_writer().clear_to_line_end() }

                pub fn clear_to_screen_end(&self) -> io::Result<()> { self.lock_writer().clear_to_screen_end() }

                pub fn move_up(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_up(n)?; }

                    Ok(())
                }

                pub fn move_down(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_down(n)?; }
                    
                    Ok(())
                }

                pub fn move_left(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_left(n)?; }

                    Ok(())
                }

                pub fn move_right(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_right(n)?; }

                    Ok(())
                }

                pub fn move_to_first_column(&self) -> io::Result<()> { self.lock_writer().move_to_first_column() }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()>
                { self.lock_writer().set_cursor_mode(mode) }

                pub fn write_char(&self, ch: char) -> io::Result<()> { self.write_str(ch.encode_utf8(&mut [0; 4])) }

                pub fn write_str(&self, s: &str) -> io::Result<()> { self.lock_writer().write_str(s) }

                pub fn write_styled
                (
                    &self,
                    fg: Option<Color>,
                    bg: Option<Color>,
                    style: Style, text: &str
                ) -> io::Result<()>
                { self.lock_writer().write_styled(fg, bg, style, text) }

                pub fn clear_attributes(&self) -> io::Result<()> { self.lock_writer().clear_attributes() }

                pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> { self.lock_writer().set_fg(fg) }

                pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> { self.lock_writer().set_bg(bg) }

                pub fn add_style(&self, style: Style) -> io::Result<()> { self.lock_writer().add_style(style) }

                pub fn remove_style(&self, style: Style) -> io::Result<()> { self.lock_writer().remove_style(style) }

                pub fn set_style(&self, style: Style) -> io::Result<()> { self.lock_writer().set_style(style) }

                pub fn set_theme(&self, theme: Theme) -> io::Result<()> { self.lock_writer().set_theme(theme) }

                pub fn lock_read(&self) -> LockResult<TerminalReadGuard> 
                {
                    map_lock_result(self.reader.lock(), |r| TerminalReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> 
                {
                    map_lock_result(self.writer.lock(), |w| TerminalWriteGuard::new(self, w))
                }

                pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard> 
                {
                    map_try_lock_result(self.reader.try_lock(), |r| TerminalReadGuard::new(self, r))
                }

                pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard> 
                {
                    map_try_lock_result(self.writer.try_lock(), |w| TerminalWriteGuard::new(self, w))
                }

                fn lock_reader(&self) -> TerminalReadGuard { self.lock_read().expect("Terminal::lock_reader") }

                fn lock_writer(&self) -> TerminalWriteGuard { self.lock_write().expect("Terminal::lock_writer") }
            }

            pub struct TerminalReadGuard<'a> 
            {
                pub term: &'a Terminal,
                pub reader: MutexGuard<'a, Reader>,
            }

            pub struct TerminalWriteGuard<'a> 
            {
                term: &'a Terminal,
                writer: MutexGuard<'a, Writer>,
            }

            struct Reader 
            {
                in_buffer: Vec<u8>,
                resume: Option<Resume>,
                report_signals: SignalSet,
            }

            struct Writer 
            {
                context: Context,
                out_buffer: Vec<u8>,
                fg: Option<Color>,
                bg: Option<Color>,
                cur_style: Style,
            }

            impl Drop for Terminal 
            {
                fn drop(&mut self) {
                    if let Err(e) = self.set_cursor_mode(CursorMode::Normal) {
                        eprintln!("failed to restore terminal: {}", e);
                    }

                    if self.owned_fd {
                        unsafe { close_fd(self.out_fd); }
                    }
                }
            }

            impl<'a> TerminalReadGuard<'a> 
            {
                fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> {
                    TerminalReadGuard{term, reader}
                }

                pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState>
                {
                    let mut writer = self.term.lock_writer();
                    self.prepare_with_lock(&mut writer, config)
                }

                pub fn prepare_with_lock
                (
                    &mut self,
                    writer: &mut TerminalWriteGuard,
                    config: PrepareConfig
                ) -> io::Result<PrepareState>
                {

                    let mut state = PrepareState
                    {
                        old_tio: None,//old_tio.into(),
                        old_sigcont: None,
                        old_sigint: None,
                        old_sigtstp: None,
                        old_sigquit: None,
                        old_sigwinch: None,
                        restore_keypad: false,
                        restore_mouse: false,
                        prev_resume: self.reader.resume,
                    };
                    /*
                    TODO:
                    use nix::sys::termios::SpecialCharacterIndices::*;

                    let old_tio = tcgetattr(self.term.in_fd).map_err(nix_to_io)?;
                    let mut tio = old_tio.clone();

                    tio.input_flags.remove(
                        InputFlags::INLCR | InputFlags::ICRNL
                    );

                    tio.local_flags.remove(
                        LocalFlags::ICANON | LocalFlags::ECHO
                    );
                    
                    if config.block_signals {
                        tio.local_flags.remove(LocalFlags::ISIG);
                    } else {
                        tio.local_flags.insert(LocalFlags::ISIG);
                        
                    if config.enable_control_flow {
                        tio.input_flags.insert(InputFlags::IXON);
                    } else {
                        tio.input_flags.remove(InputFlags::IXON);
                    }
                    
                    tio.control_chars[VMIN as usize] = 0;
                    tio.control_chars[VTIME as usize] = 0;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &tio).map_err(nix_to_io)?;

                    if config.enable_mouse {
                        if writer.enable_mouse(config.always_track_motion)? {
                            state.restore_mouse = true;
                        }
                    }

                    if config.enable_keypad {
                        if writer.enable_keypad()? {
                            state.restore_keypad = true;
                        }
                    }

                    writer.flush()?;

                    let action = SigAction::new(SigHandler::Handler(handle_signal),
                        SaFlags::empty(), SigSet::all());
                        
                    state.old_sigcont = Some(unsafe { sigaction(NixSignal::SIGCONT, &action).map_err(nix_to_io)? });
                    state.old_sigwinch = Some(unsafe { sigaction(NixSignal::SIGWINCH, &action).map_err(nix_to_io)? });

                    if config.report_signals.contains(Signal::Interrupt) {
                        state.old_sigint = Some(unsafe { sigaction(NixSignal::SIGINT, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Suspend) {
                        state.old_sigtstp = Some(unsafe { sigaction(NixSignal::SIGTSTP, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Quit) {
                        state.old_sigquit = Some(unsafe { sigaction(NixSignal::SIGQUIT, &action).map_err(nix_to_io)? });
                    }

                    self.reader.report_signals = config.report_signals;
                    self.reader.resume = Some(Resume{config}); */

                    Ok(state) 
                }

                pub fn restore(&mut self, state: PrepareState) -> io::Result<()>
                {
                    let mut writer = self.term.lock_writer();
                    self.restore_with_lock(&mut writer, state)
                }

                pub fn restore_with_lock
                (
                    &mut self,
                    writer: &mut TerminalWriteGuard,
                    state: PrepareState
                ) -> io::Result<()>
                {
                    /*
                    TODO:

                    self.reader.resume = state.prev_resume;

                    if state.restore_mouse {
                        writer.disable_mouse()?;
                    }

                    if state.restore_keypad {
                        writer.disable_keypad()?;
                    }

                    writer.flush()?;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &state.old_tio.into()).map_err(nix_to_io)?;

                    unsafe {
                        if let Some(ref old) = state.old_sigcont {
                            sigaction(NixSignal::SIGCONT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigint {
                            sigaction(NixSignal::SIGINT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigtstp {
                            sigaction(NixSignal::SIGTSTP, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigquit {
                            sigaction(NixSignal::SIGQUIT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigwinch {
                            sigaction(NixSignal::SIGWINCH, old).map_err(nix_to_io)?;
                        }
                    } */

                    Ok(())
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
                {
                    /*
                    TODO:
                    if get_signal().is_some() {
                        return Ok(true);
                    }

                    if peek_event(&self.reader.in_buffer, &self.term.sequences)?.is_some() {
                        return Ok(true);
                    }

                    let mut timeout = timeout.map(to_timeval);

                    let n = loop {
                        let in_fd = self.term.in_fd;

                        let mut r_fds = FdSet::new();
                        r_fds.insert(in_fd);
                        
                        let mut e_fds = FdSet::new();
                        e_fds.insert(in_fd);

                        match select(in_fd + 1,
                                Some(&mut r_fds), None, Some(&mut e_fds), timeout.as_mut()) {
                            Ok(n) => break n,
                            Err(Errno::EINTR) =>
                                if get_signal().is_some() {
                                    return Ok(true);
                                }
                            
                            Err(e) => return Err(nix_to_io(e))
                        }
                    };

                    Ok(n != 0) */
                    Ok(true)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if let Some(ev) = self.try_read()? {
                        return Ok(Some(ev));
                    }

                    match self.read_into_buffer(timeout)? {
                        Some(Event::Raw(_)) => self.try_read(),
                        Some(Event::Signal(sig)) => {
                            if let Some(ev) = self.handle_signal(sig)? {
                                Ok(Some(ev))
                            } else {
                                Ok(None)
                            }
                        }
                        r => Ok(r)
                    }
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if !self.reader.in_buffer.is_empty() {
                        let n = buf.len().min(self.reader.in_buffer.len());
                        buf[..n].copy_from_slice(&self.reader.in_buffer[..n]);

                        let _ = self.reader.in_buffer.drain(..n);

                        return Ok(Some(Event::Raw(n)));
                    }

                    match self.read_input(buf, timeout)? {
                        Some(Event::Signal(sig)) => {
                            if let Some(event) = self.handle_signal(sig)? {
                                Ok(Some(event))
                            } else {
                                Ok(None)
                            }
                        }
                        r => Ok(r)
                    }
                }

                fn read_into_buffer(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let mut buf = replace(&mut self.reader.in_buffer, Vec::new());

                    buf.reserve(128);

                    let len = buf.len();
                    let cap = buf.capacity();
                    let r;

                    unsafe {
                        buf.set_len(cap);

                        r = self.read_input(&mut buf[len..], timeout);

                        match r {
                            Ok(Some(Event::Raw(n))) => buf.set_len(len + n),
                            _ => buf.set_len(len)
                        }
                    }
                    
                    self.reader.in_buffer = buf;

                    r
                }

                fn read_input(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
                {
                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }
                    
                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    loop {
                        match read(self.term.in_fd, buf) {
                            Ok(n) => break Ok(Some(Event::Raw(n))),
                            Err(Errno::EINTR) => {
                                if let Some(sig) = take_signal() {
                                    return Ok(Some(Event::Signal(sig)));
                                }
                            }
                            Err(e) => return Err(nix_to_io(e))
                        }
                    }
                }

                fn try_read(&mut self) -> io::Result<Option<Event>>
                {
                    let in_buffer = &mut self.reader.in_buffer;

                    if in_buffer.is_empty() {
                        Ok(None)
                    } else {
                        match peek_event(&in_buffer, &self.term.sequences) {
                            Ok(Some((ev, n))) => {
                                let _ = in_buffer.drain(..n);
                                Ok(Some(ev))
                            }
                            Ok(None) => Ok(None),
                            Err(e) => Err(e)
                        }
                    }
                }

                fn handle_signal(&mut self, sig: Signal) -> io::Result<Option<Event>> {
                    match sig {
                        Signal::Continue => {
                            self.resume()?;
                        }
                        Signal::Resize => {
                            let size = self.term.size()?;
                            return Ok(Some(Event::Resize(size)));
                        }
                        _ => ()
                    }

                    if self.reader.report_signals.contains(sig) {
                        Ok(Some(Event::Signal(sig)))
                    } else {
                        Ok(None)
                    }
                }

                fn resume(&mut self) -> io::Result<()> {
                    if let Some(resume) = self.reader.resume {
                        let _ = self.prepare(resume.config)?;
                    }
                    Ok(())
                }
            }

            pub fn terminal_read(term: &mut TerminalReadGuardian, buf: &mut Vec<u8>) -> io::Result<RawRead>
            {
                let mut buffer = [0; 1024];

                match term.read_raw(&mut buffer, Some(Duration::new(0, 0)))? 
                {
                    None => Ok(RawRead::Bytes(0)),
                    Some(Event::Raw(n)) => 
                    {
                        buf.extend(&buffer[..n]);
                        Ok(RawRead::Bytes(n))
                    }

                    Some(Event::Resize(size)) => Ok(RawRead::Resize(size)),
                    Some(Event::Signal(sig)) => Ok(RawRead::Signal(sig)),
                    _ => unreachable!()
                }
            }

            impl<'a> TerminalWriteGuard<'a> 
            {
                fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                    TerminalWriteGuard{term, writer}
                }

                pub fn size(&self) -> io::Result<Size> {
                    get_winsize(self.term.out_fd)
                }

                fn disable_keypad(&mut self) -> io::Result<()> 
                {
                    if let Some(local) = self.term.info.read::<mode::KeypadLocal>() {
                        self.expand(local.expand())?;
                    }
                    Ok(())
                }

                fn enable_keypad(&mut self) -> io::Result<bool> 
                {
                    if let Some(xmit) = self.term.info.read::<mode::KeypadXmit>() 
                    {
                        self.expand(xmit.expand())?;
                        Ok(true)
                    } else {
                        Ok(false)
                    }
                }

                fn disable_mouse(&mut self) -> io::Result<()> 
                {
                    self.write_bytes(XTERM_DISABLE_MOUSE.as_bytes())?;
                    self.write_bytes(XTERM_DISABLE_MOUSE_MOTION.as_bytes())
                }

                fn enable_mouse(&mut self, track_motion: bool) -> io::Result<bool> 
                {
                    /*
                    TODO:
                    if self.term.is_xterm()
                    {
                        self.write_bytes(XTERM_ENABLE_MOUSE.as_bytes())?;
                        if track_motion {
                            self.write_bytes(XTERM_ENABLE_MOUSE_MOTION.as_bytes())?;
                        }
                        Ok(true)
                    } else {
                        Ok(false)
                    } */
                    Ok(true)
                }

                fn enter_screen(&mut self) -> io::Result<()> 
                {
                    match (self.term.info.read::<mode::EnterCaMode>(),
                            self.term.info.read::<mode::ChangeScrollRegion>(),
                            self.term.info.read::<mode::CursorHome>()) {
                        (enter, Some(scroll), Some(home)) => {
                            let size = self.size()?;

                            if let Some(enter) = enter {
                                self.expand(enter.expand())?;
                            }

                            self.expand(scroll.expand()
                                .parameters(0, to_u32(size.lines - 1)))?;
                            self.expand(home.expand())?;
                        }
                        (_, None, _) => return Err(not_supported("change_scroll_region")),
                        (_, _, None) => return Err(not_supported("cursor_home")),
                    }

                    self.clear_attributes()?;
                    self.clear_screen()?;

                    Ok(())
                }

                fn exit_screen(&mut self) -> io::Result<()> 
                {
                    if let Some(exit) = self.term.info.read::<mode::ExitCaMode>() {
                        self.expand(exit.expand())?;
                        self.flush()?;
                    }

                    Ok(())
                }

                pub fn clear_attributes(&mut self) -> io::Result<()> {
                    if self.writer.fg.is_some() || self.writer.bg.is_some() ||
                            !self.writer.cur_style.is_empty() {
                        self.writer.fg = None;
                        self.writer.bg = None;
                        self.writer.cur_style = Style::empty();
                        expand_opt!(self, mode::ExitAttributeMode)?;
                    }

                    Ok(())
                }

                pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                    if self.writer.fg == fg {
                        Ok(())
                    } else {
                        if let Some(fg) = fg {
                            self.set_fg_color(fg)?;
                        } else {
                            self.clear_fg()?;
                        }

                        self.writer.fg = fg;
                        Ok(())
                    }
                }

                pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                    if self.writer.bg == bg {
                        Ok(())
                    } else {
                        if let Some(bg) = bg {
                            self.set_bg_color(bg)?;
                        } else {
                            self.clear_bg()?;
                        }

                        self.writer.bg = bg;
                        Ok(())
                    }
                }

                pub fn add_style(&mut self, style: Style) -> io::Result<()>
                {
                    let add = style - self.writer.cur_style;

                    if add.contains(Style::BOLD) {
                        expand_opt!(self, mode::EnterBoldMode)?;
                    }
                    if add.contains(Style::ITALIC) {
                        expand_opt!(self, mode::EnterItalicsMode)?;
                    }
                    if add.contains(Style::REVERSE) {
                        expand_opt!(self, mode::EnterReverseMode)?;
                    }
                    if add.contains(Style::UNDERLINE) {
                        expand_opt!(self, mode::EnterUnderlineMode)?;
                    }

                    self.writer.cur_style |= add;

                    Ok(())
                }

                pub fn remove_style(&mut self, style: Style) -> io::Result<()> 
                {
                    let remove = style & self.writer.cur_style;

                    if remove.intersects(Style::BOLD | Style::REVERSE) 
                    {
                        let new_style = self.writer.cur_style - remove;
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.add_style(new_style)?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                    }

                    else 
                    {
                        if remove.contains(Style::ITALIC) {
                            expand_opt!(self, mode::ExitItalicsMode)?;
                        }
                        if remove.contains(Style::UNDERLINE) {
                            expand_opt!(self, mode::ExitUnderlineMode)?;
                        }

                        self.writer.cur_style -= remove;
                    }

                    Ok(())
                }

                pub fn set_style(&mut self, style: Style) -> io::Result<()> 
                {
                    let add = style - self.writer.cur_style;
                    let remove = self.writer.cur_style - style;

                    if remove.intersects(Style::BOLD | Style::REVERSE) 
                    {
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                        self.add_style(style)?;
                    } 
                    else 
                    {
                        self.add_style(add)?;
                        self.remove_style(remove)?;
                    }

                    Ok(())
                }

                pub fn set_theme(&mut self, theme: Theme) -> io::Result<()>
                { self.set_attrs(theme.fg, theme.bg, theme.style) }

                pub fn set_attrs(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()>
                {
                    if (self.writer.fg.is_some() && fg.is_none()) || (self.writer.bg.is_some() && bg.is_none())
                    { self.clear_attributes()?; }

                    self.set_style(style)?;
                    self.set_fg(fg)?;
                    self.set_bg(bg)?;
                    Ok(())
                }

                fn clear_fg(&mut self) -> io::Result<()> 
                {
                    let bg = self.writer.bg;
                    let style = self.writer.cur_style;
                    self.clear_attributes()?;
                    self.set_bg(bg)?;
                    self.set_style(style)
                }

                fn clear_bg(&mut self) -> io::Result<()> 
                {
                    let fg = self.writer.fg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_fg(fg)?;
                    self.set_style(style)
                }

                fn set_fg_color(&mut self, fg: Color) -> io::Result<()> 
                {
                    expand_opt!(self, mode::SetAForeground,
                        |ex| ex.parameters(color_code(fg)))
                }

                fn set_bg_color(&mut self, bg: Color) -> io::Result<()> 
                {
                    expand_opt!(self, mode::SetABackground,
                        |ex| ex.parameters(color_code(bg)))
                }

                pub fn clear_screen(&mut self) -> io::Result<()> 
                {
                    expand_req!(self, mode::ClearScreen, "clear_screen")
                }

                pub fn clear_to_line_end(&mut self) -> io::Result<()> 
                {
                    expand_req!(self, mode::ClrEol, "clr_eol")
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()> 
                {
                    expand_req!(self, mode::ClrEos, "clr_eos")
                }

                pub fn move_up(&mut self, n: usize) -> io::Result<()> 
                {
                    if n == 1 {
                        expand_req!(self, mode::CursorUp, "cursor_up")?;
                    } else if n != 0 {
                        expand_req!(self, mode::ParmUpCursor, "parm_cursor_up",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_down(&mut self, n: usize) -> io::Result<()> 
                {
                    if n != 0 {
                        expand_req!(self, mode::ParmDownCursor, "parm_cursor_down",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_left(&mut self, n: usize) -> io::Result<()> 
                {
                    if n == 1 {
                        expand_req!(self, mode::CursorLeft, "cursor_left")?;
                    } else if n != 0 {
                        expand_req!(self, mode::ParmLeftCursor, "parm_cursor_left",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> 
                {
                    if n == 1 {
                        expand_req!(self, mode::CursorRight, "cursor_right")?;
                    } else if n != 0 {
                        expand_req!(self, mode::ParmRightCursor, "parm_cursor_right",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_to_first_column(&mut self) -> io::Result<()> { self.write_bytes(b"\r") }

                pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> 
                {
                    match (self.term.info.read::<mode::CursorAddress>(), self.term.info.read::<mode::CursorHome>())
                    {
                        (_, Some(ref home)) if pos == Cursor::default() => { self.expand(home.expand())?; }

                        (Some(addr), _) =>
                        { self.expand(addr.expand().parameters(to_u32(pos.line), to_u32(pos.column)))?; }

                        (None, _) => return Err(not_supported("cursor_address"))
                    }

                    Ok(())
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                {
                    /*
                    TODO
                    match mode
                    {
                        CursorMode::Normal | CursorMode::Overwrite =>
                        {
                            expand_opt!(self, mode::CursorNormal)?;
                        }
                        
                        CursorMode::Invisible =>
                        {
                            expand_opt!(self, mode::CursorInvisible)?;
                        }
                    } */

                    Ok(())
                }

                pub fn write_char(&mut self, ch: char) -> io::Result<()> {
                    self.write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                    self.write_bytes(s.as_bytes())
                }

                pub fn write_styled(&mut self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.set_attrs(fg, bg, style)?;

                    self.write_str(text)?;
                    self.clear_attributes()
                }

                fn write_bytes(&mut self, buf: &[u8]) -> io::Result<()> {
                    if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                        self.flush()?;
                    }

                    if buf.len() > self.writer.out_buffer.capacity() {
                        self.write_data(buf).1
                    } else {
                        self.writer.out_buffer.extend(buf);
                        Ok(())
                    }
                }

                pub fn flush(&mut self) -> io::Result<()>
                {
                    let (n, res) = self.write_data(&self.writer.out_buffer);
                    self.writer.out_buffer.drain(..n);
                    res
                }

                fn write_data(&self, buf: &[u8]) -> (usize, io::Result<()>) 
                {
                    /*
                    TODO:
                    the trait bound `i32: AsFd` is not satisfied

                    let mut offset = 0;

                    let r = loop 
                    {
                        if offset == buf.len() { break Ok(()); }

                        match write(self.term.out_fd, buf) 
                        {
                            Ok(0) => break Err(io::Error::from(io::ErrorKind::WriteZero)),
                            Ok(n) => offset += n,
                            Err(Errno::EINTR) => continue,
                            Err(e) => break Err(nix_to_io(e))
                        }
                    };

                    (offset, r) */
                    (0, Ok(()))
                }

                fn expand<T: AsRef<[u8]>>(&mut self, exp: Expansion<T>) -> io::Result<()>
                {
                    let writer = &mut *self.writer;
                    exp.with(&mut writer.context)
                    .from(&mut writer.out_buffer)
                    .map_err(ti_to_io)
                }
            }

            impl<'a> Drop for TerminalWriteGuard<'a> 
            {
                fn drop(&mut self) 
                {
                    if let Err(e) = self.flush() 
                    {
                        eprintln!("failed to flush terminal: {}", e);
                    }
                }
            }

            impl Writer 
            {
                fn new() -> Writer 
                {
                    Writer
                    {
                        context: Context::default(),
                        out_buffer: Vec::with_capacity(OUT_BUFFER_SIZE),
                        fg: None,
                        bg: None,
                        cur_style: Style::empty(),
                    }
                }
            }

            fn is_xterm(name: &str) -> bool 
            {
                name == "xterm" || name.starts_with("xterm-")
            }

            fn sequences(info: &Database) -> SeqMap 
            {
                let mut map = SequenceMap::new();
                /*
                    macro_rules! add 
                    {
                        ( $seq:ty , $key:expr ) => { {
                            if let Some(seq) = info.get::<$seq>() {
                                if let Some(s) = ascii_str(seq.as_ref()) {
                                    sequences.insert(s.into(), SeqData::Key($key));
                                }
                            }
                        } }
                    }

                    add!(mode::KeyUp,        Key::Up);
                    add!(mode::KeyDown,      Key::Down);
                    add!(mode::KeyLeft,      Key::Left);
                    add!(mode::KeyRight,     Key::Right);
                    add!(mode::KeyHome,      Key::Home);
                    add!(mode::KeyEnd,       Key::End);
                    add!(mode::KeyNPage,     Key::PageDown);
                    add!(mode::KeyPPage,     Key::PageUp);
                    add!(mode::KeyDc,        Key::Delete);
                    add!(mode::KeyIc,        Key::Insert);
                    add!(mode::KeyF1,        Key::F(1));
                    add!(mode::KeyF2,        Key::F(2));
                    add!(mode::KeyF3,        Key::F(3));
                    add!(mode::KeyF4,        Key::F(4));
                    add!(mode::KeyF5,        Key::F(5));
                    add!(mode::KeyF6,        Key::F(6));
                    add!(mode::KeyF7,        Key::F(7));
                    add!(mode::KeyF8,        Key::F(8));
                    add!(mode::KeyF9,        Key::F(9));
                    add!(mode::KeyF10,       Key::F(10));
                    add!(mode::KeyF11,       Key::F(11));
                    add!(mode::KeyF12,       Key::F(12));

                    if is_xterm(info.name()) { sequences.insert(XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse); }
                */

                map
            }

            pub struct PrepareState 
            {
                old_tio: Option<termios>,
                old_sigcont: Option<SigAction>,
                old_sigint: Option<SigAction>,
                old_sigtstp: Option<SigAction>,
                old_sigquit: Option<SigAction>,
                old_sigwinch: Option<SigAction>,
                restore_keypad: bool,
                restore_mouse: bool,
                prev_resume: Option<Resume>,
            }

            #[derive(Copy, Clone, Debug)]
            struct Resume 
            {
                config: PrepareConfig,
            }

            unsafe fn close_fd(fd: RawFd) 
            {
                drop(File::from_raw_fd(fd));
            }

            fn open_rw<P: AsRef<Path>>(path: P) -> io::Result<RawFd> 
            {
                use std::fs::OpenOptions;

                let file = OpenOptions::new()
                    .read(true)
                    .write(true)
                    .open(path)?;

                Ok(file.into_raw_fd())
            }

            #[repr(C)]
            struct Winsize 
            {
                ws_row: c_ushort,
                ws_col: c_ushort,
                ws_xpixel: c_ushort,
                ws_ypixel: c_ushort,
            }

            fn get_winsize(fd: c_int) -> io::Result<Size> 
            {
                unsafe
                {
                    let mut winsz: Winsize = zeroed();
                    let res = ioctl(fd, TIOCGWINSZ.into(), &mut winsz);

                    if res == -1 { Err(io::Error::last_os_error()) }
                    else
                    {
                        Ok
                        (
                            Size
                            {
                                lines: winsz.ws_row as usize,
                                columns: winsz.ws_col as usize,
                            }    
                        )
                    }
                } 
            }

            fn nix_to_io(e: nix::Error) -> io::Error 
            {
                io::Error::from_raw_os_error(e as i32)
            }
            
            fn ti_to_io(e: OverError) -> io::Error 
            {
                match e 
                {
                    OverError::Unfounded => io::Error::new( io::ErrorKind::NotFound, "terminfo entry not found"),
                    OverError::IoError(e) => io::Error::new( io::ErrorKind::Other, "IO error."),                    
                    OverError::ParseError( e ) => io::Error::new( io::ErrorKind::Other, "failed to parse terminfo entry"),
                    OverError::ExpandError( e ) => io::Error::new( io::ErrorKind::Other, "failed to expand terminfo entry"),
                    _ => io::Error::new( io::ErrorKind::Other, "Unknown error."),   
                }
            } 

            fn to_timeval(d: Duration) -> TimeVal 
            {
                const MAX_SECS: i64 = i64::max_value() / 1_000;

                let secs = match d.whole_seconds() 
                {
                    n if n > (MAX_SECS as u64).try_into().unwrap() => MAX_SECS,
                    n => n as i64,
                };

                let millis = d.subsec_milliseconds() as i64;

                TimeVal::milliseconds(secs * 1_000 + millis)
            }

            fn peek_event(buf: &[u8], sequences: &SeqMap) -> io::Result<Option<(Event, usize)>>
            {
                let (res, n) = {
                    let s = utf8_prefix(buf)?;

                    if s.is_empty() {
                        return Ok(None);
                    }

                    let mut last_match = None;

                    for pfx in prefixes(s) {
                        match sequences.find(pfx) {
                            FindResult::NotFound => break,
                            FindResult::Found(value) => {
                                last_match = Some((pfx, *value));
                                break;
                            }
                            FindResult::Incomplete => (),
                            FindResult::Undecided(value) => {
                                last_match = Some((pfx, *value));
                            }
                        }
                    }

                    let res = last_match.and_then(|(seq, value)| 
                    {
                        match value {
                            SeqData::Key(key) => Some((Event::Key(key), seq.len())),
                            SeqData::XTermMouse => {
                                if let Some((data, len)) = parse_mouse_data(&buf[seq.len()..]) {
                                    Some((Event::Mouse(data), seq.len() + len))
                                } else {
                                    None
                                }
                            }
                        }
                    });

                    if let Some(res) = res {
                        res
                    } else {
                        let ch = s.chars().next().unwrap();
                        (Event::Key(ch.into()), ch.len_utf8())
                    }
                };

                Ok(Some((res, n)))
            }

            fn parse_mouse_data(mut buf: &[u8]) -> Option<(MouseEvent, usize)> 
            {
                let orig_len = buf.len();

                let (mut input, end) = parse_integer(&mut buf)?;

                if end != b';' {
                    return None;
                }

                let (column, end) = parse_integer(&mut buf)?;

                if end != b';' {
                    return None;
                }

                let (line, end) = parse_integer(&mut buf)?;

                let is_pressed = match end {
                    b'M' => true,
                    b'm' => false,
                    _ => return None
                };

                let mut mods = ModifierState::empty();

                if (input & XTERM_SHIFT_MASK) != 0 {
                    mods |= ModifierState::SHIFT;
                }
                if (input & XTERM_META_MASK) != 0 {
                    mods |= ModifierState::ALT;
                }
                if (input & XTERM_CTRL_MASK) != 0 {
                    mods |= ModifierState::CTRL;
                }

                input &= !XTERM_MODIFIER_MASK;

                let input = match input {
                    0 ..= 3 => mouse_button_event(input, is_pressed),
                    64 => MouseInput::WheelUp,
                    65 => MouseInput::WheelDown,
                    _ => MouseInput::Motion,
                };

                let position = Cursor{
                    line: (line - 1) as usize,
                    column: (column - 1) as usize,
                };

                Some((MouseEvent{
                    position,
                    input,
                    modifiers: mods,
                }, orig_len - buf.len()))
            }

            fn parse_integer(buf: &mut &[u8]) -> Option<(u32, u8)> 
            {
                let mut n = 0u32;
                let mut iter = buf.iter();

                while let Some(&b) = iter.next() {
                    match b {
                        b'0' ..= b'9' => {
                            n = n.checked_mul(10)?
                                .checked_add((b - b'0') as u32)?;
                        }
                        _ => {
                            *buf = iter.as_slice();
                            return Some((n, b));
                        }
                    }
                }

                None
            }

            fn mouse_button_event(input: u32, is_pressed: bool) -> MouseInput 
            {
                let button = match input {
                    0 => MouseButton::Left,
                    1 => MouseButton::Middle,
                    2 => MouseButton::Right,
                    _ => MouseButton::Other(input)
                };

                if is_pressed {
                    MouseInput::ButtonPressed(button)
                } else {
                    MouseInput::ButtonReleased(button)
                }
            }

            fn utf8_prefix(buf: &[u8]) -> io::Result<&str> 
            {
                match from_utf8(buf) {
                    Ok(s) => Ok(s),
                    Err(e) => {
                        if e.valid_up_to() != 0 {
                            from_utf8(&buf[..e.valid_up_to()])
                                .map_err(|_| unreachable!())
                        } else if e.error_len().is_some() {
                            Err(io::Error::new(io::ErrorKind::Other,
                                "read invalid utf-8 data from terminal"))
                        } else {
                            Ok("")
                        }
                    }
                }
            }

            static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(0);

            extern "C" fn handle_signal(signum: c_int) 
            {
                LAST_SIGNAL.store(signum as usize, Ordering::Relaxed);
            }

            fn conv_signal(sig: c_int) -> Option<Signal> 
            {
                match NixSignal::try_from(sig).ok() {
                    Some(NixSignal::SIGCONT)  => Some(Signal::Continue),
                    Some(NixSignal::SIGINT)   => Some(Signal::Interrupt),
                    Some(NixSignal::SIGQUIT)  => Some(Signal::Quit),
                    Some(NixSignal::SIGTSTP)  => Some(Signal::Suspend),
                    Some(NixSignal::SIGWINCH) => Some(Signal::Resize),
                    _ => None
                }
            }

            fn get_signal() -> Option<Signal> 
            {
                conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as c_int)
            }

            fn take_signal() -> Option<Signal> 
            {
                conv_signal(LAST_SIGNAL.swap(0, Ordering::Relaxed) as c_int)
            }

            fn ascii_str(s: &[u8]) -> Option<&str> 
            {
                use std::str::from_utf8_unchecked;

                if s.is_ascii() {
                    Some(unsafe { from_utf8_unchecked(s) })
                } else {
                    None
                }
            }

            fn color_code(color: Color) -> u8 
            {
                match color {
                    Color::Black =>     0,
                    Color::Red =>       1,
                    Color::Green =>     2,
                    Color::Yellow =>    3,
                    Color::Blue =>      4,
                    Color::Magenta =>   5,
                    Color::Cyan =>      6,
                    Color::White =>     7,
                }
            }

            fn not_supported(op: &str) -> io::Error 
            {
                io::Error::new(io::ErrorKind::Other,
                    format!("operation not supported: {}", op))
            }

            #[cfg(target_pointer_width = "64")]
            fn to_u32(u: usize) -> u32 
            {
                if u > u32::max_value() as usize {
                    u32::max_value()
                } else {
                    u as u32
                }
            }

            #[cfg(any(target_pointer_width = "16", target_pointer_width = "32"))]
            fn to_u32(u: usize) -> u32 
            {
                u as u32
            }
        } pub use self::terminal::{ * };
        
        impl OpenTerminalExt for system::Terminal 
        {
            fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self>
            { Terminal::open( path ).map( system::Terminal ) }
        }
        
        impl TerminalExt for system::Terminal 
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_raw(buf, timeout) }
        }
        
        impl<'a> TerminalExt for system::TerminalReadGuardian<'a> 
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_raw(buf, timeout) }
        }
    } #[cfg( unix )] pub use self::unix as sys;

    #[cfg( windows )] pub mod windows
    {
        //! Windows platform support
        use ::
        {
            libc::windows::{ * },
            system::{ Event },
            time::{ Duration },
            *,
        };
        /*
            pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };
            pub use self::terminal::{ PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard };
            pub use self::console::terminal_read;
        */
        pub mod ext
        {
            //! Windows console extension trait
            use ::
            {
                libc::windows::{ * },
                time::{ Duration },
                system::{ Event },
                *,
            };
            /*
            use std::io;
            use std::time::Duration;

            use winapi::um::wincon::INPUT_RECORD;
            
            use mortal::terminal::Event; */
            /// Implements Windows-only extensions for terminal interfaces.
            pub trait TerminalExt
            {
                /// Reads raw data from the console.
                fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>;
                /// Reads raw event data from the console.
                fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) ->
                io::Result<Option<Event>>;
            }
        } pub use self::ext::{ * };

        pub mod path
        {
            use ::
            {
                env::{ var_os },
                path::{ * },
                *,
            };
            /*
            use std::env::var_os;
            use std::path::PathBuf;
            use dirs::data_dir; */
            pub fn env_init_file() -> Option<PathBuf> { var_os("INPUTRC").map(PathBuf::from) }

            pub fn system_init_file() -> Option<PathBuf> { None }

            pub fn user_init_file() -> Option<PathBuf> { data_dir().map(|p| p.join(r"linefeed\inputrc")) }
        } pub use self::path::{ * };

        pub mod screen
        {
            use ::
            {
                libc::windows::{ * },
                sync::{ LockResult, map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result, Mutex, MutexGuard, TryLockResult },
                system::{ * },
                time::Duration,
                *,
            };            
            /*
            use winapi::shared::ntdef::HANDLE;
            use winapi::um::wincon::INPUT_RECORD;

            use mortal::buffer::ScreenBuffer;
            use mortal::sys::terminal::
            {
                size_event, PrepareState,
                Terminal, TerminalReadGuard, TerminalWriteGuard,
            };
            use mortal::terminal::{Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style};
            */

            pub struct Screen
             {
                term: Terminal,
                state: Option<PrepareState>,
                old_handle: HANDLE,
                writer: Mutex<Writer>,
            }

            pub struct ScreenReadGuard<'a>
            {
                screen: &'a Screen,
                reader: TerminalReadGuard<'a>,
            }

            pub struct ScreenWriteGuard<'a> {
                writer: TerminalWriteGuard<'a>,
                data: MutexGuard<'a, Writer>,
            }

            struct Writer 
            {
                buffer: ScreenBuffer,
                clear_screen: bool,
                real_cursor: Cursor,
            }

            impl Screen 
            {
                pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen> 
                {
                    let size = term.size()?;
                    let old_handle = term.enter_screen()?;
                    let state = term.prepare(config)?;

                    Ok(Screen
                    {
                        term,
                        state: Some(state),
                        writer: Mutex::new(Writer
                        {
                            buffer: ScreenBuffer::new(size),
                            clear_screen: false,
                            real_cursor: Cursor::default(),
                        }),
                        old_handle,
                    })
                }

                pub fn stdout(config: PrepareConfig) -> io::Result<Screen> { Screen::new(Terminal::stdout()?, config) }

                pub fn stderr(config: PrepareConfig) -> io::Result<Screen> { Screen::new(Terminal::stderr()?, config) }

                forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                pub fn lock_read(&self) -> LockResult<ScreenReadGuard> {
                    map_lock_result(self.term.lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> {
                    map_try_lock_result(self.term.try_lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> {
                    map2_lock_result(self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> {
                    map2_try_lock_result(self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                fn lock_reader(&self) -> ScreenReadGuard {
                    self.lock_read().expect("Screen::lock_reader")
                }

                fn lock_writer(&self) -> ScreenWriteGuard {
                    self.lock_write().expect("Screen::lock_writer")
                }

                fn lock_write_data(&self) -> MutexGuard<Writer> {
                    self.writer.lock().expect("Screen::lock_writer")
                }

                pub fn name(&self) -> &str {
                    self.term.name()
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                    self.term.set_cursor_mode(mode)
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn read_raw_event(&self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw_event(events, timeout)
                }

                pub fn refresh(&self) -> io::Result<()> {
                    self.lock_writer().refresh()
                }
            }

            impl Drop for Screen 
            {
                fn drop(&mut self) {
                    let res = if let Some(state) = self.state.take() {
                        self.term.restore(state)
                    } else {
                        Ok(())
                    };

                    if let Err(e) = res.and_then(
                            |_| unsafe { self.term.exit_screen(self.old_handle) }) {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            unsafe impl Send for Screen {}
            unsafe impl Sync for Screen {}

            impl<'a> ScreenReadGuard<'a> 
            {
                fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> {
                    ScreenReadGuard{screen, reader}
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.reader.wait_event(timeout)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_event(timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_raw(buf, timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw_event(&mut self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_raw_event(events, timeout)?;

                    if let Some(Event::Raw(n)) = r {
                        for ev in events[..n].iter().rev() {
                            if let Some(size) = size_event(ev) {
                                self.screen.lock_write_data().update_size(size);
                                break;
                            }
                        }
                    }

                    Ok(r)
                }
            }

            impl<'a> ScreenWriteGuard<'a> 
            {
                fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>) -> ScreenWriteGuard<'a>
                { ScreenWriteGuard{writer, data} }

                forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                { self.writer.set_cursor_mode(mode) }

                pub fn refresh(&mut self) -> io::Result<()>
                {
                    if self.data.clear_screen
                    {
                        self.writer.clear_screen()?;
                        self.data.clear_screen = false;
                    }

                    let mut real_attrs = (None, None, Style::empty());
                    self.writer.clear_attributes()?;
                    let mut indices = self.data.buffer.indices();

                    while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices)
                    {
                        self.move_cursor(pos)?;
                        self.apply_attrs(real_attrs, cell.attrs())?;
                        self.writer.write_str(cell.text())?;
                        self.data.real_cursor.column += 1;
                        real_attrs = cell.attrs();
                    }

                    self.writer.clear_attributes()?;
                    let size = self.data.buffer.size();
                    let pos = self.data.buffer.cursor();

                    if pos.is_out_of_bounds(size) {
                        self.move_cursor(Cursor::last(size))?;
                    } else {
                        self.move_cursor(pos)?;
                    }

                    Ok(())
                }

                fn apply_attrs
                (
                    &mut self,
                    src: (Option<Color>, Option<Color>, Style),
                    dest: (Option<Color>, Option<Color>, Style)
                ) -> io::Result<()>
                {
                    if src != dest { self.writer.set_attributes(dest.0, dest.1, dest.2)?; }

                    Ok(())
                }

                fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> 
                {
                    if self.data.real_cursor != pos 
                    {
                        self.writer.move_cursor(pos)?;
                        self.data.real_cursor = pos;
                    }

                    Ok(())
                }
            }

            impl<'a> Drop for ScreenWriteGuard<'a> 
            {
                fn drop(&mut self) {
                    if let Err(e) = self.refresh() {
                        eprintln!("failed to refresh screen: {}", e);
                    }
                }
            }

            impl Writer
            {
                fn update_size(&mut self, new_size: Size) {
                    if self.real_cursor.is_out_of_bounds(new_size) {
                        self.real_cursor = (!0, !0).into();
                    }
                    self.buffer.resize(new_size);
                    self.clear_screen = true;
                }
            }
        } pub use self::screen::{ * };

        pub mod terminal
        {
            use ::
            {
                char::{ DELETE, unctrl_lower },
                ffi::OsStr,
                libc::windows::{ * },
                mem::{ replace, zeroed },
                os::raw::{ c_int },
                sync::{ atomic::{ AtomicUsize, Ordering }, LockResult, map_lock_result, map_try_lock_result, Mutex, MutexGuard, TryLockResult },
                system::{ * },
                time::Duration,
                *,
            };
            /*
            use linefeed::chars::DELETE;
            use linefeed::terminal::RawRead;

            use winapi::shared::minwindef::{
                DWORD,
                TRUE,
            };
            use winapi::um::{
                self,
                INPUT_RECORD,
                KEY_EVENT,
                KEY_EVENT_RECORD,
            };
            use winapi::um::winuser;
            
            use mortal::{Event, TerminalReadGuard};
            use mortal::windows::TerminalExt;
            use mortal::priv_util::{map_lock_result, map_try_lock_result};
            use mortal::signal::{Signal, SignalSet};
            use mortal::terminal::{
                Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                MouseButton, MouseEvent, MouseInput, ModifierState,
            };
            use mortal::util::unctrl_lower;

            use winapi::ctypes::c_int;
            use winapi::shared::winerror::{
                WAIT_TIMEOUT,
            };
            use winapi::shared::minwindef::{
                FALSE, TRUE,
                BOOL, DWORD, WORD,
            };
            use winapi::shared::ntdef::{
                CHAR, SHORT, VOID, WCHAR, HANDLE,
            };
            use winapi::um::consoleapi::{
                SetConsoleCtrlHandler,
                GetConsoleMode,
                ReadConsoleW,
                ReadConsoleInputW,
                WriteConsoleW,
                SetConsoleMode,
            };
            use winapi::um::handleapi::{
                CloseHandle,
            };
            use winapi::um::processenv::{
                GetStdHandle,
            };
            use winapi::um::synchapi::{
                WaitForSingleObject,
            };
            use winapi::um::winbase::{
                INFINITE,
                STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, STD_ERROR_HANDLE,
                WAIT_FAILED, WAIT_OBJECT_0,
            };
            use winapi::um::{
                self,
                CreateConsoleScreenBuffer,
                WriteConsoleInputW,
                FillConsoleOutputAttribute,
                FillConsoleOutputCharacterA,
                ScrollConsoleScreenBufferW,
                SetConsoleActiveScreenBuffer,
                SetConsoleCursorInfo,
                SetConsoleCursorPosition,
                SetConsoleScreenBufferSize,
                GetConsoleScreenBufferInfo,
                SetConsoleTextAttribute,
                SetConsoleWindowInfo,
                CHAR_INFO, CHAR_INFO_Char, CONSOLE_CURSOR_INFO, CONSOLE_SCREEN_BUFFER_INFO,
                COORD, SMALL_RECT,
                CONSOLE_TEXTMODE_BUFFER,
                INPUT_RECORD,
                CTRL_BREAK_EVENT, CTRL_C_EVENT,
                ENABLE_ECHO_INPUT, ENABLE_LINE_INPUT, ENABLE_MOUSE_INPUT,
                ENABLE_EXTENDED_FLAGS, ENABLE_QUICK_EDIT_MODE, ENABLE_WINDOW_INPUT,
                DISABLE_NEWLINE_AUTO_RETURN,
                ENABLE_VIRTUAL_TERMINAL_INPUT,
                ENABLE_PROCESSED_INPUT,
                ENABLE_PROCESSED_OUTPUT, ENABLE_WRAP_AT_EOL_OUTPUT,
                KEY_EVENT, MOUSE_EVENT, WINDOW_BUFFER_SIZE_EVENT,
            };
            use winapi::um::winuser;
            use winapi::um::winnt::{
                GENERIC_READ, GENERIC_WRITE,
                FILE_SHARE_READ, FILE_SHARE_WRITE,
            };
            */
            const HOME_SEQ: &str = "\x1b[H";
            const END_SEQ: &str = "\x1b[F";
            const INSERT_SEQ: &str = "\x1b[2~";
            const DELETE_SEQ: &str = "\x1b[3~";
            const PAGE_UP_SEQ: &str = "\x1b[5~";
            const PAGE_DOWN_SEQ: &str = "\x1b[6~";

            struct SeqGroup 
            {
                norm: &'static str,
                ctrl: &'static str,
                shift: &'static str,
                alt: &'static str,
                ctrl_shift: &'static str,
                ctrl_alt: &'static str,
                shift_alt: &'static str,
                ctrl_shift_alt: &'static str,
            }

            impl SeqGroup 
            {
                fn select(&self, state: DWORD) -> &'static str {
                    match (has_ctrl(state), has_shift(state), has_alt(state)) {
                        (false, false, false) => self.norm,
                        (true,  false, false) => self.ctrl,
                        (false, true,  false) => self.shift,
                        (true,  true,  false) => self.ctrl_shift,
                        (false, false, true)  => self.alt,
                        (true,  false, true)  => self.ctrl_alt,
                        (false, true,  true)  => self.shift_alt,
                        (true,  true,  true)  => self.ctrl_shift_alt,
                    }
                }
            }

            macro_rules! seq_group 
            {
                ( $name:ident , $ch:expr ) => {
                    const $name: SeqGroup = SeqGroup {
                        norm:           concat!("\x1b[",  $ch),
                        ctrl:           concat!("\x1b[1", $ch),
                        shift:          concat!("\x1b[2", $ch),
                        alt:            concat!("\x1b[4", $ch),
                        ctrl_shift:     concat!("\x1b[3", $ch),
                        ctrl_alt:       concat!("\x1b[5", $ch),
                        shift_alt:      concat!("\x1b[6", $ch),
                        ctrl_shift_alt: concat!("\x1b[7", $ch),
                    };
                }
            }

            seq_group!{ UP_SEQ, "A" }
            seq_group!{ DOWN_SEQ, "B" }
            seq_group!{ RIGHT_SEQ, "C" }
            seq_group!{ LEFT_SEQ, "D" }

            pub fn terminal_read(term: &mut TerminalReadGuard, buf: &mut Vec<u8>) -> io::Result<RawRead> 
            {
                let mut events: [INPUT_RECORD; 1] = unsafe { zeroed() };

                let n = match term.read_raw_event(&mut events, Some(Duration::new(0, 0)))? {
                    Some(Event::Raw(n)) => n,
                    None => return Ok(RawRead::Bytes(0)),
                    Some(Event::Resize(size)) => return Ok(RawRead::Resize(size)),
                    Some(Event::Signal(sig)) => return Ok(RawRead::Signal(sig)),
                    _ => unreachable!()
                };

                if n == 1 {
                    let old_len = buf.len();

                    translate_event(buf, &events[0]);

                    Ok(RawRead::Bytes(buf.len() - old_len))
                } else {
                    Ok(RawRead::Bytes(0))
                }
            }

            fn translate_event(buf: &mut Vec<u8>, event: &INPUT_RECORD) 
            {
                if event.EventType == KEY_EVENT {
                    translate_key(buf, unsafe { event.Event.KeyEvent() });
                }
            }

            fn translate_key(buf: &mut Vec<u8>, event: &KEY_EVENT_RECORD) 
            {
                if event.bKeyDown == TRUE {
                    let start = buf.len();

                    match event.wVirtualKeyCode as c_int {
                        VK_BACK    => buf.push(DELETE as u8),
                        VK_TAB     => buf.push(b'\t'),
                        VK_RETURN  => {
                            buf.push(b'\r');
                        }
                        VK_ESCAPE  => buf.push(b'\x1b'),
                        VK_PRIOR   => buf.extend(PAGE_UP_SEQ.as_bytes()),
                        VK_NEXT    => buf.extend(PAGE_DOWN_SEQ.as_bytes()),
                        VK_END     => buf.extend(END_SEQ.as_bytes()),
                        VK_HOME    => buf.extend(HOME_SEQ.as_bytes()),
                        VK_LEFT    => {
                            buf.extend(LEFT_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        VK_UP      => {
                            buf.extend(UP_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        VK_RIGHT   => {
                            buf.extend(RIGHT_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        VK_DOWN    => {
                            buf.extend(DOWN_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        VK_INSERT  => buf.extend(INSERT_SEQ.as_bytes()),
                        VK_DELETE  => buf.extend(DELETE_SEQ.as_bytes()),
                        _ => {
                            let u_ch = unsafe { *event.uChar.UnicodeChar() };
                            if u_ch != 0 {
                                if let Some(ch) = char::from_u32(u_ch as u32) {
                                    let mut bytes = [0; 4];
                                    buf.extend(ch.encode_utf8(&mut bytes).as_bytes());
                                }
                            }
                        }
                    }

                    if event.wRepeatCount > 1 {
                        let seq = buf[start..].to_owned();

                        for _ in 1..event.wRepeatCount {
                            buf.extend(&seq);
                        }
                    }
                }
            }

            fn has_alt(state: DWORD) -> bool 
            {
                state & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED) != 0
            }

            fn has_ctrl(state: DWORD) -> bool 
            {
                state & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) != 0
            }

            fn has_shift(state: DWORD) -> bool 
            {
                state & SHIFT_PRESSED != 0
            }

            pub struct Terminal 
            {
                in_handle: HANDLE,
                default_attrs: WORD,
                old_out_mode: DWORD,
                reader: Mutex<Reader>,
                writer: Mutex<Writer>,
            }

            pub struct TerminalReadGuard<'a> 
            {
                term: &'a Terminal,
                reader: MutexGuard<'a, Reader>,
            }

            pub struct TerminalWriteGuard<'a> 
            {
                term: &'a Terminal,
                writer: MutexGuard<'a, Writer>,
            }

            unsafe impl Send for Terminal {}
            unsafe impl Sync for Terminal {}

            struct Reader 
            {
                always_track_motion: bool,
                prev_buttons: DWORD,
            }

            struct Writer 
            {
                out_handle: HANDLE,
                fg: Option<Color>,
                bg: Option<Color>,
                style: Style,
            }

            pub struct PrepareState 
            {
                old_in_mode: DWORD,
                clear_handler: bool,
            }

            impl Terminal 
            {
                fn new(out: DWORD) -> io::Result<Terminal>
                {
                    let in_handle = result_handle(
                        unsafe { GetStdHandle(STD_INPUT_HANDLE) })?;
                    let out_handle = result_handle(
                        unsafe { GetStdHandle(out) })?;

                    let default_attrs = unsafe { console_info(out_handle)?.wAttributes };

                    let old_out_mode = unsafe { prepare_output(out_handle)? };

                    Ok(Terminal{
                        in_handle,
                        default_attrs,
                        old_out_mode,
                        reader: Mutex::new(Reader{
                            always_track_motion: false,
                            prev_buttons: 0,
                        }),
                        writer: Mutex::new(Writer{
                            out_handle,
                            fg: None,
                            bg: None,
                            style: Style::empty(),
                        }),
                    })
                }

                pub fn stdout() -> io::Result<Terminal> {
                    Terminal::new(STD_OUTPUT_HANDLE)
                }

                pub fn stderr() -> io::Result<Terminal> {
                    Terminal::new(STD_ERROR_HANDLE)
                }

                pub fn name(&self) -> &str {
                    "windows-console"
                }

                pub fn size(&self) -> io::Result<Size> { self.lock_writer().size() }

                pub fn clear_screen(&self) -> io::Result<()> { self.lock_writer().clear_screen() }

                pub fn clear_to_line_end(&self) -> io::Result<()> { self.lock_writer().clear_to_line_end() }

                pub fn clear_to_screen_end(&self) -> io::Result<()> { self.lock_writer().clear_to_screen_end() }

                pub fn move_to_first_column(&self) -> io::Result<()> { self.lock_writer().move_to_first_column() }

                pub fn move_up(&self, n: usize) -> io::Result<()> 
                {
                    if n != 0 { self.lock_writer().move_up(n)?; }
                    Ok(())
                }

                pub fn move_down(&self, n: usize) -> io::Result<()> 
                {
                    if n != 0 { self.lock_writer().move_down(n)?; }
                    Ok(())
                }

                pub fn move_left(&self, n: usize) -> io::Result<()> 
                {
                    if n != 0 { self.lock_writer().move_left(n)?; }
                    Ok(())
                }

                pub fn move_right(&self, n: usize) -> io::Result<()> 
                {
                    if n != 0 { self.lock_writer().move_right(n)?; }
                    Ok(())
                }

                pub fn enter_screen(&self) -> io::Result<HANDLE> { self.lock_writer().enter_screen() }
                
                pub unsafe fn exit_screen(&self, old_handle: HANDLE) -> io::Result<()> 
                { self.lock_writer().exit_screen(old_handle) }

                pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> 
                { self.lock_reader().prepare(config) }

                pub fn restore(&self, state: PrepareState) -> io::Result<()> { self.lock_reader().restore(state) }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
                { self.lock_reader().wait_event(timeout) }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
                { self.lock_reader().read_event(timeout) }

                pub fn read_raw(&self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
                { self.lock_reader().read_raw(buf, timeout) }

                pub fn read_raw_event(&self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> 
                io::Result<Option<Event>> 
                { self.lock_reader().read_raw_event(events, timeout) }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> 
                { self.lock_writer().set_cursor_mode(mode) }

                pub fn clear_attributes(&self) -> io::Result<()> { self.lock_writer().clear_attributes() }

                pub fn add_style(&self, style: Style) -> io::Result<()> { self.lock_writer().add_style(style) }

                pub fn remove_style(&self, style: Style) -> io::Result<()> { self.lock_writer().remove_style(style) }

                pub fn set_style(&self, style: Style) -> io::Result<()> { self.lock_writer().set_style(style) }

                pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> { self.lock_writer().set_fg(fg) }

                pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> { self.lock_writer().set_bg(bg) }

                pub fn set_theme(&self, theme: Theme) -> io::Result<()> { self.lock_writer().set_theme(theme) }

                pub fn write_char(&self, ch: char) -> io::Result<()> 
                { self.lock_writer().write_str(ch.encode_utf8(&mut [0; 4])) }

                pub fn write_str(&self, s: &str) -> io::Result<()> { self.lock_writer().write_str(s) }

                pub fn write_styled(&self, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str) ->
                io::Result<()>
                { self.lock_writer().write_styled(fg, bg, style, text) }

                pub fn lock_read(&self) -> LockResult<TerminalReadGuard>
                {
                    map_lock_result(self.reader.lock(), |r| TerminalReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<TerminalWriteGuard>
                {
                    map_lock_result(self.writer.lock(), |w| TerminalWriteGuard::new(self, w))
                }

                pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard>
                {
                    map_try_lock_result(self.reader.try_lock(), |r| TerminalReadGuard::new(self, r))
                }

                pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard>
                {
                    map_try_lock_result(self.writer.try_lock(), |w| TerminalWriteGuard::new(self, w))
                }

                fn lock_reader(&self) -> TerminalReadGuard { self.lock_read().expect("Terminal::lock_reader") }

                fn lock_writer(&self) -> TerminalWriteGuard { self.lock_write().expect("Terminal::lock_writer") }
            }

            impl Drop for Terminal 
            {
                fn drop(&mut self) {
                    let r = self.set_cursor_mode(CursorMode::Normal);
                    let r2 = r.and_then(|_| 
                    {
                        let lock = self.lock_writer();
                        unsafe { set_console_mode(lock.writer.out_handle, self.old_out_mode)?; }
                        Ok(())
                    });

                    if let Err(e) = r2 {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            impl<'a> TerminalReadGuard<'a> 
            {
                fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> {
                    TerminalReadGuard{term, reader}
                }

                pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState>
                {
                    let mut writer = self.term.lock_writer();
                    self.prepare_with_lock(&mut writer, config)
                }

                pub fn prepare_with_lock(&mut self, _writer: &mut TerminalWriteGuard,
                        config: PrepareConfig) -> io::Result<PrepareState>
                {
                    let old_in_mode = unsafe { console_mode(self.term.in_handle)? };

                    let mut state = PrepareState{
                        old_in_mode,
                        clear_handler: false,
                    };

                    let mut in_mode = old_in_mode;
                    in_mode |= ENABLE_EXTENDED_FLAGS;
                    in_mode &= !ENABLE_ECHO_INPUT;
                    in_mode &= !ENABLE_LINE_INPUT;
                    if config.block_signals {
                        in_mode &= !ENABLE_PROCESSED_INPUT;
                    } else {
                        in_mode |= ENABLE_PROCESSED_INPUT;
                    }
                    
                    if config.enable_mouse {
                        self.reader.always_track_motion = config.always_track_motion;
                        in_mode |= ENABLE_MOUSE_INPUT;
                    } else {
                        in_mode &= !ENABLE_MOUSE_INPUT;
                    }
                    
                    in_mode &= !ENABLE_QUICK_EDIT_MODE;
                    in_mode |= ENABLE_WINDOW_INPUT;
                    in_mode &= !ENABLE_VIRTUAL_TERMINAL_INPUT;

                    unsafe {
                        set_console_mode(self.term.in_handle, in_mode)?;

                        if config.report_signals.intersects(Signal::Break | Signal::Interrupt) {
                            catch_signals(config.report_signals);
                            result_bool(SetConsoleCtrlHandler(Some(ctrl_handler), TRUE))?;
                            state.clear_handler = true;
                        }
                    }

                    Ok(state)
                }

                pub fn restore(&mut self, state: PrepareState) -> io::Result<()>
                {
                    let mut writer = self.term.lock_writer();
                    self.restore_with_lock(&mut writer, state)
                }

                pub fn restore_with_lock(&mut self, _writer: &mut TerminalWriteGuard,
                        state: PrepareState) -> io::Result<()> {
                    unsafe {
                        if state.clear_handler {
                            result_bool(SetConsoleCtrlHandler(Some(ctrl_handler), FALSE))?;
                        }

                        set_console_mode(self.term.in_handle,
                            state.old_in_mode | ENABLE_EXTENDED_FLAGS)?;
                    }

                    Ok(())
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    if get_signal().is_some() {
                        return Ok(true);
                    }

                    let res = unsafe { WaitForSingleObject(
                        self.term.in_handle, as_millis(timeout)) };

                    match res {
                        WAIT_OBJECT_0 => Ok(true),
                        WAIT_TIMEOUT => Ok(false),
                        WAIT_FAILED | _ => Err(io::Error::last_os_error())
                    }
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let mut event: [INPUT_RECORD; 1] = unsafe { zeroed() };

                    let n = match self.read_raw_event(&mut event, timeout)? {
                        Some(Event::Raw(n)) => n,
                        r => return Ok(r)
                    };

                    if n == 0 {
                        Ok(None)
                    } else {
                        let event = event[0];

                        if let Some(key) = key_press_event(&event) {
                            Ok(Some(Event::Key(key)))
                        } else if let Some(mouse) = self.mouse_event(&event) {
                            Ok(Some(Event::Mouse(mouse)))
                        } else if let Some(size) = size_event(&event) {
                            Ok(Some(Event::Resize(size)))
                        } else {
                            Ok(Some(Event::NoEvent))
                        }
                    }
                }

                pub fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>)
                        -> io::Result<Option<Event>> {
                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }

                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    unsafe {
                        let len = to_dword(buf.len());
                        let mut n_read = 0;

                        result_bool(ReadConsoleW(
                            self.term.in_handle,
                            buf.as_ptr() as *mut VOID,
                            len,
                            &mut n_read,
                            ptr::null_mut()))?;

                        if n_read == 0 {
                            Ok(None)
                        } else {
                            Ok(Some(Event::Raw(n_read as usize)))
                        }
                    }
                }

                pub fn read_raw_event(&mut self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }

                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    let len = to_dword(events.len());
                    let mut n = 0;

                    result_bool(unsafe { ReadConsoleInputW(
                        self.term.in_handle,
                        events.as_mut_ptr(),
                        len,
                        &mut n) })?;

                    Ok(Some(Event::Raw(n as usize)))
                }

                fn mouse_event(&mut self, event: &INPUT_RECORD) -> Option<MouseEvent> 
                {
                    if event.EventType == MOUSE_EVENT 
                    {
                        let mouse = unsafe { event.Event.MouseEvent() };

                        let input = if mouse.dwEventFlags & MOUSE_WHEELED != 0
                        {
                            let direction = (mouse.dwButtonState >> 16) as i16;

                            if direction > 0 {
                                MouseInput::WheelUp
                            } else {
                                MouseInput::WheelDown
                            }
                        } else {
                            let prev_buttons = self.reader.prev_buttons;
                            let now_buttons = mouse.dwButtonState;

                            self.reader.prev_buttons = mouse.dwButtonState;

                            if prev_buttons == now_buttons {
                                if now_buttons == 0 && !self.reader.always_track_motion {
                                    return None;
                                }

                                MouseInput::Motion
                            } else {
                                button_changed(prev_buttons, now_buttons)?
                            }
                        };

                        let position = coord_to_cursor(mouse.dwMousePosition);

                        let mut mods = ModifierState::empty();

                        if has_alt(mouse.dwControlKeyState) {
                            mods |= ModifierState::ALT;
                        }
                        if has_ctrl(mouse.dwControlKeyState) {
                            mods |= ModifierState::CTRL;
                        }
                        if has_shift(mouse.dwControlKeyState) {
                            mods |= ModifierState::SHIFT;
                        }

                        Some(MouseEvent{
                            position,
                            input,
                            modifiers: mods,
                        })
                    } else {
                        None
                    }
                }
            }

            impl<'a> TerminalWriteGuard<'a> 
            {
                fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                    TerminalWriteGuard{term, writer: writer}
                }

                fn enter_screen(&mut self) -> io::Result<HANDLE>
                {
                    let size = self.size()?;

                    let handle = result_handle(unsafe { CreateConsoleScreenBuffer(
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        ptr::null(),
                        CONSOLE_TEXTMODE_BUFFER,
                        ptr::null_mut()) })?;

                    if let Err(e) = unsafe { setup_screen(handle, size) } {
                        let _ = unsafe { close_handle(handle) };
                        return Err(e);
                    }

                    let old_handle = self.swap_out_handle(handle);

                    let mut out_mode = unsafe { console_mode(handle)? };
                    
                    out_mode &= !(ENABLE_WRAP_AT_EOL_OUTPUT | DISABLE_NEWLINE_AUTO_RETURN);

                    unsafe { set_console_mode(handle, out_mode)?; }

                    Ok(old_handle)
                }

                unsafe fn exit_screen(&mut self, old_handle: HANDLE) -> io::Result<()> {
                    result_bool(SetConsoleActiveScreenBuffer(old_handle))?;

                    let handle = self.swap_out_handle(old_handle);

                    close_handle(handle)
                }

                pub fn size(&self) -> io::Result<Size> {
                    unsafe { console_size(self.writer.out_handle) }
                }

                pub fn flush(&mut self) -> io::Result<()> {
                    Ok(())
                }

                pub fn clear_screen(&mut self) -> io::Result<()>
                {
                    let mut info = self.get_info()?;

                    let win_height = (info.srWindow.Bottom - info.srWindow.Top) + 1;

                    if win_height == info.dwSize.Y {
                        self.clear_area(
                            COORD{X: 0, Y: 0},
                            info.dwSize.X as DWORD * info.dwSize.Y as DWORD)?;
                    } else {
                        let max = info.dwSize.Y - (info.srWindow.Bottom + 1);
                        let dist = (info.dwCursorPosition.Y + 1) - info.srWindow.Top;

                        let down = dist.min(max);
                        
                        if down > 0 {
                            info.srWindow.Top += down as SHORT;
                            info.srWindow.Bottom += down as SHORT;

                            result_bool(unsafe { SetConsoleWindowInfo(
                                self.writer.out_handle,
                                TRUE,
                                &info.srWindow) })?;
                        }

                        let clear = info.srWindow.Bottom - info.dwCursorPosition.Y;
                        
                        if clear < win_height {
                            let dist = (win_height - clear) as SHORT;

                            let src = SMALL_RECT{
                                Top: dist,
                                Bottom: info.dwCursorPosition.Y,
                                Left: 0,
                                Right: info.dwSize.X,
                            };

                            let dest = COORD{
                                X: 0,
                                Y: 0,
                            };

                            let fill = CHAR_INFO{
                                Char: unicode_char(b' ' as WCHAR),
                                Attributes: 0,
                            };

                            result_bool(unsafe { ScrollConsoleScreenBufferW(
                                self.writer.out_handle,
                                &src,
                                ptr::null(),
                                dest,
                                &fill) })?;
                        }
                    }
                    
                    self.move_abs(COORD{
                        X: info.srWindow.Left,
                        Y: info.srWindow.Top,
                    })
                }

                pub fn clear_to_line_end(&mut self) -> io::Result<()>
                {
                    let info = self.get_info()?;

                    let start = info.dwCursorPosition;
                    let size = info.dwSize;

                    self.clear_area(start, (size.X - start.X) as DWORD)
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()>
                {
                    let info = self.get_info()?;

                    let start = info.dwCursorPosition;
                    let size = info.dwSize;

                    let lines = (size.Y - start.Y) as DWORD;
                    let columns = (size.X - start.X) as DWORD;

                    let n = lines * size.X as DWORD + columns;

                    self.clear_area(start, n)
                }

                pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    self.move_abs(cursor_to_coord(pos))
                }

                pub fn move_to_first_column(&mut self) -> io::Result<()>
                {
                    let info = self.get_info()?;
                    self.move_abs(COORD{X: 0, Y: info.dwCursorPosition.Y})
                }

                pub fn move_up(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: 0, Y: to_short_neg(n)})
                }

                pub fn move_down(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: 0, Y: to_short(n)})
                }

                pub fn move_left(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: to_short_neg(n), Y: 0})
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: to_short(n), Y: 0})
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                {
                    let (size, vis) = match mode {
                        CursorMode::Normal => (25, TRUE),
                        CursorMode::Invisible => (1, FALSE),
                        CursorMode::Overwrite => (100, TRUE),
                    };

                    let info = CONSOLE_CURSOR_INFO {
                        dwSize: size,
                        bVisible: vis,
                    };

                    result_bool(unsafe { SetConsoleCursorInfo(self.writer.out_handle, &info) })
                }

                pub fn clear_attributes(&mut self) -> io::Result<()> {
                    self.set_attributes(None, None, Style::empty())
                }

                pub fn add_style(&mut self, style: Style) -> io::Result<()>
                {
                    let add = style - self.writer.style;

                    if !add.is_empty() {
                        self.writer.style |= add;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                pub fn remove_style(&mut self, style: Style) -> io::Result<()>
                {
                    let remove = style & self.writer.style;

                    if !remove.is_empty() {
                        self.writer.style -= remove;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                pub fn set_style(&mut self, style: Style) -> io::Result<()> {
                    if self.writer.style != style {
                        self.writer.style = style;
                        self.update_attrs()?;
                    }
                    Ok(())
                }

                pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                    if self.writer.fg != fg {
                        self.writer.fg = fg;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                    if self.writer.bg != bg {
                        self.writer.bg = bg;
                        self.update_attrs()?;
                    }
                    Ok(())
                }

                pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> { self.set_attributes(theme.fg, theme.bg, theme.style) }
                /// Clears any previous attributes
                pub fn set_attributes(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()>
                {
                    if self.writer.fg != fg || self.writer.bg != bg || self.writer.style != style
                    {
                        self.writer.fg = fg;
                        self.writer.bg = bg;
                        self.writer.style = style;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                fn update_attrs(&mut self) -> io::Result<()>
                {
                    let mut attrs = self.term.default_attrs;

                    if let Some(fg) = self.writer.fg {
                        attrs &= !fg_code(Color::White);
                        attrs |= fg_code(fg);
                    }

                    if let Some(bg) = self.writer.bg {
                        attrs &= !bg_code(Color::White);
                        attrs |= bg_code(bg);
                    }

                    attrs |= style_code(self.writer.style);

                    if self.writer.style.contains(Style::REVERSE) {
                        attrs = swap_colors(attrs);
                    }

                    self.set_attrs(attrs)
                }

                pub fn write_char(&mut self, ch: char) -> io::Result<()>
                {
                    let mut buf = [0; 4];
                    self.write_str(ch.encode_utf8(&mut buf))
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()>
                {
                    let buf = OsStr::new(s).encodes_wide().collect::<Vec<_>>();
                    let mut n = 0;

                    while buf.len() > n
                    {
                        let mut n_dw = 0;
                        let len = to_dword(buf.len() - n);

                        result_bool(unsafe { WriteConsoleW
                        (
                            self.writer.out_handle,
                            buf[n..].as_ptr() as *const VOID,
                            len,
                            &mut n_dw,
                            ptr::null_mut()
                        ) })?;

                        n += n_dw as usize;
                    }

                    Ok(())
                }

                pub fn write_styled(&mut self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.set_attributes(fg, bg, style)?;
                    self.write_str(text)?;
                    self.clear_attributes()
                }

                fn clear_area(&mut self, start: COORD, n: DWORD) -> io::Result<()>
                {
                    let mut n_chars = 0;

                    result_bool(unsafe { FillConsoleOutputAttribute(
                        self.writer.out_handle,
                        self.term.default_attrs,
                        n,
                        start,
                        &mut n_chars) })?;

                    result_bool(unsafe { FillConsoleOutputCharacterA(
                        self.writer.out_handle,
                        b' ' as CHAR,
                        n,
                        start,
                        &mut n_chars) })?;

                    Ok(())
                }

                fn move_abs(&mut self, pos: COORD) -> io::Result<()> {
                    result_bool(unsafe { SetConsoleCursorPosition(
                        self.writer.out_handle, pos) })
                }

                fn move_rel(&mut self, off: COORD) -> io::Result<()>
                {
                    let info = self.get_info()?;

                    let size = info.dwSize;
                    let cursor = info.dwCursorPosition;

                    let dest = COORD{
                        X: cursor.X.saturating_add(off.X).min(size.X - 1),
                        Y: cursor.Y.saturating_add(off.Y).min(size.Y - 1),
                    };

                    self.move_abs(dest)
                }

                fn set_attrs(&mut self, attrs: WORD) -> io::Result<()> {
                    result_bool(unsafe { SetConsoleTextAttribute(
                        self.writer.out_handle, attrs) })
                }

                fn get_info(&self) -> io::Result<CONSOLE_SCREEN_BUFFER_INFO> {
                    unsafe { console_info(self.writer.out_handle) }
                }

                fn swap_out_handle(&mut self, handle: HANDLE) -> HANDLE {
                    replace(&mut self.writer.out_handle, handle)
                }
            }
            
            fn as_millis(timeout: Option<Duration>) -> DWORD 
            {
                match timeout
                {
                    Some(t) =>
                    {
                        let s = (t.whole_seconds() * 1_000) as DWORD;
                        let ms = (t.subsec_nanoseconds() / 1_000_000) as DWORD;
                        s + ms
                    }
                    None => INFINITE,
                }
            }

            fn fg_code(color: Color) -> WORD 
            {
                (match color {
                    Color::Black => 0,
                    Color::Blue => FOREGROUND_BLUE,
                    Color::Cyan => FOREGROUND_BLUE | FOREGROUND_GREEN,
                    Color::Green => FOREGROUND_GREEN,
                    Color::Magenta => FOREGROUND_BLUE | FOREGROUND_RED,
                    Color::Red => FOREGROUND_RED,
                    Color::White => FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
                    Color::Yellow => FOREGROUND_RED | FOREGROUND_GREEN,
                }) as WORD
            }

            fn bg_code(color: Color) -> WORD 
            {
                (match color 
                {
                    Color::Black => 0,
                    Color::Blue => BACKGROUND_BLUE,
                    Color::Cyan => BACKGROUND_BLUE | BACKGROUND_GREEN,
                    Color::Green => BACKGROUND_GREEN,
                    Color::Magenta => BACKGROUND_BLUE | BACKGROUND_RED,
                    Color::Red => BACKGROUND_RED,
                    Color::White => BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE,
                    Color::Yellow => BACKGROUND_RED | BACKGROUND_GREEN,
                }) as WORD
            }

            fn style_code(style: Style) -> WORD 
            {
                let mut code = 0;

                if style.contains(Style::BOLD) {
                    code |= FOREGROUND_INTENSITY as WORD;
                }

                code
            }

            fn swap_colors(code: WORD) -> WORD 
            {
                let fg_mask = fg_code(Color::White);
                let bg_mask = bg_code(Color::White);

                let fg_shift = fg_mask.trailing_zeros();
                let bg_shift = bg_mask.trailing_zeros();
                let shift = bg_shift - fg_shift;

                let fg = code & fg_mask;
                let bg = code & bg_mask;

                let swapped_fg = fg << shift;
                let swapped_bg = bg >> shift;

                (code & !(fg_mask | bg_mask)) | swapped_fg | swapped_bg
            }

            unsafe fn close_handle(handle: HANDLE) -> io::Result<()> 
            {
                result_bool(CloseHandle(handle))
            }

            unsafe fn console_info(handle: HANDLE) -> io::Result<CONSOLE_SCREEN_BUFFER_INFO> 
            {
                let mut info = zeroed();

                result_bool(GetConsoleScreenBufferInfo(handle, &mut info))?;

                Ok(info)
            }

            unsafe fn console_mode(handle: HANDLE) -> io::Result<DWORD> 
            {
                let mut mode = 0;

                result_bool(GetConsoleMode(handle, &mut mode))?;

                Ok(mode)
            }

            unsafe fn console_size(handle: HANDLE) -> io::Result<Size> 
            {
                let info = console_info(handle)?;

                Ok(coord_to_size(info.dwSize))
            }

            unsafe fn set_console_mode(handle: HANDLE, mode: DWORD) -> io::Result<()> 
            {
                result_bool(SetConsoleMode(handle, mode))
            }
            
            unsafe fn setup_screen(handle: HANDLE, size: Size) -> io::Result<()> 
            {
                result_bool(SetConsoleScreenBufferSize(handle, size_to_coord(size)))?;
                result_bool(SetConsoleActiveScreenBuffer(handle))
            }

            unsafe fn prepare_output(handle: HANDLE) -> io::Result<DWORD> 
            {
                let old_out_mode = console_mode(handle)?;

                let mut out_mode = old_out_mode;
                out_mode |= ENABLE_PROCESSED_OUTPUT;
                out_mode |= ENABLE_WRAP_AT_EOL_OUTPUT;

                set_console_mode(handle, out_mode)?;

                Ok(old_out_mode)
            }

            fn button_changed(prev_buttons: DWORD, now_buttons: DWORD) -> Option<MouseInput> 
            {
                use std::mem::size_of;

                let n_bits = size_of::<DWORD>() * 8;

                for i in 0..n_bits {
                    let bit = 1 << i;

                    let changed = (prev_buttons ^ now_buttons) & bit != 0;

                    if changed {
                        let button = bit_to_button(bit);

                        let input = if prev_buttons & bit == 0 {
                            MouseInput::ButtonPressed(button)
                        } else {
                            MouseInput::ButtonReleased(button)
                        };

                        return Some(input);
                    }
                }

                None
            }

            fn bit_to_button(mut bit: DWORD) -> MouseButton 
            {
                assert!(bit != 0);

                match bit {
                    FROM_LEFT_1ST_BUTTON_PRESSED => MouseButton::Left,
                    RIGHTMOST_BUTTON_PRESSED => MouseButton::Right,
                    FROM_LEFT_2ND_BUTTON_PRESSED => MouseButton::Middle,
                    _ => {
                        bit >>= 3;
                        let mut n = 3;

                        while bit != 1 {
                            bit >>= 1;
                            n += 1;
                        }

                        MouseButton::Other(n)
                    }
                }
            }

            fn coord_to_cursor(pos: COORD) -> Cursor 
            {
                Cursor{
                    line: pos.Y as usize,
                    column: pos.X as usize,
                }
            }

            fn coord_to_size(size: COORD) -> Size 
            {
                Size{
                    lines: size.Y as usize,
                    columns: size.X as usize,
                }
            }

            fn cursor_to_coord(pos: Cursor) -> COORD 
            {
                COORD{
                    Y: to_short(pos.line),
                    X: to_short(pos.column),
                }
            }

            fn size_to_coord(size: Size) -> COORD 
            {
                COORD{
                    Y: to_short(size.lines),
                    X: to_short(size.columns),
                }
            } 

            fn to_dword(n: usize) -> DWORD 
            {
                if n > DWORD::max_value() as usize {
                    DWORD::max_value()
                } else {
                    n as DWORD
                }
            }

            fn to_short(n: usize) -> SHORT 
            {
                if n > SHORT::max_value() as usize {
                    SHORT::max_value()
                } else {
                    n as SHORT
                }
            }

            fn to_short_neg(n: usize) -> SHORT 
            {
                let n = if n > isize::max_value() as usize {
                    isize::min_value()
                } else {
                    -(n as isize)
                };

                if n < SHORT::min_value() as isize {
                    SHORT::min_value()
                } else {
                    n as SHORT
                }
            }

            fn key_press_event(event: &INPUT_RECORD) -> Option<Key> 
            {
                if event.EventType == KEY_EVENT {
                    let key = unsafe { event.Event.KeyEvent() };

                    if key.bKeyDown == FALSE {
                        return None;
                    }

                    let key = match key.wVirtualKeyCode as c_int {
                        VK_BACK => Key::Backspace,
                        VK_RETURN => Key::Enter,
                        VK_ESCAPE => Key::Escape,
                        VK_TAB => Key::Tab,
                        VK_UP => Key::Up,
                        VK_DOWN => Key::Down,
                        VK_LEFT => Key::Left,
                        VK_RIGHT => Key::Right,
                        VK_DELETE => Key::Delete,
                        VK_INSERT => Key::Insert,
                        VK_HOME => Key::Home,
                        VK_END => Key::End,
                        VK_PRIOR => Key::PageUp,
                        VK_NEXT => Key::PageDown,
                        VK_F1 => Key::F(1),
                        VK_F2 => Key::F(2),
                        VK_F3 => Key::F(3),
                        VK_F4 => Key::F(4),
                        VK_F5 => Key::F(5),
                        VK_F6 => Key::F(6),
                        VK_F7 => Key::F(7),
                        VK_F8 => Key::F(8),
                        VK_F9 => Key::F(9),
                        VK_F10 => Key::F(10),
                        VK_F11 => Key::F(11),
                        VK_F12 => Key::F(12),
                        _ => {
                            if has_alt(key.dwControlKeyState) {
                                return None;
                            }

                            let is_ctrl = has_ctrl(key.dwControlKeyState);

                            let u_char = unsafe { *key.uChar.UnicodeChar() };

                            if u_char != 0 {
                                match char::from_u32(u_char as u32) {
                                    Some(ch) if is_ctrl => Key::Ctrl(unctrl_lower(ch)),
                                    Some(ch) => ch.into(),
                                    None => return None
                                }
                            } else {
                                return None;
                            }
                        }
                    };

                    Some(key)
                } else {
                    None
                }
            }

            pub fn size_event(event: &INPUT_RECORD) -> Option<Size> 
            {
                if event.EventType == WINDOW_BUFFER_SIZE_EVENT {
                    let size = unsafe { event.Event.WindowBufferSizeEvent() };

                    Some(Size{
                        lines: size.dwSize.Y as usize,
                        columns: size.dwSize.X as usize,
                    })
                } else {
                    None
                }
            }

            fn unicode_char(wch: WCHAR) -> CHAR_INFO_Char 
            {
                let mut ch: CHAR_INFO_Char = unsafe { zeroed() };

                unsafe { *ch.UnicodeChar_mut() = wch; }

                ch
            }

            fn result_bool(b: BOOL) -> io::Result<()> 
            {
                if b == FALSE {
                    Err(io::Error::last_os_error())
                } else {
                    Ok(())
                }
            }

            fn result_handle(ptr: HANDLE) -> io::Result<HANDLE> {
                if ptr.is_null() {
                    Err(io::Error::last_os_error())
                } else {
                    Ok(ptr)
                }
            }

            static CATCH_SIGNALS: AtomicUsize = AtomicUsize::new(0);
            
            static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(!0);

            fn catch_signals(set: SignalSet) 
            {
                let mut sigs = 0;

                if set.contains(Signal::Break) {
                    sigs |= (1 << CTRL_BREAK_EVENT) as usize;
                }
                if set.contains(Signal::Interrupt) {
                    sigs |= (1 << CTRL_C_EVENT) as usize;
                }

                CATCH_SIGNALS.store(sigs, Ordering::Relaxed);
            }

            unsafe extern "system" fn ctrl_handler(ctrl_type: DWORD) -> BOOL 
            {
                match ctrl_type {
                    CTRL_BREAK_EVENT | CTRL_C_EVENT => {
                        let catch = CATCH_SIGNALS.load(Ordering::Relaxed);

                        if catch & (1 << ctrl_type) as usize == 0 {
                            return FALSE;
                        }

                        LAST_SIGNAL.store(ctrl_type as usize, Ordering::Relaxed);

                        if let Ok(handle) = result_handle(
                                GetStdHandle(STD_INPUT_HANDLE)) {
                                    
                            let input = INPUT_RECORD{
                                EventType: KEY_EVENT,
                                Event: zeroed(),
                            };

                            let mut n = 0;
                            let _ = WriteConsoleInputW(
                                handle,
                                &input,
                                1,
                                &mut n);
                        }

                        TRUE
                    }
                    _ => FALSE
                }
            }

            fn conv_signal(sig: DWORD) -> Option<Signal> 
            {
                match sig {
                    CTRL_BREAK_EVENT => Some(Signal::Break),
                    CTRL_C_EVENT => Some(Signal::Interrupt),
                    _ => None
                }
            }

            fn get_signal() -> Option<Signal> 
            {
                conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as DWORD)
            }

            fn take_signal() -> Option<Signal> 
            {
                conv_signal(LAST_SIGNAL.swap(!0, Ordering::Relaxed) as DWORD)
            }
        } pub use self::terminal::{ * };
        
        impl TerminalExt for system::Terminal
        {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_raw(buf, timeout) }

            fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> 
            io::Result<Option<Event>> 
            { self.0.read_raw_event(events, timeout) }
        }
        
        impl<'a> TerminalExt for system::TerminalReadGuard<'a> 
        {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }

            fn read_raw_event(&mut self, events: &mut [INPUT_RECORD], timeout: Option<Duration>) -> 
            io::Result<Option<Event>> 
            { self.0.read_raw_event(events, timeout) }
        }

    } #[cfg( windows )] pub use self::windows as sys;

    pub fn filter_visible(s: &str) -> Cow<str>
    {
        //use linefeed::reader::{START_INVISIBLE, END_INVISIBLE};
        if !s.contains(START_INVISIBLE) { return Cow::Borrowed(s); }

        let mut virt = String::new();
        let mut ignore = false;

        for ch in s.chars()
        {
            if ch == START_INVISIBLE { ignore = true; }
            else if ch == END_INVISIBLE { ignore = false; }
            else if !ignore { virt.push(ch); }
        }

        Cow::Owned(virt)
    }
    /// Returns the longest common prefix of a set of strings.
    pub fn longest_common_prefix<'a, I, S>(iter: I) -> Option<&'a str> where
    I: IntoIterator<Item=&'a S>,
    S: 'a + ?Sized + AsRef<str>,
    {
        let mut iter = iter.into_iter();

        let mut pfx = iter.next()?.as_ref();

        for s in iter {
            let s = s.as_ref();

            let n = pfx.chars().zip(s.chars())
                .take_while(|&(a, b)| a == b)
                .map(|(ch, _)| ch.len_utf8()).sum();

            if n == 0 {
                return None;
            } else {
                pfx = &pfx[..n];
            }
        }

        Some(pfx)
    }
    /// Returns a string consisting of a `char`, repeated `n` times.
    pub fn repeat_char(ch: char, n: usize) -> String
    {
        let mut buf = [0; 4];
        let s = ch.encode_utf8(&mut buf);

        s.repeat(n)
    }
    /// Implemented for built-in range types
    pub trait RangeArgument<T> 
    {
        /// Returns the start of range, if present.
        fn start(&self) -> Option<&T> { None }
        /// Returns the end of range, if present.
        fn end(&self) -> Option<&T> { None }
    }

    impl<T> RangeArgument<T> for Range<T> 
    {
        fn start(&self) -> Option<&T> { Some(&self.start) }
        fn end(&self) -> Option<&T> { Some(&self.end) }
    }

    impl<T> RangeArgument<T> for RangeFrom<T> 
    {
        fn start(&self) -> Option<&T> { Some(&self.start) }
    }

    impl<T> RangeArgument<T> for RangeTo<T> 
    {
        fn end(&self) -> Option<&T> { Some(&self.end) }
    }

    impl<T> RangeArgument<T> for RangeFull {}

    pub fn backward_char(n: usize, s: &str, cur: usize) -> usize
    {
        let mut chars = s[..cur].char_indices().filter(|&(_, ch)| !is::combining_mark(ch));
        let mut res = cur;

        for _ in 0..n
        {
            match chars.next_back()
            {
                Some((idx, _)) => res = idx,
                None => return 0
            }
        }

        res
    }

    pub fn forward_char(n: usize, s: &str, cur: usize) -> usize
    {
        let mut chars = s[cur..].char_indices().filter(|&(_, ch)| !is::combining_mark(ch));

        for _ in 0..n
        {
            match chars.next()
            {
                Some(_) => (),
                None => return s.len()
            }
        }

        match chars.next()
        {
            Some((idx, _)) => cur + idx,
            None => s.len()
        }
    }

    pub fn backward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n
        {
            match buf[..cur].rfind(ch)
            {
                Some(p) =>
                {
                    cur = p;
                    pos = Some(cur);
                }

                None => break
            }
        }

        pos
    }

    pub fn forward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n
        {
            let off = match buf[cur..].chars().next()
            {
                Some(ch) => ch.len_utf8(),
                None => break
            };

            match buf[cur + off..].find(ch)
            {
                Some(p) =>
                {
                    cur += off + p;
                    pos = Some(cur);
                }
                None => break
            }
        }

        pos
    }

    pub fn backward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[..cur].char_indices().rev();

        for _ in 0..n
        {
            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some((ind, ch)) => ind + ch.len_utf8(),
            None => 0
        }
    }

    pub fn forward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n
        {
            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some((ind, _)) => cur + ind,
            None => buf.len()
        }
    }

    pub fn back_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
    {
        let prev = backward_word(1, buf, cur, word_break);
        let end = word_end(&buf, prev, word_break);

        if n > 1
        {
            let start = backward_word(n - 1, buf, prev, word_break);
            start..end
        }
        else { prev..end }
    }

    pub fn forward_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
    {
        let start = next_word(1, buf, cur, word_break);

        if n > 1
        {
            let last = next_word(n - 1, buf, start, word_break);
            let end = word_end(buf, last, word_break);
            start..end
        }
        else
        {
            let end = word_end(buf, start, word_break);
            start..end
        }
    }
    /// Returns the first character in the buffer, if it contains any valid characters.
    pub fn first_char(buf: &[u8]) -> io::Result<Option<char>>
    {
        match from_utf8(buf)
        {
            Ok(s) => Ok(s.chars().next()),
            Err(e) =>
            {
                if e.error_len().is_some()
                {
                    return Err(io::Error::new(io::ErrorKind::InvalidData, "invalid utf-8 input received"));
                }

                let valid = e.valid_up_to();
                let s = unsafe { from_utf8_unchecked(&buf[..valid]) };
                Ok(s.chars().next())
            }
        }
    }

    pub fn first_word(buf: &str, word_break: &str) -> Option<usize>
    {
        let mut chars = buf.char_indices();
        drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
        chars.next().map(|(idx, _)| idx)
    }

    pub fn word_start(buf: &str, cur: usize, word_break: &str) -> usize
    {
        let fwd = match buf[cur..].chars().next()
        {
            Some(ch) => word_break.contains(ch),
            None => return buf.len()
        };

        if fwd { next_word(1, buf, cur, word_break) }
        else
        {
            let mut chars = buf[..cur].char_indices().rev();

            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

            match chars.next()
            {
                Some((idx, ch)) => idx + ch.len_utf8(),
                None => 0
            }
        }
    }

    pub fn next_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n
        {
            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        
            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some((idx, _)) => cur + idx,
            None => buf.len()
        }
    }

    pub fn word_end(buf: &str, cur: usize, word_break: &str) -> usize
    {
        let mut chars = buf[cur..].char_indices();
        drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

        match chars.next()
        {
            Some((idx, _)) => cur + idx,
            None => buf.len()
        }
    }

    pub fn drop_while<I, T, F>(iter: &mut I, mut f: F) where 
    I: Iterator<Item=T> + Clone, F: FnMut(T) -> bool
    {
        loop
        {
            let mut clone = iter.clone();

            match clone.next()
            {
                None => break,
                Some(t) => if f(t) { *iter = clone; } else { break; },
            }
        }
    }

    pub fn get_open_paren(ch: char) -> Option<char>
    {
        match ch
        {
            ')' => Some('('),
            ']' => Some('['),
            '}' => Some('{'),
            _ => None
        }
    }

    pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize>
    {
        let mut chars = s.char_indices().rev();
        let mut level = 0;
        let mut string_delim = None;

        while let Some((ind, ch)) = chars.next()
        {
            if string_delim == Some(ch) { string_delim = None; }
            else if quotes.contains(ch) { string_delim = Some(ch); }
            else if string_delim.is_none() && ch == close { level += 1; }
            else if string_delim.is_none() && ch == open
            {
                level -= 1;
                if level == 0 { return Some(ind); }
            }
        }

        None
    }
}

pub mod time
{
    pub use ::timed::{ * };
    mod std
    {
        pub use std::time::{ * };
    }

    pub mod c
    {
        use ::
        {
            *,
        };

        use super::OffsetDateTime;

        #[derive(Debug, PartialEq, Eq)]
        pub struct DateTime
        {
            odt: OffsetDateTime,
        }

        impl DateTime
        {
            pub fn now() -> Self
            {
                let odt: OffsetDateTime = match OffsetDateTime::now_local()
                {
                    Ok(dt) => dt,
                    Err(_) => OffsetDateTime::now_utc(),
                };
                DateTime { odt }
            }

            pub fn from_timestamp(ts: f64) -> Self
            {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
                let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128)
                {
                    Ok(x) => x,
                    Err(_) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn unix_timestamp(&self) -> f64
            {
                self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
            }
        }

        impl fmt::Display for DateTime
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                write!
                (
                    f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
                )
            }
        }
    }
}

pub mod types
{
    use ::
    {
        collections::{ HashMap, HashSet },
        hash::{ Hash, Hasher },
        rc::{ Rc },
        regex::{ Regex, contains, unquote },
        *,
    };

    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct WaitStatus(i32, i32, i32);

    impl WaitStatus 
    {
        pub fn from_exited(pid: i32, status: i32) -> Self { WaitStatus(pid, 0, status) }

        pub fn from_signaled(pid: i32, sig: i32) -> Self { WaitStatus(pid, 1, sig) }

        pub fn from_stopped(pid: i32, sig: i32) -> Self { WaitStatus(pid, 2, sig) }

        pub fn from_continuted(pid: i32) -> Self { WaitStatus(pid, 3, 0) }

        pub fn from_others() -> Self { WaitStatus(0, 9, 9) }

        pub fn from_error(errno: i32) -> Self { WaitStatus(0, 255, errno) }

        pub fn empty() -> Self { WaitStatus(0, 0, 0) }

        pub fn is_error(&self) -> bool { self.1 == 255 }

        pub fn is_others(&self) -> bool { self.1 == 9 }

        pub fn is_signaled(&self) -> bool { self.1 == 1 }

        pub fn get_errno(&self) -> nix::Error { nix::Error::from_raw(self.2) }

        pub fn is_exited(&self) -> bool { self.0 != 0 && self.1 == 0 }

        pub fn is_stopped(&self) -> bool { self.1 == 2 }

        pub fn is_continued(&self) -> bool { self.1 == 3 }

        pub fn get_pid(&self) -> i32 { self.0 }

        fn _get_signaled_status(&self) -> i32 { self.2 + 128 }

        pub fn get_signal(&self) -> i32 { self.2 }

        pub fn get_name(&self) -> String
        {
            match true
            {
                true if self.is_exited() => "Exited".to_string(),
                true if self.is_stopped() => "Stopped".to_string(),
                true if self.is_continued() => "Continued".to_string(),
                true if self.is_signaled() => "Signaled".to_string(),
                true if self.is_others() => "Others".to_string(),
                true if self.is_error() => "Error".to_string(),
                _=> { format!("unknown: {}", self.2) }
            }
        }

        pub fn get_status(&self) -> i32
        {
            if self.is_exited() { self.2 }
            else { self._get_signaled_status() }
        }
    }

    impl fmt::Debug for WaitStatus 
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
        {
            let mut formatter = f.debug_struct("WaitStatus");
            formatter.field("pid", &self.0);
            let name = self.get_name();
            formatter.field("name", &name);
            formatter.field("ext", &self.2);
            formatter.finish()
        }
    }

    #[derive(Debug)]
    pub struct LineInfo
    {
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo
    {
        pub fn new(tokens: Tokens) -> Self { LineInfo { tokens, is_complete: true } }
    }
    /// command line: `ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
    /// Command {
    ///     tokens: [("", "ls"), ("", "-G"), ("\'", "foo bar")],
    ///     redirects_to: [
    ///         ("2", ">", "&1"),
    ///         ("1", ">", "/dev/null"),
    ///     ],
    ///     redirect_from: Some(("<", "one-file")),
    /// }
    #[derive(Debug)]
    pub struct Command
    {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    #[derive(Debug)]
    pub struct CommandLine
    {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl Command
    {
        pub fn from_tokens(tokens: Tokens) -> Result<Command, String>
        {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            let mut len = tokens_new.len();

            while has_redirect_from
            {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<")
                {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx
                    {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<")
                {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;

                    if len > idx
                    {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            }

            let tokens_final;
            let redirects_to;

            match tokens_to_redirections(&tokens_new) 
            {
                Ok((_tokens, _redirects_to)) =>
                {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }

                Err(e) => { return Err(e); }
            }

            let redirect_from = if redirects_from_type.is_empty() { None }
            else { Some((redirects_from_type, redirects_from_value)) };

            Ok(Command
            {
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from(&self) -> bool
        {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string(&self) -> bool
        {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin(&self) -> bool { is::builtin(&self.tokens[0].1) }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Job
    {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job
    {
        pub fn all_members_stopped(&self) -> bool
        {
            for pid in &self.pids
            {
                if !self.pids_stopped.contains(pid) { return false; }
            }
            true
        }

        pub fn all_members_running(&self) -> bool { self.pids_stopped.is_empty() }
    }
    
    #[derive(Clone, Debug, Default)]
    pub struct CommandResult
    {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult
    {
        pub const fn new() -> CommandResult
        {
            CommandResult
            {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult
        {
            CommandResult
            {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult
        {
            CommandResult
            {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }
    
    #[derive(Clone, Debug, Default)]
    pub struct CommandOptions
    {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens>
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens
        {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push(cmd.clone());
                cmd = Vec::new();
            } else {
                cmd.push(token.clone());
            }
        }

        if cmd.is_empty() { return Vec::new(); }

        cmds.push(cmd.clone());
        cmds
    }

    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> 
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
        for (sep, text) in tokens.iter() 
        {
            if !sep.is_empty() || !contains(text, r"^([a-zA-Z0-9_]+)=(.*)$") { break; }

            for cap in re.captures_iter(text) 
            {
                let name = cap[1].to_string();
                let value = unquote(&cap[2]);
                envs.insert(name, value);
            }

            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }

    impl CommandLine 
    {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String> 
        {
            let linfo = parsers::line::parse(line);
            let mut tokens = linfo.tokens;
            shell::do_expansion(sh, &mut tokens);
            let envs = drain_env_tokens(&mut tokens);
            let mut background = false;
            let len = tokens.len();
            
            if len > 1 && tokens[len - 1].1 == "&"
            {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            
            for sub_tokens in split_tokens_by_pipes(&tokens)
            {
                match Command::from_tokens(sub_tokens)
                {
                    Ok(c) => {
                        commands.push(c);
                    }
                    Err(e) => {
                        return Err(e);
                    }
                }
            }

            Ok(CommandLine
            {
                line: line.to_string(),
                commands,
                envs,
                background,
            })
        }

        pub fn is_empty(&self) -> bool { self.commands.is_empty() }

        pub fn with_pipeline(&self) -> bool { self.commands.len() > 1 }

        pub fn is_single_and_builtin(&self) -> bool { self.commands.len() == 1 && self.commands[0].is_builtin() }
    }

    pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String>
    {
        let mut tokens_new = Vec::new();
        let mut redirects = Vec::new();
        let mut to_be_continued = false;
        let mut to_be_continued_s1 = String::new();
        let mut to_be_continued_s2 = String::new();

        for token in tokens 
        {
            let sep = &token.0;
            
            if !sep.is_empty() && !to_be_continued
            {
                tokens_new.push(token.clone());
                continue;
            }
            
            let word = &token.1;

            if to_be_continued
            {
                if sep.is_empty() && word.starts_with('&')
                { return Err(String::from("bad redirection syntax near &")); }

                let s3 = word.to_string();
                if contains(&to_be_continued_s1, r"^\d+$")
                {
                    if to_be_continued_s1 != "1" && to_be_continued_s1 != "2"
                    { return Err(String::from("Bad file descriptor #3")); }

                    let s1 = to_be_continued_s1.clone();
                    let s2 = to_be_continued_s2.clone();
                    redirects.push((s1, s2, s3));
                }
                
                else
                {
                    if !to_be_continued_s1.is_empty()
                    { tokens_new.push((sep.clone(), to_be_continued_s1.to_string())); }

                    redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
                }

                to_be_continued = false;
                continue;
            }

            let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
            let ptn2 = r"^([^>]*)(>>?)$";

            if !contains(word, r">") { tokens_new.push(token.clone()); }
            
            else if contains(word, ptn1)
            {
                let re;
                
                if let Ok(x) = Regex::new(ptn1) { re = x; }
                else { return Err(String::from("Failed to build Regex")); }

                if let Some(caps) = re.captures(word)
                {
                    let s1 = caps.get(1).unwrap().as_str();
                    let s2 = caps.get(2).unwrap().as_str();
                    let s3 = caps.get(3).unwrap().as_str();

                    if s3.starts_with('&') && s3 != "&1" && s3 != "&2" { return Err(String::from("Bad file descriptor #1")); }

                    if contains(s1, r"^\d+$")
                    {
                        if s1 != "1" && s1 != "2" { return Err(String::from("Bad file descriptor #2")); }

                        redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
                    }
                    
                    else
                    {
                        if !s1.is_empty() { tokens_new.push((sep.clone(), s1.to_string())); }

                        redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
                    }
                }
            }

            else if contains(word, ptn2)
            {
                let re;

                if let Ok(x) = Regex::new(ptn2) { re = x; }
                else { return Err(String::from("Failed to build Regex")); }

                if let Some(caps) = re.captures(word)
                {
                    let s1 = caps.get(1).unwrap().as_str();
                    let s2 = caps.get(2).unwrap().as_str();
                    to_be_continued = true;
                    to_be_continued_s1 = s1.to_string();
                    to_be_continued_s2 = s2.to_string();
                }
            }
        }

        if to_be_continued { return Err(String::from("redirection syntax error")); }

        Ok((tokens_new, redirects))
    }
    /*
    uuid v1.17.0*/
    /// A 128-bit (16 byte) buffer containing the UUID.
    pub type Bytes = [u8; 16];

    /// The version of the UUID, denoting the generating algorithm.
    pub const VERSION:u8 = 4;
    /// The reserved variants of UUIDs.
    #[repr(u8)] #[non_exhaustive] #[derive(Clone, Copy, Debug, PartialEq)]
    pub enum Variant 
    {
        /// Reserved by the NCS for backward compatibility.
        NCS = 0u8,
        /// As described in the RFC 9562 Specification (default).
        RFC4122,
        /// Reserved by Microsoft for backward compatibility.
        Microsoft,
        /// Reserved for future expansion.
        Future,
    }

    /// A Universally Unique Identifier (UUID).
    #[repr(transparent)] #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
    pub struct Uuid(Bytes);

    impl Uuid 
    {
        /// UUID namespace for Domain Name System (DNS).
        pub const NAMESPACE_DNS: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
        /// UUID namespace for ISO Object Identifiers (OIDs).
        pub const NAMESPACE_OID: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
        /// UUID namespace for Uniform Resource Locators (URLs).
        pub const NAMESPACE_URL: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
        /// UUID namespace for X.500 Distinguished Names (DNs).
        pub const NAMESPACE_X500: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
        /// Creates a UUID using the supplied bytes.
        #[inline] pub const fn from_bytes(bytes: Bytes) -> Uuid { Uuid(bytes) }
        /// Returns the variant of the UUID structure.
        pub const fn get_variant(&self) -> Variant 
        {
            match self.as_bytes()[8] 
            {
                x if x & 0x80 == 0x00 => Variant::NCS,
                x if x & 0xc0 == 0x80 => Variant::RFC4122,
                x if x & 0xe0 == 0xc0 => Variant::Microsoft,
                x if x & 0xe0 == 0xe0 => Variant::Future,
                _ => Variant::Future,
            }
        }
        /// Returns the version number of the UUID.
        pub const fn get_version_num(&self) -> usize { 4 }
        /// Returns the four field values of the UUID.
        pub fn as_fields(&self) -> (u32, u16, u16, &[u8; 8]) 
        {
            let bytes = self.as_bytes();

            let d1 = (bytes[0] as u32) << 24
                | (bytes[1] as u32) << 16
                | (bytes[2] as u32) << 8
                | (bytes[3] as u32);

            let d2 = (bytes[4] as u16) << 8 | (bytes[5] as u16);

            let d3 = (bytes[6] as u16) << 8 | (bytes[7] as u16);

            let d4: &[u8; 8] = ::convert::TryInto::try_into(&bytes[8..16]).unwrap();
            (d1, d2, d3, d4)
        }
        /// Returns the four field values of the UUID in little-endian order.
        pub fn to_fields_le(&self) -> (u32, u16, u16, &[u8; 8]) 
        {
            let d1 = (self.as_bytes()[0] as u32)
                | (self.as_bytes()[1] as u32) << 8
                | (self.as_bytes()[2] as u32) << 16
                | (self.as_bytes()[3] as u32) << 24;

            let d2 = (self.as_bytes()[4] as u16) | (self.as_bytes()[5] as u16) << 8;

            let d3 = (self.as_bytes()[6] as u16) | (self.as_bytes()[7] as u16) << 8;

            let d4: &[u8; 8] = convert::TryInto::try_into(&self.as_bytes()[8..16]).unwrap();
            (d1, d2, d3, d4)
        }
        /// Returns a 128bit value containing the value.
        pub const fn as_u128(&self) -> u128 { u128::from_be_bytes(*self.as_bytes()) }
        /// Returns a 128bit little-endian value containing the value.
        pub const fn to_u128_le(&self) -> u128 { u128::from_le_bytes(*self.as_bytes()) }
        /// Returns two 64bit values containing the value.
        pub const fn as_u64_pair(&self) -> (u64, u64)
        {
            let value = self.as_u128();
            ((value >> 64) as u64, value as u64)
        }
        /// Returns a slice of 16 octets containing the value.
        #[inline] pub const fn as_bytes(&self) -> &Bytes { &self.0 }
        /// Consumes self and returns the underlying byte value of the UUID.
        #[inline] pub const fn into_bytes(self) -> Bytes { self.0 }
        /// Returns the bytes of the UUID in little-endian order.
        pub const fn to_bytes_le(&self) -> Bytes 
        {
            [
                self.0[3], self.0[2], self.0[1], self.0[0], self.0[5], self.0[4], self.0[7], self.0[6],
                self.0[8], self.0[9], self.0[10], self.0[11], self.0[12], self.0[13], self.0[14],
                self.0[15],
            ]
        }
        /// Tests if the UUID is nil (all zeros).
        pub const fn is_nil(&self) -> bool { self.as_u128() == u128::MIN }
        /// Tests if the UUID is max (all ones).
        pub const fn is_max(&self) -> bool { self.as_u128() == u128::MAX }
        /// A buffer that can be used for `encode_...` calls, 
        /// that is guaranteed to be long enough for any of the format adapters.
        pub const URN_LENGTH: usize = 45;
        pub const fn encode_buffer() -> [u8; 45] { [0; 45] }
        /// Creates a UUID from a 128bit value.
        pub const fn from_u128(v: u128) -> Self { Uuid::from_bytes(v.to_be_bytes()) }
        /// Creates a random UUID.
        pub fn new_v4() -> Uuid 
        {
            use ::rand::prelude::*;
            Uuid::from_u128( random::<u128>() & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000, )
        }
        /// The 'nil UUID' (all zeros).
        pub const fn nil() -> Self { Uuid::from_bytes([0; 16]) }
        /// Creates a UUID using the supplied bytes.
        pub fn from_slice(b: &[u8]) -> Result<Uuid, error::uuid::Error>
        {
            if b.len() != 16 { return Err( error::uuid::Error( error::uuid::ErrorKind::ByteLength { len: b.len() })); }

            let mut bytes: Bytes = [0; 16];
            bytes.copy_from_slice(b);
            Ok(Uuid::from_bytes(bytes))
        }
        /// Get a borrowed [`Hyphenated`] formatter.
        #[inline] pub fn as_hyphenated(&self) -> &Hyphenated 
        { unsafe { &*(self as *const Uuid as *const Hyphenated) } }
    }

    impl Hash for Uuid
    {
        fn hash<H: Hasher>(&self, state: &mut H) { state.write(&self.0); }
    }

    impl Default for Uuid
    {
        #[inline] fn default() -> Self { Uuid::nil() }
    }

    impl AsRef<Uuid> for Uuid
    {
        #[inline] fn as_ref(&self) -> &Uuid { self }
    }

    impl AsRef<[u8]> for Uuid
    {
        #[inline] fn as_ref(&self) -> &[u8] { &self.0 }
    }
    
    impl From<Uuid> for vec::Vec<u8>
    {
        fn from(value: Uuid) -> Self { value.0.to_vec() }
    }
    
    impl ::convert::TryFrom<std::vec::Vec<u8>> for Uuid
    {
        type Error = error::uuid::Error;

        fn try_from(value: std::vec::Vec<u8>) -> Result<Self, Self::Error> { Uuid::from_slice(&value) }
    }

    impl ::fmt::Debug for Uuid
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter<'_>) -> ::fmt::Result { ::fmt::LowerHex::fmt(self, f) }
    }
    
    impl ::fmt::LowerHex for Uuid
    {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
        {
            ::fmt::LowerHex::fmt(self.as_hyphenated(), f)
        }
    }
    /// Format a [`Uuid`] as a hyphenated string | 67e55044-10b1-426f-9247-bb680e5fe0c8
    #[repr(transparent)] #[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]    
    pub struct Hyphenated( Uuid );

    impl Hyphenated
    {
        /// Writes the [`Uuid`] as a lower-case hyphenated string to `buffer`,
        /// and returns the subslice of the buffer that contains the encoded UUID.
        #[inline] pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str
        { encode_hyphenated(self.0.as_bytes(), buffer, false) }

        #[inline] pub fn encode_hyphenated<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str
        {   
            unsafe
            {
                let buf = &mut buffer[..Hyphenated::LENGTH];
                let dst = buf.as_mut_ptr();
                ptr::write(dst.cast(), format_hyphenated(src, upper));
                str::from_utf8_unchecked_mut(buf)
            }
        }
    }
    
    impl fmt::LowerHex for Hyphenated 
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result 
        {
            f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))
        }
    }

    #[inline] pub const fn format_hyphenated(src: &[u8; 16], upper: bool) -> [u8; 36]
    {
        let lut = if upper { &UPPER } else { &LOWER };
        let groups = [(0, 8), (9, 13), (14, 18), (19, 23), (24, 36)];
        let mut dst = [0; 36];

        let mut group_idx = 0;
        let mut i = 0;
        while group_idx < 5 {
            let (start, end) = groups[group_idx];
            let mut j = start;
            while j < end {
                let x = src[i];
                i += 1;

                dst[j] = lut[(x >> 4) as usize];
                dst[j + 1] = lut[(x & 0x0f) as usize];
                j += 2;
            }
            if group_idx < 4 {
                dst[end] = b'-';
            }
            group_idx += 1;
        }
        dst
    }

    #[inline] pub fn encode_hyphenated<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str
    {
        unsafe
        {
            let buf = &mut buffer[..Hyphenated::LENGTH];
            let dst = buf.as_mut_ptr();
            ptr::write(dst.cast(), format_hyphenated(src, upper));
            str::from_utf8_unchecked_mut(buf)
        }
    }

    #[derive(Clone)]
    pub enum App
    {
        All( bool ),
        Open( Option<Option<u64>> ),
        Core( Option<Option<u64>> ),
        Soft( bool ),
        Hard( bool ),
    }

    #[derive(Clone)]
    pub enum Rule
    {
        ASCII_ALPHA,
        ASCII_ALPHANUMERIC,
        ANY,

        CMD,
        CMD_END,
        CMD_NORMAL,

        DUMMY_DO,
        DUMMY_THEN,

        EOI,
        
        EXP,
            EXP_BODY,
            EXP_IF,
            EXP_FOR,
            EXP_WHILE,

        FOR,
            FOR_HEAD,
            FOR_INIT,
            FOR_VAR,

        IF_ELSE_BR,
        IF_ELSEIF_BR,
        IF_ELSEIF_HEAD,
        IF_HEAD,
        IF_IF_BR,
        
        TEST,
        
        KW_LIST,
            KW_DONE,
            KW_ELSE,
            KW_ELSEIF,
            KW_IF,
            KW_FI,
            KW_FOR,        
            KW_WHILE,

        NEWLINE,

        WHILE_HEAD,

        WHITESPACE,
    }

    #[derive(Clone)]
    pub struct LineIndex
    {
        /// Offset (bytes) the the beginning of each line, zero-based
        line_offsets: Vec<usize>,
    }
    /// This structure serves to improve performance over Token objects.
    #[derive(Debug)]
    pub enum QueueableToken<'i, R>
    {
        Start
        {
            /// Queue (as a vec) contains both `Start` token and `End` for the same rule.
            end_token_index: usize,
            /// Position from which rule was tried to parse (or successfully parsed).
            input_pos: usize,
        },
        
        End
        {
            /// Queue (as a vec) contains both `Start` token and `End` for the same rule.
            start_token_index: usize,
            rule: R,
            tag: Option<&'i str>,
            /// Position at which successfully parsed rule finished (ended).
            input_pos: usize,
        },
    }
    /// A matching pair of [`Token`]s and everything between them.
    #[derive(Clone)]
    pub struct Pair<'i, R>
    {
        queue: Rc<Vec<QueueableToken<'i, R>>>,
        input: &'i str,
        start: usize,
        line_index: Rc<LineIndex>,
    }
}

pub mod vec
{
    pub use std::vec::{ * };
    pub use ::smallvec::
    { 
        Drain as SmallDrain,
        IntoIter as SmallIntoIter,
        *
    };
}

fn main() -> ::result::Result<(), Box<dyn std::error::Error>>
{
    use ::database::Database;
    use ::str::FromStr;

    let over:String = r#"
    receipt: "Oz-Ware Purchase Invoice"
    date:    "2012-08-06"
    customer: 
    {
        first_name:  "Dorothy"
        family_name: "Gale"
    }

    items: 
    [
        {
            part_no:  "A4786"
            descrip:  "Water Bucket (Filled)"
            price:    01.47
            quantity: 4
        }
        {
            part_no:  "E1628"
            descrip:  "High Heeled \"Ruby\" Slippers"
            size:     8
            price:    133.70
            quantity: 1
        }
    ]

    bill_to: 
    {
        street:
        # A multi-line string. Can also be written as "123 Tornado Alley\nSuite16"
        "123 Tornado Alley
        Suite 16"
        city:  "East Centerville"
        state: "KS"
    }

    ship_to: bill_to

    specialDelivery: "Follow the Yellow Brick Road to the Emerald City. 
    Pay no attention to the man behind the curtain."
    "#.to_string();
        
        // let mut db = Obj::from_str( &over.as_str() )?;
        let mut db = Database::new().build();
        println!( r#"::database::
    {:?}
    "#, db);

    Ok(())
}
// #\[stable\(feature = ".+", since = ".+"\)\]
// #\[unstable\(feature = ".+", issue = ".+"\)\]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 53994
