/*!
*/
#![feature
(
	tool_lints,
)]

#![allow
(
    dead_code,
	unknown_lints,
    unreachable_patterns,
)]
/*
#[macro_use] extern crate lazy_static;
extern crate errno;
extern crate exec;
extern crate glob;
extern crate libc;
extern crate lineread;
extern crate nix;
extern crate regex;
extern crate rusqlite;
extern crate yaml_rust;
extern crate clap;

use lineread::{Command, Interface, ReadResult};
*/

#[macro_use] pub mod macros
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
    #[macro_export] macro_rules! __lazy_static_create
    {
        ($NAME:ident, $T:ty) =>
        {
            static $NAME: ::lazy::Lazy<$T> = ::lazy::Lazy::INIT;
        };
    }

    #[macro_export(local_inner_macros)]
    macro_rules! __lazy_static_internal
    {
        ($(#[$attr:meta])* ($($vis:tt)*) static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) =>
        {
            __lazy_static_internal!(@MAKE TY, $(#[$attr])*, ($($vis)*), $N);
            __lazy_static_internal!(@TAIL, $N : $T = $e);
            lazy_static!($($t)*);
        };
        
        (@TAIL, $N:ident : $T:ty = $e:expr) =>
        {
            impl ::ops::Deref for $N
            {
                type Target = $T;
                fn deref(&self) -> &$T
                {
                    #[inline(always)] fn __static_ref_initialize() -> $T { $e }

                    #[inline(always)] fn __stability() -> &'static $T
                    {
                        __lazy_static_create!(LAZY, $T);
                        LAZY.get(__static_ref_initialize)
                    }
                    __stability()
                }
            }
            
            impl ::lazy::LazyStatic for $N
            {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
        };
        
        (@MAKE TY, $(#[$attr:meta])*, ($($vis:tt)*), $N:ident) =>
        {
            #[allow(missing_copy_implementations)]
            #[allow(non_camel_case_types)]
            #[allow(dead_code)]
            $(#[$attr])*
            $($vis)* struct $N {__private_field: ()}
                    #[allow(non_upper_case_globals)]
            $($vis)* static $N: $N = $N {__private_field: ()};
        };
        
        () => ()
    }

    #[macro_export(local_inner_macros)]
    macro_rules! lazy_static
    {

        ($(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) =>
        {
            __lazy_static_internal!($(#[$attr])* () static ref $N : $T = $e; $($t)*);
        };
        
        ($(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) =>
        {
            __lazy_static_internal!($(#[$attr])* (pub) static ref $N : $T = $e; $($t)*);
        };
        
        ($(#[$attr:meta])* pub ($($vis:tt)+) static ref $N:ident : $T:ty = $e:expr; $($t:tt)*) =>
        {
            __lazy_static_internal!($(#[$attr])* (pub ($($vis)+)) static ref $N : $T = $e; $($t)*);
        };
        
        () => ()
    }

	#[macro_export] macro_rules! println_stderr
	{
		($fmt:expr) => 
        (
			match writeln!(&mut ::io::stderr(), $fmt)
            {
				Ok(_) => {}
				Err(e) => println!("write to stderr failed: {:?}", e)
			}
		);

		($fmt:expr, $($arg:tt)*) =>
        (
			match writeln!( &mut ::io::stderr(), $fmt, $($arg)* )
            {
				Ok(_) => {}
				Err(e) => println!("write to stderr failed: {:?}", e)
			}
		);
	}

    #[macro_export] macro_rules! log
    {
        ($fmt:expr) => (
            let log_file = if let Ok(x) = std::env::var("CICADA_LOG_FILE") {
                x.clone()
            } else {
                String::new()
            };

            if !log_file.is_empty() {
                use std::io::Write as _;

                let msg = $fmt;
                match std::fs::OpenOptions::new().append(true).create(true).open(&log_file) {
                    Ok(mut cfile) => {
                        let pid = ::process::read_id();
                        let now = ::libc::time::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes()) {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }
                    Err(_) => println!("tlog: open file error"),
                }

            }
        );

        ($fmt:expr, $($arg:tt)*) => (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }

}

pub mod api
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use regex::Regex;
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::builtins::utils::print_stdout_with_capture;
	use crate::shell;
	use crate::tools;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::jobc;
	use crate::libc;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use std::env;
	use std::path::Path;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::parsers;
	use crate::shell;
	use crate::tools;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stdout_with_capture;
	use crate::history;
	use crate::libs;
	use crate::rcfile;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use exec;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::parsers;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	#![allow(unreachable_code)]
	use std::process;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use regex::Regex;
	use std::env;

	use crate::libs;
	use crate::parsers;
	use crate::tools;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use libc;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::jobc;
	use crate::shell::{self, Shell};
	use crate::types::{Command, CommandLine, CommandResult};
	
	use std::path::Path;

	use rusqlite::Connection as Conn;
	use structopt::StructOpt;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::builtins::utils::print_stdout_with_capture;
	use crate::ctime;
	use crate::history;
	use crate::parsers;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stdout_with_capture;
	use crate::jobc;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use std::io::Write;
	use std::os::fd::AsRawFd;

	use crate::builtins::utils::print_stdout_with_capture;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use std::io;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::::regex::contains;
	use crate::shell::Shell;
	use crate::tools;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use structopt::StructOpt;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::builtins::utils::print_stdout_with_capture;
	use crate::parsers;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::parsers;
	use crate::scripts;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::builtins::utils::print_stdout_with_capture;
	use crate::parsers;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	use clap::{CommandFactory, Parser};
	use std::io::Error;
	
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use crate::builtins::utils::print_stderr_with_capture;
	use crate::shell::Shell;
	use crate::types::{Command, CommandLine, CommandResult};
	
	use std::env;
	use std::fs;
	use std::path::Path;

	use crate::builtins::utils::print_stderr_with_capture;
	use crate::builtins::utils::print_stdout_with_capture;
	use ::now;
	use crate::parsers;
	use crate::shell::{self, Shell};
	use crate::types::{self, Command, CommandLine, CommandResult};
	*/
	#[derive(Debug, StructOpt)]
	#[structopt(name = "set", about = "Set shell options (BETA)")]
	struct OptMainSet
	{
		#[structopt(short, help = "exit on error status")]
		exit_on_error: bool,
	}


	#[derive(Debug, StructOpt)]
	#[structopt(name = "history", about = "History in cicada shell")]
	struct OptMainHistory
	{
		#[structopt(short, long, help = "For current session only")]
		session: bool,

		#[structopt(short, long, help = "Search old items first")]
		asc: bool,

		#[structopt(short, long, help = "For current directory only")]
		pwd: bool,

		#[structopt(short, long, help = "Only show ROWID")]
		only_id: bool,

		#[structopt(short, long, help = "Do not show ROWID")]
		no_id: bool,

		#[structopt(short = "d", long, help = "Show date")]
		show_date: bool,

		#[structopt(short, long, default_value = "20")]
		limit: i32,

		#[structopt(
			name = "PATTERN",
			default_value = "",
			help = "You can use % to match anything"
		)]
		pattern: String,

		#[structopt(subcommand)]
		cmd: Option<SubCommand>,
	}

	#[derive(StructOpt, Debug)]
	enum SubCommandHistory
	{
		#[structopt(about = "Add new item into history")]
		Add {
			#[structopt(short = "t", long, help = "Specify a timestamp for the new item")]
			timestamp: Option<f64>,

			#[structopt(name = "INPUT", help = "input to be added into history")]
			input: String,
		},
		#[structopt(about = "Delete item from history")]
		Delete {
			#[structopt(name = "ROWID", help = "Row IDs of item to delete")]
			rowid: Vec<usize>,
		},
	}
	
	#[derive(Parser)]
	#[command(name = "ulimit", about = "show / modify shell resource limits")]
	#[allow(non_snake_case)]
	struct App {
		#[arg(short, help = "All current limits are reported.")]
		a: bool,
		#[arg(
			short,
			value_name = "NEW VALUE",
			help = "The maximum number of open file descriptors."
		)]
		n: Option<Option<u64>>,
		#[arg(
			short,
			value_name = "NEW VALUE",
			help = "The maximum size of core files created."
		)]
		c: Option<Option<u64>>,
		#[arg(
			short = 'S',
			help = "Set a soft limit for the given resource. (default)"
		)]
		S: bool,
		#[arg(short = 'H', help = "Set a hard limit for the given resource.")]
		H: bool,
	}
	
	pub fn run_alias(
		sh: &mut shell::Shell,
		cl: &CommandLine,
		cmd: &Command,
		capture: bool,
	) -> CommandResult 
	{
		let mut cr = CommandResult::new();
		let tokens = cmd.tokens.clone();

		if tokens.len() == 1 {
			return show_alias_list(sh, cmd, cl, capture);
		}

		if tokens.len() > 2 {
			let info = "alias syntax error: usage: alias foo='echo foo'";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let input = &tokens[1].1;
		let re_single_read = Regex::new(r"^[a-zA-Z0-9_\.-]+$").unwrap();
		if re_single_read.is_match(input) {
			return show_single_alias(sh, input, cmd, cl, capture);
		}

		let re_to_add = Regex::new(r"^([a-zA-Z0-9_\.-]+)=(.*)$").unwrap();
		for cap in re_to_add.captures_iter(input)
        {
			let name = tools::unquote(&cap[1]);
			// due to limitation of `parses::parser_line`,
			// `alias foo-bar='foo bar'` will become 'foo-bar=foo bar'
			// while `alias foo_bar='foo bar'` keeps foo_bar='foo bar'
			let value = if cap[2].starts_with('"') || cap[2].starts_with('\'') {
				tools::unquote(&cap[2])
			} else {
				cap[2].to_string()
			};
			sh.add_alias(name.as_str(), value.as_str());
		}

		CommandResult::new()
	}

	pub fn run_bg(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let tokens = cmd.tokens.clone();
		let mut cr = CommandResult::new();

		if sh.jobs.is_empty()
        {
			let info = "cicada: bg: no job found";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let mut job_id = -1;
		if tokens.len() == 1 {
			if let Some((gid, _)) = sh.jobs.iter().next() {
				job_id = *gid;
			}
		}

		if tokens.len() >= 2 {
			let mut job_str = tokens[1].1.clone();
			if job_str.starts_with("%") {
				job_str = job_str.trim_start_matches('%').to_string();
			}

			match job_str.parse::<i32>()
            {
				Ok(n) => job_id = n,
				Err(_) => {
					let info = "cicada: bg: invalid job id";
					print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
					return cr;
				}
			}
		}
		if job_id == -1 {
			let info = "cicada: bg: not such job";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let gid: i32;

		{
			let mut result = sh.get_job_by_id(job_id);
			// fall back to find job by using prcess group id
			if result.is_none() {
				result = sh.get_job_by_gid(job_id);
			}

			match result {
				Some(job) => {
					unsafe {
						libc::killpg(job.gid, libc::SIGCONT);
						gid = job.gid;
						if job.status == "Running" {
							let info = format!("cicada: bg: job {} already in background", job.id);
							print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
							return cr;
						}
					}

					let info_cmd = format!("[{}]  {} &", job.id, job.cmd);
					print_stderr_with_capture(&info_cmd, &mut cr, cl, cmd, capture);
					cr.status = 0;
				}
				None => {
					let info = "cicada: bg: not such job";
					print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
					return cr;
				}
			}
		}

		jobc::mark_job_as_running(sh, gid, true);
		cr
	}

	pub fn run_cd
	(
		sh: &mut shell::Shell,
		cl: &CommandLine,
		cmd: &Command,
		capture: bool,
	) -> CommandResult 
	{
		let tokens = cmd.tokens.clone();
		let mut cr = CommandResult::new();
		let args = parsers::line::tokens_to_args(&tokens);

		if args.len() > 2 {
			let info = "cicada: cd: too many argument";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let str_current_dir = tools::get_current_dir();

		let mut dir_to = if args.len() == 1 {
			let home = tools::get_user_home();
			home.to_string()
		} else {
			args[1..].join("")
		};

		if dir_to == "-" {
			if sh.previous_dir.is_empty() {
				let info = "no previous dir";
				print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
				return cr;
			}
			dir_to = sh.previous_dir.clone();
		} else if !dir_to.starts_with('/') {
			dir_to = format!("{}/{}", str_current_dir, dir_to);
		}

		if !Path::new(&dir_to).exists()
        {
			let info = format!("cicada: cd: {}: No such file or directory", &args[1]);
			print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
			return cr;
		}

		match Path::new(&dir_to).canonicalize()
        {
			Ok(p) => {
				dir_to = p.as_path().to_string_lossy().to_string();
			}
			Err(e) => {
				let info = format!("cicada: cd: error: {}", e);
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				return cr;
			}
		}

		match env::set_current_dir(&dir_to)
        {
			Ok(_) => {
				sh.current_dir = dir_to.clone();
				if str_current_dir != dir_to {
					sh.previous_dir = str_current_dir.clone();
					env::set_var("PWD", &sh.current_dir);
				};
				cr.status = 0;
				cr
			}
			Err(e) => {
				let info = format!("cicada: cd: {}", e);
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				cr
			}
		}
	}

	pub fn run_cinfo(_sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
        /*
        let mut info = vec![];
		const VERSION: &str = env!("CARGO_PKG_VERSION");
        
		info.push(("version", VERSION));

		let os_name = libs::os_type::get_os_name();
		info.push(("os-name", &os_name));

		let hfile = history::get_history_file();
		info.push(("history-file", &hfile));

		let rcf = rcfile::get_rc_file();
		info.push(("rc-file", &rcf));

		let git_hash = env!("GIT_HASH");
		if !git_hash.is_empty() {
			info.push(("git-commit", env!("GIT_HASH")));
		}

		let git_branch = env!("GIT_BRANCH");
		let mut branch = String::new();
		if !git_branch.is_empty() {
			branch.push_str(git_branch);
			let git_status = env!("GIT_STATUS");
			if git_status != "0" {
				branch.push_str(" (dirty)");
			}
			info.push(("git-branch", &branch));
		}

		info.push(("built-with", env!("BUILD_RUSTC_VERSION")));
		info.push(("built-at", env!("BUILD_DATE")));

		let mut lines = Vec::new();
		for (k, v) in &info {
			// longest key above is 12-char length
			lines.push(format!("{: >12}: {}", k, v));
		}
		let buffer = lines.join("\n");
		
		print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);*/
		cr
	}

	pub fn run_exec(_sh: &Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = cmd.tokens.clone();
		let args = parsers::line::tokens_to_args(&tokens);
		let len = args.len();
		if len == 1 {
			print_stderr_with_capture("invalid usage", &mut cr, cl, cmd, capture);
			return cr;
		}

		let mut _cmd = exec::Command::new(&args[1]);
		let err = _cmd.args(&args[2..len]).exec();
		let info = format!("cicada: exec: {}", err);
		print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
		cr
	}

	pub fn run_exit(sh: &Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = cmd.tokens.clone();
		if tokens.len() > 2 {
			let info = "cicada: exit: too many arguments";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		if tokens.len() == 2 {
			let _code = &tokens[1].1;
			match _code.parse::<i32>()
            {
				Ok(x) => {
					process::exit(x);
				}
				Err(_) => {
					let info = format!("cicada: exit: {}: numeric argument required", _code);
					print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
					process::exit(255);
				}
			}
		}

		for (_i, job) in sh.jobs.iter() {
			if !job.cmd.starts_with("nohup ") {
				let mut info = String::new();
				info.push_str("There are background jobs.");
				info.push_str("Run `jobs` to see details; `exit 1` to force quit.");
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				return cr;
			}
		}

		process::exit(0);
		cr
	}

	pub fn run_export(_sh: &Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = cmd.tokens.clone();

		let re_name_ptn = Regex::new(r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$").unwrap();
		for (_, text) in tokens.iter() {
			if text == "export" {
				continue;
			}

			if !::is::env(text) {
				let mut info = String::new();
				info.push_str("export: invalid command\n");
				info.push_str("usage: export XXX=YYY");
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				return cr;
			}

			if !re_name_ptn.is_match(text) {
				let mut info = String::new();
				info.push_str("export: invalid command\n");
				info.push_str("usage: export XXX=YYY ZZ=123");
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				return cr;
			}

			for cap in re_name_ptn.captures_iter(text) {
				let name = cap[1].to_string();
				let token = parsers::line::unquote(&cap[2]);
				let value = libs::path::expand_home(&token);
				env::set_var(name, &value);
			}
		}
		cr
	}

	pub fn run_fg(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let tokens = cmd.tokens.clone();
		let mut cr = CommandResult::new();

		if sh.jobs.is_empty()
        {
			let info = "cicada: fg: no job found";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let mut job_id = -1;
		if tokens.len() == 1 {
			if let Some((gid, _)) = sh.jobs.iter().next() {
				job_id = *gid;
			}
		}

		if tokens.len() >= 2 {
			let mut job_str = tokens[1].1.clone();
			if job_str.starts_with("%") {
				job_str = job_str.trim_start_matches('%').to_string();
			}

			match job_str.parse::<i32>()
            {
				Ok(n) => job_id = n,
				Err(_) => {
					let info = "cicada: fg: invalid job id";
					print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
					return cr;
				}
			}
		}

		if job_id == -1 {
			let info = "cicada: not job id found";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let gid: i32;
		let pid_list: Vec<i32>;

		{
			let mut result = sh.get_job_by_id(job_id);
			// fall back to find job by using prcess group id
			if result.is_none() {
				result = sh.get_job_by_gid(job_id);
			}

			match result {
				Some(job) => {
					print_stderr_with_capture(&job.cmd, &mut cr, cl, cmd, capture);
					cr.status = 0;

					unsafe {
						if !shell::give_terminal_to(job.gid) {
							return CommandResult::error();
						}

						libc::killpg(job.gid, libc::SIGCONT);
						pid_list = job.pids.clone();
						gid = job.gid;
					}
				}
				None => {
					let info = "cicada: fg: no such job";
					print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
					return cr;
				}
			}
		}

		unsafe {
			jobc::mark_job_as_running(sh, gid, false);

			let cr = jobc::wait_fg_job(sh, gid, &pid_list);

			let gid_shell = libc::getpgid(0);
			if !shell::give_terminal_to(gid_shell) {
				log!("failed to give term to back to shell : {}", gid_shell);
			}

			cr
		}
	}

	pub fn run_history(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let hfile = history::get_history_file();
		let path = Path::new(hfile.as_str());
		if !path.exists()
        {
			let info = "no history file";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}
		let conn = match Conn::open(&hfile)
        {
			Ok(x) => x,
			Err(e) => {
				let info = format!("history: sqlite error: {:?}", e);
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				return cr;
			}
		};

		let tokens = cmd.tokens.clone();
		let args = parsers::line::tokens_to_args(&tokens);

		let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");
		let opt = OptMain::from_iter_safe(args);
		match opt {
			Ok(opt) => match opt.cmd {
				Some(SubCommand::Delete { rowid: rowids }) => {
					let mut _count = 0;
					for rowid in rowids {
						let _deleted = delete_history_item(&conn, rowid);
						if _deleted {
							_count += 1;
						}
					}
					if _count > 0 {
						let info = format!("deleted {} items", _count);
						print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
					}
					cr
				}
				Some(SubCommand::Add {
					timestamp: ts,
					input,
				}) => {
					let ts = ts.unwrap_or(0 as f64);
					add_history(sh, ts, &input);
					cr
				}
				None => {
					let (str_out, str_err) = list_current_history(sh, &conn, &opt);
					if !str_out.is_empty() {
						print_stdout_with_capture(&str_out, &mut cr, cl, cmd, capture);
					}
					if !str_err.is_empty() {
						print_stderr_with_capture(&str_err, &mut cr, cl, cmd, capture);
					}
					cr
				}
			},
			Err(e) => {
				let info = format!("{}", e);
				if show_usage {
					print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
					cr.status = 0;
				} else {
					print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
					cr.status = 1;
				}
				cr
			}
		}
	}

	pub fn run_jobs(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		if sh.jobs.is_empty() {
			return cr;
		}

		// update status of jobs if any
		jobc::try_wait_bg_jobs(sh, false, false);

		let mut lines = Vec::new();
		let jobs = sh.jobs.clone();
		let no_trim = cmd.tokens.len() >= 2 && cmd.tokens[1].1 == "-f";
		for (_i, job) in jobs.iter()
        {
			let line = jobc::get_job_line(job, !no_trim);
			lines.push(line);
		}
		let buffer = lines.join("\n");

		print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
		cr
	}
	
	pub fn run_minfd(_sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();

		let fd = nix::fcntl::open(
			"/dev/null",
			nix::fcntl::OFlag::empty(),
			nix::sys::stat::Mode::empty(),
		);
		match fd {
			Ok(fd) => {
				let info = format!("{}", fd.as_raw_fd());
				print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
			}
			Err(e) => {
				println_stderr!("cicada: minfd: error: {}", e);
			}
		}

		cr
	}

	pub fn run_read(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = cmd.tokens.clone();

		let name_list: Vec<String>;
		if tokens.len() <= 1 {
			name_list = vec!["REPLY".to_string()];
		} else {
			name_list = tokens[1..].iter().map(|x| x.1.clone()).collect();
			if let Some(id_) = _find_invalid_identifier(&name_list) {
				let info = format!("cicada: read: `{}': not a valid identifier", id_);
				print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
				return cr;
			}
		}

		let mut buffer = String::new();

		if cmd.has_here_string() {
			if let Some(redirect_from) = &cmd.redirect_from {
				buffer.push_str(&redirect_from.1);
				buffer.push('\n');
			}
		} else {
			match io::stdin().read_line(&mut buffer)
            {
				Ok(_) => {}
				Err(e) => {
					let info = format!("cicada: read: error in reading stdin: {:?}", e);
					print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
					return cr;
				}
			}
		}

		let envs = cl.envs.clone();
		let value_list = tools::split_into_fields(sh, buffer.trim(), &envs);

		let idx_2rd_last = name_list.len() - 1;
		for i in 0..idx_2rd_last {
			let name = name_list.get(i);
			if name.is_none() {
				let info = "cicada: read: name index error";
				print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
				return cr;
			}
			let name = name.unwrap();

			let value = value_list.get(i).unwrap_or(&String::new()).clone();
			sh.set_env(name, &value);
		}

		let name_last = &name_list[idx_2rd_last];
		let value_left: String = if value_list.len() > idx_2rd_last {
			value_list[idx_2rd_last..].join(" ")
		} else {
			String::new()
		};
		sh.set_env(name_last, &value_left);
		cr
	}
	
	pub fn run_set(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult 
	{
		let mut cr = CommandResult::new();
		let tokens = &cmd.tokens;
		let args = parsers::line::tokens_to_args(tokens);
		let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");

		let opt = OptMain::from_iter_safe(args);
		match opt {
			Ok(opt) => {
				if opt.exit_on_error {
					sh.exit_on_error = true;
					cr
				} else {
					let info = "cicada: set: option not implemented";
					print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
					cr
				}
			}
			Err(e) => {
				let info = format!("{}", e);
				if show_usage {
					print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
					cr.status = 0;
				} else {
					print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
					cr.status = 1;
				}
				cr
			}
		}
	}
	
	pub fn run_source(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = &cmd.tokens;
		let args = parsers::line::tokens_to_args(tokens);

		if args.len() < 2 {
			let info = "cicada: source: no file specified";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let status = scripting::run_script(sh, &args);
		cr.status = status;
		cr
	}

	pub fn run_ulimit(_sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = &cmd.tokens;
		let args = parsers::line::tokens_to_args(tokens);

		if args.contains(&"--help".to_string()) || args.contains(&"-h".to_string()) {
			App::command().print_help().unwrap();
			println!();
			return cr;
		}

		let app = App::parse_from(args);

		if app.H && app.S {
			println!("cicada: ulimit: Cannot both hard and soft.");
			cr.status = 1;
			return cr;
		}

		let mut all_stdout = String::new();
		let mut all_stderr = String::new();

		if app.a {
			report_all(&app, &mut all_stdout, &mut all_stderr);
		} else if handle_limit(app.n, "open_files", app.H, &mut all_stdout, &mut all_stderr)
			|| handle_limit(
				app.c,
				"core_file_size",
				app.H,
				&mut all_stdout,
				&mut all_stderr,
			)
		{
		} else {
			report_all(&app, &mut all_stdout, &mut all_stderr);
		}

		if !all_stdout.is_empty() {
			print_stdout_with_capture(&all_stdout, &mut cr, cl, cmd, capture);
		}
		if !all_stderr.is_empty() {
			print_stderr_with_capture(&all_stderr, &mut cr, cl, cmd, capture);
		}

		cr
	}

	pub fn run_unalias(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let tokens = cmd.tokens.clone();
		let mut cr = CommandResult::new();

		if tokens.len() != 2 {
			let info = "cicada: unalias: syntax error";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let input = &tokens[1].1;
		if !sh.remove_alias(input)
        {
			let info = format!("cicada: unalias: {}: not found", input);
			print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
			return cr;
		}
		cr
	}

	pub fn run_unpath(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let tokens = cmd.tokens.clone();
		let mut cr = CommandResult::new();

		if tokens.len() != 2 {
			let info = "cicada: unpath: syntax error";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let input = &tokens[1].1;
		sh.remove_path(input);
		cr
	}

	pub fn run_unset(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let tokens = cmd.tokens.clone();
		let mut cr = CommandResult::new();

		if tokens.len() != 2 {
			let info = "cicada: unset: syntax error";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			return cr;
		}

		let input = &tokens[1].1;
		if !sh.remove_env(input)
        {
			let info = format!("cicada: unset: invalid varname: {:?}", input);
			print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
			return cr;
		}
		cr
	}

	pub fn run_vox(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
	{
		let mut cr = CommandResult::new();
		let tokens = cmd.tokens.clone();
		let args = parsers::line::tokens_to_args(&tokens);
		let len = args.len();
		let subcmd = if len > 1 { &args[1] } else { "" };

		if len == 1 || (len == 2 && subcmd == "ls") {
			match get_all_venvs()
            {
				Ok(venvs) => {
					let info = venvs.join("\n");
					print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
					return cr;
				}
				Err(reason) => {
					print_stderr_with_capture(&reason, &mut cr, cl, cmd, capture);
					return cr;
				}
			}
		}

		if len == 3 && subcmd == "create" {
			let pybin = match env::var("VIRTUALENV_PYBIN")
            {
				Ok(x) => x,
				Err(_) => "python3".to_string(),
			};
			let dir_venv = get_envs_home();
			let venv_name = args[2].to_string();
			let line = format!("{} -m venv \"{}/{}\"", pybin, dir_venv, venv_name);
			print_stderr_with_capture(&line, &mut cr, cl, cmd, capture);
			let cr_list = execute::run_command_line(sh, &line, false, false);
			return cr_list[0].clone();
		}

		if len == 3 && subcmd == "enter" {
			let _err = enter_env(sh, args[2].as_str());
			if !_err.is_empty() {
				print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
			}
			cr
		} else if len == 2 && subcmd == "exit" {
			let _err = exit_env(sh);
			if !_err.is_empty() {
				print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
			}
			cr
		} else {
			let info = "cicada: vox: invalid option";
			print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
			cr
		}
	}

	fn in_env() -> bool {
		env::var("VIRTUAL_ENV").is_ok_and(|x| !x.is_empty())
	}

	fn get_envs_home() -> String {
		env::var("VIRTUALENV_HOME").unwrap_or_default()
	}

	fn get_all_venvs() -> Result<Vec<String>, String>
    {
		let home_envs = get_envs_home();
		if home_envs.is_empty()
        {
			let info = String::from("you need to set VIRTUALENV_HOME to use vox");
			return Err(info);
		}
		if !Path::new(home_envs.as_str()).exists() {
			match fs::create_dir_all(home_envs.as_str())
            {
				Ok(_) => {}
				Err(e) => {
					let info = format!("fs create_dir_all failed: {:?}", e);
					return Err(info);
				}
			}
		}

		let mut venvs = Vec::new();
		let pdir = home_envs.clone();
		if let Ok(list) = fs::read_dir(home_envs)
        {
			for ent in list.flatten() {
				let ent_name = ent.file_name();
				if let Ok(path) = ent_name.into_string() {
					let full_path = format!("{}/{}/bin/activate", pdir, path);
					if !Path::new(full_path.as_str()).exists() {
						continue;
					}
					venvs.push(path);
				}
			}
		}

		Ok(venvs)
	}

	fn enter_env(sh: &Shell, path: &str) -> String {
		if in_env() {
			return "vox: already in env".to_string();
		}

		let home_envs = get_envs_home();
		let full_path = format!("{}/{}/bin/activate", home_envs, path);
		if !Path::new(full_path.as_str()).exists() {
			return format!("no such env: {}", full_path);
		}

		let path_env = format!("{}/{}", home_envs, path);
		env::set_var("VIRTUAL_ENV", &path_env);
		let path_new = String::from("${VIRTUAL_ENV}/bin:$PATH");
		let mut tokens: types::Tokens = Vec::new();
		tokens.push((String::new(), path_new));
		shell::expand_env(sh, &mut tokens);
		env::set_var("PATH", &tokens[0].1);
		String::new()
	}

	fn exit_env(sh: &Shell) -> String {
		if !in_env() {
			return String::from("vox: not in an env");
		}

		let env_path = match env::var("PATH")
        {
			Ok(x) => x,
			Err(_) => {
				return String::from("vox: cannot read PATH env");
			}
		};

		let mut _tokens: Vec<&str> = env_path.split(':').collect();
		let mut path_virtual_env = String::from("${VIRTUAL_ENV}/bin");
		// shell::extend_env(sh, &mut path_virtual_env);
		let mut tokens: types::Tokens = Vec::new();
		tokens.push((String::new(), path_virtual_env));
		shell::expand_env(sh, &mut tokens);
		path_virtual_env = tokens[0].1.clone();
		_tokens
			.iter()
			.position(|&n| n == path_virtual_env)
			.map(|e| _tokens.remove(e));
		let env_path_new = _tokens.join(":");
		env::set_var("PATH", &env_path_new);
		env::set_var("VIRTUAL_ENV", "");

		String::new()
	}
	
	fn set_limit(limit_name: &str, value: u64, for_hard: bool) -> String
	{
		let limit_id = match limit_name {
			"open_files" => libc::RLIMIT_NOFILE,
			"core_file_size" => libc::RLIMIT_CORE,
			_ => return String::from("invalid limit name"),
		};

		let mut rlp = libc::rlimit {
			rlim_cur: 0,
			rlim_max: 0,
		};

		unsafe {
			if libc::getrlimit(limit_id, &mut rlp) != 0 {
				return format!(
					"cicada: ulimit: error getting limit: {}",
					Error::last_os_error()
				);
			}
		}

		// to support armv7-linux-gnueabihf & 32-bit musl systems
		if for_hard {
			#[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
			{
				rlp.rlim_max = value as u32;
			}
			#[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
			{
				rlp.rlim_max = value;
			}
		} else {
			#[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
			{
				rlp.rlim_cur = value as u32;
			}
			#[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
			{
				rlp.rlim_cur = value;
			}
		}

		unsafe {
			if libc::setrlimit(limit_id, &rlp) != 0 {
				return format!(
					"cicada: ulimit: error setting limit: {}",
					Error::last_os_error()
				);
			}
		}

		String::new()
	}

	fn get_limit(limit_name: &str, single_print: bool, for_hard: bool) -> (String, String)
    {
		let (desc, limit_id) = match limit_name {
			"open_files" => ("open files", libc::RLIMIT_NOFILE),
			"core_file_size" => ("core file size", libc::RLIMIT_CORE),
			_ => {
				return (
					String::new(),
					String::from("ulimit: error: invalid limit name"),
				)
			}
		};

		let mut rlp = libc::rlimit {
			rlim_cur: 0,
			rlim_max: 0,
		};

		let mut result_stdout = String::new();
		let mut result_stderr = String::new();

		unsafe {
			if libc::getrlimit(limit_id, &mut rlp) != 0 {
				result_stderr.push_str(&format!("error getting limit: {}", Error::last_os_error()));
				return (result_stdout, result_stderr);
			}

			let to_print = if for_hard { rlp.rlim_max } else { rlp.rlim_cur };

			let info = if to_print == libc::RLIM_INFINITY {
				if single_print {
					"unlimited\n".to_string()
				} else {
					format!("{}\t\tunlimited\n", desc)
				}
			} else if single_print {
				format!("{}\n", to_print)
			} else {
				format!("{}\t\t{}\n", desc, to_print)
			};

			result_stdout.push_str(&info);
		}

		(result_stdout, result_stderr)
	}

	fn report_all(app: &App, all_stdout: &mut String, all_stderr: &mut String) {
		for limit_name in &["open_files", "core_file_size"] {
			let (out, err) = get_limit(limit_name, false, app.H);
			all_stdout.push_str(&out);
			all_stderr.push_str(&err);
		}
	}

	fn handle_limit(
		limit_option: Option<Option<u64>>,
		limit_name: &str,
		for_hard: bool,
		all_stdout: &mut String,
		all_stderr: &mut String,
	) -> bool
    {
		match limit_option {
			None => false,
			Some(None) => {
				let (out, err) = get_limit(limit_name, true, for_hard);
				all_stdout.push_str(&out);
				all_stderr.push_str(&err);
				true
			}
			Some(Some(value)) => {
				let err = set_limit(limit_name, value, for_hard);
				if !err.is_empty() {
					all_stderr.push_str(&err);
				}
				true
			}
		}
	}

	
	fn _find_invalid_identifier(name_list: &Vec<String>) -> Option<String>
	{
		for id_ in name_list {
			if !re_contains(id_, r"^[a-zA-Z_][a-zA-Z0-9_]*$") {
				return Some(id_.to_string());
			}
		}
		None
	}
	
	fn add_history(sh: &Shell, ts: f64, input: &str)
	{
		let (tsb, tse) = (ts, ts + 1.0);
		history::add_raw(sh, input, 0, tsb, tse);
	}

	fn list_current_history(sh: &Shell, conn: &Conn, opt: &OptMain) -> (String, String)
    {
		let mut result_stderr = String::new();
		let result_stdout = String::new();

		let history_table = history::get_history_table();
		let mut sql = format!(
			"SELECT ROWID, inp, tsb FROM {} WHERE ROWID > 0",
			history_table
		);
		if !opt.pattern.is_empty() {
			sql = format!("{} AND inp LIKE '%{}%'", sql, opt.pattern)
		}
		if opt.session {
			sql = format!("{} AND sessionid = '{}'", sql, sh.session_id)
		}
		if opt.pwd {
			sql = format!("{} AND info like '%dir:{}|%'", sql, sh.current_dir)
		}

		if opt.asc {
			sql = format!("{} ORDER BY tsb", sql);
		} else {
			sql = format!("{} order by tsb desc", sql);
		};
		sql = format!("{} limit {} ", sql, opt.limit);

		let mut stmt = match conn.prepare(&sql)
        {
			Ok(x) => x,
			Err(e) => {
				let info = format!("history: prepare select error: {:?}", e);
				result_stderr.push_str(&info);
				return (result_stdout, result_stderr);
			}
		};

		let mut rows = match stmt.query([])
        {
			Ok(x) => x,
			Err(e) => {
				let info = format!("history: query error: {:?}", e);
				result_stderr.push_str(&info);
				return (result_stdout, result_stderr);
			}
		};

		let mut lines = Vec::new();
		loop {
			match rows.next()
            {
				Ok(_rows) => {
					if let Some(row) = _rows {
						let row_id: i32 = match row.get(0) {
							Ok(x) => x,
							Err(e) => {
								let info = format!("history: error: {:?}", e);
								result_stderr.push_str(&info);
								return (result_stdout, result_stderr);
							}
						};
						let inp: String = match row.get(1) {
							Ok(x) => x,
							Err(e) => {
								let info = format!("history: error: {:?}", e);
								result_stderr.push_str(&info);
								return (result_stdout, result_stderr);
							}
						};

						if opt.no_id {
							lines.push(inp.to_string());
						} else if opt.only_id {
							lines.push(row_id.to_string());
						} else if opt.show_date {
							let tsb: f64 = match row.get(2) {
								Ok(x) => x,
								Err(e) => {
									let info = format!("history: error: {:?}", e);
									result_stderr.push_str(&info);
									return (result_stdout, result_stderr);
								}
							};
							let dt = ctime::DateTime::from_timestamp(tsb);
							lines.push(format!("{}: {}: {}", row_id, dt, inp));
						} else {
							lines.push(format!("{}: {}", row_id, inp));
						}
					} else {
						break;
					}
				}
				Err(e) => {
					let info = format!("history: rows next error: {:?}", e);
					result_stderr.push_str(&info);
					return (result_stdout, result_stderr);
				}
			}
		}

		if !opt.asc {
			lines.reverse();
		}

		let buffer = lines.join("\n");

		(buffer, result_stderr)
	}

	fn delete_history_item(conn: &Conn, rowid: usize) -> bool
    {
		let history_table = history::get_history_table();
		let sql = format!("DELETE from {} where rowid = {}", history_table, rowid);
		match conn.execute(&sql, [])
        {
			Ok(_) => true,
			Err(e) => {
				log!("history: error when delete: {:?}", e);
				false
			}
		}
	}
	
	fn show_alias_list(
		sh: &shell::Shell,
		cmd: &Command,
		cl: &CommandLine,
		capture: bool,
	) -> CommandResult
    {
		let mut lines = Vec::new();
		for (name, value) in sh.get_alias_list()
        {
			let line = format!("alias {}='{}'", name, value);
			lines.push(line);
		}
		let buffer = lines.join("\n");
		let mut cr = CommandResult::new();
		print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
		cr
	}

	fn show_single_alias(
		sh: &shell::Shell,
		name_to_find: &str,
		cmd: &Command,
		cl: &CommandLine,
		capture: bool,
	) -> CommandResult
    {
		let mut cr = CommandResult::new();
		if let Some(content) = sh.get_alias_content(name_to_find)
        {
			let info = format!("alias {}='{}'", name_to_find, content);
			print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
		} else {
			let info = format!("cicada: alias: {}: not found", name_to_find);
			print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
		}
		cr
	}

}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod cmp
{
	pub use std::cmp::{ * };
}

pub mod collections
{
	pub use std::collections::{ * };
}

pub mod completers
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use std::path::Path;
	use std::sync::Arc;

	use lineread::complete::{Completer, Completion};
	use lineread::prompter::Prompter;
	use lineread::terminal::Terminal;
	
	use crate::libs;
	use crate::parsers;
	use crate::shell;
	use crate::tools;
	*/
	pub mod dots
	{
		use ::
		{
			*,
		};
		/*
		use std::borrow::Cow;
		use std::fs::File;
		use std::io::{Read, Write};
		use std::path::Path;

		use lineread::complete::escape;
		use lineread::complete::escaped_word_start;
		use lineread::complete::unescape;
		use lineread::complete::Suffix;
		use lineread::complete::{Completer, Completion};
		use lineread::prompter::Prompter;
		use lineread::terminal::Terminal;
		use yaml_rust::yaml::Hash;
		use yaml_rust::{Yaml, YamlLoader};

		use ::now;
		use crate::parsers;
		use crate::tools;

		*/
		/// Performs completion by searching dotfiles
		pub struct DotsCompleter;

		impl<Term: Terminal> Completer<Term> for DotsCompleter {
			fn complete(
				&self,
				word: &str,
				reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				let line = reader.buffer();
				Some(complete_dots(line, word))
			}

			fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
				escaped_word_start(&line[..end])
			}

			fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
				escape(word)
			}

			fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
				unescape(word)
			}
		}

		fn get_dot_file(line: &str) -> (String, String)
        {
			let args = parsers::line::line_to_plain_tokens(line);
			let dir = tools::get_user_completer_dir();
			let dot_file = format!("{}/{}.yaml", dir, args[0]);
			if !Path::new(&dot_file).exists() {
				return (String::new(), String::new());
			}
			let sub_cmd = if (args.len() >= 3 && !args[1].starts_with('-'))
				|| (args.len() >= 2 && !args[1].starts_with('-') && line.ends_with(' '))
			{
				args[1].as_str()
			} else {
				""
			};

			(dot_file, sub_cmd.to_string())
		}

		fn handle_lv1_string(res: &mut Vec<Completion>, value: &str, word: &str) {
			if !value.starts_with(word) && !value.starts_with('`') {
				return;
			}

			let linfo = parsers::line::parse_line(value);
			let tokens = linfo.tokens;
			if tokens.len() == 1 && tokens[0].0 == "`" {
				log!("run subcmd: {:?}", &tokens[0].1);
				let cr = execute::run(&tokens[0].1);
				let v: Vec<&str> = cr.stdout.split_whitespace().collect();
				for s in v {
					if s.trim().is_empty() {
						continue;
					}
					handle_lv1_string(res, s, word);
				}
				return;
			}

			let display = None;
			let suffix = Suffix::Default;
			res.push(Completion {
				completion: value.to_string(),
				display,
				suffix,
			});
		}

		fn handle_lv1_hash(res: &mut Vec<Completion>, h: &Hash, word: &str)
        {
			for v in h.values() {
				if let Yaml::Array(ref arr) = v {
					for s in arr {
						if let Yaml::String(value) = s {
							if !value.starts_with(word) && !value.starts_with('`') {
								continue;
							}
							handle_lv1_string(res, value, word);
						}
					}
				}
			}
		}

		fn complete_dots(line: &str, word: &str) -> Vec<Completion>
        {
			let mut res = Vec::new();
			if line.trim().is_empty() {
				return res;
			}
			let (dot_file, sub_cmd) = get_dot_file(line);
			if dot_file.is_empty() {
				return res;
			}

			let mut f;
			match File::open(&dot_file)
            {
				Ok(x) => f = x,
				Err(e) => {
					println_stderr!("\ncicada: open dot_file error: {:?}", e);
					return res;
				}
			}

			let mut s = String::new();
			match f.read_to_string(&mut s)
            {
				Ok(_) => {}
				Err(e) => {
					println_stderr!("\ncicada: read_to_string error: {:?}", e);
					return res;
				}
			}

			let docs = match YamlLoader::load_from_str(&s)
            {
				Ok(x) => x,
				Err(e) => {
					println_stderr!("\ncicada: Bad Yaml file: {}: {:?}", dot_file, e);
					return res;
				}
			};

			for doc in docs.iter() {
				match *doc {
					Yaml::Array(ref v) => {
						for x in v {
							match *x {
								Yaml::String(ref name) => {
									if !sub_cmd.is_empty() {
										continue;
									}
									handle_lv1_string(&mut res, name, word);
								}
								Yaml::Hash(ref h) => {
									if sub_cmd.is_empty() {
										for k in h.keys() {
											if let Yaml::String(value) = k {
												handle_lv1_string(&mut res, value, word);
											}
										}
									} else {
										let key = Yaml::from_str(&sub_cmd);
										if !h.contains_key(&key) {
											continue;
										}
										handle_lv1_hash(&mut res, h, word);
									}
								}
								_ => {
									println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
								}
							}
						}
					}
					_ => {
						println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
					}
				}
			}
			res
		}
		
	}
	
	pub mod env
	{
		use ::
		{
			*,
		};
		/*
		use std::env;
		use std::sync::Arc;

		use lineread::complete::{Completer, Completion, Suffix};
		use lineread::prompter::Prompter;
		use lineread::terminal::Terminal;

		use crate::shell;
		*/
		pub struct EnvCompleter {
			pub sh: Arc<shell::Shell>,
		}

		impl<Term: Terminal> Completer<Term> for EnvCompleter {
			fn complete(
				&self,
				word: &str,
				_reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				let sh = Arc::try_unwrap(self.sh.clone());
				match sh {
					Ok(x) => Some(complete_env(&x, word)),
					Err(x) => Some(complete_env(&x, word)),
				}
			}
		}

		fn complete_env(sh: &shell::Shell, path: &str) -> Vec<Completion>
        {
			let mut res = Vec::new();
			if path.trim().is_empty() {
				return res;
			}
			let mut prefix = path.to_string();
			prefix.remove(0);

			for (key, _) in env::vars_os() {
				let env_name = key.to_string_lossy().to_string();
				if env_name.starts_with(&prefix) {
					res.push(Completion {
						completion: format!("${}", env_name),
						display: None,
						suffix: Suffix::Default,
					});
				}
			}

			// sh.envs is a just clone here; see FIXME in main.rs
			for key in sh.envs.keys() {
				if key.starts_with(&prefix) {
					res.push(Completion {
						completion: format!("${}", key),
						display: None,
						suffix: Suffix::Default,
					});
				}
			}

			res
		}

	}
	
	pub mod make
	{
		use ::
		{
			*,
		};
		/*
		use std::env;
		use std::fs::File;
		use std::io::{BufRead, BufReader, Write};

		use regex::Regex;

		use lineread::complete::{Completer, Completion, Suffix};
		use lineread::prompter::Prompter;
		use lineread::terminal::Terminal;
		*/
		pub struct MakeCompleter;

		impl<Term: Terminal> Completer<Term> for MakeCompleter {
			fn complete(
				&self,
				word: &str,
				_reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				Some(complete_make(word))
			}
		}

		fn handle_file(ci: &mut Vec<Completion>, path: &str, file_path: &str, current_dir: &str) {
			if let Ok(f) = File::open(file_path) {
				let file = BufReader::new(&f);
				let re_cmd = match Regex::new(r"^ *([^ ]+):") {
					Ok(x) => x,
					Err(e) => {
						println_stderr!("cicada: regex build error: {:?}", e);
						return;
					}
				};

				let re_include = match Regex::new(r"^ *include  *([^ ]+) *$") {
					Ok(x) => x,
					Err(e) => {
						println_stderr!("cicada: regex build error: {:?}", e);
						return;
					}
				};

				for line in file.lines().map_while(Result::ok) {
					if re_cmd.is_match(&line) {
						for cap in re_cmd.captures_iter(&line) {
							if !cap[1].starts_with(path) {
								continue;
							}
							ci.push(Completion {
								completion: cap[1].to_string(),
								display: None,
								suffix: Suffix::Default,
							});
						}
					}
					if re_include.is_match(&line) {
						for cap in re_include.captures_iter(&line) {
							let _file = &cap[1];
							if _file.contains('/') {
								handle_file(ci, path, _file, current_dir);
							} else {
								let make_file = current_dir.to_owned() + "/" + _file;
								handle_file(ci, path, &make_file, current_dir);
							}
						}
					}
				}
			}
		}

		fn complete_make(path: &str) -> Vec<Completion>
        {
			let mut res = Vec::new();
			let current_dir = match env::current_dir()
            {
				Ok(dir) => match dir.to_str() {
					Some(s) => s.to_string(),
					None => {
						println!("cicada: to_str error");
						return res;
					}
				},
				Err(e) => {
					println!("cicada: get current_dir error: {:?}", e);
					return res;
				}
			};

			let make_file = format!("{}/Makefile", current_dir);
			handle_file(&mut res, path, &make_file, &current_dir);
			res
		}

		
	}
	
	pub mod path
	{
		use ::
		{
			*,
		};
		/*
		use std::collections::HashSet;
		use std::env;
		use std::fs::read_dir;
		use std::io::Write;
		use std::iter::FromIterator;
		use std::os::unix::fs::PermissionsExt;
		use std::path::MAIN_SEPARATOR;
		use std::sync::Arc;

		use lineread::complete::{Completer, Completion, Suffix};
		use lineread::terminal::Terminal;
		use lineread::Prompter;

		use crate::completers::utils;
		use crate::libs;
		use crate::parsers;
		use crate::shell;
		use crate::tools;
		*/
		pub struct BinCompleter {
			pub sh: Arc<shell::Shell>,
		}
		pub struct CdCompleter;
		pub struct PathCompleter;

		impl<Term: Terminal> Completer<Term> for BinCompleter {
			fn complete(
				&self,
				word: &str,
				_reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				let sh = Arc::try_unwrap(self.sh.clone());
				match sh {
					Ok(x) => Some(complete_bin(&x, word)),
					Err(x) => Some(complete_bin(&x, word)),
				}
			}
		}

		impl<Term: Terminal> Completer<Term> for PathCompleter {
			fn complete(
				&self,
				word: &str,
				_reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				Some(complete_path(word, false))
			}
		}

		impl<Term: Terminal> Completer<Term> for CdCompleter {
			fn complete(
				&self,
				word: &str,
				_reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				Some(complete_path(word, true))
			}
		}

		fn needs_expand_home(line: &str) -> bool {
			::regex::contains(line, r"( +~ +)|( +~/)|(^ *~/)|( +~ *$)")
		}
		/// Returns a sorted list of paths whose prefix matches the given path.
		pub fn complete_path(word: &str, for_dir: bool) -> Vec<Completion>
        {
			let is_env = is_env_prefix(word);
			let mut res = Vec::new();
			let linfo = parsers::line::parse_line(word);
			let tokens = linfo.tokens;
			let (path, path_sep) = if tokens.is_empty() {
				(String::new(), String::new())
			} else {
				let (ref _path_sep, ref _path) = tokens[tokens.len() - 1];
				(_path.clone(), _path_sep.clone())
			};

			let (_, _dir_orig, _f) = split_pathname(&path, "");
			let dir_orig = if _dir_orig.is_empty() {
				String::new()
			} else {
				_dir_orig.clone()
			};
			let mut path_extended = path.clone();
			if needs_expand_home(&path_extended) {
				utils::expand_home_string(&mut path_extended)
			}
			utils::expand_env_string(&mut path_extended);

			let (_, _dir_lookup, file_name) = split_pathname(&path_extended, "");
			let dir_lookup = if _dir_lookup.is_empty() {
				".".to_string()
			} else {
				_dir_lookup.clone()
			};
			// let dir_lookup = _dir_lookup.unwrap_or(".");
			if let Ok(entries) = read_dir(dir_lookup) {
				for entry in entries.flatten() {
					let pathbuf = entry.path();
					let is_dir = pathbuf.is_dir();
					if for_dir && !is_dir {
						continue;
					}

					let entry_name = entry.file_name();
					// TODO: Deal with non-UTF8 paths in some way
					if let Ok(_path) = entry_name.into_string() {
						if _path.starts_with(&file_name) {
							let (name, display) = if !dir_orig.is_empty() {
								(
									format!("{}{}{}", dir_orig, MAIN_SEPARATOR, _path),
									Some(_path),
								)
							} else {
								(_path, None)
							};
							let mut name = str::replace(name.as_str(), "//", "/");
							if path_sep.is_empty() && !is_env {
								name = tools::escape_path(&name);
							}
							let mut quoted = false;
							if !path_sep.is_empty() {
								name = tools::wrap_sep_string(&path_sep, &name);
								quoted = true;
							}
							let suffix = if is_dir {
								if quoted {
									name.pop();
								}
								Suffix::Some(MAIN_SEPARATOR)
							} else {
								Suffix::Default
							};
							res.push(Completion {
								completion: name,
								display,
								suffix,
							});
						}
					}
				}
			}
			res.sort_by(|a, b| a.completion.cmp(&b.completion));
			res
		}

		// Split optional directory and prefix. (see its test cases for more details)
		fn split_pathname(path: &str, prefix: &str) -> (String, String, String) {
			if is_pipelined(path) {
				let tokens: Vec<&str> = path.rsplitn(2, '|').collect();
				let prefix = format!("{}|", tokens[1]);
				return split_pathname(tokens[0], &prefix);
			}
			match path.rfind('/') {
				Some(pos) => (
					prefix.to_string(),
					path[..=pos].to_string(),
					path[pos + 1..].to_string(),
				),
				None => (prefix.to_string(), String::new(), path.to_string()),
			}
		}
		/// Returns a sorted list of paths whose prefix matches the given path.
		fn complete_bin(sh: &shell::Shell, path: &str) -> Vec<Completion>
        {
			let mut res = Vec::new();
			let (prefix, _, fname) = split_pathname(path, "");
			let env_path = match env::var("PATH")
            {
				Ok(x) => x,
				Err(e) => {
					println_stderr!("cicada: env error when complete_bin: {:?}", e);
					return res;
				}
			};

			let mut checker: HashSet<String> = HashSet::new();

			// handle alias, builtins, and functions
			for func in sh.funcs.keys() {
				if !func.starts_with(&fname) {
					continue;
				}
				if checker.contains(func) {
					continue;
				}
				checker.insert(func.clone());
				res.push(Completion {
					completion: func.to_owned(),
					display: None,
					suffix: Suffix::Default,
				});
			}
			for alias in sh.aliases.keys() {
				if !alias.starts_with(&fname) {
					continue;
				}
				if checker.contains(alias) {
					continue;
				}
				checker.insert(alias.clone());
				res.push(Completion {
					completion: alias.to_owned(),
					display: None,
					suffix: Suffix::Default,
				});
			}

			let builtins = vec![
				"alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg", "history", "jobs", "read",
				"source", "ulimit", "unalias", "vox", "minfd", "set", "unset", "unpath",
			];
			for item in &builtins {
				if !item.starts_with(&fname) {
					continue;
				}
				if checker.contains(*item) {
					continue;
				}
				checker.insert(item.to_string());
				res.push(Completion {
					completion: item.to_string(),
					display: None,
					suffix: Suffix::Default,
				});
			}

			let vec_path: Vec<&str> = env_path.split(':').collect();
			let path_list: HashSet<&str> = HashSet::from_iter(vec_path.iter().cloned());

			for p in &path_list {
				if let Ok(list) = read_dir(p) {
					for entry in list.flatten() {
						if let Ok(name) = entry.file_name().into_string() {
							if name.starts_with(&fname) {
								let _mode = match entry.metadata() {
									Ok(x) => x,
									Err(e) => {
										println_stderr!("cicada: metadata error: {:?}", e);
										continue;
									}
								};
								let mode = _mode.permissions().mode();
								if mode & 0o111 == 0 {
									// not binary
									continue;
								}
								if checker.contains(&name) {
									continue;
								}

								let display = None;
								let suffix = Suffix::Default;
								checker.insert(name.clone());
								// TODO: need to handle quoted: `$ "foo#bar"`
								let name_e = tools::escape_path(&name);
								let name_e = format!("{}{}", prefix, name_e);
								res.push(Completion {
									completion: name_e,
									display,
									suffix,
								});
							}
						}
					}
				}
			}
			res
		}
	}
	
	pub mod ssh
	{
		use ::
		{
			*,
		};
		/*
		use std::fs::File;
		use std::io::{BufRead, BufReader};

		use regex::Regex;

		use lineread::complete::{Completer, Completion, Suffix};
		use lineread::terminal::Terminal;
		use lineread::Prompter;

		use crate::tools;
		*/
		pub struct SshCompleter;

		impl<Term: Terminal> Completer<Term> for SshCompleter {
			fn complete(
				&self,
				word: &str,
				_reader: &Prompter<Term>,
				_start: usize,
				_end: usize,
			) -> Option<Vec<Completion>> {
				Some(complete_ssh(word))
			}
		}

		fn complete_ssh(path: &str) -> Vec<Completion>
        {
			let mut res = Vec::new();
			let home = tools::get_user_home();
			let ssh_config = home + "/.ssh/config";
			if let Ok(f) = File::open(&ssh_config) {
				let file = BufReader::new(&f);
				let re = match Regex::new(r"^ *(?i)host +([^ ]+)") {
					Ok(x) => x,
					Err(e) => {
						println!("Regex build error: {:?}", e);
						return res;
					}
				};
				for line in file.lines().map_while(Result::ok) {
					if !re.is_match(&line) {
						continue;
					}
					for cap in re.captures_iter(&line) {
						if !cap[1].starts_with(path) {
							continue;
						}
						res.push(Completion {
							completion: cap[1].to_string(),
							display: None,
							suffix: Suffix::Default,
						});
					}
				}
			}
			res
		}

	}
	
	pub mod utils
	{
		use ::
		{
			*,
		};
		/*
		use regex::Regex;
		use std::env;

		use crate::libs;
		use crate::tools;
		*/
		pub fn expand_home_string(text: &mut String)
		{
			let v = vec![
				r"(?P<head> +)~(?P<tail> +)",
				r"(?P<head> +)~(?P<tail>/)",
				r"^(?P<head> *)~(?P<tail>/)",
				r"(?P<head> +)~(?P<tail> *$)",
			];
			for item in &v {
				let re;
				if let Ok(x) = Regex::new(item) {
					re = x;
				} else {
					return;
				}
				let home = tools::get_user_home();
				let ss = text.clone();
				let to = format!("$head{}$tail", home);
				let result = re.replace_all(ss.as_str(), to.as_str());
				*text = result.to_string();
			}
		}

		pub fn expand_env_string(text: &mut String) {
			// expand "$HOME/.local/share" to "/home/tom/.local/share"
			if !text.starts_with('$') {
				return;
			}
			let ptn = r"^\$([A-Za-z_][A-Za-z0-9_]*)";
			let mut env_value = String::new();
			match libs::re::find_first_group(ptn, text) {
				Some(x) => {
					if let Ok(val) = env::var(&x) {
						env_value = val;
					}
				}
				None => {
					return;
				}
			}

			if env_value.is_empty() {
				return;
			}
			let t = text.clone();
			*text = libs::re::replace_all(&t, ptn, &env_value);
		}
	}
	
	pub struct CicadaCompleter {
		pub sh: Arc<shell::Shell>,
	}

	fn for_make(line: &str) -> bool {
		::regex::contains(line, r"^ *make ")
	}

	fn for_env(line: &str) -> bool {
		::regex::contains(line, r" *\$[_a-zA-Z0-9]*$")
	}

	fn for_ssh(line: &str) -> bool {
		::regex::contains(line, r"^ *(ssh|scp).* +[^ \./]+ *$")
	}

	fn for_cd(line: &str) -> bool {
		::regex::contains(line, r"^ *cd +")
	}

	fn for_bin(line: &str) -> bool
    {
		let ptn = r"(^ *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)|(^.+\| *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)";
		::regex::contains(line, ptn)
	}

	fn for_dots(line: &str) -> bool
    {
		let args = parsers::line::line_to_plain_tokens(line);
		let len = args.len();
		if len == 0 {
			return false;
		}
		let dir = tools::get_user_completer_dir();
		let dot_file = format!("{}/{}.yaml", dir, args[0]);
		Path::new(dot_file.as_str()).exists()
	}

	impl<Term: Terminal> Completer<Term> for CicadaCompleter {
		fn complete(
			&self,
			word: &str,
			reader: &Prompter<Term>,
			start: usize,
			_end: usize,
		) -> Option<Vec<Completion>>
        {
			let line = reader.buffer();

			let completions: Option<Vec<Completion>>;
			if for_dots(line) {
				let cpl = Arc::new(dots::DotsCompleter);
				completions = cpl.complete(word, reader, start, _end);
			} else if for_ssh(line) {
				let cpl = Arc::new(ssh::SshCompleter);
				completions = cpl.complete(word, reader, start, _end);
			} else if for_make(line) {
				let cpl = Arc::new(make::MakeCompleter);
				completions = cpl.complete(word, reader, start, _end);
			} else if for_bin(line) {
				let cpl = Arc::new(path::BinCompleter {
					sh: self.sh.clone(),
				});
				completions = cpl.complete(word, reader, start, _end);
			} else if for_env(line) {
				let cpl = Arc::new(env::EnvCompleter {
					sh: self.sh.clone(),
				});
				completions = cpl.complete(word, reader, start, _end);
			} else if for_cd(line) {
				// `for_cd` should be put a bottom position, so that
				// `cd $SOME_ENV_<TAB>` works as expected.
				let cpl = Arc::new(path::CdCompleter);
				// completions for `cd` should not fail back to path-completion
				return cpl.complete(word, reader, start, _end);
			} else {
				completions = None;
			}

			if let Some(x) = completions {
				if !x.is_empty() {
					return Some(x);
				}
			}

			// empty completions should fail back to path-completion,
			// so that `$ make generate /path/to/fi<Tab>` still works.
			let cpl = Arc::new(path::PathCompleter);
			cpl.complete(word, reader, start, _end)
		}

		fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
			escaped_word_start(&line[..end])
		}
	}

	pub fn escaped_word_start(line: &str) -> usize
    {
		let mut start_position: usize = 0;
		let mut found_bs = false;
		let mut found_space = false;
		let mut with_quote = false;
		let mut ch_quote = '\0';
		let mut extra_bytes = 0;
		for (i, c) in line.chars().enumerate() {
			if found_space {
				found_space = false;
				start_position = i + extra_bytes;
			}

			if c == '\\' {
				found_bs = true;
				continue;
			}
			if c == ' ' && !found_bs && !with_quote {
				found_space = true;
				continue;
			}

			if !with_quote && !found_bs && (c == '"' || c == '\'') {
				with_quote = true;
				ch_quote = c;
			} else if with_quote && !found_bs && ch_quote == c {
				with_quote = false;
			}

			let bytes_c = c.len_utf8();
			if bytes_c > 1 {
				extra_bytes += bytes_c - 1;
			}
			found_bs = false;
		}
		if found_space {
			start_position = line.len();
		}
		start_position
	}
}

pub mod env
{
	pub use std::env::{ * };
    /*
    pub fn init_path_env() */
	pub fn initialize()
    {
		let mut paths: Vec<String> = vec![];
		for x in
        [
			"/usr/local/sbin",
			"/usr/local/bin",
			"/usr/sbin",
			"/usr/bin",
			"/sbin",
			"/bin",
		]
        { 
            if Path::new(x).exists() { paths.push(x.to_string()); }
        }

		if let Ok(env_path) = var("PATH")
        {
			for x in env_path.split(":")
            {
				if !paths.contains(&x.to_string()) { paths.push(x.to_string()); }
			}
		}
		
        let paths = paths.join(":");
		set_var("PATH", paths);
	}
}

pub mod fmt
{
	pub use std::fmt::{ * };
}

pub mod fs
{
	pub use std::fs::{ * };
}

pub mod error
{
	pub use std::error::{ * };
}

pub mod extend
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
}

pub mod get
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
}

pub mod highlight
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use std::collections::HashSet;
	use std::env;
	use std::fs;
	use std::ops::Range;
	use std::os::unix::fs::PermissionsExt;
	use std::path::Path;
	use std::sync::Arc;
	use std::sync::Mutex;

	use lineread::highlighting::{Highlighter, Style};

	use crate::parsers::parser_line;
	use crate::shell;
	use crate::tools;
	*/
	#[derive(Clone)]
	pub struct CicadaHighlighter;

	// ANSI color codes wrapped with \x01 and \x02 for lineread
	const GREEN: &str = "\x01\x1b[0;32m\x02";

	lazy_static! {
		static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
		static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
	}

	/// Initialize the available commands cache by scanning PATH directories
	pub fn init_command_cache()
    {
		let commands = scan_available_commands();
		if let Ok(mut cache) = AVAILABLE_COMMANDS.lock() {
			*cache = commands;
		}
	}

	/// Update aliases in the highlighter's cache
	pub fn update_aliases(sh: &shell::Shell)
    {
		if let Ok(mut aliases) = ALIASES.lock() {
			aliases.clear();
			for alias_name in sh.aliases.keys() {
				aliases.insert(alias_name.clone());
			}
		}
	}

	fn scan_available_commands() -> HashSet<String>
    {
		let mut commands = HashSet::new();

		if let Ok(path_var) = env::var("PATH")
        {
			for path in path_var.split(':') {
				if path.is_empty() {
					continue;
				}

				let dir_path = Path::new(path);
				if !dir_path.is_dir() {
					continue;
				}

				if let Ok(entries) = fs::read_dir(dir_path) {
					for entry in entries.filter_map(Result::ok) {
						if let Ok(file_type) = entry.file_type() {
							if file_type.is_file() || file_type.is_symlink() {
								if let Ok(metadata) = entry.metadata() {
									// Check if file is executable
									if metadata.permissions().mode() & 0o111 != 0 {
										if let Some(name) = entry.file_name().to_str() {
											commands.insert(name.to_string());
										}
									}
								}
							}
						}
					}
				}
			}
		}

		commands
	}

	fn find_token_range_heuristic(
		line: &str,
		start_byte: usize,
		token: &(String, String),
	) -> Option<Range<usize>>
    {
		let (sep, word) = token;

		// Find the start of the token, skipping leading whitespace from the search start position
		let mut search_area = &line[start_byte..];
		let token_start_byte =
			if let Some(non_ws_offset) = search_area.find(|c: char| !c.is_whitespace()) {
				// Calculate the actual byte index of the first non-whitespace character
				start_byte
					+ search_area
						.char_indices()
						.nth(non_ws_offset)
						.map_or(0, |(idx, _)| idx)
			} else {
				return None; // Only whitespace left
			};

		search_area = &line[token_start_byte..];

		// Estimate the end byte based on the token structure
		let mut estimated_len = 0;
		let mut current_search_offset = 0;

		// Match separator prefix if needed (e.g., `"` or `'`)
		if !sep.is_empty() && search_area.starts_with(sep) {
			estimated_len += sep.len();
			current_search_offset += sep.len();
		}

		// Match the word content
		// Use starts_with for a basic check, assuming the word appears next
		if search_area[current_search_offset..].starts_with(word) {
			estimated_len += word.len();
			current_search_offset += word.len();

			// Match separator suffix if needed
			if !sep.is_empty() && search_area[current_search_offset..].starts_with(sep) {
				estimated_len += sep.len();
			}

			Some(token_start_byte..(token_start_byte + estimated_len))
		} else if word.is_empty()
			&& !sep.is_empty()
			&& search_area.starts_with(sep)
			&& search_area[sep.len()..].starts_with(sep)
		{
			// Handle empty quoted string like "" or ''
			estimated_len += sep.len() * 2;
			Some(token_start_byte..(token_start_byte + estimated_len))
		} else {
			// Fallback: Maybe it's just the word without quotes, or a separator like `|`
			if search_area.starts_with(word) {
				Some(token_start_byte..(token_start_byte + word.len()))
			} else {
				// Could not reliably map the token back to the original string segment
				// This might happen with complex escapes or parser ambiguities
				// As a basic fallback, consume up to the next space or end of line? Unsafe.
				// Return None to signal failure for this token.
				None
			}
		}
	}

	impl Highlighter for CicadaHighlighter {
		fn highlight(&self, line: &str) -> Vec<(Range<usize>, Style)>
        {
			let mut styles = Vec::new();
			if line.is_empty() {
				return styles;
			}

			let line_info = parser_line::parse_line(line);
			if line_info.tokens.is_empty() {
				// If parser returns no tokens, style whole line as default
				styles.push((0..line.len(), Style::Default));
				return styles;
			}

			let mut current_byte_idx = 0;
			let mut is_start_of_segment = true;

			for token in &line_info.tokens {
				// Find the range in the original line for this token
				match find_token_range_heuristic(line, current_byte_idx, token) {
					Some(token_range) => {
						// Style potential whitespace before the token
						if token_range.start > current_byte_idx {
							styles.push((current_byte_idx..token_range.start, Style::Default));
						}

						let (_sep, word) = token;
						let mut current_token_style = Style::Default;

						if is_start_of_segment && !word.is_empty() {
							if is_command(word) {
								current_token_style = Style::AnsiColor(GREEN.to_string());
							}
							// Only the first non-empty token in a segment can be a command
							is_start_of_segment = false;
						}

						styles.push((token_range.clone(), current_token_style));

						// Check if this token marks the end of a command segment
						if ["|", "&&", "||", ";"].contains(&word.as_str()) {
							is_start_of_segment = true;
						}

						current_byte_idx = token_range.end;
					}
					None => {
						// If we can't map a token, style the rest of the line as default and stop.
						if current_byte_idx < line.len() {
							styles.push((current_byte_idx..line.len(), Style::Default));
						}
						current_byte_idx = line.len(); // Mark as done
						break; // Stop processing further tokens
					}
				}
			}

			// Style any remaining characters after the last processed token
			if current_byte_idx < line.len() {
				styles.push((current_byte_idx..line.len(), Style::Default));
			}

			styles
		}
	}

	pub fn create_highlighter() -> Arc<CicadaHighlighter> {
		Arc::new(CicadaHighlighter)
	}

}

pub mod history
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use std::collections::HashMap;
	use std::env;
	use std::fs;
	use std::io::Write;
	use std::path::Path;

	use lineread::terminal::DefaultTerminal;
	use lineread::Interface;
	use rusqlite::Connection as Conn;
	use rusqlite::Error::SqliteFailure;

	use crate::shell;
	use crate::tools;
	*/
	fn init_db(hfile: &str, htable: &str)
    {
		let path = Path::new(hfile);
		if !path.exists()
        {
			let _parent = match path.parent() {
				Some(x) => x,
				None => {
					println_stderr!("cicada: history init - no parent found");
					return;
				}
			};
			let parent = match _parent.to_str() {
				Some(x) => x,
				None => {
					println_stderr!("cicada: parent to_str is None");
					return;
				}
			};
			match fs::create_dir_all(parent)
            {
				Ok(_) => {}
				Err(e) => {
					println_stderr!("cicada: histdir create error: {}", e);
					return;
				}
			}
			match fs::File::create(hfile)
            {
				Ok(_) => {
					println!("cicada: created history file: {}", hfile);
				}
				Err(e) => {
					println_stderr!("cicada: history: file create failed: {}", e);
				}
			}
		}

		let conn = match Conn::open(hfile)
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: history: open db error: {}", e);
				return;
			}
		};
		let sql = format!(
			"
			CREATE TABLE IF NOT EXISTS {}
				(inp TEXT,
				 rtn INTEGER,
				 tsb REAL,
				 tse REAL,
				 sessionid TEXT,
				 out TEXT,
				 info TEXT
				);
		",
			htable
		);
		match conn.execute(&sql, [])
        {
			Ok(_) => {}
			Err(e) => println_stderr!("cicada: history: query error: {}", e),
		}
	}

	pub fn init(rl: &mut Interface<DefaultTerminal>)
    {
		let mut hist_size: usize = 99999;
		if let Ok(x) = env::var("HISTORY_SIZE") {
			if let Ok(y) = x.parse::<usize>() {
				hist_size = y;
			}
		}
		rl.set_history_size(hist_size);

		let history_table = get_history_table();
		let hfile = get_history_file();

		if !Path::new(&hfile).exists() {
			init_db(&hfile, &history_table);
		}

		let mut delete_dups = true;
		if let Ok(x) = env::var("HISTORY_DELETE_DUPS") {
			if x == "0" {
				delete_dups = false;
			}
		}
		if delete_dups {
			delete_duplicated_histories();
		}

		let conn = match Conn::open(&hfile)
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: history: conn error: {}", e);
				return;
			}
		};
		let sql = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
		let mut stmt = match conn.prepare(&sql)
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: prepare select error: {}", e);
				return;
			}
		};

		let rows = match stmt.query_map([], |row| row.get(0))
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: query select error: {}", e);
				return;
			}
		};

		let mut dict_helper: HashMap<String, bool> = HashMap::new();
		for x in rows.flatten()
        {
			let inp: String = x;
			if dict_helper.contains_key(&inp) {
				continue;
			}
			dict_helper.insert(inp.clone(), true);
			rl.add_history(inp.trim().to_string());
		}
	}

	pub fn get_history_file() -> String
    {
		if let Ok(hfile) = env::var("HISTORY_FILE") {
			hfile
		} else if let Ok(d) = env::var("XDG_DATA_HOME") {
			format!("{}/{}", d, "cicada/history.sqlite")
		} else {
			let home = tools::get_user_home();
			format!("{}/{}", home, ".local/share/cicada/history.sqlite")
		}
	}

	pub fn get_history_table() -> String
    {
		if let Ok(hfile) = env::var("HISTORY_TABLE") {
			hfile
		} else {
			String::from("cicada_history")
		}
	}

	fn delete_duplicated_histories()
    {
		let hfile = get_history_file();
		let history_table = get_history_table();
		let conn = match Conn::open(&hfile)
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: history: conn error: {}", e);
				return;
			}
		};
		let sql = format!(
			"DELETE FROM {} WHERE rowid NOT IN (
			SELECT MAX(rowid) FROM {} GROUP BY inp)",
			history_table, history_table
		);
		match conn.execute(&sql, [])
        {
			Ok(_) => {}
			Err(e) => match e {
				SqliteFailure(ee, msg) => {
					if ee.extended_code == 5 {
						log!(
							"failed to delete dup histories: {}",
							msg.unwrap_or("db is locked?".to_owned()),
						);
						return;
					}
					println_stderr!("cicada: history: delete dups error: {}: {:?}", &ee, &msg);
				}
				_ => {
					println_stderr!("cicada: history: delete dup error: {}", e);
				}
			},
		}
	}

	pub fn add_raw(sh: &shell::Shell, line: &str, status: i32, tsb: f64, tse: f64)
    {
		let hfile = get_history_file();
		let history_table = get_history_table();
		if !Path::new(&hfile).exists() {
			init_db(&hfile, &history_table);
		}

		let conn = match Conn::open(&hfile)
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: history: conn error: {}", e);
				return;
			}
		};
		let sql = format!(
			"INSERT INTO \
			 {} (inp, rtn, tsb, tse, sessionid, info) \
			 VALUES('{}', {}, {}, {}, '{}', 'dir:{}|');",
			history_table,
			str::replace(line.trim(), "'", "''"),
			status,
			tsb,
			tse,
			sh.session_id,
			sh.current_dir,
		);
		match conn.execute(&sql, [])
        {
			Ok(_) => {}
			Err(e) => println_stderr!("cicada: history: save error: {}", e),
		}
	}

	pub fn add(
		sh: &shell::Shell,
		rl: &mut Interface<DefaultTerminal>,
		line: &str,
		status: i32,
		tsb: f64,
		tse: f64,
	) {
		add_raw(sh, line, status, tsb, tse);
		rl.add_history(line.to_string());
	}

}

pub mod io
{
	pub use std::io::{ * };
}

pub mod is
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
	// pub fn is_env_prefix(line: &str) -> bool
	pub fn env_prefix(line: &str) -> bool
	{
		::regex::contains(line, r" *\$[a-zA-Z_][A-Za-z0-9_]*")
	}
	// pub fn is_pipelined(path: &str) -> bool
	pub fn pipelined(path: &str) -> bool
	{
		if !path.contains('|') { return false; }
		
		!path.starts_with('"') && !path.starts_with('\'')
	}
	// pub fn is_shell_altering_command(line: &str) -> bool 
	pub fn shell_altering_command(line: &str) -> bool 
	{
		let line = line.trim();
		
		if ::regex::contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") { return true; }
		
		line.starts_with("alias ")
		|| line.starts_with("export ")
		|| line.starts_with("unalias ")
		|| line.starts_with("unset ")
		|| line.starts_with("source ")
	}
	// pub fn is_builtin(s: &str) -> bool
	pub fn builtin(s: &str) -> bool
	{
		let builtins = [
			"alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg", "history", "jobs", "read",
			"source", "ulimit", "unalias", "vox", "minfd", "set", "unset", "unpath",
		];
		builtins.contains(&s)
	}
	// pub fn is_arithmetic(line: &str) -> bool
	pub fn arithmetic(line: &str) -> bool
	{
		if !::regex::contains(line, r"[0-9]+") { return false; }
		
		if !::regex::contains(line, r"\+|\-|\*|/|\^") { return false; }
		
		::regex::contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
	}
	// pub fn is_env(line: &str) -> bool
	pub fn env(line: &str) -> bool
	{
		::regex::contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$")
	}
	// pub fn is_signal_handler_enabled() -> bool
	pub fn signal_handler_enabled() -> bool
	{
		env::var("CICADA_ENABLE_SIG_HANDLER").is_ok_and(|x| x == "1")
	}
	// pub fn is_args_in_token(token: &str) -> bool
	pub fn args_in_token(token: &str) -> bool { ::regex::contains(token, r"\$\{?[0-9@]+\}?") }

	/// Returns true if the given character has significance in a regex.
	// pub fn is_meta_character(c: char) -> bool
	pub fn meta_character(c: char) -> bool
	{
		match c
		{
			'\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^' | '$' | '#' | '&' | '-' 
			| '~' => true,
			_ => false,
		}
	}
	/// Returns true if the given character can be escaped in a regex.
	// pub fn is_escapeable_character(c: char) -> bool
	pub fn escapeable_character(c: char) -> bool
	{
		if meta_character(c) { return true; }

		if !c.is_ascii() { return false; }

		match c
		{
			'0'..='9' | 'A'..='Z' | 'a'..='z' => false,
			'<' | '>' => false,
			_ => true,
		}
	}
	/// Returns true if and only if the given character is a Unicode word
	// pub fn is_word_character(c: char) -> bool
	pub fn a_word_character(c: char) -> bool
	{ try_is_word_character(c).expect("unicode-perl feature must be enabled") }
	/// Returns true if and only if the given character is a Unicode word
	pub fn try_is_word_character( c: char ) -> ::result::Result<bool, UnicodeWordError>
	{ unicode::is_word_character(c) }
	/// Returns true if and only if the given character is an ASCII word character.
	// pub fn is_word_byte(c: u8) -> bool
	pub fn word_byte(c: u8) -> bool
	{
		match c
		{
			b'_' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' => true,
			_ => false,
		}
	}
	/// Returns true only if the given codepoint is in the `\w` character class.
	// pub fn is_word_character(c: char) -> Result<bool, UnicodeWordError>
	pub fn word_character(c: char) -> Result<bool, UnicodeWordError>
	{
		fn imp(c: char) -> Result<bool, UnicodeWordError>
		{
			use ::regex::syntax::{ unicode_tables::perl_word::PERL_WORD };

			if u8::try_from(c).map_or(false, is::word_byte) { return Ok(true); }
			
			Ok
			(
				PERL_WORD
				.binary_search_by(|&(start, end)|
				{
					use ::cmp::Ordering;

					if start <= c && c <= end { Ordering::Equal }
					else if start > c { Ordering::Greater }
					else { Ordering::Less }
				}
			).is_ok())
		}

		imp(c)
	}
	/// Returns true if the given character is a hexadecimal digit.
	//pub fn is_hex(c: char) -> bool
	pub fn hex(c: char) -> bool
	{ ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F') }
	/// Returns true if the given character is a valid in a capture group name.
	//pub fn is_capture_char(c: char, first: bool) -> bool
	pub fn capture_char(c: char, first: bool) -> bool
	{
		if first { c == '_' || c.is_alphabetic() }
		
		else { c == '_' || c == '.' || c == '[' || c == ']' || c.is_alphanumeric() }
	}
	/// Returns true if and only if the given offset in the given bytes falls on a
	// #[inline( always )] pub fn is_boundary(bytes: &[u8], i: usize) -> bool
	#[inline( always )] pub fn boundary(bytes: &[u8], i: usize) -> bool
	{
		match bytes.get(i)
		{
			None => i == bytes.len(),
			Some(&b) => b <= 0b0111_1111 || b >= 0b1100_0000,
		}
	}
	/// Returns true if and only if the given byte is either a valid leading UTF-8
	//#[inline( always )] pub fn is_leading_or_invalid_byte(b: u8) -> bool
	#[inline( always )] pub fn leading_or_invalid_byte(b: u8) -> bool
	{ (b & 0b1100_0000) != 0b1000_0000 }
	/// Returns true if and only if the given byte is considered a word character.
	/// Returns true if and only if the given byte is allowed in a capture name
	//pub fn is_valid_cap_letter(b: u8) -> bool
	pub fn valid_cap_letter(b: u8) -> bool
	{ matches!(b, b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' | b'_') }
	// pub fn is_prefix_char(c: char) -> bool
	pub fn prefix_char(c: char) -> bool
	{ c == '[' || c == '{' }
	// pub fn is_suffix_char(c: char) -> bool
	pub fn suffix_char(c: char) -> bool
	{ c == ']' || c == '}' }
	// pub fn is_prompt_item_char(c: char, token: &str) -> bool
	pub fn prompt_item_char(c: char, token: &str) -> bool
	{
		let s = c.to_string();
		
		if token.is_empty() { ::regex::contains(&s, r#"^[a-zA-Z_]$"#) }
		else { ::regex::contains(&s, r#"^[a-zA-Z0-9_]$"#) }
	}
	// pub fn is_command(word: &str) -> bool
	pub fn command(word: &str) -> bool
	{
		if ::is::builtin(word) { return true; }
		
		if let Ok(aliases) = ALIASES.lock()
		{
			if aliases.contains(word) { return true; }
		}
		
		if let Ok(commands) = AVAILABLE_COMMANDS.lock()
		{
			if commands.contains(word) { return true; }
		}

		false
	}
	// pub fn is_login(args: &[String]) -> bool
	pub fn login(args: &[String]) -> bool
	{
		if !args.is_empty() && args[0].starts_with("-") { return true; }

		if args.len() > 1 && (args[1] == "--login" || args[1] == "-l") { return true; }

		if let Ok(term_program) = ::env::var("TERM_PROGRAM")
		{ if term_program == "vscode" { return true; } }

		false
	}
	//pub fn is_script(args: &[String]) -> bool
	pub fn script(args: &[String]) -> bool
	{ args.len() > 1 && !args[1].starts_with("-") }
	// pub fn is_command_string(args: &[String]) -> bool
	pub fn command_string(args: &[String]) -> bool
	{ args.len() > 1 && args[1] == "-c" }
	// pub fn is_non_tty() -> bool
	pub fn non_tty() -> bool { unsafe { libc::isatty(0) == 0 } }
}

pub mod lazy
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use self::std::cell::Cell;
	use self::std::mem::MaybeUninit;
	use self::std::prelude::v1::*;
	use self::std::sync::Once;
	#[allow(deprecated)]
	pub use self::std::sync::ONCE_INIT;
	*/
	#[allow(dead_code)] // Used in macros
	pub struct Lazy<T: Sync>(Cell<MaybeUninit<T>>, Once);

	impl<T: Sync> Lazy<T>
	{
		pub const INIT: Self = Lazy(Cell::new(MaybeUninit::uninit()), ONCE_INIT);

		#[inline(always)] pub fn get<F>(&'static self, f: F) -> &T where
		F: FnOnce() -> T,
		{
			self.1.call_once(|| { self.0.set(MaybeUninit::new(f())); });
			
			unsafe { &*(*self.0.as_ptr()).as_ptr() }
		}
	}	
	/// Support trait for enabling a few common operation on lazy static values.
	pub trait LazyStatic
	{
		fn initialize(lazy: &Self);
	}
	/// Takes a shared reference to a lazy static and initializes it if it has not been already.
	pub fn initialize<T: LazyStatic>(lazy: &T) { LazyStatic::initialize(lazy); }
}

pub mod libc
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
	pub mod jobs
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use std::io::Write;

		use nix::sys::signal::Signal;
		use nix::sys::wait::waitpid;
		use nix::sys::wait::WaitPidFlag as WF;
		use nix::sys::wait::WaitStatus as WS;
		use nix::unistd::Pid;

		use crate::shell;
		use crate::signals;
		use crate::types::{self, CommandResult};
		*/		
		pub fn get_job_line(job: &types::Job, trim: bool) -> String {
			let mut cmd = job.cmd.clone();
			if trim && cmd.len() > 50 {
				cmd.truncate(50);
				cmd.push_str(" ...");
			}
			let _cmd = if job.is_bg && job.status == "Running" {
				format!("{} &", cmd)
			} else {
				cmd
			};
			format!("[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd)
		}

		pub fn print_job(job: &types::Job)
        {
			let line = get_job_line(job, true);
			println_stderr!("{}", line);
		}

		pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str) {
			if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
				job.status = reason.to_string();
				if job.is_bg {
					println_stderr!("");
					print_job(&job);
				}
			}
		}

		pub fn mark_job_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool) {
			sh.mark_job_as_stopped(gid);
			if !report {
				return;
			}

			// add an extra line to separate output of fg commands if any.
			if let Some(job) = sh.get_job_by_gid(gid) {
				println_stderr!("");
				print_job(job);
			}
		}

		pub fn mark_job_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool)
        {
			let _gid = if gid == 0 {
				unsafe { libc::getpgid(pid) }
			} else {
				gid
			};

			if let Some(job) = sh.mark_job_member_stopped(pid, gid) {
				if job.all_members_stopped() {
					mark_job_as_stopped(sh, gid, report);
				}
			}
		}

		pub fn mark_job_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32)
        {
			let _gid = if gid == 0 {
				unsafe { libc::getpgid(pid) }
			} else {
				gid
			};

			if let Some(job) = sh.mark_job_member_continued(pid, gid) {
				if job.all_members_running() {
					mark_job_as_running(sh, gid, true);
				}
			}
		}

		pub fn mark_job_as_running(sh: &mut shell::Shell, gid: i32, bg: bool) {
			sh.mark_job_as_running(gid, bg);
		}

			pub fn waitpidx(wpid: i32, block: bool) -> types::WaitStatus {
			let options = if block {
				Some(WF::WUNTRACED | WF::WCONTINUED)
			} else {
				Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
			};
			match waitpid(Pid::from_raw(wpid), options)
            {
				Ok(WS::Exited(pid, status)) => {
					let pid = i32::from(pid);
					types::WaitStatus::from_exited(pid, status)
				}
				Ok(WS::Stopped(pid, sig)) => {
					let pid = i32::from(pid);
					types::WaitStatus::from_stopped(pid, sig as i32)
				}
				Ok(WS::Continued(pid)) => {
					let pid = i32::from(pid);
					types::WaitStatus::from_continuted(pid)
				}
				Ok(WS::Signaled(pid, sig, _core_dumped)) => {
					let pid = i32::from(pid);
					types::WaitStatus::from_signaled(pid, sig as i32)
				}
				Ok(WS::StillAlive) => types::WaitStatus::empty(),
				Ok(_others) => {
					// this is for PtraceEvent and PtraceSyscall on Linux,
					// unreachable on other platforms.
					types::WaitStatus::from_others()
				}
				Err(e) => types::WaitStatus::from_error(e as i32),
			}
		}

		pub fn wait_fg_job(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult {
			let mut cmd_result = CommandResult::new();
			let mut count_waited = 0;
			let count_child = pids.len();
			if count_child == 0 {
				return cmd_result;
			}
			let pid_last = pids.last().unwrap();

			loop {
				let ws = waitpidx(-1, true);
				// here when we calling waitpidx(), all signals should have
				// been masked. There should no errors (ECHILD/EINTR etc) happen.
				if ws.is_error() {
					let err = ws.get_errno();
					if err == nix::Error::ECHILD {
						break;
					}

					log!("jobc unexpected waitpid error: {}", err);
					cmd_result = CommandResult::from_status(gid, err as i32);
					break;
				}

				let pid = ws.get_pid();
				let is_a_fg_child = pids.contains(&pid);
				if is_a_fg_child && !ws.is_continued() {
					count_waited += 1;
				}

				if ws.is_exited() {
					if is_a_fg_child {
						mark_job_as_done(sh, gid, pid, "Done");
					} else {
						let status = ws.get_status();
						signals::insert_reap_map(pid, status);
					}
				} else if ws.is_stopped() {
					if is_a_fg_child {
						// for stop signal of fg job (current job)
						// i.e. Ctrl-Z is pressed on the fg job
						mark_job_member_stopped(sh, pid, gid, true);
					} else {
						// for stop signal of bg jobs
						signals::insert_stopped_map(pid);
						mark_job_member_stopped(sh, pid, 0, false);
					}
				} else if ws.is_continued() {
					if !is_a_fg_child {
						signals::insert_cont_map(pid);
					}
					continue;
				} else if ws.is_signaled() {
					if is_a_fg_child {
						mark_job_as_done(sh, gid, pid, "Killed");
					} else {
						signals::killed_map_insert(pid, ws.get_signal());
					}
				}

				if is_a_fg_child && pid == *pid_last {
					let status = ws.get_status();
					cmd_result.status = status;
				}

				if count_waited >= count_child {
					break;
				}
			}
			cmd_result
		}

		pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool) {
			if sh.jobs.is_empty() {
				return;
			}

			if !sig_handler_enabled {
				// we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
				signals::handle_sigchld(Signal::SIGCHLD as i32);
			}

			let jobs = sh.jobs.clone();
			for (_i, job) in jobs.iter() {
				for pid in job.pids.iter() {
					if let Some(_status) = signals::pop_reap_map(*pid) {
						mark_job_as_done(sh, job.gid, *pid, "Done");
						continue;
					}

					if let Some(sig) = signals::killed_map_pop(*pid) {
						let reason = if sig == Signal::SIGQUIT as i32 {
							format!("Quit: {}", sig)
						} else if sig == Signal::SIGINT as i32 {
							format!("Interrupt: {}", sig)
						} else if sig == Signal::SIGKILL as i32 {
							format!("Killed: {}", sig)
						} else if sig == Signal::SIGTERM as i32 {
							format!("Terminated: {}", sig)
						} else {
							format!("Killed: {}", sig)
						};
						mark_job_as_done(sh, job.gid, *pid, &reason);
						continue;
					}

					if signals::pop_stopped_map(*pid) {
						mark_job_member_stopped(sh, *pid, job.gid, report);
					} else if signals::pop_cont_map(*pid) {
						mark_job_member_continued(sh, *pid, job.gid);
					}
				}
			}
		}

	}
	
	pub mod time
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use std::fmt;
		use time::OffsetDateTime;
		*/
		#[derive(Debug, PartialEq, Eq)]
		pub struct DateTime {
			odt: OffsetDateTime,
		}

		impl DateTime {
			pub fn now() -> Self {
				let odt: OffsetDateTime = match OffsetDateTime::now_local() {
					Ok(dt) => dt,
					Err(_) => OffsetDateTime::now_utc(),
				};
				DateTime { odt }
			}

			pub fn from_timestamp(ts: f64) -> Self {
				let dummy_now = Self::now();
				let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
				let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
				let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128)
				{
					Ok(x) => x,
					Err(_) => OffsetDateTime::now_utc(),
				};
				DateTime { odt }
			}

			pub fn unix_timestamp(&self) -> f64 {
				self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
			}
		}

		impl fmt::Display for DateTime {
			fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
				write!(
					f,
					"{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
					self.odt.year(),
					self.odt.month() as u8,
					self.odt.day(),
					self.odt.hour(),
					self.odt.minute(),
					self.odt.second(),
					self.odt.millisecond(),
				)
			}
		}

	}
}

pub mod libs
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
	pub mod colored
	{
		/*!
		Setting prompt in crate lineread needs wrap every SEQ chars with prefixing with '\x01' and suffix with '\x02'.
		Color Reference: https://misc.flogisoft.com/bash/tip_colors_and_formatting */
		use ::
		{
			*,
		};
		/*
		*/
		// cicada special
		pub const SEQ: &str = "\x01";
		pub const END_SEQ: &str = "\x02";
		pub const ESC: &str = "\x1B";

		// Set
		pub const BOLD: &str = "\x01\x1B[1m\x02";
		pub const DIM: &str = "\x01\x1B[2m\x02";
		pub const UNDERLINED: &str = "\x01\x1B[4m\x02";
		pub const BLINK: &str = "\x01\x1B[5m\x02";
		pub const REVERSE: &str = "\x01\x1B[7m\x02";
		pub const HIDDEN: &str = "\x01\x1B[8m\x02";

		// Reset
		pub const RESET: &str = "\x01\x1B[0m\x02";
		pub const RESET_BOLD: &str = "\x01\x1B[21m\x02";
		pub const RESET_DIM: &str = "\x01\x1B[22m\x02";
		pub const RESET_UNDERLINED: &str = "\x01\x1B[24m\x02";
		pub const RESET_BLINK: &str = "\x01\x1B[25m\x02";
		pub const RESET_REVERSE: &str = "\x01\x1B[27m\x02";
		pub const RESET_HIDDEN: &str = "\x01\x1B[28m\x02";

		// Foreground (text)
		pub const DEFAULT: &str = "\x01\x1B[39m\x02";
		pub const BLACK: &str = "\x01\x1B[30m\x02";
		pub const RED: &str = "\x01\x1B[31m\x02";
		pub const GREEN: &str = "\x01\x1B[32m\x02";
		pub const YELLOW: &str = "\x01\x1B[33m\x02";
		pub const BLUE: &str = "\x01\x1B[34m\x02";
		pub const MAGENTA: &str = "\x01\x1B[35m\x02";
		pub const CYAN: &str = "\x01\x1B[36m\x02";
		pub const GRAY_L: &str = "\x01\x1B[37m\x02";

		pub const GRAY_D: &str = "\x01\x1B[90m\x02";
		pub const RED_L: &str = "\x01\x1B[91m\x02";
		pub const GREEN_L: &str = "\x01\x1B[92m\x02";
		pub const YELLOW_L: &str = "\x01\x1B[93m\x02";
		pub const BLUE_L: &str = "\x01\x1B[94m\x02";
		pub const MAGENTA_L: &str = "\x01\x1B[95m\x02";
		pub const CYAN_L: &str = "\x01\x1B[96m\x02";
		pub const WHITE: &str = "\x01\x1B[97m\x02";

		pub const BLUE_B: &str = "\x01\x1B[34m\x1B[1m\x02";
		pub const BLACK_B: &str = "\x01\x1B[30m\x1B[1m\x02";
		pub const WHITE_B: &str = "\x01\x1B[97m\x1B[1m\x02";
		pub const RED_B: &str = "\x01\x1B[31m\x1B[1m\x02";
		pub const GREEN_B: &str = "\x01\x1B[32m\x1B[1m\x02";

		// Background
		pub const DEFAULT_BG: &str = "\x01\x1B[49m\x02";
		pub const BLACK_BG: &str = "\x01\x1B[40m\x02";
		pub const RED_BG: &str = "\x01\x1B[41m\x02";
		pub const GREEN_BG: &str = "\x01\x1B[42m\x02";
		pub const YELLOW_BG: &str = "\x01\x1B[43m\x02";
		pub const BLUE_BG: &str = "\x01\x1B[44m\x02";
		pub const MAGENTA_BG: &str = "\x01\x1B[45m\x02";
		pub const CYAN_BG: &str = "\x01\x1B[46m\x02";
		pub const GRAY_L_BG: &str = "\x01\x1B[47m\x02";

		pub const GRAY_D_BG: &str = "\x01\x1B[100m\x02";
		pub const RED_L_BG: &str = "\x01\x1B[101m\x02";
		pub const GREEN_L_BG: &str = "\x01\x1B[102m\x02";
		pub const YELLOW_L_BG: &str = "\x01\x1B[103m\x02";
		pub const BLUE_L_BG: &str = "\x01\x1B[104m\x02";
		pub const MAGENTA_L_BG: &str = "\x01\x1B[105m\x02";
		pub const CYAN_L_BG: &str = "\x01\x1B[106m\x02";
		pub const WHITE_BG: &str = "\x01\x1B[107m\x02";		
	}
		
	pub mod os_type
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use ::now;
		*/		
		pub fn get_os_name() -> String
		{
			let uname = get_uname();
			if uname.to_lowercase() == "darwin" { get_macos_name() }
			else { get_other_os_name() }
		}

		fn get_other_os_name() -> String
		{
			let mut name = get_release_value("PRETTY_NAME");
			
			if !name.is_empty() { return name; }
			
			name = get_release_value("DISTRIB_DESCRIPTION");
			
			if !name.is_empty() { return name; }
			
			name = get_release_value("IMAGE_DESCRIPTION");
			
			if !name.is_empty() { return name; }
			
			get_uname_mo()
		}

		fn get_release_value(ptn: &str) -> String {
			let line = format!(
				"grep -i '{}' /etc/*release* 2>&1 | grep -o '=.*' | tr '\"=' ' '",
				ptn
			);
			let cr = execute::run(&line);
			cr.stdout.trim().to_string()
		}

		fn get_uname() -> String {
			let cr = execute::run("uname");
			cr.stdout.trim().to_string()
		}

		fn get_uname_mo() -> String {
			let cr = execute::run("uname -m -o");
			cr.stdout.trim().to_string()
		}

		fn get_macos_name() -> String {
			let mut os_name = get_osx_codename();
			let ver = get_osx_version();
			if !ver.is_empty() {
				os_name.push(' ');
				os_name.push_str(&ver);
			}
			os_name
		}

		fn get_osx_codename() -> String {
			let cr = execute::run("grep -o 'SOFTWARE LICENSE AGREEMENT FOR .*[a-zA-Z]' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | sed 's/SOFTWARE LICENSE AGREEMENT FOR *//'");
			cr.stdout.trim().to_string()
		}

		fn get_osx_version() -> String {
			let cr = execute::run("sw_vers -productVersion");
			cr.stdout.trim().to_string()
		}

	}
	
	pub mod term_size
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use libc::{c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO};
		use std::mem::zeroed;
		*/
		// Unfortunately the actual command is not standardised...
		#[cfg(any(target_os = "linux", target_os = "android"))]
		static TIOCGWINSZ: c_ulong = 0x5413;

		#[cfg(any(
			target_os = "macos",
			target_os = "ios",
			target_os = "dragonfly",
			target_os = "freebsd",
			target_os = "netbsd",
			target_os = "openbsd"
		))]
		static TIOCGWINSZ: c_ulong = 0x40087468;

		#[cfg(target_os = "solaris")]
		static TIOCGWINSZ: c_ulong = 0x5468;

		extern "C" {
			fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;
		}
		/// Runs the ioctl command. Returns (0, 0) if all of the streams are not to a terminal, or
		/// there is an error. (0, 0) is an invalid size to have anyway, which is why
		/// it can be used as a nil value.
		unsafe fn get_dimensions_any() -> winsize {
			let mut window: winsize = zeroed();
			let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);

			if result == -1 {
				window = zeroed();
				result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
				if result == -1 {
					window = zeroed();
					result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
					if result == -1 {
						return zeroed();
					}
				}
			}
			window
		}
		/// Query the current processes's output (`stdout`), input (`stdin`), and error (`stderr`) in
		/// that order, in the attempt to dtermine terminal width. If one of those streams is actually
		/// a tty, this function returns its width and height as a number of characters.
		///
		/// # Errors
		///
		/// If *all* of the streams are not ttys or return any errors this function will return `None`.
		///
		/// # Example
		///
		/// To get the dimensions of your terminal window, simply use the following:
		///
		/// ```ignore
		/// if let Some((w, h)) = term_size::dimensions() {
		///     println!("Width: {}\nHeight: {}", w, h);
		/// } else {
		///     println!("Unable to get term size :(")
		/// }
		/// ```
		pub fn dimensions() -> Option<(usize, usize)>
        {
			let w = unsafe { get_dimensions_any() };

			if w.ws_col == 0 || w.ws_row == 0 {
				None
			} else {
				Some((w.ws_col as usize, w.ws_row as usize))
			}
		}

	}
}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod now
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use std::collections::HashMap;
	use std::io::{self, Read, Write};

	use regex::Regex;

	use crate::core;
	use crate::libs;
	use crate::parsers;
	use crate::shell::{self, Shell};
	use crate::types::{CommandLine, CommandResult, Tokens};
	*/
	/// Entry point for non-ttys (e.g. Cmd-N on MacVim)
	pub fn run_procs_for_non_tty(sh: &mut Shell)
    {
		let mut buffer = String::new();
		let stdin = io::stdin();
		let mut handle = stdin.lock();
		match handle.read_to_string(&mut buffer)
        {
			Ok(_) => {
				log!("run non tty command: {}", &buffer);
				run_command_line(sh, &buffer, false, false);
			}
			Err(e) => {
				println!("cicada: stdin.read_to_string() failed: {:?}", e);
			}
		}
	}

	pub fn run_command_line(
		sh: &mut Shell,
		line: &str,
		tty: bool,
		capture: bool,
	) -> Vec<CommandResult>
    {
		let mut cr_list = Vec::new();
		let mut status = 0;
		let mut sep = String::new();
		for token in parsers::line::line_to_cmds(line) {
			if token == ";" || token == "&&" || token == "||" {
				sep = token.clone();
				continue;
			}
			if sep == "&&" && status != 0 {
				break;
			}
			if sep == "||" && status == 0 {
				break;
			}
			let cmd = token.clone();
			let cr = run_proc(sh, &cmd, tty, capture);
			status = cr.status;
			sh.previous_status = status;
			cr_list.push(cr);
		}
		cr_list
	}

	fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String>
    {
		let mut envs: HashMap<String, String> = HashMap::new();
		let mut n = 0;
		let ptn_env_exp = r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$";
		let re = Regex::new(ptn_env_exp).unwrap();
		for (sep, text) in tokens.iter() {
			if !sep.is_empty() || !::regex::contains(text, ptn_env_exp) {
				break;
			}

			for cap in re.captures_iter(text) {
				let name = cap[1].to_string();
				let value = parsers::line::unquote(&cap[2]);
				envs.insert(name, value);
			}

			n += 1;
		}
		if n > 0 {
			tokens.drain(0..n);
		}
		envs
	}

	fn line_to_tokens(sh: &mut Shell, line: &str) -> (Tokens, HashMap<String, String>)
    {
		let linfo = parsers::line::parse_line(line);
		let mut tokens = linfo.tokens;
		shell::do_expansion(sh, &mut tokens);
		let envs = drain_env_tokens(&mut tokens);
		(tokens, envs)
	}

	fn set_shell_vars(sh: &mut Shell, envs: &HashMap<String, String>) {
		for (name, value) in envs.iter() {
			sh.set_env(name, value);
		}
	}

	/// Run simple command or pipeline without using `&&`, `||`, `;`.
	/// example 1: `ls`
	/// example 2: `ls | wc`
	fn run_proc(sh: &mut Shell, line: &str, tty: bool, capture: bool) -> CommandResult
    {
		let log_cmd = !sh.cmd.starts_with(' ');
		match CommandLine::from_line(line, sh)
        {
			Ok(cl) => {
				if cl.is_empty() {
					// for commands with only envs, e.g.
					// $ FOO=1 BAR=2
					// we need to define these **Shell Variables**.
					if !cl.envs.is_empty() {
						set_shell_vars(sh, &cl.envs);
					}
					return CommandResult::new();
				}

				let (term_given, cr) = core::run_pipeline(sh, &cl, tty, capture, log_cmd);
				if term_given {
					unsafe {
						let gid = libc::getpgid(0);
						shell::give_terminal_to(gid);
					}
				}

				cr
			}
			Err(e) => {
				println_stderr!("cicada: {}", e);
				CommandResult::from_status(0, 1)
			}
		}
	}

	fn run_with_shell(sh: &mut Shell, line: &str) -> CommandResult
    {
		let (tokens, envs) = line_to_tokens(sh, line);
		if tokens.is_empty() {
			set_shell_vars(sh, &envs);
			return CommandResult::new();
		}

		match CommandLine::from_line(line, sh)
        {
			Ok(c) => {
				let (term_given, cr) = core::run_pipeline(sh, &c, false, true, false);
				if term_given {
					unsafe {
						let gid = libc::getpgid(0);
						shell::give_terminal_to(gid);
					}
				}

				cr
			}
			Err(e) => {
				println_stderr!("cicada: {}", e);
				CommandResult::from_status(0, 1)
			}
		}
	}

	pub fn run(line: &str) -> CommandResult
    {
		let mut sh = Shell::new();
		run_with_shell(&mut sh, line)
	}
}

pub mod num
{
    pub use std::num::{ * };
}

pub mod parsers
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
	pub mod line
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use regex::Regex;
		use crate::libs;
		use crate::tools;
		use crate::types::{LineInfo, Redirection, Tokens};
		*/
		pub fn line_to_plain_tokens(line: &str) -> Vec<String>
        {
			let mut result = Vec::new();
			let linfo = parse_line(line);
			for (_, r) in linfo.tokens {
				result.push(r.clone());
			}
			result
		}

		pub fn tokens_to_args(tokens: &Tokens) -> Vec<String>
        {
			let mut result = Vec::new();
			for s in tokens {
				result.push(s.1.clone());
			}
			result
		}

		pub fn tokens_to_line(tokens: &Tokens) -> String {
			let mut result = String::new();
			for t in tokens {
				if t.0.is_empty() {
					result.push_str(&t.1);
				} else {
					let s = tools::wrap_sep_string(&t.0, &t.1);
					result.push_str(&s);
				}
				result.push(' ');
			}
			if result.ends_with(' ') {
				let len = result.len();
				result.truncate(len - 1);
			}
			result
		}
		/// Parse command line for multiple commands.
		///
		/// ```ignore
		/// let result1 = line_to_cmds("echo foo && echo bar; echo end");
		/// // Returns vec!["echo foo", "&&", "echo bar", ";", "echo end"]
		///
		/// let result2 = line_to_cmds("man awk | grep version");
		/// // Returns vec!["man awk | grep version"]
		/// ```
		pub fn line_to_cmds(line: &str) -> Vec<String> {
			// Special characters: http://tldp.org/LDP/abs/html/special-chars.html
			let mut result = Vec::new();
			let mut sep = String::new();
			let mut token = String::new();
			let mut has_backslash = false;
			let len = line.chars().count();
			for (i, c) in line.chars().enumerate() {
				if has_backslash {
					token.push('\\');
					token.push(c);
					has_backslash = false;
					continue;
				}

				if c == '\\' && sep != "'" {
					has_backslash = true;
					continue;
				}

				if c == '#' {
					if sep.is_empty() {
						break;
					} else {
						token.push(c);
						continue;
					}
				}
				if c == '\'' || c == '"' || c == '`' {
					if sep.is_empty() {
						sep.push(c);
						token.push(c);
						continue;
					} else if sep == c.to_string() {
						token.push(c);
						sep = String::new();
						continue;
					} else {
						token.push(c);
						continue;
					}
				}
				if c == '&' || c == '|' {
					// needs watch ahead here
					if sep.is_empty() {
						if i + 1 == len {
							// for bg commands, e.g. `ls &`
							token.push(c);
							continue;
						} else {
							let c_next = match line.chars().nth(i + 1) {
								Some(x) => x,
								None => {
									println!("chars nth error - should never happen");
									continue;
								}
							};

							if c_next != c {
								token.push(c);
								continue;
							}
						}
					}

					if sep.is_empty() {
						sep.push(c);
						continue;
					} else if c.to_string() == sep {
						let _token = token.trim().to_string();
						if !_token.is_empty() {
							result.push(_token);
						}
						token = String::new();
						result.push(format!("{}{}", sep, sep));
						sep = String::new();
						continue;
					} else {
						token.push(c);
						continue;
					}
				}
				if c == ';' {
					if sep.is_empty() {
						let _token = token.trim().to_string();
						if !_token.is_empty() {
							result.push(_token);
						}
						result.push(String::from(";"));
						token = String::new();
						continue;
					} else {
						token.push(c);
						continue;
					}
				}
				token.push(c);
			}
			if !token.is_empty() {
				result.push(token.trim().to_string());
			}
			result
		}
		/// Parse command line to tokens
		///
		/// ```ignore
		/// let result = parse_line("echo 'hi yoo' | grep \"hi\"");
		/// // Returns LineInfo {
		/// //     tokens: vec![
		/// //         ("", "echo"),
		/// //         ("'", "hi yoo"),
		/// //         ("", "|"),
		/// //         ("", "grep"),
		/// //         ("\"", "hi"),
		/// //     ],
		/// //     is_complete: true
		/// // }
		/// ```
		// #[allow(clippy::cyclomatic_complexity)]
		pub fn parse_line(line: &str) -> LineInfo {
			// FIXME: let rewrite this parse part and make it a separated lib
			let mut result = Vec::new();
			if ::is::arithmetic(line) {
				for x in line.split(' ') {
					result.push((String::from(""), x.to_string()));
				}
				return LineInfo::new(result);
			}

			let mut sep = String::new();
			// `sep_second` is for commands like this:
			//    export DIR=`brew --prefix openssl`/include
			// it only could have non-empty value when sep is empty.
			let mut sep_second = String::new();
			let mut token = String::new();
			let mut has_backslash = false;
			let mut met_parenthesis = false;
			let mut new_round = true;
			let mut skip_next = false;
			let mut has_dollar = false;
			let mut parens_left_ignored = false;

			// for cmds like: `ll foo\>bar end` -> `ll 'foo>bar' end`
			let mut sep_made = String::new();

			// using semi_ok makes quite dirty here
			// it is mainly for path completion like:
			// $ ls "foo b<TAB>
			// # then got `"foo bar"/`, then hit tab again:
			// $ ls "foo bar"/<TAB>
			// # should got:
			// $ ls "foo bar/the-single-file.txt"
			// also using semi_ok makes the following command works as expected:
			// $ touch "foo"/bar.txt  # create bar.txt under ./foo directory
			let mut semi_ok = false;
			let count_chars = line.chars().count();
			for (i, c) in line.chars().enumerate() {
				if skip_next {
					skip_next = false;
					continue;
				}

				if has_backslash && sep.is_empty() && (c == '>' || c == '<') {
					sep_made = String::from("'");
					token.push(c);
					has_backslash = false;
					continue;
				}

				if has_backslash && sep == "\"" && c != '\"' {
					// constant with bash: "\"" --> "; "\a" --> \a
					token.push('\\');
					token.push(c);
					has_backslash = false;
					continue;
				}

				if has_backslash {
					if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty() {
						sep = String::from("\\");
						token = format!("{}", c);
					} else {
						token.push(c);
					}
					new_round = false;
					has_backslash = false;
					continue;
				}

				if c == '$' {
					has_dollar = true;
				}

				// for cases like: echo $(foo bar)
				if c == '(' && sep.is_empty() {
					if !has_dollar && token.is_empty() {
						// temp solution for cmd like `(ls)`, `(ls -lh)`
						parens_left_ignored = true;
						continue;
					}
					met_parenthesis = true;
				}
				if c == ')' {
					if parens_left_ignored && !has_dollar {
						// temp solution for cmd like `(ls)`, `(ls -lh)`
						if i == count_chars - 1
							|| (i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == ' ')
						{
							continue;
						}
					}
					if sep.is_empty() {
						met_parenthesis = false;
					}
				}

				if c == '\\' {
					if sep == "'" || !sep_second.is_empty() {
						token.push(c)
					} else {
						has_backslash = true;
					}
					continue;
				}

				if new_round {
					if c == ' ' {
						continue;
					} else if c == '"' || c == '\'' || c == '`' {
						sep = c.to_string();
						new_round = false;
						continue;
					}

					sep = String::new();

					if c == '#' {
						// handle inline comments
						break;
					}

					if c == '|' {
						if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|' {
							result.push((String::from(""), "||".to_string()));
							skip_next = true;
						} else {
							result.push((String::from(""), "|".to_string()));
						}
						new_round = true;
						continue;
					}

					token.push(c);
					new_round = false;
					continue;
				}

				if c == '|' && !has_backslash {
					if semi_ok {
						if sep.is_empty() && !sep_made.is_empty() {
							result.push((sep_made.to_string(), token));
							sep_made = String::new();
						} else {
							result.push((sep.to_string(), token));
						}
						result.push((String::from(""), "|".to_string()));
						sep = String::new();
						sep_second = String::new();
						token = String::new();
						new_round = true;
						semi_ok = false;
						continue;
					} else if !met_parenthesis && sep_second.is_empty() && sep.is_empty() {
						if sep.is_empty() && !sep_made.is_empty() {
							result.push((sep_made.to_string(), token));
							sep_made = String::new();
						} else {
							result.push((String::from(""), token));
						}
						result.push((String::from(""), "|".to_string()));
						sep = String::new();
						sep_second = String::new();
						token = String::new();
						new_round = true;
						continue;
					}
				}

				if c == ' ' {
					if semi_ok {
						if sep.is_empty() && !sep_made.is_empty() {
							result.push((sep_made.to_string(), token));
							sep_made = String::new();
						} else {
							result.push((sep.to_string(), token));
						}
						sep = String::new();
						sep_second = String::new();
						token = String::new();
						new_round = true;
						semi_ok = false;
						continue;
					}

					if has_backslash {
						has_backslash = false;
						token.push(c);
						continue;
					}

					if met_parenthesis {
						token.push(c);
						continue;
					}

					if sep == "\\" {
						result.push((String::from("\\"), token));
						token = String::new();
						new_round = true;
						continue;
					}

					if sep.is_empty() {
						if sep_second.is_empty() {
							if sep.is_empty() && !sep_made.is_empty() {
								result.push((sep_made.clone(), token));
								sep_made = String::new();
							} else {
								result.push((String::from(""), token));
							}
							token = String::new();
							new_round = true;
							continue;
						} else {
							token.push(c);
							continue;
						}
					} else {
						token.push(c);
						continue;
					}
				}

				if c == '\'' || c == '"' || c == '`' {
					if has_backslash {
						has_backslash = false;
						token.push(c);
						continue;
					}

					if sep != c.to_string() && semi_ok {
						if sep.is_empty() && !sep_made.is_empty() {
							result.push((sep_made.to_string(), token));
							sep_made = String::new();
						} else {
							result.push((sep.to_string(), token));
						}
						sep = String::new();
						sep_second = String::new();
						token = String::new();
						new_round = true;
						semi_ok = false;
						// do not use continue here!
					}

					if sep != c.to_string() && met_parenthesis {
						token.push(c);
						continue;
					}
					if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string() {
						token.push(c);
						continue;
					}

					if sep.is_empty() {
						let is_an_env = ::regex::contains(&token, r"^[a-zA-Z0-9_]+=.*$");
						if !is_an_env && (c == '\'' || c == '"') {
							sep = c.to_string();
							continue;
						}

						token.push(c);
						if sep_second.is_empty() {
							sep_second = c.to_string();
						} else if sep_second == c.to_string() {
							sep_second = String::new();
						}
						continue;
					} else if sep == c.to_string() {
						semi_ok = true;
						continue;
					} else {
						token.push(c);
					}
				} else {
					if has_backslash {
						has_backslash = false;
						if sep == "\"" || sep == "'" {
							token.push('\\');
						}
					}
					token.push(c);
				}
			}
			if !token.is_empty() || semi_ok {
				if sep.is_empty() && !sep_made.is_empty() {
					result.push((sep_made.clone(), token));
				} else {
					result.push((sep.clone(), token));
				}
			}

			let mut is_line_complete = true;
			if !result.is_empty() {
				let token_last = result[result.len() - 1].clone();
				if token_last.0.is_empty() && token_last.1 == "|" {
					is_line_complete = false;
				}
			}

			if !sep.is_empty() {
				is_line_complete = semi_ok;
			}
			if has_backslash {
				is_line_complete = false;
			}

			LineInfo {
				tokens: result,
				is_complete: is_line_complete,
			}
		}

		pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String>
        {
			let mut tokens_new = Vec::new();
			let mut redirects = Vec::new();
			let mut to_be_continued = false;
			let mut to_be_continued_s1 = String::new();
			let mut to_be_continued_s2 = String::new();

			for token in tokens {
				let sep = &token.0;
				if !sep.is_empty() && !to_be_continued {
					tokens_new.push(token.clone());
					continue;
				}
				let word = &token.1;

				if to_be_continued {
					if sep.is_empty() && word.starts_with('&') {
						return Err(String::from("bad redirection syntax near &"));
					}

					let s3 = word.to_string();
					if ::regex::contains(&to_be_continued_s1, r"^\d+$") {
						if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" {
							return Err(String::from("Bad file descriptor #3"));
						}
						let s1 = to_be_continued_s1.clone();
						let s2 = to_be_continued_s2.clone();
						redirects.push((s1, s2, s3));
					} else {
						if !to_be_continued_s1.is_empty() {
							tokens_new.push((sep.clone(), to_be_continued_s1.to_string()));
						}
						redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
					}

					to_be_continued = false;
					continue;
				}

				let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
				let ptn2 = r"^([^>]*)(>>?)$";
				if !::regex::contains(word, r">") {
					tokens_new.push(token.clone());
				} else if ::regex::contains(word, ptn1) {
					let re;
					if let Ok(x) = Regex::new(ptn1) {
						re = x;
					} else {
						return Err(String::from("Failed to build Regex"));
					}

					if let Some(caps) = re.captures(word) {
						let s1 = caps.get(1).unwrap().as_str();
						let s2 = caps.get(2).unwrap().as_str();
						let s3 = caps.get(3).unwrap().as_str();
						if s3.starts_with('&') && s3 != "&1" && s3 != "&2" {
							return Err(String::from("Bad file descriptor #1"));
						}

						if ::regex::contains(s1, r"^\d+$") {
							if s1 != "1" && s1 != "2" {
								return Err(String::from("Bad file descriptor #2"));
							}
							redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
						} else {
							if !s1.is_empty() {
								tokens_new.push((sep.clone(), s1.to_string()));
							}
							redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
						}
					}
				} else if ::regex::contains(word, ptn2) {
					let re;
					if let Ok(x) = Regex::new(ptn2) {
						re = x;
					} else {
						return Err(String::from("Failed to build Regex"));
					}

					if let Some(caps) = re.captures(word) {
						let s1 = caps.get(1).unwrap().as_str();
						let s2 = caps.get(2).unwrap().as_str();

						to_be_continued = true;
						to_be_continued_s1 = s1.to_string();
						to_be_continued_s2 = s2.to_string();
					}
				}
			}

			if to_be_continued {
				return Err(String::from("redirection syntax error"));
			}

			Ok((tokens_new, redirects))
		}

		pub fn unquote(text: &str) -> String {
			let mut new_str = String::from(text);
			for &c in ['"', '\''].iter() {
				if text.starts_with(c) && text.ends_with(c) {
					new_str.remove(0);
					new_str.pop();
					break;
				}
			}
			new_str
		}
	}
    /*
    */
    pub mod rules
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
        pub struct Rule();
    }
}

pub mod panic
{
	pub use std::panic::{ * };
}

pub mod path
{
	pub use std::path::{ * };
	use ::
	{
		*,
	};
	/*
	use std::borrow::Cow;
	use std::env;
	use std::fs::read_dir;
	use std::io::{ErrorKind, Write};
	use std::os::unix::fs::PermissionsExt;

	use regex::Regex;

	use crate::tools;
	*/
	pub fn basename(path: &str) -> Cow<'_, str>
    {
		let mut pieces = path.rsplit('/');
		match pieces.next() {
			Some(p) => p.into(),
			None => path.into(),
		}
	}

	pub fn expand_home(text: &str) -> String
    {
		let mut s: String = text.to_string();
		let v = vec![
			r"(?P<head> +)~(?P<tail> +)",
			r"(?P<head> +)~(?P<tail>/)",
			r"^(?P<head> *)~(?P<tail>/)",
			r"(?P<head> +)~(?P<tail> *$)",
		];
		for item in &v {
			let re;
			if let Ok(x) = Regex::new(item) {
				re = x;
			} else {
				return String::new();
			}
			let home = tools::get_user_home();
			let ss = s.clone();
			let to = format!("$head{}$tail", home);
			let result = re.replace_all(ss.as_str(), to.as_str());
			s = result.to_string();
		}
		s
	}

	pub fn find_file_in_path(filename: &str, exec: bool) -> String
    {
		let env_path = match env::var("PATH")
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: error with env PATH: {:?}", e);
				return String::new();
			}
		};
		let vec_path: Vec<&str> = env_path.split(':').collect();
		for p in &vec_path {
			match read_dir(p)
            {
				Ok(list) => {
					for entry in list.flatten() {
						if let Ok(name) = entry.file_name().into_string() {
							if name != filename {
								continue;
							}

							if exec {
								let _mode = match entry.metadata() {
									Ok(x) => x,
									Err(e) => {
										println_stderr!("cicada: metadata error: {:?}", e);
										continue;
									}
								};
								let mode = _mode.permissions().mode();
								if mode & 0o111 == 0 {
									// not binary
									continue;
								}
							}

							return entry.path().to_string_lossy().to_string();
						}
					}
				}
				Err(e) => {
					if e.kind() == ErrorKind::NotFound {
						continue;
					}
					log!("cicada: fs read_dir error: {}: {}", p, e);
				}
			}
		}
		String::new()
	}

	pub fn current_dir() -> String
    {
		let _current_dir = match env::current_dir()
        {
			Ok(x) => x,
			Err(e) => {
				log!("cicada: PROMPT: env current_dir error: {}", e);
				return String::new();
			}
		};
		let current_dir = match _current_dir.to_str() {
			Some(x) => x,
			None => {
				log!("cicada: PROMPT: to_str error");
				return String::new();
			}
		};

		current_dir.to_string()
	}

}

pub mod process
{
	pub use std::process::{ * };
	/*
	use nix::unistd::{fork as nix_fork, ForkResult};
	use nix::Result;
	use libc::c_int;
	use nix::Error;
	use std::mem;
	use std::os::fd::RawFd;
	*/
	pub fn close(fd: i32) {
		unsafe {
			libc::close(fd);
		}
	}

	pub fn dup(fd: i32) -> i32 {
		unsafe { libc::dup(fd) }
	}

	pub fn dup2(src: i32, dst: i32) {
		unsafe {
			libc::dup2(src, dst);
		}
	}
	// make fork "safe again", in order not to touch the code in core.rs,
	// see https://github.com/nix-rust/nix/issues/586
	// we can have refactorings any time needed.
	pub fn fork() -> Result<ForkResult> {
		unsafe { nix_fork() }
	}
	
	pub fn pipe() -> std::result::Result<(RawFd, RawFd), Error>
    {
		let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
		let res = unsafe { libc::pipe(fds.as_mut_ptr() as *mut c_int) };
		Error::result(res)?;
		unsafe { Ok((fds.assume_init()[0], fds.assume_init()[1])) }
	}

    pub fn read_id() -> i32 {
        unsafe { libc::getpid() }
    }
	
}

pub mod prompt
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use crate::libs;
	use crate::shell;

	use self::main::get_prompt_string;
	use self::main::render_prompt;
	pub use self::multilines::EnterFunction;
	*/
	pub mod main
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use std::env;

		use ::now;
		use crate::libs;
		use crate::shell;
		*/
		const DEFAULT_PROMPT: &str = "${COLOR_STATUS}$USER${RESET}\
			@${COLOR_STATUS}$HOSTNAME${RESET}: \
			${COLOR_STATUS}$CWD${RESET}$ ";
		use super::preset::apply_preset_item;
		use super::preset::apply_pyenv;

		pub fn get_prompt_string() -> String {
			if let Ok(x) = env::var("PROMPT") {
				return x;
			}
			DEFAULT_PROMPT.to_string()
		}

		fn apply_prompt_item(sh: &shell::Shell, result: &mut String, token: &str) {
			if let Some(x) = sh.get_env(token) {
				result.push_str(&x);
				return;
			}
			apply_preset_item(sh, result, token);
		}

		fn apply_command(result: &mut String, token: &str, prefix: &str, suffix: &str)
        {
			let cr = execute::run(token);
			let output = cr.stdout.trim();
			if !output.is_empty() {
				result.push_str(prefix);
				result.push_str(output);
				result.push_str(suffix);
			}
		}

		pub fn render_prompt(sh: &shell::Shell, ps: &str) -> String {
			let mut prompt = String::new();
			apply_pyenv(&mut prompt);

			let mut met_dollar = false;
			let mut met_brace = false;
			let mut met_paren = false;
			let mut token = String::new();
			let mut prefix = String::new();
			let mut suffix = String::new();
			for c in ps.chars() {
				if met_dollar {
					if c == '(' && !met_brace && !met_paren {
						met_paren = true;
						continue;
					}
					if c == ')' && met_paren {
						apply_command(&mut prompt, &token, &prefix, &suffix);
						token.clear();
						prefix.clear();
						suffix.clear();
						met_dollar = false;
						met_paren = false;
						continue;
					}
					if c == '{' && !met_brace && !met_paren {
						met_brace = true;
						continue;
					} else if c == '}' && met_brace {
						apply_prompt_item(sh, &mut prompt, &token);
						token.clear();
						met_dollar = false;
						met_brace = false;
						continue;
					} else if c == '$' {
						if token.is_empty() {
							// to make single $ as a plain $
							prompt.push('$');
							met_dollar = true;
							continue;
						} else {
							apply_prompt_item(sh, &mut prompt, &token);
							token.clear();
							// met_dollar is still true
							continue;
						}
					} else if met_paren {
						if is_prefix_char(c) {
							prefix.push(c);
						} else if is_suffix_char(c) {
							suffix.push(c);
						} else {
							token.push(c);
						}
						continue;
					} else if is_prompt_item_char(c, &token) {
						token.push(c);
						continue;
					} else if token.is_empty() {
						prompt.push('$');
						prompt.push(c);
						met_dollar = false;
						continue;
					}
				}

				if c == '$' {
					met_dollar = true;
					continue;
				}

				if !token.is_empty() {
					apply_prompt_item(sh, &mut prompt, &token);
					token.clear();
				}
				prompt.push(c);
				met_dollar = false;
			}

			if !token.is_empty() {
				apply_prompt_item(sh, &mut prompt, &token);
				met_dollar = false;
			}

			if met_dollar {
				// for cases like PROMPT='$$'
				prompt.push('$');
			}
            /*
			if prompt.trim().is_empty() {
				return format!("cicada-{} >> ", env!("CARGO_PKG_VERSION"));
			} */

			prompt
		}
	}
	
	pub mod multilines
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use lineread::{Function, Prompter, Terminal};
		use std::io;

		use crate::parsers::parser_line;
		*/

		pub struct EnterFunction;

		impl<T: Terminal> Function<T> for EnterFunction {
			fn execute(&self, prompter: &mut Prompter<T>, count: i32, _ch: char) -> io::Result<()> {
				let buf = prompter.buffer();
				let linfo = parser_line::parse_line(buf);
				if linfo.is_complete {
					prompter.accept_input()
				} else if count > 0 {
					match prompter.insert(count as usize, '\n') {
						Ok(_) => {}
						Err(e) => {
							println!("sub-prompt error: {}", e);
						}
					}
					prompter.insert_str(">> ")
				} else {
					Ok(())
				}
			}
		}
	}
	
	pub mod preset
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use std::env;
		use std::fs::File;
		use std::io::{Read, Write};
		use std::path::Path;

		use crate::libs;
		use crate::shell;
		use crate::tools;
		*/
		fn apply_seq(prompt: &mut String) {
			prompt.push_str(libs::colored::SEQ);
		}

		fn apply_end_seq(prompt: &mut String) {
			prompt.push_str(libs::colored::END_SEQ);
		}

		fn apply_esc(prompt: &mut String) {
			prompt.push_str(libs::colored::ESC);
		}

		fn apply_underlined(prompt: &mut String) {
			prompt.push_str(libs::colored::UNDERLINED);
		}

		fn apply_user(prompt: &mut String)
        {
			let username = tools::get_user_name();
			prompt.push_str(&username);
		}

		fn apply_black(prompt: &mut String) {
			prompt.push_str(libs::colored::BLACK);
		}

		fn apply_black_b(prompt: &mut String) {
			prompt.push_str(libs::colored::BLACK_B);
		}

		fn apply_black_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::BLACK_BG);
		}

		fn apply_blue(prompt: &mut String) {
			prompt.push_str(libs::colored::BLUE);
		}

		fn apply_blue_b(prompt: &mut String) {
			prompt.push_str(libs::colored::BLUE_B);
		}

		fn apply_blue_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::BLUE_BG);
		}

		fn apply_bold(prompt: &mut String) {
			prompt.push_str(libs::colored::BOLD);
		}

		fn apply_green(prompt: &mut String) {
			prompt.push_str(libs::colored::GREEN);
		}

		fn apply_green_b(prompt: &mut String) {
			prompt.push_str(libs::colored::GREEN_B);
		}

		fn apply_green_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::GREEN_BG);
		}

		fn apply_red(prompt: &mut String) {
			prompt.push_str(libs::colored::RED);
		}

		fn apply_red_b(prompt: &mut String) {
			prompt.push_str(libs::colored::RED_B);
		}

		fn apply_red_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::RED_BG);
		}

		fn apply_white(prompt: &mut String) {
			prompt.push_str(libs::colored::WHITE);
		}

		fn apply_white_b(prompt: &mut String) {
			prompt.push_str(libs::colored::WHITE_B);
		}

		fn apply_white_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::WHITE_BG);
		}

		fn apply_hidden(prompt: &mut String) {
			prompt.push_str(libs::colored::HIDDEN);
		}

		fn apply_reset(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET);
		}

		fn apply_reverse(prompt: &mut String) {
			prompt.push_str(libs::colored::REVERSE);
		}

		fn apply_dim(prompt: &mut String) {
			prompt.push_str(libs::colored::DIM);
		}

		fn apply_blink(prompt: &mut String) {
			prompt.push_str(libs::colored::BLINK);
		}

		fn apply_reset_underlined(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET_UNDERLINED);
		}

		fn apply_reset_dim(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET_DIM);
		}

		fn apply_reset_reverse(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET_REVERSE);
		}

		fn apply_reset_hidden(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET_HIDDEN);
		}

		fn apply_reset_blink(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET_BLINK);
		}

		fn apply_reset_bold(prompt: &mut String) {
			prompt.push_str(libs::colored::RESET_BOLD);
		}

		fn apply_default(prompt: &mut String) {
			prompt.push_str(libs::colored::DEFAULT);
		}

		fn apply_default_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::DEFAULT_BG);
		}

		fn apply_cyan(prompt: &mut String) {
			prompt.push_str(libs::colored::CYAN);
		}

		fn apply_cyan_l(prompt: &mut String) {
			prompt.push_str(libs::colored::CYAN_L);
		}

		fn apply_cyan_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::CYAN_BG);
		}

		fn apply_cyan_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::CYAN_L_BG);
		}

		fn apply_red_l(prompt: &mut String) {
			prompt.push_str(libs::colored::RED_L);
		}

		fn apply_red_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::RED_L_BG);
		}

		fn apply_green_l(prompt: &mut String) {
			prompt.push_str(libs::colored::GREEN_L);
		}

		fn apply_green_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::GREEN_L_BG);
		}

		fn apply_gray_l(prompt: &mut String) {
			prompt.push_str(libs::colored::GRAY_L);
		}

		fn apply_gray_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::GRAY_L_BG);
		}

		fn apply_gray_d(prompt: &mut String) {
			prompt.push_str(libs::colored::GRAY_D);
		}

		fn apply_gray_d_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::GRAY_D_BG);
		}

		fn apply_magenta(prompt: &mut String) {
			prompt.push_str(libs::colored::MAGENTA);
		}

		fn apply_magenta_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::MAGENTA_BG);
		}

		fn apply_magenta_l(prompt: &mut String) {
			prompt.push_str(libs::colored::MAGENTA_L);
		}

		fn apply_magenta_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::MAGENTA_L_BG);
		}

		fn apply_yellow(prompt: &mut String) {
			prompt.push_str(libs::colored::YELLOW);
		}

		fn apply_yellow_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::YELLOW_BG);
		}

		fn apply_yellow_l(prompt: &mut String) {
			prompt.push_str(libs::colored::YELLOW_L);
		}

		fn apply_yellow_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::YELLOW_L_BG);
		}

		fn apply_blue_l(prompt: &mut String) {
			prompt.push_str(libs::colored::BLUE_L);
		}

		fn apply_blue_l_bg(prompt: &mut String) {
			prompt.push_str(libs::colored::BLUE_L_BG);
		}

		fn apply_color_status(sh: &shell::Shell, prompt: &mut String) {
			if sh.previous_status == 0 {
				prompt.push_str(libs::colored::GREEN_B);
			} else {
				prompt.push_str(libs::colored::RED_B);
			}
		}

		fn _find_git_root() -> String {
			let current_dir = libs::path::current_dir();
			let dir_git = format!("{}/.git", current_dir);
			if Path::new(&dir_git).exists() {
				return current_dir;
			}

			let mut _dir = current_dir.clone();
			while Path::new(&_dir).parent().is_some() {
				match Path::new(&_dir).parent() {
					Some(p) => {
						_dir = p.to_string_lossy().to_string();
						let dir_git = format!("{}/.git", _dir);
						if Path::new(&dir_git).exists() {
							return _dir;
						}
					}
					None => {
						break;
					}
				}
			}

			String::new()
		}

		fn apply_gitbr(prompt: &mut String)
        {
			let git_root = _find_git_root();
			if git_root.is_empty() {
				return;
			}

			let file_head = format!("{}/.git/HEAD", git_root);
			if !Path::new(&file_head).exists() {
				return;
			}

			let mut file;
			match File::open(&file_head)
            {
				Ok(x) => file = x,
				Err(e) => {
					println!("cicada: .git/HEAD err: {:?}", e);
					return;
				}
			}
			let mut text = String::new();
			match file.read_to_string(&mut text)
            {
				Ok(_) => {}
				Err(e) => {
					println!("cicada: read_to_string error: {:?}", e);
					return;
				}
			}

			if let Some(branch) = libs::re::find_first_group(r"^[a-z]+: ?[a-z]+/[a-z]+/(.+)$", text.trim())
			{
				apply_blue_b(prompt);
				if let Ok(x) = env::var("CICADA_GITBR_PREFIX") {
					prompt.push_str(&x);
				}

				let _len_default: i32 = 32;
				let mut len_max = if let Ok(x) = env::var("CICADA_GITBR_MAX_LEN") {
					match x.parse::<i32>() {
						Ok(n) => n,
						Err(_) => _len_default,
					}
				} else {
					_len_default
				};
				if len_max <= 0 {
					len_max = _len_default;
				}

				if branch.len() as i32 <= len_max {
					prompt.push_str(&branch);
				} else {
					let len = branch.len() as i32;
					let offset = (len - len_max + 2) as usize;
					let branch_short = format!("..{}", &branch[offset..]);
					prompt.push_str(&branch_short);
				}
				if let Ok(x) = env::var("CICADA_GITBR_SUFFIX") {
					prompt.push_str(&x);
				}
				apply_reset(prompt);
			}
		}

		fn apply_cwd(prompt: &mut String)
        {
			let _current_dir = match env::current_dir()
            {
				Ok(x) => x,
				Err(e) => {
					println_stderr!("cicada: PROMPT: env current_dir error: {}", e);
					return;
				}
			};
			let current_dir = match _current_dir.to_str() {
				Some(x) => x,
				None => {
					println_stderr!("cicada: PROMPT: to_str error");
					return;
				}
			};
			let _tokens: Vec<&str> = current_dir.split('/').collect();

			let last = match _tokens.last() {
				Some(x) => x,
				None => {
					log!("cicada: PROMPT: token last error");
					return;
				}
			};

			let home = tools::get_user_home();
			let pwd = if last.is_empty() {
				"/"
			} else if current_dir == home {
				"~"
			} else {
				last
			};
			prompt.push_str(pwd);
		}

		fn apply_hostname(prompt: &mut String)
        {
			let hostname = tools::get_hostname();
			prompt.push_str(&hostname);
		}

		fn apply_newline(prompt: &mut String) {
			prompt.push('\n');
		}

		pub fn apply_pyenv(prompt: &mut String) {
			if let Ok(x) = env::var("VIRTUAL_ENV") {
				if !x.is_empty() {
					let _tokens: Vec<&str> = x.split('/').collect();
					let env_name = match _tokens.last() {
						Some(x) => x,
						None => {
							log!("prompt token last error");
							return;
						}
					};

					apply_blue_b(prompt);
					prompt.push('(');
					prompt.push_str(env_name);
					prompt.push(')');
					apply_reset(prompt);
				}
			}
		}

		pub fn apply_preset_item(sh: &shell::Shell, prompt: &mut String, token: &str) {
			match token.to_ascii_lowercase().as_ref() {
				"black" => apply_black(prompt),
				"black_b" => apply_black_b(prompt),
				"black_bg" => apply_black_bg(prompt),
				"blink" => apply_blink(prompt),
				"blue" => apply_blue(prompt),
				"blue_b" => apply_blue_b(prompt),
				"blue_bg" => apply_blue_bg(prompt),
				"blue_l" => apply_blue_l(prompt),
				"blue_l_bg" => apply_blue_l_bg(prompt),
				"bold" => apply_bold(prompt),
				"color_status" => apply_color_status(sh, prompt),
				"cwd" => apply_cwd(prompt),
				"cyan" => apply_cyan(prompt),
				"cyan_bg" => apply_cyan_bg(prompt),
				"cyan_l" => apply_cyan_l(prompt),
				"cyan_l_bg" => apply_cyan_l_bg(prompt),
				"default" => apply_default(prompt),
				"default_bg" => apply_default_bg(prompt),
				"dim" => apply_dim(prompt),
				"end_seq" => apply_end_seq(prompt),
				"esc" => apply_esc(prompt),
				"gitbr" => apply_gitbr(prompt),
				"gray_d" => apply_gray_d(prompt),
				"gray_d_bg" => apply_gray_d_bg(prompt),
				"gray_l" => apply_gray_l(prompt),
				"gray_l_bg" => apply_gray_l_bg(prompt),
				"green" => apply_green(prompt),
				"green_b" => apply_green_b(prompt),
				"green_bg" => apply_green_bg(prompt),
				"green_l" => apply_green_l(prompt),
				"green_l_bg" => apply_green_l_bg(prompt),
				"hidden" => apply_hidden(prompt),
				"hostname" => apply_hostname(prompt),
				"magenta" => apply_magenta(prompt),
				"magenta_bg" => apply_magenta_bg(prompt),
				"magenta_l" => apply_magenta_l(prompt),
				"magenta_l_bg" => apply_magenta_l_bg(prompt),
				"newline" => apply_newline(prompt),
				"red" => apply_red(prompt),
				"red_b" => apply_red_b(prompt),
				"red_bg" => apply_red_bg(prompt),
				"red_l" => apply_red_l(prompt),
				"red_l_bg" => apply_red_l_bg(prompt),
				"reset" => apply_reset(prompt),
				"reset_blink" => apply_reset_blink(prompt),
				"reset_bold" => apply_reset_bold(prompt),
				"reset_dim" => apply_reset_dim(prompt),
				"reset_hidden" => apply_reset_hidden(prompt),
				"reset_reverse" => apply_reset_reverse(prompt),
				"reset_underlined" => apply_reset_underlined(prompt),
				"reverse" => apply_reverse(prompt),
				"seq" => apply_seq(prompt),
				"underlined" => apply_underlined(prompt),
				"user" => apply_user(prompt),
				"white" => apply_white(prompt),
				"white_b" => apply_white_b(prompt),
				"white_bg" => apply_white_bg(prompt),
				"yellow" => apply_yellow(prompt),
				"yellow_bg" => apply_yellow_bg(prompt),
				"yellow_l" => apply_yellow_l(prompt),
				"yellow_l_bg" => apply_yellow_l_bg(prompt),
				_ => (),
			}
		}

	}
	
	fn get_prompt_len(prompt: &str) -> i32
	{
		let mut count = 0;
		let mut met_x01 = false;
		for c in prompt.chars() {
			if c == '\x01' {
				met_x01 = true;
				continue;
			} else if c == '\x02' {
				met_x01 = false;
				continue;
			}
			if !met_x01 {
				count += 1;
			}
		}
		count
	}

	pub fn get_prompt(sh: &shell::Shell) -> String
    {
		let ps = get_prompt_string();
		let mut prompt = render_prompt(sh, &ps);
		if let Some((w, _h)) = libs::term_size::dimensions() {
			if get_prompt_len(&prompt) > (w / 2) as i32
				&& !::regex::contains(&ps, r#"(?i)\$\{?newline.\}?"#)
			{
				prompt.push_str("\n$ ");
			}
		} else {
			log!("ERROR: Failed to get term size");
		}
		prompt
	}

}

pub mod rc
{
	/*!
	*/
	pub use std::rc::{ * };
	use ::
	{
		*,
	};
	/*
	*/
	pub mod file
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use std::path::Path;

		use crate::scripts;
		use crate::shell;
		use crate::tools;
		*/
		pub fn get_rc_file() -> String {
			let dir_config = tools::get_config_dir();
			let rc_file = format!("{}/cicadarc", dir_config);
			if Path::new(&rc_file).exists() {
				return rc_file;
			}

			// fail back to $HOME/.cicadarc
			let home = tools::get_user_home();
			let rc_file_home = format!("{}/{}", home, ".cicadarc");
			if Path::new(&rc_file_home).exists() {
				return rc_file_home;
			}

			// use std path if both absent
			rc_file
		}

		pub fn load_rc_files(sh: &mut shell::Shell)
        {
			let rc_file = get_rc_file();
			if !Path::new(&rc_file).exists() {
				return;
			}

			let args = vec!["source".to_string(), rc_file];
			scripting::run_script(sh, &args);
		}
	}
}

pub mod regex
{
    /*!
    This crate provides routines for searching strings for matches of a [regular expression] (aka "regex").
    */
    pub mod automata
    {
        /*!
        This crate exposes a variety of regex engines used by the `regex` crate. */
        pub use ::
        {
            regex::automata::
            {
                util::
                {
                    primitives::PatternID,
                    search::{ * },
                },
            },
        };
        /*
        */
        pub mod dfa
        {
            /*!
            A module for building and searching with deterministic finite automata (DFAs). */
            use ::
            {
                regex::automata::
                {
                    dfa::
                    {
                        automaton::{Automaton, OverlappingState, StartError},
                        start::StartKind,
                    }
                },
                *,
            };
            /*
            */
            const DEAD: ::regex::automata::util::primitives::StateID = ::regex::automata::util::primitives::StateID::ZERO;
            
            pub mod dense
            {
                /*!
                Types and routines specific to dense DFAs.*/
                use ::
                {
                    collections::{BTreeMap, BTreeSet},
                    regex::automata::
                    {
                        dfa::
                        { 
                            accel::{ Accel, Accels }, determinize, minimize::Minimizer, remapper::Remapper, sparse,
                            automaton::{fmt_state_indicator, Automaton, StartError},
                            special::Special,
                            start::StartKind,
                            DEAD,
                        },
                        nfa::thompson,
                        util::
                        {
                            look::LookMatcher, search::MatchKind, alphabet::{self, ByteClasses, ByteSet},
                            int::{Pointer, Usize},
                            prefilter::Prefilter,
                            primitives::{PatternID, StateID},
                            search::Anchored,
                            start::{self, Start, StartByteMap},
                            wire::{self, DeserializeError, Endian, SerializeError},
                        },
                    },
                    mem::{ size_of },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                /// The label that is pre-pended to a serialized DFA.
                const LABEL: &str = "rust-regex-automata-dfa-dense";
                /// The format version of dense regexes. This version gets incremented when a
                const VERSION: u32 = 2;
                /// The configuration used for compiling a dense DFA.
                #[derive(Clone, Debug, Default)]
                pub struct Config 
                {
                    accelerate: Option<bool>,
                    pre: Option<Option<Prefilter>>,
                    minimize: Option<bool>,
                    match_kind: Option<MatchKind>,
                    start_kind: Option<StartKind>,
                    starts_for_each_pattern: Option<bool>,
                    byte_classes: Option<bool>,
                    unicode_word_boundary: Option<bool>,
                    quitset: Option<ByteSet>,
                    specialize_start_states: Option<bool>,
                    dfa_size_limit: Option<Option<usize>>,
                    determinize_size_limit: Option<Option<usize>>,
                }

                impl Config
                {
                    /// Return a new default dense DFA compiler configuration.
                    pub fn new() -> Config {
                        Config::default()
                    }
                    /// Enable state acceleration.
                    pub fn accelerate(mut self, yes: bool) -> Config {
                        self.accelerate = Some(yes);
                        self
                    }
                    /// Set a prefilter to be used whenever a start state is entered.
                    pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
                        self.pre = Some(pre);
                        
                        if self.specialize_start_states.is_none() {
                            self.specialize_start_states =
                                Some(self.get_prefilter().is_some());
                        }
                        self
                    }
                    /// Minimize the DFA.
                    pub fn minimize(mut self, yes: bool) -> Config {
                        self.minimize = Some(yes);
                        self
                    }
                    /// Set the desired match semantics.
                    pub fn match_kind(mut self, kind: MatchKind) -> Config {
                        self.match_kind = Some(kind);
                        self
                    }
                    /// The type of starting state configuration to use for a DFA.
                    pub fn start_kind(mut self, kind: StartKind) -> Config {
                        self.start_kind = Some(kind);
                        self
                    }
                    /// Whether to compile a separate start state for each pattern in the
                    pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {
                        self.starts_for_each_pattern = Some(yes);
                        self
                    }
                    /// Whether to attempt to shrink the size of the DFA's alphabet or not.
                    pub fn byte_classes(mut self, yes: bool) -> Config {
                        self.byte_classes = Some(yes);
                        self
                    }
                    /// Heuristically enable Unicode word boundaries.
                    pub fn unicode_word_boundary(mut self, yes: bool) -> Config {
                        self.unicode_word_boundary = Some(yes);
                        self
                    }
                    /// Add a "quit" byte to the DFA.
                    pub fn quit(mut self, byte: u8, yes: bool) -> Config {
                        if self.get_unicode_word_boundary() && !byte.is_ascii() && !yes {
                            panic!(
                                "cannot set non-ASCII byte to be non-quit when \
                                Unicode word boundaries are enabled"
                            );
                        }
                        
                        if self.quitset.is_none() {
                            self.quitset = Some(ByteSet::empty());
                        }
                        
                        if yes {
                            self.quitset.as_mut().unwrap().add(byte);
                        } else {
                            self.quitset.as_mut().unwrap().remove(byte);
                        }
                        self
                    }
                    /// Enable specializing start states in the DFA.
                    pub fn specialize_start_states(mut self, yes: bool) -> Config {
                        self.specialize_start_states = Some(yes);
                        self
                    }
                    /// Set a size limit on the total heap used by a DFA.
                    pub fn dfa_size_limit(mut self, bytes: Option<usize>) -> Config {
                        self.dfa_size_limit = Some(bytes);
                        self
                    }
                    /// Set a size limit on the total heap used by determinization.
                    pub fn determinize_size_limit(mut self, bytes: Option<usize>) -> Config {
                        self.determinize_size_limit = Some(bytes);
                        self
                    }
                    /// Returns whether this configuration has enabled simple state
                    pub fn get_accelerate(&self) -> bool {
                        self.accelerate.unwrap_or(true)
                    }
                    /// Returns the prefilter attached to this configuration, if any.
                    pub fn get_prefilter(&self) -> Option<&Prefilter> {
                        self.pre.as_ref().unwrap_or(&None).as_ref()
                    }
                    /// Returns whether this configuration has enabled the expensive process
                    pub fn get_minimize(&self) -> bool {
                        self.minimize.unwrap_or(false)
                    }
                    /// Returns the match semantics set in this configuration.
                    pub fn get_match_kind(&self) -> MatchKind {
                        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
                    }
                    /// Returns the starting state configuration for a DFA.
                    pub fn get_starts(&self) -> StartKind {
                        self.start_kind.unwrap_or(StartKind::Both)
                    }
                    /// Returns whether this configuration has enabled anchored starting states
                    pub fn get_starts_for_each_pattern(&self) -> bool {
                        self.starts_for_each_pattern.unwrap_or(false)
                    }
                    /// Returns whether this configuration has enabled byte classes or not.
                    pub fn get_byte_classes(&self) -> bool {
                        self.byte_classes.unwrap_or(true)
                    }
                    /// Returns whether this configuration has enabled heuristic Unicode word
                    pub fn get_unicode_word_boundary(&self) -> bool {
                        self.unicode_word_boundary.unwrap_or(false)
                    }
                    /// Returns whether this configuration will instruct the DFA to enter a
                    pub fn get_quit(&self, byte: u8) -> bool {
                        self.quitset.map_or(false, |q| q.contains(byte))
                    }
                    /// Returns whether this configuration will instruct the DFA to
                    pub fn get_specialize_start_states(&self) -> bool {
                        self.specialize_start_states.unwrap_or(false)
                    }
                    /// Returns the DFA size limit of this configuration if one was set.
                    pub fn get_dfa_size_limit(&self) -> Option<usize> {
                        self.dfa_size_limit.unwrap_or(None)
                    }
                    /// Returns the determinization size limit of this configuration if one
                    pub fn get_determinize_size_limit(&self) -> Option<usize> {
                        self.determinize_size_limit.unwrap_or(None)
                    }
                    /// Overwrite the default configuration such that the options in `o` are
                    pub fn overwrite(&self, o: Config) -> Config {
                        Config {
                            accelerate: o.accelerate.or(self.accelerate),
                            pre: o.pre.or_else(|| self.pre.clone()),
                            minimize: o.minimize.or(self.minimize),
                            match_kind: o.match_kind.or(self.match_kind),
                            start_kind: o.start_kind.or(self.start_kind),
                            starts_for_each_pattern: o
                                .starts_for_each_pattern
                                .or(self.starts_for_each_pattern),
                            byte_classes: o.byte_classes.or(self.byte_classes),
                            unicode_word_boundary: o
                                .unicode_word_boundary
                                .or(self.unicode_word_boundary),
                            quitset: o.quitset.or(self.quitset),
                            specialize_start_states: o
                                .specialize_start_states
                                .or(self.specialize_start_states),
                            dfa_size_limit: o.dfa_size_limit.or(self.dfa_size_limit),
                            determinize_size_limit: o
                                .determinize_size_limit
                                .or(self.determinize_size_limit),
                        }
                    }
                }
                /// A builder for constructing a deterministic finite automaton from regular
                #[derive(Clone, Debug)]
                pub struct Builder
                {
                    config: Config,
                    thompson: thompson::Compiler,
                }

                impl Builder
                {
                    /// Create a new dense DFA builder with the default configuration.
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                                    thompson: thompson::Compiler::new(),
                        }
                    }
                    /// Build a DFA from the given pattern.
                    pub fn build(&self, pattern: &str) -> Result<OwnedDFA, BuildError> {
                        self.build_many(&[pattern])
                    }
                    /// Build a DFA from the given patterns.
                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<OwnedDFA, BuildError> {
                        let nfa = self
                            .thompson
                            .clone()
                            .configure(
                                thompson::Config::new()
                                    .which_captures(thompson::WhichCaptures::None),
                            )
                            .build_many(patterns)
                            .map_err(BuildError::nfa)?;
                        self.build_from_nfa(&nfa)
                    }
                    /// Build a DFA from the given NFA.
                    pub fn build_from_nfa(
                        &self,
                        nfa: &thompson::NFA,
                    ) -> Result<OwnedDFA, BuildError> {
                        let mut quitset = self.config.quitset.unwrap_or(ByteSet::empty());
                        
                        if self.config.get_unicode_word_boundary()
                            && nfa.look_set_any().contains_word_unicode()
                        {
                            for b in 0x80..=0xFF {
                                quitset.add(b);
                            }
                        }
                        let classes = if !self.config.get_byte_classes() {
                            ByteClasses::singletons()
                        } else {
                            let mut set = nfa.byte_class_set().clone();
                            if !quitset.is_empty() {
                                set.add_set(&quitset);
                            }
                            set.byte_classes()
                        };

                        let mut dfa = DFA::initial(
                            classes,
                            nfa.pattern_len(),
                            self.config.get_starts(),
                            nfa.look_matcher(),
                            self.config.get_starts_for_each_pattern(),
                            self.config.get_prefilter().map(|p| p.clone()),
                            quitset,
                            Flags::from_nfa(&nfa),
                        )?;
                        determinize::Config::new()
                            .match_kind(self.config.get_match_kind())
                            .quit(quitset)
                            .dfa_size_limit(self.config.get_dfa_size_limit())
                            .determinize_size_limit(self.config.get_determinize_size_limit())
                            .run(nfa, &mut dfa)?;
                        
                        if self.config.get_minimize() {
                            dfa.minimize();
                        }
                        
                        if self.config.get_accelerate() {
                            dfa.accelerate();
                        }
                        
                        if !self.config.get_specialize_start_states() {
                            dfa.special.set_no_special_start_states();
                        }
                        // Look for and set the universal starting states.
                        dfa.set_universal_starts();
                        Ok(dfa)
                    }
                    /// Apply the given dense DFA configuration options to this builder.
                    pub fn configure(&mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }
                    /// Set the syntax configuration for this builder using
                    pub fn syntax
                    (
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.thompson.syntax(config);
                        self
                    }
                    /// Set the Thompson NFA configuration for this builder using
                    pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                        self.thompson.configure(config);
                        self
                    }
                }

                impl Default for Builder
                {
                    fn default() -> Builder {
                        Builder::new()
                    }
                }
                /// A convenience alias for an owned DFA. We use this particular instantiation
                pub type OwnedDFA = DFA<Vec<u32>>;
                /// A dense table-based deterministic finite automaton (DFA).
                #[derive(Clone)]
                pub struct DFA<T>
                {
                    /// The transition table for this DFA. This includes the transitions
                    tt: TransitionTable<T>,
                    /// The set of starting state identifiers for this DFA. The starting state
                    st: StartTable<T>,
                    /// The set of match states and the patterns that match for each
                    ms: MatchStates<T>,
                    /// Information about which states are "special." Special states are states
                    special: Special,
                    /// The accelerators for this DFA.
                    accels: Accels<T>,
                    /// Any prefilter attached to this DFA.
                    pre: Option<Prefilter>,
                    /// The set of "quit" bytes for this DFA.
                    quitset: ByteSet,
                    /// Various flags describing the behavior of this DFA.
                    flags: Flags,
                }

                impl OwnedDFA
                {
                    /// Parse the given regular expression using a default configuration and
                    pub fn new(pattern: &str) -> Result<OwnedDFA, BuildError> {
                        Builder::new().build(pattern)
                    }
                    /// Parse the given regular expressions using a default configuration and
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<OwnedDFA, BuildError> {
                        Builder::new().build_many(patterns)
                    }
                }

                impl OwnedDFA
                {
                    /// Create a new DFA that matches every input.
                    pub fn always_match() -> Result<OwnedDFA, BuildError> {
                        let nfa = thompson::NFA::always_match();
                        Builder::new().build_from_nfa(&nfa)
                    }
                    /// Create a new DFA that never matches any input.
                    pub fn never_match() -> Result<OwnedDFA, BuildError> {
                        let nfa = thompson::NFA::never_match();
                        Builder::new().build_from_nfa(&nfa)
                    }
                    /// Create an initial DFA with the given equivalence classes, pattern
                    fn initial(
                        classes: ByteClasses,
                        pattern_len: usize,
                        starts: StartKind,
                        lookm: &LookMatcher,
                        starts_for_each_pattern: bool,
                        pre: Option<Prefilter>,
                        quitset: ByteSet,
                        flags: Flags,
                    ) -> Result<OwnedDFA, BuildError> {
                        let start_pattern_len =
                            if starts_for_each_pattern { Some(pattern_len) } else { None };
                        Ok(DFA {
                            tt: TransitionTable::minimal(classes),
                            st: StartTable::dead(starts, lookm, start_pattern_len)?,
                            ms: MatchStates::empty(pattern_len),
                            special: Special::new(),
                            accels: Accels::empty(),
                            pre,
                            quitset,
                            flags,
                        })
                    }
                }

                impl DFA<&[u32]>
                {
                    /// Return a new default dense DFA compiler configuration.
                    pub fn config() -> Config {
                        Config::new()
                    }
                    /// Create a new dense DFA builder with the default configuration.
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                }

                impl<T: AsRef<[u32]>> DFA<T>
                {
                    /// Cheaply return a borrowed version of this dense DFA. Specifically,
                    pub fn as_ref(&self) -> DFA<&'_ [u32]> {
                        DFA {
                            tt: self.tt.as_ref(),
                            st: self.st.as_ref(),
                            ms: self.ms.as_ref(),
                            special: self.special,
                            accels: self.accels(),
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }
                    /// Return an owned version of this sparse DFA. Specifically, the DFA
                        pub fn to_owned(&self) -> OwnedDFA {
                        DFA {
                            tt: self.tt.to_owned(),
                            st: self.st.to_owned(),
                            ms: self.ms.to_owned(),
                            special: self.special,
                            accels: self.accels().to_owned(),
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }
                    /// Returns the starting state configuration for this DFA.
                    pub fn start_kind(&self) -> StartKind {
                        self.st.kind
                    }
                    /// Returns the start byte map used for computing the `Start` configuration
                    pub fn start_map(&self) -> &StartByteMap {
                        &self.st.start_map
                    }
                    /// Returns true only if this DFA has starting states for each pattern.
                    pub fn starts_for_each_pattern(&self) -> bool {
                        self.st.pattern_len.is_some()
                    }
                    /// Returns the equivalence classes that make up the alphabet for this DFA.
                    pub fn byte_classes(&self) -> &ByteClasses {
                        &self.tt.classes
                    }
                    /// Returns the total number of elements in the alphabet for this DFA.
                    pub fn alphabet_len(&self) -> usize {
                        self.tt.alphabet_len()
                    }
                    /// Returns the total stride for every state in this DFA, expressed as the
                    pub fn stride2(&self) -> usize {
                        self.tt.stride2
                    }
                    /// Returns the total stride for every state in this DFA. This corresponds
                    pub fn stride(&self) -> usize {
                        self.tt.stride()
                    }
                    /// Returns the memory usage, in bytes, of this DFA.
                    pub fn memory_usage(&self) -> usize {
                        self.tt.memory_usage()
                            + self.st.memory_usage()
                            + self.ms.memory_usage()
                            + self.accels.memory_usage()
                    }
                }
                /// Routines for converting a dense DFA to other representations, such as
                impl<T: AsRef<[u32]>> DFA<T>
                {
                    /// Convert this dense DFA to a sparse DFA.
                        pub fn to_sparse(&self) -> Result<sparse::DFA<Vec<u8>>, BuildError> {
                        sparse::DFA::from_dense(self)
                    }
                    /// Serialize this DFA as raw bytes to a `Vec<u8>` in little endian
                        pub fn to_bytes_little_endian(&self) -> (Vec<u8>, usize) {
                        self.to_bytes::<wire::LE>()
                    }
                    /// Serialize this DFA as raw bytes to a `Vec<u8>` in big endian
                        pub fn to_bytes_big_endian(&self) -> (Vec<u8>, usize) {
                        self.to_bytes::<wire::BE>()
                    }
                    /// Serialize this DFA as raw bytes to a `Vec<u8>` in native endian
                        pub fn to_bytes_native_endian(&self) -> (Vec<u8>, usize) {
                        self.to_bytes::<wire::NE>()
                    }
                    /// The implementation of the public `to_bytes` serialization methods,
                        fn to_bytes<E: Endian>(&self) -> (Vec<u8>, usize) {
                        let len = self.write_to_len();
                        let (mut buf, padding) = wire::alloc_aligned_buffer::<u32>(len);
                        self.as_ref().write_to::<E>(&mut buf[padding..]).unwrap();
                        (buf, padding)
                    }
                    /// Serialize this DFA as raw bytes to the given slice, in little endian
                    pub fn write_to_little_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        self.as_ref().write_to::<wire::LE>(dst)
                    }
                    /// Serialize this DFA as raw bytes to the given slice, in big endian
                    pub fn write_to_big_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        self.as_ref().write_to::<wire::BE>(dst)
                    }
                    /// Serialize this DFA as raw bytes to the given slice, in native endian
                    pub fn write_to_native_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        self.as_ref().write_to::<wire::NE>(dst)
                    }
                    /// Return the total number of bytes required to serialize this DFA.
                    pub fn write_to_len(&self) -> usize {
                        wire::write_label_len(LABEL)
                        + wire::write_endianness_check_len()
                        + wire::write_version_len()
                        + size_of::<u32>() // unused, intended for future flexibility
                        + self.flags.write_to_len()
                        + self.tt.write_to_len()
                        + self.st.write_to_len()
                        + self.ms.write_to_len()
                        + self.special.write_to_len()
                        + self.accels.write_to_len()
                        + self.quitset.write_to_len()
                    }
                }

                impl<'a> DFA<&'a [u32]>
                {
                    /// Safely deserialize a DFA with a specific state identifier
                    pub fn from_bytes(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u32]>, usize), DeserializeError> {
                        let (dfa, nread) = unsafe { DFA::from_bytes_unchecked(slice)? };
                        dfa.tt.validate(&dfa)?;
                        dfa.st.validate(&dfa)?;
                        dfa.ms.validate(&dfa)?;
                        dfa.accels.validate()?;
                        for state in dfa.states()
                        {
                            if dfa.is_accel_state(state.id()) {
                                let index = dfa.accelerator_index(state.id());
                                
                                if index >= dfa.accels.len() {
                                    return Err(DeserializeError::generic(
                                        "found DFA state with invalid accelerator index",
                                    ));
                                }
                                let needles = dfa.accels.needles(index);
                                
                                if !(1 <= needles.len() && needles.len() <= 3) {
                                    return Err(DeserializeError::generic(
                                        "accelerator needles has invalid length",
                                    ));
                                }
                            }
                        }
                        Ok((dfa, nread))
                    }
                    /// Deserialize a DFA with a specific state identifier representation in
                    pub unsafe fn from_bytes_unchecked(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u32]>, usize), DeserializeError> {
                        let mut nr = 0;

                        nr += wire::skip_initial_padding(slice);
                        wire::check_alignment::<StateID>(&slice[nr..])?;
                        nr += wire::read_label(&slice[nr..], LABEL)?;
                        nr += wire::read_endianness_check(&slice[nr..])?;
                        nr += wire::read_version(&slice[nr..], VERSION)?;

                        let _unused = wire::try_read_u32(&slice[nr..], "unused space")?;
                        nr += size_of::<u32>();

                        let (flags, nread) = Flags::from_bytes(&slice[nr..])?;
                        nr += nread;

                        let (tt, nread) = TransitionTable::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (st, nread) = StartTable::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (ms, nread) = MatchStates::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (special, nread) = Special::from_bytes(&slice[nr..])?;
                        nr += nread;
                        special.validate_state_len(tt.len(), tt.stride2)?;

                        let (accels, nread) = Accels::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (quitset, nread) = ByteSet::from_bytes(&slice[nr..])?;
                        nr += nread;

                        // Prefilters don't support serialization, so they're always absent.
                        let pre = None;
                        Ok((DFA { tt, st, ms, special, accels, pre, quitset, flags }, nr))
                    }
                    /// The implementation of the public `write_to` serialization methods,
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("dense DFA"));
                        }
                        dst = &mut dst[..nwrite];

                        let mut nw = 0;
                        nw += wire::write_label(LABEL, &mut dst[nw..])?;
                        nw += wire::write_endianness_check::<E>(&mut dst[nw..])?;
                        nw += wire::write_version::<E>(VERSION, &mut dst[nw..])?;
                        nw += {
                            // Currently unused, intended for future flexibility
                            E::write_u32(0, &mut dst[nw..]);
                            size_of::<u32>()
                        };
                        nw += self.flags.write_to::<E>(&mut dst[nw..])?;
                        nw += self.tt.write_to::<E>(&mut dst[nw..])?;
                        nw += self.st.write_to::<E>(&mut dst[nw..])?;
                        nw += self.ms.write_to::<E>(&mut dst[nw..])?;
                        nw += self.special.write_to::<E>(&mut dst[nw..])?;
                        nw += self.accels.write_to::<E>(&mut dst[nw..])?;
                        nw += self.quitset.write_to::<E>(&mut dst[nw..])?;
                        Ok(nw)
                    }
                }
                /// Other routines that work for all `T`.
                impl<T> DFA<T>
                {
                    /// Set or unset the prefilter attached to this DFA.
                    pub fn set_prefilter(&mut self, prefilter: Option<Prefilter>) {
                        self.pre = prefilter
                    }
                }
                impl OwnedDFA
                {
                    /// Add a start state of this DFA.
                    pub fn set_start_state
                    (
                        &mut self,
                        anchored: Anchored,
                        start: Start,
                        id: StateID,
                    ) {
                        assert!(self.tt.is_valid(id), "invalid start state");
                        self.st.set_start(anchored, start, id);
                    }
                    /// Set the given transition to this DFA. Both the `from` and `to` states
                    pub fn set_transition
                    (
                        &mut self,
                        from: StateID,
                        byte: alphabet::Unit,
                        to: StateID,
                    ) {
                        self.tt.set(from, byte, to);
                    }
                    /// An empty state (a state where all transitions lead to a dead state)
                    pub fn add_empty_state(&mut self) -> Result<StateID, BuildError> {
                        self.tt.add_empty_state()
                    }
                    /// Swap the two states given in the transition table.
                    pub fn swap_states(&mut self, id1: StateID, id2: StateID) {
                        self.tt.swap(id1, id2);
                    }
                    /// Remap all of the state identifiers in this DFA according to the map
                    pub fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
                        for sid in self.tt.table_mut().iter_mut() {
                            *sid = map(*sid);
                        }
                        for sid in self.st.table_mut().iter_mut() {
                            *sid = map(*sid);
                        }
                    }
                    /// Remap the transitions for the state given according to the function
                    pub fn remap_state
                    (
                        &mut self,
                        id: StateID,
                        map: impl Fn(StateID) -> StateID,
                    ) {
                        self.tt.remap(id, map);
                    }
                    /// Truncate the states in this DFA to the given length.
                    pub fn truncate_states(&mut self, len: usize) {
                        self.tt.truncate(len);
                    }
                    /// Minimize this DFA in place using Hopcroft's algorithm.
                    pub fn minimize(&mut self) {
                        Minimizer::new(self).run();
                    }
                    /// Updates the match state pattern ID map to use the one provided.
                    pub fn set_pattern_map
                    (
                        &mut self,
                        map: &BTreeMap<StateID, Vec<PatternID>>,
                    ) -> Result<(), BuildError> {
                        self.ms = self.ms.new_with_map(map)?;
                        Ok(())
                    }
                    /// Find states that have a small number of non-loop transitions and mark
                    pub fn accelerate(&mut self) {
                        // dead and quit states can never be accelerated.
                        if self.state_len() <= 2 {
                            return;
                        }

                        // Go through every state and record their accelerator, if possible.
                        let mut accels = BTreeMap::new();
                        let (mut cmatch, mut cstart, mut cnormal) = (0, 0, 0);
                        for state in self.states()
                        {
                            if let Some(accel) = state.accelerate(self.byte_classes()) {
                                debug!(
                                    "accelerating full DFA state {}: {:?}",
                                    state.id().as_usize(),
                                    accel,
                                );
                                accels.insert(state.id(), accel);
                                
                                if self.is_match_state(state.id()) {
                                    cmatch += 1;
                                } else if self.is_start_state(state.id()) {
                                    cstart += 1;
                                } else {
                                    assert!(!self.is_dead_state(state.id()));
                                    assert!(!self.is_quit_state(state.id()));
                                    cnormal += 1;
                                }
                            }
                        }
                        // If no states were able to be accelerated, then we're done.
                        if accels.is_empty() {
                            return;
                        }
                        let original_accels_len = accels.len();
                        let mut remapper = Remapper::new(self);
                        let mut new_matches = self.ms.to_map(self);
                        self.special.min_accel = StateID::MAX;
                        self.special.max_accel = StateID::ZERO;
                        let update_special_accel =
                            |special: &mut Special, accel_id: StateID| {
                                special.min_accel = cmp::min(special.min_accel, accel_id);
                                special.max_accel = cmp::max(special.max_accel, accel_id);
                            };
                        
                        if cmatch > 0 && self.special.matches() {
                            let mut next_id = self.special.max_match;
                            let mut cur_id = next_id;
                            while cur_id >= self.special.min_match {
                                if let Some(accel) = accels.remove(&cur_id) {
                                    accels.insert(next_id, accel);
                                    update_special_accel(&mut self.special, next_id);

                                    // No need to do any actual swapping for equivalent IDs.
                                    if cur_id != next_id {
                                        remapper.swap(self, cur_id, next_id);

                                        // Swap pattern IDs for match states.
                                        let cur_pids = new_matches.remove(&cur_id).unwrap();
                                        let next_pids = new_matches.remove(&next_id).unwrap();
                                        new_matches.insert(cur_id, next_pids);
                                        new_matches.insert(next_id, cur_pids);
                                    }
                                    next_id = self.tt.prev_state_id(next_id);
                                }
                                cur_id = self.tt.prev_state_id(cur_id);
                            }
                        }
                        
                        if cnormal > 0 {
                            // our next available starting and normal states for swapping.
                            let mut next_start_id = self.special.min_start;
                            let mut cur_id = self.to_state_id(self.state_len() - 1);
                            // This is guaranteed to exist since cnormal > 0.
                            let mut next_norm_id =
                                self.tt.next_state_id(self.special.max_start);
                            while cur_id >= next_norm_id {
                                if let Some(accel) = accels.remove(&cur_id) {
                                    remapper.swap(self, next_start_id, cur_id);
                                    remapper.swap(self, next_norm_id, cur_id);
                                    if let Some(accel2) = accels.remove(&next_norm_id) {
                                        accels.insert(cur_id, accel2);
                                    }
                                    if let Some(accel2) = accels.remove(&next_start_id) {
                                        accels.insert(next_norm_id, accel2);
                                    }
                                    accels.insert(next_start_id, accel);
                                    update_special_accel(&mut self.special, next_start_id);
                                    // Our start range shifts one to the right now.
                                    self.special.min_start =
                                        self.tt.next_state_id(self.special.min_start);
                                    self.special.max_start =
                                        self.tt.next_state_id(self.special.max_start);
                                    next_start_id = self.tt.next_state_id(next_start_id);
                                    next_norm_id = self.tt.next_state_id(next_norm_id);
                                }
                                if !accels.contains_key(&cur_id) {
                                    cur_id = self.tt.prev_state_id(cur_id);
                                }
                            }
                        }
                        
                        if cstart > 0 {
                            let mut next_id = self.special.min_start;
                            let mut cur_id = next_id;
                            while cur_id <= self.special.max_start {
                                if let Some(accel) = accels.remove(&cur_id) {
                                    remapper.swap(self, cur_id, next_id);
                                    accels.insert(next_id, accel);
                                    update_special_accel(&mut self.special, next_id);
                                    next_id = self.tt.next_state_id(next_id);
                                }
                                cur_id = self.tt.next_state_id(cur_id);
                            }
                        }

                        // Remap all transitions in our DFA and assert some things.
                        remapper.remap(self);
                        self.set_pattern_map(&new_matches).unwrap();
                        self.special.set_max();
                        self.special.validate().expect("special state ranges should validate");
                        self.special
                            .validate_state_len(self.state_len(), self.stride2())
                            .expect(
                                "special state ranges should be consistent with state length",
                            );
                        assert_eq!(
                            self.special.accel_len(self.stride()),
                            original_accels_len,
                            "mismatch with expected number of accelerated states",
                        );
                        let mut prev: Option<StateID> = None;
                        for (id, accel) in accels {
                            assert!(prev.map_or(true, |p| self.tt.next_state_id(p) == id));
                            prev = Some(id);
                            self.accels.add(accel);
                        }
                    }
                    /// Shuffle the states in this DFA so that starting states, match
                    pub fn shuffle
                    (
                        &mut self,
                        mut matches: BTreeMap<StateID, Vec<PatternID>>,
                    ) -> Result<(), BuildError> {
                        // The determinizer always adds a quit state and it is always second.
                        self.special.quit_id = self.to_state_id(1);
                        
                        if self.state_len() <= 2 {
                            self.special.set_max();
                            
                            return Ok(());
                        }
                        let mut is_start: BTreeSet<StateID> = BTreeSet::new();
                        for (start_id, _, _) in self.starts()
                        {
                            if start_id == DEAD {
                                continue;
                            }
                            assert!(
                                !matches.contains_key(&start_id),
                                "{start_id:?} is both a start and a match state, \
                                which is not allowed",
                            );
                            is_start.insert(start_id);
                        }
                        let mut remapper = Remapper::new(self);

                        // Shuffle matching states.
                        if matches.is_empty() {
                            self.special.min_match = DEAD;
                            self.special.max_match = DEAD;
                        } else {
                            let mut next_id = self.to_state_id(2);
                            let mut new_matches = BTreeMap::new();
                            self.special.min_match = next_id;
                            for (id, pids) in matches {
                                remapper.swap(self, next_id, id);
                                new_matches.insert(next_id, pids);
                                // If we swapped a start state, then update our set.
                                if is_start.contains(&next_id) {
                                    is_start.remove(&next_id);
                                    is_start.insert(id);
                                }
                                next_id = self.tt.next_state_id(next_id);
                            }
                            matches = new_matches;
                            self.special.max_match = cmp::max(
                                self.special.min_match,
                                self.tt.prev_state_id(next_id),
                            );
                        }

                        // Shuffle starting states.
                        {
                            let mut next_id = self.to_state_id(2);
                            if self.special.matches() {
                                next_id = self.tt.next_state_id(self.special.max_match);
                            }
                            self.special.min_start = next_id;
                            for id in is_start {
                                remapper.swap(self, next_id, id);
                                next_id = self.tt.next_state_id(next_id);
                            }
                            self.special.max_start = cmp::max(
                                self.special.min_start,
                                self.tt.prev_state_id(next_id),
                            );
                        }

                        // Finally remap all transitions in our DFA.
                        remapper.remap(self);
                        self.set_pattern_map(&matches)?;
                        self.special.set_max();
                        self.special.validate().expect("special state ranges should validate");
                        self.special
                            .validate_state_len(self.state_len(), self.stride2())
                            .expect(
                                "special state ranges should be consistent with state length",
                            );
                        Ok(())
                    }
                    /// Checks whether there are universal start states (both anchored and
                    fn set_universal_starts(&mut self) {
                        assert_eq!(6, Start::len(), "expected 6 start configurations");

                        let start_id = |dfa: &mut OwnedDFA,
                                        anchored: Anchored,
                                        start: Start| {
                            dfa.st.start(anchored, start).expect("valid Input configuration")
                        };
                        
                        if self.start_kind().has_unanchored() {
                            let anchor = Anchored::No;
                            let sid = start_id(self, anchor, Start::NonWordByte);
                            if sid == start_id(self, anchor, Start::WordByte)
                                && sid == start_id(self, anchor, Start::Text)
                                && sid == start_id(self, anchor, Start::LineLF)
                                && sid == start_id(self, anchor, Start::LineCR)
                                && sid == start_id(self, anchor, Start::CustomLineTerminator)
                            {
                                self.st.universal_start_unanchored = Some(sid);
                            }
                        }
                        
                        if self.start_kind().has_anchored() {
                            let anchor = Anchored::Yes;
                            let sid = start_id(self, anchor, Start::NonWordByte);
                            if sid == start_id(self, anchor, Start::WordByte)
                                && sid == start_id(self, anchor, Start::Text)
                                && sid == start_id(self, anchor, Start::LineLF)
                                && sid == start_id(self, anchor, Start::LineCR)
                                && sid == start_id(self, anchor, Start::CustomLineTerminator)
                            {
                                self.st.universal_start_anchored = Some(sid);
                            }
                        }
                    }
                }
                
                impl<T: AsRef<[u32]>> DFA<T>
                {
                    /// Return the info about special states.
                    pub fn special(&self) -> &Special {
                        &self.special
                    }
                    /// Return the info about special states as a mutable borrow.
                        pub fn special_mut(&mut self) -> &mut Special {
                        &mut self.special
                    }
                    /// Returns the quit set (may be empty) used by this DFA.
                    pub fn quitset(&self) -> &ByteSet {
                        &self.quitset
                    }
                    /// Returns the flags for this DFA.
                    pub fn flags(&self) -> &Flags {
                        &self.flags
                    }
                    /// Returns an iterator over all states in this DFA.
                    pub fn states(&self) -> StateIter<'_, T> {
                        self.tt.states()
                    }
                    /// Return the total number of states in this DFA. Every DFA has at least
                    pub fn state_len(&self) -> usize {
                        self.tt.len()
                    }
                    /// Return an iterator over all pattern IDs for the given match state.
                        pub fn pattern_id_slice(&self, id: StateID) -> &[PatternID] {
                        assert!(self.is_match_state(id));
                        self.ms.pattern_id_slice(self.match_state_index(id))
                    }
                    /// Return the total number of pattern IDs for the given match state.
                    pub fn match_pattern_len(&self, id: StateID) -> usize {
                        assert!(self.is_match_state(id));
                        self.ms.pattern_len(self.match_state_index(id))
                    }
                    /// Returns the total number of patterns matched by this DFA.
                    pub fn pattern_len(&self) -> usize {
                        self.ms.pattern_len
                    }
                    /// Returns a map from match state ID to a list of pattern IDs that match
                        pub fn pattern_map(&self) -> BTreeMap<StateID, Vec<PatternID>> {
                        self.ms.to_map(self)
                    }
                    /// Returns the ID of the quit state for this DFA.
                        pub fn quit_id(&self) -> StateID {
                        self.to_state_id(1)
                    }
                    /// Convert the given state identifier to the state's index. The state's
                    pub fn to_index(&self, id: StateID) -> usize {
                        self.tt.to_index(id)
                    }
                    /// Convert an index to a state (in the range 0..self.state_len()) to an
                        pub fn to_state_id(&self, index: usize) -> StateID {
                        self.tt.to_state_id(index)
                    }
                    /// Return the table of state IDs for this DFA's start states.
                    pub fn starts(&self) -> StartStateIter<'_> {
                        self.st.iter()
                    }
                    /// Returns the index of the match state for the given ID. If the
                    #[inline( always )]
                    fn match_state_index(&self, id: StateID) -> usize {
                        debug_assert!(self.is_match_state(id));
                        let min = self.special().min_match.as_usize();
                        self.to_index(StateID::new_unchecked(id.as_usize() - min))
                    }
                    /// Returns the index of the accelerator state for the given ID. If the
                    fn accelerator_index(&self, id: StateID) -> usize {
                        let min = self.special().min_accel.as_usize();
                        self.to_index(StateID::new_unchecked(id.as_usize() - min))
                    }
                    /// Return the accelerators for this DFA.
                    fn accels(&self) -> Accels<&[u32]> {
                        self.accels.as_ref()
                    }
                    /// Return this DFA's transition table as a slice.
                    fn trans(&self) -> &[StateID] {
                        self.tt.table()
                    }
                }

                impl<T: AsRef<[u32]>> fmt::Debug for DFA<T> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        writeln!(f, "dense::DFA(")?;
                        for state in self.states() {
                            fmt_state_indicator(f, self, state.id())?;
                            let id = if f.alternate() {
                                state.id().as_usize()
                            } else {
                                self.to_index(state.id())
                            };
                            write!(f, "{id:06?}: ")?;
                            state.fmt(f)?;
                            write!(f, "\n")?;
                        }
                        writeln!(f, "")?;
                        for (i, (start_id, anchored, sty)) in self.starts().enumerate() {
                            let id = if f.alternate() {
                                start_id.as_usize()
                            } else {
                                self.to_index(start_id)
                            };
                            if i % self.st.stride == 0 {
                                match anchored {
                                    Anchored::No => writeln!(f, "START-GROUP(unanchored)")?,
                                    Anchored::Yes => writeln!(f, "START-GROUP(anchored)")?,
                                    Anchored::Pattern(pid) => {
                                        writeln!(f, "START_GROUP(pattern: {pid:?})")?
                                    }
                                }
                            }
                            writeln!(f, "  {sty:?} => {id:06?}")?;
                        }
                        
                        if self.pattern_len() > 1 {
                            writeln!(f, "")?;
                            for i in 0..self.ms.len() {
                                let id = self.ms.match_state_id(self, i);
                                let id = if f.alternate() {
                                    id.as_usize()
                                } else {
                                    self.to_index(id)
                                };
                                write!(f, "MATCH({id:06?}): ")?;
                                for (i, &pid) in self.ms.pattern_id_slice(i).iter().enumerate()
                                {
                                    if i > 0 {
                                        write!(f, ", ")?;
                                    }
                                    write!(f, "{pid:?}")?;
                                }
                                writeln!(f, "")?;
                            }
                        }
                        writeln!(f, "state length: {:?}", self.state_len())?;
                        writeln!(f, "pattern length: {:?}", self.pattern_len())?;
                        writeln!(f, "flags: {:?}", self.flags)?;
                        writeln!(f, ")")?;
                        Ok(())
                    }
                }
                
                unsafe impl<T: AsRef<[u32]>> Automaton for DFA<T> 
                {
                    #[inline( always )]
                    fn is_special_state(&self, id: StateID) -> bool {
                        self.special.is_special_state(id)
                    }

                    #[inline( always )]
                    fn is_dead_state(&self, id: StateID) -> bool {
                        self.special.is_dead_state(id)
                    }

                    #[inline( always )]
                    fn is_quit_state(&self, id: StateID) -> bool {
                        self.special.is_quit_state(id)
                    }

                    #[inline( always )]
                    fn is_match_state(&self, id: StateID) -> bool {
                        self.special.is_match_state(id)
                    }

                    #[inline( always )]
                    fn is_start_state(&self, id: StateID) -> bool {
                        self.special.is_start_state(id)
                    }

                    #[inline( always )]
                    fn is_accel_state(&self, id: StateID) -> bool {
                        self.special.is_accel_state(id)
                    }

                    #[inline( always )]
                    fn next_state(&self, current: StateID, input: u8) -> StateID {
                        let input = self.byte_classes().get(input);
                        let o = current.as_usize() + usize::from(input);
                        self.trans()[o]
                    }

                    #[inline( always )]
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        byte: u8,
                    ) -> StateID {
                        let class = self.byte_classes().get(byte);
                        let o = current.as_usize() + usize::from(class);
                        let next = *self.trans().get_unchecked(o);
                        next
                    }

                    #[inline( always )]
                    fn next_eoi_state(&self, current: StateID) -> StateID {
                        let eoi = self.byte_classes().eoi().as_usize();
                        let o = current.as_usize() + eoi;
                        self.trans()[o]
                    }

                    #[inline( always )]
                    fn pattern_len(&self) -> usize {
                        self.ms.pattern_len
                    }

                    #[inline( always )]
                    fn match_len(&self, id: StateID) -> usize {
                        self.match_pattern_len(id)
                    }

                    #[inline( always )]
                    fn match_pattern(&self, id: StateID, match_index: usize) -> PatternID {
                        if self.ms.pattern_len == 1 {
                            return PatternID::ZERO;
                        }
                        let state_index = self.match_state_index(id);
                        self.ms.pattern_id(state_index, match_index)
                    }

                    #[inline( always )]
                    fn has_empty(&self) -> bool {
                        self.flags.has_empty
                    }

                    #[inline( always )]
                    fn is_utf8(&self) -> bool {
                        self.flags.is_utf8
                    }

                    #[inline( always )]
                    fn is_always_start_anchored(&self) -> bool {
                        self.flags.is_always_start_anchored
                    }

                    #[inline( always )]
                    fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError> {
                        let anchored = config.get_anchored();
                        let start = match config.get_look_behind() {
                            None => Start::Text,
                            Some(byte) => {
                                if !self.quitset.is_empty() && self.quitset.contains(byte) {
                                    return Err(StartError::quit(byte));
                                }
                                self.st.start_map.get(byte)
                            }
                        };
                        self.st.start(anchored, start)
                    }

                    #[inline( always )]
                    fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {
                        match mode {
                            Anchored::No => self.st.universal_start_unanchored,
                            Anchored::Yes => self.st.universal_start_anchored,
                            Anchored::Pattern(_) => None,
                        }
                    }

                    #[inline( always )]
                    fn accelerator(&self, id: StateID) -> &[u8] {
                        if !self.is_accel_state(id) {
                            return &[];
                        }
                        self.accels.needles(self.accelerator_index(id))
                    }

                    #[inline( always )]
                    fn get_prefilter(&self) -> Option<&Prefilter> {
                        self.pre.as_ref()
                    }
                }
                /// The transition table portion of a dense DFA.
                #[derive(Clone)]
                pub struct TransitionTable<T>
                {
                    /// A contiguous region of memory representing the transition table in
                    table: T,
                    /// A set of equivalence classes, where a single equivalence class
                    classes: ByteClasses,
                    /// The stride of each DFA state, expressed as a power-of-two exponent.
                    stride2: usize,
                }

                impl<'a> TransitionTable<&'a [u32]>
                {
                    /// Deserialize a transition table starting at the beginning of `slice`.
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(TransitionTable<&'a [u32]>, usize), DeserializeError> {
                        let slice_start = slice.as_ptr().as_usize();

                        let (state_len, nr) =
                            wire::try_read_u32_as_usize(slice, "state length")?;
                        slice = &slice[nr..];

                        let (stride2, nr) = wire::try_read_u32_as_usize(slice, "stride2")?;
                        slice = &slice[nr..];

                        let (classes, nr) = ByteClasses::from_bytes(slice)?;
                        slice = &slice[nr..];
                        
                        if stride2 > 9 {
                            return Err(DeserializeError::generic(
                                "dense DFA has invalid stride2 (too big)",
                            ));
                        }
                        
                        if stride2 < 1 {
                            return Err(DeserializeError::generic(
                                "dense DFA has invalid stride2 (too small)",
                            ));
                        }
                        // This is OK since 1 <= stride2 <= 9.
                        let stride =
                            1usize.checked_shl(u32::try_from(stride2).unwrap()).unwrap();
                        
                        if classes.alphabet_len() > stride {
                            return Err(DeserializeError::generic(
                                "alphabet size cannot be bigger than transition table stride",
                            ));
                        }

                        let trans_len =
                            wire::shl(state_len, stride2, "dense table transition length")?;
                        let table_bytes_len = wire::mul(
                            trans_len,
                            StateID::SIZE,
                            "dense table state byte length",
                        )?;
                        wire::check_slice_len(slice, table_bytes_len, "transition table")?;
                        wire::check_alignment::<StateID>(slice)?;
                        let table_bytes = &slice[..table_bytes_len];
                        slice = &slice[table_bytes_len..];
                        let table = ::slice::from_raw_parts(
                            table_bytes.as_ptr().cast::<u32>(),
                            trans_len,
                        );
                        let tt = TransitionTable { table, classes, stride2 };
                        Ok((tt, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl TransitionTable<Vec<u32>>
                {
                    /// Create a minimal transition table with just two states: a dead state
                    fn minimal(classes: ByteClasses) -> TransitionTable<Vec<u32>> {
                        let mut tt = TransitionTable {
                            table: vec![],
                            classes,
                            stride2: classes.stride2(),
                        };
                        // Two states, regardless of alphabet size, can always fit into u32.
                        tt.add_empty_state().unwrap(); // dead state
                        tt.add_empty_state().unwrap(); // quit state
                        tt
                    }
                    /// Set a transition in this table. Both the `from` and `to` states must
                    fn set(&mut self, from: StateID, unit: alphabet::Unit, to: StateID) {
                        assert!(self.is_valid(from), "invalid 'from' state");
                        assert!(self.is_valid(to), "invalid 'to' state");
                        self.table[from.as_usize() + self.classes.get_by_unit(unit)] =
                            to.as_u32();
                    }
                    /// Add an empty state (a state where all transitions lead to a dead state)
                    fn add_empty_state(&mut self) -> Result<StateID, BuildError> {
                        let next = self.table.len();
                        let id =
                            StateID::new(next).map_err(|_| BuildError::too_many_states())?;
                        self.table.extend(iter::repeat(0).take(self.stride()));
                        Ok(id)
                    }
                    /// Swap the two states given in this transition table.
                    fn swap(&mut self, id1: StateID, id2: StateID) {
                        assert!(self.is_valid(id1), "invalid 'id1' state: {id1:?}");
                        assert!(self.is_valid(id2), "invalid 'id2' state: {id2:?}");
                        for b in 0..self.classes.alphabet_len() {
                            self.table.swap(id1.as_usize() + b, id2.as_usize() + b);
                        }
                    }
                    /// Remap the transitions for the state given according to the function
                    fn remap(&mut self, id: StateID, map: impl Fn(StateID) -> StateID) {
                        for byte in 0..self.alphabet_len() {
                            let i = id.as_usize() + byte;
                            let next = self.table()[i];
                            self.table_mut()[id.as_usize() + byte] = map(next);
                        }
                    }
                    /// Truncate the states in this transition table to the given length.
                    fn truncate(&mut self, len: usize) {
                        self.table.truncate(len << self.stride2);
                    }
                }

                impl<T: AsRef<[u32]>> TransitionTable<T>
                {
                    /// Writes a serialized form of this transition table to the buffer given.
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("transition table"));
                        }
                        dst = &mut dst[..nwrite];
                        E::write_u32(u32::try_from(self.len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(u32::try_from(self.stride2).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];

                        // write byte class map
                        let n = self.classes.write_to(dst)?;
                        dst = &mut dst[n..];

                        // write actual transitions
                        for &sid in self.table() {
                            let n = wire::write_state_id::<E>(sid, &mut dst);
                            dst = &mut dst[n..];
                        }
                        Ok(nwrite)
                    }
                    /// Returns the number of bytes the serialized form of this transition
                    fn write_to_len(&self) -> usize {
                        size_of::<u32>()   // state length
                        + size_of::<u32>() // stride2
                        + self.classes.write_to_len()
                        + (self.table().len() * StateID::SIZE)
                    }
                    /// Validates that every state ID in this transition table is valid.
                    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {
                        let sp = &dfa.special;
                        for state in self.states()
                        {
                            if sp.is_special_state(state.id()) {
                                let is_actually_special = sp.is_dead_state(state.id())
                                    || sp.is_quit_state(state.id())
                                    || sp.is_match_state(state.id())
                                    || sp.is_start_state(state.id())
                                    || sp.is_accel_state(state.id());
                                
                                if !is_actually_special {
                                    // This is kind of a cryptic error message...
                                    return Err(DeserializeError::generic(
                                        "found dense state tagged as special but \
                                        wasn't actually special",
                                    ));
                                }
                                if sp.is_match_state(state.id())
                                    && dfa.match_len(state.id()) == 0
                                {
                                    return Err(DeserializeError::generic(
                                        "found match state with zero pattern IDs",
                                    ));
                                }
                            }
                            
                            for (_, to) in state.transitions()
                            {
                                if !self.is_valid(to) {
                                    return Err(DeserializeError::generic(
                                        "found invalid state ID in transition table",
                                    ));
                                }
                            }
                        }
                        Ok(())
                    }
                    /// Converts this transition table to a borrowed value.
                    fn as_ref(&self) -> TransitionTable<&'_ [u32]> {
                        TransitionTable {
                            table: self.table.as_ref(),
                            classes: self.classes.clone(),
                            stride2: self.stride2,
                        }
                    }
                    /// Converts this transition table to an owned value.
                        fn to_owned(&self) -> TransitionTable<Vec<u32>> {
                        TransitionTable {
                            table: self.table.as_ref().to_vec(),
                            classes: self.classes.clone(),
                            stride2: self.stride2,
                        }
                    }
                    /// Return the state for the given ID. If the given ID is not valid, then
                    fn state(&self, id: StateID) -> State<'_> {
                        assert!(self.is_valid(id));

                        let i = id.as_usize();
                        State {
                            id,
                            stride2: self.stride2,
                            transitions: &self.table()[i..i + self.alphabet_len()],
                        }
                    }
                    /// Returns an iterator over all states in this transition table.
                    fn states(&self) -> StateIter<'_, T> {
                        StateIter {
                            tt: self,
                            it: self.table().chunks(self.stride()).enumerate(),
                        }
                    }
                    /// Convert a state identifier to an index to a state (in the range
                    fn to_index(&self, id: StateID) -> usize {
                        id.as_usize() >> self.stride2
                    }
                    /// Convert an index to a state (in the range 0..self.len()) to an actual
                    fn to_state_id(&self, index: usize) -> StateID {
                        StateID::new_unchecked(index << self.stride2)
                    }
                    /// Returns the state ID for the state immediately following the one given.
                        fn next_state_id(&self, id: StateID) -> StateID {
                        self.to_state_id(self.to_index(id).checked_add(1).unwrap())
                    }
                    /// Returns the state ID for the state immediately preceding the one given.
                        fn prev_state_id(&self, id: StateID) -> StateID {
                        self.to_state_id(self.to_index(id).checked_sub(1).unwrap())
                    }
                    /// Returns the table as a slice of state IDs.
                    fn table(&self) -> &[StateID] {
                        wire::u32s_to_state_ids(self.table.as_ref())
                    }
                    /// Returns the total number of states in this transition table.
                    fn len(&self) -> usize {
                        self.table().len() >> self.stride2
                    }
                    /// Returns the total stride for every state in this DFA. This corresponds
                    fn stride(&self) -> usize {
                        1 << self.stride2
                    }
                    /// Returns the total number of elements in the alphabet for this
                    fn alphabet_len(&self) -> usize {
                        self.classes.alphabet_len()
                    }
                    /// Returns true if and only if the given state ID is valid for this
                    fn is_valid(&self, id: StateID) -> bool {
                        let id = id.as_usize();
                        id < self.table().len() && id % self.stride() == 0
                    }
                    /// Return the memory usage, in bytes, of this transition table.
                    fn memory_usage(&self) -> usize {
                        self.table().len() * StateID::SIZE
                    }
                }

                impl<T: AsMut<[u32]>> TransitionTable<T>
                {
                    /// Returns the table as a slice of state IDs.
                    fn table_mut(&mut self) -> &mut [StateID] {
                        wire::u32s_to_state_ids_mut(self.table.as_mut())
                    }
                }
                /// The set of all possible starting states in a DFA.
                #[derive(Clone)]
                pub struct StartTable<T>
                {
                    /// The initial start state IDs.
                    table: T,
                    /// The starting state configuration supported. When 'both', both
                    kind: StartKind,
                    /// The start state configuration for every possible byte.
                    start_map: StartByteMap,
                    /// The number of starting state IDs per pattern.
                    stride: usize,
                    /// The total number of patterns for which starting states are encoded.
                    pattern_len: Option<usize>,
                    /// The universal starting state for unanchored searches. This is only
                    universal_start_unanchored: Option<StateID>,
                    /// The universal starting state for anchored searches. This is only
                    universal_start_anchored: Option<StateID>,
                }

                impl StartTable<Vec<u32>>
                {
                    /// Create a valid set of start states all pointing to the dead state.
                    fn dead(
                        kind: StartKind,
                        lookm: &LookMatcher,
                        pattern_len: Option<usize>,
                    ) -> Result<StartTable<Vec<u32>>, BuildError> {
                        if let Some(len) = pattern_len {
                            assert!(len <= PatternID::LIMIT);
                        }
                        let stride = Start::len();
                        // OK because 2*4 is never going to overflow anything.
                        let starts_len = stride.checked_mul(2).unwrap();
                        let pattern_starts_len =
                            match stride.checked_mul(pattern_len.unwrap_or(0)) {
                                Some(x) => x,
                                None => return Err(BuildError::too_many_start_states()),
                            };
                        let table_len = match starts_len.checked_add(pattern_starts_len) {
                            Some(x) => x,
                            None => return Err(BuildError::too_many_start_states()),
                        };
                        
                        if let Err(_) = isize::try_from(table_len) {
                            return Err(BuildError::too_many_start_states());
                        }
                        let table = vec![DEAD.as_u32(); table_len];
                        let start_map = StartByteMap::new(lookm);
                        Ok(StartTable {
                            table,
                            kind,
                            start_map,
                            stride,
                            pattern_len,
                            universal_start_unanchored: None,
                            universal_start_anchored: None,
                        })
                    }
                }

                impl<'a> StartTable<&'a [u32]>
                {
                    /// Deserialize a table of start state IDs starting at the beginning of
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(StartTable<&'a [u32]>, usize), DeserializeError> {
                        let slice_start = slice.as_ptr().as_usize();

                        let (kind, nr) = StartKind::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (start_map, nr) = StartByteMap::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (stride, nr) =
                            wire::try_read_u32_as_usize(slice, "start table stride")?;
                        slice = &slice[nr..];
                        
                        if stride != Start::len() {
                            return Err(DeserializeError::generic(
                                "invalid starting table stride",
                            ));
                        }

                        let (maybe_pattern_len, nr) =
                            wire::try_read_u32_as_usize(slice, "start table patterns")?;
                        slice = &slice[nr..];
                        let pattern_len = if maybe_pattern_len.as_u32() == u32::MAX {
                            None
                        } else {
                            Some(maybe_pattern_len)
                        };
                        
                        if pattern_len.map_or(false, |len| len > PatternID::LIMIT) {
                            return Err(DeserializeError::generic(
                                "invalid number of patterns",
                            ));
                        }

                        let (universal_unanchored, nr) =
                            wire::try_read_u32(slice, "universal unanchored start")?;
                        slice = &slice[nr..];
                        let universal_start_unanchored = if universal_unanchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_unanchored).map_err(|e| {
                                DeserializeError::state_id_error(
                                    e,
                                    "universal unanchored start",
                                )
                            })?)
                        };

                        let (universal_anchored, nr) =
                            wire::try_read_u32(slice, "universal anchored start")?;
                        slice = &slice[nr..];
                        let universal_start_anchored = if universal_anchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_anchored).map_err(|e| {
                                DeserializeError::state_id_error(e, "universal anchored start")
                            })?)
                        };

                        let pattern_table_size = wire::mul(
                            stride,
                            pattern_len.unwrap_or(0),
                            "invalid pattern length",
                        )?;
                        let start_state_len = wire::add(
                            wire::mul(2, stride, "start state stride too big")?,
                            pattern_table_size,
                            "invalid 'any' pattern starts size",
                        )?;
                        let table_bytes_len = wire::mul(
                            start_state_len,
                            StateID::SIZE,
                            "pattern table bytes length",
                        )?;
                        wire::check_slice_len(slice, table_bytes_len, "start ID table")?;
                        wire::check_alignment::<StateID>(slice)?;
                        let table_bytes = &slice[..table_bytes_len];
                        slice = &slice[table_bytes_len..];
                        let table = ::slice::from_raw_parts(
                            table_bytes.as_ptr().cast::<u32>(),
                            start_state_len,
                        );
                        let st = StartTable {
                            table,
                            kind,
                            start_map,
                            stride,
                            pattern_len,
                            universal_start_unanchored,
                            universal_start_anchored,
                        };
                        Ok((st, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<T: AsRef<[u32]>> StartTable<T>
                {
                    /// Writes a serialized form of this start table to the buffer given. If
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "starting table ids",
                            ));
                        }
                        dst = &mut dst[..nwrite];

                        // write start kind
                        let nw = self.kind.write_to::<E>(dst)?;
                        dst = &mut dst[nw..];
                        // write start byte map
                        let nw = self.start_map.write_to(dst)?;
                        dst = &mut dst[nw..];
                        E::write_u32(u32::try_from(self.stride).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            u32::try_from(self.pattern_len.unwrap_or(0xFFFF_FFFF)).unwrap(),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        // write universal start unanchored state id, u32::MAX if absent
                        E::write_u32(
                            self.universal_start_unanchored
                                .map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        // write universal start anchored state id, u32::MAX if absent
                        E::write_u32(
                            self.universal_start_anchored.map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        // write start IDs
                        for &sid in self.table() {
                            let n = wire::write_state_id::<E>(sid, &mut dst);
                            dst = &mut dst[n..];
                        }
                        Ok(nwrite)
                    }
                    /// Returns the number of bytes the serialized form of this start ID table
                    fn write_to_len(&self) -> usize {
                        self.kind.write_to_len()
                        + self.start_map.write_to_len()
                        + size_of::<u32>() // stride
                        + size_of::<u32>() // # patterns
                        + size_of::<u32>() // universal unanchored start
                        + size_of::<u32>() // universal anchored start
                        + (self.table().len() * StateID::SIZE)
                    }
                    /// Validates that every state ID in this start table is valid by checking
                    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {
                        let tt = &dfa.tt;
                        
                        if !self.universal_start_unanchored.map_or(true, |s| tt.is_valid(s)) {
                            return Err(DeserializeError::generic(
                                "found invalid universal unanchored starting state ID",
                            ));
                        }
                        
                        if !self.universal_start_anchored.map_or(true, |s| tt.is_valid(s)) {
                            return Err(DeserializeError::generic(
                                "found invalid universal anchored starting state ID",
                            ));
                        }
                        for &id in self.table()
                        {
                            if !tt.is_valid(id) {
                                return Err(DeserializeError::generic(
                                    "found invalid starting state ID",
                                ));
                            }
                        }
                        Ok(())
                    }
                    /// Converts this start list to a borrowed value.
                    fn as_ref(&self) -> StartTable<&'_ [u32]> {
                        StartTable {
                            table: self.table.as_ref(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }
                    /// Converts this start list to an owned value.
                        fn to_owned(&self) -> StartTable<Vec<u32>> {
                        StartTable {
                            table: self.table.as_ref().to_vec(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }
                    /// Return the start state for the given input and starting configuration.
                    #[inline( always )]
                    fn start(
                        &self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<StateID, StartError> {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => {
                                if !self.kind.has_unanchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                start_index
                            }
                            Anchored::Yes => {
                                if !self.kind.has_anchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                self.stride + start_index
                            }
                            Anchored::Pattern(pid) => {
                                let len = match self.pattern_len {
                                    None => {
                                        return Err(StartError::unsupported_anchored(anchored))
                                    }
                                    Some(len) => len,
                                };
                                
                                if pid.as_usize() >= len {
                                    return Ok(DEAD);
                                }
                                (2 * self.stride)
                                    + (self.stride * pid.as_usize())
                                    + start_index
                            }
                        };
                        Ok(self.table()[index])
                    }
                    /// Returns an iterator over all start state IDs in this table.
                    fn iter(&self) -> StartStateIter<'_> {
                        StartStateIter { st: self.as_ref(), i: 0 }
                    }
                    /// Returns the table as a slice of state IDs.
                    fn table(&self) -> &[StateID] {
                        wire::u32s_to_state_ids(self.table.as_ref())
                    }
                    /// Return the memory usage, in bytes, of this start list.
                    fn memory_usage(&self) -> usize {
                        self.table().len() * StateID::SIZE
                    }
                }

                impl<T: AsMut<[u32]>> StartTable<T>
                {
                    /// Set the start state for the given index and pattern.
                    fn set_start(&mut self, anchored: Anchored, start: Start, id: StateID) {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => self.stride + start_index,
                            Anchored::Pattern(pid) => {
                                let pid = pid.as_usize();
                                let len = self
                                    .pattern_len
                                    .expect("start states for each pattern enabled");
                                assert!(pid < len, "invalid pattern ID {pid:?}");
                                self.stride
                                    .checked_mul(pid)
                                    .unwrap()
                                    .checked_add(self.stride.checked_mul(2).unwrap())
                                    .unwrap()
                                    .checked_add(start_index)
                                    .unwrap()
                            }
                        };
                        self.table_mut()[index] = id;
                    }
                    /// Returns the table as a mutable slice of state IDs.
                    fn table_mut(&mut self) -> &mut [StateID] {
                        wire::u32s_to_state_ids_mut(self.table.as_mut())
                    }
                }
                /// An iterator over start state IDs.
                pub struct StartStateIter<'a> {
                    st: StartTable<&'a [u32]>,
                    i: usize,
                }

                impl<'a> Iterator for StartStateIter<'a> {
                    type Item = (StateID, Anchored, Start);

                    fn next(&mut self) -> Option<(StateID, Anchored, Start)> {
                        let i = self.i;
                        let table = self.st.table();
                        
                        if i >= table.len() {
                            return None;
                        }
                        self.i += 1;
                        let start_type = Start::from_usize(i % self.st.stride).unwrap();
                        let anchored = if i < self.st.stride {
                            Anchored::No
                        } else if i < (2 * self.st.stride) {
                            Anchored::Yes
                        } else {
                            let pid = (i - (2 * self.st.stride)) / self.st.stride;
                            Anchored::Pattern(PatternID::new(pid).unwrap())
                        };
                        Some((table[i], anchored, start_type))
                    }
                }
                /// This type represents that patterns that should be reported whenever a DFA
                #[derive(Clone, Debug)]
                struct MatchStates<T>
                {
                    /// Slices is a flattened sequence of pairs, where each pair points to a
                    slices: T,
                    /// A flattened sequence of pattern IDs for each DFA match state. The only
                    pattern_ids: T,
                    /// The total number of unique patterns represented by these match states.
                    pattern_len: usize,
                }

                impl<'a> MatchStates<&'a [u32]> {
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(MatchStates<&'a [u32]>, usize), DeserializeError> {
                        let slice_start = slice.as_ptr().as_usize();

                        // Read the total number of match states.
                        let (state_len, nr) =
                            wire::try_read_u32_as_usize(slice, "match state length")?;
                        slice = &slice[nr..];

                        // Read the slice start/length pairs.
                        let pair_len = wire::mul(2, state_len, "match state offset pairs")?;
                        let slices_bytes_len = wire::mul(
                            pair_len,
                            PatternID::SIZE,
                            "match state slice offset byte length",
                        )?;
                        wire::check_slice_len(slice, slices_bytes_len, "match state slices")?;
                        wire::check_alignment::<PatternID>(slice)?;
                        let slices_bytes = &slice[..slices_bytes_len];
                        slice = &slice[slices_bytes_len..];
                        let slices = ::slice::from_raw_parts(
                            slices_bytes.as_ptr().cast::<u32>(),
                            pair_len,
                        );
                        let (pattern_len, nr) =
                            wire::try_read_u32_as_usize(slice, "pattern length")?;
                        slice = &slice[nr..];
                        let (idlen, nr) =
                            wire::try_read_u32_as_usize(slice, "pattern ID length")?;
                        slice = &slice[nr..];

                        // Read the actual pattern IDs.
                        let pattern_ids_len =
                            wire::mul(idlen, PatternID::SIZE, "pattern ID byte length")?;
                        wire::check_slice_len(slice, pattern_ids_len, "match pattern IDs")?;
                        wire::check_alignment::<PatternID>(slice)?;
                        let pattern_ids_bytes = &slice[..pattern_ids_len];
                        slice = &slice[pattern_ids_len..];
                        let pattern_ids = ::slice::from_raw_parts(
                            pattern_ids_bytes.as_ptr().cast::<u32>(),
                            idlen,
                        );

                        let ms = MatchStates { slices, pattern_ids, pattern_len };
                        Ok((ms, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl MatchStates<Vec<u32>> 
                {
                    fn empty(pattern_len: usize) -> MatchStates<Vec<u32>> {
                        assert!(pattern_len <= PatternID::LIMIT);
                        MatchStates { slices: vec![], pattern_ids: vec![], pattern_len }
                    }

                    fn new(
                        matches: &BTreeMap<StateID, Vec<PatternID>>,
                        pattern_len: usize,
                    ) -> Result<MatchStates<Vec<u32>>, BuildError> {
                        let mut m = MatchStates::empty(pattern_len);
                        for (_, pids) in matches.iter() {
                            let start = PatternID::new(m.pattern_ids.len())
                                .map_err(|_| BuildError::too_many_match_pattern_ids())?;
                            m.slices.push(start.as_u32());
                            m.slices.push(u32::try_from(pids.len()).unwrap());
                            for &pid in pids {
                                m.pattern_ids.push(pid.as_u32());
                            }
                        }
                        m.pattern_len = pattern_len;
                        Ok(m)
                    }

                    fn new_with_map(
                        &self,
                        matches: &BTreeMap<StateID, Vec<PatternID>>,
                    ) -> Result<MatchStates<Vec<u32>>, BuildError> {
                        MatchStates::new(matches, self.pattern_len)
                    }
                }

                impl<T: AsRef<[u32]>> MatchStates<T>
                {
                    /// Writes a serialized form of these match states to the buffer given. If
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("match states"));
                        }
                        dst = &mut dst[..nwrite];
                        E::write_u32(u32::try_from(self.len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];

                        // write slice offset pairs
                        for &pid in self.slices() {
                            let n = wire::write_pattern_id::<E>(pid, &mut dst);
                            dst = &mut dst[n..];
                        }
                        E::write_u32(u32::try_from(self.pattern_len).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(u32::try_from(self.pattern_ids().len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];

                        // write pattern IDs
                        for &pid in self.pattern_ids() {
                            let n = wire::write_pattern_id::<E>(pid, &mut dst);
                            dst = &mut dst[n..];
                        }

                        Ok(nwrite)
                    }
                    /// Returns the number of bytes the serialized form of these match states
                    fn write_to_len(&self) -> usize {
                        size_of::<u32>()   // match state length
                        + (self.slices().len() * PatternID::SIZE)
                        + size_of::<u32>() // unique pattern ID length
                        + size_of::<u32>() // pattern ID length
                        + (self.pattern_ids().len() * PatternID::SIZE)
                    }
                    /// Validates that the match state info is itself internally consistent and
                    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {
                        if self.len() != dfa.special.match_len(dfa.stride()) {
                            return Err(DeserializeError::generic(
                                "match state length mismatch",
                            ));
                        }
                        for si in 0..self.len() {
                            let start = self.slices()[si * 2].as_usize();
                            let len = self.slices()[si * 2 + 1].as_usize();
                            if start >= self.pattern_ids().len() {
                                return Err(DeserializeError::generic(
                                    "invalid pattern ID start offset",
                                ));
                            }
                            
                            if start + len > self.pattern_ids().len() {
                                return Err(DeserializeError::generic(
                                    "invalid pattern ID length",
                                ));
                            }
                            
                            for mi in 0..len 
                            {
                                let pid = self.pattern_id(si, mi);
                                
                                if pid.as_usize() >= self.pattern_len {
                                    return Err(DeserializeError::generic(
                                        "invalid pattern ID",
                                    ));
                                }
                            }
                        }
                        Ok(())
                    }
                    /// Converts these match states back into their map form. This is useful
                        fn to_map(&self, dfa: &DFA<T>) -> BTreeMap<StateID, Vec<PatternID>> {
                        let mut map = BTreeMap::new();
                        for i in 0..self.len() {
                            let mut pids = vec![];
                            for j in 0..self.pattern_len(i) {
                                pids.push(self.pattern_id(i, j));
                            }
                            map.insert(self.match_state_id(dfa, i), pids);
                        }
                        map
                    }
                    /// Converts these match states to a borrowed value.
                    fn as_ref(&self) -> MatchStates<&'_ [u32]> {
                        MatchStates {
                            slices: self.slices.as_ref(),
                            pattern_ids: self.pattern_ids.as_ref(),
                            pattern_len: self.pattern_len,
                        }
                    }
                    /// Converts these match states to an owned value.
                        fn to_owned(&self) -> MatchStates<Vec<u32>> {
                        MatchStates {
                            slices: self.slices.as_ref().to_vec(),
                            pattern_ids: self.pattern_ids.as_ref().to_vec(),
                            pattern_len: self.pattern_len,
                        }
                    }
                    /// Returns the match state ID given the match state index. (Where the
                    fn match_state_id(&self, dfa: &DFA<T>, index: usize) -> StateID {
                        assert!(dfa.special.matches(), "no match states to index");
                        let stride2 = u32::try_from(dfa.stride2()).unwrap();
                        let offset = index.checked_shl(stride2).unwrap();
                        let id = dfa.special.min_match.as_usize().checked_add(offset).unwrap();
                        let sid = StateID::new(id).unwrap();
                        assert!(dfa.is_match_state(sid));
                        sid
                    }
                    /// Returns the pattern ID at the given match index for the given match
                    #[inline( always )]
                    fn pattern_id(&self, state_index: usize, match_index: usize) -> PatternID {
                        self.pattern_id_slice(state_index)[match_index]
                    }
                    /// Returns the number of patterns in the given match state.
                    #[inline( always )]
                    fn pattern_len(&self, state_index: usize) -> usize {
                        self.slices()[state_index * 2 + 1].as_usize()
                    }
                    /// Returns all of the pattern IDs for the given match state index.
                    #[inline( always )]
                    fn pattern_id_slice(&self, state_index: usize) -> &[PatternID] {
                        let start = self.slices()[state_index * 2].as_usize();
                        let len = self.pattern_len(state_index);
                        &self.pattern_ids()[start..start + len]
                    }
                    /// Returns the pattern ID offset slice of u32 as a slice of PatternID.
                    #[inline( always )]
                    fn slices(&self) -> &[PatternID] {
                        wire::u32s_to_pattern_ids(self.slices.as_ref())
                    }
                    /// Returns the total number of match states.
                    #[inline( always )]
                    fn len(&self) -> usize {
                        assert_eq!(0, self.slices().len() % 2);
                        self.slices().len() / 2
                    }
                    /// Returns the pattern ID slice of u32 as a slice of PatternID.
                    #[inline( always )]
                    fn pattern_ids(&self) -> &[PatternID] {
                        wire::u32s_to_pattern_ids(self.pattern_ids.as_ref())
                    }
                    /// Return the memory usage, in bytes, of these match pairs.
                    fn memory_usage(&self) -> usize {
                        (self.slices().len() + self.pattern_ids().len()) * PatternID::SIZE
                    }
                }
                /// A common set of flags for both dense and sparse DFAs. This primarily
                #[derive(Clone, Copy, Debug)]
                pub struct Flags
                {
                    /// Whether the DFA can match the empty string. When this is false, all
                    pub has_empty: bool,
                    /// Whether the DFA should only produce matches with spans that correspond
                    pub is_utf8: bool,
                    /// Whether the DFA is always anchored or not, regardless of `Input`
                    pub is_always_start_anchored: bool,
                }

                impl Flags
                {
                    /// Creates a set of flags for a DFA from an NFA.
                        fn from_nfa(nfa: &thompson::NFA) -> Flags {
                        Flags {
                            has_empty: nfa.has_empty(),
                            is_utf8: nfa.is_utf8(),
                            is_always_start_anchored: nfa.is_always_start_anchored(),
                        }
                    }
                    /// Deserializes the flags from the given slice. On success, this also
                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(Flags, usize), DeserializeError> {
                        let (bits, nread) = wire::try_read_u32(slice, "flag bitset")?;
                        let flags = Flags {
                            has_empty: bits & (1 << 0) != 0,
                            is_utf8: bits & (1 << 1) != 0,
                            is_always_start_anchored: bits & (1 << 2) != 0,
                        };
                        Ok((flags, nread))
                    }
                    /// Writes these flags to the given byte slice. If the buffer is too small,
                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        fn bool_to_int(b: bool) -> u32 {
                            if b {
                                1
                            } else {
                                0
                            }
                        }

                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("flag bitset"));
                        }
                        let bits = (bool_to_int(self.has_empty) << 0)
                            | (bool_to_int(self.is_utf8) << 1)
                            | (bool_to_int(self.is_always_start_anchored) << 2);
                        E::write_u32(bits, dst);
                        Ok(nwrite)
                    }
                    /// Returns the number of bytes the serialized form of these flags
                    pub fn write_to_len(&self) -> usize {
                        size_of::<u32>()
                    }
                }
                /// An iterator over all states in a DFA.
                pub struct StateIter<'a, T> {
                    tt: &'a TransitionTable<T>,
                    it: iter::Enumerate<slice::Chunks<'a, StateID>>,
                }

                impl<'a, T: AsRef<[u32]>> Iterator for StateIter<'a, T> {
                    type Item = State<'a>;

                    fn next(&mut self) -> Option<State<'a>> {
                        self.it.next().map(|(index, _)| {
                            let id = self.tt.to_state_id(index);
                            self.tt.state(id)
                        })
                    }
                }
                /// An immutable representation of a single DFA state.
                pub struct State<'a> {
                    id: StateID,
                    stride2: usize,
                    transitions: &'a [StateID],
                }

                impl<'a> State<'a>
                {
                    /// Return an iterator over all transitions in this state. This yields
                    pub fn transitions(&self) -> StateTransitionIter<'_> {
                        StateTransitionIter {
                            len: self.transitions.len(),
                            it: self.transitions.iter().enumerate(),
                        }
                    }
                    /// Return an iterator over a sparse representation of the transitions in
                    pub fn sparse_transitions(&self) -> StateSparseTransitionIter<'_> {
                        StateSparseTransitionIter { dense: self.transitions(), cur: None }
                    }
                    /// Returns the identifier for this state.
                    pub fn id(&self) -> StateID {
                        self.id
                    }
                    /// Analyzes this state to determine whether it can be accelerated. If so,
                        fn accelerate(&self, classes: &ByteClasses) -> Option<Accel> {
                        let mut accel = Accel::new();
                        for (class, id) in self.transitions()
                        {
                            if id == self.id() {
                                continue;
                            }
                            
                            for unit in classes.elements(class) {
                                if let Some(byte) = unit.as_u8() {
                                    if !accel.add(byte) {
                                        return None;
                                    }
                                }
                            }
                        }
                        
                        if accel.is_empty() {
                            None
                        } else {
                            Some(accel)
                        }
                    }
                }

                impl<'a> fmt::Debug for State<'a> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        for (i, (start, end, sid)) in self.sparse_transitions().enumerate() {
                            let id = if f.alternate() {
                                sid.as_usize()
                            } else {
                                sid.as_usize() >> self.stride2
                            };
                            if i > 0 {
                                write!(f, ", ")?;
                            }
                            
                            if start == end {
                                write!(f, "{start:?} => {id:?}")?;
                            } else {
                                write!(f, "{start:?}-{end:?} => {id:?}")?;
                            }
                        }
                        Ok(())
                    }
                }
                /// An iterator over all transitions in a single DFA state. This yields
                #[derive(Debug)]
                pub struct StateTransitionIter<'a> {
                    len: usize,
                    it: iter::Enumerate<slice::Iter<'a, StateID>>,
                }

                impl<'a> Iterator for StateTransitionIter<'a> {
                    type Item = (alphabet::Unit, StateID);

                    fn next(&mut self) -> Option<(alphabet::Unit, StateID)> {
                        self.it.next().map(|(i, &id)| {
                            let unit = if i + 1 == self.len {
                                alphabet::Unit::eoi(i)
                            } else {
                                let b = u8::try_from(i)
                                    .expect("raw byte alphabet is never exceeded");
                                alphabet::Unit::u8(b)
                            };
                            (unit, id)
                        })
                    }
                }
                /// An iterator over all non-DEAD transitions in a single DFA state using a
                #[derive(Debug)]
                pub struct StateSparseTransitionIter<'a> {
                    dense: StateTransitionIter<'a>,
                    cur: Option<(alphabet::Unit, alphabet::Unit, StateID)>,
                }

                impl<'a> Iterator for StateSparseTransitionIter<'a> {
                    type Item = (alphabet::Unit, alphabet::Unit, StateID);

                    fn next(&mut self) -> Option<(alphabet::Unit, alphabet::Unit, StateID)> {
                        while let Some((unit, next)) = self.dense.next() {
                            let (prev_start, prev_end, prev_next) = match self.cur {
                                Some(t) => t,
                                None => {
                                    self.cur = Some((unit, unit, next));
                                    continue;
                                }
                            };
                            if prev_next == next && !unit.is_eoi() {
                                self.cur = Some((prev_start, unit, prev_next));
                            } else {
                                self.cur = Some((unit, unit, next));
                                
                                if prev_next != DEAD {
                                    return Some((prev_start, prev_end, prev_next));
                                }
                            }
                        }
                        
                        if let Some((start, end, next)) = self.cur.take()
                        {
                            if next != DEAD { return Some((start, end, next)); }
                        }

                        None
                    }
                }
                /// An error that occurred during the construction of a DFA.
                #[derive(Clone, Debug)]
                pub struct BuildError {
                    kind: BuildErrorKind,
                }

                impl BuildError
                {
                    /// Returns true if and only if this error corresponds to an error with DFA
                    #[inline] pub fn is_size_limit_exceeded(&self) -> bool {
                        use self::BuildErrorKind::*;

                        match self.kind {
                            NFA(_) | Unsupported(_) => false,
                            TooManyStates
                            | TooManyStartStates
                            | TooManyMatchPatternIDs
                            | DFAExceededSizeLimit { .. }
                            | DeterminizeExceededSizeLimit { .. } => true,
                        }
                    }
                }
                /// The kind of error that occurred during the construction of a DFA.
                #[derive(Clone, Debug)]
                enum BuildErrorKind
                {
                    /// An error that occurred while constructing an NFA as a precursor step
                    NFA(thompson::BuildError),
                    /// An error that occurred because an unsupported regex feature was used.
                    Unsupported(&'static str),
                    /// An error that occurs if too many states are produced while building a
                    TooManyStates,
                    /// An error that occurs if too many start states are needed while building
                    TooManyStartStates,
                    /// This is another oddball error that can occur if there are too many
                    TooManyMatchPatternIDs,
                    /// An error that occurs if the DFA got too big during determinization.
                    DFAExceededSizeLimit { limit: usize },
                    /// An error that occurs if auxiliary storage (not the DFA) used during
                    DeterminizeExceededSizeLimit { limit: usize },
                }

                impl BuildError
                {
                    /// Return the kind of this error.
                    fn kind(&self) -> &BuildErrorKind {
                        &self.kind
                    }

                    pub fn nfa(err: thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }

                    pub fn unsupported_dfa_word_boundary_unicode() -> BuildError {
                        let msg = "cannot build DFAs for regexes with Unicode word \
                                boundaries; switch to ASCII word boundaries, or \
                                heuristically enable Unicode word boundaries or use a \
                                different regex engine";
                        BuildError { kind: BuildErrorKind::Unsupported(msg) }
                    }

                    pub fn too_many_states() -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyStates }
                    }

                    pub fn too_many_start_states() -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyStartStates }
                    }

                    pub fn too_many_match_pattern_ids() -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyMatchPatternIDs }
                    }

                    pub fn dfa_exceeded_size_limit(limit: usize) -> BuildError {
                        BuildError { kind: BuildErrorKind::DFAExceededSizeLimit { limit } }
                    }

                    pub fn determinize_exceeded_size_limit(limit: usize) -> BuildError {
                        BuildError {
                            kind: BuildErrorKind::DeterminizeExceededSizeLimit { limit },
                        }
                    }
                }
                
                impl ::error::Error for BuildError
                {
                    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                        match self.kind() {
                            BuildErrorKind::NFA(ref err) => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for BuildError
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match self.kind() {
                            BuildErrorKind::NFA(_) => write!(f, "error building NFA"),
                            BuildErrorKind::Unsupported(ref msg) => {
                                write!(f, "unsupported regex feature for DFAs: {msg}")
                            }
                            BuildErrorKind::TooManyStates => write!(
                                f,
                                "number of DFA states exceeds limit of {}",
                                StateID::LIMIT,
                            ),
                            BuildErrorKind::TooManyStartStates => {
                                let stride = Start::len();
                                let max = usize::try_from(::isize::MAX).unwrap();
                                let limit = (max - stride) / stride;
                                write!(
                                    f,
                                    "compiling DFA with start states exceeds pattern \
                                    pattern limit of {}",
                                    limit,
                                )
                            }
                            BuildErrorKind::TooManyMatchPatternIDs => write!(
                                f,
                                "compiling DFA with total patterns in all match states \
                                exceeds limit of {}",
                                PatternID::LIMIT,
                            ),
                            BuildErrorKind::DFAExceededSizeLimit { limit } => write!(
                                f,
                                "DFA exceeded size limit of {limit:?} during determinization",
                            ),
                            BuildErrorKind::DeterminizeExceededSizeLimit { limit } => {
                                write!(f, "determinization exceeded size limit of {limit:?}")
                            }
                        }
                    }
                }
            }

            pub mod onepass
            {
                /*!
                A DFA that can return spans for matching capturing groups. */
                use ::
                {
                    regex::automata::
                    {
                        dfa::{remapper::Remapper, DEAD},
                        nfa::thompson::{self, NFA},
                        util::
                        {
                            alphabet::ByteClasses,
                            captures::Captures,
                            escape::DebugByte,
                            int::{Usize, U32, U64, U8},
                            look::{Look, LookSet, UnicodeWordBoundaryError},
                            primitives::{NonMaxUsize, PatternID, StateID},
                            search::{Anchored, Input, Match, MatchError, MatchKind, Span},
                            sparse_set::SparseSet,
                        },
                    },
                    vec::{ Vec },
                    *,
                };
                /*
                */
                /// The configuration used for building a [one-pass DFA](DFA).
                #[derive(Clone, Debug, Default)]
                pub struct Config {
                    match_kind: Option<MatchKind>,
                    starts_for_each_pattern: Option<bool>,
                    byte_classes: Option<bool>,
                    size_limit: Option<Option<usize>>,
                }

                impl Config
                {
                    /// Return a new default one-pass DFA configuration.
                    pub fn new() -> Config {
                        Config::default()
                    }
                    /// Set the desired match semantics.
                    pub fn match_kind(mut self, kind: MatchKind) -> Config {
                        self.match_kind = Some(kind);
                        self
                    }
                    /// Whether to compile a separate start state for each pattern in the
                    pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {
                        self.starts_for_each_pattern = Some(yes);
                        self
                    }
                    /// Whether to attempt to shrink the size of the DFA's alphabet or not.
                    pub fn byte_classes(mut self, yes: bool) -> Config {
                        self.byte_classes = Some(yes);
                        self
                    }
                    /// Set a size limit on the total heap used by a one-pass DFA.
                    pub fn size_limit(mut self, limit: Option<usize>) -> Config {
                        self.size_limit = Some(limit);
                        self
                    }
                    /// Returns the match semantics set in this configuration.
                    pub fn get_match_kind(&self) -> MatchKind {
                        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
                    }
                    /// Returns whether this configuration has enabled anchored starting states
                    pub fn get_starts_for_each_pattern(&self) -> bool {
                        self.starts_for_each_pattern.unwrap_or(false)
                    }
                    /// Returns whether this configuration has enabled byte classes or not.
                    pub fn get_byte_classes(&self) -> bool {
                        self.byte_classes.unwrap_or(true)
                    }
                    /// Returns the DFA size limit of this configuration if one was set.
                    pub fn get_size_limit(&self) -> Option<usize> {
                        self.size_limit.unwrap_or(None)
                    }
                    /// Overwrite the default configuration such that the options in `o` are
                    pub fn overwrite(&self, o: Config) -> Config {
                        Config {
                            match_kind: o.match_kind.or(self.match_kind),
                            starts_for_each_pattern: o
                                .starts_for_each_pattern
                                .or(self.starts_for_each_pattern),
                            byte_classes: o.byte_classes.or(self.byte_classes),
                            size_limit: o.size_limit.or(self.size_limit),
                        }
                    }
                }
                /// A builder for a [one-pass DFA](DFA).
                #[derive(Clone, Debug)]
                pub struct Builder {
                    config: Config,
                    thompson: thompson::Compiler,
                }

                impl Builder
                {
                    /// Create a new one-pass DFA builder with the default configuration.
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                                    thompson: thompson::Compiler::new(),
                        }
                    }
                    /// Build a one-pass DFA from the given pattern.
                    pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> {
                        self.build_many(&[pattern])
                    }
                    /// Build a one-pass DFA from the given patterns.
                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<DFA, BuildError> {
                        let nfa =
                            self.thompson.build_many(patterns).map_err(BuildError::nfa)?;
                        self.build_from_nfa(nfa)
                    }
                    /// Build a DFA from the given NFA.
                    pub fn build_from_nfa(&self, nfa: NFA) -> Result<DFA, BuildError> {
                        InternalBuilder::new(self.config.clone(), &nfa).build()
                    }
                    /// Apply the given one-pass DFA configuration options to this builder.
                    pub fn configure(&mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }
                    /// Set the syntax configuration for this builder using
                    pub fn syntax
                    (
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.thompson.syntax(config);
                        self
                    }
                    /// Set the Thompson NFA configuration for this builder using
                    pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                        self.thompson.configure(config);
                        self
                    }
                }
                /// An internal builder for encapsulating the state necessary to build a
                #[derive(Debug)]
                struct InternalBuilder<'a>
                {
                    /// The DFA we're building.
                    dfa: DFA,
                    /// An unordered collection of NFA state IDs that we haven't yet tried to
                    uncompiled_nfa_ids: Vec<StateID>,
                    /// A map from NFA state ID to DFA state ID. This is useful for easily
                    nfa_to_dfa_id: Vec<StateID>,
                    /// A stack used to traverse the NFA states that make up a single DFA
                    stack: Vec<(StateID, Epsilons)>,
                    /// The set of NFA states that we've visited via 'stack'.
                    seen: SparseSet,
                    /// Whether a match NFA state has been observed while constructing a
                    matched: bool,
                    /// The config passed to the builder.
                    config: Config,
                    /// The NFA we're building a one-pass DFA from.
                    nfa: &'a NFA,
                    /// The equivalence classes that make up the alphabet for this DFA>
                    classes: ByteClasses,
                }

                impl<'a> InternalBuilder<'a>
                {
                    /// Create a new builder with an initial empty DFA.
                    fn new(config: Config, nfa: &'a NFA) -> InternalBuilder<'a> {
                        let classes = if !config.get_byte_classes() {
                            ByteClasses::singletons()
                        } else {
                            nfa.byte_classes().clone()
                        };
                        let alphabet_len = classes.alphabet_len().checked_sub(1).unwrap();
                        let stride2 = classes.stride2();
                        let dfa = DFA {
                            config: config.clone(),
                            nfa: nfa.clone(),
                            table: vec![],
                            starts: vec![],
                            min_match_id: StateID::MAX,
                            classes: classes.clone(),
                            alphabet_len,
                            stride2,
                            pateps_offset: alphabet_len,
                            // OK because PatternID::MAX*2 is guaranteed not to overflow.
                            explicit_slot_start: nfa.pattern_len().checked_mul(2).unwrap(),
                        };
                        InternalBuilder {
                            dfa,
                            uncompiled_nfa_ids: vec![],
                            nfa_to_dfa_id: vec![DEAD; nfa.states().len()],
                            stack: vec![],
                            seen: SparseSet::new(nfa.states().len()),
                            matched: false,
                            config,
                            nfa,
                            classes,
                        }
                    }
                    /// Build the DFA from the NFA given to this builder. If the NFA is not
                    fn build(mut self) -> Result<DFA, BuildError> {
                        self.nfa.look_set_any().available().map_err(BuildError::word)?;
                        for look in self.nfa.look_set_any().iter()
                        {
                            if look.as_repr() > Look::WordUnicodeNegate.as_repr() {
                                return Err(BuildError::unsupported_look(look));
                            }
                        }
                        
                        if self.nfa.pattern_len().as_u64() > PatternEpsilons::PATTERN_ID_LIMIT
                        {
                            return Err(BuildError::too_many_patterns(
                                PatternEpsilons::PATTERN_ID_LIMIT,
                            ));
                        }
                        
                        if self.nfa.group_info().explicit_slot_len() > Slots::LIMIT {
                            return Err(BuildError::not_one_pass(
                                "too many explicit capturing groups (max is 16)",
                            ));
                        }
                        assert_eq!(DEAD, self.add_empty_state()?);
                        let explicit_slot_start = self.nfa.pattern_len() * 2;
                        self.add_start_state(None, self.nfa.start_anchored())?;
                        
                        if self.config.get_starts_for_each_pattern() {
                            for pid in self.nfa.patterns() {
                                self.add_start_state(
                                    Some(pid),
                                    self.nfa.start_pattern(pid).unwrap(),
                                )?;
                            }
                        }
                        while let Some(nfa_id) = self.uncompiled_nfa_ids.pop() {
                            let dfa_id = self.nfa_to_dfa_id[nfa_id];
                            self.matched = false;
                            // The NFA states we've already explored for this DFA state.
                            self.seen.clear();
                            self.stack_push(nfa_id, Epsilons::empty())?;
                            while let Some((id, epsilons)) = self.stack.pop() {
                                match *self.nfa.state(id) {
                                    thompson::State::ByteRange { ref trans } => {
                                        self.compile_transition(dfa_id, trans, epsilons)?;
                                    }
                                    thompson::State::Sparse(ref sparse) => {
                                        for trans in sparse.transitions.iter() {
                                            self.compile_transition(dfa_id, trans, epsilons)?;
                                        }
                                    }
                                    thompson::State::Dense(ref dense) => {
                                        for trans in dense.iter() {
                                            self.compile_transition(dfa_id, &trans, epsilons)?;
                                        }
                                    }
                                    thompson::State::Look { look, next } => {
                                        let looks = epsilons.looks().insert(look);
                                        self.stack_push(next, epsilons.set_looks(looks))?;
                                    }
                                    thompson::State::Union { ref alternates } => {
                                        for &sid in alternates.iter().rev() {
                                            self.stack_push(sid, epsilons)?;
                                        }
                                    }
                                    thompson::State::BinaryUnion { alt1, alt2 } => {
                                        self.stack_push(alt2, epsilons)?;
                                        self.stack_push(alt1, epsilons)?;
                                    }
                                    thompson::State::Capture { next, slot, .. } => {
                                        let slot = slot.as_usize();
                                        let epsilons = if slot < explicit_slot_start {
                                            epsilons
                                        } else {
                                            let offset = slot - explicit_slot_start;
                                            epsilons.set_slots(epsilons.slots().insert(offset))
                                        };
                                        self.stack_push(next, epsilons)?;
                                    }
                                    thompson::State::Fail => {
                                        continue;
                                    }
                                    thompson::State::Match { pattern_id } => {
                                        if self.matched {
                                            return Err(BuildError::not_one_pass(
                                                "multiple epsilon transitions to match state",
                                            ));
                                        }
                                        self.matched = true;
                                        self.dfa.set_pattern_epsilons(
                                            dfa_id,
                                            PatternEpsilons::empty()
                                                .set_pattern_id(pattern_id)
                                                .set_epsilons(epsilons),
                                        );
                                    }
                                }
                            }
                        }
                        self.shuffle_states();
                        Ok(self.dfa)
                    }
                    /// Shuffle all match states to the end of the transition table and set
                    fn shuffle_states(&mut self) {
                        let mut remapper = Remapper::new(&self.dfa);
                        let mut next_dest = self.dfa.last_state_id();
                        for i in (0..self.dfa.state_len()).rev() {
                            let id = StateID::must(i);
                            let is_match =
                                self.dfa.pattern_epsilons(id).pattern_id().is_some();
                            if !is_match {
                                continue;
                            }
                            remapper.swap(&mut self.dfa, next_dest, id);
                            self.dfa.min_match_id = next_dest;
                            next_dest = self.dfa.prev_state_id(next_dest).expect(
                                "match states should be a proper subset of all states",
                            );
                        }
                        remapper.remap(&mut self.dfa);
                    }
                    /// Compile the given NFA transition into the DFA state given.
                    fn compile_transition
                    (
                        &mut self,
                        dfa_id: StateID,
                        trans: &thompson::Transition,
                        epsilons: Epsilons,
                    ) -> Result<(), BuildError> {
                        let next_dfa_id = self.add_dfa_state_for_nfa_state(trans.next)?;
                        for byte in self
                            .classes
                            .representatives(trans.start..=trans.end)
                            .filter_map(|r| r.as_u8())
                        {
                            let oldtrans = self.dfa.transition(dfa_id, byte);
                            let newtrans =
                                Transition::new(self.matched, next_dfa_id, epsilons);
                            if oldtrans.state_id() == DEAD {
                                self.dfa.set_transition(dfa_id, byte, newtrans);
                            } else if oldtrans != newtrans {
                                return Err(BuildError::not_one_pass(
                                    "conflicting transition",
                                ));
                            }
                        }
                        Ok(())
                    }
                    /// Add a start state to the DFA corresponding to the given NFA starting
                    fn add_start_state
                    (
                        &mut self,
                        pid: Option<PatternID>,
                        nfa_id: StateID,
                    ) -> Result<StateID, BuildError> {
                        match pid {
                            None => assert!(self.dfa.starts.is_empty()),
                            // With a pid, we want it to be at self.dfa.starts[pid+1].
                            Some(pid) => assert!(self.dfa.starts.len() == pid.one_more()),
                        }
                        let dfa_id = self.add_dfa_state_for_nfa_state(nfa_id)?;
                        self.dfa.starts.push(dfa_id);
                        Ok(dfa_id)
                    }
                    /// Add a new DFA state corresponding to the given NFA state. If adding a
                    fn add_dfa_state_for_nfa_state
                    (
                        &mut self,
                        nfa_id: StateID,
                    ) -> Result<StateID, BuildError> {
                        let existing_dfa_id = self.nfa_to_dfa_id[nfa_id];
                        
                        if existing_dfa_id != DEAD {
                            return Ok(existing_dfa_id);
                        }
                        let dfa_id = self.add_empty_state()?;
                        self.nfa_to_dfa_id[nfa_id] = dfa_id;
                        self.uncompiled_nfa_ids.push(nfa_id);
                        Ok(dfa_id)
                    }
                    /// Unconditionally add a new empty DFA state. If adding it would exceed
                    fn add_empty_state(&mut self) -> Result<StateID, BuildError> {
                        let state_limit = Transition::STATE_ID_LIMIT;
                        let next_id = self.dfa.table.len() >> self.dfa.stride2();
                        let id = StateID::new(next_id)
                            .map_err(|_| BuildError::too_many_states(state_limit))?;
                        
                        if id.as_u64() > Transition::STATE_ID_LIMIT {
                            return Err(BuildError::too_many_states(state_limit));
                        }
                        self.dfa
                            .table
                            .extend(::iter::repeat(Transition(0)).take(self.dfa.stride()));
                        self.dfa.set_pattern_epsilons(id, PatternEpsilons::empty());
                        
                        if let Some(size_limit) = self.config.get_size_limit()
                        {
                            if self.dfa.memory_usage() > size_limit {
                                return Err(BuildError::exceeded_size_limit(size_limit));
                            }
                        }
                        Ok(id)
                    }
                    /// Push the given NFA state ID and its corresponding epsilons (slots and
                    fn stack_push
                    (
                        &mut self,
                        nfa_id: StateID,
                        epsilons: Epsilons,
                    ) -> Result<(), BuildError> {
                        if !self.seen.insert(nfa_id) {
                            return Err(BuildError::not_one_pass(
                                "multiple epsilon transitions to same state",
                            ));
                        }
                        self.stack.push((nfa_id, epsilons));
                        Ok(())
                    }
                }
                /// A one-pass DFA for executing a subset of anchored regex searches while
                #[derive(Clone)]
                pub struct DFA
                {
                    /// The configuration provided by the caller.
                    config: Config,
                    /// The NFA used to build this DFA.
                    nfa: NFA,
                    /// The transition table. Given a state ID 's' and a byte of haystack 'b',
                    table: Vec<Transition>,
                    /// The DFA state IDs of the starting states.
                    starts: Vec<StateID>,
                    /// Every state ID >= this value corresponds to a match state.
                    min_match_id: StateID,
                    /// The alphabet of this DFA, split into equivalence classes. Bytes in the
                    classes: ByteClasses,
                    /// The number of elements in each state in the transition table. This may
                    alphabet_len: usize,
                    /// The number of columns in the transition table, expressed as a power of
                    stride2: usize,
                    /// The offset at which the PatternEpsilons for a match state is stored in
                    pateps_offset: usize,
                    /// The first explicit slot index. This refers to the first slot appearing
                    explicit_slot_start: usize,
                }

                impl DFA
                {
                    /// Parse the given regular expression using the default configuration.
                    #[inline] pub fn new(pattern: &str) -> Result<DFA, BuildError> {
                        DFA::builder().build(pattern)
                    }
                    /// Like `new`, but parses multiple patterns into a single "multi regex."
                    #[inline] pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<DFA, BuildError> {
                        DFA::builder().build_many(patterns)
                    }
                    /// Like `new`, but builds a one-pass DFA directly from an NFA. This is
                    pub fn new_from_nfa(nfa: NFA) -> Result<DFA, BuildError> {
                        DFA::builder().build_from_nfa(nfa)
                    }
                    /// Create a new one-pass DFA that matches every input.
                    pub fn always_match() -> Result<DFA, BuildError> {
                        let nfa = thompson::NFA::always_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    /// Create a new one-pass DFA that never matches any input.
                    pub fn never_match() -> Result<DFA, BuildError> {
                        let nfa = thompson::NFA::never_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    /// Return a default configuration for a DFA.
                    #[inline] pub fn config() -> Config {
                        Config::new()
                    }
                    /// Return a builder for configuring the construction of a DFA.
                    #[inline] pub fn builder() -> Builder {
                        Builder::new()
                    }
                    /// Create a new empty set of capturing groups that is guaranteed to be
                    #[inline] pub fn create_captures(&self) -> Captures {
                        Captures::all(self.nfa.group_info().clone())
                    }
                    /// Create a new cache for this DFA.
                    #[inline] pub fn create_cache(&self) -> Cache {
                        Cache::new(self)
                    }
                    /// Reset the given cache such that it can be used for searching with the
                    #[inline] pub fn reset_cache(&self, cache: &mut Cache) {
                        cache.reset(self);
                    }
                    /// Return the config for this one-pass DFA.
                    #[inline] pub fn get_config(&self) -> &Config {
                        &self.config
                    }
                    /// Returns a reference to the underlying NFA.
                    #[inline] pub fn get_nfa(&self) -> &NFA {
                        &self.nfa
                    }
                    /// Returns the total number of patterns compiled into this DFA.
                    #[inline] pub fn pattern_len(&self) -> usize {
                        self.get_nfa().pattern_len()
                    }
                    /// Returns the total number of states in this one-pass DFA.
                    #[inline] pub fn state_len(&self) -> usize {
                        self.table.len() >> self.stride2()
                    }
                    /// Returns the total number of elements in the alphabet for this DFA.
                    #[inline] pub fn alphabet_len(&self) -> usize {
                        self.alphabet_len
                    }
                    /// Returns the total stride for every state in this DFA, expressed as the
                    #[inline] pub fn stride2(&self) -> usize {
                        self.stride2
                    }
                    /// Returns the total stride for every state in this DFA. This corresponds
                    #[inline] pub fn stride(&self) -> usize {
                        1 << self.stride2()
                    }
                    /// Returns the memory usage, in bytes, of this DFA.
                    #[inline] pub fn memory_usage(&self) -> usize {
                        use ::mem::size_of;

                        self.table.len() * size_of::<Transition>()
                            + self.starts.len() * size_of::<StateID>()
                    }
                }

                impl DFA
                {
                    /// Executes an anchored leftmost forward search, and returns true if and
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> bool {
                        let mut input = input.into().earliest(true);
                        
                        if matches!(input.get_anchored(), Anchored::No) {
                            input.set_anchored(Anchored::Yes);
                        }
                        self.try_search_slots(cache, &input, &mut []).unwrap().is_some()
                    }
                    /// Executes an anchored leftmost forward search, and returns a `Match` if
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> Option<Match> {
                        let mut input = input.into();
                        
                        if matches!(input.get_anchored(), Anchored::No) {
                            input.set_anchored(Anchored::Yes);
                        }
                        
                        if self.get_nfa().pattern_len() == 1 {
                            let mut slots = [None, None];
                            let pid =
                                self.try_search_slots(cache, &input, &mut slots).unwrap()?;
                            let start = slots[0].unwrap().get();
                            let end = slots[1].unwrap().get();
                            
                            return Some(Match::new(pid, Span { start, end }));
                        }
                        let ginfo = self.get_nfa().group_info();
                        let slots_len = ginfo.implicit_slot_len();
                        let mut slots = vec![None; slots_len];
                        let pid = self.try_search_slots(cache, &input, &mut slots).unwrap()?;
                        let start = slots[pid.as_usize() * 2].unwrap().get();
                        let end = slots[pid.as_usize() * 2 + 1].unwrap().get();
                        Some(Match::new(pid, Span { start, end }))
                    }
                    /// Executes an anchored leftmost forward search and writes the spans
                    #[inline] pub fn captures<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                        caps: &mut Captures,
                    ) {
                        let mut input = input.into();
                        
                        if matches!(input.get_anchored(), Anchored::No) {
                            input.set_anchored(Anchored::Yes);
                        }
                        self.try_search(cache, &input, caps).unwrap();
                    }
                    /// Executes an anchored leftmost forward search and writes the spans
                    #[inline] pub fn try_search(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        caps: &mut Captures,
                    ) -> Result<(), MatchError> {
                        let pid = self.try_search_slots(cache, input, caps.slots_mut())?;
                        caps.set_pattern(pid);
                        Ok(())
                    }
                    /// Executes an anchored leftmost forward search and writes the spans
                    #[inline] pub fn try_search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Result<Option<PatternID>, MatchError> {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        
                        if !utf8empty {
                            return self.try_search_slots_imp(cache, input, slots);
                        }
                        // See PikeVM::try_search_slots for why we do this.
                        let min = self.get_nfa().group_info().implicit_slot_len();
                        
                        if slots.len() >= min {
                            return self.try_search_slots_imp(cache, input, slots);
                        }
                        
                        if self.get_nfa().pattern_len() == 1 {
                            let mut enough = [None, None];
                            let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                            slots.copy_from_slice(&enough[..slots.len()]);
                            
                            return Ok(got);
                        }
                        let mut enough = vec![None; min];
                        let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                        slots.copy_from_slice(&enough[..slots.len()]);
                        Ok(got)
                    }

                    #[inline(never)]
                    fn try_search_slots_imp(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Result<Option<PatternID>, MatchError> {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        match self.search_imp(cache, input, slots)? {
                            None => return Ok(None),
                            Some(pid) if !utf8empty => return Ok(Some(pid)),
                            Some(pid) => {
                                let slot_start = pid.as_usize().wrapping_mul(2);
                                let slot_end = slot_start.wrapping_add(1);
                                let start = slots[slot_start].unwrap().get();
                                let end = slots[slot_end].unwrap().get();
                                
                                if start == end && !input.is_char_boundary(start) {
                                    return Ok(None);
                                }
                                Ok(Some(pid))
                            }
                        }
                    }
                }

                impl DFA {
                    fn search_imp(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Result<Option<PatternID>, MatchError> {

                        if input.is_done() {
                            return Ok(None);
                        }
                        let explicit_slots_len = ::cmp::min(
                            Slots::LIMIT,
                            slots.len().saturating_sub(self.explicit_slot_start),
                        );
                        cache.setup_search(explicit_slots_len);
                        for slot in cache.explicit_slots() {
                            *slot = None;
                        }
                        for slot in slots.iter_mut() {
                            *slot = None;
                        }
                        for pid in self.nfa.patterns() {
                            let i = pid.as_usize() * 2;
                            if i >= slots.len() {
                                break;
                            }
                            slots[i] = NonMaxUsize::new(input.start());
                        }
                        let mut pid = None;
                        let mut next_sid = match input.get_anchored() {
                            Anchored::Yes => self.start(),
                            Anchored::Pattern(pid) => self.start_pattern(pid)?,
                            Anchored::No => {
                                if !self.nfa.is_always_start_anchored() {
                                    return Err(MatchError::unsupported_anchored(
                                        Anchored::No,
                                    ));
                                }
                                self.start()
                            }
                        };
                        let leftmost_first =
                            matches!(self.config.get_match_kind(), MatchKind::LeftmostFirst);
                        for at in input.start()..input.end() {
                            let sid = next_sid;
                            let trans = self.transition(sid, input.haystack()[at]);
                            next_sid = trans.state_id();
                            let epsilons = trans.epsilons();
                            if sid >= self.min_match_id {
                                if self.find_match(cache, input, at, sid, slots, &mut pid) {
                                    if input.get_earliest()
                                        || (leftmost_first && trans.match_wins())
                                    {
                                        return Ok(pid);
                                    }
                                }
                            }
                            
                            if sid == DEAD
                                || (!epsilons.looks().is_empty()
                                    && !self.nfa.look_matcher().matches_set_inline(
                                        epsilons.looks(),
                                        input.haystack(),
                                        at,
                                    ))
                            {
                                return Ok(pid);
                            }
                            epsilons.slots().apply(at, cache.explicit_slots());
                        }
                        
                        if next_sid >= self.min_match_id {
                            self.find_match(
                                cache,
                                input,
                                input.end(),
                                next_sid,
                                slots,
                                &mut pid,
                            );
                        }
                        Ok(pid)
                    }
                    /// Assumes 'sid' is a match state and looks for whether a match can
                    #[inline( always )]
                    fn find_match(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        at: usize,
                        sid: StateID,
                        slots: &mut [Option<NonMaxUsize>],
                        matched_pid: &mut Option<PatternID>,
                    ) -> bool {
                        debug_assert!(sid >= self.min_match_id);
                        let pateps = self.pattern_epsilons(sid);
                        let epsilons = pateps.epsilons();
                        
                        if !epsilons.looks().is_empty()
                            && !self.nfa.look_matcher().matches_set_inline(
                                epsilons.looks(),
                                input.haystack(),
                                at,
                            )
                        {
                            return false;
                        }
                        let pid = pateps.pattern_id_unchecked();
                        let slot_end = pid.as_usize().wrapping_mul(2).wrapping_add(1);
                        
                        if slot_end < slots.len() {
                            slots[slot_end] = NonMaxUsize::new(at);
                        }
                        
                        if self.explicit_slot_start < slots.len() {
                            slots[self.explicit_slot_start..]
                                .copy_from_slice(cache.explicit_slots());
                            epsilons.slots().apply(at, &mut slots[self.explicit_slot_start..]);
                        }
                        *matched_pid = Some(pid);
                        true
                    }
                }

                impl DFA
                {
                    /// Returns the anchored start state for matching any pattern in this DFA.
                    fn start(&self) -> StateID {
                        self.starts[0]
                    }
                    /// Returns the anchored start state for matching the given pattern. If
                    fn start_pattern(&self, pid: PatternID) -> Result<StateID, MatchError> {
                        if !self.config.get_starts_for_each_pattern() {
                            return Err(MatchError::unsupported_anchored(Anchored::Pattern(
                                pid,
                            )));
                        }
                        Ok(self.starts.get(pid.one_more()).copied().unwrap_or(DEAD))
                    }
                    /// Returns the transition from the given state ID and byte of input. The
                    fn transition(&self, sid: StateID, byte: u8) -> Transition {
                        let offset = sid.as_usize() << self.stride2();
                        let class = self.classes.get(byte).as_usize();
                        self.table[offset + class]
                    }
                    /// Set the transition from the given state ID and byte of input to the
                    fn set_transition(&mut self, sid: StateID, byte: u8, to: Transition) {
                        let offset = sid.as_usize() << self.stride2();
                        let class = self.classes.get(byte).as_usize();
                        self.table[offset + class] = to;
                    }
                    /// Return an iterator of "sparse" transitions for the given state ID.
                    fn sparse_transitions(&self, sid: StateID) -> SparseTransitionIter<'_> {
                        let start = sid.as_usize() << self.stride2();
                        let end = start + self.alphabet_len();
                        SparseTransitionIter {
                            it: self.table[start..end].iter().enumerate(),
                            cur: None,
                        }
                    }
                    /// Return the pattern epsilons for the given state ID.
                    fn pattern_epsilons(&self, sid: StateID) -> PatternEpsilons {
                        let offset = sid.as_usize() << self.stride2();
                        PatternEpsilons(self.table[offset + self.pateps_offset].0)
                    }
                    /// Set the pattern epsilons for the given state ID.
                    fn set_pattern_epsilons(&mut self, sid: StateID, pateps: PatternEpsilons) {
                        let offset = sid.as_usize() << self.stride2();
                        self.table[offset + self.pateps_offset] = Transition(pateps.0);
                    }
                    /// Returns the state ID prior to the one given. This returns None if the
                    fn prev_state_id(&self, id: StateID) -> Option<StateID> {
                        if id == DEAD {
                            None
                        } else {
                            Some(StateID::new_unchecked(id.as_usize().checked_sub(1).unwrap()))
                        }
                    }
                    /// Returns the state ID of the last state in this DFA's transition table.
                    fn last_state_id(&self) -> StateID {
                        StateID::new_unchecked(
                            (self.table.len() >> self.stride2()).checked_sub(1).unwrap(),
                        )
                    }
                    /// Move the transitions from 'id1' to 'id2' and vice versa.
                    pub(super) fn swap_states(&mut self, id1: StateID, id2: StateID) {
                        let o1 = id1.as_usize() << self.stride2();
                        let o2 = id2.as_usize() << self.stride2();
                        for b in 0..self.stride() {
                            self.table.swap(o1 + b, o2 + b);
                        }
                    }
                    /// Map all state IDs in this DFA (transition table + start states)
                    pub(super) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
                        for i in 0..self.state_len() {
                            let offset = i << self.stride2();
                            for b in 0..self.alphabet_len() {
                                let next = self.table[offset + b].state_id();
                                self.table[offset + b].set_state_id(map(next));
                            }
                        }
                        for i in 0..self.starts.len() {
                            self.starts[i] = map(self.starts[i]);
                        }
                    }
                }

                impl ::fmt::Debug for DFA {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        fn debug_state_transitions(
                            f: &mut ::fmt::Formatter,
                            dfa: &DFA,
                            sid: StateID,
                        ) -> ::fmt::Result {
                            for (i, (start, end, trans)) in
                                dfa.sparse_transitions(sid).enumerate()
                            {
                                let next = trans.state_id();
                                
                                if i > 0 {
                                    write!(f, ", ")?;
                                }
                                if start == end {
                                    write!(
                                        f,
                                        "{:?} => {:?}",
                                        DebugByte(start),
                                        next.as_usize(),
                                    )?;
                                } else {
                                    write!(
                                        f,
                                        "{:?}-{:?} => {:?}",
                                        DebugByte(start),
                                        DebugByte(end),
                                        next.as_usize(),
                                    )?;
                                }
                                if trans.match_wins() {
                                    write!(f, " (MW)")?;
                                }
                                if !trans.epsilons().is_empty() {
                                    write!(f, " ({:?})", trans.epsilons())?;
                                }
                            }
                            Ok(())
                        }

                        writeln!(f, "onepass::DFA(")?;
                        for index in 0..self.state_len() {
                            let sid = StateID::must(index);
                            let pateps = self.pattern_epsilons(sid);
                            if sid == DEAD {
                                write!(f, "D ")?;
                            } else if pateps.pattern_id().is_some() {
                                write!(f, "* ")?;
                            } else {
                                write!(f, "  ")?;
                            }
                            write!(f, "{:06?}", sid.as_usize())?;
                            if !pateps.is_empty() {
                                write!(f, " ({pateps:?})")?;
                            }
                            write!(f, ": ")?;
                            debug_state_transitions(f, self, sid)?;
                            write!(f, "\n")?;
                        }
                        writeln!(f, "")?;
                        for (i, &sid) in self.starts.iter().enumerate()
                        {
                            if i == 0 {
                                writeln!(f, "START(ALL): {:?}", sid.as_usize())?;
                            } else {
                                writeln!(
                                    f,
                                    "START(pattern: {:?}): {:?}",
                                    i - 1,
                                    sid.as_usize(),
                                )?;
                            }
                        }
                        writeln!(f, "state length: {:?}", self.state_len())?;
                        writeln!(f, "pattern length: {:?}", self.pattern_len())?;
                        writeln!(f, ")")?;
                        Ok(())
                    }
                }
                /// An iterator over groups of consecutive equivalent transitions in a single
                #[derive(Debug)]
                struct SparseTransitionIter<'a> {
                    it: ::iter::Enumerate<::slice::Iter<'a, Transition>>,
                    cur: Option<(u8, u8, Transition)>,
                }

                impl<'a> Iterator for SparseTransitionIter<'a> {
                    type Item = (u8, u8, Transition);

                    fn next(&mut self) -> Option<(u8, u8, Transition)> {
                        while let Some((b, &trans)) = self.it.next() {
                            let b = b.as_u8();
                            let (prev_start, prev_end, prev_trans) = match self.cur {
                                Some(t) => t,
                                None => {
                                    self.cur = Some((b, b, trans));
                                    continue;
                                }
                            };
                            if prev_trans == trans {
                                self.cur = Some((prev_start, b, prev_trans));
                            } else {
                                self.cur = Some((b, b, trans));
                                
                                if prev_trans.state_id() != DEAD {
                                    return Some((prev_start, prev_end, prev_trans));
                                }
                            }
                        }
                        
                        if let Some((start, end, trans)) = self.cur.take()
                        {
                            if trans.state_id() != DEAD {
                                return Some((start, end, trans));
                            }
                        }
                        None
                    }
                }
                /// A cache represents mutable state that a one-pass [`DFA`] requires during a
                #[derive(Clone, Debug)]
                pub struct Cache
                {
                    /// Scratch space used to store slots during a search. Basically, we use
                    explicit_slots: Vec<Option<NonMaxUsize>>,
                    /// The number of slots in the caller-provided 'Captures' value for the
                    explicit_slot_len: usize,
                }

                impl Cache
                {
                    /// Create a new [`onepass::DFA`](DFA) cache.
                    pub fn new(re: &DFA) -> Cache {
                        let mut cache = Cache { explicit_slots: vec![], explicit_slot_len: 0 };
                        cache.reset(re);
                        cache
                    }
                    /// Reset this cache such that it can be used for searching with a
                    pub fn reset(&mut self, re: &DFA) {
                        let explicit_slot_len = re.get_nfa().group_info().explicit_slot_len();
                        self.explicit_slots.resize(explicit_slot_len, None);
                        self.explicit_slot_len = explicit_slot_len;
                    }
                    /// Returns the heap memory usage, in bytes, of this cache.
                    pub fn memory_usage(&self) -> usize {
                        self.explicit_slots.len() * ::mem::size_of::<Option<NonMaxUsize>>()
                    }

                    fn explicit_slots(&mut self) -> &mut [Option<NonMaxUsize>] {
                        &mut self.explicit_slots[..self.explicit_slot_len]
                    }

                    fn setup_search(&mut self, explicit_slot_len: usize) {
                        self.explicit_slot_len = explicit_slot_len;
                    }
                }
                /// Represents a single transition in a one-pass DFA.
                #[derive(Clone, Copy, Eq, PartialEq)]
                struct Transition(u64);

                impl Transition {
                    const STATE_ID_BITS: u64 = 21;
                    const STATE_ID_SHIFT: u64 = 64 - Transition::STATE_ID_BITS;
                    const STATE_ID_LIMIT: u64 = 1 << Transition::STATE_ID_BITS;
                    const MATCH_WINS_SHIFT: u64 = 64 - (Transition::STATE_ID_BITS + 1);
                    const INFO_MASK: u64 = 0x000003FF_FFFFFFFF;
                    /// Return a new transition to the given state ID with the given epsilons.
                    fn new(match_wins: bool, sid: StateID, epsilons: Epsilons) -> Transition {
                        let match_wins =
                            if match_wins { 1 << Transition::MATCH_WINS_SHIFT } else { 0 };
                        let sid = sid.as_u64() << Transition::STATE_ID_SHIFT;
                        Transition(sid | match_wins | epsilons.0)
                    }
                    /// Returns true if and only if this transition points to the DEAD state.
                    fn is_dead(self) -> bool {
                        self.state_id() == DEAD
                    }
                    /// Return whether this transition has a "match wins" property.
                    fn match_wins(&self) -> bool {
                        (self.0 >> Transition::MATCH_WINS_SHIFT & 1) == 1
                    }
                    /// Return the "next" state ID that this transition points to.
                    fn state_id(&self) -> StateID {
                        StateID::new_unchecked(
                            (self.0 >> Transition::STATE_ID_SHIFT).as_usize(),
                        )
                    }
                    /// Set the "next" state ID in this transition.
                    fn set_state_id(&mut self, sid: StateID) {
                        *self = Transition::new(self.match_wins(), sid, self.epsilons());
                    }
                    /// Return the epsilons embedded in this transition.
                    fn epsilons(&self) -> Epsilons {
                        Epsilons(self.0 & Transition::INFO_MASK)
                    }
                }

                impl ::fmt::Debug for Transition {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.is_dead() {
                            return write!(f, "0");
                        }
                        write!(f, "{}", self.state_id().as_usize())?;
                        
                        if self.match_wins() {
                            write!(f, "-MW")?;
                        }
                        
                        if !self.epsilons().is_empty() {
                            write!(f, "-{:?}", self.epsilons())?;
                        }
                        Ok(())
                    }
                }
                /// A representation of a match state's pattern ID along with the epsilons for
                #[derive(Clone, Copy)]
                struct PatternEpsilons(u64);

                impl PatternEpsilons {
                    const PATTERN_ID_BITS: u64 = 22;
                    const PATTERN_ID_SHIFT: u64 = 64 - PatternEpsilons::PATTERN_ID_BITS;
                    const PATTERN_ID_NONE: u64 = 0x00000000_003FFFFF;
                    const PATTERN_ID_LIMIT: u64 = PatternEpsilons::PATTERN_ID_NONE;
                    const PATTERN_ID_MASK: u64 = 0xFFFFFC00_00000000;
                    const EPSILONS_MASK: u64 = 0x000003FF_FFFFFFFF;
                    /// Return a new empty pattern epsilons that has no pattern ID and has no
                    fn empty() -> PatternEpsilons {
                        PatternEpsilons(
                            PatternEpsilons::PATTERN_ID_NONE
                                << PatternEpsilons::PATTERN_ID_SHIFT,
                        )
                    }
                    /// Whether this pattern epsilons is empty or not. It's empty when it has
                    fn is_empty(self) -> bool {
                        self.pattern_id().is_none() && self.epsilons().is_empty()
                    }
                    /// Return the pattern ID in this pattern epsilons if one exists.
                    fn pattern_id(self) -> Option<PatternID> {
                        let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
                        
                        if pid == PatternEpsilons::PATTERN_ID_LIMIT {
                            None
                        } else {
                            Some(PatternID::new_unchecked(pid.as_usize()))
                        }
                    }
                    /// Returns the pattern ID without checking whether it's valid. If this is
                    fn pattern_id_unchecked(self) -> PatternID {
                        let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
                        PatternID::new_unchecked(pid.as_usize())
                    }
                    /// Return a new pattern epsilons with the given pattern ID, but the same
                    fn set_pattern_id(self, pid: PatternID) -> PatternEpsilons {
                        PatternEpsilons(
                            (pid.as_u64() << PatternEpsilons::PATTERN_ID_SHIFT)
                                | (self.0 & PatternEpsilons::EPSILONS_MASK),
                        )
                    }
                    /// Return the epsilons part of this pattern epsilons.
                    fn epsilons(self) -> Epsilons {
                        Epsilons(self.0 & PatternEpsilons::EPSILONS_MASK)
                    }
                    /// Return a new pattern epsilons with the given epsilons, but the same
                    fn set_epsilons(self, epsilons: Epsilons) -> PatternEpsilons {
                        PatternEpsilons(
                            (self.0 & PatternEpsilons::PATTERN_ID_MASK)
                                | (u64::from(epsilons.0) & PatternEpsilons::EPSILONS_MASK),
                        )
                    }
                }

                impl ::fmt::Debug for PatternEpsilons {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.is_empty() {
                            return write!(f, "N/A");
                        }
                        
                        if let Some(pid) = self.pattern_id() {
                            write!(f, "{}", pid.as_usize())?;
                        }
                        
                        if !self.epsilons().is_empty()
                        {
                            if self.pattern_id().is_some() {
                                write!(f, "/")?;
                            }
                            write!(f, "{:?}", self.epsilons())?;
                        }
                        Ok(())
                    }
                }
                /// Epsilons represents all of the NFA epsilons transitions that went into a
                #[derive(Clone, Copy)]
                struct Epsilons(u64);

                impl Epsilons {
                    const SLOT_MASK: u64 = 0x000003FF_FFFFFC00;
                    const SLOT_SHIFT: u64 = 10;
                    const LOOK_MASK: u64 = 0x00000000_000003FF;
                    /// Create a new empty epsilons. It has no slots and no assertions that
                    fn empty() -> Epsilons {
                        Epsilons(0)
                    }
                    /// Returns true if this epsilons contains no slots and no assertions.
                    fn is_empty(self) -> bool {
                        self.0 == 0
                    }
                    /// Returns the slot epsilon transitions.
                    fn slots(self) -> Slots {
                        Slots((self.0 >> Epsilons::SLOT_SHIFT).low_u32())
                    }
                    /// Set the slot epsilon transitions.
                    fn set_slots(self, slots: Slots) -> Epsilons {
                        Epsilons(
                            (u64::from(slots.0) << Epsilons::SLOT_SHIFT)
                                | (self.0 & Epsilons::LOOK_MASK),
                        )
                    }
                    /// Return the set of look-around assertions in these epsilon transitions.
                    fn looks(self) -> LookSet {
                        LookSet { bits: (self.0 & Epsilons::LOOK_MASK).low_u32() }
                    }
                    /// Set the look-around assertions on these epsilon transitions.
                    fn set_looks(self, look_set: LookSet) -> Epsilons {
                        Epsilons(
                            (self.0 & Epsilons::SLOT_MASK)
                                | (u64::from(look_set.bits) & Epsilons::LOOK_MASK),
                        )
                    }
                }

                impl ::fmt::Debug for Epsilons {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let mut wrote = false;
                        
                        if !self.slots().is_empty() {
                            write!(f, "{:?}", self.slots())?;
                            wrote = true;
                        }
                        
                        if !self.looks().is_empty()
                        {
                            if wrote {
                                write!(f, "/")?;
                            }
                            write!(f, "{:?}", self.looks())?;
                            wrote = true;
                        }
                        
                        if !wrote {
                            write!(f, "N/A")?;
                        }
                        Ok(())
                    }
                }
                /// The set of epsilon transitions indicating that the current position in a
                #[derive(Clone, Copy)]
                struct Slots(u32);

                impl Slots {
                    const LIMIT: usize = 32;
                    /// Insert the slot at the given bit index.
                    fn insert(self, slot: usize) -> Slots {
                        debug_assert!(slot < Slots::LIMIT);
                        Slots(self.0 | (1 << slot.as_u32()))
                    }
                    /// Remove the slot at the given bit index.
                    fn remove(self, slot: usize) -> Slots {
                        debug_assert!(slot < Slots::LIMIT);
                        Slots(self.0 & !(1 << slot.as_u32()))
                    }
                    /// Returns true if and only if this set contains no slots.
                    fn is_empty(self) -> bool {
                        self.0 == 0
                    }
                    /// Returns an iterator over all of the set bits in this set.
                    fn iter(self) -> SlotsIter {
                        SlotsIter { slots: self }
                    }
                    /// For the position `at` in the current haystack, copy it to
                    fn apply(
                        self,
                        at: usize,
                        caller_explicit_slots: &mut [Option<NonMaxUsize>],
                    ) {
                        if self.is_empty() {
                            return;
                        }
                        let at = NonMaxUsize::new(at);
                        for slot in self.iter()
                        {
                            if slot >= caller_explicit_slots.len() {
                                break;
                            }
                            caller_explicit_slots[slot] = at;
                        }
                    }
                }

                impl ::fmt::Debug for Slots {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "S")?;
                        for slot in self.iter() {
                            write!(f, "-{slot:?}")?;
                        }
                        Ok(())
                    }
                }
                /// An iterator over all of the bits set in a slot set.
                #[derive(Debug)]
                struct SlotsIter {
                    slots: Slots,
                }

                impl Iterator for SlotsIter {
                    type Item = usize;

                    fn next(&mut self) -> Option<usize> {
                        // Number of zeroes here is always <= u8::MAX, and so fits in a usize.
                        let slot = self.slots.0.trailing_zeros().as_usize();
                        
                        if slot >= Slots::LIMIT {
                            return None;
                        }
                        self.slots = self.slots.remove(slot);
                        Some(slot)
                    }
                }
                /// An error that occurred during the construction of a one-pass DFA.
                #[derive(Clone, Debug)]
                pub struct BuildError {
                    kind: BuildErrorKind,
                }
                /// The kind of error that occurred during the construction of a one-pass DFA.
                #[derive(Clone, Debug)]
                enum BuildErrorKind {
                    NFA(crate::nfa::thompson::BuildError),
                    Word(UnicodeWordBoundaryError),
                    TooManyStates { limit: u64 },
                    TooManyPatterns { limit: u64 },
                    UnsupportedLook { look: Look },
                    ExceededSizeLimit { limit: usize },
                    NotOnePass { msg: &'static str },
                }

                impl BuildError {
                    fn nfa(err: crate::nfa::thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }

                    fn word(err: UnicodeWordBoundaryError) -> BuildError {
                        BuildError { kind: BuildErrorKind::Word(err) }
                    }

                    fn too_many_states(limit: u64) -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyStates { limit } }
                    }

                    fn too_many_patterns(limit: u64) -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyPatterns { limit } }
                    }

                    fn unsupported_look(look: Look) -> BuildError {
                        BuildError { kind: BuildErrorKind::UnsupportedLook { look } }
                    }

                    fn exceeded_size_limit(limit: usize) -> BuildError {
                        BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit } }
                    }

                    fn not_one_pass(msg: &'static str) -> BuildError {
                        BuildError { kind: BuildErrorKind::NotOnePass { msg } }
                    }
                }
                
                impl ::error::Error for BuildError {
                    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                        use self::BuildErrorKind::*;

                        match self.kind {
                            NFA(ref err) => Some(err),
                            Word(ref err) => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for BuildError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        use self::BuildErrorKind::*;

                        match self.kind {
                            NFA(_) => write!(f, "error building NFA"),
                            Word(_) => write!(f, "NFA contains Unicode word boundary"),
                            TooManyStates { limit } => write!(
                                f,
                                "one-pass DFA exceeded a limit of {limit:?} \
                                for number of states",
                            ),
                            TooManyPatterns { limit } => write!(
                                f,
                                "one-pass DFA exceeded a limit of {limit:?} \
                                for number of patterns",
                            ),
                            UnsupportedLook { look } => write!(
                                f,
                                "one-pass DFA does not support the {look:?} assertion",
                            ),
                            ExceededSizeLimit { limit } => write!(
                                f,
                                "one-pass DFA exceeded size limit of {limit:?} during building",
                            ),
                            NotOnePass { msg } => write!(
                                f,
                                "one-pass DFA could not be built because \
                                pattern is not one-pass: {}",
                                msg,
                            ),
                        }
                    }
                }
            }

            pub mod regex
            {
                /*!
                A DFA-backed `Regex`. */
                use ::
                {
                    regex::automata::
                    {
                        dfa::{ automaton::Automaton, dense::{ self, BuildError}, sparse, StartKind },
                        util::{ iter, search::{ Input, MatchKind } },
                        Anchored, Match, MatchError,
                    },
                    vec::{ Vec },
                    *,
                };
                /*
                */
                macro_rules! define_regex_type
                {
                    ($(#[$doc:meta])*) =>
                    {
                                $(#[$doc])*
                        pub struct Regex<A = dense::OwnedDFA>
                        {
                            forward: A,
                            reverse: A,
                        }
                    };
                }

                define_regex_type!
                (
                    /// A regular expression that uses deterministic finite automata for fast
                    #[derive(Clone, Debug)]
                );

                impl Regex
                {
                    /// Parse the given regular expression using the default configuration and
                    pub fn new(pattern: &str) -> Result<Regex, BuildError> {
                        Builder::new().build(pattern)
                    }
                    /// Like `new`, but parses multiple patterns into a single "regex set."
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        Builder::new().build_many(patterns)
                    }
                }

                impl Regex<sparse::DFA<Vec<u8>>>
                {
                    /// Parse the given regular expression using the default configuration,
                    pub fn new_sparse(
                        pattern: &str,
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> {
                        Builder::new().build_sparse(pattern)
                    }
                    /// Like `new`, but parses multiple patterns into a single "regex set"
                    pub fn new_many_sparse<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> {
                        Builder::new().build_many_sparse(patterns)
                    }
                }
                /// Convenience routines for regex construction.
                impl Regex<dense::DFA<&'static [u32]>>
                {
                    /// Return a builder for configuring the construction of a `Regex`.
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                }
                /// Standard search routines for finding and iterating over matches.
                impl<A: Automaton> Regex<A>
                {
                    /// Returns true if and only if this regex matches the given haystack.
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(&self, input: I) -> bool {
                        let input = input.into().earliest(true);
                        self.forward().try_search_fwd(&input).map(|x| x.is_some()).unwrap()
                    }
                    /// Returns the start and end offset of the leftmost match. If no match
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(&self, input: I) -> Option<Match> {
                        self.try_search(&input.into()).unwrap()
                    }
                    /// Returns an iterator over all non-overlapping leftmost matches in the
                    #[inline] pub fn find_iter<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> FindMatches<'r, 'h, A> {
                        let it = iter::Searcher::new(input.into());
                        FindMatches { re: self, it }
                    }
                }
                /// Lower level fallible search routines that permit controlling where the
                impl<A: Automaton> Regex<A>
                {
                    /// Returns the start and end offset of the leftmost match. If no match
                    #[inline] pub fn try_search(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, MatchError> {
                        let (fwd, rev) = (self.forward(), self.reverse());
                        let end = match fwd.try_search_fwd(input)? {
                            None => return Ok(None),
                            Some(end) => end,
                        };
                        
                        if input.start() == end.offset() {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                end.offset()..end.offset(),
                            )));
                        }
                        
                        if self.is_anchored(input) {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                input.start()..end.offset(),
                            )));
                        }
                        let revsearch = input
                            .clone()
                            .span(input.start()..end.offset())
                            .anchored(Anchored::Yes)
                            .earliest(false);
                        let start = rev
                            .try_search_rev(&revsearch)?
                            .expect("reverse search must match if forward search does");
                        assert_eq!(
                            start.pattern(),
                            end.pattern(),
                            "forward and reverse search must match same pattern",
                        );
                        assert!(start.offset() <= end.offset());
                        Ok(Some(Match::new(end.pattern(), start.offset()..end.offset())))
                    }
                    /// Returns true if either the given input specifies an anchored search
                    fn is_anchored(&self, input: &Input<'_>) -> bool {
                        match input.get_anchored() {
                            Anchored::No => self.forward().is_always_start_anchored(),
                            Anchored::Yes | Anchored::Pattern(_) => true,
                        }
                    }
                }
                /// Non-search APIs for querying information about the regex and setting a
                impl<A: Automaton> Regex<A>
                {
                    /// Return the underlying DFA responsible for forward matching.
                    pub fn forward(&self) -> &A {
                        &self.forward
                    }
                    /// Return the underlying DFA responsible for reverse matching.
                    pub fn reverse(&self) -> &A {
                        &self.reverse
                    }
                    /// Returns the total number of patterns matched by this regex.
                    pub fn pattern_len(&self) -> usize {
                        assert_eq!(self.forward().pattern_len(), self.reverse().pattern_len());
                        self.forward().pattern_len()
                    }
                }
                /// An iterator over all non-overlapping matches for an infallible search.
                #[derive(Debug)]
                pub struct FindMatches<'r, 'h, A> {
                    re: &'r Regex<A>,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'h, A: Automaton> Iterator for FindMatches<'r, 'h, A> {
                    type Item = Match;

                    #[inline]
                    fn next(&mut self) -> Option<Match> {
                        let FindMatches { re, ref mut it } = *self;
                        it.advance(|input| re.try_search(input))
                    }
                }
                /// A builder for a regex based on deterministic finite automatons.
                #[derive(Clone, Debug)]
                pub struct Builder {
                        dfa: dense::Builder,
                }

                impl Builder
                {
                    /// Create a new regex builder with the default configuration.
                    pub fn new() -> Builder {
                        Builder {
                                        dfa: dense::Builder::new(),
                        }
                    }
                    /// Build a regex from the given pattern.
                        pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> {
                        self.build_many(&[pattern])
                    }
                    /// Build a regex from the given pattern using sparse DFAs.
                        pub fn build_sparse(
                        &self,
                        pattern: &str,
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> {
                        self.build_many_sparse(&[pattern])
                    }
                    /// Build a regex from the given patterns.
                        pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        let forward = self.dfa.build_many(patterns)?;
                        let reverse = self
                            .dfa
                            .clone()
                            .configure(
                                dense::Config::new()
                                    .prefilter(None)
                                    .specialize_start_states(false)
                                    .start_kind(StartKind::Anchored)
                                    .match_kind(MatchKind::All),
                            )
                            .thompson(crate::nfa::thompson::Config::new().reverse(true))
                            .build_many(patterns)?;
                        Ok(self.build_from_dfas(forward, reverse))
                    }
                    /// Build a sparse regex from the given patterns.
                        pub fn build_many_sparse<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> {
                        let re = self.build_many(patterns)?;
                        let forward = re.forward().to_sparse()?;
                        let reverse = re.reverse().to_sparse()?;
                        Ok(self.build_from_dfas(forward, reverse))
                    }
                    /// Build a regex from its component forward and reverse DFAs.
                    pub fn build_from_dfas<A: Automaton>(
                        &self,
                        forward: A,
                        reverse: A,
                    ) -> Regex<A> {
                        Regex { forward, reverse }
                    }
                    /// Set the syntax configuration for this builder using
                        pub fn syntax
                    (
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.dfa.syntax(config);
                        self
                    }
                    /// Set the Thompson NFA configuration for this builder using
                        pub fn thompson
                    (
                        &mut self,
                        config: crate::nfa::thompson::Config,
                    ) -> &mut Builder {
                        self.dfa.thompson(config);
                        self
                    }
                    /// Set the dense DFA compilation configuration for this builder using
                        pub fn dense(&mut self, config: dense::Config) -> &mut Builder {
                        self.dfa.configure(config);
                        self
                    }
                }

                impl Default for Builder {
                    fn default() -> Builder {
                        Builder::new()
                    }
                }
            }

            pub mod sparse
            {
                /*!
                Types and routines specific to sparse DFAs. */
                use ::
                {
                    mem::{ size_of },
                    regex::automata::
                    {
                        dfa::
                        {
                            automaton::{fmt_state_indicator, Automaton, StartError},
                            dense::{self, BuildError, Flags},
                            special::Special,
                            StartKind, DEAD,
                        },
                        util::
                        {
                            alphabet::{ByteClasses, ByteSet},
                            escape::DebugByte,
                            int::{Pointer, Usize, U16, U32},
                            prefilter::Prefilter,
                            primitives::{PatternID, StateID},
                            search::Anchored,
                            start::{self, Start, StartByteMap},
                            wire::{self, DeserializeError, Endian, SerializeError},
                        },
                    },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                const LABEL: &str = "rust-regex-automata-dfa-sparse";
                const VERSION: u32 = 2;
                /// A sparse deterministic finite automaton (DFA) with variable sized states.
                #[derive(Clone)]
                pub struct DFA<T> {
                    tt: Transitions<T>,
                    st: StartTable<T>,
                    special: Special,
                    pre: Option<Prefilter>,
                    quitset: ByteSet,
                    flags: Flags,
                }

                impl DFA<Vec<u8>>
                {
                    /// Parse the given regular expression using a default configuration and
                    pub fn new(pattern: &str) -> Result<DFA<Vec<u8>>, BuildError> {
                        dense::Builder::new()
                            .build(pattern)
                            .and_then(|dense| dense.to_sparse())
                    }
                    /// Parse the given regular expressions using a default configuration and
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<DFA<Vec<u8>>, BuildError> {
                        dense::Builder::new()
                            .build_many(patterns)
                            .and_then(|dense| dense.to_sparse())
                    }
                }

                impl DFA<Vec<u8>>
                {
                    /// Create a new DFA that matches every input.
                    pub fn always_match() -> Result<DFA<Vec<u8>>, BuildError> {
                        dense::DFA::always_match()?.to_sparse()
                    }
                    /// Create a new sparse DFA that never matches any input.
                    pub fn never_match() -> Result<DFA<Vec<u8>>, BuildError> {
                        dense::DFA::never_match()?.to_sparse()
                    }
                    /// The implementation for constructing a sparse DFA from a dense DFA.
                    pub fn from_dense<T: AsRef<[u32]>>(
                        dfa: &dense::DFA<T>,
                    ) -> Result<DFA<Vec<u8>>, BuildError> {
                        let mut sparse = Vec::with_capacity(StateID::SIZE * dfa.state_len());
                        let mut remap: Vec<StateID> = vec![DEAD; dfa.state_len()];
                        for state in dfa.states() {
                            let pos = sparse.len();

                            remap[dfa.to_index(state.id())] = StateID::new(pos)
                                .map_err(|_| BuildError::too_many_states())?;
                            // zero-filled space for the transition length
                            sparse.push(0);
                            sparse.push(0);

                            let mut transition_len = 0;
                            for (unit1, unit2, _) in state.sparse_transitions() {
                                match (unit1.as_u8(), unit2.as_u8()) {
                                    (Some(b1), Some(b2)) => {
                                        transition_len += 1;
                                        sparse.push(b1);
                                        sparse.push(b2);
                                    }
                                    (None, None) => {}
                                    (Some(_), None) | (None, Some(_)) => {
                                        unreachable!()
                                    }
                                }
                            }
                            transition_len += 1;
                            sparse.push(0);
                            sparse.push(0);

                            // Check some assumptions about transition length.
                            assert_ne!(
                                transition_len, 0,
                                "transition length should be non-zero",
                            );
                            assert!(
                                transition_len <= 257,
                                "expected transition length {transition_len} to be <= 257",
                            );
                            let ntrans = if dfa.is_match_state(state.id()) {
                                transition_len | (1 << 15)
                            } else {
                                transition_len
                            };
                            wire::NE::write_u16(ntrans, &mut sparse[pos..]);
                            let zeros = usize::try_from(transition_len)
                                .unwrap()
                                .checked_mul(StateID::SIZE)
                                .unwrap();
                            sparse.extend(iter::repeat(0).take(zeros));
                            if dfa.is_match_state(state.id()) {
                                let plen = dfa.match_pattern_len(state.id());
                                let mut pos = sparse.len();
                                let zeros = size_of::<u32>()
                                    .checked_mul(plen)
                                    .unwrap()
                                    .checked_add(size_of::<u32>())
                                    .unwrap();
                                sparse.extend(iter::repeat(0).take(zeros));

                                // Now write the length prefix.
                                wire::NE::write_u32(
                                    plen.try_into().expect("pattern ID length fits in u32"),
                                    &mut sparse[pos..],
                                );
                                pos += size_of::<u32>();

                                // Now write the pattern IDs.
                                for &pid in dfa.pattern_id_slice(state.id()) {
                                    pos += wire::write_pattern_id::<wire::NE>(
                                        pid,
                                        &mut sparse[pos..],
                                    );
                                }
                            }
                            let accel = dfa.accelerator(state.id());
                            sparse.push(accel.len().try_into().unwrap());
                            sparse.extend_from_slice(accel);
                        }

                        let mut new = DFA {
                            tt: Transitions {
                                sparse,
                                classes: dfa.byte_classes().clone(),
                                state_len: dfa.state_len(),
                                pattern_len: dfa.pattern_len(),
                            },
                            st: StartTable::from_dense_dfa(dfa, &remap)?,
                            special: dfa.special().remap(|id| remap[dfa.to_index(id)]),
                            pre: dfa.get_prefilter().map(|p| p.clone()),
                            quitset: dfa.quitset().clone(),
                            flags: dfa.flags().clone(),
                        };
                        for old_state in dfa.states() {
                            let new_id = remap[dfa.to_index(old_state.id())];
                            let mut new_state = new.tt.state_mut(new_id);
                            let sparse = old_state.sparse_transitions();
                            for (i, (_, _, next)) in sparse.enumerate() {
                                let next = remap[dfa.to_index(next)];
                                new_state.set_next_at(i, next);
                            }
                        }
                        debug!(
                            "created sparse DFA, memory usage: {} (dense memory usage: {})",
                            new.memory_usage(),
                            dfa.memory_usage(),
                        );
                        Ok(new)
                    }
                }

                impl<T: AsRef<[u8]>> DFA<T>
                {
                    /// Cheaply return a borrowed version of this sparse DFA. Specifically, the
                    pub fn as_ref<'a>(&'a self) -> DFA<&'a [u8]> {
                        DFA {
                            tt: self.tt.as_ref(),
                            st: self.st.as_ref(),
                            special: self.special,
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }
                    /// Return an owned version of this sparse DFA. Specifically, the DFA
                        pub fn to_owned(&self) -> DFA<Vec<u8>> {
                        DFA {
                            tt: self.tt.to_owned(),
                            st: self.st.to_owned(),
                            special: self.special,
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }
                    /// Returns the starting state configuration for this DFA.
                    pub fn start_kind(&self) -> StartKind {
                        self.st.kind
                    }
                    /// Returns true only if this DFA has starting states for each pattern.
                    pub fn starts_for_each_pattern(&self) -> bool {
                        self.st.pattern_len.is_some()
                    }
                    /// Returns the equivalence classes that make up the alphabet for this DFA.
                    pub fn byte_classes(&self) -> &ByteClasses {
                        &self.tt.classes
                    }
                    /// Returns the memory usage, in bytes, of this DFA.
                    pub fn memory_usage(&self) -> usize {
                        self.tt.memory_usage() + self.st.memory_usage()
                    }
                }
                /// Routines for converting a sparse DFA to other representations, such as raw
                impl<T: AsRef<[u8]>> DFA<T>
                {
                    /// Serialize this DFA as raw bytes to a `Vec<u8>` in little endian
                        pub fn to_bytes_little_endian(&self) -> Vec<u8> {
                        self.to_bytes::<wire::LE>()
                    }
                    /// Serialize this DFA as raw bytes to a `Vec<u8>` in big endian
                        pub fn to_bytes_big_endian(&self) -> Vec<u8> {
                        self.to_bytes::<wire::BE>()
                    }
                    /// Serialize this DFA as raw bytes to a `Vec<u8>` in native endian
                        pub fn to_bytes_native_endian(&self) -> Vec<u8> {
                        self.to_bytes::<wire::NE>()
                    }
                    /// The implementation of the public `to_bytes` serialization methods,
                        fn to_bytes<E: Endian>(&self) -> Vec<u8> {
                        let mut buf = vec![0; self.write_to_len()];
                        self.write_to::<E>(&mut buf).unwrap();
                        buf
                    }
                    /// Serialize this DFA as raw bytes to the given slice, in little endian
                    pub fn write_to_little_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        self.write_to::<wire::LE>(dst)
                    }
                    /// Serialize this DFA as raw bytes to the given slice, in big endian
                    pub fn write_to_big_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        self.write_to::<wire::BE>(dst)
                    }
                    /// Serialize this DFA as raw bytes to the given slice, in native endian
                    pub fn write_to_native_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        self.write_to::<wire::NE>(dst)
                    }
                    /// The implementation of the public `write_to` serialization methods,
                    fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let mut nw = 0;
                        nw += wire::write_label(LABEL, &mut dst[nw..])?;
                        nw += wire::write_endianness_check::<E>(&mut dst[nw..])?;
                        nw += wire::write_version::<E>(VERSION, &mut dst[nw..])?;
                        nw += {
                            // Currently unused, intended for future flexibility
                            E::write_u32(0, &mut dst[nw..]);
                            size_of::<u32>()
                        };
                        nw += self.flags.write_to::<E>(&mut dst[nw..])?;
                        nw += self.tt.write_to::<E>(&mut dst[nw..])?;
                        nw += self.st.write_to::<E>(&mut dst[nw..])?;
                        nw += self.special.write_to::<E>(&mut dst[nw..])?;
                        nw += self.quitset.write_to::<E>(&mut dst[nw..])?;
                        Ok(nw)
                    }
                    /// Return the total number of bytes required to serialize this DFA.
                    pub fn write_to_len(&self) -> usize {
                        wire::write_label_len(LABEL)
                        + wire::write_endianness_check_len()
                        + wire::write_version_len()
                        + size_of::<u32>() // unused, intended for future flexibility
                        + self.flags.write_to_len()
                        + self.tt.write_to_len()
                        + self.st.write_to_len()
                        + self.special.write_to_len()
                        + self.quitset.write_to_len()
                    }
                }

                impl<'a> DFA<&'a [u8]>
                {
                    /// Safely deserialize a sparse DFA with a specific state identifier
                    pub fn from_bytes(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u8]>, usize), DeserializeError> {
                        let (dfa, nread) = unsafe { DFA::from_bytes_unchecked(slice)? };
                        let seen = dfa.tt.validate(&dfa.special)?;
                        dfa.st.validate(&dfa.special, &seen)?;
                        Ok((dfa, nread))
                    }
                    /// Deserialize a DFA with a specific state identifier representation in
                    pub unsafe fn from_bytes_unchecked(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u8]>, usize), DeserializeError> {
                        let mut nr = 0;

                        nr += wire::read_label(&slice[nr..], LABEL)?;
                        nr += wire::read_endianness_check(&slice[nr..])?;
                        nr += wire::read_version(&slice[nr..], VERSION)?;

                        let _unused = wire::try_read_u32(&slice[nr..], "unused space")?;
                        nr += size_of::<u32>();

                        let (flags, nread) = Flags::from_bytes(&slice[nr..])?;
                        nr += nread;

                        let (tt, nread) = Transitions::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (st, nread) = StartTable::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (special, nread) = Special::from_bytes(&slice[nr..])?;
                        nr += nread;
                        
                        if special.max.as_usize() >= tt.sparse().len() {
                            return Err(DeserializeError::generic(
                                "max should not be greater than or equal to sparse bytes",
                            ));
                        }

                        let (quitset, nread) = ByteSet::from_bytes(&slice[nr..])?;
                        nr += nread;

                        // Prefilters don't support serialization, so they're always absent.
                        let pre = None;
                        Ok((DFA { tt, st, special, pre, quitset, flags }, nr))
                    }
                }
                /// Other routines that work for all `T`.
                impl<T> DFA<T>
                {
                    /// Set or unset the prefilter attached to this DFA.
                    pub fn set_prefilter(&mut self, prefilter: Option<Prefilter>) {
                        self.pre = prefilter
                    }
                }

                impl<T: AsRef<[u8]>> fmt::Debug for DFA<T> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        writeln!(f, "sparse::DFA(")?;
                        for state in self.tt.states() {
                            fmt_state_indicator(f, self, state.id())?;
                            writeln!(f, "{:06?}: {:?}", state.id().as_usize(), state)?;
                        }
                        writeln!(f, "")?;
                        for (i, (start_id, anchored, sty)) in self.st.iter().enumerate()
                        {
                            if i % self.st.stride == 0 {
                                match anchored {
                                    Anchored::No => writeln!(f, "START-GROUP(unanchored)")?,
                                    Anchored::Yes => writeln!(f, "START-GROUP(anchored)")?,
                                    Anchored::Pattern(pid) => writeln!(
                                        f,
                                        "START_GROUP(pattern: {:?})",
                                        pid.as_usize()
                                    )?,
                                }
                            }
                            writeln!(f, "  {:?} => {:06?}", sty, start_id.as_usize())?;
                        }
                        writeln!(f, "state length: {:?}", self.tt.state_len)?;
                        writeln!(f, "pattern length: {:?}", self.pattern_len())?;
                        writeln!(f, "flags: {:?}", self.flags)?;
                        writeln!(f, ")")?;
                        Ok(())
                    }
                }

                // SAFETY: We assert that our implementation of each method is correct.
                unsafe impl<T: AsRef<[u8]>> Automaton for DFA<T> {
                    #[inline]
                    fn is_special_state(&self, id: StateID) -> bool {
                        self.special.is_special_state(id)
                    }

                    #[inline]
                    fn is_dead_state(&self, id: StateID) -> bool {
                        self.special.is_dead_state(id)
                    }

                    #[inline]
                    fn is_quit_state(&self, id: StateID) -> bool {
                        self.special.is_quit_state(id)
                    }

                    #[inline]
                    fn is_match_state(&self, id: StateID) -> bool {
                        self.special.is_match_state(id)
                    }

                    #[inline]
                    fn is_start_state(&self, id: StateID) -> bool {
                        self.special.is_start_state(id)
                    }

                    #[inline]
                    fn is_accel_state(&self, id: StateID) -> bool {
                        self.special.is_accel_state(id)
                    }
                    #[inline( always )]
                    fn next_state(&self, current: StateID, input: u8) -> StateID {
                        let input = self.tt.classes.get(input);
                        self.tt.state(current).next(input)
                    }

                    #[inline]
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        input: u8,
                    ) -> StateID {
                        self.next_state(current, input)
                    }

                    #[inline]
                    fn next_eoi_state(&self, current: StateID) -> StateID {
                        self.tt.state(current).next_eoi()
                    }

                    #[inline]
                    fn pattern_len(&self) -> usize {
                        self.tt.pattern_len
                    }

                    #[inline]
                    fn match_len(&self, id: StateID) -> usize {
                        self.tt.state(id).pattern_len()
                    }

                    #[inline]
                    fn match_pattern(&self, id: StateID, match_index: usize) -> PatternID {
                        if self.tt.pattern_len == 1 {
                            return PatternID::ZERO;
                        }
                        self.tt.state(id).pattern_id(match_index)
                    }

                    #[inline]
                    fn has_empty(&self) -> bool {
                        self.flags.has_empty
                    }

                    #[inline]
                    fn is_utf8(&self) -> bool {
                        self.flags.is_utf8
                    }

                    #[inline]
                    fn is_always_start_anchored(&self) -> bool {
                        self.flags.is_always_start_anchored
                    }

                    #[inline]
                    fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError> {
                        let anchored = config.get_anchored();
                        let start = match config.get_look_behind() {
                            None => Start::Text,
                            Some(byte) => {
                                if !self.quitset.is_empty() && self.quitset.contains(byte) {
                                    return Err(StartError::quit(byte));
                                }
                                self.st.start_map.get(byte)
                            }
                        };
                        self.st.start(anchored, start)
                    }

                    #[inline]
                    fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {
                        match mode {
                            Anchored::No => self.st.universal_start_unanchored,
                            Anchored::Yes => self.st.universal_start_anchored,
                            Anchored::Pattern(_) => None,
                        }
                    }

                    #[inline]
                    fn accelerator(&self, id: StateID) -> &[u8] {
                        self.tt.state(id).accelerator()
                    }

                    #[inline]
                    fn get_prefilter(&self) -> Option<&Prefilter> {
                        self.pre.as_ref()
                    }
                }
                /// The transition table portion of a sparse DFA.
                #[derive(Clone)]
                struct Transitions<T>
                {
                    /// The raw encoding of each state in this DFA.
                    sparse: T,
                    /// A set of equivalence classes, where a single equivalence class
                    classes: ByteClasses,
                    /// The total number of states in this DFA. Note that a DFA always has at
                    state_len: usize,
                    /// The total number of unique patterns represented by these match states.
                    pattern_len: usize,
                }

                impl<'a> Transitions<&'a [u8]> {
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(Transitions<&'a [u8]>, usize), DeserializeError> {
                        let slice_start = slice.as_ptr().as_usize();

                        let (state_len, nr) =
                            wire::try_read_u32_as_usize(&slice, "state length")?;
                        slice = &slice[nr..];

                        let (pattern_len, nr) =
                            wire::try_read_u32_as_usize(&slice, "pattern length")?;
                        slice = &slice[nr..];

                        let (classes, nr) = ByteClasses::from_bytes(&slice)?;
                        slice = &slice[nr..];

                        let (len, nr) =
                            wire::try_read_u32_as_usize(&slice, "sparse transitions length")?;
                        slice = &slice[nr..];

                        wire::check_slice_len(slice, len, "sparse states byte length")?;
                        let sparse = &slice[..len];
                        slice = &slice[len..];

                        let trans = Transitions { sparse, classes, state_len, pattern_len };
                        Ok((trans, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<T: AsRef<[u8]>> Transitions<T>
                {
                    /// Writes a serialized form of this transition table to the buffer given.
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "sparse transition table",
                            ));
                        }
                        dst = &mut dst[..nwrite];

                        // write state length
                        E::write_u32(u32::try_from(self.state_len).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];

                        // write pattern length
                        E::write_u32(u32::try_from(self.pattern_len).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];

                        // write byte class map
                        let n = self.classes.write_to(dst)?;
                        dst = &mut dst[n..];

                        // write number of bytes in sparse transitions
                        E::write_u32(u32::try_from(self.sparse().len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];

                        // write actual transitions
                        let mut id = DEAD;
                        while id.as_usize() < self.sparse().len() {
                            let state = self.state(id);
                            let n = state.write_to::<E>(&mut dst)?;
                            dst = &mut dst[n..];
                            // The next ID is the offset immediately following `state`.
                            id = StateID::new(id.as_usize() + state.write_to_len()).unwrap();
                        }
                        Ok(nwrite)
                    }
                    /// Returns the number of bytes the serialized form of this transition
                    fn write_to_len(&self) -> usize {
                        size_of::<u32>()   // state length
                        + size_of::<u32>() // pattern length
                        + self.classes.write_to_len()
                        + size_of::<u32>() // sparse transitions length
                        + self.sparse().len()
                    }
                    /// Validates that every state ID in this transition table is valid.
                    fn validate(&self, sp: &Special) -> Result<Seen, DeserializeError> {
                        let mut verified = Seen::new();
                        let mut len = 0;
                        let mut id = DEAD;
                        while id.as_usize() < self.sparse().len()
                        {
                            if sp.is_special_state(id) {
                                let is_actually_special = sp.is_dead_state(id)
                                    || sp.is_quit_state(id)
                                    || sp.is_match_state(id)
                                    || sp.is_start_state(id)
                                    || sp.is_accel_state(id);
                                
                                if !is_actually_special {
                                    // This is kind of a cryptic error message...
                                    return Err(DeserializeError::generic(
                                        "found sparse state tagged as special but \
                                        wasn't actually special",
                                    ));
                                }
                            }
                            let state = self.try_state(sp, id)?;
                            verified.insert(id);
                            // The next ID should be the offset immediately following `state`.
                            id = StateID::new(wire::add(
                                id.as_usize(),
                                state.write_to_len(),
                                "next state ID offset",
                            )?)
                            .map_err(|err| {
                                DeserializeError::state_id_error(err, "next state ID offset")
                            })?;
                            len += 1;
                        }
                        for state in self.states() {
                            // Check that all transitions in this state are correct.
                            for i in 0..state.ntrans {
                                let to = state.next_at(i);
                                #[cfg(not(feature = "alloc"))]
                                {
                                    let _ = self.try_state(sp, to)?;
                                }
                                                {
                                    if !verified.contains(&to) {
                                        return Err(DeserializeError::generic(
                                            "found transition that points to a \
                                            non-existent state",
                                        ));
                                    }
                                }
                            }
                        }
                        
                        if len != self.state_len {
                            return Err(DeserializeError::generic(
                                "mismatching sparse state length",
                            ));
                        }
                        Ok(verified)
                    }
                    /// Converts these transitions to a borrowed value.
                    fn as_ref(&self) -> Transitions<&'_ [u8]> {
                        Transitions {
                            sparse: self.sparse(),
                            classes: self.classes.clone(),
                            state_len: self.state_len,
                            pattern_len: self.pattern_len,
                        }
                    }
                    /// Converts these transitions to an owned value.
                        fn to_owned(&self) -> Transitions<Vec<u8>> {
                        Transitions {
                            sparse: self.sparse().to_vec(),
                            classes: self.classes.clone(),
                            state_len: self.state_len,
                            pattern_len: self.pattern_len,
                        }
                    }
                    /// Return a convenient representation of the given state.
                    #[inline( always )]
                    fn state(&self, id: StateID) -> State<'_> {
                        let mut state = &self.sparse()[id.as_usize()..];
                        let mut ntrans = wire::read_u16(&state).as_usize();
                        let is_match = (1 << 15) & ntrans != 0;
                        ntrans &= !(1 << 15);
                        state = &state[2..];

                        let (input_ranges, state) = state.split_at(ntrans * 2);
                        let (next, state) = state.split_at(ntrans * StateID::SIZE);
                        let (pattern_ids, state) = if is_match {
                            let npats = wire::read_u32(&state).as_usize();
                            state[4..].split_at(npats * 4)
                        } else {
                            (&[][..], state)
                        };

                        let accel_len = usize::from(state[0]);
                        let accel = &state[1..accel_len + 1];
                        State { id, is_match, ntrans, input_ranges, next, pattern_ids, accel }
                    }
                    /// Like `state`, but will return an error if the state encoding is
                    fn try_state(
                        &self,
                        sp: &Special,
                        id: StateID,
                    ) -> Result<State<'_>, DeserializeError> {
                        if id.as_usize() > self.sparse().len() {
                            return Err(DeserializeError::generic(
                                "invalid caller provided sparse state ID",
                            ));
                        }
                        let mut state = &self.sparse()[id.as_usize()..];
                        let (mut ntrans, _) =
                            wire::try_read_u16_as_usize(state, "state transition length")?;
                        let is_match = ((1 << 15) & ntrans) != 0;
                        ntrans &= !(1 << 15);
                        state = &state[2..];
                        
                        if ntrans > 257 || ntrans == 0 {
                            return Err(DeserializeError::generic(
                                "invalid transition length",
                            ));
                        }
                        
                        if is_match && !sp.is_match_state(id) {
                            return Err(DeserializeError::generic(
                                "state marked as match but not in match ID range",
                            ));
                        } else if !is_match && sp.is_match_state(id) {
                            return Err(DeserializeError::generic(
                                "state in match ID range but not marked as match state",
                            ));
                        }
                        let input_ranges_len = ntrans.checked_mul(2).unwrap();
                        wire::check_slice_len(state, input_ranges_len, "sparse byte pairs")?;
                        let (input_ranges, state) = state.split_at(input_ranges_len);
                        // Every range should be of the form A-B, where A<=B.
                        for pair in input_ranges.chunks(2) {
                            let (start, end) = (pair[0], pair[1]);
                            if start > end {
                                return Err(DeserializeError::generic("invalid input range"));
                            }
                        }
                        let next_len = ntrans
                            .checked_mul(self.id_len())
                            .expect("state size * #trans should always fit in a usize");
                        wire::check_slice_len(state, next_len, "sparse trans state IDs")?;
                        let (next, state) = state.split_at(next_len);
                        // We can at least verify that every state ID is in bounds.
                        for idbytes in next.chunks(self.id_len()) {
                            let (id, _) =
                                wire::read_state_id(idbytes, "sparse state ID in try_state")?;
                            wire::check_slice_len(
                                self.sparse(),
                                id.as_usize(),
                                "invalid sparse state ID",
                            )?;
                        }
                        let (pattern_ids, state) = if is_match {
                            let (npats, nr) =
                                wire::try_read_u32_as_usize(state, "pattern ID length")?;
                            let state = &state[nr..];
                            if npats == 0 {
                                return Err(DeserializeError::generic(
                                    "state marked as a match, but pattern length is zero",
                                ));
                            }

                            let pattern_ids_len =
                                wire::mul(npats, 4, "sparse pattern ID byte length")?;
                            wire::check_slice_len(
                                state,
                                pattern_ids_len,
                                "sparse pattern IDs",
                            )?;
                            let (pattern_ids, state) = state.split_at(pattern_ids_len);
                            for patbytes in pattern_ids.chunks(PatternID::SIZE) {
                                wire::read_pattern_id(
                                    patbytes,
                                    "sparse pattern ID in try_state",
                                )?;
                            }
                            (pattern_ids, state)
                        } else {
                            (&[][..], state)
                        };
                        
                        if is_match && pattern_ids.is_empty() {
                            return Err(DeserializeError::generic(
                                "state marked as a match, but has no pattern IDs",
                            ));
                        }
                        
                        if sp.is_match_state(id) && pattern_ids.is_empty() {
                            return Err(DeserializeError::generic(
                                "state marked special as a match, but has no pattern IDs",
                            ));
                        }
                        
                        if sp.is_match_state(id) != is_match {
                            return Err(DeserializeError::generic(
                                "whether state is a match or not is inconsistent",
                            ));
                        }
                        
                        if state.is_empty() {
                            return Err(DeserializeError::generic("no accelerator length"));
                        }
                        let (accel_len, state) = (usize::from(state[0]), &state[1..]);

                        if accel_len > 3 {
                            return Err(DeserializeError::generic(
                                "sparse invalid accelerator length",
                            ));
                        } else if accel_len == 0 && sp.is_accel_state(id) {
                            return Err(DeserializeError::generic(
                                "got no accelerators in state, but in accelerator ID range",
                            ));
                        } else if accel_len > 0 && !sp.is_accel_state(id) {
                            return Err(DeserializeError::generic(
                                "state in accelerator ID range, but has no accelerators",
                            ));
                        }

                        wire::check_slice_len(
                            state,
                            accel_len,
                            "sparse corrupt accelerator length",
                        )?;
                        let (accel, _) = (&state[..accel_len], &state[accel_len..]);

                        let state = State {
                            id,
                            is_match,
                            ntrans,
                            input_ranges,
                            next,
                            pattern_ids,
                            accel,
                        };
                        
                        if sp.is_quit_state(state.next_at(state.ntrans - 1)) {
                            return Err(DeserializeError::generic(
                                "state with EOI transition to quit state is illegal",
                            ));
                        }
                        Ok(state)
                    }
                    /// Return an iterator over all of the states in this DFA.
                    fn states(&self) -> StateIter<'_, T> {
                        StateIter { trans: self, id: DEAD.as_usize() }
                    }
                    /// Returns the sparse transitions as raw bytes.
                    fn sparse(&self) -> &[u8] {
                        self.sparse.as_ref()
                    }
                    /// Returns the number of bytes represented by a single state ID.
                    fn id_len(&self) -> usize {
                        StateID::SIZE
                    }
                    /// Return the memory usage, in bytes, of these transitions.
                    fn memory_usage(&self) -> usize {
                        self.sparse().len()
                    }
                }

                impl<T: AsMut<[u8]>> Transitions<T>
                {
                    /// Return a convenient mutable representation of the given state.
                    fn state_mut(&mut self, id: StateID) -> StateMut<'_> {
                        let mut state = &mut self.sparse_mut()[id.as_usize()..];
                        let mut ntrans = wire::read_u16(&state).as_usize();
                        let is_match = (1 << 15) & ntrans != 0;
                        ntrans &= !(1 << 15);
                        state = &mut state[2..];

                        let (input_ranges, state) = state.split_at_mut(ntrans * 2);
                        let (next, state) = state.split_at_mut(ntrans * StateID::SIZE);
                        let (pattern_ids, state) = if is_match {
                            let npats = wire::read_u32(&state).as_usize();
                            state[4..].split_at_mut(npats * 4)
                        } else {
                            (&mut [][..], state)
                        };

                        let accel_len = usize::from(state[0]);
                        let accel = &mut state[1..accel_len + 1];
                        StateMut {
                            id,
                            is_match,
                            ntrans,
                            input_ranges,
                            next,
                            pattern_ids,
                            accel,
                        }
                    }
                    /// Returns the sparse transitions as raw mutable bytes.
                    fn sparse_mut(&mut self) -> &mut [u8] {
                        self.sparse.as_mut()
                    }
                }
                /// The set of all possible starting states in a DFA.
                #[derive(Clone)]
                struct StartTable<T>
                {
                    /// The initial start state IDs as a contiguous table of native endian
                    table: T,
                    /// The starting state configuration supported. When 'both', both
                    kind: StartKind,
                    /// The start state configuration for every possible byte.
                    start_map: StartByteMap,
                    /// The number of starting state IDs per pattern.
                    stride: usize,
                    /// The total number of patterns for which starting states are encoded.
                    pattern_len: Option<usize>,
                    /// The universal starting state for unanchored searches. This is only
                    universal_start_unanchored: Option<StateID>,
                    /// The universal starting state for anchored searches. This is only
                    universal_start_anchored: Option<StateID>,
                }

                impl StartTable<Vec<u8>> {
                    fn new<T: AsRef<[u32]>>(
                        dfa: &dense::DFA<T>,
                        pattern_len: Option<usize>,
                    ) -> StartTable<Vec<u8>> {
                        let stride = Start::len();
                        let len = stride
                            .checked_mul(pattern_len.unwrap_or(0))
                            .unwrap()
                            .checked_add(stride.checked_mul(2).unwrap())
                            .unwrap()
                            .checked_mul(StateID::SIZE)
                            .unwrap();
                        StartTable {
                            table: vec![0; len],
                            kind: dfa.start_kind(),
                            start_map: dfa.start_map().clone(),
                            stride,
                            pattern_len,
                            universal_start_unanchored: dfa
                                .universal_start_state(Anchored::No),
                            universal_start_anchored: dfa.universal_start_state(Anchored::Yes),
                        }
                    }

                    fn from_dense_dfa<T: AsRef<[u32]>>(
                        dfa: &dense::DFA<T>,
                        remap: &[StateID],
                    ) -> Result<StartTable<Vec<u8>>, BuildError> {
                        let start_pattern_len = if dfa.starts_for_each_pattern() {
                            Some(dfa.pattern_len())
                        } else {
                            None
                        };
                        let mut sl = StartTable::new(dfa, start_pattern_len);
                        for (old_start_id, anchored, sty) in dfa.starts() {
                            let new_start_id = remap[dfa.to_index(old_start_id)];
                            sl.set_start(anchored, sty, new_start_id);
                        }
                        Ok(sl)
                    }
                }

                impl<'a> StartTable<&'a [u8]> {
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(StartTable<&'a [u8]>, usize), DeserializeError> {
                        let slice_start = slice.as_ptr().as_usize();

                        let (kind, nr) = StartKind::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (start_map, nr) = StartByteMap::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (stride, nr) =
                            wire::try_read_u32_as_usize(slice, "sparse start table stride")?;
                        slice = &slice[nr..];
                        
                        if stride != Start::len() {
                            return Err(DeserializeError::generic(
                                "invalid sparse starting table stride",
                            ));
                        }

                        let (maybe_pattern_len, nr) =
                            wire::try_read_u32_as_usize(slice, "sparse start table patterns")?;
                        slice = &slice[nr..];
                        let pattern_len = if maybe_pattern_len.as_u32() == u32::MAX {
                            None
                        } else {
                            Some(maybe_pattern_len)
                        };
                        
                        if pattern_len.map_or(false, |len| len > PatternID::LIMIT) {
                            return Err(DeserializeError::generic(
                                "sparse invalid number of patterns",
                            ));
                        }

                        let (universal_unanchored, nr) =
                            wire::try_read_u32(slice, "universal unanchored start")?;
                        slice = &slice[nr..];
                        let universal_start_unanchored = if universal_unanchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_unanchored).map_err(|e| {
                                DeserializeError::state_id_error(
                                    e,
                                    "universal unanchored start",
                                )
                            })?)
                        };

                        let (universal_anchored, nr) =
                            wire::try_read_u32(slice, "universal anchored start")?;
                        slice = &slice[nr..];
                        let universal_start_anchored = if universal_anchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_anchored).map_err(|e| {
                                DeserializeError::state_id_error(e, "universal anchored start")
                            })?)
                        };

                        let pattern_table_size = wire::mul(
                            stride,
                            pattern_len.unwrap_or(0),
                            "sparse invalid pattern length",
                        )?;
                        let start_state_len = wire::add(
                            wire::mul(2, stride, "start state stride too big")?,
                            pattern_table_size,
                            "sparse invalid 'any' pattern starts size",
                        )?;
                        let table_bytes_len = wire::mul(
                            start_state_len,
                            StateID::SIZE,
                            "sparse pattern table bytes length",
                        )?;
                        wire::check_slice_len(
                            slice,
                            table_bytes_len,
                            "sparse start ID table",
                        )?;
                        let table = &slice[..table_bytes_len];
                        slice = &slice[table_bytes_len..];

                        let sl = StartTable {
                            table,
                            kind,
                            start_map,
                            stride,
                            pattern_len,
                            universal_start_unanchored,
                            universal_start_anchored,
                        };
                        Ok((sl, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<T: AsRef<[u8]>> StartTable<T> {
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "sparse starting table ids",
                            ));
                        }
                        dst = &mut dst[..nwrite];

                        // write start kind
                        let nw = self.kind.write_to::<E>(dst)?;
                        dst = &mut dst[nw..];
                        // write start byte map
                        let nw = self.start_map.write_to(dst)?;
                        dst = &mut dst[nw..];
                        // write stride
                        E::write_u32(u32::try_from(self.stride).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        // write pattern length
                        E::write_u32(
                            u32::try_from(self.pattern_len.unwrap_or(0xFFFF_FFFF)).unwrap(),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        // write universal start unanchored state id, u32::MAX if absent
                        E::write_u32(
                            self.universal_start_unanchored
                                .map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        // write universal start anchored state id, u32::MAX if absent
                        E::write_u32(
                            self.universal_start_anchored.map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        // write start IDs
                        for (sid, _, _) in self.iter() {
                            E::write_u32(sid.as_u32(), dst);
                            dst = &mut dst[StateID::SIZE..];
                        }
                        Ok(nwrite)
                    }
                    /// Returns the number of bytes the serialized form of this transition
                    fn write_to_len(&self) -> usize {
                        self.kind.write_to_len()
                        + self.start_map.write_to_len()
                        + size_of::<u32>() // stride
                        + size_of::<u32>() // # patterns
                        + size_of::<u32>() // universal unanchored start
                        + size_of::<u32>() // universal anchored start
                        + self.table().len()
                    }
                    /// Validates that every starting state ID in this table is valid.
                    fn validate(
                        &self,
                        sp: &Special,
                        seen: &Seen,
                    ) -> Result<(), DeserializeError> {
                        for (id, _, _) in self.iter()
                        {
                            if !seen.contains(&id) {
                                return Err(DeserializeError::generic(
                                    "found invalid start state ID",
                                ));
                            }
                            
                            if sp.is_match_state(id) {
                                return Err(DeserializeError::generic(
                                    "start states cannot be match states",
                                ));
                            }
                        }
                        Ok(())
                    }
                    /// Converts this start list to a borrowed value.
                    fn as_ref(&self) -> StartTable<&'_ [u8]> {
                        StartTable {
                            table: self.table(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }
                    /// Converts this start list to an owned value.
                        fn to_owned(&self) -> StartTable<Vec<u8>> {
                        StartTable {
                            table: self.table().to_vec(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }
                    /// Return the start state for the given index and pattern ID. If the
                    fn start(
                        &self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<StateID, StartError> {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => {
                                if !self.kind.has_unanchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                start_index
                            }
                            Anchored::Yes => {
                                if !self.kind.has_anchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                self.stride + start_index
                            }
                            Anchored::Pattern(pid) => {
                                let len = match self.pattern_len {
                                    None => {
                                        return Err(StartError::unsupported_anchored(anchored))
                                    }
                                    Some(len) => len,
                                };
                                
                                if pid.as_usize() >= len {
                                    return Ok(DEAD);
                                }
                                (2 * self.stride)
                                    + (self.stride * pid.as_usize())
                                    + start_index
                            }
                        };
                        let start = index * StateID::SIZE;
                        Ok(wire::read_state_id_unchecked(&self.table()[start..]).0)
                    }
                    /// Return an iterator over all start IDs in this table.
                    fn iter(&self) -> StartStateIter<'_, T> {
                        StartStateIter { st: self, i: 0 }
                    }
                    /// Returns the total number of start state IDs in this table.
                    fn len(&self) -> usize {
                        self.table().len() / StateID::SIZE
                    }
                    /// Returns the table as a raw slice of bytes.
                    fn table(&self) -> &[u8] {
                        self.table.as_ref()
                    }
                    /// Return the memory usage, in bytes, of this start list.
                    fn memory_usage(&self) -> usize {
                        self.table().len()
                    }
                }

                impl<T: AsMut<[u8]>> StartTable<T>
                {
                    /// Set the start state for the given index and pattern.
                    fn set_start(&mut self, anchored: Anchored, start: Start, id: StateID) {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => self.stride + start_index,
                            Anchored::Pattern(pid) => {
                                let pid = pid.as_usize();
                                let len = self
                                    .pattern_len
                                    .expect("start states for each pattern enabled");
                                assert!(pid < len, "invalid pattern ID {pid:?}");
                                self.stride
                                    .checked_mul(pid)
                                    .unwrap()
                                    .checked_add(self.stride.checked_mul(2).unwrap())
                                    .unwrap()
                                    .checked_add(start_index)
                                    .unwrap()
                            }
                        };
                        let start = index * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        wire::write_state_id::<wire::NE>(
                            id,
                            &mut self.table.as_mut()[start..end],
                        );
                    }
                }
                /// An iterator over all state state IDs in a sparse DFA.
                struct StartStateIter<'a, T> {
                    st: &'a StartTable<T>,
                    i: usize,
                }

                impl<'a, T: AsRef<[u8]>> Iterator for StartStateIter<'a, T> {
                    type Item = (StateID, Anchored, Start);

                    fn next(&mut self) -> Option<(StateID, Anchored, Start)> {
                        let i = self.i;
                        
                        if i >= self.st.len() {
                            return None;
                        }
                        self.i += 1;
                        let start_type = Start::from_usize(i % self.st.stride).unwrap();
                        let anchored = if i < self.st.stride {
                            Anchored::No
                        } else if i < (2 * self.st.stride) {
                            Anchored::Yes
                        } else {
                            let pid = (i - (2 * self.st.stride)) / self.st.stride;
                            Anchored::Pattern(PatternID::new(pid).unwrap())
                        };
                        let start = i * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        let bytes = self.st.table()[start..end].try_into().unwrap();
                        let id = StateID::from_ne_bytes_unchecked(bytes);
                        Some((id, anchored, start_type))
                    }
                }

                impl<'a, T> fmt::Debug for StartStateIter<'a, T> {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        f.debug_struct("StartStateIter").field("i", &self.i).finish()
                    }
                }
                /// An iterator over all states in a sparse DFA.
                struct StateIter<'a, T> {
                    trans: &'a Transitions<T>,
                    id: usize,
                }

                impl<'a, T: AsRef<[u8]>> Iterator for StateIter<'a, T> {
                    type Item = State<'a>;

                    fn next(&mut self) -> Option<State<'a>> {
                        if self.id >= self.trans.sparse().len() {
                            return None;
                        }
                        let state = self.trans.state(StateID::new_unchecked(self.id));
                        self.id = self.id + state.write_to_len();
                        Some(state)
                    }
                }

                impl<'a, T> fmt::Debug for StateIter<'a, T> {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        f.debug_struct("StateIter").field("id", &self.id).finish()
                    }
                }
                /// A representation of a sparse DFA state that can be cheaply materialized
                #[derive(Clone)]
                struct State<'a>
                {
                    /// The identifier of this state.
                    id: StateID,
                    /// Whether this is a match state or not.
                    is_match: bool,
                    /// The number of transitions in this state.
                    ntrans: usize,
                    /// Pairs of input ranges, where there is one pair for each transition.
                    input_ranges: &'a [u8],
                    /// Transitions to the next state. This slice contains native endian
                    next: &'a [u8],
                    /// If this is a match state, then this contains the pattern IDs that match
                    pattern_ids: &'a [u8],
                    /// An accelerator for this state, if present. If this state has no
                    accel: &'a [u8],
                }

                impl<'a> State<'a>
                {
                    /// Searches for the next transition given an input byte. If no such
                    #[inline( always )]
                    fn next(&self, input: u8) -> StateID {
                        for i in 0..(self.ntrans - 1) {
                            let (start, end) = self.range(i);
                            if start <= input && input <= end {
                                return self.next_at(i);
                            }
                        }
                        DEAD
                    }
                    /// Returns the next state ID for the special EOI transition.
                    fn next_eoi(&self) -> StateID {
                        self.next_at(self.ntrans - 1)
                    }
                    /// Returns the identifier for this state.
                    fn id(&self) -> StateID {
                        self.id
                    }
                    /// Returns the inclusive input byte range for the ith transition in this
                    fn range(&self, i: usize) -> (u8, u8) {
                        (self.input_ranges[i * 2], self.input_ranges[i * 2 + 1])
                    }
                    /// Returns the next state for the ith transition in this state.
                    fn next_at(&self, i: usize) -> StateID {
                        let start = i * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        let bytes = self.next[start..end].try_into().unwrap();
                        StateID::from_ne_bytes_unchecked(bytes)
                    }
                    /// Returns the pattern ID for the given match index. If the match index
                    fn pattern_id(&self, match_index: usize) -> PatternID {
                        let start = match_index * PatternID::SIZE;
                        wire::read_pattern_id_unchecked(&self.pattern_ids[start..]).0
                    }
                    /// Returns the total number of pattern IDs for this state. This is always
                    fn pattern_len(&self) -> usize {
                        assert_eq!(0, self.pattern_ids.len() % 4);
                        self.pattern_ids.len() / 4
                    }
                    /// Return an accelerator for this state.
                    fn accelerator(&self) -> &'a [u8] {
                        self.accel
                    }
                    /// Write the raw representation of this state to the given buffer using
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "sparse state transitions",
                            ));
                        }

                        let ntrans =
                            if self.is_match { self.ntrans | (1 << 15) } else { self.ntrans };
                        E::write_u16(u16::try_from(ntrans).unwrap(), dst);
                        dst = &mut dst[size_of::<u16>()..];

                        dst[..self.input_ranges.len()].copy_from_slice(self.input_ranges);
                        dst = &mut dst[self.input_ranges.len()..];

                        for i in 0..self.ntrans {
                            E::write_u32(self.next_at(i).as_u32(), dst);
                            dst = &mut dst[StateID::SIZE..];
                        }

                        if self.is_match {
                            E::write_u32(u32::try_from(self.pattern_len()).unwrap(), dst);
                            dst = &mut dst[size_of::<u32>()..];
                            for i in 0..self.pattern_len() {
                                let pid = self.pattern_id(i);
                                E::write_u32(pid.as_u32(), dst);
                                dst = &mut dst[PatternID::SIZE..];
                            }
                        }

                        dst[0] = u8::try_from(self.accel.len()).unwrap();
                        dst[1..][..self.accel.len()].copy_from_slice(self.accel);

                        Ok(nwrite)
                    }
                    /// Return the total number of bytes that this state consumes in its
                    fn write_to_len(&self) -> usize {
                        let mut len = 2
                            + (self.ntrans * 2)
                            + (self.ntrans * StateID::SIZE)
                            + (1 + self.accel.len());
                        
                        if self.is_match {
                            len += size_of::<u32>() + self.pattern_ids.len();
                        }
                        len
                    }
                }

                impl<'a> fmt::Debug for State<'a> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let mut printed = false;
                        for i in 0..(self.ntrans - 1) {
                            let next = self.next_at(i);
                            if next == DEAD {
                                continue;
                            }

                            if printed {
                                write!(f, ", ")?;
                            }
                            let (start, end) = self.range(i);
                            if start == end {
                                write!(f, "{:?} => {:?}", DebugByte(start), next.as_usize())?;
                            } else {
                                write!(
                                    f,
                                    "{:?}-{:?} => {:?}",
                                    DebugByte(start),
                                    DebugByte(end),
                                    next.as_usize(),
                                )?;
                            }
                            printed = true;
                        }
                        let eoi = self.next_at(self.ntrans - 1);
                        
                        if eoi != DEAD {
                            if printed {
                                write!(f, ", ")?;
                            }
                            write!(f, "EOI => {:?}", eoi.as_usize())?;
                        }
                        Ok(())
                    }
                }
                /// A representation of a mutable sparse DFA state that can be cheaply
                struct StateMut<'a>
                {
                    /// The identifier of this state.
                    id: StateID,
                    /// Whether this is a match state or not.
                    is_match: bool,
                    /// The number of transitions in this state.
                    ntrans: usize,
                    /// Pairs of input ranges, where there is one pair for each transition.
                    input_ranges: &'a mut [u8],
                    /// Transitions to the next state. This slice contains native endian
                    next: &'a mut [u8],
                    /// If this is a match state, then this contains the pattern IDs that match
                    pattern_ids: &'a [u8],
                    /// An accelerator for this state, if present. If this state has no
                    accel: &'a mut [u8],
                }

                impl<'a> StateMut<'a>
                {
                    /// Sets the ith transition to the given state.
                    fn set_next_at(&mut self, i: usize, next: StateID) {
                        let start = i * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        wire::write_state_id::<wire::NE>(next, &mut self.next[start..end]);
                    }
                }

                impl<'a> fmt::Debug for StateMut<'a> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let state = State {
                            id: self.id,
                            is_match: self.is_match,
                            ntrans: self.ntrans,
                            input_ranges: self.input_ranges,
                            next: self.next,
                            pattern_ids: self.pattern_ids,
                            accel: self.accel,
                        };
                        fmt::Debug::fmt(&state, f)
                    }
                }
                #[derive(Debug)]
                struct Seen {
                        set: alloc::collections::BTreeSet<StateID>,
                    #[cfg(not(feature = "alloc"))]
                    set: ::marker::PhantomData<StateID>,
                }

                impl Seen {
                    fn new() -> Seen {
                        Seen { set: alloc::collections::BTreeSet::new() }
                    }
                    fn insert(&mut self, id: StateID) {
                        self.set.insert(id);
                    }
                    fn contains(&self, id: &StateID) -> bool {
                        self.set.contains(id)
                    }
                }
                /*
                /// A binary search routine specialized specifically to a sparse DFA state's
                #[inline( always )] fn binary_search_ranges(ranges: &[u8], needle: u8) -> Option<usize> {
                    debug_assert!(ranges.len() % 2 == 0, "ranges must have even length");
                    debug_assert!(ranges.len() <= 512, "ranges should be short");

                    let (mut left, mut right) = (0, ranges.len() / 2);
                    
                    while left < right {
                        let mid = (left + right) / 2;
                        let (b1, b2) = (ranges[mid * 2], ranges[mid * 2 + 1]);
                        
                        if needle < b1 {
                            right = mid;
                        } else if needle > b2 {
                            left = mid + 1;
                        } else {
                            return Some(mid);
                        }
                    }
                    
                    None
                }
                */
            }

            pub mod accel
            {
                /*!
                defines some core types for dealing with accelerated DFA states. */
                use ::
                {
                    regex::automata::
                    {
                        util::
                        {
                            int::Pointer,
                            memchr,
                            wire::{self, DeserializeError, Endian, SerializeError},
                        },
                    },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                /// The base type used to represent a collection of accelerators.
                type AccelTy = u32;
                /// The size of the unit of representation for accelerators.
                const ACCEL_TY_SIZE: usize = ::mem::size_of::<AccelTy>();
                /// The maximum length in bytes that a single Accel can be. This is distinct
                const ACCEL_LEN: usize = 4;
                /// The capacity of each accelerator, in bytes. We set this to 8 since it's a
                const ACCEL_CAP: usize = 8;
                /// Search for between 1 and 3 needle bytes in the given haystack, starting the
                #[inline( always )] pub fn find_fwd(
                    needles: &[u8],
                    haystack: &[u8],
                    at: usize,
                ) -> Option<usize>
                {
                    let bs = needles;
                    let i = match needles.len() {
                        1 => memchr::memchr(bs[0], &haystack[at..])?,
                        2 => memchr::memchr2(bs[0], bs[1], &haystack[at..])?,
                        3 => memchr::memchr3(bs[0], bs[1], bs[2], &haystack[at..])?,
                        0 => panic!("cannot find with empty needles"),
                        n => panic!("invalid needles length: {n}"),
                    };
                    Some(at + i)
                }
                /// Search for between 1 and 3 needle bytes in the given haystack in reverse,
                #[inline( always )] pub fn find_rev(
                    needles: &[u8],
                    haystack: &[u8],
                    at: usize,
                ) -> Option<usize>
                {
                    let bs = needles;
                    match needles.len() {
                        1 => memchr::memrchr(bs[0], &haystack[..at]),
                        2 => memchr::memrchr2(bs[0], bs[1], &haystack[..at]),
                        3 => memchr::memrchr3(bs[0], bs[1], bs[2], &haystack[..at]),
                        0 => panic!("cannot find with empty needles"),
                        n => panic!("invalid needles length: {n}"),
                    }
                }
                /// Represents the accelerators for all accelerated states in a dense DFA.
                #[derive(Clone)]
                pub struct Accels<A>
                {
                    /// A length prefixed slice of contiguous accelerators. See the top comment
                    accels: A,
                }

                impl Accels<Vec<AccelTy>>
                {
                    /// Create an empty sequence of accelerators for a DFA.
                    pub fn empty() -> Accels<Vec<AccelTy>> {
                        Accels { accels: vec![0] }
                    }
                    /// Add an accelerator to this sequence.
                    pub fn add(&mut self, accel: Accel) {
                        self.accels.extend_from_slice(&accel.as_accel_tys());
                        let len = self.len();
                        self.set_len(len + 1);
                    }
                    /// Set the number of accelerators in this sequence, which is encoded in
                    fn set_len(&mut self, new_len: usize) {
                        let new_len = AccelTy::try_from(new_len).unwrap();
                        self.accels[0] = new_len;
                    }
                }

                impl<'a> Accels<&'a [AccelTy]>
                {
                    /// Deserialize a sequence of accelerators from the given bytes. If there
                    pub fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(Accels<&'a [AccelTy]>, usize), DeserializeError> {
                        let slice_start = slice.as_ptr().as_usize();

                        let (accel_len, _) =
                            wire::try_read_u32_as_usize(slice, "accelerators length")?;

                        let accel_tys_len = wire::add(
                            wire::mul(accel_len, 2, "total number of accelerator accel_tys")?,
                            1,
                            "total number of accel_tys",
                        )?;
                        let accel_tys_bytes_len = wire::mul(
                            ACCEL_TY_SIZE,
                            accel_tys_len,
                            "total number of bytes in accelerators",
                        )?;
                        wire::check_slice_len(slice, accel_tys_bytes_len, "accelerators")?;
                        wire::check_alignment::<AccelTy>(slice)?;
                        let accel_tys = &slice[..accel_tys_bytes_len];
                        slice = &slice[accel_tys_bytes_len..];
                        let accels = unsafe {
                            ::slice::from_raw_parts(
                                accel_tys.as_ptr().cast::<AccelTy>(),
                                accel_tys_len,
                            )
                        };
                        Ok((Accels { accels }, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<A: AsRef<[AccelTy]>> Accels<A>
                {
                    /// Return an owned version of the accelerators.
                        pub fn to_owned(&self) -> Accels<Vec<AccelTy>> {
                        Accels { accels: self.accels.as_ref().to_vec() }
                    }
                    /// Return a borrowed version of the accelerators.
                    pub fn as_ref(&self) -> Accels<&[AccelTy]> {
                        Accels { accels: self.accels.as_ref() }
                    }
                    /// Return the bytes representing the serialization of the accelerators.
                    pub fn as_bytes(&self) -> &[u8] {
                        let accels = self.accels.as_ref();
                        unsafe {
                            ::slice::from_raw_parts(
                                accels.as_ptr().cast::<u8>(),
                                accels.len() * ACCEL_TY_SIZE,
                            )
                        }
                    }
                    /// Returns the memory usage, in bytes, of these accelerators.
                    pub fn memory_usage(&self) -> usize {
                        self.as_bytes().len()
                    }
                    /// Return the bytes to search for corresponding to the accelerator in this
                    #[inline( always )]
                    pub fn needles(&self, i: usize) -> &[u8] {
                        if i >= self.len() {
                            panic!("invalid accelerator index {i}");
                        }
                        let bytes = self.as_bytes();
                        let offset = ACCEL_TY_SIZE + i * ACCEL_CAP;
                        let len = usize::from(bytes[offset]);
                        &bytes[offset + 1..offset + 1 + len]
                    }
                    /// Return the total number of accelerators in this sequence.
                    pub fn len(&self) -> usize {
                        usize::try_from(self.accels.as_ref()[0]).unwrap()
                    }
                    /// Return the accelerator in this sequence at index `i`. If no such
                    fn get(&self, i: usize) -> Option<Accel> {
                        if i >= self.len() {
                            return None;
                        }
                        let offset = ACCEL_TY_SIZE + i * ACCEL_CAP;
                        let accel = Accel::from_slice(&self.as_bytes()[offset..])
                            .expect("Accels must contain valid accelerators");
                        Some(accel)
                    }
                    /// Returns an iterator of accelerators in this sequence.
                    fn iter(&self) -> IterAccels<'_, A> {
                        IterAccels { accels: self, i: 0 }
                    }
                    /// Writes these accelerators to the given byte buffer using the indicated
                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        assert_eq!(
                            nwrite % ACCEL_TY_SIZE,
                            0,
                            "expected accelerator bytes written to be a multiple \
                            of {ACCEL_TY_SIZE}",
                        );
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("accelerators"));
                        }

                        // The number of accelerators can never exceed AccelTy::MAX.
                        E::write_u32(AccelTy::try_from(self.len()).unwrap(), dst);
                        dst[ACCEL_TY_SIZE..nwrite]
                            .copy_from_slice(&self.as_bytes()[ACCEL_TY_SIZE..nwrite]);
                        Ok(nwrite)
                    }
                    /// Validates that every accelerator in this collection can be successfully
                    pub fn validate(&self) -> Result<(), DeserializeError> {
                        for chunk in self.as_bytes()[ACCEL_TY_SIZE..].chunks(ACCEL_CAP) {
                            let _ = Accel::from_slice(chunk)?;
                        }
                        Ok(())
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize {
                        self.as_bytes().len()
                    }
                }

                impl<A: AsRef<[AccelTy]>> ::fmt::Debug for Accels<A> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "Accels(")?;
                        let mut list = f.debug_list();
                        for a in self.iter() {
                            list.entry(&a);
                        }
                        list.finish()?;
                        write!(f, ")")
                    }
                }

                #[derive(Debug)]
                struct IterAccels<'a, A: AsRef<[AccelTy]>> {
                    accels: &'a Accels<A>,
                    i: usize,
                }

                impl<'a, A: AsRef<[AccelTy]>> Iterator for IterAccels<'a, A> {
                    type Item = Accel;

                    fn next(&mut self) -> Option<Accel> {
                        let accel = self.accels.get(self.i)?;
                        self.i += 1;
                        Some(accel)
                    }
                }
                /// Accel represents a structure for determining how to "accelerate" a DFA
                #[derive(Clone)]
                pub struct Accel
                {
                    /// The first byte is the length. Subsequent bytes are the accelerated
                    bytes: [u8; ACCEL_CAP],
                }

                impl Accel
                {
                    /// Returns an empty accel, where no bytes are accelerated.
                        pub fn new() -> Accel {
                        Accel { bytes: [0; ACCEL_CAP] }
                    }
                    /// Returns a verified accelerator derived from the beginning of the given
                    pub fn from_slice(mut slice: &[u8]) -> Result<Accel, DeserializeError> {
                        slice = &slice[..::cmp::min(ACCEL_LEN, slice.len())];
                        let bytes = slice
                            .try_into()
                            .map_err(|_| DeserializeError::buffer_too_small("accelerator"))?;
                        Accel::from_bytes(bytes)
                    }
                    /// Returns a verified accelerator derived from raw bytes.
                    fn from_bytes(bytes: [u8; 4]) -> Result<Accel, DeserializeError> {
                        if usize::from(bytes[0]) >= ACCEL_LEN {
                            return Err(DeserializeError::generic(
                                "accelerator bytes cannot have length more than 3",
                            ));
                        }
                        Ok(Accel::from_bytes_unchecked(bytes))
                    }
                    /// Returns an accelerator derived from raw bytes.
                    fn from_bytes_unchecked(bytes: [u8; 4]) -> Accel {
                        Accel { bytes: [bytes[0], bytes[1], bytes[2], bytes[3], 0, 0, 0, 0] }
                    }
                    /// Attempts to add the given byte to this accelerator. If the accelerator
                        pub fn add(&mut self, byte: u8) -> bool {
                        if self.len() >= 3 {
                            return false;
                        }
                        
                        if byte == b' ' {
                            return false;
                        }
                        assert!(
                            !self.contains(byte),
                            "accelerator already contains {:?}",
                            crate::util::escape::DebugByte(byte)
                        );
                        self.bytes[self.len() + 1] = byte;
                        self.bytes[0] += 1;
                        true
                    }
                    /// Return the number of bytes in this accelerator.
                    pub fn len(&self) -> usize {
                        usize::from(self.bytes[0])
                    }
                    /// Returns true if and only if there are no bytes in this accelerator.
                        pub fn is_empty(&self) -> bool {
                        self.len() == 0
                    }
                    /// Returns the slice of bytes to accelerate.
                    fn needles(&self) -> &[u8] {
                        &self.bytes[1..1 + self.len()]
                    }
                    /// Returns true if and only if this accelerator will accelerate the given
                        fn contains(&self, byte: u8) -> bool {
                        self.needles().iter().position(|&b| b == byte).is_some()
                    }
                    /// Returns the accelerator bytes as an array of AccelTys.
                        fn as_accel_tys(&self) -> [AccelTy; 2] {
                        assert_eq!(ACCEL_CAP, 8);
                        // These unwraps are OK since ACCEL_CAP is set to 8.
                        let first =
                            AccelTy::from_ne_bytes(self.bytes[0..4].try_into().unwrap());
                        let second =
                            AccelTy::from_ne_bytes(self.bytes[4..8].try_into().unwrap());
                        [first, second]
                    }
                }

                impl ::fmt::Debug for Accel {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "Accel(")?;
                        let mut set = f.debug_set();
                        for &b in self.needles() {
                            set.entry(&crate::util::escape::DebugByte(b));
                        }
                        set.finish()?;
                        write!(f, ")")
                    }
                }
            }

            pub mod automaton
            {
                use ::
                {
                    regex::automata::
                    {
                        dfa::search,
                        util::
                        {
                            empty,
                            prefilter::Prefilter,
                            primitives::{PatternID, StateID},
                            search::{Anchored, HalfMatch, Input, MatchError,PatternSet},
                            start,
                        },
                    },
                    *,
                };
                /*
                */                
                /// A trait describing the interface of a deterministic finite automaton (DFA).
                pub unsafe trait Automaton
                {
                    /// Transitions from the current state to the next state, given the next
                    fn next_state(&self, current: StateID, input: u8) -> StateID;
                    /// Transitions from the current state to the next state, given the next
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        input: u8,
                    ) -> StateID;
                    /// Transitions from the current state to the next state for the special
                    fn next_eoi_state(&self, current: StateID) -> StateID;
                    /// Return the ID of the start state for this DFA for the given starting
                    fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError>;
                    /// Return the ID of the start state for this DFA when executing a forward
                    fn start_state_forward(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError> {
                        let config = start::Config::from_input_forward(input);
                        self.start_state(&config).map_err(|err| match err {
                            StartError::Quit { byte } => {
                                let offset = input
                                    .start()
                                    .checked_sub(1)
                                    .expect("no quit in start without look-behind");
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => {
                                MatchError::unsupported_anchored(mode)
                            }
                        })
                    }
                    /// Return the ID of the start state for this DFA when executing a reverse
                    fn start_state_reverse(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError> {
                        let config = start::Config::from_input_reverse(input);
                        self.start_state(&config).map_err(|err| match err {
                            StartError::Quit { byte } => {
                                let offset = input.end();
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => {
                                MatchError::unsupported_anchored(mode)
                            }
                        })
                    }
                    /// If this DFA has a universal starting state for the given anchor mode
                    #[inline]
                    fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> {
                        None
                    }
                    /// Returns true if and only if the given identifier corresponds to a
                    fn is_special_state(&self, id: StateID) -> bool;
                    /// Returns true if and only if the given identifier corresponds to a dead
                    fn is_dead_state(&self, id: StateID) -> bool;
                    /// Returns true if and only if the given identifier corresponds to a quit
                    fn is_quit_state(&self, id: StateID) -> bool;
                    /// Returns true if and only if the given identifier corresponds to a
                    fn is_match_state(&self, id: StateID) -> bool;
                    /// Returns true only if the given identifier corresponds to a start
                    fn is_start_state(&self, id: StateID) -> bool;
                    /// Returns true if and only if the given identifier corresponds to an
                    fn is_accel_state(&self, id: StateID) -> bool;
                    /// Returns the total number of patterns compiled into this DFA.
                    fn pattern_len(&self) -> usize;
                    /// Returns the total number of patterns that match in this state.
                    fn match_len(&self, id: StateID) -> usize;
                    /// Returns the pattern ID corresponding to the given match index in the
                    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;
                    /// Returns true if and only if this automaton can match the empty string.
                    fn has_empty(&self) -> bool;
                    /// Whether UTF-8 mode is enabled for this DFA or not.
                    fn is_utf8(&self) -> bool;
                    /// Returns true if and only if this DFA is limited to returning matches
                    fn is_always_start_anchored(&self) -> bool;
                    /// Return a slice of bytes to accelerate for the given state, if possible.
                    #[inline]
                    fn accelerator(&self, _id: StateID) -> &[u8] {
                        &[]
                    }
                    /// Returns the prefilter associated with a DFA, if one exists.
                    #[inline]
                    fn get_prefilter(&self) -> Option<&Prefilter> {
                        None
                    }
                    /// Executes a forward search and returns the end position of the leftmost
                    #[inline]
                    fn try_search_fwd(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        let hm = match search::find_fwd(&self, input)? {
                            None => return Ok(None),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                            let got = search::find_fwd(&self, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    /// Executes a reverse search and returns the start of the position of the
                    #[inline]
                    fn try_search_rev(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        let hm = match search::find_rev(self, input)? {
                            None => return Ok(None),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        empty::skip_splits_rev(input, hm, hm.offset(), |input| {
                            let got = search::find_rev(self, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    /// Executes an overlapping forward search. Matches, if one exists, can be
                    #[inline]
                    fn try_search_overlapping_fwd(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        search::find_overlapping_fwd(self, input, state)?;
                        match state.get_match() {
                            None => Ok(()),
                            Some(_) if !utf8empty => Ok(()),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_fwd(self, input, state)
                                },
                            ),
                        }
                    }
                    /// Executes a reverse overlapping forward search. Matches, if one exists,
                    #[inline]
                    fn try_search_overlapping_rev(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        search::find_overlapping_rev(self, input, state)?;
                        match state.get_match() {
                            None => Ok(()),
                            Some(_) if !utf8empty => Ok(()),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_rev(self, input, state)
                                },
                            ),
                        }
                    }
                    /// Writes the set of patterns that match anywhere in the given search
                        #[inline]
                    fn try_which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), MatchError> {
                        let mut state = OverlappingState::start();
                        while let Some(m) = {
                            self.try_search_overlapping_fwd(input, &mut state)?;
                            state.get_match()
                        } {
                            let _ = patset.insert(m.pattern());
                            if patset.is_full() || input.get_earliest() {
                                break;
                            }
                        }
                        Ok(())
                    }
                }

                unsafe impl<'a, A: Automaton + ?Sized> Automaton for &'a A {
                    #[inline]
                    fn next_state(&self, current: StateID, input: u8) -> StateID {
                        (**self).next_state(current, input)
                    }

                    #[inline]
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        input: u8,
                    ) -> StateID {
                        (**self).next_state_unchecked(current, input)
                    }

                    #[inline]
                    fn next_eoi_state(&self, current: StateID) -> StateID {
                        (**self).next_eoi_state(current)
                    }

                    #[inline]
                    fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError> {
                        (**self).start_state(config)
                    }

                    #[inline]
                    fn start_state_forward(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError> {
                        (**self).start_state_forward(input)
                    }

                    #[inline]
                    fn start_state_reverse(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError> {
                        (**self).start_state_reverse(input)
                    }

                    #[inline]
                    fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {
                        (**self).universal_start_state(mode)
                    }

                    #[inline]
                    fn is_special_state(&self, id: StateID) -> bool {
                        (**self).is_special_state(id)
                    }

                    #[inline]
                    fn is_dead_state(&self, id: StateID) -> bool {
                        (**self).is_dead_state(id)
                    }

                    #[inline]
                    fn is_quit_state(&self, id: StateID) -> bool {
                        (**self).is_quit_state(id)
                    }

                    #[inline]
                    fn is_match_state(&self, id: StateID) -> bool {
                        (**self).is_match_state(id)
                    }

                    #[inline]
                    fn is_start_state(&self, id: StateID) -> bool {
                        (**self).is_start_state(id)
                    }

                    #[inline]
                    fn is_accel_state(&self, id: StateID) -> bool {
                        (**self).is_accel_state(id)
                    }

                    #[inline]
                    fn pattern_len(&self) -> usize {
                        (**self).pattern_len()
                    }

                    #[inline]
                    fn match_len(&self, id: StateID) -> usize {
                        (**self).match_len(id)
                    }

                    #[inline]
                    fn match_pattern(&self, id: StateID, index: usize) -> PatternID {
                        (**self).match_pattern(id, index)
                    }

                    #[inline]
                    fn has_empty(&self) -> bool {
                        (**self).has_empty()
                    }

                    #[inline]
                    fn is_utf8(&self) -> bool {
                        (**self).is_utf8()
                    }

                    #[inline]
                    fn is_always_start_anchored(&self) -> bool {
                        (**self).is_always_start_anchored()
                    }

                    #[inline]
                    fn accelerator(&self, id: StateID) -> &[u8] {
                        (**self).accelerator(id)
                    }

                    #[inline]
                    fn get_prefilter(&self) -> Option<&Prefilter> {
                        (**self).get_prefilter()
                    }

                    #[inline]
                    fn try_search_fwd(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> {
                        (**self).try_search_fwd(input)
                    }

                    #[inline]
                    fn try_search_rev(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> {
                        (**self).try_search_rev(input)
                    }

                    #[inline]
                    fn try_search_overlapping_fwd(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> {
                        (**self).try_search_overlapping_fwd(input, state)
                    }

                    #[inline]
                    fn try_search_overlapping_rev(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> {
                        (**self).try_search_overlapping_rev(input, state)
                    }

                        #[inline]
                    fn try_which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), MatchError> {
                        (**self).try_which_overlapping_matches(input, patset)
                    }
                }
                /// Represents the current state of an overlapping search.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct OverlappingState
                {
                    /// The match reported by the most recent overlapping search to use this
                    pub mat: Option<HalfMatch>,
                    /// The state ID of the state at which the search was in when the call
                    pub id: Option<StateID>,
                    /// The position of the search.
                    pub at: usize,
                    /// The index into the matching patterns of the next match to report if the
                    pub next_match_index: Option<usize>,
                    /// This is set to true when a reverse overlapping search has entered its
                    pub rev_eoi: bool,
                }

                impl OverlappingState
                {
                    /// Create a new overlapping state that begins at the start state of any
                    pub fn start() -> OverlappingState {
                        OverlappingState {
                            mat: None,
                            id: None,
                            at: 0,
                            next_match_index: None,
                            rev_eoi: false,
                        }
                    }
                    /// Return the match result of the most recent search to execute with this
                    pub fn get_match(&self) -> Option<HalfMatch> {
                        self.mat
                    }
                }
                /// An error that can occur when computing the start state for a search.
                #[non_exhaustive]
                #[derive(Clone, Debug)]
                pub enum StartError
                {
                    /// An error that occurs when a starting configuration's look-behind byte
                    Quit {
                        /// The quit byte that was found.
                        byte: u8,
                    },
                    /// An error that occurs when the caller requests an anchored mode that
                    UnsupportedAnchored {
                        /// The anchored mode given that is unsupported.
                        mode: Anchored,
                    },
                }

                impl StartError {
                    pub fn quit(byte: u8) -> StartError {
                        StartError::Quit { byte }
                    }

                    pub fn unsupported_anchored(mode: Anchored) -> StartError {
                        StartError::UnsupportedAnchored { mode }
                    }
                }
                
                impl ::error::Error for StartError {}

                impl ::fmt::Display for StartError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match *self {
                            StartError::Quit { byte } => write!(
                                f,
                                "error computing start state because the look-behind byte \
                                {:?} triggered a quit state",
                                crate::util::escape::DebugByte(byte),
                            ),
                            StartError::UnsupportedAnchored { mode: Anchored::Yes } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored { mode: Anchored::No } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    unanchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored {
                                mode: Anchored::Pattern(pid),
                            } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches for a specific pattern ({}) \
                                    are not supported or enabled",
                                    pid.as_usize(),
                                )
                            }
                        }
                    }
                }
                /// Runs the given overlapping `search` function (forwards or backwards) until
                #[cold]
                #[inline(never)]
                fn skip_empty_utf8_splits_overlapping<F>(
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                    mut search: F,
                ) -> Result<(), MatchError> where
                    F: FnMut(&Input<'_>, &mut OverlappingState) -> Result<(), MatchError>,
                {

                    let mut hm = match state.get_match() {
                        None => return Ok(()),
                        Some(hm) => hm,
                    };
                    if input.get_anchored().is_anchored() {
                        if !input.is_char_boundary(hm.offset()) {
                            state.mat = None;
                        }
                        return Ok(());
                    }
                    while !input.is_char_boundary(hm.offset()) {
                        search(input, state)?;
                        hm = match state.get_match() {
                            None => return Ok(()),
                            Some(hm) => hm,
                        };
                    }
                    Ok(())
                }
                /// Write a prefix "state" indicator for fmt::Debug impls.
                pub fn fmt_state_indicator<A: Automaton>(
                    f: &mut ::fmt::Formatter<'_>,
                    dfa: A,
                    id: StateID,
                ) -> ::fmt::Result {
                    if dfa.is_dead_state(id) {
                        write!(f, "D")?;
                        
                        if dfa.is_start_state(id) {
                            write!(f, ">")?;
                        } else {
                            write!(f, " ")?;
                        }
                    } else if dfa.is_quit_state(id) {
                        write!(f, "Q ")?;
                    } else if dfa.is_start_state(id) {
                        if dfa.is_accel_state(id) {
                            write!(f, "A>")?;
                        } else {
                            write!(f, " >")?;
                        }
                    } else if dfa.is_match_state(id) {
                        if dfa.is_accel_state(id) {
                            write!(f, "A*")?;
                        } else {
                            write!(f, " *")?;
                        }
                    } else if dfa.is_accel_state(id) {
                        write!(f, "A ")?;
                    } else {
                        write!(f, "  ")?;
                    }
                    Ok(())
                }
            }

            pub mod determinize
            {
                use ::
                {
                    collections::{ BTreeMap },
                    regex::automata::
                    {
                        dfa::
                        {
                            dense::{self, BuildError},
                            DEAD,
                        },
                        nfa::thompson,
                        util::
                        {
                            self,
                            alphabet::{self, ByteSet},
                            determinize::{State, StateBuilderEmpty, StateBuilderNFA},
                            primitives::{PatternID, StateID},
                            search::{Anchored, MatchKind},
                            sparse_set::SparseSets,
                            start::Start,
                        },
                    },
                    vec::{ Vec },
                    *,
                };
                /*
                */
                /// A builder for configuring and running a DFA determinizer.
                #[derive(Clone, Debug)]
                pub struct Config {
                    match_kind: MatchKind,
                    quit: ByteSet,
                    dfa_size_limit: Option<usize>,
                    determinize_size_limit: Option<usize>,
                }

                impl Config
                {
                    /// Create a new default config for a determinizer. The determinizer may be
                    pub fn new() -> Config {
                        Config {
                            match_kind: MatchKind::LeftmostFirst,
                            quit: ByteSet::empty(),
                            dfa_size_limit: None,
                            determinize_size_limit: None,
                        }
                    }
                    /// Run determinization on the given NFA and write the resulting DFA into
                    pub fn run(
                        &self,
                        nfa: &thompson::NFA,
                        dfa: &mut dense::OwnedDFA,
                    ) -> Result<(), BuildError> {
                        let dead = State::dead();
                        let quit = State::dead();
                        let mut cache = StateMap::default();
                        cache.insert(dead.clone(), DEAD);

                        let runner = Runner {
                            config: self.clone(),
                            nfa,
                            dfa,
                            builder_states: vec![dead, quit],
                            cache,
                            memory_usage_state: 0,
                            sparses: SparseSets::new(nfa.states().len()),
                            stack: vec![],
                            scratch_state_builder: StateBuilderEmpty::new(),
                        };
                        runner.run()
                    }
                    /// The match semantics to use for determinization.
                    pub fn match_kind(&mut self, kind: MatchKind) -> &mut Config {
                        self.match_kind = kind;
                        self
                    }
                    /// The set of bytes to use that will cause the DFA to enter a quit state,
                    pub fn quit(&mut self, set: ByteSet) -> &mut Config {
                        self.quit = set;
                        self
                    }
                    /// The limit, in bytes of the heap, that the DFA is permitted to use. This
                    pub fn dfa_size_limit(&mut self, bytes: Option<usize>) -> &mut Config {
                        self.dfa_size_limit = bytes;
                        self
                    }
                    /// The limit, in bytes of the heap, that determinization itself is allowed
                    pub fn determinize_size_limit
                    (
                        &mut self,
                        bytes: Option<usize>,
                    ) -> &mut Config {
                        self.determinize_size_limit = bytes;
                        self
                    }
                }
                /// The actual implementation of determinization that converts an NFA to a DFA
                #[derive(Debug)]
                struct Runner<'a>
                {
                    /// The configuration used to initialize determinization.
                    config: Config,
                    /// The NFA we're converting into a DFA.
                    nfa: &'a thompson::NFA,
                    /// The DFA we're building.
                    dfa: &'a mut dense::OwnedDFA,
                    /// Each DFA state being built is defined as an *ordered* set of NFA
                    builder_states: Vec<State>,
                    /// A cache of DFA states that already exist and can be easily looked up
                    cache: StateMap,
                    /// The memory usage, in bytes, used by builder_states and cache. We track
                    memory_usage_state: usize,
                    /// A pair of sparse sets for tracking ordered sets of NFA state IDs.
                    sparses: SparseSets,
                    /// Scratch space for a stack of NFA states to visit, for depth first
                    stack: Vec<StateID>,
                    /// Scratch space for storing an ordered sequence of NFA states, for
                    scratch_state_builder: StateBuilderEmpty,
                }
                /// A map from states to state identifiers. When using std, we use a standard
                type StateMap = ::collections::HashMap<State, StateID>;

                impl<'a> Runner<'a>
                {
                    /// Build the DFA. If there was a problem constructing the DFA (e.g., if
                    fn run(mut self) -> Result<(), BuildError> {
                        if self.nfa.look_set_any().contains_word_unicode()
                            && !self.config.quit.contains_range(0x80, 0xFF)
                        {
                            return Err(BuildError::unsupported_dfa_word_boundary_unicode());
                        }
                        let representatives: Vec<alphabet::Unit> =
                            self.dfa.byte_classes().representatives(..).collect();
                        let mut uncompiled = vec![];
                        self.add_all_starts(&mut uncompiled)?;
                        while let Some(dfa_id) = uncompiled.pop() {
                            for &unit in &representatives {
                                if unit.as_u8().map_or(false, |b| self.config.quit.contains(b))
                                {
                                    continue;
                                }
                                let (next_dfa_id, is_new) = self.cached_state(dfa_id, unit)?;
                                self.dfa.set_transition(dfa_id, unit, next_dfa_id);
                                
                                if is_new {
                                    uncompiled.push(next_dfa_id);
                                }
                            }
                        }
                       /* debug!(
                            "determinization complete, memory usage: {}, \
                            dense DFA size: {}, \
                            is reverse? {}",
                            self.memory_usage(),
                            self.dfa.memory_usage(),
                            self.nfa.is_reverse(),
                        );*/
                        let mut matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::new();
                        self.cache.clear();
                        #[cfg(feature = "logging")]
                        let mut total_pat_len = 0;
                        for (i, state) in self.builder_states.into_iter().enumerate()
                        {
                            if let Some(pat_ids) = state.match_pattern_ids() {
                                let id = self.dfa.to_state_id(i);
                                total_pat_len += pat_ids.len();
                                matches.insert(id, pat_ids);
                            }
                        }
                        
                        use ::mem::size_of;
                        let per_elem = size_of::<StateID>() + size_of::<Vec<PatternID>>();
                        let pats = total_pat_len * size_of::<PatternID>();
                        let mem = (matches.len() * per_elem) + pats;
                        self.dfa.shuffle(matches)?;
                        Ok(())
                    }
                    /// Return the identifier for the next DFA state given an existing DFA
                    fn cached_state
                    (
                        &mut self,
                        dfa_id: StateID,
                        unit: alphabet::Unit,
                    ) -> Result<(StateID, bool), BuildError> {
                        // Compute the set of all reachable NFA states, including epsilons.
                        let empty_builder = self.get_state_builder();
                        let builder = util::determinize::next(
                            self.nfa,
                            self.config.match_kind,
                            &mut self.sparses,
                            &mut self.stack,
                            &self.builder_states[self.dfa.to_index(dfa_id)],
                            unit,
                            empty_builder,
                        );
                        self.maybe_add_state(builder)
                    }
                    /// Compute the set of DFA start states and add their identifiers in
                    fn add_all_starts
                    (
                        &mut self,
                        dfa_state_ids: &mut Vec<StateID>,
                    ) -> Result<(), BuildError> {
                        // These should be the first states added.
                        assert!(dfa_state_ids.is_empty());
                        
                        if self.dfa.start_kind().has_unanchored() {
                            self.add_start_group(Anchored::No, dfa_state_ids)?;
                        }
                        
                        if self.dfa.start_kind().has_anchored() {
                            self.add_start_group(Anchored::Yes, dfa_state_ids)?;
                        }
                        
                        if self.dfa.starts_for_each_pattern() {
                            for pid in self.nfa.patterns() {
                                self.add_start_group(Anchored::Pattern(pid), dfa_state_ids)?;
                            }
                        }
                        Ok(())
                    }
                    /// Add a group of start states for the given match pattern ID. Any new
                    fn add_start_group
                    (
                        &mut self,
                        anchored: Anchored,
                        dfa_state_ids: &mut Vec<StateID>,
                    ) -> Result<(), BuildError> {
                        let nfa_start = match anchored {
                            Anchored::No => self.nfa.start_unanchored(),
                            Anchored::Yes => self.nfa.start_anchored(),
                            Anchored::Pattern(pid) => {
                                self.nfa.start_pattern(pid).expect("valid pattern ID")
                            }
                        };

                        let (id, is_new) =
                            self.add_one_start(nfa_start, Start::NonWordByte)?;
                        self.dfa.set_start_state(anchored, Start::NonWordByte, id);
                        
                        if is_new {
                            dfa_state_ids.push(id);
                        }

                        if !self.nfa.look_set_prefix_any().contains_word() {
                            self.dfa.set_start_state(anchored, Start::WordByte, id);
                        } else {
                            let (id, is_new) =
                                self.add_one_start(nfa_start, Start::WordByte)?;
                            self.dfa.set_start_state(anchored, Start::WordByte, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }
                        }
                        
                        if !self.nfa.look_set_prefix_any().contains_anchor() {
                            self.dfa.set_start_state(anchored, Start::Text, id);
                            self.dfa.set_start_state(anchored, Start::LineLF, id);
                            self.dfa.set_start_state(anchored, Start::LineCR, id);
                            self.dfa.set_start_state(
                                anchored,
                                Start::CustomLineTerminator,
                                id,
                            );
                        } else {
                            let (id, is_new) = self.add_one_start(nfa_start, Start::Text)?;
                            self.dfa.set_start_state(anchored, Start::Text, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }

                            let (id, is_new) = self.add_one_start(nfa_start, Start::LineLF)?;
                            self.dfa.set_start_state(anchored, Start::LineLF, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }

                            let (id, is_new) = self.add_one_start(nfa_start, Start::LineCR)?;
                            self.dfa.set_start_state(anchored, Start::LineCR, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }

                            let (id, is_new) =
                                self.add_one_start(nfa_start, Start::CustomLineTerminator)?;
                            self.dfa.set_start_state(
                                anchored,
                                Start::CustomLineTerminator,
                                id,
                            );
                            if is_new {
                                dfa_state_ids.push(id);
                            }
                        }

                        Ok(())
                    }
                    /// Add a new DFA start state corresponding to the given starting NFA
                    fn add_one_start
                    (
                        &mut self,
                        nfa_start: StateID,
                        start: Start,
                    ) -> Result<(StateID, bool), BuildError> {
                        let mut builder_matches = self.get_state_builder().into_matches();
                        util::determinize::set_lookbehind_from_start(
                            self.nfa,
                            &start,
                            &mut builder_matches,
                        );
                        self.sparses.set1.clear();
                        util::determinize::epsilon_closure(
                            self.nfa,
                            nfa_start,
                            builder_matches.look_have(),
                            &mut self.stack,
                            &mut self.sparses.set1,
                        );
                        let mut builder = builder_matches.into_nfa();
                        util::determinize::add_nfa_states(
                            &self.nfa,
                            &self.sparses.set1,
                            &mut builder,
                        );
                        self.maybe_add_state(builder)
                    }
                    /// Adds the given state to the DFA being built depending on whether it
                    fn maybe_add_state
                    (
                        &mut self,
                        builder: StateBuilderNFA,
                    ) -> Result<(StateID, bool), BuildError> {
                        if let Some(&cached_id) = self.cache.get(builder.as_bytes()) {
                            self.put_state_builder(builder);
                            
                            return Ok((cached_id, false));
                        }
                        self.add_state(builder).map(|sid| (sid, true))
                    }
                    /// Add the given state to the DFA and make it available in the cache.
                    fn add_state
                    (
                        &mut self,
                        builder: StateBuilderNFA,
                    ) -> Result<StateID, BuildError> {
                        let id = self.dfa.add_empty_state()?;
                        
                        if !self.config.quit.is_empty() {
                            for b in self.config.quit.iter() {
                                self.dfa.set_transition(
                                    id,
                                    alphabet::Unit::u8(b),
                                    self.dfa.quit_id(),
                                );
                            }
                        }
                        let state = builder.to_state();
                        self.memory_usage_state += state.memory_usage();
                        self.builder_states.push(state.clone());
                        self.cache.insert(state, id);
                        self.put_state_builder(builder);
                        
                        if let Some(limit) = self.config.dfa_size_limit {
                            if self.dfa.memory_usage() > limit {
                                return Err(BuildError::dfa_exceeded_size_limit(limit));
                            }
                        }
                        
                        if let Some(limit) = self.config.determinize_size_limit {
                            if self.memory_usage() > limit {
                                return Err(BuildError::determinize_exceeded_size_limit(
                                    limit,
                                ));
                            }
                        }
                        Ok(id)
                    }
                    /// Returns a state builder from this determinizer that might have existing
                    fn get_state_builder(&mut self) -> StateBuilderEmpty {
                        ::mem::replace(
                            &mut self.scratch_state_builder,
                            StateBuilderEmpty::new(),
                        )
                    }
                    /// Puts the given state builder back into this determinizer for reuse.
                    fn put_state_builder(&mut self, builder: StateBuilderNFA) {
                        let _ = ::mem::replace(
                            &mut self.scratch_state_builder,
                            builder.clear(),
                        );
                    }
                    /// Return the memory usage, in bytes, of this determinizer at the current
                    fn memory_usage(&self) -> usize {
                        use ::mem::size_of;

                        self.builder_states.len() * size_of::<State>()
                        // Maps likely use more memory than this, but it's probably close.
                        + self.cache.len() * (size_of::<State>() + size_of::<StateID>())
                        + self.memory_usage_state
                        + self.stack.capacity() * size_of::<StateID>()
                        + self.scratch_state_builder.capacity()
                    }
                }
            }

            pub mod minimize
            {
                use ::
                {
                    cell::{ RefCell },
                    collections::{ BTreeMap }, 
                    rc::{ Rc },
                    regex::automata::
                    {
                        dfa::{automaton::Automaton, dense, DEAD},
                        util::
                        {
                            alphabet,
                            primitives::{PatternID, StateID},
                        },
                    },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                /// An implementation of Hopcroft's algorithm for minimizing DFAs.
                pub struct Minimizer<'a>
                {
                    dfa: &'a mut dense::OwnedDFA,
                    in_transitions: Vec<Vec<Vec<StateID>>>,
                    partitions: Vec<StateSet>,
                    waiting: Vec<StateSet>,
                }

                impl<'a> fmt::Debug for Minimizer<'a>
                {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        f.debug_struct("Minimizer")
                            .field("dfa", &self.dfa)
                            .field("in_transitions", &self.in_transitions)
                            .field("partitions", &self.partitions)
                            .field("waiting", &self.waiting)
                            .finish()
                    }
                }
                /// A set of states. A state set makes up a single partition in Hopcroft's
                #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
                struct StateSet
                {
                    ids: Rc<RefCell<Vec<StateID>>>,
                }

                impl<'a> Minimizer<'a>
                {
                    pub fn new(dfa: &'a mut dense::OwnedDFA) -> Minimizer<'a> {
                        let in_transitions = Minimizer::incoming_transitions(dfa);
                        let partitions = Minimizer::initial_partitions(dfa);
                        let waiting = partitions.clone();
                        Minimizer { dfa, in_transitions, partitions, waiting }
                    }

                    pub fn run(mut self) {
                        let stride2 = self.dfa.stride2();
                        let as_state_id = |index: usize| -> StateID {
                            StateID::new(index << stride2).unwrap()
                        };
                        let as_index = |id: StateID| -> usize { id.as_usize() >> stride2 };

                        let mut incoming = StateSet::empty();
                        let mut scratch1 = StateSet::empty();
                        let mut scratch2 = StateSet::empty();
                        let mut newparts = vec![];
                        while let Some(set) = self.waiting.pop() {
                            for b in self.dfa.byte_classes().iter() {
                                self.find_incoming_to(b, &set, &mut incoming);
                                
                                if incoming.is_empty() {
                                    continue;
                                }

                                for p in 0..self.partitions.len() {
                                    self.partitions[p].intersection(&incoming, &mut scratch1);
                                    if scratch1.is_empty() {
                                        newparts.push(self.partitions[p].clone());
                                        continue;
                                    }

                                    self.partitions[p].subtract(&incoming, &mut scratch2);
                                    if scratch2.is_empty() {
                                        newparts.push(self.partitions[p].clone());
                                        continue;
                                    }

                                    let (x, y) =
                                        (scratch1.deep_clone(), scratch2.deep_clone());
                                    newparts.push(x.clone());
                                    newparts.push(y.clone());
                                    match self.find_waiting(&self.partitions[p]) {
                                        Some(i) => {
                                            self.waiting[i] = x;
                                            self.waiting.push(y);
                                        }
                                        None => {
                                            if x.len() <= y.len() {
                                                self.waiting.push(x);
                                            } else {
                                                self.waiting.push(y);
                                            }
                                        }
                                    }
                                }
                                newparts = mem::replace(&mut self.partitions, newparts);
                                newparts.clear();
                            }
                        }
                        let mut state_to_part = vec![DEAD; self.dfa.state_len()];
                        for p in &self.partitions {
                            p.iter(|id| state_to_part[as_index(id)] = p.min());
                        }
                        let mut minimal_ids = vec![DEAD; self.dfa.state_len()];
                        let mut new_index = 0;
                        for state in self.dfa.states()
                        {
                            if state_to_part[as_index(state.id())] == state.id() {
                                minimal_ids[as_index(state.id())] = as_state_id(new_index);
                                new_index += 1;
                            }
                        }
                        // The total number of states in the minimal DFA.
                        let minimal_count = new_index;
                        let remap = |old| minimal_ids[as_index(state_to_part[as_index(old)])];
                        for id in (0..self.dfa.state_len()).map(as_state_id) {
                            if state_to_part[as_index(id)] != id {
                                continue;
                            }
                            self.dfa.remap_state(id, remap);
                            self.dfa.swap_states(id, minimal_ids[as_index(id)]);
                        }
                        self.dfa.truncate_states(minimal_count);
                        let starts: Vec<_> = self.dfa.starts().collect();
                        for (old_start_id, anchored, start_type) in starts {
                            self.dfa.set_start_state(
                                anchored,
                                start_type,
                                remap(old_start_id),
                            );
                        }
                        let mut pmap = BTreeMap::new();
                        for (match_id, pattern_ids) in self.dfa.pattern_map() {
                            let new_id = remap(match_id);
                            pmap.insert(new_id, pattern_ids);
                        }
                        self.dfa.set_pattern_map(&pmap).unwrap();
                        let old = self.dfa.special().clone();
                        let new = self.dfa.special_mut();
                        // ... but only remap if we had match states.
                        if old.matches() {
                            new.min_match = StateID::MAX;
                            new.max_match = StateID::ZERO;
                            for i in as_index(old.min_match)..=as_index(old.max_match) {
                                let new_id = remap(as_state_id(i));
                                
                                if new_id < new.min_match {
                                    new.min_match = new_id;
                                }
                                if new_id > new.max_match {
                                    new.max_match = new_id;
                                }
                            }
                        }
                        // ... same, but for start states.
                        if old.starts() {
                            new.min_start = StateID::MAX;
                            new.max_start = StateID::ZERO;
                            for i in as_index(old.min_start)..=as_index(old.max_start) {
                                let new_id = remap(as_state_id(i));
                                
                                if new_id == DEAD {
                                    continue;
                                }
                                if new_id < new.min_start {
                                    new.min_start = new_id;
                                }
                                if new_id > new.max_start {
                                    new.max_start = new_id;
                                }
                            }
                            
                            if new.max_start == DEAD {
                                new.min_start = DEAD;
                            }
                        }
                        new.quit_id = remap(new.quit_id);
                        new.set_max();
                    }

                    fn find_waiting(&self, set: &StateSet) -> Option<usize> {
                        self.waiting.iter().position(|s| s == set)
                    }

                    fn find_incoming_to(
                        &self,
                        b: alphabet::Unit,
                        set: &StateSet,
                        incoming: &mut StateSet,
                    ) {
                        incoming.clear();
                        set.iter(|id| {
                            for &inid in
                                &self.in_transitions[self.dfa.to_index(id)][b.as_usize()]
                            {
                                incoming.add(inid);
                            }
                        });
                        incoming.canonicalize();
                    }

                    fn initial_partitions(dfa: &dense::OwnedDFA) -> Vec<StateSet> {
                        let mut matching: BTreeMap<Vec<PatternID>, StateSet> = BTreeMap::new();
                        let mut is_quit = StateSet::empty();
                        let mut no_match = StateSet::empty();
                        for state in dfa.states()
                        {
                            if dfa.is_match_state(state.id()) {
                                let mut pids = vec![];
                                for i in 0..dfa.match_len(state.id()) {
                                    pids.push(dfa.match_pattern(state.id(), i));
                                }
                                matching
                                    .entry(pids)
                                    .or_insert(StateSet::empty())
                                    .add(state.id());
                            } else if dfa.is_quit_state(state.id()) {
                                is_quit.add(state.id());
                            } else {
                                no_match.add(state.id());
                            }
                        }

                        let mut sets: Vec<StateSet> =
                            matching.into_iter().map(|(_, set)| set).collect();
                        sets.push(no_match);
                        sets.push(is_quit);
                        sets
                    }

                    fn incoming_transitions(dfa: &dense::OwnedDFA) -> Vec<Vec<Vec<StateID>>> {
                        let mut incoming = vec![];
                        for _ in dfa.states() {
                            incoming.push(vec![vec![]; dfa.alphabet_len()]);
                        }
                        for state in dfa.states() {
                            for (b, next) in state.transitions() {
                                incoming[dfa.to_index(next)][b.as_usize()].push(state.id());
                            }
                        }
                        incoming
                    }
                }

                impl StateSet
                {
                    fn empty() -> StateSet
                    {
                        StateSet { ids: Rc::new(RefCell::new(vec![])) }
                    }

                    fn add(&mut self, id: StateID)
                    {
                        self.ids.borrow_mut().push(id);
                    }

                    fn min(&self) -> StateID
                    {
                        self.ids.borrow()[0]
                    }

                    fn canonicalize(&mut self)
                    {
                        self.ids.borrow_mut().sort();
                        self.ids.borrow_mut().dedup();
                    }

                    fn clear(&mut self)
                    {
                        self.ids.borrow_mut().clear();
                    }

                    fn len(&self) -> usize
                    {
                        self.ids.borrow().len()
                    }

                    fn is_empty(&self) -> bool
                    {
                        self.len() == 0
                    }

                    fn deep_clone(&self) -> StateSet
                    {
                        let ids = self.ids.borrow().iter().cloned().collect();
                        StateSet { ids: Rc::new(RefCell::new(ids)) }
                    }

                    fn iter<F: FnMut(StateID)>(&self, mut f: F)
                    {
                        for &id in self.ids.borrow().iter() {
                            f(id);
                        }
                    }

                    fn intersection(&self, other: &StateSet, dest: &mut StateSet)
                    {
                        dest.clear();
                        
                        if self.is_empty() || other.is_empty() {
                            return;
                        }

                        let (seta, setb) = (self.ids.borrow(), other.ids.borrow());
                        let (mut ita, mut itb) = (seta.iter().cloned(), setb.iter().cloned());
                        let (mut a, mut b) = (ita.next().unwrap(), itb.next().unwrap());

                        loop
                        {
                            if a == b
                            {
                                dest.add(a);
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                                b = match itb.next() {
                                    None => break,
                                    Some(b) => b,
                                };
                            }
                            
                            else if a < b
                            {
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                            }
                            
                            else
                            {
                                b = match itb.next() {
                                    None => break,
                                    Some(b) => b,
                                };
                            }
                        }
                    }

                    fn subtract(&self, other: &StateSet, dest: &mut StateSet) 
                    {
                        dest.clear();
                        
                        if self.is_empty() || other.is_empty() {
                            self.iter(|s| dest.add(s));
                            return;
                        }

                        let (seta, setb) = (self.ids.borrow(), other.ids.borrow());
                        let (mut ita, mut itb) = (seta.iter().cloned(), setb.iter().cloned());
                        let (mut a, mut b) = (ita.next().unwrap(), itb.next().unwrap());

                        loop
                        {
                            if a == b {
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                                b = match itb.next() {
                                    None => {
                                        dest.add(a);
                                        break;
                                    }
                                    Some(b) => b,
                                };
                            } else if a < b {
                                dest.add(a);
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                            } else {
                                b = match itb.next() {
                                    None => {
                                        dest.add(a);
                                        break;
                                    }
                                    Some(b) => b,
                                };
                            }
                        }
                        for a in ita {
                            dest.add(a);
                        }
                    }
                }
            }

            pub mod remapper
            {
                use ::
                {
                    regex::automata::
                    {
                        util::primitives::StateID,
                    },
                    vec::{ Vec },
                    *,
                };
                /*
                */
                /// Remappable is a tightly coupled abstraction that facilitates remapping
                pub(super) trait Remappable: ::fmt::Debug
                {
                    /// Return the total number of states.
                    fn state_len(&self) -> usize;
                    /// Return the power-of-2 exponent that yields the stride. The pertinent
                    fn stride2(&self) -> usize;
                    /// Swap the states pointed to by the given IDs. The underlying finite
                    fn swap_states(&mut self, id1: StateID, id2: StateID);
                    /// This must remap every single state ID in the underlying value according
                    fn remap(&mut self, map: impl Fn(StateID) -> StateID);
                }
                /// Remapper is an abstraction the manages the remapping of state IDs in a
                #[derive(Debug)]
                pub(super) struct Remapper
                {
                    /// A map from the index of a state to its pre-multiplied identifier.
                    map: Vec<StateID>,
                    /// A mapper from state index to state ID (and back).
                    idxmap: IndexMapper,
                }

                impl Remapper
                {
                    /// Create a new remapper from the given remappable implementation. The
                    pub(super) fn new(r: &impl Remappable) -> Remapper {
                        let idxmap = IndexMapper { stride2: r.stride2() };
                        let map = (0..r.state_len()).map(|i| idxmap.to_state_id(i)).collect();
                        Remapper { map, idxmap }
                    }
                    /// Swap two states. Once this is called, callers must follow through to
                    pub(super) fn swap
                    (
                        &mut self,
                        r: &mut impl Remappable,
                        id1: StateID,
                        id2: StateID,
                    ) {
                        if id1 == id2 {
                            return;
                        }
                        r.swap_states(id1, id2);
                        self.map.swap(self.idxmap.to_index(id1), self.idxmap.to_index(id2));
                    }
                    /// Complete the remapping process by rewriting all state IDs in the
                    pub(super) fn remap(mut self, r: &mut impl Remappable) {
                        let oldmap = self.map.clone();
                        for i in 0..r.state_len() {
                            let cur_id = self.idxmap.to_state_id(i);
                            let mut new_id = oldmap[i];
                            if cur_id == new_id {
                                continue;
                            }
                            loop {
                                let id = oldmap[self.idxmap.to_index(new_id)];
                                
                                if cur_id == id {
                                    self.map[i] = new_id;
                                    break;
                                }
                                new_id = id;
                            }
                        }
                        r.remap(|next| self.map[self.idxmap.to_index(next)]);
                    }
                }
                /// A simple type for mapping between state indices and state IDs.
                #[derive(Debug)]
                struct IndexMapper
                {
                    /// The power of 2 corresponding to the stride of the corresponding
                    stride2: usize,
                }

                impl IndexMapper
                {
                    /// Convert a state ID to a state index.
                    fn to_index(&self, id: StateID) -> usize {
                        id.as_usize() >> self.stride2
                    }
                    /// Convert a state index to a state ID.
                    fn to_state_id(&self, index: usize) -> StateID {
                        StateID::new_unchecked(index << self.stride2)
                    }
                }

                mod dense
                {
                    use ::
                    {
                        regex::automata::{ dfa::dense::OwnedDFA, util::primitives::StateID },
                        *,
                    };
                    
                    use super::Remappable;

                    impl Remappable for OwnedDFA {
                        fn state_len(&self) -> usize {
                            OwnedDFA::state_len(self)
                        }

                        fn stride2(&self) -> usize {
                            OwnedDFA::stride2(self)
                        }

                        fn swap_states(&mut self, id1: StateID, id2: StateID) {
                            OwnedDFA::swap_states(self, id1, id2)
                        }

                        fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
                            OwnedDFA::remap(self, map)
                        }
                    }
                }

                mod onepass 
                {

                    use ::regex::automata::{dfa::onepass::DFA, util::primitives::StateID};

                    use super::Remappable;

                    impl Remappable for DFA {
                        fn state_len(&self) -> usize {
                            DFA::state_len(self)
                        }

                        fn stride2(&self) -> usize {
                            0
                        }

                        fn swap_states(&mut self, id1: StateID, id2: StateID) {
                            DFA::swap_states(self, id1, id2)
                        }

                        fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
                            DFA::remap(self, map)
                        }
                    }
                }
            }

            pub mod search
            {
                use ::
                {
                    regex::automata::
                    {
                        dfa::{
                            accel,
                            automaton::{Automaton, OverlappingState},
                        },
                        util::{
                            prefilter::Prefilter,
                            primitives::StateID,
                            search::{Anchored, HalfMatch, Input, Span},
                        },
                        MatchError,
                    },
                    *,
                };
                /*
                */
                #[inline(never)]
                pub fn find_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok(None);
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_prefilter()
                    };
                    if pre.is_some() {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, input, pre, true)
                        } else {
                            find_fwd_imp(dfa, input, pre, false)
                        }
                    } else {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, input, None, true)
                        } else {
                            find_fwd_imp(dfa, input, None, false)
                        }
                    }
                }

                #[inline( always )] fn find_fwd_imp<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    pre: Option<&'_ Prefilter>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.universal_start_state(Anchored::No).is_some();
                    let mut mat = None;
                    let mut sid = init_fwd(dfa, input)?;
                    let mut at = input.start();
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_unchecked($sid, byte)
                        }};
                    }

                    if let Some(ref pre) = pre {
                        let span = Span::from(at..input.end());
                        match pre.find(input.haystack(), span) {
                            None => return Ok(mat),
                            Some(ref span) => {
                                at = span.start;
                                
                                if !universal_start {
                                    sid = prefilter_restart(dfa, &input, at)?;
                                }
                            }
                        }
                    }
                    while at < input.end() {
                        let mut prev_sid;
                        while at < input.end() {
                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid) || at + 3 >= input.end() {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at += 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at += 1;

                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid) {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at += 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at += 1;
                        }
                        
                        if dfa.is_special_state(sid) {
                            if dfa.is_start_state(sid) {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => return Ok(mat),
                                        Some(ref span) => {
                                            if span.start > at {
                                                at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(dfa, &input, at)?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                } else if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_fwd(needles, input.haystack(), at + 1)
                                        .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                
                                if earliest {
                                    return Ok(mat);
                                }
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_fwd(needles, input.haystack(), at + 1)
                                        .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_accel_state(sid) {
                                let needs = dfa.accelerator(sid);
                                at = accel::find_fwd(needs, input.haystack(), at + 1)
                                    .unwrap_or(input.end());
                                continue;
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat);
                            } else {
                                return Err(MatchError::quit(input.haystack()[at], at));
                            }
                        }
                        at += 1;
                    }
                    eoi_fwd(dfa, input, &mut sid, &mut mat)?;
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok(None);
                    }
                    if input.get_earliest() {
                        find_rev_imp(dfa, input, true)
                    } else {
                        find_rev_imp(dfa, input, false)
                    }
                }

                #[inline( always )] fn find_rev_imp<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError>
                {
                    let mut mat = None;
                    let mut sid = init_rev(dfa, input)?;
                    if input.start() == input.end() {
                        eoi_rev(dfa, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }

                    let mut at = input.end() - 1;
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_unchecked($sid, byte)
                        }};
                    }
                    loop {
                        // SAFETY: See comments in 'find_fwd' for a safety argument.
                        let mut prev_sid;
                        while at >= input.start() {
                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid)
                                || at <= input.start().saturating_add(3)
                            {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at -= 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at -= 1;

                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid) {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at -= 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at -= 1;
                        }
                        
                        if dfa.is_special_state(sid) {
                            if dfa.is_start_state(sid) {
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_rev(needles, input.haystack(), at)
                                        .map(|i| i + 1)
                                        .unwrap_or(input.start());
                                }
                            } else if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                                
                                if earliest {
                                    return Ok(mat);
                                }
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_rev(needles, input.haystack(), at)
                                        .map(|i| i + 1)
                                        .unwrap_or(input.start());
                                }
                            } else if dfa.is_accel_state(sid) {
                                let needles = dfa.accelerator(sid);
                                at = accel::find_rev(needles, input.haystack(), at)
                                    .map(|i| i + 1)
                                    .unwrap_or(input.start());
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat);
                            } else {
                                return Err(MatchError::quit(input.haystack()[at], at));
                            }
                        }
                        
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                    }
                    eoi_rev(dfa, input, &mut sid, &mut mat)?;
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_overlapping_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok(());
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_prefilter()
                    };
                    if pre.is_some() {
                        find_overlapping_fwd_imp(dfa, input, pre, state)
                    } else {
                        find_overlapping_fwd_imp(dfa, input, None, state)
                    }
                }

                #[inline( always )] fn find_overlapping_fwd_imp<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    pre: Option<&'_ Prefilter>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.universal_start_state(Anchored::No).is_some();
                    let mut sid = match state.id {
                        None => {
                            state.at = input.start();
                            init_fwd(dfa, input)?
                        }
                        Some(sid) =>
                        {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(sid);
                                
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok(());
                                }
                            }
                            state.at += 1;
                            if state.at > input.end() {
                                return Ok(());
                            }
                            sid
                        }
                    };
                    
                    while state.at < input.end() {
                        sid = dfa.next_state(sid, input.haystack()[state.at]);
                        
                        if dfa.is_special_state(sid) {
                            state.id = Some(sid);
                            if dfa.is_start_state(sid) {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(state.at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => return Ok(()),
                                        Some(ref span) => {
                                            if span.start > state.at {
                                                state.at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(
                                                        dfa, &input, state.at,
                                                    )?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                } else if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    state.at = accel::find_fwd(
                                        needles,
                                        input.haystack(),
                                        state.at + 1,
                                    )
                                    .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_match_state(sid) {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at));
                                return Ok(());
                            } else if dfa.is_accel_state(sid) {
                                let needs = dfa.accelerator(sid);
                                state.at =
                                    accel::find_fwd(needs, input.haystack(), state.at + 1)
                                        .unwrap_or(input.end());
                                continue;
                            } else if dfa.is_dead_state(sid) {
                                return Ok(());
                            } else {
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            }
                        }
                        state.at += 1;
                    }

                    let result = eoi_fwd(dfa, input, &mut sid, &mut state.mat);
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    result
                }

                #[inline(never)]
                pub fn find_overlapping_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok(());
                    }
                    let mut sid = match state.id {
                        None => {
                            let sid = init_rev(dfa, input)?;
                            state.id = Some(sid);
                            if input.start() == input.end() {
                                state.rev_eoi = true;
                            } else {
                                state.at = input.end() - 1;
                            }
                            sid
                        }
                        Some(sid) =>
                        {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(sid);
                                
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok(());
                                }
                            }
                            
                            if state.rev_eoi {
                                return Ok(());
                            } else if state.at == input.start() {
                                state.rev_eoi = true;
                            } else {
                                // We haven't hit the end of the search yet, so move on.
                                state.at -= 1;
                            }
                            sid
                        }
                    };
                    
                    while !state.rev_eoi {
                        sid = dfa.next_state(sid, input.haystack()[state.at]);
                        
                        if dfa.is_special_state(sid) {
                            state.id = Some(sid);
                            if dfa.is_start_state(sid) {
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    state.at =
                                        accel::find_rev(needles, input.haystack(), state.at)
                                            .map(|i| i + 1)
                                            .unwrap_or(input.start());
                                }
                            } else if dfa.is_match_state(sid) {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at + 1));
                                return Ok(());
                            } else if dfa.is_accel_state(sid) {
                                let needles = dfa.accelerator(sid);
                                state.at =
                                    accel::find_rev(needles, input.haystack(), state.at)
                                        .map(|i| i + 1)
                                        .unwrap_or(input.start());
                            } else if dfa.is_dead_state(sid) {
                                return Ok(());
                            } else {
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            }
                        }
                        
                        if state.at == input.start() {
                            break;
                        }
                        state.at -= 1;
                    }

                    let result = eoi_rev(dfa, input, &mut sid, &mut state.mat);
                    state.rev_eoi = true;
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    result
                }

                #[inline( always )] fn init_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<StateID, MatchError>
                {
                    let sid = dfa.start_state_forward(input)?;
                    debug_assert!(!dfa.is_match_state(sid));
                    Ok(sid)
                }

                #[inline( always )] fn init_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<StateID, MatchError>
                {
                    let sid = dfa.start_state_reverse(input)?;
                    debug_assert!(!dfa.is_match_state(sid));
                    Ok(sid)
                }

                #[inline( always )] fn eoi_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    sid: &mut StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid = dfa.next_state(*sid, b);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if dfa.is_quit_state(*sid) {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa.next_eoi_state(*sid);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                        }
                    }
                    Ok(())
                }

                #[inline( always )] fn eoi_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    sid: &mut StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa.next_state(*sid, byte);
                        
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if dfa.is_quit_state(*sid) {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid = dfa.next_eoi_state(*sid);
                        
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                    }
                    Ok(())
                }
                /// Re-compute the starting state that a DFA should be in after finding a
                #[inline( always )] fn prefilter_restart<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    at: usize,
                ) -> Result<StateID, MatchError>
                {
                    let mut input = input.clone();
                    input.set_start(at);
                    init_fwd(dfa, &input)
                }
            }

            pub mod special
            {
                use ::
                {
                    regex::automata::
                    {
                        dfa::DEAD,
                        util::
                        {
                            primitives::StateID,
                            wire::{self, DeserializeError, Endian, SerializeError, write_state_id },
                        }, 
                    },
                    *,
                };
                /*
                */
                macro_rules! err {
                    ($msg:expr) => {
                        return Err(DeserializeError::generic($msg));
                    };
                }
                #[derive(Clone, Copy, Debug)]
                pub struct Special
                {
                    /// The identifier of the last special state in a DFA. A state is special
                    pub max: StateID,
                    /// The identifier of the quit state in a DFA. (There is no analogous field
                    pub quit_id: StateID,
                    /// The identifier of the first match state.
                    pub min_match: StateID,
                    /// The identifier of the last match state.
                    pub max_match: StateID,
                    /// The identifier of the first accelerated state.
                    pub min_accel: StateID,
                    /// The identifier of the last accelerated state.
                    pub max_accel: StateID,
                    /// The identifier of the first start state.
                    pub min_start: StateID,
                    /// The identifier of the last start state.
                    pub max_start: StateID,
                }

                impl Special
                {
                    /// Creates a new set of special ranges for a DFA. All ranges are initially
                        pub fn new() -> Special {
                        Special {
                            max: DEAD,
                            quit_id: DEAD,
                            min_match: DEAD,
                            max_match: DEAD,
                            min_accel: DEAD,
                            max_accel: DEAD,
                            min_start: DEAD,
                            max_start: DEAD,
                        }
                    }
                    /// Remaps all of the special state identifiers using the function given.
                        pub fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {
                        Special {
                            max: map(self.max),
                            quit_id: map(self.quit_id),
                            min_match: map(self.min_match),
                            max_match: map(self.max_match),
                            min_accel: map(self.min_accel),
                            max_accel: map(self.max_accel),
                            min_start: map(self.min_start),
                            max_start: map(self.max_start),
                        }
                    }
                    /// Deserialize the given bytes into special state ranges. If the slice
                    pub fn from_bytes(
                        mut slice: &[u8],
                    ) -> Result<(Special, usize), DeserializeError> {
                        wire::check_slice_len(slice, 8 * StateID::SIZE, "special states")?;

                        let mut nread = 0;
                        let mut read_id = |what| -> Result<StateID, DeserializeError> {
                            let (id, nr) = wire::try_read_state_id(slice, what)?;
                            nread += nr;
                            slice = &slice[StateID::SIZE..];
                            Ok(id)
                        };

                        let max = read_id("special max id")?;
                        let quit_id = read_id("special quit id")?;
                        let min_match = read_id("special min match id")?;
                        let max_match = read_id("special max match id")?;
                        let min_accel = read_id("special min accel id")?;
                        let max_accel = read_id("special max accel id")?;
                        let min_start = read_id("special min start id")?;
                        let max_start = read_id("special max start id")?;

                        let special = Special {
                            max,
                            quit_id,
                            min_match,
                            max_match,
                            min_accel,
                            max_accel,
                            min_start,
                            max_start,
                        };
                        special.validate()?;
                        assert_eq!(nread, special.write_to_len());
                        Ok((special, nread))
                    }
                    /// Validate that the information describing special states satisfies
                    pub fn validate(&self) -> Result<(), DeserializeError> {
                        // Check that both ends of the range are DEAD or neither are.
                        if self.min_match == DEAD && self.max_match != DEAD {
                            err!("min_match is DEAD, but max_match is not");
                        }
                        
                        if self.min_match != DEAD && self.max_match == DEAD {
                            err!("max_match is DEAD, but min_match is not");
                        }
                        
                        if self.min_accel == DEAD && self.max_accel != DEAD {
                            err!("min_accel is DEAD, but max_accel is not");
                        }
                        
                        if self.min_accel != DEAD && self.max_accel == DEAD {
                            err!("max_accel is DEAD, but min_accel is not");
                        }
                        
                        if self.min_start == DEAD && self.max_start != DEAD {
                            err!("min_start is DEAD, but max_start is not");
                        }
                        
                        if self.min_start != DEAD && self.max_start == DEAD {
                            err!("max_start is DEAD, but min_start is not");
                        }

                        // Check that ranges are well formed.
                        if self.min_match > self.max_match {
                            err!("min_match should not be greater than max_match");
                        }
                        
                        if self.min_accel > self.max_accel {
                            err!("min_accel should not be greater than max_accel");
                        }
                        
                        if self.min_start > self.max_start {
                            err!("min_start should not be greater than max_start");
                        }

                        // Check that ranges are ordered with respect to one another.
                        if self.matches() && self.quit_id >= self.min_match {
                            err!("quit_id should not be greater than min_match");
                        }
                        
                        if self.accels() && self.quit_id >= self.min_accel {
                            err!("quit_id should not be greater than min_accel");
                        }
                        
                        if self.starts() && self.quit_id >= self.min_start {
                            err!("quit_id should not be greater than min_start");
                        }
                        
                        if self.matches() && self.accels() && self.min_accel < self.min_match {
                            err!("min_match should not be greater than min_accel");
                        }
                        
                        if self.matches() && self.starts() && self.min_start < self.min_match {
                            err!("min_match should not be greater than min_start");
                        }
                        
                        if self.accels() && self.starts() && self.min_start < self.min_accel {
                            err!("min_accel should not be greater than min_start");
                        }

                        // Check that max is at least as big as everything else.
                        if self.max < self.quit_id {
                            err!("quit_id should not be greater than max");
                        }
                        
                        if self.max < self.max_match {
                            err!("max_match should not be greater than max");
                        }
                        
                        if self.max < self.max_accel {
                            err!("max_accel should not be greater than max");
                        }
                        
                        if self.max < self.max_start {
                            err!("max_start should not be greater than max");
                        }

                        Ok(())
                    }
                    /// Validate that the special state information is compatible with the
                    pub fn validate_state_len(
                        &self,
                        len: usize,
                        stride2: usize,
                    ) -> Result<(), DeserializeError> {
                        if (self.max.as_usize() >> stride2) >= len {
                            err!("max should not be greater than or equal to state length");
                        }
                        Ok(())
                    }
                    /// Write the IDs and ranges for special states to the given byte buffer.
                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        use write_state_id as write;

                        if dst.len() < self.write_to_len() {
                            return Err(SerializeError::buffer_too_small("special state ids"));
                        }

                        let mut nwrite = 0;
                        nwrite += write::<E>(self.max, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.quit_id, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.min_match, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.max_match, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.min_accel, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.max_accel, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.min_start, &mut dst[nwrite..]);
                        nwrite += write::<E>(self.max_start, &mut dst[nwrite..]);

                        assert_eq!(
                            self.write_to_len(),
                            nwrite,
                            "expected to write certain number of bytes",
                        );
                        assert_eq!(
                            nwrite % 8,
                            0,
                            "expected to write multiple of 8 bytes for special states",
                        );
                        Ok(nwrite)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize {
                        8 * StateID::SIZE
                    }
                    /// Sets the maximum special state ID based on the current values. This
                        pub fn set_max(&mut self) {
                        use ::cmp::max;
                        self.max = max(
                            self.quit_id,
                            max(self.max_match, max(self.max_accel, self.max_start)),
                        );
                    }
                    /// Sets the maximum special state ID such that starting states are not
                        pub fn set_no_special_start_states(&mut self) {
                        use ::cmp::max;
                        self.max = max(self.quit_id, max(self.max_match, self.max_accel));
                        self.min_start = DEAD;
                        self.max_start = DEAD;
                    }
                    /// Returns true if and only if the given state ID is a special state.
                    #[inline] pub fn is_special_state(&self, id: StateID) -> bool {
                        id <= self.max
                    }
                    /// Returns true if and only if the given state ID is a dead state.
                    #[inline] pub fn is_dead_state(&self, id: StateID) -> bool {
                        id == DEAD
                    }
                    /// Returns true if and only if the given state ID is a quit state.
                    #[inline] pub fn is_quit_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.quit_id == id
                    }
                    /// Returns true if and only if the given state ID is a match state.
                    #[inline] pub fn is_match_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.min_match <= id && id <= self.max_match
                    }
                    /// Returns true if and only if the given state ID is an accel state.
                    #[inline] pub fn is_accel_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.min_accel <= id && id <= self.max_accel
                    }
                    /// Returns true if and only if the given state ID is a start state.
                    #[inline] pub fn is_start_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.min_start <= id && id <= self.max_start
                    }
                    /// Returns the total number of match states for a dense table based DFA.
                    #[inline] pub fn match_len(&self, stride: usize) -> usize {
                        if self.matches() {
                            (self.max_match.as_usize() - self.min_match.as_usize() + stride)
                                / stride
                        } else {
                            0
                        }
                    }
                    /// Returns true if and only if there is at least one match state.
                    #[inline] pub fn matches(&self) -> bool {
                        self.min_match != DEAD
                    }
                    /// Returns the total number of accel states.
                        pub fn accel_len(&self, stride: usize) -> usize {
                        if self.accels() {
                            (self.max_accel.as_usize() - self.min_accel.as_usize() + stride)
                                / stride
                        } else {
                            0
                        }
                    }
                    /// Returns true if and only if there is at least one accel state.
                    #[inline] pub fn accels(&self) -> bool {
                        self.min_accel != DEAD
                    }
                    /// Returns true if and only if there is at least one start state.
                    #[inline] pub fn starts(&self) -> bool {
                        self.min_start != DEAD
                    }
                }
            }

            pub mod start
            {
                use ::
                {
                    mem::{ size_of },
                    regex::automata::
                    {
                        util::wire::{ self, DeserializeError, Endian, SerializeError },
                    },
                    *,
                };
                /*
                */
                /// The kind of anchored starting configurations to support in a DFA.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum StartKind
                {
                    /// Support both anchored and unanchored searches.
                    Both,
                    /// Support only unanchored searches. Requesting an anchored search will
                    Unanchored,
                    /// Support only anchored searches. Requesting an unanchored search will
                    Anchored,
                }

                impl StartKind {
                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(StartKind, usize), DeserializeError> {
                        wire::check_slice_len(slice, size_of::<u32>(), "start kind bytes")?;
                        let (n, nr) = wire::try_read_u32(slice, "start kind integer")?;
                        match n {
                            0 => Ok((StartKind::Both, nr)),
                            1 => Ok((StartKind::Unanchored, nr)),
                            2 => Ok((StartKind::Anchored, nr)),
                            _ => Err(DeserializeError::generic("unrecognized start kind")),
                        }
                    }

                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("start kind"));
                        }
                        let n = match *self {
                            StartKind::Both => 0,
                            StartKind::Unanchored => 1,
                            StartKind::Anchored => 2,
                        };
                        E::write_u32(n, dst);
                        Ok(nwrite)
                    }

                    pub fn write_to_len(&self) -> usize {
                        size_of::<u32>()
                    }

                    #[inline( always )]
                    pub fn has_unanchored(&self) -> bool {
                        matches!(*self, StartKind::Both | StartKind::Unanchored)
                    }

                    #[inline( always )]
                    pub fn has_anchored(&self) -> bool {
                        matches!(*self, StartKind::Both | StartKind::Anchored)
                    }
                }
            }
        }

        pub mod hybrid
        {
            /*!
            A module for building and searching with lazy deterministic finite automata (DFAs). */
            use ::
            {
                regex::automata::
                {
                    
                },
                *,
            };
            /*
            pub use self::{
                error::{BuildError, CacheError, StartError},
                id::LazyStateID,
            };
            */
            pub mod dfa
            {
                /*!
                Types and routines specific to lazy DFAs. */
                use ::
                {
                    mem::{ size_of },
                    regex::automata::
                    {
                        hybrid::
                        {
                            error::{BuildError, CacheError, StartError},
                            id::{LazyStateID, LazyStateIDError},
                            search,
                        },
                        nfa::thompson,
                        util::
                        {
                            alphabet::{self, ByteClasses, ByteSet},
                            determinize::{self, State, StateBuilderEmpty, StateBuilderNFA},
                            empty,
                            prefilter::Prefilter,
                            primitives::{PatternID, StateID as NFAStateID},
                            search::{ Anchored, HalfMatch, Input, MatchError, MatchKind, PatternSet, },
                            sparse_set::SparseSets,
                            start::{self, Start, StartByteMap},
                        },
                    },
                    vec::{ Vec },
                    *,
                };
                /*
                */
                /// The minimum number of states that a lazy DFA's cache size must support.
                const MIN_STATES: usize = SENTINEL_STATES + 2;
                /// The number of "sentinel" states that get added to every lazy DFA.
                const SENTINEL_STATES: usize = 3;
                /// A hybrid NFA/DFA (also called a "lazy DFA") for regex searching.
                #[derive(Clone, Debug)]
                pub struct DFA {
                    config: Config,
                    nfa: thompson::NFA,
                    stride2: usize,
                    start_map: StartByteMap,
                    classes: ByteClasses,
                    quitset: ByteSet,
                    cache_capacity: usize,
                }

                impl DFA
                {
                    /// Parse the given regular expression using a default configuration and
                    pub fn new(pattern: &str) -> Result<DFA, BuildError> {
                        DFA::builder().build(pattern)
                    }
                    /// Parse the given regular expressions using a default configuration and
                    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<DFA, BuildError> {
                        DFA::builder().build_many(patterns)
                    }
                    /// Create a new lazy DFA that matches every input.
                    pub fn always_match() -> Result<DFA, BuildError> {
                        let nfa = thompson::NFA::always_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    /// Create a new lazy DFA that never matches any input.
                    pub fn never_match() -> Result<DFA, BuildError> {
                        let nfa = thompson::NFA::never_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    /// Return a default configuration for a `DFA`.
                    pub fn config() -> Config {
                        Config::new()
                    }
                    /// Return a builder for configuring the construction of a `Regex`.
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                    /// Create a new cache for this lazy DFA.
                    pub fn create_cache(&self) -> Cache {
                        Cache::new(self)
                    }
                    /// Reset the given cache such that it can be used for searching with the
                    pub fn reset_cache(&self, cache: &mut Cache) {
                        Lazy::new(self, cache).reset_cache()
                    }
                    /// Returns the total number of patterns compiled into this lazy DFA.
                    pub fn pattern_len(&self) -> usize {
                        self.nfa.pattern_len()
                    }
                    /// Returns the equivalence classes that make up the alphabet for this DFA.
                    pub fn byte_classes(&self) -> &ByteClasses {
                        &self.classes
                    }
                    /// Returns this lazy DFA's configuration.
                    pub fn get_config(&self) -> &Config {
                        &self.config
                    }
                    /// Returns a reference to the underlying NFA.
                    pub fn get_nfa(&self) -> &thompson::NFA {
                        &self.nfa
                    }
                    /// Returns the stride, as a base-2 exponent, required for these
                    fn stride2(&self) -> usize {
                        self.stride2
                    }
                    /// Returns the total stride for every state in this lazy DFA. This
                    fn stride(&self) -> usize {
                        1 << self.stride2()
                    }
                    /// Returns the memory usage, in bytes, of this lazy DFA.
                    pub fn memory_usage(&self) -> usize {
                        0
                    }
                }

                impl DFA
                {
                    /// Executes a forward search and returns the end position of the leftmost
                    #[inline] pub fn try_search_fwd(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        let hm = match search::find_fwd(self, cache, input)? {
                            None => return Ok(None),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                            let got = search::find_fwd(self, cache, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    /// Executes a reverse search and returns the start of the position of the
                    #[inline] pub fn try_search_rev(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        let hm = match search::find_rev(self, cache, input)? {
                            None => return Ok(None),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        empty::skip_splits_rev(input, hm, hm.offset(), |input| {
                            let got = search::find_rev(self, cache, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    /// Executes an overlapping forward search and returns the end position of
                    #[inline] pub fn try_search_overlapping_fwd(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        search::find_overlapping_fwd(self, cache, input, state)?;
                        match state.get_match() {
                            None => Ok(()),
                            Some(_) if !utf8empty => Ok(()),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_fwd(self, cache, input, state)
                                },
                            ),
                        }
                    }
                    /// Executes a reverse overlapping search and returns the start of the
                    #[inline] pub fn try_search_overlapping_rev(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        search::find_overlapping_rev(self, cache, input, state)?;
                        match state.get_match() {
                            None => Ok(()),
                            Some(_) if !utf8empty => Ok(()),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_rev(self, cache, input, state)
                                },
                            ),
                        }
                    }
                    /// Writes the set of patterns that match anywhere in the given search
                    #[inline] pub fn try_which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), MatchError> {
                        let mut state = OverlappingState::start();
                        while let Some(m) = {
                            self.try_search_overlapping_fwd(cache, input, &mut state)?;
                            state.get_match()
                        } {
                            let _ = patset.try_insert(m.pattern());
                            if patset.is_full() || input.get_earliest() {
                                break;
                            }
                        }
                        Ok(())
                    }
                }

                impl DFA
                {
                    /// Transitions from the current state to the next state, given the next
                    #[inline] pub fn next_state(
                        &self,
                        cache: &mut Cache,
                        current: LazyStateID,
                        input: u8,
                    ) -> Result<LazyStateID, CacheError> {
                        let class = usize::from(self.classes.get(input));
                        let offset = current.as_usize_untagged() + class;
                        let sid = cache.trans[offset];
                        
                        if !sid.is_unknown() {
                            return Ok(sid);
                        }
                        let unit = alphabet::Unit::u8(input);
                        Lazy::new(self, cache).cache_next_state(current, unit)
                    }
                    /// Transitions from the current state to the next state, given the next
                    #[inline] pub fn next_state_untagged(
                        &self,
                        cache: &Cache,
                        current: LazyStateID,
                        input: u8,
                    ) -> LazyStateID {
                        debug_assert!(!current.is_tagged());
                        let class = usize::from(self.classes.get(input));
                        let offset = current.as_usize_unchecked() + class;
                        cache.trans[offset]
                    }
                    /// Transitions from the current state to the next state, eliding bounds
                    #[inline] pub unsafe fn next_state_untagged_unchecked(
                        &self,
                        cache: &Cache,
                        current: LazyStateID,
                        input: u8,
                    ) -> LazyStateID {
                        debug_assert!(!current.is_tagged());
                        let class = usize::from(self.classes.get(input));
                        let offset = current.as_usize_unchecked() + class;
                        *cache.trans.get_unchecked(offset)
                    }
                    /// Transitions from the current state to the next state for the special
                    #[inline] pub fn next_eoi_state(
                        &self,
                        cache: &mut Cache,
                        current: LazyStateID,
                    ) -> Result<LazyStateID, CacheError> {
                        let eoi = self.classes.eoi().as_usize();
                        let offset = current.as_usize_untagged() + eoi;
                        let sid = cache.trans[offset];
                        
                        if !sid.is_unknown() {
                            return Ok(sid);
                        }
                        let unit = self.classes.eoi();
                        Lazy::new(self, cache).cache_next_state(current, unit)
                    }
                    /// Return the ID of the start state for this lazy DFA for the given
                    #[inline( always )]
                    pub fn start_state(
                        &self,
                        cache: &mut Cache,
                        config: &start::Config,
                    ) -> Result<LazyStateID, StartError> {
                        let lazy = LazyRef::new(self, cache);
                        let anchored = config.get_anchored();
                        let start = match config.get_look_behind() {
                            None => Start::Text,
                            Some(byte) => {
                                if !self.quitset.is_empty() && self.quitset.contains(byte) {
                                    return Err(StartError::quit(byte));
                                }
                                self.start_map.get(byte)
                            }
                        };
                        let start_id = lazy.get_cached_start_id(anchored, start)?;
                        
                        if !start_id.is_unknown() {
                            return Ok(start_id);
                        }
                        Lazy::new(self, cache).cache_start_group(anchored, start)
                    }
                    /// Return the ID of the start state for this lazy DFA when executing a
                    #[inline( always )]
                    pub fn start_state_forward(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<LazyStateID, MatchError> {
                        let config = start::Config::from_input_forward(input);
                        self.start_state(cache, &config).map_err(|err| match err {
                            StartError::Cache { .. } => MatchError::gave_up(input.start()),
                            StartError::Quit { byte } => {
                                let offset = input
                                    .start()
                                    .checked_sub(1)
                                    .expect("no quit in start without look-behind");
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => {
                                MatchError::unsupported_anchored(mode)
                            }
                        })
                    }
                    /// Return the ID of the start state for this lazy DFA when executing a
                    #[inline( always )]
                    pub fn start_state_reverse(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<LazyStateID, MatchError> {
                        let config = start::Config::from_input_reverse(input);
                        self.start_state(cache, &config).map_err(|err| match err {
                            StartError::Cache { .. } => MatchError::gave_up(input.end()),
                            StartError::Quit { byte } => {
                                let offset = input.end();
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => {
                                MatchError::unsupported_anchored(mode)
                            }
                        })
                    }
                    /// Returns the total number of patterns that match in this state.
                    #[inline] pub fn match_len(&self, cache: &Cache, id: LazyStateID) -> usize {
                        assert!(id.is_match());
                        LazyRef::new(self, cache).get_cached_state(id).match_len()
                    }
                    /// Returns the pattern ID corresponding to the given match index in the
                    #[inline] pub fn match_pattern(
                        &self,
                        cache: &Cache,
                        id: LazyStateID,
                        match_index: usize,
                    ) -> PatternID {
                        if self.pattern_len() == 1 {
                            return PatternID::ZERO;
                        }
                        LazyRef::new(self, cache)
                            .get_cached_state(id)
                            .match_pattern(match_index)
                    }
                }
                /// A cache represents a partially computed DFA.
                #[derive(Clone, Debug)]
                pub struct Cache {
                    trans: Vec<LazyStateID>,
                    /// The starting states for this DFA.
                    starts: Vec<LazyStateID>,
                    /// A sequence of NFA/DFA powerset states that have been computed for this
                    states: Vec<State>,
                    /// A map from states to their corresponding IDs. This map may be accessed
                    states_to_id: StateMap,
                    /// Sparse sets used to track which NFA states have been visited during
                    sparses: SparseSets,
                    /// Scratch space for traversing the NFA graph. (We use space on the heap
                    stack: Vec<NFAStateID>,
                    /// Scratch space for building a NFA/DFA powerset state. This is used to
                    scratch_state_builder: StateBuilderEmpty,
                    /// A simple abstraction for handling the saving of at most a single state
                    state_saver: StateSaver,
                    /// The memory usage, in bytes, used by 'states' and 'states_to_id'. We
                    memory_usage_state: usize,
                    /// The number of times the cache has been cleared. When a minimum cache
                    clear_count: usize,
                    /// The total number of bytes searched since the last time this cache was
                    bytes_searched: usize,
                    /// The progress of the current search.
                    progress: Option<SearchProgress>,
                }

                impl Cache
                {
                    /// Create a new cache for the given lazy DFA.
                    pub fn new(dfa: &DFA) -> Cache {
                        let mut cache = Cache {
                            trans: vec![],
                            starts: vec![],
                            states: vec![],
                            states_to_id: StateMap::new(),
                            sparses: SparseSets::new(dfa.get_nfa().states().len()),
                            stack: vec![],
                            scratch_state_builder: StateBuilderEmpty::new(),
                            state_saver: StateSaver::none(),
                            memory_usage_state: 0,
                            clear_count: 0,
                            bytes_searched: 0,
                            progress: None,
                        };
                        debug!("pre-init lazy DFA cache size: {}", cache.memory_usage());
                        Lazy { dfa, cache: &mut cache }.init_cache();
                        debug!("post-init lazy DFA cache size: {}", cache.memory_usage());
                        cache
                    }
                    /// Reset this cache such that it can be used for searching with the given
                    pub fn reset(&mut self, dfa: &DFA) {
                        Lazy::new(dfa, self).reset_cache()
                    }
                    /// Initializes a new search starting at the given position.
                    #[inline] pub fn search_start(&mut self, at: usize) {
                        if let Some(p) = self.progress.take() {
                            self.bytes_searched += p.len();
                        }
                        self.progress = Some(SearchProgress { start: at, at });
                    }
                    /// Updates the current search to indicate that it has search to the
                    #[inline] pub fn search_update(&mut self, at: usize) {
                        let p =
                            self.progress.as_mut().expect("no in-progress search to update");
                        p.at = at;
                    }
                    /// Indicates that a search has finished at the given position.
                    #[inline] pub fn search_finish(&mut self, at: usize) {
                        let mut p =
                            self.progress.take().expect("no in-progress search to finish");
                        p.at = at;
                        self.bytes_searched += p.len();
                    }
                    /// Returns the total number of bytes that have been searched since this
                    pub fn search_total_len(&self) -> usize {
                        self.bytes_searched + self.progress.as_ref().map_or(0, |p| p.len())
                    }
                    /// Returns the total number of times this cache has been cleared since it
                    pub fn clear_count(&self) -> usize {
                        self.clear_count
                    }
                    /// Returns the heap memory usage, in bytes, of this cache.
                    pub fn memory_usage(&self) -> usize {
                        const ID_SIZE: usize = size_of::<LazyStateID>();
                        const STATE_SIZE: usize = size_of::<State>();

                        self.trans.len() * ID_SIZE
                        + self.starts.len() * ID_SIZE
                        + self.states.len() * STATE_SIZE
                        // Maps likely use more memory than this, but it's probably close.
                        + self.states_to_id.len() * (STATE_SIZE + ID_SIZE)
                        + self.sparses.memory_usage()
                        + self.stack.capacity() * ID_SIZE
                        + self.scratch_state_builder.capacity()
                        // Heap memory used by 'State' in both 'states' and 'states_to_id'.
                        + self.memory_usage_state
                    }
                }
                /// Keeps track of the progress of the current search.
                #[derive(Clone, Debug)]
                struct SearchProgress {
                    start: usize,
                    at: usize,
                }

                impl SearchProgress
                {
                    /// Returns the length, in bytes, of this search so far.
                    fn len(&self) -> usize {
                        if self.start <= self.at {
                            self.at - self.start
                        } else {
                            self.start - self.at
                        }
                    }
                }
                /// A map from states to state identifiers. When using std, we use a standard
                type StateMap = ::collections::HashMap<State, LazyStateID>;
                /// A type that groups methods that require the base NFA/DFA and writable
                #[derive(Debug)]
                struct Lazy<'i, 'c> {
                    dfa: &'i DFA,
                    cache: &'c mut Cache,
                }

                impl<'i, 'c> Lazy<'i, 'c>
                {
                    /// Creates a new 'Lazy' wrapper for a DFA and its corresponding cache.
                    fn new(dfa: &'i DFA, cache: &'c mut Cache) -> Lazy<'i, 'c> {
                        Lazy { dfa, cache }
                    }
                    /// Return an immutable view by downgrading a writable cache to a read-only
                    fn as_ref<'a>(&'a self) -> LazyRef<'i, 'a> {
                        LazyRef::new(self.dfa, self.cache)
                    }
                    /// This is marked as 'inline(never)' to avoid bloating methods on 'DFA'
                    #[cold]
                    #[inline(never)]
                    fn cache_next_state
                    (
                        &mut self,
                        mut current: LazyStateID,
                        unit: alphabet::Unit,
                    ) -> Result<LazyStateID, CacheError> {
                        let stride2 = self.dfa.stride2();
                        let empty_builder = self.get_state_builder();
                        let builder = determinize::next(
                            self.dfa.get_nfa(),
                            self.dfa.get_config().get_match_kind(),
                            &mut self.cache.sparses,
                            &mut self.cache.stack,
                            &self.cache.states[current.as_usize_untagged() >> stride2],
                            unit,
                            empty_builder,
                        );
                        let save_state = !self.as_ref().state_builder_fits_in_cache(&builder);
                        
                        if save_state {
                            self.save_state(current);
                        }
                        let next = self.add_builder_state(builder, |sid| sid)?;
                        
                        if save_state {
                            current = self.saved_state_id();
                        }
                        self.set_transition(current, unit, next);
                        Ok(next)
                    }
                    /// Compute and cache the starting state for the given pattern ID (if
                    #[cold]
                    #[inline(never)]
                    fn cache_start_group
                    (
                        &mut self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<LazyStateID, StartError> {
                        let nfa_start_id = match anchored {
                            Anchored::No => self.dfa.get_nfa().start_unanchored(),
                            Anchored::Yes => self.dfa.get_nfa().start_anchored(),
                            Anchored::Pattern(pid) => {
                                if !self.dfa.get_config().get_starts_for_each_pattern() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                match self.dfa.get_nfa().start_pattern(pid) {
                                    None => return Ok(self.as_ref().dead_id()),
                                    Some(sid) => sid,
                                }
                            }
                        };

                        let id = self
                            .cache_start_one(nfa_start_id, start)
                            .map_err(StartError::cache)?;
                        self.set_start_state(anchored, start, id);
                        Ok(id)
                    }
                    /// Compute and cache the starting state for the given NFA state ID and the
                    fn cache_start_one
                    (
                        &mut self,
                        nfa_start_id: NFAStateID,
                        start: Start,
                    ) -> Result<LazyStateID, CacheError> {
                        let mut builder_matches = self.get_state_builder().into_matches();
                        determinize::set_lookbehind_from_start(
                            self.dfa.get_nfa(),
                            &start,
                            &mut builder_matches,
                        );
                        self.cache.sparses.set1.clear();
                        determinize::epsilon_closure(
                            self.dfa.get_nfa(),
                            nfa_start_id,
                            builder_matches.look_have(),
                            &mut self.cache.stack,
                            &mut self.cache.sparses.set1,
                        );
                        let mut builder = builder_matches.into_nfa();
                        determinize::add_nfa_states(
                            &self.dfa.get_nfa(),
                            &self.cache.sparses.set1,
                            &mut builder,
                        );
                        let tag_starts = self.dfa.get_config().get_specialize_start_states();
                        self.add_builder_state(builder, |id| {
                            if tag_starts {
                                id.to_start()
                            } else {
                                id
                            }
                        })
                    }
                    /// Either add the given builder state to this cache, or return an ID to an
                    fn add_builder_state
                    (
                        &mut self,
                        builder: StateBuilderNFA,
                        idmap: impl Fn(LazyStateID) -> LazyStateID,
                    ) -> Result<LazyStateID, CacheError> {
                        if let Some(&cached_id) =
                            self.cache.states_to_id.get(builder.as_bytes())
                        {
                            self.put_state_builder(builder);
                            
                            return Ok(cached_id);
                        }
                        let result = self.add_state(builder.to_state(), idmap);
                        self.put_state_builder(builder);
                        result
                    }
                    /// Allocate a new state ID and add the given state to this cache.
                    fn add_state
                    (
                        &mut self,
                        state: State,
                        idmap: impl Fn(LazyStateID) -> LazyStateID,
                    ) -> Result<LazyStateID, CacheError> {
                        if !self.as_ref().state_fits_in_cache(&state) {
                            self.try_clear_cache()?;
                        }
                        let mut id = idmap(self.next_state_id()?);
                        
                        if state.is_match() {
                            id = id.to_match();
                        }
                        self.cache.trans.extend(
                            iter::repeat(self.as_ref().unknown_id()).take(self.dfa.stride()),
                        );
                        
                        if !self.dfa.quitset.is_empty() && !self.as_ref().is_sentinel(id) {
                            let quit_id = self.as_ref().quit_id();
                            for b in self.dfa.quitset.iter() {
                                self.set_transition(id, alphabet::Unit::u8(b), quit_id);
                            }
                        }
                        self.cache.memory_usage_state += state.memory_usage();
                        self.cache.states.push(state.clone());
                        self.cache.states_to_id.insert(state, id);
                        Ok(id)
                    }
                    /// Allocate a new state ID.
                    fn next_state_id(&mut self) -> Result<LazyStateID, CacheError> {
                        let sid = match LazyStateID::new(self.cache.trans.len()) {
                            Ok(sid) => sid,
                            Err(_) => {
                                self.try_clear_cache()?;
                                LazyStateID::new(self.cache.trans.len()).unwrap()
                            }
                        };
                        Ok(sid)
                    }
                    /// Attempt to clear the cache used by this lazy DFA.
                    fn try_clear_cache(&mut self) -> Result<(), CacheError> {
                        let c = self.dfa.get_config();
                        
                        if let Some(min_count) = c.get_minimum_cache_clear_count()
                        {
                            if self.cache.clear_count >= min_count {
                                if let Some(min_bytes_per) = c.get_minimum_bytes_per_state() {
                                    let len = self.cache.search_total_len();
                                    let min_bytes =
                                        min_bytes_per.saturating_mul(self.cache.states.len());
                                    if len == 0 {
                                        trace!(
                                            "number of bytes searched is 0, but \
                                            a minimum bytes per state searched ({}) is \
                                            enabled, maybe Cache::search_update \
                                            is not being used?",
                                            min_bytes_per,
                                        );
                                    }
                                    if len < min_bytes {
                                        trace!(
                                            "lazy DFA cache has been cleared {} times, \
                                            which exceeds the limit of {}, \
                                            AND its bytes searched per state is less \
                                            than the configured minimum of {}, \
                                            therefore lazy DFA is giving up \
                                            (bytes searched since cache clear = {}, \
                                            number of states = {})",
                                            self.cache.clear_count,
                                            min_count,
                                            min_bytes_per,
                                            len,
                                            self.cache.states.len(),
                                        );
                                        return Err(CacheError::bad_efficiency());
                                    } else {
                                        trace!(
                                            "lazy DFA cache has been cleared {} times, \
                                            which exceeds the limit of {}, \
                                            AND its bytes searched per state is greater \
                                            than the configured minimum of {}, \
                                            therefore lazy DFA is continuing! \
                                            (bytes searched since cache clear = {}, \
                                            number of states = {})",
                                            self.cache.clear_count,
                                            min_count,
                                            min_bytes_per,
                                            len,
                                            self.cache.states.len(),
                                        );
                                    }
                                } else {
                                    trace!(
                                        "lazy DFA cache has been cleared {} times, \
                                        which exceeds the limit of {}, \
                                        since there is no configured bytes per state \
                                        minimum, lazy DFA is giving up",
                                        self.cache.clear_count,
                                        min_count,
                                    );
                                    return Err(CacheError::too_many_cache_clears());
                                }
                            }
                        }
                        self.clear_cache();
                        Ok(())
                    }
                    /// Clears _and_ resets the cache. Resetting the cache means that no
                    fn reset_cache(&mut self) {
                        self.cache.state_saver = StateSaver::none();
                        self.clear_cache();
                        self.cache.sparses.resize(self.dfa.get_nfa().states().len());
                        self.cache.clear_count = 0;
                        self.cache.progress = None;
                    }
                    /// Clear the cache used by this lazy DFA.
                    fn clear_cache(&mut self) {
                        self.cache.trans.clear();
                        self.cache.starts.clear();
                        self.cache.states.clear();
                        self.cache.states_to_id.clear();
                        self.cache.memory_usage_state = 0;
                        self.cache.clear_count += 1;
                        self.cache.bytes_searched = 0;
                        
                        if let Some(ref mut progress) = self.cache.progress {
                            progress.start = progress.at;
                        }
                        trace!(
                            "lazy DFA cache has been cleared (count: {})",
                            self.cache.clear_count
                        );
                        self.init_cache();
                        
                        if let Some((old_id, state)) = self.cache.state_saver.take_to_save() {
                            assert!(
                                !self.as_ref().is_sentinel(old_id),
                                "cannot save sentinel state"
                            );
                            let new_id = self
                                .add_state(state, |id| {
                                    if old_id.is_start() {
                                        id.to_start()
                                    } else {
                                        id
                                    }
                                })
                                .expect("adding one state after cache clear must work");
                            self.cache.state_saver = StateSaver::Saved(new_id);
                        }
                    }
                    /// Initialize this cache from emptiness to a place where it can be used
                    fn init_cache(&mut self) {
                        let mut starts_len = Start::len().checked_mul(2).unwrap();
                        
                        if self.dfa.get_config().get_starts_for_each_pattern() {
                            starts_len += Start::len() * self.dfa.pattern_len();
                        }
                        self.cache
                            .starts
                            .extend(iter::repeat(self.as_ref().unknown_id()).take(starts_len));
                        let dead = State::dead();
                        let unk_id =
                            self.add_state(dead.clone(), |id| id.to_unknown()).unwrap();
                        let dead_id = self.add_state(dead.clone(), |id| id.to_dead()).unwrap();
                        let quit_id = self.add_state(dead.clone(), |id| id.to_quit()).unwrap();
                        assert_eq!(unk_id, self.as_ref().unknown_id());
                        assert_eq!(dead_id, self.as_ref().dead_id());
                        assert_eq!(quit_id, self.as_ref().quit_id());
                        self.set_all_transitions(unk_id, unk_id);
                        self.set_all_transitions(dead_id, dead_id);
                        self.set_all_transitions(quit_id, quit_id);
                        self.cache.states_to_id.insert(dead, dead_id);
                    }
                    /// Save the state corresponding to the ID given such that the state
                    fn save_state(&mut self, id: LazyStateID) {
                        let state = self.as_ref().get_cached_state(id).clone();
                        self.cache.state_saver = StateSaver::ToSave { id, state };
                    }
                    /// Returns the updated lazy state ID for a state that was persisted
                    fn saved_state_id(&mut self) -> LazyStateID {
                        self.cache
                            .state_saver
                            .take_saved()
                            .expect("state saver does not have saved state ID")
                    }
                    /// Set all transitions on the state 'from' to 'to'.
                    fn set_all_transitions(&mut self, from: LazyStateID, to: LazyStateID) {
                        for unit in self.dfa.classes.representatives(..) {
                            self.set_transition(from, unit, to);
                        }
                    }
                    /// Set the transition on 'from' for 'unit' to 'to'.
                    fn set_transition
                    (
                        &mut self,
                        from: LazyStateID,
                        unit: alphabet::Unit,
                        to: LazyStateID,
                    ) {
                        assert!(self.as_ref().is_valid(from), "invalid 'from' id: {from:?}");
                        assert!(self.as_ref().is_valid(to), "invalid 'to' id: {to:?}");
                        let offset =
                            from.as_usize_untagged() + self.dfa.classes.get_by_unit(unit);
                        self.cache.trans[offset] = to;
                    }
                    /// Set the start ID for the given pattern ID (if given) and starting
                    fn set_start_state
                    (
                        &mut self,
                        anchored: Anchored,
                        start: Start,
                        id: LazyStateID,
                    ) {
                        assert!(self.as_ref().is_valid(id));
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => Start::len() + start_index,
                            Anchored::Pattern(pid) => {
                                assert!(
                                    self.dfa.get_config().get_starts_for_each_pattern(),
                                    "attempted to search for a specific pattern \
                                    without enabling starts_for_each_pattern",
                                );
                                let pid = pid.as_usize();
                                (2 * Start::len()) + (Start::len() * pid) + start_index
                            }
                        };
                        self.cache.starts[index] = id;
                    }
                    /// Returns a state builder from this DFA that might have existing
                    fn get_state_builder(&mut self) -> StateBuilderEmpty {
                        ::mem::replace(
                            &mut self.cache.scratch_state_builder,
                            StateBuilderEmpty::new(),
                        )
                    }
                    /// Puts the given state builder back into this DFA for reuse.
                    fn put_state_builder(&mut self, builder: StateBuilderNFA) {
                        let _ = ::mem::replace(
                            &mut self.cache.scratch_state_builder,
                            builder.clear(),
                        );
                    }
                }
                /// A type that groups methods that require the base NFA/DFA and read-only
                #[derive(Debug)]
                struct LazyRef<'i, 'c> {
                    dfa: &'i DFA,
                    cache: &'c Cache,
                }

                impl<'i, 'c> LazyRef<'i, 'c>
                {
                    /// Creates a new 'Lazy' wrapper for a DFA and its corresponding cache.
                    fn new(dfa: &'i DFA, cache: &'c Cache) -> LazyRef<'i, 'c> {
                        LazyRef { dfa, cache }
                    }
                    /// Return the ID of the start state for the given configuration.
                    #[inline( always )]
                    fn get_cached_start_id(
                        &self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<LazyStateID, StartError> {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => Start::len() + start_index,
                            Anchored::Pattern(pid) => {
                                if !self.dfa.get_config().get_starts_for_each_pattern() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                if pid.as_usize() >= self.dfa.pattern_len() {
                                    return Ok(self.dead_id());
                                }
                                (2 * Start::len())
                                    + (Start::len() * pid.as_usize())
                                    + start_index
                            }
                        };
                        Ok(self.cache.starts[index])
                    }
                    /// Return the cached NFA/DFA powerset state for the given ID.
                    fn get_cached_state(&self, sid: LazyStateID) -> &State {
                        let index = sid.as_usize_untagged() >> self.dfa.stride2();
                        &self.cache.states[index]
                    }
                    /// Returns true if and only if the given ID corresponds to a "sentinel"
                    fn is_sentinel(&self, id: LazyStateID) -> bool {
                        id == self.unknown_id() || id == self.dead_id() || id == self.quit_id()
                    }
                    /// Returns the ID of the unknown state for this lazy DFA.
                    fn unknown_id(&self) -> LazyStateID {
                        // This unwrap is OK since 0 is always a valid state ID.
                        LazyStateID::new(0).unwrap().to_unknown()
                    }
                    /// Returns the ID of the dead state for this lazy DFA.
                    fn dead_id(&self) -> LazyStateID {
                        LazyStateID::new(1 << self.dfa.stride2()).unwrap().to_dead()
                    }
                    /// Returns the ID of the quit state for this lazy DFA.
                    fn quit_id(&self) -> LazyStateID {
                        LazyStateID::new(2 << self.dfa.stride2()).unwrap().to_quit()
                    }
                    /// Returns true if and only if the given ID is valid.
                    fn is_valid(&self, id: LazyStateID) -> bool {
                        let id = id.as_usize_untagged();
                        id < self.cache.trans.len() && id % self.dfa.stride() == 0
                    }
                    /// Returns true if adding the state given would fit in this cache.
                    fn state_fits_in_cache(&self, state: &State) -> bool {
                        let needed = self.cache.memory_usage()
                            + self.memory_usage_for_one_more_state(state.memory_usage());
                        trace!(
                            "lazy DFA cache capacity check: {:?} ?<=? {:?}",
                            needed,
                            self.dfa.cache_capacity
                        );
                        needed <= self.dfa.cache_capacity
                    }
                    /// Returns true if adding the state to be built by the given builder would
                    fn state_builder_fits_in_cache(&self, state: &StateBuilderNFA) -> bool {
                        let needed = self.cache.memory_usage()
                            + self.memory_usage_for_one_more_state(state.as_bytes().len());
                        needed <= self.dfa.cache_capacity
                    }
                    /// Returns the additional memory usage, in bytes, required to add one more
                    fn memory_usage_for_one_more_state(
                        &self,
                        state_heap_size: usize,
                    ) -> usize {
                        const ID_SIZE: usize = size_of::<LazyStateID>();
                        const STATE_SIZE: usize = size_of::<State>();

                        self.dfa.stride() * ID_SIZE // additional space needed in trans table
                        + STATE_SIZE // space in cache.states
                        + (STATE_SIZE + ID_SIZE) // space in cache.states_to_id
                        + state_heap_size // heap memory used by state itself
                    }
                }
                /// A simple type that encapsulates the saving of a state ID through a cache
                #[derive(Clone, Debug)]
                enum StateSaver
                {
                    /// An empty state saver. In this case, no states (other than the special
                    None,
                    /// An ID of a state (and the state itself) that should be preserved after
                    ToSave { id: LazyStateID, state: State },
                    /// An ID that of a state that has been persisted through a lazy DFA
                    Saved(LazyStateID),
                }

                impl StateSaver
                {
                    /// Create an empty state saver.
                    fn none() -> StateSaver {
                        StateSaver::None
                    }
                    /// Replace this state saver with an empty saver, and if this saver is a
                    fn take_to_save(&mut self) -> Option<(LazyStateID, State)> {
                        match ::mem::replace(self, StateSaver::None) {
                            StateSaver::None | StateSaver::Saved(_) => None,
                            StateSaver::ToSave { id, state } => Some((id, state)),
                        }
                    }
                    /// Replace this state saver with an empty saver, and if this saver is a
                    fn take_saved(&mut self) -> Option<LazyStateID> {
                        match ::mem::replace(self, StateSaver::None) {
                            StateSaver::None => None,
                            StateSaver::Saved(id) | StateSaver::ToSave { id, .. } => Some(id),
                        }
                    }
                }
                /// The configuration used for building a lazy DFA.
                #[derive(Clone, Debug, Default)]
                pub struct Config {
                    match_kind: Option<MatchKind>,
                    pre: Option<Option<Prefilter>>,
                    starts_for_each_pattern: Option<bool>,
                    byte_classes: Option<bool>,
                    unicode_word_boundary: Option<bool>,
                    quitset: Option<ByteSet>,
                    specialize_start_states: Option<bool>,
                    cache_capacity: Option<usize>,
                    skip_cache_capacity_check: Option<bool>,
                    minimum_cache_clear_count: Option<Option<usize>>,
                    minimum_bytes_per_state: Option<Option<usize>>,
                }

                impl Config
                {
                    /// Return a new default lazy DFA builder configuration.
                    pub fn new() -> Config {
                        Config::default()
                    }
                    /// Set the desired match semantics.
                    pub fn match_kind(mut self, kind: MatchKind) -> Config {
                        self.match_kind = Some(kind);
                        self
                    }
                    /// Set a prefilter to be used whenever a start state is entered.
                    pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
                        self.pre = Some(pre);
                        
                        if self.specialize_start_states.is_none() {
                            self.specialize_start_states =
                                Some(self.get_prefilter().is_some());
                        }
                        self
                    }
                    /// Whether to compile a separate start state for each pattern in the
                    pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {
                        self.starts_for_each_pattern = Some(yes);
                        self
                    }
                    /// Whether to attempt to shrink the size of the lazy DFA's alphabet or
                    pub fn byte_classes(mut self, yes: bool) -> Config {
                        self.byte_classes = Some(yes);
                        self
                    }
                    /// Heuristically enable Unicode word boundaries.
                    pub fn unicode_word_boundary(mut self, yes: bool) -> Config {
                        self.unicode_word_boundary = Some(yes);
                        self
                    }
                    /// Add a "quit" byte to the lazy DFA.
                    pub fn quit(mut self, byte: u8, yes: bool) -> Config {
                        if self.get_unicode_word_boundary() && !byte.is_ascii() && !yes {
                            panic!(
                                "cannot set non-ASCII byte to be non-quit when \
                                Unicode word boundaries are enabled"
                            );
                        }
                        
                        if self.quitset.is_none() {
                            self.quitset = Some(ByteSet::empty());
                        }
                        
                        if yes {
                            self.quitset.as_mut().unwrap().add(byte);
                        } else {
                            self.quitset.as_mut().unwrap().remove(byte);
                        }
                        self
                    }
                    /// Enable specializing start states in the lazy DFA.
                    pub fn specialize_start_states(mut self, yes: bool) -> Config {
                        self.specialize_start_states = Some(yes);
                        self
                    }
                    /// Sets the maximum amount of heap memory, in bytes, to allocate to the
                    pub fn cache_capacity(mut self, bytes: usize) -> Config {
                        self.cache_capacity = Some(bytes);
                        self
                    }
                    /// Configures construction of a lazy DFA to use the minimum cache capacity
                    pub fn skip_cache_capacity_check(mut self, yes: bool) -> Config {
                        self.skip_cache_capacity_check = Some(yes);
                        self
                    }
                    /// Configure a lazy DFA search to quit after a certain number of cache
                    pub fn minimum_cache_clear_count(mut self, min: Option<usize>) -> Config {
                        self.minimum_cache_clear_count = Some(min);
                        self
                    }
                    /// Configure a lazy DFA search to quit only when its efficiency drops
                    pub fn minimum_bytes_per_state(mut self, min: Option<usize>) -> Config {
                        self.minimum_bytes_per_state = Some(min);
                        self
                    }
                    /// Returns the match semantics set in this configuration.
                    pub fn get_match_kind(&self) -> MatchKind {
                        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
                    }
                    /// Returns the prefilter set in this configuration, if one at all.
                    pub fn get_prefilter(&self) -> Option<&Prefilter> {
                        self.pre.as_ref().unwrap_or(&None).as_ref()
                    }
                    /// Returns whether this configuration has enabled anchored starting states
                    pub fn get_starts_for_each_pattern(&self) -> bool {
                        self.starts_for_each_pattern.unwrap_or(false)
                    }
                    /// Returns whether this configuration has enabled byte classes or not.
                    pub fn get_byte_classes(&self) -> bool {
                        self.byte_classes.unwrap_or(true)
                    }
                    /// Returns whether this configuration has enabled heuristic Unicode word
                    pub fn get_unicode_word_boundary(&self) -> bool {
                        self.unicode_word_boundary.unwrap_or(false)
                    }
                    /// Returns whether this configuration will instruct the lazy DFA to enter
                    pub fn get_quit(&self, byte: u8) -> bool {
                        self.quitset.map_or(false, |q| q.contains(byte))
                    }
                    /// Returns whether this configuration will instruct the lazy DFA to
                    pub fn get_specialize_start_states(&self) -> bool {
                        self.specialize_start_states.unwrap_or(false)
                    }
                    /// Returns the cache capacity set on this configuration.
                    pub fn get_cache_capacity(&self) -> usize {
                        self.cache_capacity.unwrap_or(2 * (1 << 20))
                    }
                    /// Returns whether the cache capacity check should be skipped.
                    pub fn get_skip_cache_capacity_check(&self) -> bool {
                        self.skip_cache_capacity_check.unwrap_or(false)
                    }
                    /// Returns, if set, the minimum number of times the cache must be cleared
                    pub fn get_minimum_cache_clear_count(&self) -> Option<usize> {
                        self.minimum_cache_clear_count.unwrap_or(None)
                    }
                    /// Returns, if set, the minimum number of bytes per state that need to be
                    pub fn get_minimum_bytes_per_state(&self) -> Option<usize> {
                        self.minimum_bytes_per_state.unwrap_or(None)
                    }
                    /// Returns the minimum lazy DFA cache capacity required for the given NFA.
                    pub fn get_minimum_cache_capacity(
                        &self,
                        nfa: &thompson::NFA,
                    ) -> Result<usize, BuildError> {
                        let quitset = self.quit_set_from_nfa(nfa)?;
                        let classes = self.byte_classes_from_nfa(nfa, &quitset);
                        let starts = self.get_starts_for_each_pattern();
                        Ok(minimum_cache_capacity(nfa, &classes, starts))
                    }
                    /// Returns the byte class map used during search from the given NFA.
                    fn byte_classes_from_nfa(
                        &self,
                        nfa: &thompson::NFA,
                        quit: &ByteSet,
                    ) -> ByteClasses {
                        if !self.get_byte_classes() {
                            ByteClasses::singletons()
                        } else {
                            let mut set = nfa.byte_class_set().clone();
                            if !quit.is_empty() {
                                set.add_set(&quit);
                            }
                            set.byte_classes()
                        }
                    }
                    /// Return the quit set for this configuration and the given NFA.
                    fn quit_set_from_nfa(
                        &self,
                        nfa: &thompson::NFA,
                    ) -> Result<ByteSet, BuildError> {
                        let mut quit = self.quitset.unwrap_or(ByteSet::empty());
                        
                        if nfa.look_set_any().contains_word_unicode()
                        {
                            if self.get_unicode_word_boundary() {
                                for b in 0x80..=0xFF {
                                    quit.add(b);
                                }
                            } else {
                                if !quit.contains_range(0x80, 0xFF) {
                                    return Err(
                                        BuildError::unsupported_dfa_word_boundary_unicode(),
                                    );
                                }
                            }
                        }
                        Ok(quit)
                    }
                    /// Overwrite the default configuration such that the options in `o` are
                    fn overwrite(&self, o: Config) -> Config {
                        Config {
                            match_kind: o.match_kind.or(self.match_kind),
                            pre: o.pre.or_else(|| self.pre.clone()),
                            starts_for_each_pattern: o
                                .starts_for_each_pattern
                                .or(self.starts_for_each_pattern),
                            byte_classes: o.byte_classes.or(self.byte_classes),
                            unicode_word_boundary: o
                                .unicode_word_boundary
                                .or(self.unicode_word_boundary),
                            quitset: o.quitset.or(self.quitset),
                            specialize_start_states: o
                                .specialize_start_states
                                .or(self.specialize_start_states),
                            cache_capacity: o.cache_capacity.or(self.cache_capacity),
                            skip_cache_capacity_check: o
                                .skip_cache_capacity_check
                                .or(self.skip_cache_capacity_check),
                            minimum_cache_clear_count: o
                                .minimum_cache_clear_count
                                .or(self.minimum_cache_clear_count),
                            minimum_bytes_per_state: o
                                .minimum_bytes_per_state
                                .or(self.minimum_bytes_per_state),
                        }
                    }
                }
                /// A builder for constructing a lazy deterministic finite automaton from
                #[derive(Clone, Debug)]
                pub struct Builder {
                    config: Config,
                    thompson: thompson::Compiler,
                }

                impl Builder
                {
                    /// Create a new lazy DFA builder with the default configuration.
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                                    thompson: thompson::Compiler::new(),
                        }
                    }
                    /// Build a lazy DFA from the given pattern.
                    pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> {
                        self.build_many(&[pattern])
                    }
                    /// Build a lazy DFA from the given patterns.
                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<DFA, BuildError> {
                        let nfa = self
                            .thompson
                            .clone()
                            .configure(
                                thompson::Config::new()
                                    .which_captures(thompson::WhichCaptures::None),
                            )
                            .build_many(patterns)
                            .map_err(BuildError::nfa)?;
                        self.build_from_nfa(nfa)
                    }
                    /// Build a DFA from the given NFA.
                    pub fn build_from_nfa(
                        &self,
                        nfa: thompson::NFA,
                    ) -> Result<DFA, BuildError> {
                        let quitset = self.config.quit_set_from_nfa(&nfa)?;
                        let classes = self.config.byte_classes_from_nfa(&nfa, &quitset);
                        let min_cache = minimum_cache_capacity(
                            &nfa,
                            &classes,
                            self.config.get_starts_for_each_pattern(),
                        );
                        let mut cache_capacity = self.config.get_cache_capacity();
                        
                        if cache_capacity < min_cache {
                            if self.config.get_skip_cache_capacity_check() {
                                debug!(
                                    "given capacity ({cache_capacity}) is too small, \
                                    since skip_cache_capacity_check is enabled, \
                                    setting cache capacity to minimum ({min_cache})",
                                );
                                cache_capacity = min_cache;
                            } else {
                                return Err(BuildError::insufficient_cache_capacity(
                                    min_cache,
                                    cache_capacity,
                                ));
                            }
                        }
                        
                        if let Err(err) = minimum_lazy_state_id(&classes) {
                            return Err(BuildError::insufficient_state_id_capacity(err));
                        }
                        let stride2 = classes.stride2();
                        let start_map = StartByteMap::new(nfa.look_matcher());
                        Ok(DFA {
                            config: self.config.clone(),
                            nfa,
                            stride2,
                            start_map,
                            classes,
                            quitset,
                            cache_capacity,
                        })
                    }
                    /// Apply the given lazy DFA configuration options to this builder.
                    pub fn configure(&mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }
                    /// Set the syntax configuration for this builder using
                    pub fn syntax
                    (
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.thompson.syntax(config);
                        self
                    }
                    /// Set the Thompson NFA configuration for this builder using
                    pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                        self.thompson.configure(config);
                        self
                    }
                }
                /// Represents the current state of an overlapping search.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct OverlappingState
                {
                    /// The match reported by the most recent overlapping search to use this
                    pub mat: Option<HalfMatch>,
                    /// The state ID of the state at which the search was in when the call
                    pub id: Option<LazyStateID>,
                    /// The position of the search.
                    pub at: usize,
                    /// The index into the matching patterns of the next match to report if the
                    pub next_match_index: Option<usize>,
                    /// This is set to true when a reverse overlapping search has entered its
                    pub rev_eoi: bool,
                }

                impl OverlappingState
                {
                    /// Create a new overlapping state that begins at the start state of any
                    pub fn start() -> OverlappingState {
                        OverlappingState {
                            mat: None,
                            id: None,
                            at: 0,
                            next_match_index: None,
                            rev_eoi: false,
                        }
                    }
                    /// Return the match result of the most recent search to execute with this
                    pub fn get_match(&self) -> Option<HalfMatch> {
                        self.mat
                    }
                }
                /// Runs the given overlapping `search` function (forwards or backwards) until
                #[cold]
                #[inline(never)]
                fn skip_empty_utf8_splits_overlapping<F>(
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                    mut search: F,
                ) -> Result<(), MatchError> where
                    F: FnMut(&Input<'_>, &mut OverlappingState) -> Result<(), MatchError>,
                {

                    let mut hm = match state.get_match() {
                        None => return Ok(()),
                        Some(hm) => hm,
                    };
                    if input.get_anchored().is_anchored() {
                        if !input.is_char_boundary(hm.offset()) {
                            state.mat = None;
                        }
                        return Ok(());
                    }
                    while !input.is_char_boundary(hm.offset()) {
                        search(input, state)?;
                        hm = match state.get_match() {
                            None => return Ok(()),
                            Some(hm) => hm,
                        };
                    }
                    Ok(())
                }
                /// Based on the minimum number of states required for a useful lazy DFA cache,
                fn minimum_lazy_state_id(
                    classes: &ByteClasses,
                ) -> Result<LazyStateID, LazyStateIDError>
                {
                    let stride = 1 << classes.stride2();
                    let min_state_index = MIN_STATES.checked_sub(1).unwrap();
                    LazyStateID::new(min_state_index * stride)
                }
                /// Based on the minimum number of states required for a useful lazy DFA cache,
                fn minimum_cache_capacity(
                    nfa: &thompson::NFA,
                    classes: &ByteClasses,
                    starts_for_each_pattern: bool,
                ) -> usize {
                    const ID_SIZE: usize = size_of::<LazyStateID>();
                    const STATE_SIZE: usize = size_of::<State>();

                    let stride = 1 << classes.stride2();
                    let states_len = nfa.states().len();
                    let sparses = 2 * states_len * NFAStateID::SIZE;
                    let trans = MIN_STATES * stride * ID_SIZE;

                    let mut starts = Start::len() * ID_SIZE;
                    if starts_for_each_pattern {
                        starts += (Start::len() * nfa.pattern_len()) * ID_SIZE;
                    }
                    assert!(MIN_STATES >= 5, "minimum number of states has to be at least 5");
                    let non_sentinel = MIN_STATES.checked_sub(SENTINEL_STATES).unwrap();
                    let dead_state_size = State::dead().memory_usage();
                    let max_state_size = 5 + 4 + (nfa.pattern_len() * 4) + (states_len * 5);
                    let states = (SENTINEL_STATES * (STATE_SIZE + dead_state_size))
                        + (non_sentinel * (STATE_SIZE + max_state_size));
                    let states_to_sid = (MIN_STATES * STATE_SIZE) + (MIN_STATES * ID_SIZE);
                    let stack = states_len * NFAStateID::SIZE;
                    let scratch_state_builder = max_state_size;

                    trans
                        + starts
                        + states
                        + states_to_sid
                        + sparses
                        + stack
                        + scratch_state_builder
                }
            }

            pub mod error
            {
                use ::
                {
                    regex::automata::
                    {
                        hybrid::id::LazyStateIDError, 
                        nfa, 
                        util::search::Anchored,
                    },
                    *,
                };
                /*
                */
                /// An error that occurs when initial construction of a lazy DFA fails.
                #[derive(Clone, Debug)]
                pub struct BuildError {
                    kind: BuildErrorKind,
                }

                #[derive(Clone, Debug)]
                enum BuildErrorKind {
                    NFA(nfa::thompson::BuildError),
                    InsufficientCacheCapacity { minimum: usize, given: usize },
                    InsufficientStateIDCapacity { err: LazyStateIDError },
                    Unsupported(&'static str),
                }

                impl BuildError {
                    pub fn nfa(err: nfa::thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }

                    pub fn insufficient_cache_capacity(
                        minimum: usize,
                        given: usize,
                    ) -> BuildError {
                        BuildError {
                            kind: BuildErrorKind::InsufficientCacheCapacity { minimum, given },
                        }
                    }

                    pub fn insufficient_state_id_capacity(
                        err: LazyStateIDError,
                    ) -> BuildError {
                        BuildError {
                            kind: BuildErrorKind::InsufficientStateIDCapacity { err },
                        }
                    }

                    pub fn unsupported_dfa_word_boundary_unicode() -> BuildError {
                        let msg = "cannot build lazy DFAs for regexes with Unicode word \
                                boundaries; switch to ASCII word boundaries, or \
                                heuristically enable Unicode word boundaries or use a \
                                different regex engine";
                        BuildError { kind: BuildErrorKind::Unsupported(msg) }
                    }
                }
                
                impl ::error::Error for BuildError {
                    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                        match self.kind {
                            BuildErrorKind::NFA(ref err) => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for BuildError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match self.kind {
                            BuildErrorKind::NFA(_) => write!(f, "error building NFA"),
                            BuildErrorKind::InsufficientCacheCapacity { minimum, given } => {
                                write!(
                                    f,
                                    "given cache capacity ({given}) is smaller than \
                                    minimum required ({minimum})",
                                )
                            }
                            BuildErrorKind::InsufficientStateIDCapacity { ref err } => {
                                err.fmt(f)
                            }
                            BuildErrorKind::Unsupported(ref msg) => {
                                write!(f, "unsupported regex feature for DFAs: {msg}")
                            }
                        }
                    }
                }
                /// An error that can occur when computing the start state for a search.
                #[non_exhaustive]
                #[derive(Clone, Debug)]
                pub enum StartError
                {
                    /// An error that occurs when cache inefficiency has dropped below the
                    Cache {
                        /// The underlying cache error that occurred.
                        err: CacheError,
                    },
                    /// An error that occurs when a starting configuration's look-behind byte
                    Quit {
                        /// The quit byte that was found.
                        byte: u8,
                    },
                    /// An error that occurs when the caller requests an anchored mode that
                    UnsupportedAnchored {
                        /// The anchored mode given that is unsupported.
                        mode: Anchored,
                    },
                }

                impl StartError {
                    pub fn cache(err: CacheError) -> StartError {
                        StartError::Cache { err }
                    }

                    pub fn quit(byte: u8) -> StartError {
                        StartError::Quit { byte }
                    }

                    pub fn unsupported_anchored(mode: Anchored) -> StartError {
                        StartError::UnsupportedAnchored { mode }
                    }
                }
                
                impl ::error::Error for StartError {
                    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                        match *self {
                            StartError::Cache { ref err } => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for StartError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match *self {
                            StartError::Cache { .. } => write!(
                                f,
                                "error computing start state because of cache inefficiency"
                            ),
                            StartError::Quit { byte } => write!(
                                f,
                                "error computing start state because the look-behind byte \
                                {:?} triggered a quit state",
                                crate::util::escape::DebugByte(byte),
                            ),
                            StartError::UnsupportedAnchored { mode: Anchored::Yes } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored { mode: Anchored::No } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    unanchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored {
                                mode: Anchored::Pattern(pid),
                            } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches for a specific pattern ({}) \
                                    are not supported or enabled",
                                    pid.as_usize(),
                                )
                            }
                        }
                    }
                }
                /// An error that occurs when cache usage has become inefficient.
                #[derive(Clone, Debug)]
                pub struct CacheError(());

                impl CacheError {
                    pub fn too_many_cache_clears() -> CacheError {
                        CacheError(())
                    }

                    pub fn bad_efficiency() -> CacheError {
                        CacheError(())
                    }
                }
                
                impl ::error::Error for CacheError {}

                impl ::fmt::Display for CacheError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        write!(f, "lazy DFA cache has been cleared too many times")
                    }
                }

            }

            pub mod id
            {
                use ::
                {
                    regex::automata::
                    {
                        
                    },
                    *,
                };
                /*
                */
                /// A state identifier specifically tailored for lazy DFAs.
                #[derive(
                    Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
                )]
                pub struct LazyStateID(u32);

                impl LazyStateID {
                    #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
                    const MAX_BIT: usize = 31;

                    #[cfg(target_pointer_width = "16")]
                    const MAX_BIT: usize = 15;

                    const MASK_UNKNOWN: usize = 1 << (LazyStateID::MAX_BIT);
                    const MASK_DEAD: usize = 1 << (LazyStateID::MAX_BIT - 1);
                    const MASK_QUIT: usize = 1 << (LazyStateID::MAX_BIT - 2);
                    const MASK_START: usize = 1 << (LazyStateID::MAX_BIT - 3);
                    const MASK_MATCH: usize = 1 << (LazyStateID::MAX_BIT - 4);
                    const MAX: usize = LazyStateID::MASK_MATCH - 1;
                    /// Create a new lazy state ID.
                    #[inline] pub fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> {
                        if id > LazyStateID::MAX {
                            let attempted = u64::try_from(id).unwrap();
                            
                            return Err(LazyStateIDError { attempted });
                        }
                        Ok(LazyStateID::new_unchecked(id))
                    }
                    /// Create a new lazy state ID without checking whether the given value
                    #[inline]
                    const fn new_unchecked(id: usize) -> LazyStateID {
                        // FIXME: Use as_u32() once const functions in traits are stable.
                        LazyStateID(id as u32)
                    }
                    /// Return this lazy state ID as an untagged `usize`.
                    #[inline] pub fn as_usize_untagged(&self) -> usize {
                        self.as_usize_unchecked() & LazyStateID::MAX
                    }
                    /// Return this lazy state ID as its raw internal `usize` value, which may
                    #[inline] pub const fn as_usize_unchecked(&self) -> usize {
                        // FIXME: Use as_usize() once const functions in traits are stable.
                        self.0 as usize
                    }

                    #[inline] pub const fn to_unknown(&self) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_UNKNOWN,
                        )
                    }

                    #[inline] pub const fn to_dead(&self) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_DEAD,
                        )
                    }

                    #[inline] pub const fn to_quit(&self) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_QUIT,
                        )
                    }
                    /// Return this lazy state ID as a state ID that is tagged as a start
                    #[inline] pub const fn to_start(&self) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_START,
                        )
                    }
                    /// Return this lazy state ID as a lazy state ID that is tagged as a match
                    #[inline] pub const fn to_match(&self) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_MATCH,
                        )
                    }
                    /// Return true if and only if this lazy state ID is tagged.
                    #[inline] pub const fn is_tagged(&self) -> bool {
                        self.as_usize_unchecked() > LazyStateID::MAX
                    }
                    /// Return true if and only if this represents a lazy state ID that is
                    #[inline] pub const fn is_unknown(&self) -> bool {
                        self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0
                    }
                    /// Return true if and only if this represents a dead state. A dead state
                    #[inline] pub const fn is_dead(&self) -> bool {
                        self.as_usize_unchecked() & LazyStateID::MASK_DEAD > 0
                    }
                    /// Return true if and only if this represents a quit state. A quit state
                    #[inline] pub const fn is_quit(&self) -> bool {
                        self.as_usize_unchecked() & LazyStateID::MASK_QUIT > 0
                    }
                    /// Return true if and only if this lazy state ID has been tagged as a
                    #[inline] pub const fn is_start(&self) -> bool {
                        self.as_usize_unchecked() & LazyStateID::MASK_START > 0
                    }
                    /// Return true if and only if this lazy state ID has been tagged as a
                    #[inline] pub const fn is_match(&self) -> bool {
                        self.as_usize_unchecked() & LazyStateID::MASK_MATCH > 0
                    }
                }
                /// This error occurs when a lazy state ID could not be constructed.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct LazyStateIDError {
                    attempted: u64,
                }

                impl LazyStateIDError
                {
                    /// Returns the value that failed to constructed a lazy state ID.
                    pub fn attempted(&self) -> u64 {
                        self.attempted
                    }
                }
                
                impl ::error::Error for LazyStateIDError {}

                impl ::fmt::Display for LazyStateIDError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(
                            f,
                            "failed to create LazyStateID from {:?}, which exceeds {:?}",
                            self.attempted(),
                            LazyStateID::MAX,
                        )
                    }
                }

            }

            pub mod regex
            {
                /*!
                A lazy DFA backed `Regex`. */
                use ::
                {
                    regex::automata::
                    {
                        hybrid::
                        {
                            dfa::{self, DFA},
                            error::BuildError,
                        },
                        nfa::thompson,
                        util::
                        {
                            iter,
                            search::{Anchored, Input, Match, MatchError, MatchKind},
                        },  
                    },
                    *,
                };
                /*
                */
                /// A regular expression that uses hybrid NFA/DFAs (also called "lazy DFAs")
                #[derive(Debug)]
                pub struct Regex
                {
                    /// The forward lazy DFA. This can only find the end of a match.
                    forward: DFA,
                    /// The reverse lazy DFA. This can only find the start of a match.
                    reverse: DFA,
                }
                /// Convenience routines for regex and cache construction.
                impl Regex
                {
                    /// Parse the given regular expression using the default configuration and
                    pub fn new(pattern: &str) -> Result<Regex, BuildError> {
                        Regex::builder().build(pattern)
                    }
                    /// Like `new`, but parses multiple patterns into a single "multi regex."
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        Regex::builder().build_many(patterns)
                    }
                    /// Return a builder for configuring the construction of a `Regex`.
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                    /// Create a new cache for this `Regex`.
                    pub fn create_cache(&self) -> Cache {
                        Cache::new(self)
                    }
                    /// Reset the given cache such that it can be used for searching with the
                    pub fn reset_cache(&self, cache: &mut Cache) {
                        self.forward().reset_cache(&mut cache.forward);
                        self.reverse().reset_cache(&mut cache.reverse);
                    }
                }
                /// Standard infallible search routines for finding and iterating over matches.
                impl Regex
                {
                    /// Returns true if and only if this regex matches the given haystack.
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> bool {
                        self.forward()
                            .try_search_fwd(&mut cache.forward, &input.into().earliest(true))
                            .unwrap()
                            .is_some()
                    }
                    /// Returns the start and end offset of the leftmost match. If no match
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> Option<Match> {
                        self.try_search(cache, &input.into()).unwrap()
                    }
                    /// Returns an iterator over all non-overlapping leftmost matches in the
                    #[inline] pub fn find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        cache: &'c mut Cache,
                        input: I,
                    ) -> FindMatches<'r, 'c, 'h> {
                        let it = iter::Searcher::new(input.into());
                        FindMatches { re: self, cache, it }
                    }
                }
                /// Lower level "search" primitives that accept a `&Input` for cheap reuse
                impl Regex
                {
                    /// Returns the start and end offset of the leftmost match. If no match
                    #[inline] pub fn try_search(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, MatchError> {
                        let (fcache, rcache) = (&mut cache.forward, &mut cache.reverse);
                        let end = match self.forward().try_search_fwd(fcache, input)? {
                            None => return Ok(None),
                            Some(end) => end,
                        };
                        
                        if input.start() == end.offset() {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                end.offset()..end.offset(),
                            )));
                        }
                        
                        if self.is_anchored(input) {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                input.start()..end.offset(),
                            )));
                        }
                        let revsearch = input
                            .clone()
                            .span(input.start()..end.offset())
                            .anchored(Anchored::Yes)
                            .earliest(false);
                        let start = self
                            .reverse()
                            .try_search_rev(rcache, &revsearch)?
                            .expect("reverse search must match if forward search does");
                        debug_assert_eq!(
                            start.pattern(),
                            end.pattern(),
                            "forward and reverse search must match same pattern",
                        );
                        debug_assert!(start.offset() <= end.offset());
                        Ok(Some(Match::new(end.pattern(), start.offset()..end.offset())))
                    }
                    /// Returns true if either the given input specifies an anchored search
                    fn is_anchored(&self, input: &Input<'_>) -> bool {
                        match input.get_anchored() {
                            Anchored::No => {
                                self.forward().get_nfa().is_always_start_anchored()
                            }
                            Anchored::Yes | Anchored::Pattern(_) => true,
                        }
                    }
                }
                /// Non-search APIs for querying information about the regex and setting a
                impl Regex
                {
                    /// Return the underlying lazy DFA responsible for forward matching.
                    pub fn forward(&self) -> &DFA {
                        &self.forward
                    }
                    /// Return the underlying lazy DFA responsible for reverse matching.
                    pub fn reverse(&self) -> &DFA {
                        &self.reverse
                    }
                    /// Returns the total number of patterns matched by this regex.
                    pub fn pattern_len(&self) -> usize {
                        assert_eq!(self.forward().pattern_len(), self.reverse().pattern_len());
                        self.forward().pattern_len()
                    }
                }
                /// An iterator over all non-overlapping matches for an infallible search.
                #[derive(Debug)]
                pub struct FindMatches<'r, 'c, 'h> {
                    re: &'r Regex,
                    cache: &'c mut Cache,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'c, 'h> Iterator for FindMatches<'r, 'c, 'h> {
                    type Item = Match;

                    #[inline]
                    fn next(&mut self) -> Option<Match> {
                        let FindMatches { re, ref mut cache, ref mut it } = *self;
                        it.advance(|input| re.try_search(cache, input))
                    }
                }
                /// A cache represents a partially computed forward and reverse DFA.
                #[derive(Debug, Clone)]
                pub struct Cache {
                    forward: dfa::Cache,
                    reverse: dfa::Cache,
                }

                impl Cache
                {
                    /// Create a new cache for the given `Regex`.
                    pub fn new(re: &Regex) -> Cache {
                        let forward = dfa::Cache::new(re.forward());
                        let reverse = dfa::Cache::new(re.reverse());
                        Cache { forward, reverse }
                    }
                    /// Reset this cache such that it can be used for searching with the given
                    pub fn reset(&mut self, re: &Regex) {
                        self.forward.reset(re.forward());
                        self.reverse.reset(re.reverse());
                    }
                    /// Return a reference to the forward cache.
                    pub fn forward(&mut self) -> &dfa::Cache {
                        &self.forward
                    }
                    /// Return a reference to the reverse cache.
                    pub fn reverse(&mut self) -> &dfa::Cache {
                        &self.reverse
                    }
                    /// Return a mutable reference to the forward cache.
                    pub fn forward_mut(&mut self) -> &mut dfa::Cache {
                        &mut self.forward
                    }
                    /// Return a mutable reference to the reverse cache.
                    pub fn reverse_mut(&mut self) -> &mut dfa::Cache {
                        &mut self.reverse
                    }
                    /// Return references to the forward and reverse caches, respectively.
                    pub fn as_parts(&self) -> (&dfa::Cache, &dfa::Cache) {
                        (&self.forward, &self.reverse)
                    }
                    /// Return mutable references to the forward and reverse caches,
                    pub fn as_parts_mut(&mut self) -> (&mut dfa::Cache, &mut dfa::Cache) {
                        (&mut self.forward, &mut self.reverse)
                    }
                    /// Returns the heap memory usage, in bytes, as a sum of the forward and
                    pub fn memory_usage(&self) -> usize {
                        self.forward.memory_usage() + self.reverse.memory_usage()
                    }
                }
                /// A builder for a regex based on a hybrid NFA/DFA.
                #[derive(Clone, Debug)]
                pub struct Builder {
                    dfa: dfa::Builder,
                }

                impl Builder
                {
                    /// Create a new regex builder with the default configuration.
                    pub fn new() -> Builder {
                        Builder { dfa: DFA::builder() }
                    }
                    /// Build a regex from the given pattern.
                    pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> {
                        self.build_many(&[pattern])
                    }
                    /// Build a regex from the given patterns.
                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        let forward = self.dfa.build_many(patterns)?;
                        let reverse = self
                            .dfa
                            .clone()
                            .configure(
                                DFA::config()
                                    .prefilter(None)
                                    .specialize_start_states(false)
                                    .match_kind(MatchKind::All),
                            )
                            .thompson(thompson::Config::new().reverse(true))
                            .build_many(patterns)?;
                        Ok(self.build_from_dfas(forward, reverse))
                    }
                    /// Build a regex from its component forward and reverse hybrid NFA/DFAs.
                    pub fn build_from_dfas(&self, forward: DFA, reverse: DFA) -> Regex {
                        Regex { forward, reverse }
                    }
                    /// Set the syntax configuration for this builder using
                    pub fn syntax
                    (
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.dfa.syntax(config);
                        self
                    }
                    /// Set the Thompson NFA configuration for this builder using
                    pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                        self.dfa.thompson(config);
                        self
                    }
                    /// Set the lazy DFA compilation configuration for this builder using
                    pub fn dfa(&mut self, config: dfa::Config) -> &mut Builder {
                        self.dfa.configure(config);
                        self
                    }
                }

                impl Default for Builder {
                    fn default() -> Builder {
                        Builder::new()
                    }
                }
            }

            pub mod search
            {
                use ::
                {
                    regex::automata::
                    {
                        hybrid::
                        {
                            dfa::{Cache, OverlappingState, DFA},
                            id::LazyStateID,
                        },

                        util::
                        {
                            prefilter::Prefilter,
                            search::{HalfMatch, Input, MatchError, Span},
                        }, 
                    },
                    *,
                };
                /*
                */
                #[inline(never)]
                pub fn find_fwd
                (
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok(None);
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_config().get_prefilter()
                    };
                    if pre.is_some() {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, cache, input, pre, true)
                        } else {
                            find_fwd_imp(dfa, cache, input, pre, false)
                        }
                    } else {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, cache, input, None, true)
                        } else {
                            find_fwd_imp(dfa, cache, input, None, false)
                        }
                    }
                }

                #[inline( always )] fn find_fwd_imp(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    pre: Option<&'_ Prefilter>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.get_nfa().look_set_prefix_any().is_empty();
                    let mut mat = None;
                    let mut sid = init_fwd(dfa, cache, input)?;
                    let mut at = input.start();
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_untagged_unchecked(cache, $sid, byte)
                        }};
                    }

                    if let Some(ref pre) = pre {
                        let span = Span::from(at..input.end());
                        match pre.find(input.haystack(), span) {
                            None => return Ok(mat),
                            Some(ref span) => {
                                at = span.start;
                                
                                if !universal_start {
                                    sid = prefilter_restart(dfa, cache, &input, at)?;
                                }
                            }
                        }
                    }
                    cache.search_start(at);
                    
                    while at < input.end() {
                        if sid.is_tagged() {
                            cache.search_update(at);
                            sid = dfa
                                .next_state(cache, sid, input.haystack()[at])
                                .map_err(|_| gave_up(at))?;
                        } else {
                            let mut prev_sid = sid;
                            while at < input.end() {
                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                
                                if prev_sid.is_tagged() || at + 3 >= input.end() {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at += 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                
                                if sid.is_tagged() {
                                    break;
                                }
                                at += 1;

                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                
                                if prev_sid.is_tagged() {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at += 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                
                                if sid.is_tagged() {
                                    break;
                                }
                                at += 1;
                            }
                            
                            if sid.is_unknown() {
                                cache.search_update(at);
                                sid = dfa
                                    .next_state(cache, prev_sid, input.haystack()[at])
                                    .map_err(|_| gave_up(at))?;
                            }
                        }
                        
                        if sid.is_tagged()
                        {
                            if sid.is_start()
                            {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => {
                                            cache.search_finish(span.end);
                                            return Ok(mat);
                                        }
                                        Some(ref span) => {
                                            if span.start > at {
                                                at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(
                                                        dfa, cache, &input, at,
                                                    )?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                }
                            } else if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                
                                if earliest {
                                    cache.search_finish(at);
                                    return Ok(mat);
                                }
                            } else if sid.is_dead() {
                                cache.search_finish(at);
                                return Ok(mat);
                            } else if sid.is_quit() {
                                cache.search_finish(at);
                                return Err(MatchError::quit(input.haystack()[at], at));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        at += 1;
                    }
                    eoi_fwd(dfa, cache, input, &mut sid, &mut mat)?;
                    cache.search_finish(input.end());
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_rev
                (
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok(None);
                    }
                    if input.get_earliest() {
                        find_rev_imp(dfa, cache, input, true)
                    } else {
                        find_rev_imp(dfa, cache, input, false)
                    }
                }

                #[inline( always )] fn find_rev_imp(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError>
                {
                    let mut mat = None;
                    let mut sid = init_rev(dfa, cache, input)?;
                    if input.start() == input.end() {
                        eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }

                    let mut at = input.end() - 1;
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_untagged_unchecked(cache, $sid, byte)
                        }};
                    }
                    cache.search_start(at);

                    loop
                    {
                        if sid.is_tagged() {
                            cache.search_update(at);
                            sid = dfa
                                .next_state(cache, sid, input.haystack()[at])
                                .map_err(|_| gave_up(at))?;
                        } else {
                            let mut prev_sid = sid;
                            while at >= input.start() {
                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                
                                if prev_sid.is_tagged()
                                    || at <= input.start().saturating_add(3)
                                {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at -= 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                
                                if sid.is_tagged() {
                                    break;
                                }
                                at -= 1;

                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                
                                if prev_sid.is_tagged() {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at -= 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                
                                if sid.is_tagged() {
                                    break;
                                }
                                at -= 1;
                            }
                            
                            if sid.is_unknown() {
                                cache.search_update(at);
                                sid = dfa
                                    .next_state(cache, prev_sid, input.haystack()[at])
                                    .map_err(|_| gave_up(at))?;
                            }
                        }
                        
                        if sid.is_tagged()
                        {
                            if sid.is_start() {
                                // do nothing
                            } else if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                                
                                if earliest {
                                    cache.search_finish(at);
                                    return Ok(mat);
                                }
                            } else if sid.is_dead() {
                                cache.search_finish(at);
                                return Ok(mat);
                            } else if sid.is_quit() {
                                cache.search_finish(at);
                                return Err(MatchError::quit(input.haystack()[at], at));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                    }
                    cache.search_finish(input.start());
                    eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_overlapping_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok(());
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_config().get_prefilter()
                    };
                    if pre.is_some() {
                        find_overlapping_fwd_imp(dfa, cache, input, pre, state)
                    } else {
                        find_overlapping_fwd_imp(dfa, cache, input, None, state)
                    }
                }

                #[inline( always )] fn find_overlapping_fwd_imp(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    pre: Option<&'_ Prefilter>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> 
                {
                    let universal_start = dfa.get_nfa().look_set_prefix_any().is_empty();
                    let mut sid = match state.id {
                        None => {
                            state.at = input.start();
                            init_fwd(dfa, cache, input)?
                        }
                        Some(sid) =>
                        {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(cache, sid);
                                
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(cache, sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok(());
                                }
                            }
                            state.at += 1;
                            if state.at > input.end() {
                                return Ok(());
                            }
                            sid
                        }
                    };
                    cache.search_start(state.at);
                    
                    while state.at < input.end() {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[state.at])
                            .map_err(|_| gave_up(state.at))?;
                        
                        if sid.is_tagged() {
                            state.id = Some(sid);
                            if sid.is_start()
                            {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(state.at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => return Ok(()),
                                        Some(ref span) => {
                                            if span.start > state.at {
                                                state.at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(
                                                        dfa, cache, &input, state.at,
                                                    )?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                }
                            } else if sid.is_match() {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at));
                                cache.search_finish(state.at);
                                return Ok(());
                            } else if sid.is_dead() {
                                cache.search_finish(state.at);
                                return Ok(());
                            } else if sid.is_quit() {
                                cache.search_finish(state.at);
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        state.at += 1;
                        cache.search_update(state.at);
                    }

                    let result = eoi_fwd(dfa, cache, input, &mut sid, &mut state.mat);
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    cache.search_finish(input.end());
                    result
                }

                #[inline(never)]
                pub fn find_overlapping_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok(());
                    }
                    let mut sid = match state.id {
                        None => {
                            let sid = init_rev(dfa, cache, input)?;
                            state.id = Some(sid);
                            if input.start() == input.end() {
                                state.rev_eoi = true;
                            } else {
                                state.at = input.end() - 1;
                            }
                            sid
                        }
                        Some(sid) =>
                        {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(cache, sid);
                                
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(cache, sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok(());
                                }
                            }
                            
                            if state.rev_eoi {
                                return Ok(());
                            } else if state.at == input.start() {
                                state.rev_eoi = true;
                            } else {
                                // We haven't hit the end of the search yet, so move on.
                                state.at -= 1;
                            }
                            sid
                        }
                    };
                    cache.search_start(state.at);
                    
                    while !state.rev_eoi {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[state.at])
                            .map_err(|_| gave_up(state.at))?;
                        
                        if sid.is_tagged() {
                            state.id = Some(sid);
                            if sid.is_start() {
                                // do nothing
                            } else if sid.is_match() {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at + 1));
                                cache.search_finish(state.at);
                                return Ok(());
                            } else if sid.is_dead() {
                                cache.search_finish(state.at);
                                return Ok(());
                            } else if sid.is_quit() {
                                cache.search_finish(state.at);
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        
                        if state.at == input.start() {
                            break;
                        }
                        state.at -= 1;
                        cache.search_update(state.at);
                    }

                    let result = eoi_rev(dfa, cache, input, &mut sid, &mut state.mat);
                    state.rev_eoi = true;
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    cache.search_finish(input.start());
                    result
                }

                #[inline( always )] fn init_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<LazyStateID, MatchError>
                {
                    let sid = dfa.start_state_forward(cache, input)?;
                    debug_assert!(!sid.is_match());
                    Ok(sid)
                }

                #[inline( always )] fn init_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<LazyStateID, MatchError>
                {
                    let sid = dfa.start_state_reverse(cache, input)?;
                    debug_assert!(!sid.is_match());
                    Ok(sid)
                }

                #[inline( always )] fn eoi_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    sid: &mut LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid =
                                dfa.next_state(cache, *sid, b).map_err(|_| gave_up(sp.end))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa
                                .next_eoi_state(cache, *sid)
                                .map_err(|_| gave_up(input.haystack().len()))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                            debug_assert!(!sid.is_quit());
                        }
                    }
                    Ok(())
                }

                #[inline( always )] fn eoi_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    sid: &mut LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa
                            .next_state(cache, *sid, byte)
                            .map_err(|_| gave_up(sp.start))?;
                        
                        if sid.is_match() {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if sid.is_quit() {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid =
                            dfa.next_eoi_state(cache, *sid).map_err(|_| gave_up(sp.start))?;
                        
                        if sid.is_match() {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                        debug_assert!(!sid.is_quit());
                    }
                    Ok(())
                }
                /// Re-compute the starting state that a DFA should be in after finding a
                #[inline( always )] fn prefilter_restart(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    at: usize,
                ) -> Result<LazyStateID, MatchError>
                {
                    let mut input = input.clone();
                    input.set_start(at);
                    init_fwd(dfa, cache, &input)
                }
                /// A convenience routine for constructing a "gave up" match error.
                #[inline( always )] fn gave_up(offset: usize) -> MatchError { MatchError::gave_up(offset) }
            }
        }

        pub mod meta
        {
            /*!
            Provides a regex matcher that composes several other regex matchers automatically. */
            use ::
            {
                *,
            };
            /*
            */            
            pub use self::
            {
                error::BuildError,
                regex::
                {
                    Builder, Cache, CapturesMatches, Config, FindMatches, Regex, Split,
                    SplitN,
                },
            };

            pub mod error
            {
                use ::
                {
                    regex::
                    {
                        automata::{ nfa, util::search::MatchError, PatternID },
                        syntax::{ ast, hir },
                    },
                    *,
                };
                /*
                */
                /// An error that occurs when construction of a `Regex` fails.
                #[derive(Clone, Debug)]
                pub struct BuildError 
                {
                    kind: BuildErrorKind,
                }

                #[derive(Clone, Debug)]
                enum BuildErrorKind
                {
                    Syntax { pid: PatternID, err: regex_syntax::Error },
                    NFA( nfa::thompson::BuildError ),
                }

                impl BuildError
                {
                    /// If it is known which pattern ID caused this build error to occur, then
                    pub fn pattern(&self) -> Option<PatternID> {
                        match self.kind {
                            BuildErrorKind::Syntax { pid, .. } => Some(pid),
                            _ => None,
                        }
                    }
                    /// If this error occurred because the regex exceeded the configured size
                    pub fn size_limit(&self) -> Option<usize> {
                        match self.kind {
                            BuildErrorKind::NFA(ref err) => err.size_limit(),
                            _ => None,
                        }
                    }
                    /// If this error corresponds to a syntax error, then a reference to it is
                    pub fn syntax_error(&self) -> Option<&regex_syntax::Error> {
                        match self.kind {
                            BuildErrorKind::Syntax { ref err, .. } => Some(err),
                            _ => None,
                        }
                    }

                    pub fn ast(pid: PatternID, err: ast::Error) -> BuildError {
                        let err = regex_syntax::Error::from(err);
                        BuildError { kind: BuildErrorKind::Syntax { pid, err } }
                    }

                    pub fn hir(pid: PatternID, err: hir::Error) -> BuildError {
                        let err = regex_syntax::Error::from(err);
                        BuildError { kind: BuildErrorKind::Syntax { pid, err } }
                    }

                    pub fn nfa(err: nfa::thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }
                }
                
                impl ::error::Error for BuildError
                {
                    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                        match self.kind {
                            BuildErrorKind::Syntax { ref err, .. } => Some(err),
                            BuildErrorKind::NFA(ref err) => Some(err),
                        }
                    }
                }

                impl ::fmt::Display for BuildError
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match self.kind {
                            BuildErrorKind::Syntax { pid, .. } => {
                                write!(f, "error parsing pattern {}", pid.as_usize())
                            }
                            BuildErrorKind::NFA(_) => write!(f, "error building NFA"),
                        }
                    }
                }
                /// An error that occurs when a search should be retried.
                #[derive(Debug)]
                pub enum RetryError
                {
                    Quadratic(RetryQuadraticError),
                    Fail(RetryFailError),
                }
                
                impl ::error::Error for RetryError {}

                impl ::fmt::Display for RetryError
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match *self {
                            RetryError::Quadratic(ref err) => err.fmt(f),
                            RetryError::Fail(ref err) => err.fmt(f),
                        }
                    }
                }

                impl From<MatchError> for RetryError
                {
                    fn from(merr: MatchError) -> RetryError {
                        RetryError::Fail(RetryFailError::from(merr))
                    }
                }
                /// An error that occurs when potential quadratic behavior has been detected
                #[derive(Debug)]
                pub struct RetryQuadraticError(());

                impl RetryQuadraticError
                {
                    pub fn new() -> RetryQuadraticError {
                        RetryQuadraticError(())
                    }
                }
                
                impl ::error::Error for RetryQuadraticError {}

                impl ::fmt::Display for RetryQuadraticError
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        write!(f, "regex engine gave up to avoid quadratic behavior")
                    }
                }

                impl From<RetryQuadraticError> for RetryError
                {
                    fn from(err: RetryQuadraticError) -> RetryError {
                        RetryError::Quadratic(err)
                    }
                }
                /// An error that occurs when a regex engine "gives up" for some reason before
                #[derive(Debug)]
                pub struct RetryFailError
                {
                    offset: usize,
                }

                impl RetryFailError
                {
                    pub fn from_offset(offset: usize) -> RetryFailError {
                        RetryFailError { offset }
                    }
                }
                
                impl ::error::Error for RetryFailError {}

                impl ::fmt::Display for RetryFailError
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        write!(f, "regex engine failed at offset {:?}", self.offset)
                    }
                }

                impl From<RetryFailError> for RetryError
                {
                    fn from(err: RetryFailError) -> RetryError {
                        RetryError::Fail(err)
                    }
                }

                impl From<MatchError> for RetryFailError
                {
                    fn from(merr: MatchError) -> RetryFailError
                    {
                        use regex::automata::util::search::MatchErrorKind::*;

                        match *merr.kind()
                        {
                            Quit { offset, .. } => RetryFailError::from_offset(offset),
                            GaveUp { offset } => RetryFailError::from_offset(offset),
                            HaystackTooLong { .. } | UnsupportedAnchored { .. } => {
                                unreachable!("found impossible error in meta engine: {merr}")
                            }
                        }
                    }
                }
            }

            pub mod limited
            {
                /*!
                This module defines two bespoke reverse DFA searching routines. */
                use ::
                {
                    regex::automata::
                    {
                        meta::error::{RetryError, RetryQuadraticError},
                        HalfMatch, Input, MatchError,
                    },
                    *,
                };
                /*
                */
                pub fn dfa_try_search_half_rev
                (
                    dfa: &::regex::automata::dfa::dense::DFA<Vec<u32>>,
                    input: &Input<'_>,
                    min_start: usize,
                ) -> Result<Option<HalfMatch>, RetryError> 
                {
                    use ::regex::automata::dfa::Automaton;

                    let mut mat = None;
                    let mut sid = dfa.start_state_reverse(input)?;
                    if input.start() == input.end() {
                        dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }
                    let mut at = input.end() - 1;
                    loop {
                        sid = dfa.next_state(sid, input.haystack()[at]);
                        
                        if dfa.is_special_state(sid) {
                            if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat);
                            } else if dfa.is_quit_state(sid) {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            }
                        }
                        
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                        
                        if at < min_start {
                            trace!(
                                "reached position {at} which is before the previous literal \
                                match, quitting to avoid quadratic behavior",
                            );
                            
                            return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                        }
                    }
                    let was_dead = dfa.is_dead_state(sid);
                    dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;
                    if at == input.start()
                        && mat.map_or(false, |m| m.offset() > input.start())
                        && !was_dead
                    {
                        trace!(
                            "reached beginning of search at offset {at} without hitting \
                            a dead state, quitting to avoid potential false positive match",
                        );
                        return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                    }
                    Ok(mat)
                }
                
                pub fn hybrid_try_search_half_rev
                (
                    dfa: &::regex::automata::hybrid::dfa::DFA,
                    cache: &mut ::regex::automata::hybrid::dfa::Cache,
                    input: &Input<'_>,
                    min_start: usize,
                ) -> Result<Option<HalfMatch>, RetryError>
                {
                    let mut mat = None;
                    let mut sid = dfa.start_state_reverse(cache, input)?;
                    if input.start() == input.end() {
                        hybrid_eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }
                    let mut at = input.end() - 1;
                    loop {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[at])
                            .map_err(|_| MatchError::gave_up(at))?;
                        
                        if sid.is_tagged()
                        {
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                            } else if sid.is_dead() {
                                return Ok(mat);
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            }
                        }
                        
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                        
                        if at < min_start {
                            trace!(
                                "reached position {at} which is before the previous literal \
                                match, quitting to avoid quadratic behavior",
                            );
                            
                            return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                        }
                    }
                    let was_dead = sid.is_dead();
                    hybrid_eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                    // See the comments in the full DFA routine above for why we need this.
                    if at == input.start()
                        && mat.map_or(false, |m| m.offset() > input.start())
                        && !was_dead
                    {
                        trace!(
                            "reached beginning of search at offset {at} without hitting \
                            a dead state, quitting to avoid potential false positive match",
                        );
                        return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                    }
                    Ok(mat)
                }

                #[inline( always )] fn dfa_eoi_rev
                (
                    dfa: &::regex::automata::dfa::dense::DFA<Vec<u32>>,
                    input: &Input<'_>,
                    sid: &mut ::regex::automata::util::primitives::StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    use ::regex::automata::dfa::Automaton;

                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa.next_state(*sid, byte);
                        
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if dfa.is_quit_state(*sid) {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid = dfa.next_eoi_state(*sid);
                        
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                        debug_assert!(!dfa.is_quit_state(*sid));
                    }
                    Ok(())
                }
                
                #[inline( always )] fn hybrid_eoi_rev
                (
                    dfa: &::regex::automata::hybrid::dfa::DFA,
                    cache: &mut ::regex::automata::hybrid::dfa::Cache,
                    input: &Input<'_>,
                    sid: &mut ::regex::automata::hybrid::LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    let sp = input.get_span();
                    if sp.start > 0
                    {
                        let byte = input.haystack()[sp.start - 1];
                        
                        *sid = dfa
                        .next_state(cache, *sid, byte)
                        .map_err(|_| MatchError::gave_up(sp.start))?;
                        
                        if sid.is_match()
                        {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        }

                        else if sid.is_quit() { return Err(MatchError::quit(byte, sp.start - 1)); }
                    }

                    else 
                    {
                        *sid = dfa
                        .next_eoi_state(cache, *sid)
                        .map_err(|_| MatchError::gave_up(sp.start))?;
                        
                        if sid.is_match() 
                        {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }

                        debug_assert!(!sid.is_quit());
                    }

                    Ok(())
                }
            }

            pub mod literal
            {
                use ::
                {
                    *,
                };
                /*
                use ::{vec, vec::Vec};

                use regex_syntax::hir::Hir;

                use crate::{meta::regex::RegexInfo, util::search::MatchKind};
                */
                /// Pull out an alternation of literals from the given sequence of HIR
                pub fn alternation_literals(
                    info: &RegexInfo,
                    hirs: &[&Hir],
                ) -> Option<Vec<Vec<u8>>> {
                    use regex_syntax::hir::{HirKind, Literal};
                    if !cfg!(feature = "perf-literal-multisubstring") {
                        return None;
                    }
                    if hirs.len() != 1
                        || !info.props()[0].look_set().is_empty()
                        || info.props()[0].explicit_captures_len() > 0
                        || !info.props()[0].is_alternation_literal()
                        || info.config().get_match_kind() != MatchKind::LeftmostFirst
                    {
                        return None;
                    }
                    let hir = &hirs[0];
                    let alts = match *hir.kind() {
                        HirKind::Alternation(ref alts) => alts,
                        _ => return None, // one literal isn't worth it
                    };

                    let mut lits = vec![];
                    
                    for alt in alts {
                        let mut lit = vec![];
                        match *alt.kind() {
                            HirKind::Literal(Literal(ref bytes)) => {
                                lit.extend_from_slice(bytes)
                            }
                            HirKind::Concat(ref exprs) => {
                                for e in exprs {
                                    match *e.kind() {
                                        HirKind::Literal(Literal(ref bytes)) => {
                                            lit.extend_from_slice(bytes);
                                        }
                                        _ => unreachable!("expected literal, got {e:?}"),
                                    }
                                }
                            }
                            _ => unreachable!("expected literal or concat, got {alt:?}"),
                        }
                        lits.push(lit);
                    }
                    if lits.len() < 3000 {
                        debug!("skipping Aho-Corasick because there are too few literals");
                        return None;
                    }
                    Some(lits)
                }
            }

            pub mod regex
            {
                use ::
                {
                    *,
                };
                /*
                use ::{
                    borrow::Borrow,
                    panic::{RefUnwindSafe, UnwindSafe},
                };

                use ::{boxed::Box, sync::Arc, vec, vec::Vec};

                use regex_syntax::{
                    ast,
                    hir::{self, Hir},
                };

                use crate::{
                    meta::{
                        error::BuildError,
                        strategy::{self, Strategy},
                        wrappers,
                    },
                    nfa::thompson::WhichCaptures,
                    util::{
                        captures::{Captures, GroupInfo},
                        iter,
                        pool::{Pool, PoolGuard},
                        prefilter::Prefilter,
                        primitives::{NonMaxUsize, PatternID},
                        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},
                    },
                };

                */
                /// A type alias for our pool of meta::Cache that fixes the type parameters to
                type CachePool = Pool<Cache, CachePoolFn>;
                /// Same as above, but for the guard returned by a pool.
                type CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;
                /// The type of the closure we use to create new caches. We need to spell out
                type CachePoolFn =
                    Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;
                /// A regex matcher that works by composing several other regex matchers
                #[derive(Debug)]
                pub struct Regex
                {
                    /// The actual regex implementation.
                    imp: Arc<RegexI>,
                    /// A thread safe pool of caches.
                    pool: CachePool,
                }
                /// The internal implementation of `Regex`, split out so that it can be wrapped
                #[derive(Debug)]
                struct RegexI
                {
                    /// The core matching engine.
                    strat: Arc<dyn Strategy>,
                    /// Metadata about the regexes driving the strategy. The metadata is also
                    info: RegexInfo,
                }
                /// Convenience constructors for a `Regex` using the default configuration.
                impl Regex
                {
                    /// Builds a `Regex` from a single pattern string using the default
                    pub fn new(pattern: &str) -> Result<Regex, BuildError> {
                        Regex::builder().build(pattern)
                    }
                    /// Builds a `Regex` from many pattern strings using the default
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        Regex::builder().build_many(patterns)
                    }
                    /// Return a default configuration for a `Regex`.
                    pub fn config() -> Config {
                        Config::new()
                    }
                    /// Return a builder for configuring the construction of a `Regex`.
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                }
                /// High level convenience routines for using a regex to search a haystack.
                impl Regex
                {
                    /// Returns true if and only if this regex matches the given haystack.
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(&self, input: I) -> bool {
                        let input = input.into().earliest(true);
                        
                        if self.imp.info.is_impossible(&input) {
                            return false;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.is_match(&mut guard, &input);
                        // See 'Regex::search' for why we put the guard back explicitly.
                        PoolGuard::put(guard);
                        result
                    }
                    /// Executes a leftmost search and returns the first match that is found,
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(&self, input: I) -> Option<Match> {
                        self.search(&input.into())
                    }
                    /// Executes a leftmost forward search and writes the spans of capturing
                    #[inline] pub fn captures<'h, I: Into<Input<'h>>>(
                        &self,
                        input: I,
                        caps: &mut Captures,
                    ) {
                        self.search_captures(&input.into(), caps)
                    }
                    /// Returns an iterator over all non-overlapping leftmost matches in
                    #[inline] pub fn find_iter<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> FindMatches<'r, 'h> {
                        let cache = self.pool.get();
                        let it = iter::Searcher::new(input.into());
                        FindMatches { re: self, cache, it }
                    }
                    /// Returns an iterator over all non-overlapping `Captures` values. If no
                    #[inline] pub fn captures_iter<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> CapturesMatches<'r, 'h> {
                        let cache = self.pool.get();
                        let caps = self.create_captures();
                        let it = iter::Searcher::new(input.into());
                        CapturesMatches { re: self, cache, caps, it }
                    }
                    /// Returns an iterator of spans of the haystack given, delimited by a
                    #[inline] pub fn split<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> Split<'r, 'h> {
                        Split { finder: self.find_iter(input), last: 0 }
                    }
                    /// Returns an iterator of at most `limit` spans of the haystack given,
                    pub fn splitn<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                        limit: usize,
                    ) -> SplitN<'r, 'h> {
                        SplitN { splits: self.split(input), limit }
                    }
                }
                /// Lower level search routines that give more control.
                impl Regex
                {
                    /// Returns the start and end offset of the leftmost match. If no match
                    #[inline] pub fn search(&self, input: &Input<'_>) -> Option<Match> {
                        if self.imp.info.is_impossible(input) {
                            return None;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.search(&mut guard, input);
                        PoolGuard::put(guard);
                        result
                    }
                    /// Returns the end offset of the leftmost match. If no match exists, then
                    #[inline] pub fn search_half(&self, input: &Input<'_>) -> Option<HalfMatch> {
                        if self.imp.info.is_impossible(input) {
                            return None;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.search_half(&mut guard, input);
                        // See 'Regex::search' for why we put the guard back explicitly.
                        PoolGuard::put(guard);
                        result
                    }
                    /// Executes a leftmost forward search and writes the spans of capturing
                    #[inline] pub fn search_captures(&self, input: &Input<'_>, caps: &mut Captures) {
                        caps.set_pattern(None);
                        let pid = self.search_slots(input, caps.slots_mut());
                        caps.set_pattern(pid);
                    }
                    /// Executes a leftmost forward search and writes the spans of capturing
                    #[inline] pub fn search_slots(
                        &self,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if self.imp.info.is_impossible(input) {
                            return None;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.search_slots(&mut guard, input, slots);
                        // See 'Regex::search' for why we put the guard back explicitly.
                        PoolGuard::put(guard);
                        result
                    }
                    /// Writes the set of patterns that match anywhere in the given search
                    #[inline] pub fn which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if self.imp.info.is_impossible(input) {
                            return;
                        }
                        let mut guard = self.pool.get();
                        let result = self
                            .imp
                            .strat
                            .which_overlapping_matches(&mut guard, input, patset);
                        // See 'Regex::search' for why we put the guard back explicitly.
                        PoolGuard::put(guard);
                        result
                    }
                }
                /// Lower level search routines that give more control, and require the caller
                impl Regex
                {
                    /// This is like [`Regex::search`], but requires the caller to
                    #[inline] pub fn search_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<Match> {
                        if self.imp.info.is_impossible(input) {
                            return None;
                        }
                        self.imp.strat.search(cache, input)
                    }
                    /// This is like [`Regex::search_half`], but requires the caller to
                    #[inline] pub fn search_half_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if self.imp.info.is_impossible(input) {
                            return None;
                        }
                        self.imp.strat.search_half(cache, input)
                    }
                    /// This is like [`Regex::search_captures`], but requires the caller to
                    #[inline] pub fn search_captures_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        caps: &mut Captures,
                    ) {
                        caps.set_pattern(None);
                        let pid = self.search_slots_with(cache, input, caps.slots_mut());
                        caps.set_pattern(pid);
                    }
                    /// This is like [`Regex::search_slots`], but requires the caller to
                    #[inline] pub fn search_slots_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if self.imp.info.is_impossible(input) {
                            return None;
                        }
                        self.imp.strat.search_slots(cache, input, slots)
                    }
                    /// This is like [`Regex::which_overlapping_matches`], but requires the
                    #[inline] pub fn which_overlapping_matches_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if self.imp.info.is_impossible(input) {
                            return;
                        }
                        self.imp.strat.which_overlapping_matches(cache, input, patset)
                    }
                }
                /// Various non-search routines for querying properties of a `Regex` and
                impl Regex
                {
                    /// Creates a new object for recording capture group offsets. This is used
                    pub fn create_captures(&self) -> Captures {
                        Captures::all(self.group_info().clone())
                    }
                    /// Creates a new cache for use with lower level search APIs like
                    pub fn create_cache(&self) -> Cache {
                        self.imp.strat.create_cache()
                    }
                    /// Returns the total number of patterns in this regex.
                    pub fn pattern_len(&self) -> usize {
                        self.imp.info.pattern_len()
                    }
                    /// Returns the total number of capturing groups.
                    pub fn captures_len(&self) -> usize {
                        self.imp
                            .info
                            .props_union()
                            .explicit_captures_len()
                            .saturating_add(self.pattern_len())
                    }
                    /// Returns the total number of capturing groups that appear in every
                    #[inline] pub fn static_captures_len(&self) -> Option<usize> {
                        self.imp
                            .info
                            .props_union()
                            .static_explicit_captures_len()
                            .map(|len| len.saturating_add(1))
                    }
                    /// Return information about the capture groups in this `Regex`.
                    #[inline] pub fn group_info(&self) -> &GroupInfo {
                        self.imp.strat.group_info()
                    }
                    /// Returns the configuration object used to build this `Regex`.
                    #[inline] pub fn get_config(&self) -> &Config {
                        self.imp.info.config()
                    }
                    /// Returns true if this regex has a high chance of being "accelerated."
                    #[inline] pub fn is_accelerated(&self) -> bool {
                        self.imp.strat.is_accelerated()
                    }
                    /// Return the total approximate heap memory, in bytes, used by this `Regex`.
                    #[inline] pub fn memory_usage(&self) -> usize {
                        self.imp.strat.memory_usage()
                    }
                }

                impl Clone for Regex {
                    fn clone(&self) -> Regex {
                        let imp = Arc::clone(&self.imp);
                        let pool = {
                            let strat = Arc::clone(&imp.strat);
                            let create: CachePoolFn = Box::new(move || strat.create_cache());
                            Pool::new(create)
                        };
                        Regex { imp, pool }
                    }
                }

                #[derive(Clone, Debug)]
                pub struct RegexInfo(Arc<RegexInfoI>);

                #[derive(Clone, Debug)]
                struct RegexInfoI {
                    config: Config,
                    props: Vec<hir::Properties>,
                    props_union: hir::Properties,
                }

                impl RegexInfo {
                    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {
                        let mut props = vec![];
                        for hir in hirs.iter() {
                            props.push(hir.properties().clone());
                        }
                        let props_union = hir::Properties::union(&props);

                        RegexInfo(Arc::new(RegexInfoI { config, props, props_union }))
                    }

                    pub fn config(&self) -> &Config {
                        &self.0.config
                    }

                    pub fn props(&self) -> &[hir::Properties] {
                        &self.0.props
                    }

                    pub fn props_union(&self) -> &hir::Properties {
                        &self.0.props_union
                    }

                    pub fn pattern_len(&self) -> usize {
                        self.props().len()
                    }

                    pub fn memory_usage(&self) -> usize {
                        self.props().iter().map(|p| p.memory_usage()).sum::<usize>()
                            + self.props_union().memory_usage()
                    }
                    /// Returns true when the search is guaranteed to be anchored. That is,
                    #[inline( always )]
                    pub fn is_anchored_start(&self, input: &Input<'_>) -> bool {
                        input.get_anchored().is_anchored() || self.is_always_anchored_start()
                    }
                    /// Returns true when this regex is always anchored to the start of a
                    #[inline( always )]
                    pub fn is_always_anchored_start(&self) -> bool {
                        use regex_syntax::hir::Look;
                        self.props_union().look_set_prefix().contains(Look::Start)
                    }
                    /// Returns true when this regex is always anchored to the end of a
                    #[inline( always )]
                    pub fn is_always_anchored_end(&self) -> bool {
                        use regex_syntax::hir::Look;
                        self.props_union().look_set_suffix().contains(Look::End)
                    }
                    /// Returns true if and only if it is known that a match is impossible
                    #[inline( always )]
                    fn is_impossible(&self, input: &Input<'_>) -> bool {
                        if input.start() > 0 && self.is_always_anchored_start() {
                            return true;
                        }
                        // Same idea, but for the end anchor.
                        if input.end() < input.haystack().len()
                            && self.is_always_anchored_end()
                        {
                            return true;
                        }
                        let minlen = match self.props_union().minimum_len() {
                            None => return false,
                            Some(minlen) => minlen,
                        };
                        
                        if input.get_span().len() < minlen {
                            return true;
                        }
                        
                        if self.is_anchored_start(input) && self.is_always_anchored_end() {
                            let maxlen = match self.props_union().maximum_len() {
                                None => return false,
                                Some(maxlen) => maxlen,
                            };
                            if input.get_span().len() > maxlen {
                                return true;
                            }
                        }
                        false
                    }
                }
                /// An iterator over all non-overlapping matches.
                #[derive(Debug)]
                pub struct FindMatches<'r, 'h> {
                    re: &'r Regex,
                    cache: CachePoolGuard<'r>,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'h> FindMatches<'r, 'h>
                {
                    /// Returns the `Regex` value that created this iterator.
                    #[inline] pub fn regex(&self) -> &'r Regex {
                        self.re
                    }
                    /// Returns the current `Input` associated with this iterator.
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> {
                        self.it.input()
                    }
                }

                impl<'r, 'h> Iterator for FindMatches<'r, 'h> {
                    type Item = Match;

                    #[inline]
                    fn next(&mut self) -> Option<Match> {
                        let FindMatches { re, ref mut cache, ref mut it } = *self;
                        it.advance(|input| Ok(re.search_with(cache, input)))
                    }

                    #[inline]
                    fn count(self) -> usize {
                        let FindMatches { re, mut cache, it } = self;
                        // This does the deref for PoolGuard once instead of every iter.
                        let cache = &mut *cache;
                        it.into_half_matches_iter(
                            |input| Ok(re.search_half_with(cache, input)),
                        )
                        .count()
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for FindMatches<'r, 'h> {}
                /// An iterator over all non-overlapping leftmost matches with their capturing
                #[derive(Debug)]
                pub struct CapturesMatches<'r, 'h> {
                    re: &'r Regex,
                    cache: CachePoolGuard<'r>,
                    caps: Captures,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'h> CapturesMatches<'r, 'h>
                {
                    /// Returns the `Regex` value that created this iterator.
                    #[inline] pub fn regex(&self) -> &'r Regex {
                        self.re
                    }
                    /// Returns the current `Input` associated with this iterator.
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> {
                        self.it.input()
                    }
                }

                impl<'r, 'h> Iterator for CapturesMatches<'r, 'h> {
                    type Item = Captures;

                    #[inline]
                    fn next(&mut self) -> Option<Captures> {
                        // Splitting 'self' apart seems necessary to appease borrowck.
                        let CapturesMatches { re, ref mut cache, ref mut caps, ref mut it } =
                            *self;
                        let _ = it.advance(|input| {
                            re.search_captures_with(cache, input, caps);
                            Ok(caps.get_match())
                        });
                        
                        if caps.is_match() {
                            Some(caps.clone())
                        } else {
                            None
                        }
                    }

                    #[inline]
                    fn count(self) -> usize {
                        let CapturesMatches { re, mut cache, it, .. } = self;
                        // This does the deref for PoolGuard once instead of every iter.
                        let cache = &mut *cache;
                        it.into_half_matches_iter(
                            |input| Ok(re.search_half_with(cache, input)),
                        )
                        .count()
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for CapturesMatches<'r, 'h> {}
                /// Yields all substrings delimited by a regular expression match.
                #[derive(Debug)]
                pub struct Split<'r, 'h> {
                    finder: FindMatches<'r, 'h>,
                    last: usize,
                }

                impl<'r, 'h> Split<'r, 'h>
                {
                    /// Returns the current `Input` associated with this iterator.
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> {
                        self.finder.input()
                    }
                }

                impl<'r, 'h> Iterator for Split<'r, 'h> {
                    type Item = Span;

                    fn next(&mut self) -> Option<Span> {
                        match self.finder.next() {
                            None => {
                                let len = self.finder.it.input().haystack().len();
                                
                                if self.last > len {
                                    None
                                } else {
                                    let span = Span::from(self.last..len);
                                    self.last = len + 1; // Next call will return None
                                    Some(span)
                                }
                            }
                            Some(m) => {
                                let span = Span::from(self.last..m.start());
                                self.last = m.end();
                                Some(span)
                            }
                        }
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}
                /// Yields at most `N` spans delimited by a regular expression match.
                #[derive(Debug)]
                pub struct SplitN<'r, 'h> {
                    splits: Split<'r, 'h>,
                    limit: usize,
                }

                impl<'r, 'h> SplitN<'r, 'h>
                {
                    /// Returns the current `Input` associated with this iterator.
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> {
                        self.splits.input()
                    }
                }

                impl<'r, 'h> Iterator for SplitN<'r, 'h> {
                    type Item = Span;

                    fn next(&mut self) -> Option<Span> {
                        if self.limit == 0 {
                            return None;
                        }

                        self.limit -= 1;
                        
                        if self.limit > 0 {
                            return self.splits.next();
                        }

                        let len = self.splits.finder.it.input().haystack().len();
                        
                        if self.splits.last > len {
                            // We've already returned all substrings.
                            None
                        } else {
                            // self.n == 0, so future calls will return None immediately
                            Some(Span::from(self.splits.last..len))
                        }
                    }

                    fn size_hint(&self) -> (usize, Option<usize>) {
                        (0, Some(self.limit))
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}
                /// Represents mutable scratch space used by regex engines during a search.
                #[derive(Debug, Clone)]
                pub struct Cache {
                    pub capmatches: Captures,
                    pub pikevm: wrappers::PikeVMCache,
                    pub backtrack: wrappers::BoundedBacktrackerCache,
                    pub onepass: wrappers::OnePassCache,
                    pub hybrid: wrappers::HybridCache,
                    pub revhybrid: wrappers::ReverseHybridCache,
                }

                impl Cache
                {
                    /// Creates a new `Cache` for use with this regex.
                    pub fn new(re: &Regex) -> Cache {
                        re.create_cache()
                    }
                    /// Reset this cache such that it can be used for searching with the given
                    pub fn reset(&mut self, re: &Regex) {
                        re.imp.strat.reset_cache(self)
                    }
                    /// Returns the heap memory usage, in bytes, of this cache.
                    pub fn memory_usage(&self) -> usize {
                        let mut bytes = 0;
                        bytes += self.pikevm.memory_usage();
                        bytes += self.backtrack.memory_usage();
                        bytes += self.onepass.memory_usage();
                        bytes += self.hybrid.memory_usage();
                        bytes += self.revhybrid.memory_usage();
                        bytes
                    }
                }
                /// An object describing the configuration of a `Regex`.
                #[derive(Clone, Debug, Default)]
                pub struct Config {
                    match_kind: Option<MatchKind>,
                    utf8_empty: Option<bool>,
                    autopre: Option<bool>,
                    pre: Option<Option<Prefilter>>,
                    which_captures: Option<WhichCaptures>,
                    nfa_size_limit: Option<Option<usize>>,
                    onepass_size_limit: Option<Option<usize>>,
                    hybrid_cache_capacity: Option<usize>,
                    hybrid: Option<bool>,
                    dfa: Option<bool>,
                    dfa_size_limit: Option<Option<usize>>,
                    dfa_state_limit: Option<Option<usize>>,
                    onepass: Option<bool>,
                    backtrack: Option<bool>,
                    byte_classes: Option<bool>,
                    line_terminator: Option<u8>,
                }

                impl Config
                {
                    /// Create a new configuration object for a `Regex`.
                    pub fn new() -> Config {
                        Config::default()
                    }
                    /// Set the match semantics for a `Regex`.
                    pub fn match_kind(self, kind: MatchKind) -> Config {
                        Config { match_kind: Some(kind), ..self }
                    }
                    /// Toggles whether empty matches are permitted to occur between the code
                    pub fn utf8_empty(self, yes: bool) -> Config {
                        Config { utf8_empty: Some(yes), ..self }
                    }
                    /// Toggles whether automatic prefilter support is enabled.
                    pub fn auto_prefilter(self, yes: bool) -> Config {
                        Config { autopre: Some(yes), ..self }
                    }
                    /// Overrides and sets the prefilter to use inside a `Regex`.
                    pub fn prefilter(self, pre: Option<Prefilter>) -> Config {
                        Config { pre: Some(pre), ..self }
                    }
                    /// Configures what kinds of groups are compiled as "capturing" in the
                    pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {
                        self.which_captures = Some(which_captures);
                        self
                    }
                    /// Sets the size limit, in bytes, to enforce on the construction of every
                    pub fn nfa_size_limit(self, limit: Option<usize>) -> Config {
                        Config { nfa_size_limit: Some(limit), ..self }
                    }
                    /// Sets the size limit, in bytes, for the one-pass DFA.
                    pub fn onepass_size_limit(self, limit: Option<usize>) -> Config {
                        Config { onepass_size_limit: Some(limit), ..self }
                    }
                    /// Set the cache capacity, in bytes, for the lazy DFA.
                    pub fn hybrid_cache_capacity(self, limit: usize) -> Config {
                        Config { hybrid_cache_capacity: Some(limit), ..self }
                    }
                    /// Sets the size limit, in bytes, for heap memory used for a fully
                    pub fn dfa_size_limit(self, limit: Option<usize>) -> Config {
                        Config { dfa_size_limit: Some(limit), ..self }
                    }
                    /// Sets a limit on the total number of NFA states, beyond which, a full
                    pub fn dfa_state_limit(self, limit: Option<usize>) -> Config {
                        Config { dfa_state_limit: Some(limit), ..self }
                    }
                    /// Whether to attempt to shrink the size of the alphabet for the regex
                    pub fn byte_classes(self, yes: bool) -> Config {
                        Config { byte_classes: Some(yes), ..self }
                    }
                    /// Set the line terminator to be used by the `^` and `$` anchors in
                    pub fn line_terminator(self, byte: u8) -> Config {
                        Config { line_terminator: Some(byte), ..self }
                    }
                    /// Toggle whether the hybrid NFA/DFA (also known as the "lazy DFA") should
                    pub fn hybrid(self, yes: bool) -> Config {
                        Config { hybrid: Some(yes), ..self }
                    }
                    /// Toggle whether a fully compiled DFA should be available for use by the
                    pub fn dfa(self, yes: bool) -> Config {
                        Config { dfa: Some(yes), ..self }
                    }
                    /// Toggle whether a one-pass DFA should be available for use by the meta
                    pub fn onepass(self, yes: bool) -> Config {
                        Config { onepass: Some(yes), ..self }
                    }
                    /// Toggle whether a bounded backtracking regex engine should be available
                    pub fn backtrack(self, yes: bool) -> Config {
                        Config { backtrack: Some(yes), ..self }
                    }
                    /// Returns the match kind on this configuration, as set by
                    pub fn get_match_kind(&self) -> MatchKind {
                        self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
                    }
                    /// Returns whether empty matches must fall on valid UTF-8 boundaries, as
                    pub fn get_utf8_empty(&self) -> bool {
                        self.utf8_empty.unwrap_or(true)
                    }
                    /// Returns whether automatic prefilters are enabled, as set by
                    pub fn get_auto_prefilter(&self) -> bool {
                        self.autopre.unwrap_or(true)
                    }
                    /// Returns a manually set prefilter, if one was set by
                    pub fn get_prefilter(&self) -> Option<&Prefilter> {
                        self.pre.as_ref().unwrap_or(&None).as_ref()
                    }
                    /// Returns the capture configuration, as set by
                    pub fn get_which_captures(&self) -> WhichCaptures {
                        self.which_captures.unwrap_or(WhichCaptures::All)
                    }
                    /// Returns NFA size limit, as set by [`Config::nfa_size_limit`].
                    pub fn get_nfa_size_limit(&self) -> Option<usize> {
                        self.nfa_size_limit.unwrap_or(Some(10 * (1 << 20)))
                    }
                    /// Returns one-pass DFA size limit, as set by
                    pub fn get_onepass_size_limit(&self) -> Option<usize> {
                        self.onepass_size_limit.unwrap_or(Some(1 * (1 << 20)))
                    }
                    /// Returns hybrid NFA/DFA cache capacity, as set by
                    pub fn get_hybrid_cache_capacity(&self) -> usize {
                        self.hybrid_cache_capacity.unwrap_or(2 * (1 << 20))
                    }
                    /// Returns DFA size limit, as set by [`Config::dfa_size_limit`].
                    pub fn get_dfa_size_limit(&self) -> Option<usize> {
                        self.dfa_size_limit.unwrap_or(Some(40 * (1 << 10)))
                    }
                    /// Returns DFA size limit in terms of the number of states in the NFA, as
                    pub fn get_dfa_state_limit(&self) -> Option<usize> {
                        // Again, as with the size limit, we keep this very small.
                        self.dfa_state_limit.unwrap_or(Some(30))
                    }
                    /// Returns whether byte classes are enabled, as set by
                    pub fn get_byte_classes(&self) -> bool {
                        self.byte_classes.unwrap_or(true)
                    }
                    /// Returns the line terminator for this configuration, as set by
                    pub fn get_line_terminator(&self) -> u8 {
                        self.line_terminator.unwrap_or(b'\n')
                    }
                    /// Returns whether the hybrid NFA/DFA regex engine may be used, as set by
                    pub fn get_hybrid(&self) -> bool {
                        #[cfg(feature = "hybrid")]
                        {
                            self.hybrid.unwrap_or(true)
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            false
                        }
                    }
                    /// Returns whether the DFA regex engine may be used, as set by
                    pub fn get_dfa(&self) -> bool {
                                {
                            self.dfa.unwrap_or(true)
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            false
                        }
                    }
                    /// Returns whether the one-pass DFA regex engine may be used, as set by
                    pub fn get_onepass(&self) -> bool {
                                {
                            self.onepass.unwrap_or(true)
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            false
                        }
                    }
                    /// Returns whether the bounded backtracking regex engine may be used, as
                    pub fn get_backtrack(&self) -> bool {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            self.backtrack.unwrap_or(true)
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            false
                        }
                    }
                    /// Overwrite the default configuration such that the options in `o` are
                    pub fn overwrite(&self, o: Config) -> Config {
                        Config {
                            match_kind: o.match_kind.or(self.match_kind),
                            utf8_empty: o.utf8_empty.or(self.utf8_empty),
                            autopre: o.autopre.or(self.autopre),
                            pre: o.pre.or_else(|| self.pre.clone()),
                            which_captures: o.which_captures.or(self.which_captures),
                            nfa_size_limit: o.nfa_size_limit.or(self.nfa_size_limit),
                            onepass_size_limit: o
                                .onepass_size_limit
                                .or(self.onepass_size_limit),
                            hybrid_cache_capacity: o
                                .hybrid_cache_capacity
                                .or(self.hybrid_cache_capacity),
                            hybrid: o.hybrid.or(self.hybrid),
                            dfa: o.dfa.or(self.dfa),
                            dfa_size_limit: o.dfa_size_limit.or(self.dfa_size_limit),
                            dfa_state_limit: o.dfa_state_limit.or(self.dfa_state_limit),
                            onepass: o.onepass.or(self.onepass),
                            backtrack: o.backtrack.or(self.backtrack),
                            byte_classes: o.byte_classes.or(self.byte_classes),
                            line_terminator: o.line_terminator.or(self.line_terminator),
                        }
                    }
                }
                /// A builder for configuring and constructing a `Regex`.
                #[derive(Clone, Debug)]
                pub struct Builder {
                    config: Config,
                    ast: ast::parse::ParserBuilder,
                    hir: hir::translate::TranslatorBuilder,
                }

                impl Builder
                {
                    /// Creates a new builder for configuring and constructing a [`Regex`].
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                            ast: ast::parse::ParserBuilder::new(),
                            hir: hir::translate::TranslatorBuilder::new(),
                        }
                    }
                    /// Builds a `Regex` from a single pattern string.
                    pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> {
                        self.build_many(&[pattern])
                    }
                    /// Builds a `Regex` from many pattern strings.
                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        use crate::util::primitives::IteratorIndexExt;
                        for (pid, p) in patterns.iter().with_pattern_ids() {
                                let p = p.as_ref();
                                let maxoff = p
                                    .char_indices()
                                    .map(|(i, ch)| i + ch.len_utf8())
                                    .take(1000)
                                    .last()
                                    .unwrap_or(0);
                                /*if maxoff < p.len() {
                                    debug!("{pid:?}: {}[... snip ...]", &p[..maxoff]);
                                } else {
                                    debug!("{pid:?}: {p}");
                                } */
                            }
                        let (mut asts, mut hirs) = (vec![], vec![]);
                        for (pid, p) in patterns.iter().with_pattern_ids() {
                            let ast = self
                                .ast
                                .build()
                                .parse(p.as_ref())
                                .map_err(|err| BuildError::ast(pid, err))?;
                            asts.push(ast);
                        }
                        for ((pid, p), ast) in
                            patterns.iter().with_pattern_ids().zip(asts.iter())
                        {
                            let hir = self
                                .hir
                                .build()
                                .translate(p.as_ref(), ast)
                                .map_err(|err| BuildError::hir(pid, err))?;
                            hirs.push(hir);
                        }
                        self.build_many_from_hir(&hirs)
                    }
                    /// Builds a `Regex` directly from an `Hir` expression.
                    pub fn build_from_hir(&self, hir: &Hir) -> Result<Regex, BuildError> {
                        self.build_many_from_hir(&[hir])
                    }
                    /// Builds a `Regex` directly from many `Hir` expressions.
                    pub fn build_many_from_hir<H: Borrow<Hir>>(
                        &self,
                        hirs: &[H],
                    ) -> Result<Regex, BuildError> {
                        let config = self.config.clone();
                        let hirs: Vec<&Hir> = hirs.iter().map(|hir| hir.borrow()).collect();
                        let info = RegexInfo::new(config, &hirs);
                        let strat = strategy::new(&info, &hirs)?;
                        let pool = {
                            let strat = Arc::clone(&strat);
                            let create: CachePoolFn = Box::new(move || strat.create_cache());
                            Pool::new(create)
                        };
                        Ok(Regex { imp: Arc::new(RegexI { strat, info }), pool })
                    }
                    /// Configure the behavior of a `Regex`.
                    pub fn configure(&mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }
                    /// Configure the syntax options when parsing a pattern string while
                    pub fn syntax
                    (
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        config.apply_ast(&mut self.ast);
                        config.apply_hir(&mut self.hir);
                        self
                    }
                }
            }

            pub mod reverse_inner
            {
                /*!
                A module dedicated to plucking inner literals out of a regex pattern, and then constructing a prefilter for them. */
                use ::
                {
                    *,
                };
                /*
                use ::vec::Vec;

                use regex_syntax::hir::{self, literal, Hir, HirKind};

                use crate::{util::prefilter::Prefilter, MatchKind};
                */
                /// Attempts to extract an "inner" prefilter from the given HIR expressions. If
                pub fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {
                    if hirs.len() != 1 {
                        debug!(
                            "skipping reverse inner optimization since it only \
                            supports 1 pattern, {} were given",
                            hirs.len(),
                        );
                        return None;
                    }
                    let mut concat = match top_concat(hirs[0]) {
                        Some(concat) => concat,
                        None => {
                            debug!(
                                "skipping reverse inner optimization because a top-level \
                                concatenation could not found",
                            );
                            
                            return None;
                        }
                    };
                    
                    for i in 1..concat.len() {
                        let hir = &concat[i];
                        let pre = match prefilter(hir) {
                            None => continue,
                            Some(pre) => pre,
                        };
                        
                        if !pre.is_fast() {
                            debug!(
                                "skipping extracted inner prefilter because \
                                it probably isn't fast"
                            );
                            continue;
                        }
                        let concat_suffix = Hir::concat(concat.split_off(i));
                        let concat_prefix = Hir::concat(concat);
                        let pre2 = match prefilter(&concat_suffix) {
                            None => pre,
                            Some(pre2) => {
                                if pre2.is_fast() {
                                    pre2
                                } else {
                                    pre
                                }
                            }
                        };
                        return Some((concat_prefix, pre2));
                    }
                    debug!(
                        "skipping reverse inner optimization because a top-level \
                        sub-expression with a fast prefilter could not be found"
                    );
                    None
                }
                /// Attempt to extract a prefilter from an HIR expression.
                fn prefilter(hir: &Hir) -> Option<Prefilter>
                {
                    let mut extractor = literal::Extractor::new();
                    extractor.kind(literal::ExtractKind::Prefix);
                    let mut prefixes = extractor.extract(hir);
                    debug!(
                        "inner prefixes (len={:?}) extracted before optimization: {:?}",
                        prefixes.len(),
                        prefixes
                    );
                    prefixes.make_inexact();
                    prefixes.optimize_for_prefix_by_preference();
                    debug!(
                        "inner prefixes (len={:?}) extracted after optimization: {:?}",
                        prefixes.len(),
                        prefixes
                    );
                    prefixes
                        .literals()
                        .and_then(|lits| Prefilter::new(MatchKind::LeftmostFirst, lits))
                }
                /// Looks for a "top level" HirKind::Concat item in the given HIR. This will
                fn top_concat(mut hir: &Hir) -> Option<Vec<Hir>> {
                    loop {
                        hir = match hir.kind() {
                            HirKind::Empty
                            | HirKind::Literal(_)
                            | HirKind::Class(_)
                            | HirKind::Look(_)
                            | HirKind::Repetition(_)
                            | HirKind::Alternation(_) => return None,
                            HirKind::Capture(hir::Capture { ref sub, .. }) => sub,
                            HirKind::Concat(ref subs) => {
                                let concat =
                                    Hir::concat(subs.iter().map(|h| flatten(h)).collect());
                                return match concat.into_kind() {
                                    HirKind::Concat(xs) => Some(xs),
                                    _ => return None,
                                };
                            }
                        };
                    }
                }
                /// Returns a copy of the given HIR but with all capturing groups removed.
                fn flatten(hir: &Hir) -> Hir {
                    match hir.kind() {
                        HirKind::Empty => Hir::empty(),
                        HirKind::Literal(hir::Literal(ref x)) => Hir::literal(x.clone()),
                        HirKind::Class(ref x) => Hir::class(x.clone()),
                        HirKind::Look(ref x) => Hir::look(x.clone()),
                        HirKind::Repetition(ref x) => Hir::repetition(x.with(flatten(&x.sub))),
                        HirKind::Capture(hir::Capture { ref sub, .. }) => flatten(sub),
                        HirKind::Alternation(ref xs) => {
                            Hir::alternation(xs.iter().map(|x| flatten(x)).collect())
                        }
                        HirKind::Concat(ref xs) => {
                            Hir::concat(xs.iter().map(|x| flatten(x)).collect())
                        }
                    }
                }
            }

            pub mod stopat
            {
                /*!
                This module defines two bespoke forward DFA search routines. One for the lazy
                DFA and one for the fully compiled DFA. */
                use ::
                {
                    *,
                };
                /*
                use crate::{meta::error::RetryFailError, HalfMatch, Input, MatchError};
                */
                pub fn dfa_try_search_half_fwd(
                    dfa: &crate::dfa::dense::DFA<Vec<u32>>,
                    input: &Input<'_>,
                ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                    use crate::dfa::{accel, Automaton};

                    let mut mat = None;
                    let mut sid = dfa.start_state_forward(input)?;
                    let mut at = input.start();
                    
                    while at < input.end() {
                        sid = dfa.next_state(sid, input.haystack()[at]);
                        
                        if dfa.is_special_state(sid) {
                            if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                
                                if input.get_earliest() {
                                    return Ok(mat.ok_or(at));
                                }
                                if dfa.is_accel_state(sid) {
                                    let needs = dfa.accelerator(sid);
                                    at = accel::find_fwd(needs, input.haystack(), at)
                                        .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_accel_state(sid) {
                                let needs = dfa.accelerator(sid);
                                at = accel::find_fwd(needs, input.haystack(), at)
                                    .unwrap_or(input.end());
                                continue;
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat.ok_or(at));
                            } else if dfa.is_quit_state(sid) {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            } else {
                                debug_assert!(dfa.is_start_state(sid));
                            }
                        }
                        at += 1;
                    }
                    dfa_eoi_fwd(dfa, input, &mut sid, &mut mat)?;
                    Ok(mat.ok_or(at))
                }

                #[cfg(feature = "hybrid")]
                pub fn hybrid_try_search_half_fwd(
                    dfa: &crate::hybrid::dfa::DFA,
                    cache: &mut crate::hybrid::dfa::Cache,
                    input: &Input<'_>,
                ) -> Result<Result<HalfMatch, usize>, RetryFailError>
                {
                    let mut mat = None;
                    let mut sid = dfa.start_state_forward(cache, input)?;
                    let mut at = input.start();
                    
                    while at < input.end() {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[at])
                            .map_err(|_| MatchError::gave_up(at))?;
                        
                        if sid.is_tagged()
                        {
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                
                                if input.get_earliest() {
                                    return Ok(mat.ok_or(at));
                                }
                            } else if sid.is_dead() {
                                return Ok(mat.ok_or(at));
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            } else {
                                debug_assert!(!sid.is_unknown());
                                debug_assert!(sid.is_start());
                            }
                        }
                        at += 1;
                    }
                    hybrid_eoi_fwd(dfa, cache, input, &mut sid, &mut mat)?;
                    Ok(mat.ok_or(at))
                }

                #[inline( always )] fn dfa_eoi_fwd(
                    dfa: &crate::dfa::dense::DFA<Vec<u32>>,
                    input: &Input<'_>,
                    sid: &mut crate::util::primitives::StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    use crate::dfa::Automaton;

                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid = dfa.next_state(*sid, b);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if dfa.is_quit_state(*sid) {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa.next_eoi_state(*sid);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                            debug_assert!(!dfa.is_quit_state(*sid));
                        }
                    }
                    Ok(())
                }

                #[cfg(feature = "hybrid")]
                #[inline( always )] fn hybrid_eoi_fwd(
                    dfa: &crate::hybrid::dfa::DFA,
                    cache: &mut crate::hybrid::dfa::Cache,
                    input: &Input<'_>,
                    sid: &mut crate::hybrid::LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError>
                {
                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid = dfa
                                .next_state(cache, *sid, b)
                                .map_err(|_| MatchError::gave_up(sp.end))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa
                                .next_eoi_state(cache, *sid)
                                .map_err(|_| MatchError::gave_up(input.haystack().len()))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                            debug_assert!(!sid.is_quit());
                        }
                    }
                    Ok(())
                }
            }

            pub mod strategy
            {
                use ::
                {
                    *,
                };
                /*
                use ::{
                    fmt::Debug,
                    panic::{RefUnwindSafe, UnwindSafe},
                };

                use ::sync::Arc;

                use regex_syntax::hir::{literal, Hir};

                use crate::{
                    meta::{
                        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},
                        regex::{Cache, RegexInfo},
                        reverse_inner, wrappers,
                    },
                    nfa::thompson::{self, WhichCaptures, NFA},
                    util::{
                        captures::{Captures, GroupInfo},
                        look::LookMatcher,
                        prefilter::{self, Prefilter, PrefilterI},
                        primitives::{NonMaxUsize, PatternID},
                        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},
                    },
                };
                */
                /// A trait that represents a single meta strategy. Its main utility is in
                pub(super) trait Strategy:
                    Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static
                {
                    fn group_info(&self) -> &GroupInfo;

                    fn create_cache(&self) -> Cache;

                    fn reset_cache(&self, cache: &mut Cache);

                    fn is_accelerated(&self) -> bool;

                    fn memory_usage(&self) -> usize;

                    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;

                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch>;

                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;

                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID>;

                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    );
                }

                pub(super) fn new(
                    info: &RegexInfo,
                    hirs: &[&Hir],
                ) -> Result<Arc<dyn Strategy>, BuildError>
                {
                    let pre = if info.is_always_anchored_start() {
                        debug!("skipping literal extraction since regex is anchored");
                        None
                    } else if let Some(pre) = info.config().get_prefilter() {
                        debug!(
                            "skipping literal extraction since the caller provided a prefilter"
                        );
                        Some(pre.clone())
                    } else if info.config().get_auto_prefilter() {
                        let kind = info.config().get_match_kind();
                        let prefixes = crate::util::prefilter::prefixes(kind, hirs);
                        
                        if let Some(pre) = Pre::from_prefixes(info, &prefixes) {
                            debug!(
                                "found that the regex can be broken down to a literal \
                                search, avoiding the regex engine entirely",
                            );
                            
                            return Ok(pre);
                        }
                        
                        if let Some(pre) = Pre::from_alternation_literals(info, hirs) {
                            debug!(
                                "found plain alternation of literals, \
                                avoiding regex engine entirely and using Aho-Corasick"
                            );
                            
                            return Ok(pre);
                        }
                        prefixes.literals().and_then(|strings| {
                            debug!(
                                "creating prefilter from {} literals: {:?}",
                                strings.len(),
                                strings,
                            );
                            Prefilter::new(kind, strings)
                        })
                    } else {
                        debug!("skipping literal extraction since prefilters were disabled");
                        None
                    };
                    let mut core = Core::new(info.clone(), pre.clone(), hirs)?;
                    core = match ReverseAnchored::new(core) {
                        Err(core) => core,
                        Ok(ra) => {
                            debug!("using reverse anchored strategy");
                            
                            return Ok(Arc::new(ra));
                        }
                    };
                    core = match ReverseSuffix::new(core, hirs) {
                        Err(core) => core,
                        Ok(rs) => {
                            debug!("using reverse suffix strategy");
                            
                            return Ok(Arc::new(rs));
                        }
                    };
                    core = match ReverseInner::new(core, hirs) {
                        Err(core) => core,
                        Ok(ri) => {
                            debug!("using reverse inner strategy");
                            
                            return Ok(Arc::new(ri));
                        }
                    };
                    debug!("using core strategy");
                    Ok(Arc::new(core))
                }

                #[derive(Clone, Debug)]
                struct Pre<P> {
                    pre: P,
                    group_info: GroupInfo,
                }

                impl<P: PrefilterI> Pre<P> {
                    fn new(pre: P) -> Arc<dyn Strategy> {
                        let group_info = GroupInfo::new([[None::<&str>]]).unwrap();
                        Arc::new(Pre { pre, group_info })
                    }
                }
                impl Pre<()>
                {
                    /// Given a sequence of prefixes, attempt to return a full `Strategy` using
                    fn from_prefixes(
                        info: &RegexInfo,
                        prefixes: &literal::Seq,
                    ) -> Option<Arc<dyn Strategy>> {
                        let kind = info.config().get_match_kind();
                        
                        if !prefixes.is_exact() {
                            return None;
                        }
                        
                        if info.pattern_len() != 1 {
                            return None;
                        }
                        
                        if info.props()[0].explicit_captures_len() != 0 {
                            return None;
                        }
                        
                        if !info.props()[0].look_set().is_empty() {
                            return None;
                        }
                        
                        if kind != MatchKind::LeftmostFirst {
                            return None;
                        }
                        let prefixes = prefixes.literals().unwrap();
                        debug!(
                            "trying to bypass regex engine by creating \
                            prefilter from {} literals: {:?}",
                            prefixes.len(),
                            prefixes,
                        );
                        let choice = match prefilter::Choice::new(kind, prefixes) {
                            Some(choice) => choice,
                            None => {
                                debug!(
                                    "regex bypass failed because no prefilter could be built"
                                );
                                return None;
                            }
                        };
                        let strat: Arc<dyn Strategy> = match choice {
                            prefilter::Choice::Memchr(pre) => Pre::new(pre),
                            prefilter::Choice::Memchr2(pre) => Pre::new(pre),
                            prefilter::Choice::Memchr3(pre) => Pre::new(pre),
                            prefilter::Choice::Memmem(pre) => Pre::new(pre),
                            prefilter::Choice::Teddy(pre) => Pre::new(pre),
                            prefilter::Choice::ByteSet(pre) => Pre::new(pre),
                            prefilter::Choice::AhoCorasick(pre) => Pre::new(pre),
                        };
                        Some(strat)
                    }
                    /// Attempts to extract an alternation of literals, and if it's deemed
                    fn from_alternation_literals(
                        info: &RegexInfo,
                        hirs: &[&Hir],
                    ) -> Option<Arc<dyn Strategy>> {
                        use crate::util::prefilter::AhoCorasick;

                        let lits = crate::meta::literal::alternation_literals(info, hirs)?;
                        let ac = AhoCorasick::new(MatchKind::LeftmostFirst, &lits)?;
                        Some(Pre::new(ac))
                    }
                }
                impl<P: PrefilterI> Strategy for Pre<P> {
                    #[inline( always )]
                    fn group_info(&self) -> &GroupInfo {
                        &self.group_info
                    }

                    fn create_cache(&self) -> Cache {
                        Cache {
                            capmatches: Captures::all(self.group_info().clone()),
                            pikevm: wrappers::PikeVMCache::none(),
                            backtrack: wrappers::BoundedBacktrackerCache::none(),
                            onepass: wrappers::OnePassCache::none(),
                            hybrid: wrappers::HybridCache::none(),
                            revhybrid: wrappers::ReverseHybridCache::none(),
                        }
                    }

                    fn reset_cache(&self, _cache: &mut Cache) {}

                    fn is_accelerated(&self) -> bool {
                        self.pre.is_fast()
                    }

                    fn memory_usage(&self) -> usize {
                        self.pre.memory_usage()
                    }

                    #[inline( always )]
                    fn search(&self, _cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.is_done() {
                            return None;
                        }
                        
                        if input.get_anchored().is_anchored() {
                            return self
                                .pre
                                .prefix(input.haystack(), input.get_span())
                                .map(|sp| Match::new(PatternID::ZERO, sp));
                        }
                        self.pre
                            .find(input.haystack(), input.get_span())
                            .map(|sp| Match::new(PatternID::ZERO, sp))
                    }

                    #[inline( always )]
                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        self.search(cache, input).map(|m| HalfMatch::new(m.pattern(), m.end()))
                    }

                    #[inline( always )]
                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        self.search(cache, input).is_some()
                    }

                    #[inline( always )]
                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        let m = self.search(cache, input)?;
                        
                        if let Some(slot) = slots.get_mut(0) {
                            *slot = NonMaxUsize::new(m.start());
                        }
                        
                        if let Some(slot) = slots.get_mut(1) {
                            *slot = NonMaxUsize::new(m.end());
                        }
                        Some(m.pattern())
                    }

                    #[inline( always )]
                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if self.search(cache, input).is_some() {
                            patset.insert(PatternID::ZERO);
                        }
                    }
                }

                #[derive(Debug)]
                struct Core {
                    info: RegexInfo,
                    pre: Option<Prefilter>,
                    nfa: NFA,
                    nfarev: Option<NFA>,
                    pikevm: wrappers::PikeVM,
                    backtrack: wrappers::BoundedBacktracker,
                    onepass: wrappers::OnePass,
                    hybrid: wrappers::Hybrid,
                    dfa: wrappers::DFA,
                }

                impl Core {
                    fn new(
                        info: RegexInfo,
                        pre: Option<Prefilter>,
                        hirs: &[&Hir],
                    ) -> Result<Core, BuildError> {
                        let mut lookm = LookMatcher::new();
                        lookm.set_line_terminator(info.config().get_line_terminator());
                        let thompson_config = thompson::Config::new()
                            .utf8(info.config().get_utf8_empty())
                            .nfa_size_limit(info.config().get_nfa_size_limit())
                            .shrink(false)
                            .which_captures(info.config().get_which_captures())
                            .look_matcher(lookm);
                        let nfa = thompson::Compiler::new()
                            .configure(thompson_config.clone())
                            .build_many_from_hir(hirs)
                            .map_err(BuildError::nfa)?;
                        let pikevm = wrappers::PikeVM::new(&info, pre.clone(), &nfa)?;
                        let backtrack =
                            wrappers::BoundedBacktracker::new(&info, pre.clone(), &nfa)?;
                        let onepass = wrappers::OnePass::new(&info, &nfa);
                        let (nfarev, hybrid, dfa) =
                            if !info.config().get_hybrid() && !info.config().get_dfa() {
                                (None, wrappers::Hybrid::none(), wrappers::DFA::none())
                            } else {
                                let nfarev = thompson::Compiler::new()
                                    .configure(
                                        thompson_config
                                            .clone()
                                            .which_captures(WhichCaptures::None)
                                            .reverse(true),
                                    )
                                    .build_many_from_hir(hirs)
                                    .map_err(BuildError::nfa)?;
                                let dfa = if !info.config().get_dfa() {
                                    wrappers::DFA::none()
                                } else {
                                    wrappers::DFA::new(&info, pre.clone(), &nfa, &nfarev)
                                };
                                let hybrid = if !info.config().get_hybrid() {
                                    wrappers::Hybrid::none()
                                } else if dfa.is_some() {
                                    debug!("skipping lazy DFA because we have a full DFA");
                                    wrappers::Hybrid::none()
                                } else {
                                    wrappers::Hybrid::new(&info, pre.clone(), &nfa, &nfarev)
                                };
                                (Some(nfarev), hybrid, dfa)
                            };
                        Ok(Core {
                            info,
                            pre,
                            nfa,
                            nfarev,
                            pikevm,
                            backtrack,
                            onepass,
                            hybrid,
                            dfa,
                        })
                    }

                    #[inline( always )]
                    fn try_search_mayfail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<Result<Option<Match>, RetryFailError>> {
                        if let Some(e) = self.dfa.get(input) {
                            trace!("using full DFA for search at {:?}", input.get_span());
                            Some(e.try_search(input))
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!("using lazy DFA for search at {:?}", input.get_span());
                            Some(e.try_search(&mut cache.hybrid, input))
                        } else {
                            None
                        }
                    }

                    fn search_nofail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<Match> {
                        let caps = &mut cache.capmatches;
                        caps.set_pattern(None);
                        let pid = if let Some(ref e) = self.onepass.get(input) {
                            trace!("using OnePass for search at {:?}", input.get_span());
                            e.search_slots(&mut cache.onepass, input, caps.slots_mut())
                        } else if let Some(ref e) = self.backtrack.get(input) {
                            trace!(
                                "using BoundedBacktracker for search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.backtrack, input, caps.slots_mut())
                        } else {
                            trace!("using PikeVM for search at {:?}", input.get_span());
                            let e = self.pikevm.get();
                            e.search_slots(&mut cache.pikevm, input, caps.slots_mut())
                        };
                        caps.set_pattern(pid);
                        caps.get_match()
                    }

                    fn search_half_nofail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        let m = self.search_nofail(cache, input)?;
                        Some(HalfMatch::new(m.pattern(), m.end()))
                    }

                    fn search_slots_nofail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if let Some(ref e) = self.onepass.get(input) {
                            trace!(
                                "using OnePass for capture search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.onepass, input, slots)
                        } else if let Some(ref e) = self.backtrack.get(input) {
                            trace!(
                                "using BoundedBacktracker for capture search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.backtrack, input, slots)
                        } else {
                            trace!(
                                "using PikeVM for capture search at {:?}",
                                input.get_span()
                            );
                            let e = self.pikevm.get();
                            e.search_slots(&mut cache.pikevm, input, slots)
                        }
                    }

                    fn is_match_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if let Some(ref e) = self.onepass.get(input) {
                            trace!(
                                "using OnePass for is-match search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.onepass, input, &mut []).is_some()
                        } else if let Some(ref e) = self.backtrack.get(input) {
                            trace!(
                                "using BoundedBacktracker for is-match search at {:?}",
                                input.get_span()
                            );
                            e.is_match(&mut cache.backtrack, input)
                        } else {
                            trace!(
                                "using PikeVM for is-match search at {:?}",
                                input.get_span()
                            );
                            let e = self.pikevm.get();
                            e.is_match(&mut cache.pikevm, input)
                        }
                    }

                    fn is_capture_search_needed(&self, slots_len: usize) -> bool {
                        slots_len > self.nfa.group_info().implicit_slot_len()
                    }
                }

                impl Strategy for Core {
                    #[inline( always )]
                    fn group_info(&self) -> &GroupInfo {
                        self.nfa.group_info()
                    }

                    #[inline( always )]
                    fn create_cache(&self) -> Cache {
                        Cache {
                            capmatches: Captures::all(self.group_info().clone()),
                            pikevm: self.pikevm.create_cache(),
                            backtrack: self.backtrack.create_cache(),
                            onepass: self.onepass.create_cache(),
                            hybrid: self.hybrid.create_cache(),
                            revhybrid: wrappers::ReverseHybridCache::none(),
                        }
                    }

                    #[inline( always )]
                    fn reset_cache(&self, cache: &mut Cache) {
                        cache.pikevm.reset(&self.pikevm);
                        cache.backtrack.reset(&self.backtrack);
                        cache.onepass.reset(&self.onepass);
                        cache.hybrid.reset(&self.hybrid);
                    }

                    fn is_accelerated(&self) -> bool {
                        self.pre.as_ref().map_or(false, |pre| pre.is_fast())
                    }

                    fn memory_usage(&self) -> usize {
                        self.info.memory_usage()
                            + self.pre.as_ref().map_or(0, |pre| pre.memory_usage())
                            + self.nfa.memory_usage()
                            + self.nfarev.as_ref().map_or(0, |nfa| nfa.memory_usage())
                            + self.onepass.memory_usage()
                            + self.dfa.memory_usage()
                    }

                    #[inline( always )]
                    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        return if let Some(e) = self.dfa.get(input) {
                            trace!("using full DFA for full search at {:?}", input.get_span());
                            match e.try_search(input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("full DFA search failed: {_err}");
                                    self.search_nofail(cache, input)
                                }
                            }
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!("using lazy DFA for full search at {:?}", input.get_span());
                            match e.try_search(&mut cache.hybrid, input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("lazy DFA search failed: {_err}");
                                    self.search_nofail(cache, input)
                                }
                            }
                        } else {
                            self.search_nofail(cache, input)
                        };
                    }

                    #[inline( always )]
                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if let Some(e) = self.dfa.get(input) {
                            trace!("using full DFA for half search at {:?}", input.get_span());
                            match e.try_search_half_fwd(input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("full DFA half search failed: {_err}");
                                    self.search_half_nofail(cache, input)
                                }
                            }
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!("using lazy DFA for half search at {:?}", input.get_span());
                            match e.try_search_half_fwd(&mut cache.hybrid, input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("lazy DFA half search failed: {_err}");
                                    self.search_half_nofail(cache, input)
                                }
                            }
                        } else {
                            self.search_half_nofail(cache, input)
                        }
                    }

                    #[inline( always )]
                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if let Some(e) = self.dfa.get(input) {
                            trace!(
                                "using full DFA for is-match search at {:?}",
                                input.get_span()
                            );
                            match e.try_search_half_fwd(input) {
                                Ok(x) => x.is_some(),
                                Err(_err) => {
                                    trace!("full DFA half search failed: {_err}");
                                    self.is_match_nofail(cache, input)
                                }
                            }
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!(
                                "using lazy DFA for is-match search at {:?}",
                                input.get_span()
                            );
                            match e.try_search_half_fwd(&mut cache.hybrid, input) {
                                Ok(x) => x.is_some(),
                                Err(_err) => {
                                    trace!("lazy DFA half search failed: {_err}");
                                    self.is_match_nofail(cache, input)
                                }
                            }
                        } else {
                            self.is_match_nofail(cache, input)
                        }
                    }

                    #[inline( always )]
                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if !self.is_capture_search_needed(slots.len()) {
                            trace!("asked for slots unnecessarily, trying fast path");
                            let m = self.search(cache, input)?;
                            copy_match_to_slots(m, slots);
                            
                            return Some(m.pattern());
                        }
                        
                        if self.onepass.get(&input).is_some() {
                            return self.search_slots_nofail(cache, &input, slots);
                        }
                        let m = match self.try_search_mayfail(cache, input) {
                            Some(Ok(Some(m))) => m,
                            Some(Ok(None)) => return None,
                            Some(Err(_err)) => {
                                trace!("fast capture search failed: {_err}");
                                return self.search_slots_nofail(cache, input, slots);
                            }
                            None => {
                                return self.search_slots_nofail(cache, input, slots);
                            }
                        };
                        trace!(
                            "match found at {}..{} in capture search, \
                            using another engine to find captures",
                            m.start(),
                            m.end(),
                        );
                        let input = input
                            .clone()
                            .span(m.start()..m.end())
                            .anchored(Anchored::Pattern(m.pattern()));
                        Some(
                            self.search_slots_nofail(cache, &input, slots)
                                .expect("should find a match"),
                        )
                    }

                    #[inline( always )]
                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if let Some(e) = self.dfa.get(input) {
                            trace!(
                                "using full DFA for overlapping search at {:?}",
                                input.get_span()
                            );
                            let _err = match e.try_which_overlapping_matches(input, patset) {
                                Ok(()) => return,
                                Err(err) => err,
                            };
                            trace!("fast overlapping search failed: {_err}");
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!(
                                "using lazy DFA for overlapping search at {:?}",
                                input.get_span()
                            );
                            let _err = match e.try_which_overlapping_matches(
                                &mut cache.hybrid,
                                input,
                                patset,
                            ) {
                                Ok(()) => {
                                    return;
                                }
                                Err(err) => err,
                            };
                            trace!("fast overlapping search failed: {_err}");
                        }
                        trace!(
                            "using PikeVM for overlapping search at {:?}",
                            input.get_span()
                        );
                        let e = self.pikevm.get();
                        e.which_overlapping_matches(&mut cache.pikevm, input, patset)
                    }
                }

                #[derive(Debug)]
                struct ReverseAnchored {
                    core: Core,
                }

                impl ReverseAnchored {
                    fn new(core: Core) -> Result<ReverseAnchored, Core> {
                        if !core.info.is_always_anchored_end() {
                            debug!(
                                "skipping reverse anchored optimization because \
                                the regex is not always anchored at the end"
                            );
                            
                            return Err(core);
                        }
                        
                        if core.info.is_always_anchored_start() {
                            debug!(
                                "skipping reverse anchored optimization because \
                                the regex is also anchored at the start"
                            );
                            
                            return Err(core);
                        }
                        
                        if !core.hybrid.is_some() && !core.dfa.is_some() {
                            debug!(
                                "skipping reverse anchored optimization because \
                                we don't have a lazy DFA or a full DFA"
                            );
                            
                            return Err(core);
                        }
                        Ok(ReverseAnchored { core })
                    }

                    #[inline( always )]
                    fn try_search_half_anchored_rev(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                        let input = input.clone().anchored(Anchored::Yes);
                        
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for reverse anchored search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_rev(&input)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for reverse anchored search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_rev(&mut cache.hybrid, &input)
                        } else {
                            unreachable!("ReverseAnchored always has a DFA")
                        }
                    }
                }
                impl Strategy for ReverseAnchored {
                    #[inline( always )]
                    fn group_info(&self) -> &GroupInfo {
                        self.core.group_info()
                    }

                    #[inline( always )]
                    fn create_cache(&self) -> Cache {
                        self.core.create_cache()
                    }

                    #[inline( always )]
                    fn reset_cache(&self, cache: &mut Cache) {
                        self.core.reset_cache(cache);
                    }

                    fn is_accelerated(&self) -> bool {
                        true
                    }

                    fn memory_usage(&self) -> usize {
                        self.core.memory_usage()
                    }

                    #[inline( always )]
                    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search(cache, input);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.search_nofail(cache, input)
                            }
                            Ok(None) => None,
                            Ok(Some(hm)) => {
                                Some(Match::new(hm.pattern(), hm.offset()..input.end()))
                            }
                        }
                    }

                    #[inline( always )]
                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_half(cache, input);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.search_half_nofail(cache, input)
                            }
                            Ok(None) => None,
                            Ok(Some(hm)) => {
                                Some(HalfMatch::new(hm.pattern(), input.end()))
                            }
                        }
                    }

                    #[inline( always )]
                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if input.get_anchored().is_anchored() {
                            return self.core.is_match(cache, input);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.is_match_nofail(cache, input)
                            }
                            Ok(None) => false,
                            Ok(Some(_)) => true,
                        }
                    }

                    #[inline( always )]
                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_slots(cache, input, slots);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.search_slots_nofail(cache, input, slots)
                            }
                            Ok(None) => None,
                            Ok(Some(hm)) => {
                                if !self.core.is_capture_search_needed(slots.len()) {
                                    trace!("asked for slots unnecessarily, skipping captures");
                                    let m = Match::new(hm.pattern(), hm.offset()..input.end());
                                    copy_match_to_slots(m, slots);
                                    return Some(m.pattern());
                                }
                                let start = hm.offset();
                                let input = input
                                    .clone()
                                    .span(start..input.end())
                                    .anchored(Anchored::Pattern(hm.pattern()));
                                self.core.search_slots_nofail(cache, &input, slots)
                            }
                        }
                    }

                    #[inline( always )]
                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.core.which_overlapping_matches(cache, input, patset)
                    }
                }

                #[derive(Debug)]
                struct ReverseSuffix {
                    core: Core,
                    pre: Prefilter,
                }

                impl ReverseSuffix {
                    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {
                        if !core.info.config().get_auto_prefilter() {
                            debug!(
                                "skipping reverse suffix optimization because \
                                automatic prefilters are disabled"
                            );
                            
                            return Err(core);
                        }
                        
                        if core.info.is_always_anchored_start() {
                            debug!(
                                "skipping reverse suffix optimization because \
                                the regex is always anchored at the start",
                            );
                            
                            return Err(core);
                        }
                        
                        if !core.hybrid.is_some() && !core.dfa.is_some() {
                            debug!(
                                "skipping reverse suffix optimization because \
                                we don't have a lazy DFA or a full DFA"
                            );
                            
                            return Err(core);
                        }
                        
                        if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
                            debug!(
                                "skipping reverse suffix optimization because \
                                we already have a prefilter that we think is fast"
                            );
                            
                            return Err(core);
                        }
                        let kind = core.info.config().get_match_kind();
                        let suffixes = crate::util::prefilter::suffixes(kind, hirs);
                        let lcs = match suffixes.longest_common_suffix() {
                            None => {
                                debug!(
                                    "skipping reverse suffix optimization because \
                                    a longest common suffix could not be found",
                                );
                                return Err(core);
                            }
                            Some(lcs) if lcs.is_empty() => {
                                debug!(
                                    "skipping reverse suffix optimization because \
                                    the longest common suffix is the empty string",
                                );
                                return Err(core);
                            }
                            Some(lcs) => lcs,
                        };
                        let pre = match Prefilter::new(kind, &[lcs]) {
                            Some(pre) => pre,
                            None => {
                                debug!(
                                    "skipping reverse suffix optimization because \
                                    a prefilter could not be constructed from the \
                                    longest common suffix",
                                );
                                return Err(core);
                            }
                        };
                        
                        if !pre.is_fast() {
                            debug!(
                                "skipping reverse suffix optimization because \
                                while we have a suffix prefilter, it is not \
                                believed to be 'fast'"
                            );
                            
                            return Err(core);
                        }
                        Ok(ReverseSuffix { core, pre })
                    }

                    #[inline( always )]
                    fn try_search_half_start(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        let mut span = input.get_span();
                        let mut min_start = 0;

                        loop
                        {
                            let litmatch = match self.pre.find(input.haystack(), span) {
                                None => return Ok(None),
                                Some(span) => span,
                            };
                            trace!("reverse suffix scan found suffix match at {litmatch:?}");
                            let revinput = input
                                .clone()
                                .anchored(Anchored::Yes)
                                .span(input.start()..litmatch.end);
                            match self
                                .try_search_half_rev_limited(cache, &revinput, min_start)?
                            {
                                None => {
                                    if span.start >= span.end {
                                        break;
                                    }
                                    span.start = litmatch.start.checked_add(1).unwrap();
                                }
                                Some(hm) => return Ok(Some(hm)),
                            }
                            min_start = litmatch.end;
                        }
                        Ok(None)
                    }

                    #[inline( always )]
                    fn try_search_half_fwd(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for forward reverse suffix search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_fwd(&input)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for forward reverse suffix search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_fwd(&mut cache.hybrid, &input)
                        } else {
                            unreachable!("ReverseSuffix always has a DFA")
                        }
                    }

                    #[inline( always )]
                    fn try_search_half_rev_limited(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for reverse suffix search at {:?}, \
                                but will be stopped at {} to avoid quadratic behavior",
                                input.get_span(),
                                min_start,
                            );
                            e.try_search_half_rev_limited(&input, min_start)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for reverse suffix search at {:?}, \
                                but will be stopped at {} to avoid quadratic behavior",
                                input.get_span(),
                                min_start,
                            );
                            e.try_search_half_rev_limited(&mut cache.hybrid, &input, min_start)
                        } else {
                            unreachable!("ReverseSuffix always has a DFA")
                        }
                    }
                }

                impl Strategy for ReverseSuffix {
                    #[inline( always )]
                    fn group_info(&self) -> &GroupInfo {
                        self.core.group_info()
                    }

                    #[inline( always )]
                    fn create_cache(&self) -> Cache {
                        self.core.create_cache()
                    }

                    #[inline( always )]
                    fn reset_cache(&self, cache: &mut Cache) {
                        self.core.reset_cache(cache);
                    }

                    fn is_accelerated(&self) -> bool {
                        self.pre.is_fast()
                    }

                    fn memory_usage(&self) -> usize {
                        self.core.memory_usage() + self.pre.memory_usage()
                    }

                    #[inline( always )]
                    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search(cache, input);
                        }
                        match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix optimization failed: {_err}");
                                self.core.search(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!("reverse suffix reverse fast search failed: {_err}");
                                self.core.search_nofail(cache, input)
                            }
                            Ok(None) => None,
                            Ok(Some(hm_start)) => {
                                let fwdinput = input
                                    .clone()
                                    .anchored(Anchored::Pattern(hm_start.pattern()))
                                    .span(hm_start.offset()..input.end());
                                match self.try_search_half_fwd(cache, &fwdinput) {
                                    Err(_err) => {
                                        trace!(
                                            "reverse suffix forward fast search failed: {_err}"
                                        );
                                        self.core.search_nofail(cache, input)
                                    }
                                    Ok(None) => {
                                        unreachable!(
                                            "suffix match plus reverse match implies \
                                            there must be a match",
                                        )
                                    }
                                    Ok(Some(hm_end)) => Some(Match::new(
                                        hm_start.pattern(),
                                        hm_start.offset()..hm_end.offset(),
                                    )),
                                }
                            }
                        }
                    }

                    #[inline( always )]
                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_half(cache, input);
                        }
                        match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix half optimization failed: {_err}");
                                self.core.search_half(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!(
                                    "reverse suffix reverse fast half search failed: {_err}"
                                );
                                self.core.search_half_nofail(cache, input)
                            }
                            Ok(None) => None,
                            Ok(Some(hm_start)) => {
                                let fwdinput = input
                                    .clone()
                                    .anchored(Anchored::Pattern(hm_start.pattern()))
                                    .span(hm_start.offset()..input.end());
                                match self.try_search_half_fwd(cache, &fwdinput) {
                                    Err(_err) => {
                                        trace!(
                                            "reverse suffix forward fast search failed: {_err}"
                                        );
                                        self.core.search_half_nofail(cache, input)
                                    }
                                    Ok(None) => {
                                        unreachable!(
                                            "suffix match plus reverse match implies \
                                            there must be a match",
                                        )
                                    }
                                    Ok(Some(hm_end)) => Some(hm_end),
                                }
                            }
                        }
                    }

                    #[inline( always )]
                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if input.get_anchored().is_anchored() {
                            return self.core.is_match(cache, input);
                        }
                        match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix half optimization failed: {_err}");
                                self.core.is_match_nofail(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!(
                                    "reverse suffix reverse fast half search failed: {_err}"
                                );
                                self.core.is_match_nofail(cache, input)
                            }
                            Ok(None) => false,
                            Ok(Some(_)) => true,
                        }
                    }

                    #[inline( always )]
                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_slots(cache, input, slots);
                        }
                        
                        if !self.core.is_capture_search_needed(slots.len()) {
                            trace!("asked for slots unnecessarily, trying fast path");
                            let m = self.search(cache, input)?;
                            copy_match_to_slots(m, slots);
                            
                            return Some(m.pattern());
                        }
                        let hm_start = match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix captures optimization failed: {_err}");
                                return self.core.search_slots(cache, input, slots);
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!(
                                    "reverse suffix reverse fast captures search failed: \
                                        {_err}"
                                );
                                return self.core.search_slots_nofail(cache, input, slots);
                            }
                            Ok(None) => return None,
                            Ok(Some(hm_start)) => hm_start,
                        };
                        trace!(
                            "match found at {}..{} in capture search, \
                            using another engine to find captures",
                            hm_start.offset(),
                            input.end(),
                        );
                        let start = hm_start.offset();
                        let input = input
                            .clone()
                            .span(start..input.end())
                            .anchored(Anchored::Pattern(hm_start.pattern()));
                        self.core.search_slots_nofail(cache, &input, slots)
                    }

                    #[inline( always )]
                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.core.which_overlapping_matches(cache, input, patset)
                    }
                }

                #[derive(Debug)]
                struct ReverseInner {
                    core: Core,
                    preinner: Prefilter,
                    nfarev: NFA,
                    hybrid: wrappers::ReverseHybrid,
                    dfa: wrappers::ReverseDFA,
                }

                impl ReverseInner {
                    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {
                        if !core.info.config().get_auto_prefilter() {
                            debug!(
                                "skipping reverse inner optimization because \
                                automatic prefilters are disabled"
                            );
                            
                            return Err(core);
                        }
                        
                        if core.info.config().get_match_kind() != MatchKind::LeftmostFirst {
                            debug!(
                                "skipping reverse inner optimization because \
                                match kind is {:?} but this only supports leftmost-first",
                                core.info.config().get_match_kind(),
                            );
                            
                            return Err(core);
                        }
                        
                        if core.info.is_always_anchored_start() {
                            debug!(
                                "skipping reverse inner optimization because \
                                the regex is always anchored at the start",
                            );
                            
                            return Err(core);
                        }
                        
                        if !core.hybrid.is_some() && !core.dfa.is_some() {
                            debug!(
                                "skipping reverse inner optimization because \
                                we don't have a lazy DFA or a full DFA"
                            );
                            
                            return Err(core);
                        }
                        
                        if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
                            debug!(
                                "skipping reverse inner optimization because \
                                we already have a prefilter that we think is fast"
                            );
                            
                            return Err(core);
                        } else if core.pre.is_some() {
                            debug!(
                                "core engine has a prefix prefilter, but it is \
                                probably not fast, so continuing with attempt to \
                                use reverse inner prefilter"
                            );
                        }
                        let (concat_prefix, preinner) = match reverse_inner::extract(hirs) {
                            Some(x) => x,
                            None => return Err(core),
                        };
                        debug!("building reverse NFA for prefix before inner literal");
                        let mut lookm = LookMatcher::new();
                        lookm.set_line_terminator(core.info.config().get_line_terminator());
                        let thompson_config = thompson::Config::new()
                            .reverse(true)
                            .utf8(core.info.config().get_utf8_empty())
                            .nfa_size_limit(core.info.config().get_nfa_size_limit())
                            .shrink(false)
                            .which_captures(WhichCaptures::None)
                            .look_matcher(lookm);
                        let result = thompson::Compiler::new()
                            .configure(thompson_config)
                            .build_from_hir(&concat_prefix);
                        let nfarev = match result {
                            Ok(nfarev) => nfarev,
                            Err(_err) => {
                                debug!(
                                    "skipping reverse inner optimization because the \
                                    reverse NFA failed to build: {}",
                                    _err,
                                );
                                return Err(core);
                            }
                        };
                        debug!("building reverse DFA for prefix before inner literal");
                        let dfa = if !core.info.config().get_dfa() {
                            wrappers::ReverseDFA::none()
                        } else {
                            wrappers::ReverseDFA::new(&core.info, &nfarev)
                        };
                        let hybrid = if !core.info.config().get_hybrid() {
                            wrappers::ReverseHybrid::none()
                        } else if dfa.is_some() {
                            debug!(
                                "skipping lazy DFA for reverse inner optimization \
                                because we have a full DFA"
                            );
                            wrappers::ReverseHybrid::none()
                        } else {
                            wrappers::ReverseHybrid::new(&core.info, &nfarev)
                        };
                        Ok(ReverseInner { core, preinner, nfarev, hybrid, dfa })
                    }

                    #[inline( always )]
                    fn try_search_full(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, RetryError> {
                        let mut span = input.get_span();
                        let mut min_match_start = 0;
                        let mut min_pre_start = 0;

                        loop
                        {
                            let litmatch = match self.preinner.find(input.haystack(), span) {
                                None => return Ok(None),
                                Some(span) => span,
                            };
                            if litmatch.start < min_pre_start {
                                trace!(
                                    "found inner prefilter match at {litmatch:?}, which starts \
                                    before the end of the last forward scan at {min_pre_start}, \
                                    quitting to avoid quadratic behavior",
                                );
                                return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                            }
                            trace!("reverse inner scan found inner match at {litmatch:?}");
                            let revinput = input
                                .clone()
                                .anchored(Anchored::Yes)
                                .span(input.start()..litmatch.start);
                            match self.try_search_half_rev_limited(
                                cache,
                                &revinput,
                                min_match_start,
                            )? {
                                None => {
                                    if span.start >= span.end {
                                        break;
                                    }
                                    span.start = litmatch.start.checked_add(1).unwrap();
                                }
                                Some(hm_start) => {
                                    let fwdinput = input
                                        .clone()
                                        .anchored(Anchored::Pattern(hm_start.pattern()))
                                        .span(hm_start.offset()..input.end());
                                    match self.try_search_half_fwd_stopat(cache, &fwdinput)? {
                                        Err(stopat) => {
                                            min_pre_start = stopat;
                                            span.start =
                                                litmatch.start.checked_add(1).unwrap();
                                        }
                                        Ok(hm_end) => {
                                            return Ok(Some(Match::new(
                                                hm_start.pattern(),
                                                hm_start.offset()..hm_end.offset(),
                                            )))
                                        }
                                    }
                                }
                            }
                            min_match_start = litmatch.end;
                        }
                        Ok(None)
                    }

                    #[inline( always )]
                    fn try_search_half_fwd_stopat(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for forward reverse inner search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_fwd_stopat(&input)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for forward reverse inner search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_fwd_stopat(&mut cache.hybrid, &input)
                        } else {
                            unreachable!("ReverseInner always has a DFA")
                        }
                    }

                    #[inline( always )]
                    fn try_search_half_rev_limited(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        if let Some(e) = self.dfa.get(&input) {
                            trace!(
                                "using full DFA for reverse inner search at {:?}, \
                                but will be stopped at {} to avoid quadratic behavior",
                                input.get_span(),
                                min_start,
                            );
                            e.try_search_half_rev_limited(&input, min_start)
                        } else if let Some(e) = self.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for reverse inner search at {:?}, \
                                but will be stopped at {} to avoid quadratic behavior",
                                input.get_span(),
                                min_start,
                            );
                            e.try_search_half_rev_limited(
                                &mut cache.revhybrid,
                                &input,
                                min_start,
                            )
                        } else {
                            unreachable!("ReverseInner always has a DFA")
                        }
                    }
                }

                impl Strategy for ReverseInner {
                    #[inline( always )]
                    fn group_info(&self) -> &GroupInfo {
                        self.core.group_info()
                    }

                    #[inline( always )]
                    fn create_cache(&self) -> Cache {
                        let mut cache = self.core.create_cache();
                        cache.revhybrid = self.hybrid.create_cache();
                        cache
                    }

                    #[inline( always )]
                    fn reset_cache(&self, cache: &mut Cache) {
                        self.core.reset_cache(cache);
                        cache.revhybrid.reset(&self.hybrid);
                    }

                    fn is_accelerated(&self) -> bool {
                        self.preinner.is_fast()
                    }

                    fn memory_usage(&self) -> usize {
                        self.core.memory_usage()
                            + self.preinner.memory_usage()
                            + self.nfarev.memory_usage()
                            + self.dfa.memory_usage()
                    }

                    #[inline( always )]
                    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search(cache, input);
                        }
                        match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse inner optimization failed: {_err}");
                                self.core.search(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!("reverse inner fast search failed: {_err}");
                                self.core.search_nofail(cache, input)
                            }
                            Ok(matornot) => matornot,
                        }
                    }

                    #[inline( always )]
                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_half(cache, input);
                        }
                        match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse inner half optimization failed: {_err}");
                                self.core.search_half(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!("reverse inner fast half search failed: {_err}");
                                self.core.search_half_nofail(cache, input)
                            }
                            Ok(None) => None,
                            Ok(Some(m)) => Some(HalfMatch::new(m.pattern(), m.end())),
                        }
                    }

                    #[inline( always )]
                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if input.get_anchored().is_anchored() {
                            return self.core.is_match(cache, input);
                        }
                        match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse inner half optimization failed: {_err}");
                                self.core.is_match_nofail(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!("reverse inner fast half search failed: {_err}");
                                self.core.is_match_nofail(cache, input)
                            }
                            Ok(None) => false,
                            Ok(Some(_)) => true,
                        }
                    }

                    #[inline( always )]
                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_slots(cache, input, slots);
                        }
                        
                        if !self.core.is_capture_search_needed(slots.len()) {
                            trace!("asked for slots unnecessarily, trying fast path");
                            let m = self.search(cache, input)?;
                            copy_match_to_slots(m, slots);
                            
                            return Some(m.pattern());
                        }
                        let m = match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse inner captures optimization failed: {_err}");
                                return self.core.search_slots(cache, input, slots);
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!("reverse inner fast captures search failed: {_err}");
                                return self.core.search_slots_nofail(cache, input, slots);
                            }
                            Ok(None) => return None,
                            Ok(Some(m)) => m,
                        };
                        trace!(
                            "match found at {}..{} in capture search, \
                            using another engine to find captures",
                            m.start(),
                            m.end(),
                        );
                        let input = input
                            .clone()
                            .span(m.start()..m.end())
                            .anchored(Anchored::Pattern(m.pattern()));
                        self.core.search_slots_nofail(cache, &input, slots)
                    }

                    #[inline( always )]
                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.core.which_overlapping_matches(cache, input, patset)
                    }
                }
                /// Copies the offsets in the given match to the corresponding positions in
                #[inline( always )] fn copy_match_to_slots(m: Match, slots: &mut [Option<NonMaxUsize>])
                {
                    let slot_start = m.pattern().as_usize() * 2;
                    let slot_end = slot_start + 1;
                    if let Some(slot) = slots.get_mut(slot_start) {
                        *slot = NonMaxUsize::new(m.start());
                    }
                    if let Some(slot) = slots.get_mut(slot_end) {
                        *slot = NonMaxUsize::new(m.end());
                    }
                }
            }

            pub mod wrappers
            {
                /*!
                This module contains a boat load of wrappers around each of our internal regex
                engines.*/
                use ::
                {
                    *,
                };
                /*
                use ::vec::Vec;

                use crate::{
                    meta::{
                        error::{BuildError, RetryError, RetryFailError},
                        regex::RegexInfo,
                    },
                    nfa::thompson::{pikevm, NFA},
                    util::{prefilter::Prefilter, primitives::NonMaxUsize},
                    HalfMatch, Input, Match, MatchKind, PatternID, PatternSet,
                };

                use crate::dfa;
                use crate::dfa::onepass;
                #[cfg(feature = "hybrid")]
                use crate::hybrid;
                #[cfg(feature = "nfa-backtrack")]
                use crate::nfa::thompson::backtrack;
                */
                #[derive(Debug)]
                pub struct PikeVM(PikeVMEngine);

                impl PikeVM {
                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<PikeVM, BuildError> {
                        PikeVMEngine::new(info, pre, nfa).map(PikeVM)
                    }

                    pub fn create_cache(&self) -> PikeVMCache {
                        PikeVMCache::new(self)
                    }

                    #[inline( always )]
                    pub fn get(&self) -> &PikeVMEngine {
                        &self.0
                    }
                }

                #[derive(Debug)]
                pub struct PikeVMEngine(pikevm::PikeVM);

                impl PikeVMEngine {
                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<PikeVMEngine, BuildError> {
                        let pikevm_config = pikevm::Config::new()
                            .match_kind(info.config().get_match_kind())
                            .prefilter(pre);
                        let engine = pikevm::Builder::new()
                            .configure(pikevm_config)
                            .build_from_nfa(nfa.clone())
                            .map_err(BuildError::nfa)?;
                        debug!("PikeVM built");
                        Ok(PikeVMEngine(engine))
                    }

                    #[inline( always )]
                    pub fn is_match(
                        &self,
                        cache: &mut PikeVMCache,
                        input: &Input<'_>,
                    ) -> bool {
                        self.0.is_match(cache.0.as_mut().unwrap(), input.clone())
                    }

                    #[inline( always )]
                    pub fn search_slots(
                        &self,
                        cache: &mut PikeVMCache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        self.0.search_slots(cache.0.as_mut().unwrap(), input, slots)
                    }

                    #[inline( always )]
                    pub fn which_overlapping_matches(
                        &self,
                        cache: &mut PikeVMCache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.0.which_overlapping_matches(
                            cache.0.as_mut().unwrap(),
                            input,
                            patset,
                        )
                    }
                }

                #[derive(Clone, Debug)]
                pub struct PikeVMCache(Option<pikevm::Cache>);

                impl PikeVMCache {
                    pub fn none() -> PikeVMCache {
                        PikeVMCache(None)
                    }

                    pub fn new(builder: &PikeVM) -> PikeVMCache {
                        PikeVMCache(Some(builder.get().0.create_cache()))
                    }

                    pub fn reset(&mut self, builder: &PikeVM) {
                        self.0.as_mut().unwrap().reset(&builder.get().0);
                    }

                    pub fn memory_usage(&self) -> usize {
                        self.0.as_ref().map_or(0, |c| c.memory_usage())
                    }
                }

                #[derive(Debug)]
                pub struct BoundedBacktracker(Option<BoundedBacktrackerEngine>);

                impl BoundedBacktracker {
                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<BoundedBacktracker, BuildError> {
                        BoundedBacktrackerEngine::new(info, pre, nfa).map(BoundedBacktracker)
                    }

                    pub fn create_cache(&self) -> BoundedBacktrackerCache {
                        BoundedBacktrackerCache::new(self)
                    }

                    #[inline( always )]
                    pub fn get(
                        &self,
                        input: &Input<'_>,
                    ) -> Option<&BoundedBacktrackerEngine> {
                        let engine = self.0.as_ref()?;
                        
                        if input.get_earliest() && input.haystack().len() > 128 {
                            return None;
                        }
                        
                        if input.get_span().len() > engine.max_haystack_len() {
                            return None;
                        }
                        Some(engine)
                    }
                }

                #[derive(Debug)]
                pub struct BoundedBacktrackerEngine(
                    #[cfg(feature = "nfa-backtrack")] backtrack::BoundedBacktracker,
                    #[cfg(not(feature = "nfa-backtrack"))] (),
                );

                impl BoundedBacktrackerEngine {
                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<Option<BoundedBacktrackerEngine>, BuildError> {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            if !info.config().get_backtrack()
                                || info.config().get_match_kind() != MatchKind::LeftmostFirst
                            {
                                return Ok(None);
                            }
                            let backtrack_config = backtrack::Config::new().prefilter(pre);
                            let engine = backtrack::Builder::new()
                                .configure(backtrack_config)
                                .build_from_nfa(nfa.clone())
                                .map_err(BuildError::nfa)?;
                            debug!(
                                "BoundedBacktracker built (max haystack length: {:?})",
                                engine.max_haystack_len()
                            );
                            Ok(Some(BoundedBacktrackerEngine(engine)))
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            Ok(None)
                        }
                    }

                    #[inline( always )]
                    pub fn is_match(
                        &self,
                        cache: &mut BoundedBacktrackerCache,
                        input: &Input<'_>,
                    ) -> bool {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            self.0
                                .try_is_match(cache.0.as_mut().unwrap(), input.clone())
                                .unwrap()
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn search_slots(
                        &self,
                        cache: &mut BoundedBacktrackerCache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            self.0
                                .try_search_slots(cache.0.as_mut().unwrap(), input, slots)
                                .unwrap()
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    fn max_haystack_len(&self) -> usize {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            self.0.max_haystack_len()
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            unreachable!()
                        }
                    }
                }

                #[derive(Clone, Debug)]
                pub struct BoundedBacktrackerCache(
                    #[cfg(feature = "nfa-backtrack")] Option<backtrack::Cache>,
                    #[cfg(not(feature = "nfa-backtrack"))] (),
                );

                impl BoundedBacktrackerCache {
                    pub fn none() -> BoundedBacktrackerCache {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            BoundedBacktrackerCache(None)
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            BoundedBacktrackerCache(())
                        }
                    }

                    pub fn new(
                        builder: &BoundedBacktracker,
                    ) -> BoundedBacktrackerCache {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            BoundedBacktrackerCache(
                                builder.0.as_ref().map(|e| e.0.create_cache()),
                            )
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            BoundedBacktrackerCache(())
                        }
                    }

                    pub fn reset(&mut self, builder: &BoundedBacktracker) {
                        #[cfg(feature = "nfa-backtrack")]
                        if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                        #[cfg(feature = "nfa-backtrack")]
                        {
                            self.0.as_ref().map_or(0, |c| c.memory_usage())
                        }
                        #[cfg(not(feature = "nfa-backtrack"))]
                        {
                            0
                        }
                    }
                }

                #[derive(Debug)]
                pub struct OnePass(Option<OnePassEngine>);

                impl OnePass {
                    pub fn new(info: &RegexInfo, nfa: &NFA) -> OnePass {
                        OnePass(OnePassEngine::new(info, nfa))
                    }

                    pub fn create_cache(&self) -> OnePassCache {
                        OnePassCache::new(self)
                    }

                    #[inline( always )]
                    pub fn get(&self, input: &Input<'_>) -> Option<&OnePassEngine> {
                        let engine = self.0.as_ref()?;
                        
                        if !input.get_anchored().is_anchored()
                            && !engine.get_nfa().is_always_start_anchored()
                        {
                            return None;
                        }
                        Some(engine)
                    }

                    pub fn memory_usage(&self) -> usize {
                        self.0.as_ref().map_or(0, |e| e.memory_usage())
                    }
                }

                #[derive(Debug)]
                pub struct OnePassEngine(
                    #[cfg(feature = "dfa-onepass")] onepass::DFA,
                    #[cfg(not(feature = "dfa-onepass"))] (),
                );

                impl OnePassEngine {
                    pub fn new(info: &RegexInfo, nfa: &NFA) -> Option<OnePassEngine> {
                                {
                            if !info.config().get_onepass() {
                                return None;
                            }
                            
                            if info.props_union().explicit_captures_len() == 0
                                && !info.props_union().look_set().contains_word_unicode()
                            {
                                debug!("not building OnePass because it isn't worth it");
                                return None;
                            }
                            let onepass_config = onepass::Config::new()
                                .match_kind(info.config().get_match_kind())
                                .starts_for_each_pattern(true)
                                .byte_classes(info.config().get_byte_classes())
                                .size_limit(info.config().get_onepass_size_limit());
                            let result = onepass::Builder::new()
                                .configure(onepass_config)
                                .build_from_nfa(nfa.clone());
                            let engine = match result {
                                Ok(engine) => engine,
                                Err(_err) => {
                                    debug!("OnePass failed to build: {_err}");
                                    return None;
                                }
                            };
                            debug!("OnePass built, {} bytes", engine.memory_usage());
                            Some(OnePassEngine(engine))
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            None
                        }
                    }

                    #[inline( always )]
                    pub fn search_slots(
                        &self,
                        cache: &mut OnePassCache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                                {
                            self.0
                                .try_search_slots(cache.0.as_mut().unwrap(), input, slots)
                                .unwrap()
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            unreachable!()
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                                {
                            self.0.memory_usage()
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    fn get_nfa(&self) -> &NFA {
                                {
                            self.0.get_nfa()
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            unreachable!()
                        }
                    }
                }

                #[derive(Clone, Debug)]
                pub struct OnePassCache(
                    #[cfg(feature = "dfa-onepass")] Option<onepass::Cache>,
                    #[cfg(not(feature = "dfa-onepass"))] (),
                );

                impl OnePassCache {
                    pub fn none() -> OnePassCache {
                                {
                            OnePassCache(None)
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            OnePassCache(())
                        }
                    }

                    pub fn new(builder: &OnePass) -> OnePassCache {
                                {
                            OnePassCache(builder.0.as_ref().map(|e| e.0.create_cache()))
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            OnePassCache(())
                        }
                    }

                    pub fn reset(&mut self, builder: &OnePass) {
                                if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                                {
                            self.0.as_ref().map_or(0, |c| c.memory_usage())
                        }
                        #[cfg(not(feature = "dfa-onepass"))]
                        {
                            0
                        }
                    }
                }

                #[derive(Debug)]
                pub struct Hybrid(Option<HybridEngine>);

                impl Hybrid {
                    pub fn none() -> Hybrid {
                        Hybrid(None)
                    }

                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> Hybrid {
                        Hybrid(HybridEngine::new(info, pre, nfa, nfarev))
                    }

                    pub fn create_cache(&self) -> HybridCache {
                        HybridCache::new(self)
                    }

                    #[inline( always )]
                    pub fn get(&self, _input: &Input<'_>) -> Option<&HybridEngine> {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }

                    pub fn is_some(&self) -> bool {
                        self.0.is_some()
                    }
                }

                #[derive(Debug)]
                pub struct HybridEngine(
                    #[cfg(feature = "hybrid")] hybrid::regex::Regex,
                    #[cfg(not(feature = "hybrid"))] (),
                );

                impl HybridEngine {
                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> Option<HybridEngine> {
                        #[cfg(feature = "hybrid")]
                        {
                            if !info.config().get_hybrid() {
                                return None;
                            }
                            let dfa_config = hybrid::dfa::Config::new()
                                .match_kind(info.config().get_match_kind())
                                .prefilter(pre.clone())
                                .starts_for_each_pattern(true)
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states(pre.is_some())
                                .cache_capacity(info.config().get_hybrid_cache_capacity())
                                .skip_cache_capacity_check(false)
                                .minimum_cache_clear_count(Some(3))
                                .minimum_bytes_per_state(Some(10));
                            let result = hybrid::dfa::Builder::new()
                                .configure(dfa_config.clone())
                                .build_from_nfa(nfa.clone());
                            let fwd = match result {
                                Ok(fwd) => fwd,
                                Err(_err) => {
                                    debug!("forward lazy DFA failed to build: {_err}");
                                    return None;
                                }
                            };
                            let result = hybrid::dfa::Builder::new()
                                .configure(
                                    dfa_config
                                        .clone()
                                        .match_kind(MatchKind::All)
                                        .prefilter(None)
                                        .specialize_start_states(false),
                                )
                                .build_from_nfa(nfarev.clone());
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    debug!("reverse lazy DFA failed to build: {_err}");
                                    return None;
                                }
                            };
                            let engine =
                                hybrid::regex::Builder::new().build_from_dfas(fwd, rev);
                            debug!("lazy DFA built");
                            Some(HybridEngine(engine))
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            None
                        }
                    }

                    #[inline( always )]
                    pub fn try_search(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, RetryFailError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let cache = cache.0.as_mut().unwrap();
                            self.0.try_search(cache, input).map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let fwd = self.0.forward();
                            let mut fwdcache = cache.0.as_mut().unwrap().as_parts_mut().0;
                            fwd.try_search_fwd(&mut fwdcache, input).map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd_stopat(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let dfa = self.0.forward();
                            let mut cache = cache.0.as_mut().unwrap().as_parts_mut().0;
                            crate::meta::stopat::hybrid_try_search_half_fwd(
                                dfa, &mut cache, input,
                            )
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let rev = self.0.reverse();
                            let mut revcache = cache.0.as_mut().unwrap().as_parts_mut().1;
                            rev.try_search_rev(&mut revcache, input).map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let dfa = self.0.reverse();
                            let mut cache = cache.0.as_mut().unwrap().as_parts_mut().1;
                            crate::meta::limited::hybrid_try_search_half_rev(
                                dfa, &mut cache, input, min_start,
                            )
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline] pub fn try_which_overlapping_matches(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), RetryFailError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let fwd = self.0.forward();
                            let mut fwdcache = cache.0.as_mut().unwrap().as_parts_mut().0;
                            fwd.try_which_overlapping_matches(&mut fwdcache, input, patset)
                                .map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }
                }

                #[derive(Clone, Debug)]
                pub struct HybridCache(
                    #[cfg(feature = "hybrid")] Option<hybrid::regex::Cache>,
                    #[cfg(not(feature = "hybrid"))] (),
                );

                impl HybridCache {
                    pub fn none() -> HybridCache {
                        #[cfg(feature = "hybrid")]
                        {
                            HybridCache(None)
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            HybridCache(())
                        }
                    }

                    pub fn new(builder: &Hybrid) -> HybridCache {
                        #[cfg(feature = "hybrid")]
                        {
                            HybridCache(builder.0.as_ref().map(|e| e.0.create_cache()))
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            HybridCache(())
                        }
                    }

                    pub fn reset(&mut self, builder: &Hybrid) {
                        #[cfg(feature = "hybrid")]
                        if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                        #[cfg(feature = "hybrid")]
                        {
                            self.0.as_ref().map_or(0, |c| c.memory_usage())
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            0
                        }
                    }
                }

                #[derive(Debug)]
                pub struct DFA(Option<DFAEngine>);

                impl DFA {
                    pub fn none() -> DFA {
                        DFA(None)
                    }

                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> DFA {
                        DFA(DFAEngine::new(info, pre, nfa, nfarev))
                    }

                    #[inline( always )]
                    pub fn get(&self, _input: &Input<'_>) -> Option<&DFAEngine> {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }

                    pub fn is_some(&self) -> bool {
                        self.0.is_some()
                    }

                    pub fn memory_usage(&self) -> usize {
                        self.0.as_ref().map_or(0, |e| e.memory_usage())
                    }
                }

                #[derive(Debug)]
                pub struct DFAEngine(
                    #[cfg(feature = "dfa-build")] dfa::regex::Regex,
                    #[cfg(not(feature = "dfa-build"))] (),
                );

                impl DFAEngine {
                    pub fn new(
                        info: &RegexInfo,
                        pre: Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> Option<DFAEngine> {
                                {
                            if !info.config().get_dfa() {
                                return None;
                            }
                            // If our NFA is anything but small, don't even bother with a DFA.
                            if let Some(state_limit) = info.config().get_dfa_state_limit()
                            {
                                if nfa.states().len() > state_limit {
                                    debug!(
                                        "skipping full DFA because NFA has {} states, \
                                        which exceeds the heuristic limit of {}",
                                        nfa.states().len(),
                                        state_limit,
                                    );
                                    return None;
                                }
                            }
                            let size_limit = info.config().get_dfa_size_limit().map(|n| n / 4);
                            let dfa_config = dfa::dense::Config::new()
                                .match_kind(info.config().get_match_kind())
                                .prefilter(pre.clone())
                                .starts_for_each_pattern(true)
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states(pre.is_some())
                                .determinize_size_limit(size_limit)
                                .dfa_size_limit(size_limit);
                            let result = dfa::dense::Builder::new()
                                .configure(dfa_config.clone())
                                .build_from_nfa(&nfa);
                            let fwd = match result {
                                Ok(fwd) => fwd,
                                Err(_err) => {
                                    debug!("forward full DFA failed to build: {_err}");
                                    return None;
                                }
                            };
                            let result = dfa::dense::Builder::new()
                                .configure(
                                    dfa_config
                                        .clone()
                                        .start_kind(dfa::StartKind::Anchored)
                                        .match_kind(MatchKind::All)
                                        .prefilter(None)
                                        .specialize_start_states(false),
                                )
                                .build_from_nfa(&nfarev);
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    debug!("reverse full DFA failed to build: {_err}");
                                    return None;
                                }
                            };
                            let engine = dfa::regex::Builder::new().build_from_dfas(fwd, rev);
                            debug!(
                                "fully compiled forward and reverse DFAs built, {} bytes",
                                engine.forward().memory_usage()
                                    + engine.reverse().memory_usage(),
                            );
                            Some(DFAEngine(engine))
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            None
                        }
                    }

                    #[inline( always )]
                    pub fn try_search(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, RetryFailError> {
                                {
                            self.0.try_search(input).map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                                {
                            use crate::dfa::Automaton;
                            self.0.forward().try_search_fwd(input).map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd_stopat(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                                {
                            let dfa = self.0.forward();
                            crate::meta::stopat::dfa_try_search_half_fwd(dfa, input)
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                                {
                            use crate::dfa::Automaton;
                            self.0.reverse().try_search_rev(&input).map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                                {
                            let dfa = self.0.reverse();
                            crate::meta::limited::dfa_try_search_half_rev(
                                dfa, input, min_start,
                            )
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    #[inline] pub fn try_which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), RetryFailError> {
                                {
                            use crate::dfa::Automaton;
                            self.0
                                .forward()
                                .try_which_overlapping_matches(input, patset)
                                .map_err(|e| e.into())
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                                {
                            self.0.forward().memory_usage() + self.0.reverse().memory_usage()
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }
                }

                #[derive(Debug)]
                pub struct ReverseHybrid(Option<ReverseHybridEngine>);

                impl ReverseHybrid {
                    pub fn none() -> ReverseHybrid {
                        ReverseHybrid(None)
                    }

                    pub fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseHybrid {
                        ReverseHybrid(ReverseHybridEngine::new(info, nfarev))
                    }

                    pub fn create_cache(&self) -> ReverseHybridCache {
                        ReverseHybridCache::new(self)
                    }

                    #[inline( always )]
                    pub fn get(
                        &self,
                        _input: &Input<'_>,
                    ) -> Option<&ReverseHybridEngine> {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }
                }

                #[derive(Debug)]
                pub struct ReverseHybridEngine(
                    #[cfg(feature = "hybrid")] hybrid::dfa::DFA,
                    #[cfg(not(feature = "hybrid"))] (),
                );

                impl ReverseHybridEngine {
                    pub fn new(
                        info: &RegexInfo,
                        nfarev: &NFA,
                    ) -> Option<ReverseHybridEngine> {
                        #[cfg(feature = "hybrid")]
                        {
                            if !info.config().get_hybrid() {
                                return None;
                            }
                            let dfa_config = hybrid::dfa::Config::new()
                                .match_kind(MatchKind::All)
                                .prefilter(None)
                                .starts_for_each_pattern(false)
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states(false)
                                .cache_capacity(info.config().get_hybrid_cache_capacity())
                                .skip_cache_capacity_check(false)
                                .minimum_cache_clear_count(Some(3))
                                .minimum_bytes_per_state(Some(10));
                            let result = hybrid::dfa::Builder::new()
                                .configure(dfa_config)
                                .build_from_nfa(nfarev.clone());
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    debug!("lazy reverse DFA failed to build: {_err}");
                                    return None;
                                }
                            };
                            debug!("lazy reverse DFA built");
                            Some(ReverseHybridEngine(rev))
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            None
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        cache: &mut ReverseHybridCache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        #[cfg(feature = "hybrid")]
                        {
                            let dfa = &self.0;
                            let mut cache = cache.0.as_mut().unwrap();
                            crate::meta::limited::hybrid_try_search_half_rev(
                                dfa, &mut cache, input, min_start,
                            )
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            unreachable!()
                        }
                    }
                }

                #[derive(Clone, Debug)]
                pub struct ReverseHybridCache(
                    #[cfg(feature = "hybrid")] Option<hybrid::dfa::Cache>,
                    #[cfg(not(feature = "hybrid"))] (),
                );

                impl ReverseHybridCache {
                    pub fn none() -> ReverseHybridCache {
                        #[cfg(feature = "hybrid")]
                        {
                            ReverseHybridCache(None)
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            ReverseHybridCache(())
                        }
                    }

                    pub fn new(builder: &ReverseHybrid) -> ReverseHybridCache {
                        #[cfg(feature = "hybrid")]
                        {
                            ReverseHybridCache(builder.0.as_ref().map(|e| e.0.create_cache()))
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            ReverseHybridCache(())
                        }
                    }

                    pub fn reset(&mut self, builder: &ReverseHybrid) {
                        #[cfg(feature = "hybrid")]
                        if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                        #[cfg(feature = "hybrid")]
                        {
                            self.0.as_ref().map_or(0, |c| c.memory_usage())
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            0
                        }
                    }
                }

                #[derive(Debug)]
                pub struct ReverseDFA(Option<ReverseDFAEngine>);

                impl ReverseDFA {
                    pub fn none() -> ReverseDFA {
                        ReverseDFA(None)
                    }

                    pub fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseDFA {
                        ReverseDFA(ReverseDFAEngine::new(info, nfarev))
                    }

                    #[inline( always )]
                    pub fn get(&self, _input: &Input<'_>) -> Option<&ReverseDFAEngine> {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }

                    pub fn is_some(&self) -> bool {
                        self.0.is_some()
                    }

                    pub fn memory_usage(&self) -> usize {
                        self.0.as_ref().map_or(0, |e| e.memory_usage())
                    }
                }

                #[derive(Debug)]
                pub struct ReverseDFAEngine(
                    #[cfg(feature = "dfa-build")] dfa::dense::DFA<Vec<u32>>,
                    #[cfg(not(feature = "dfa-build"))] (),
                );

                impl ReverseDFAEngine {
                    pub fn new(
                        info: &RegexInfo,
                        nfarev: &NFA,
                    ) -> Option<ReverseDFAEngine> {
                                {
                            if !info.config().get_dfa() {
                                return None;
                            }
                            // If our NFA is anything but small, don't even bother with a DFA.
                            if let Some(state_limit) = info.config().get_dfa_state_limit()
                            {
                                if nfarev.states().len() > state_limit {
                                    debug!(
                                        "skipping full reverse DFA because NFA has {} states, \
                                        which exceeds the heuristic limit of {}",
                                        nfarev.states().len(),
                                        state_limit,
                                    );
                                    return None;
                                }
                            }
                            let size_limit = info.config().get_dfa_size_limit().map(|n| n / 2);
                            let dfa_config = dfa::dense::Config::new()
                                .match_kind(MatchKind::All)
                                .prefilter(None)
                                .accelerate(false)
                                .start_kind(dfa::StartKind::Anchored)
                                .starts_for_each_pattern(false)
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states(false)
                                .determinize_size_limit(size_limit)
                                .dfa_size_limit(size_limit);
                            let result = dfa::dense::Builder::new()
                                .configure(dfa_config)
                                .build_from_nfa(&nfarev);
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    debug!("full reverse DFA failed to build: {_err}");
                                    return None;
                                }
                            };
                            debug!(
                                "fully compiled reverse DFA built, {} bytes",
                                rev.memory_usage()
                            );
                            Some(ReverseDFAEngine(rev))
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            None
                        }
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                                {
                            let dfa = &self.0;
                            crate::meta::limited::dfa_try_search_half_rev(
                                dfa, input, min_start,
                            )
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }

                    pub fn memory_usage(&self) -> usize {
                                {
                            self.0.memory_usage()
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            unreachable!()
                        }
                    }
                }
            }

        }

        pub mod nfa
        {
            /*! 
            Provides non-deterministic finite automata (NFA) and regex engines that use them.*/
            use ::
            {
                *,
            };
            /*
            */
            pub mod thompson
            {
                /*!
                Defines a Thompson NFA and provides the [`PikeVM`](pikevm::PikeVM) and
                [`BoundedBacktracker`](backtrack::BoundedBacktracker) regex engines. */
                use ::
                {
                    *,
                };
                /*
                pub use self::{
                    builder::Builder,
                    error::BuildError,
                    nfa::{
                        DenseTransitions, PatternIter, SparseTransitions, State, Transition,
                        NFA,
                    },
                };
                #[cfg(feature = "syntax")]
                pub use compiler::{Compiler, Config, WhichCaptures};
                */
                pub mod backtrack
                {
                    /*!
                    An NFA backed bounded backtracker for executing regex searches with capturing
                    groups. */
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::{vec, vec::Vec};

                    use crate::{
                        nfa::thompson::{self, BuildError, State, NFA},
                        util::{
                            captures::Captures,
                            empty, iter,
                            prefilter::Prefilter,
                            primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},
                            search::{Anchored, HalfMatch, Input, Match, MatchError, Span},
                        },
                    };
                    */
                    /// Returns the minimum visited capacity for the given haystack.
                    pub fn min_visited_capacity(nfa: &NFA, input: &Input<'_>) -> usize {
                        div_ceil(nfa.states().len() * (input.get_span().len() + 1), 8)
                    }
                    /// The configuration used for building a bounded backtracker.
                    #[derive(Clone, Debug, Default)]
                    pub struct Config {
                        pre: Option<Option<Prefilter>>,
                        visited_capacity: Option<usize>,
                    }

                    impl Config {
                        /// Return a new default regex configuration.
                        pub fn new() -> Config {
                            Config::default()
                        }
                        /// Set a prefilter to be used whenever a start state is entered.
                        pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
                            self.pre = Some(pre);
                            self
                        }
                        /// Set the visited capacity used to bound backtracking.
                        pub fn visited_capacity(mut self, capacity: usize) -> Config {
                            self.visited_capacity = Some(capacity);
                            self
                        }
                        /// Returns the prefilter set in this configuration, if one at all.
                        pub fn get_prefilter(&self) -> Option<&Prefilter> {
                            self.pre.as_ref().unwrap_or(&None).as_ref()
                        }
                        /// Returns the configured visited capacity.
                        pub fn get_visited_capacity(&self) -> usize {
                            const DEFAULT: usize = 256 * (1 << 10); // 256 KB
                            self.visited_capacity.unwrap_or(DEFAULT)
                        }
                        /// Overwrite the default configuration such that the options in `o` are
                        pub fn overwrite(&self, o: Config) -> Config {
                            Config {
                                pre: o.pre.or_else(|| self.pre.clone()),
                                visited_capacity: o.visited_capacity.or(self.visited_capacity),
                            }
                        }
                    }
                    /// A builder for a bounded backtracker.
                    #[derive(Clone, Debug)]
                    pub struct Builder {
                        config: Config,
                            thompson: thompson::Compiler,
                    }

                    impl Builder {
                        /// Create a new BoundedBacktracker builder with its default configuration.
                        pub fn new() -> Builder {
                            Builder {
                                config: Config::default(),
                                            thompson: thompson::Compiler::new(),
                            }
                        }
                        /// Build a `BoundedBacktracker` from the given pattern.
                            pub fn build(
                            &self,
                            pattern: &str,
                        ) -> Result<BoundedBacktracker, BuildError> {
                            self.build_many(&[pattern])
                        }
                        /// Build a `BoundedBacktracker` from the given patterns.
                            pub fn build_many<P: AsRef<str>>(
                            &self,
                            patterns: &[P],
                        ) -> Result<BoundedBacktracker, BuildError> {
                            let nfa = self.thompson.build_many(patterns)?;
                            self.build_from_nfa(nfa)
                        }
                        /// Build a `BoundedBacktracker` directly from its NFA.
                        pub fn build_from_nfa(
                            &self,
                            nfa: NFA,
                        ) -> Result<BoundedBacktracker, BuildError> {
                            nfa.look_set_any().available().map_err(BuildError::word)?;
                            Ok(BoundedBacktracker { config: self.config.clone(), nfa })
                        }
                        /// Apply the given `BoundedBacktracker` configuration options to this
                        pub fn configure(&mut self, config: Config) -> &mut Builder {
                            self.config = self.config.overwrite(config);
                            self
                        }
                        /// Set the syntax configuration for this builder using
                            pub fn syntax(
                            &mut self,
                            config: crate::util::syntax::Config,
                        ) -> &mut Builder {
                            self.thompson.syntax(config);
                            self
                        }
                        /// Set the Thompson NFA configuration for this builder using
                            pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                            self.thompson.configure(config);
                            self
                        }
                    }
                    /// A backtracking regex engine that bounds its execution to avoid exponential
                    #[derive(Clone, Debug)]
                    pub struct BoundedBacktracker {
                        config: Config,
                        nfa: NFA,
                    }

                    impl BoundedBacktracker {
                        /// Parse the given regular expression using the default configuration and
                            pub fn new(pattern: &str) -> Result<BoundedBacktracker, BuildError> {
                            BoundedBacktracker::builder().build(pattern)
                        }
                        /// Like `new`, but parses multiple patterns into a single "multi regex."
                            pub fn new_many<P: AsRef<str>>(
                            patterns: &[P],
                        ) -> Result<BoundedBacktracker, BuildError> {
                            BoundedBacktracker::builder().build_many(patterns)
                        }
                        /// # Example
                        pub fn new_from_nfa(nfa: NFA) -> Result<BoundedBacktracker, BuildError> {
                            BoundedBacktracker::builder().build_from_nfa(nfa)
                        }
                        /// Create a new `BoundedBacktracker` that matches every input.
                        pub fn always_match() -> Result<BoundedBacktracker, BuildError> {
                            let nfa = thompson::NFA::always_match();
                            BoundedBacktracker::new_from_nfa(nfa)
                        }
                        /// Create a new `BoundedBacktracker` that never matches any input.
                        pub fn never_match() -> Result<BoundedBacktracker, BuildError> {
                            let nfa = thompson::NFA::never_match();
                            BoundedBacktracker::new_from_nfa(nfa)
                        }
                        /// Return a default configuration for a `BoundedBacktracker`.
                        pub fn config() -> Config {
                            Config::new()
                        }
                        /// Return a builder for configuring the construction of a
                        pub fn builder() -> Builder {
                            Builder::new()
                        }
                        /// Create a new cache for this regex.
                        pub fn create_cache(&self) -> Cache {
                            Cache::new(self)
                        }
                        /// Create a new empty set of capturing groups that is guaranteed to be
                        pub fn create_captures(&self) -> Captures {
                            Captures::all(self.get_nfa().group_info().clone())
                        }
                        /// Reset the given cache such that it can be used for searching with the
                        pub fn reset_cache(&self, cache: &mut Cache) {
                            cache.reset(self);
                        }
                        /// Returns the total number of patterns compiled into this
                        pub fn pattern_len(&self) -> usize {
                            self.nfa.pattern_len()
                        }
                        /// Return the config for this `BoundedBacktracker`.
                        #[inline]
                        pub fn get_config(&self) -> &Config {
                            &self.config
                        }
                        /// Returns a reference to the underlying NFA.
                        #[inline]
                        pub fn get_nfa(&self) -> &NFA {
                            &self.nfa
                        }
                        /// Returns the maximum haystack length supported by this backtracker.
                        #[inline]
                        pub fn max_haystack_len(&self) -> usize {
                            let capacity = 8 * self.get_config().get_visited_capacity();
                            let blocks = div_ceil(capacity, Visited::BLOCK_SIZE);
                            let real_capacity = blocks.saturating_mul(Visited::BLOCK_SIZE);
                            (real_capacity / self.nfa.states().len()).saturating_sub(1)
                        }
                    }

                    impl BoundedBacktracker {
                        /// Returns true if and only if this regex matches the given haystack.
                        #[inline]
                        pub fn try_is_match<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Result<bool, MatchError> {
                            let input = input.into().earliest(true);
                            self.try_search_slots(cache, &input, &mut []).map(|pid| pid.is_some())
                        }
                        /// Executes a leftmost forward search and returns a `Match` if one exists.
                        #[inline]
                        pub fn try_find<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Result<Option<Match>, MatchError> {
                            let input = input.into();
                            if self.get_nfa().pattern_len() == 1 {
                                let mut slots = [None, None];
                                let pid = match self.try_search_slots(cache, &input, &mut slots)? {
                                    None => return Ok(None),
                                    Some(pid) => pid,
                                };
                                let start = match slots[0] {
                                    None => return Ok(None),
                                    Some(s) => s.get(),
                                };
                                let end = match slots[1] {
                                    None => return Ok(None),
                                    Some(s) => s.get(),
                                };
                                return Ok(Some(Match::new(pid, Span { start, end })));
                            }
                            let ginfo = self.get_nfa().group_info();
                            let slots_len = ginfo.implicit_slot_len();
                            let mut slots = vec![None; slots_len];
                            let pid = match self.try_search_slots(cache, &input, &mut slots)? {
                                None => return Ok(None),
                                Some(pid) => pid,
                            };
                            let start = match slots[pid.as_usize() * 2] {
                                None => return Ok(None),
                                Some(s) => s.get(),
                            };
                            let end = match slots[pid.as_usize() * 2 + 1] {
                                None => return Ok(None),
                                Some(s) => s.get(),
                            };
                            Ok(Some(Match::new(pid, Span { start, end })))
                        }
                        /// Executes a leftmost forward search and writes the spans of capturing
                        #[inline]
                        pub fn try_captures<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                            caps: &mut Captures,
                        ) -> Result<(), MatchError> {
                            self.try_search(cache, &input.into(), caps)
                        }
                        /// Returns an iterator over all non-overlapping leftmost matches in the
                        #[inline]
                        pub fn try_find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> TryFindMatches<'r, 'c, 'h> {
                            let caps = Captures::matches(self.get_nfa().group_info().clone());
                            let it = iter::Searcher::new(input.into());
                            TryFindMatches { re: self, cache, caps, it }
                        }
                        /// Returns an iterator over all non-overlapping `Captures` values. If no
                        #[inline]
                        pub fn try_captures_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> TryCapturesMatches<'r, 'c, 'h> {
                            let caps = self.create_captures();
                            let it = iter::Searcher::new(input.into());
                            TryCapturesMatches { re: self, cache, caps, it }
                        }
                    }

                    impl BoundedBacktracker {
                        /// Executes a leftmost forward search and writes the spans of capturing
                        #[inline]
                        pub fn try_search(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            caps: &mut Captures,
                        ) -> Result<(), MatchError> {
                            caps.set_pattern(None);
                            let pid = self.try_search_slots(cache, input, caps.slots_mut())?;
                            caps.set_pattern(pid);
                            Ok(())
                        }
                        /// Executes a leftmost forward search and writes the spans of capturing
                        #[inline]
                        pub fn try_search_slots(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<PatternID>, MatchError> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            if !utf8empty {
                                let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;
                                return Ok(maybe_hm.map(|hm| hm.pattern()));
                            }
                            // See PikeVM::try_search_slots for why we do this.
                            let min = self.get_nfa().group_info().implicit_slot_len();
                            if slots.len() >= min {
                                let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;
                                return Ok(maybe_hm.map(|hm| hm.pattern()));
                            }
                            
                            if self.get_nfa().pattern_len() == 1 {
                                let mut enough = [None, None];
                                let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                                slots.copy_from_slice(&enough[..slots.len()]);
                                return Ok(got.map(|hm| hm.pattern()));
                            }
                            let mut enough = vec![None; min];
                            let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                            slots.copy_from_slice(&enough[..slots.len()]);
                            Ok(got.map(|hm| hm.pattern()))
                        }
                        /// This is the actual implementation of `try_search_slots_imp` that
                        #[inline(never)]
                        fn try_search_slots_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<HalfMatch>, MatchError> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            let hm = match self.search_imp(cache, input, slots)? {
                                None => return Ok(None),
                                Some(hm) if !utf8empty => return Ok(Some(hm)),
                                Some(hm) => hm,
                            };
                            empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                                Ok(self
                                    .search_imp(cache, input, slots)?
                                    .map(|hm| (hm, hm.offset())))
                            })
                        }
                        /// The implementation of standard leftmost backtracking search.
                        fn search_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<HalfMatch>, MatchError> {
                            for slot in slots.iter_mut() {
                                *slot = None;
                            }
                            cache.setup_search(&self, input)?;
                            if input.is_done() {
                                return Ok(None);
                            }
                            let (anchored, start_id) = match input.get_anchored() {
                                Anchored::No => (
                                    self.nfa.is_always_start_anchored(),
                                    self.nfa.start_anchored(),
                                ),
                                Anchored::Yes => (true, self.nfa.start_anchored()),
                                Anchored::Pattern(pid) => match self.nfa.start_pattern(pid) {
                                    None => return Ok(None),
                                    Some(sid) => (true, sid),
                                },
                            };
                            if anchored {
                                let at = input.start();
                                return Ok(self.backtrack(cache, input, at, start_id, slots));
                            }
                            let pre = self.get_config().get_prefilter();
                            let mut at = input.start();
                            while at <= input.end()
                            {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => break,
                                        Some(ref span) => at = span.start,
                                    }
                                }
                                if let Some(hm) = self.backtrack(cache, input, at, start_id, slots)
                                {
                                    return Ok(Some(hm));
                                }
                                at += 1;
                            }
                            Ok(None)
                        }
                        /// Look for a match starting at `at` in `input` and write the matching
                        #[inline( always )]
                        fn backtrack(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            at: usize,
                            start_id: StateID,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            cache.stack.push(Frame::Step { sid: start_id, at });
                            while let Some(frame) = cache.stack.pop() {
                                match frame {
                                    Frame::Step { sid, at } => {
                                        if let Some(hm) = self.step(cache, input, sid, at, slots) {
                                            return Some(hm);
                                        }
                                    }
                                    Frame::RestoreCapture { slot, offset } => {
                                        slots[slot] = offset;
                                    }
                                }
                            }
                            None
                        }
                        #[inline( always )]
                        fn step(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            mut sid: StateID,
                            mut at: usize,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            loop {
                                if !cache.visited.insert(sid, at - input.start()) {
                                    return None;
                                }
                                match *self.nfa.state(sid) {
                                    State::ByteRange { ref trans } => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        if !trans.matches(input.haystack(), at) {
                                            return None;
                                        }
                                        sid = trans.next;
                                        at += 1;
                                    }
                                    State::Sparse(ref sparse) => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        sid = sparse.matches(input.haystack(), at)?;
                                        at += 1;
                                    }
                                    State::Dense(ref dense) => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        sid = dense.matches(input.haystack(), at)?;
                                        at += 1;
                                    }
                                    State::Look { look, next } => {
                                        if !self.nfa.look_matcher().matches_inline(
                                            look,
                                            input.haystack(),
                                            at,
                                        ) {
                                            return None;
                                        }
                                        sid = next;
                                    }
                                    State::Union { ref alternates } => {
                                        sid = match alternates.get(0) {
                                            None => return None,
                                            Some(&sid) => sid,
                                        };
                                        cache.stack.extend(
                                            alternates[1..]
                                                .iter()
                                                .copied()
                                                .rev()
                                                .map(|sid| Frame::Step { sid, at }),
                                        );
                                    }
                                    State::BinaryUnion { alt1, alt2 } => {
                                        sid = alt1;
                                        cache.stack.push(Frame::Step { sid: alt2, at });
                                    }
                                    State::Capture { next, slot, .. } => {
                                        if slot.as_usize() < slots.len() {
                                            cache.stack.push(Frame::RestoreCapture {
                                                slot,
                                                offset: slots[slot],
                                            });
                                            slots[slot] = NonMaxUsize::new(at);
                                        }
                                        sid = next;
                                    }
                                    State::Fail => return None,
                                    State::Match { pattern_id } => {
                                        return Some(HalfMatch::new(pattern_id, at));
                                    }
                                }
                            }
                        }
                    }
                    /// An iterator over all non-overlapping matches for a fallible search.
                    #[derive(Debug)]
                    pub struct TryFindMatches<'r, 'c, 'h> {
                        re: &'r BoundedBacktracker,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }

                    impl<'r, 'c, 'h> Iterator for TryFindMatches<'r, 'c, 'h> {
                        type Item = Result<Match, MatchError>;

                        #[inline]
                        fn next(&mut self) -> Option<Result<Match, MatchError>> {
                            // Splitting 'self' apart seems necessary to appease borrowck.
                            let TryFindMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            it.try_advance(|input| {
                                re.try_search(cache, input, caps)?;
                                Ok(caps.get_match())
                            })
                            .transpose()
                        }
                    }
                    /// An iterator over all non-overlapping leftmost matches, with their capturing
                    #[derive(Debug)]
                    pub struct TryCapturesMatches<'r, 'c, 'h> {
                        re: &'r BoundedBacktracker,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }

                    impl<'r, 'c, 'h> Iterator for TryCapturesMatches<'r, 'c, 'h> {
                        type Item = Result<Captures, MatchError>;

                        #[inline]
                        fn next(&mut self) -> Option<Result<Captures, MatchError>> {
                            // Splitting 'self' apart seems necessary to appease borrowck.
                            let TryCapturesMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            let _ = it
                                .try_advance(|input| {
                                    re.try_search(cache, input, caps)?;
                                    Ok(caps.get_match())
                                })
                                .transpose()?;
                            if caps.is_match() {
                                Some(Ok(caps.clone()))
                            } else {
                                None
                            }
                        }
                    }
                    /// A cache represents mutable state that a [`BoundedBacktracker`] requires
                    #[derive(Clone, Debug)]
                    pub struct Cache {
                        /// Stack used on the heap for doing backtracking instead of the
                        stack: Vec<Frame>,
                        /// The set of (StateID, HaystackOffset) pairs that have been visited
                        visited: Visited,
                    }

                    impl Cache {
                        /// Create a new [`BoundedBacktracker`] cache.
                        pub fn new(re: &BoundedBacktracker) -> Cache {
                            Cache { stack: vec![], visited: Visited::new(re) }
                        }
                        /// Reset this cache such that it can be used for searching with different
                        pub fn reset(&mut self, re: &BoundedBacktracker) {
                            self.visited.reset(re);
                        }
                        /// Returns the heap memory usage, in bytes, of this cache.
                        pub fn memory_usage(&self) -> usize {
                            self.stack.len() * ::mem::size_of::<Frame>()
                                + self.visited.memory_usage()
                        }
                        /// Clears this cache. This should be called at the start of every search
                        fn setup_search(
                            &mut self,
                            re: &BoundedBacktracker,
                            input: &Input<'_>,
                        ) -> Result<(), MatchError> {
                            self.stack.clear();
                            self.visited.setup_search(re, input)?;
                            Ok(())
                        }
                    }
                    /// Represents a stack frame on the heap while doing backtracking.
                    #[derive(Clone, Debug)]
                    enum Frame {
                        /// Look for a match starting at `sid` and the given position in the
                        Step { sid: StateID, at: usize },
                        /// Reset the given `slot` to the given `offset` (which might be `None`).
                        RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },
                    }
                    /// A bitset that keeps track of whether a particular (StateID, offset) has
                    #[derive(Clone, Debug)]
                    struct Visited {
                        /// The actual underlying bitset. Each element in the bitset corresponds
                        bitset: Vec<usize>,
                        /// The stride represents one plus length of the haystack we're searching
                        stride: usize,
                    }

                    impl Visited {
                        /// The size of each block, in bits.
                        const BLOCK_SIZE: usize = 8 * ::mem::size_of::<usize>();

                        /// Create a new visited set for the given backtracker.
                        fn new(re: &BoundedBacktracker) -> Visited {
                            let mut visited = Visited { bitset: vec![], stride: 0 };
                            visited.reset(re);
                            visited
                        }
                        /// Insert the given (StateID, offset) pair into this set. If it already
                        fn insert(&mut self, sid: StateID, at: usize) -> bool {
                            let table_index = sid.as_usize() * self.stride + at;
                            let block_index = table_index / Visited::BLOCK_SIZE;
                            let bit = table_index % Visited::BLOCK_SIZE;
                            let block_with_bit = 1 << bit;
                            if self.bitset[block_index] & block_with_bit != 0 {
                                return false;
                            }
                            self.bitset[block_index] |= block_with_bit;
                            true
                        }
                        /// Reset this visited set to work with the given bounded backtracker.
                        fn reset(&mut self, _: &BoundedBacktracker) {
                            self.bitset.truncate(0);
                        }
                        /// Setup this visited set to work for a search using the given NFA
                        fn setup_search(
                            &mut self,
                            re: &BoundedBacktracker,
                            input: &Input<'_>,
                        ) -> Result<(), MatchError> {
                            let haylen = input.get_span().len();
                            let err = || MatchError::haystack_too_long(haylen);
                            self.stride = haylen + 1;
                            let needed_capacity =
                                match re.get_nfa().states().len().checked_mul(self.stride) {
                                    None => return Err(err()),
                                    Some(capacity) => capacity,
                                };
                            let max_capacity = 8 * re.get_config().get_visited_capacity();
                            if needed_capacity > max_capacity {
                                return Err(err());
                            }
                            let needed_blocks = div_ceil(needed_capacity, Visited::BLOCK_SIZE);
                            self.bitset.truncate(needed_blocks);
                            for block in self.bitset.iter_mut() {
                                *block = 0;
                            }
                            
                            if needed_blocks > self.bitset.len() {
                                self.bitset.resize(needed_blocks, 0);
                            }
                            Ok(())
                        }
                        /// Return the heap memory usage, in bytes, of this visited set.
                        fn memory_usage(&self) -> usize {
                            self.bitset.len() * ::mem::size_of::<usize>()
                        }
                    }
                    /// Integer division, but rounds up instead of down.
                    fn div_ceil(lhs: usize, rhs: usize) -> usize {
                        if lhs % rhs == 0 {
                            lhs / rhs
                        } else {
                            (lhs / rhs) + 1
                        }
                    }
                }

                pub mod builder
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::mem;

                    use ::{sync::Arc, vec, vec::Vec};

                    use crate::{
                        nfa::thompson::{
                            error::BuildError,
                            nfa::{self, SparseTransitions, Transition, NFA},
                        },
                        util::{
                            look::{Look, LookMatcher},
                            primitives::{IteratorIndexExt, PatternID, SmallIndex, StateID},
                        },
                    };
                    */
                    /// An intermediate NFA state used during construction.
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    enum State {
                        /// An empty state whose only purpose is to forward the automaton to
                        Empty {
                            /// The next state that this state should transition to.
                            next: StateID,
                        },
                        /// A state that only transitions to another state if the current input
                        ByteRange { trans: Transition },
                        /// A state with possibly many transitions, represented in a sparse
                        Sparse { transitions: Vec<Transition> },
                        /// A conditional epsilon transition satisfied via some sort of
                        Look { look: Look, next: StateID },
                        /// An empty state that records the start of a capture location. This is an
                        CaptureStart {
                            /// The ID of the pattern that this capture was defined.
                            pattern_id: PatternID,
                            /// The capture group index that this capture state corresponds to.
                            group_index: SmallIndex,
                            /// The next state that this state should transition to.
                            next: StateID,
                        },
                        /// An empty state that records the end of a capture location. This is an
                        CaptureEnd {
                            /// The ID of the pattern that this capture was defined.
                            pattern_id: PatternID,
                            /// The capture group index that this capture state corresponds to.
                            group_index: SmallIndex,
                            /// The next state that this state should transition to.
                            next: StateID,
                        },
                        /// An alternation such that there exists an epsilon transition to all
                        Union { alternates: Vec<StateID> },
                        /// An alternation such that there exists an epsilon transition to all
                        UnionReverse { alternates: Vec<StateID> },
                        /// A state that cannot be transitioned out of. This is useful for cases
                        Fail,
                        /// A match state. There is at most one such occurrence of this state in
                        Match { pattern_id: PatternID },
                    }

                    impl State {
                        /// If this state is an unconditional epsilon transition, then this returns
                        fn goto(&self) -> Option<StateID> {
                            match *self {
                                State::Empty { next } => Some(next),
                                State::Union { ref alternates } if alternates.len() == 1 => {
                                    Some(alternates[0])
                                }
                                State::UnionReverse { ref alternates }
                                    if alternates.len() == 1 =>
                                {
                                    Some(alternates[0])
                                }
                                _ => None,
                            }
                        }
                        /// Returns the heap memory usage, in bytes, of this state.
                        fn memory_usage(&self) -> usize {
                            match *self {
                                State::Empty { .. }
                                | State::ByteRange { .. }
                                | State::Look { .. }
                                | State::CaptureStart { .. }
                                | State::CaptureEnd { .. }
                                | State::Fail
                                | State::Match { .. } => 0,
                                State::Sparse { ref transitions } => {
                                    transitions.len() * mem::size_of::<Transition>()
                                }
                                State::Union { ref alternates } => {
                                    alternates.len() * mem::size_of::<StateID>()
                                }
                                State::UnionReverse { ref alternates } => {
                                    alternates.len() * mem::size_of::<StateID>()
                                }
                            }
                        }
                    }
                    /// An abstraction for building Thompson NFAs by hand.
                    #[derive(Clone, Debug, Default)]
                    pub struct Builder {
                        /// The ID of the pattern that we're currently building.
                        pattern_id: Option<PatternID>,
                        /// A sequence of intermediate NFA states. Once a state is added to this
                        states: Vec<State>,
                        /// The starting states for each individual pattern. Starting at any
                        start_pattern: Vec<StateID>,
                        /// A map from pattern ID to capture group index to name. (If no name
                        captures: Vec<Vec<Option<Arc<str>>>>,
                        /// The combined memory used by each of the 'State's in 'states'. This
                        memory_states: usize,
                        /// Whether this NFA only matches UTF-8 and whether regex engines using
                        utf8: bool,
                        /// Whether this NFA should be matched in reverse or not.
                        reverse: bool,
                        /// The matcher to use for look-around assertions.
                        look_matcher: LookMatcher,
                        /// A size limit to respect when building an NFA. If the total heap memory
                        size_limit: Option<usize>,
                    }

                    impl Builder {
                        /// Create a new builder for hand-assembling NFAs.
                        pub fn new() -> Builder {
                            Builder::default()
                        }
                        /// Clear this builder.
                        pub fn clear(&mut self) {
                            self.pattern_id = None;
                            self.states.clear();
                            self.start_pattern.clear();
                            self.captures.clear();
                            self.memory_states = 0;
                        }
                        /// Assemble a [`NFA`] from the states added so far.
                        pub fn build(
                            &self,
                            start_anchored: StateID,
                            start_unanchored: StateID,
                        ) -> Result<NFA, BuildError> {
                            assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
                            debug!(
                                "intermediate NFA compilation via builder is complete, \
                                intermediate NFA size: {} states, {} bytes on heap",
                                self.states.len(),
                                self.memory_usage(),
                            );

                            let mut nfa = nfa::Inner::default();
                            nfa.set_utf8(self.utf8);
                            nfa.set_reverse(self.reverse);
                            nfa.set_look_matcher(self.look_matcher.clone());
                            let mut empties = vec![];
                            let mut remap = vec![];
                            remap.resize(self.states.len(), StateID::ZERO);

                            nfa.set_starts(start_anchored, start_unanchored, &self.start_pattern);
                            nfa.set_captures(&self.captures).map_err(BuildError::captures)?;
                            for (sid, state) in self.states.iter().with_state_ids() {
                                match *state {
                                    State::Empty { next } => {
                                        empties.push((sid, next));
                                    }
                                    State::ByteRange { trans } => {
                                        remap[sid] = nfa.add(nfa::State::ByteRange { trans });
                                    }
                                    State::Sparse { ref transitions } => {
                                        remap[sid] = match transitions.len() {
                                            0 => nfa.add(nfa::State::Fail),
                                            1 => nfa.add(nfa::State::ByteRange {
                                                trans: transitions[0],
                                            }),
                                            _ => {
                                                let transitions =
                                                    transitions.to_vec().into_boxed_slice();
                                                let sparse = SparseTransitions { transitions };
                                                nfa.add(nfa::State::Sparse(sparse))
                                            }
                                        }
                                    }
                                    State::Look { look, next } => {
                                        remap[sid] = nfa.add(nfa::State::Look { look, next });
                                    }
                                    State::CaptureStart { pattern_id, group_index, next } => {
                                        let slot = nfa
                                            .group_info()
                                            .slot(pattern_id, group_index.as_usize())
                                            .expect("invalid capture index");
                                        let slot =
                                            SmallIndex::new(slot).expect("a small enough slot");
                                        remap[sid] = nfa.add(nfa::State::Capture {
                                            next,
                                            pattern_id,
                                            group_index,
                                            slot,
                                        });
                                    }
                                    State::CaptureEnd { pattern_id, group_index, next } => {
                                        let slot = nfa
                                            .group_info()
                                            .slot(pattern_id, group_index.as_usize())
                                            .expect("invalid capture index")
                                            .checked_add(1)
                                            .unwrap();
                                        let slot =
                                            SmallIndex::new(slot).expect("a small enough slot");
                                        remap[sid] = nfa.add(nfa::State::Capture {
                                            next,
                                            pattern_id,
                                            group_index,
                                            slot,
                                        });
                                    }
                                    State::Union { ref alternates } => {
                                        if alternates.is_empty() {
                                            remap[sid] = nfa.add(nfa::State::Fail);
                                        } else if alternates.len() == 1 {
                                            empties.push((sid, alternates[0]));
                                            remap[sid] = alternates[0];
                                        } else if alternates.len() == 2 {
                                            remap[sid] = nfa.add(nfa::State::BinaryUnion {
                                                alt1: alternates[0],
                                                alt2: alternates[1],
                                            });
                                        } else {
                                            let alternates =
                                                alternates.to_vec().into_boxed_slice();
                                            remap[sid] = nfa.add(nfa::State::Union { alternates });
                                        }
                                    }
                                    State::UnionReverse { ref alternates } => {
                                        if alternates.is_empty() {
                                            remap[sid] = nfa.add(nfa::State::Fail);
                                        } else if alternates.len() == 1 {
                                            empties.push((sid, alternates[0]));
                                            remap[sid] = alternates[0];
                                        } else if alternates.len() == 2 {
                                            remap[sid] = nfa.add(nfa::State::BinaryUnion {
                                                alt1: alternates[1],
                                                alt2: alternates[0],
                                            });
                                        } else {
                                            let mut alternates =
                                                alternates.to_vec().into_boxed_slice();
                                            alternates.reverse();
                                            remap[sid] = nfa.add(nfa::State::Union { alternates });
                                        }
                                    }
                                    State::Fail => {
                                        remap[sid] = nfa.add(nfa::State::Fail);
                                    }
                                    State::Match { pattern_id } => {
                                        remap[sid] = nfa.add(nfa::State::Match { pattern_id });
                                    }
                                }
                            }
                            let mut remapped = vec![false; self.states.len()];
                            for &(empty_id, empty_next) in empties.iter()
                            {
                                if remapped[empty_id] {
                                    continue;
                                }
                                let mut new_next = empty_next;
                                while let Some(next) = self.states[new_next].goto() {
                                    new_next = next;
                                }
                                remap[empty_id] = remap[new_next];
                                remapped[empty_id] = true;
                                let mut next2 = empty_next;
                                while let Some(next) = self.states[next2].goto() {
                                    remap[next2] = remap[new_next];
                                    remapped[next2] = true;
                                    next2 = next;
                                }
                            }
                            // Finally remap all of the state IDs.
                            nfa.remap(&remap);
                            let final_nfa = nfa.into_nfa();
                            debug!(
                                "NFA compilation via builder complete, \
                                final NFA size: {} states, {} bytes on heap, \
                                has empty? {:?}, utf8? {:?}",
                                final_nfa.states().len(),
                                final_nfa.memory_usage(),
                                final_nfa.has_empty(),
                                final_nfa.is_utf8(),
                            );
                            Ok(final_nfa)
                        }
                        /// Start the assembly of a pattern in this NFA.
                        pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {
                            assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");

                            let proposed = self.start_pattern.len();
                            let pid = PatternID::new(proposed)
                                .map_err(|_| BuildError::too_many_patterns(proposed))?;
                            self.pattern_id = Some(pid);
                            // This gets filled in when 'finish_pattern' is called.
                            self.start_pattern.push(StateID::ZERO);
                            Ok(pid)
                        }
                        /// Finish the assembly of a pattern in this NFA.
                        pub fn finish_pattern(
                            &mut self,
                            start_id: StateID,
                        ) -> Result<PatternID, BuildError> {
                            let pid = self.current_pattern_id();
                            self.start_pattern[pid] = start_id;
                            self.pattern_id = None;
                            Ok(pid)
                        }
                        /// Returns the pattern identifier of the current pattern.
                        pub fn current_pattern_id(&self) -> PatternID {
                            self.pattern_id.expect("must call 'start_pattern' first")
                        }
                        /// Returns the number of patterns added to this builder so far.
                        pub fn pattern_len(&self) -> usize {
                            self.start_pattern.len()
                        }
                        /// Add an "empty" NFA state.
                        pub fn add_empty(&mut self) -> Result<StateID, BuildError> {
                            self.add(State::Empty { next: StateID::ZERO })
                        }
                        /// Add a "union" NFA state.
                        pub fn add_union(
                            &mut self,
                            alternates: Vec<StateID>,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::Union { alternates })
                        }
                        /// Add a "reverse union" NFA state.
                        pub fn add_union_reverse(
                            &mut self,
                            alternates: Vec<StateID>,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::UnionReverse { alternates })
                        }
                        /// Add a "range" NFA state.
                        pub fn add_range(
                            &mut self,
                            trans: Transition,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::ByteRange { trans })
                        }
                        /// Add a "sparse" NFA state.
                        pub fn add_sparse(
                            &mut self,
                            transitions: Vec<Transition>,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::Sparse { transitions })
                        }
                        /// Add a "look" NFA state.
                        pub fn add_look(
                            &mut self,
                            next: StateID,
                            look: Look,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::Look { look, next })
                        }
                        /// Add a "start capture" NFA state.
                        pub fn add_capture_start(
                            &mut self,
                            next: StateID,
                            group_index: u32,
                            name: Option<Arc<str>>,
                        ) -> Result<StateID, BuildError> {
                            let pid = self.current_pattern_id();
                            let group_index = match SmallIndex::try_from(group_index) {
                                Err(_) => {
                                    return Err(BuildError::invalid_capture_index(group_index))
                                }
                                Ok(group_index) => group_index,
                            };
                            // Make sure we have space to insert our (pid,index)|-->name mapping.
                            if pid.as_usize() >= self.captures.len() {
                                for _ in 0..=(pid.as_usize() - self.captures.len()) {
                                    self.captures.push(vec![]);
                                }
                            }
                            
                            if group_index.as_usize() >= self.captures[pid].len() {
                                for _ in 0..(group_index.as_usize() - self.captures[pid].len()) {
                                    self.captures[pid].push(None);
                                }
                                self.captures[pid].push(name);
                            }
                            self.add(State::CaptureStart { pattern_id: pid, group_index, next })
                        }
                        /// Add a "end capture" NFA state.
                        pub fn add_capture_end(
                            &mut self,
                            next: StateID,
                            group_index: u32,
                        ) -> Result<StateID, BuildError> {
                            let pid = self.current_pattern_id();
                            let group_index = match SmallIndex::try_from(group_index) {
                                Err(_) => {
                                    return Err(BuildError::invalid_capture_index(group_index))
                                }
                                Ok(group_index) => group_index,
                            };
                            self.add(State::CaptureEnd { pattern_id: pid, group_index, next })
                        }
                        /// Adds a "fail" NFA state.
                        pub fn add_fail(&mut self) -> Result<StateID, BuildError> {
                            self.add(State::Fail)
                        }
                        /// Adds a "match" NFA state.
                        pub fn add_match(&mut self) -> Result<StateID, BuildError> {
                            let pattern_id = self.current_pattern_id();
                            let sid = self.add(State::Match { pattern_id })?;
                            Ok(sid)
                        }
                        /// The common implementation of "add a state." It handles the common
                        fn add(&mut self, state: State) -> Result<StateID, BuildError> {
                            let id = StateID::new(self.states.len())
                                .map_err(|_| BuildError::too_many_states(self.states.len()))?;
                            self.memory_states += state.memory_usage();
                            self.states.push(state);
                            self.check_size_limit()?;
                            Ok(id)
                        }
                        /// Add a transition from one state to another.
                        pub fn patch(
                            &mut self,
                            from: StateID,
                            to: StateID,
                        ) -> Result<(), BuildError> {
                            let old_memory_states = self.memory_states;
                            match self.states[from] {
                                State::Empty { ref mut next } => {
                                    *next = to;
                                }
                                State::ByteRange { ref mut trans } => {
                                    trans.next = to;
                                }
                                State::Sparse { .. } => {
                                    panic!("cannot patch from a sparse NFA state")
                                }
                                State::Look { ref mut next, .. } => {
                                    *next = to;
                                }
                                State::Union { ref mut alternates } => {
                                    alternates.push(to);
                                    self.memory_states += mem::size_of::<StateID>();
                                }
                                State::UnionReverse { ref mut alternates } => {
                                    alternates.push(to);
                                    self.memory_states += mem::size_of::<StateID>();
                                }
                                State::CaptureStart { ref mut next, .. } => {
                                    *next = to;
                                }
                                State::CaptureEnd { ref mut next, .. } => {
                                    *next = to;
                                }
                                State::Fail => {}
                                State::Match { .. } => {}
                            }
                            
                            if old_memory_states != self.memory_states {
                                self.check_size_limit()?;
                            }
                            Ok(())
                        }
                        /// Set whether the NFA produced by this builder should only match UTF-8.
                        pub fn set_utf8(&mut self, yes: bool) {
                            self.utf8 = yes;
                        }
                        /// Returns whether UTF-8 mode is enabled for this builder.
                        pub fn get_utf8(&self) -> bool {
                            self.utf8
                        }
                        /// Sets whether the NFA produced by this builder should be matched in
                        pub fn set_reverse(&mut self, yes: bool) {
                            self.reverse = yes;
                        }
                        /// Returns whether reverse mode is enabled for this builder.
                        pub fn get_reverse(&self) -> bool {
                            self.reverse
                        }
                        /// Sets the look-around matcher that should be used for the resulting NFA.
                        pub fn set_look_matcher(&mut self, m: LookMatcher) {
                            self.look_matcher = m;
                        }
                        /// Returns the look-around matcher used for this builder.
                        pub fn get_look_matcher(&self) -> &LookMatcher {
                            &self.look_matcher
                        }
                        /// Set the size limit on this builder.
                        pub fn set_size_limit(
                            &mut self,
                            limit: Option<usize>,
                        ) -> Result<(), BuildError> {
                            self.size_limit = limit;
                            self.check_size_limit()
                        }
                        /// Return the currently configured size limit.
                        pub fn get_size_limit(&self) -> Option<usize> {
                            self.size_limit
                        }
                        /// Returns the heap memory usage, in bytes, used by the NFA states added
                        pub fn memory_usage(&self) -> usize {
                            self.states.len() * mem::size_of::<State>() + self.memory_states
                        }

                        fn check_size_limit(&self) -> Result<(), BuildError> {
                            if let Some(limit) = self.size_limit {
                                if self.memory_usage() > limit {
                                    return Err(BuildError::exceeded_size_limit(limit));
                                }
                            }
                            Ok(())
                        }
                    }
                }

                pub mod compiler
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::{borrow::Borrow, cell::RefCell};

                    use ::{sync::Arc, vec, vec::Vec};

                    use regex_syntax::{
                        hir::{self, Hir},
                        utf8::{Utf8Range, Utf8Sequences},
                        ParserBuilder,
                    };

                    use crate::{
                        nfa::thompson::{
                            builder::Builder,
                            error::BuildError,
                            literal_trie::LiteralTrie,
                            map::{Utf8BoundedMap, Utf8SuffixKey, Utf8SuffixMap},
                            nfa::{Transition, NFA},
                            range_trie::RangeTrie,
                        },
                        util::{
                            look::{Look, LookMatcher},
                            primitives::{PatternID, StateID},
                        },
                    };
                    */
                    /// The configuration used for a Thompson NFA compiler.
                    #[derive(Clone, Debug, Default)]
                    pub struct Config {
                        utf8: Option<bool>,
                        reverse: Option<bool>,
                        nfa_size_limit: Option<Option<usize>>,
                        shrink: Option<bool>,
                        which_captures: Option<WhichCaptures>,
                        look_matcher: Option<LookMatcher>,
                    }

                    impl Config {
                        /// Return a new default Thompson NFA compiler configuration.
                        pub fn new() -> Config {
                            Config::default()
                        }
                        /// Whether to enable UTF-8 mode during search or not.
                        pub fn utf8(mut self, yes: bool) -> Config {
                            self.utf8 = Some(yes);
                            self
                        }
                        /// Reverse the NFA.
                        pub fn reverse(mut self, yes: bool) -> Config {
                            self.reverse = Some(yes);
                            self
                        }
                        /// Sets an approximate size limit on the total heap used by the NFA being
                        pub fn nfa_size_limit(mut self, bytes: Option<usize>) -> Config {
                            self.nfa_size_limit = Some(bytes);
                            self
                        }
                        /// Apply best effort heuristics to shrink the NFA at the expense of more
                        pub fn shrink(mut self, yes: bool) -> Config {
                            self.shrink = Some(yes);
                            self
                        }
                        /// Whether to include 'Capture' states in the NFA.
                        #[deprecated(since = "0.3.5", note = "use which_captures instead")]
                        pub fn captures(self, yes: bool) -> Config {
                            self.which_captures(if yes {
                                WhichCaptures::All
                            } else {
                                WhichCaptures::None
                            })
                        }
                        /// Configures what kinds of capture groups are compiled into
                        pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {
                            self.which_captures = Some(which_captures);
                            self
                        }
                        /// Sets the look-around matcher that should be used with this NFA.
                        pub fn look_matcher(mut self, m: LookMatcher) -> Config {
                            self.look_matcher = Some(m);
                            self
                        }
                        /// Returns whether this configuration has enabled UTF-8 mode.
                        pub fn get_utf8(&self) -> bool {
                            self.utf8.unwrap_or(true)
                        }
                        /// Returns whether this configuration has enabled reverse NFA compilation.
                        pub fn get_reverse(&self) -> bool {
                            self.reverse.unwrap_or(false)
                        }
                        /// Return the configured NFA size limit, if it exists, in the number of
                        pub fn get_nfa_size_limit(&self) -> Option<usize> {
                            self.nfa_size_limit.unwrap_or(None)
                        }
                        /// Return whether NFA shrinking is enabled.
                        pub fn get_shrink(&self) -> bool {
                            self.shrink.unwrap_or(false)
                        }
                        /// Return whether NFA compilation is configured to produce capture states.
                        #[deprecated(since = "0.3.5", note = "use get_which_captures instead")]
                        pub fn get_captures(&self) -> bool {
                            self.get_which_captures().is_any()
                        }
                        /// Return what kinds of capture states will be compiled into an NFA.
                        pub fn get_which_captures(&self) -> WhichCaptures {
                            self.which_captures.unwrap_or(WhichCaptures::All)
                        }
                        /// Return the look-around matcher for this NFA.
                        pub fn get_look_matcher(&self) -> LookMatcher {
                            self.look_matcher.clone().unwrap_or(LookMatcher::default())
                        }
                        /// Return whether NFA compilation is configured to include an unanchored
                        fn get_unanchored_prefix(&self) -> bool {
                            true
                        }
                        /// Overwrite the default configuration such that the options in `o` are
                        pub fn overwrite(&self, o: Config) -> Config {
                            Config {
                                utf8: o.utf8.or(self.utf8),
                                reverse: o.reverse.or(self.reverse),
                                nfa_size_limit: o.nfa_size_limit.or(self.nfa_size_limit),
                                shrink: o.shrink.or(self.shrink),
                                which_captures: o.which_captures.or(self.which_captures),
                                look_matcher: o.look_matcher.or_else(|| self.look_matcher.clone()),
                            }
                        }
                    }
                    /// A configuration indicating which kinds of
                    #[derive(Clone, Copy, Debug)]
                    pub enum WhichCaptures {
                        /// All capture states, including those corresponding to both implicit and
                        All,
                        /// Only capture states corresponding to implicit capture groups are
                        Implicit,
                        /// No capture states are compiled into the Thompson NFA.
                        None,
                    }

                    impl Default for WhichCaptures {
                        fn default() -> WhichCaptures {
                            WhichCaptures::All
                        }
                    }

                    impl WhichCaptures {
                        /// Returns true if this configuration indicates that no capture states
                        pub fn is_none(&self) -> bool {
                            matches!(*self, WhichCaptures::None)
                        }
                        /// Returns true if this configuration indicates that some capture states
                        pub fn is_any(&self) -> bool {
                            !self.is_none()
                        }
                    }

                    /*
                    This compiler below uses Thompson's construction algorithm.*/

                    /// A builder for compiling an NFA from a regex's high-level intermediate
                    #[derive(Clone, Debug)]
                    pub struct Compiler {
                        /// A regex parser, used when compiling an NFA directly from a pattern
                        parser: ParserBuilder,
                        /// The compiler configuration.
                        config: Config,
                        /// The builder for actually constructing an NFA. This provides a
                        builder: RefCell<Builder>,
                        /// State used for compiling character classes to UTF-8 byte automata.
                        utf8_state: RefCell<Utf8State>,
                        /// State used for arranging character classes in reverse into a trie.
                        trie_state: RefCell<RangeTrie>,
                        /// State used for caching common suffixes when compiling reverse UTF-8
                        utf8_suffix: RefCell<Utf8SuffixMap>,
                    }

                    impl Compiler {
                        /// Create a new NFA builder with its default configuration.
                        pub fn new() -> Compiler {
                            Compiler {
                                parser: ParserBuilder::new(),
                                config: Config::default(),
                                builder: RefCell::new(Builder::new()),
                                utf8_state: RefCell::new(Utf8State::new()),
                                trie_state: RefCell::new(RangeTrie::new()),
                                utf8_suffix: RefCell::new(Utf8SuffixMap::new(1000)),
                            }
                        }
                        /// Compile the given regular expression pattern into an NFA.
                        pub fn build(&self, pattern: &str) -> Result<NFA, BuildError> {
                            self.build_many(&[pattern])
                        }
                        /// Compile the given regular expression patterns into a single NFA.
                        pub fn build_many<P: AsRef<str>>(
                            &self,
                            patterns: &[P],
                        ) -> Result<NFA, BuildError> {
                            let mut hirs = vec![];
                            for p in patterns {
                                hirs.push(
                                    self.parser
                                        .build()
                                        .parse(p.as_ref())
                                        .map_err(BuildError::syntax)?,
                                );
                                debug!("parsed: {:?}", p.as_ref());
                            }
                            self.build_many_from_hir(&hirs)
                        }
                        /// Compile the given high level intermediate representation of a regular
                        pub fn build_from_hir(&self, expr: &Hir) -> Result<NFA, BuildError> {
                            self.build_many_from_hir(&[expr])
                        }
                        /// Compile the given high level intermediate representations of regular
                        pub fn build_many_from_hir<H: Borrow<Hir>>(
                            &self,
                            exprs: &[H],
                        ) -> Result<NFA, BuildError> {
                            self.compile(exprs)
                        }
                        /// Apply the given NFA configuration options to this builder.
                        pub fn configure(&mut self, config: Config) -> &mut Compiler {
                            self.config = self.config.overwrite(config);
                            self
                        }
                        /// Set the syntax configuration for this builder using
                        pub fn syntax(
                            &mut self,
                            config: crate::util::syntax::Config,
                        ) -> &mut Compiler {
                            config.apply(&mut self.parser);
                            self
                        }
                    }

                    impl Compiler {
                        /// Compile the sequence of HIR expressions given. Pattern IDs are
                        fn compile<H: Borrow<Hir>>(&self, exprs: &[H]) -> Result<NFA, BuildError> {
                            if exprs.len() > PatternID::LIMIT {
                                return Err(BuildError::too_many_patterns(exprs.len()));
                            }
                            
                            if self.config.get_reverse()
                                && self.config.get_which_captures().is_any()
                            {
                                return Err(BuildError::unsupported_captures());
                            }

                            self.builder.borrow_mut().clear();
                            self.builder.borrow_mut().set_utf8(self.config.get_utf8());
                            self.builder.borrow_mut().set_reverse(self.config.get_reverse());
                            self.builder
                                .borrow_mut()
                                .set_look_matcher(self.config.get_look_matcher());
                            self.builder
                                .borrow_mut()
                                .set_size_limit(self.config.get_nfa_size_limit())?;
                            let all_anchored = exprs.iter().all(|e| {
                                let props = e.borrow().properties();
                                
                                if self.config.get_reverse() {
                                    props.look_set_suffix().contains(hir::Look::End)
                                } else {
                                    props.look_set_prefix().contains(hir::Look::Start)
                                }
                            });
                            let anchored = !self.config.get_unanchored_prefix() || all_anchored;
                            let unanchored_prefix = if anchored {
                                self.c_empty()?
                            } else {
                                self.c_at_least(&Hir::dot(hir::Dot::AnyByte), false, 0)?
                            };

                            let compiled = self.c_alt_iter(exprs.iter().map(|e| {
                                let _ = self.start_pattern()?;
                                let one = self.c_cap(0, None, e.borrow())?;
                                let match_state_id = self.add_match()?;
                                self.patch(one.end, match_state_id)?;
                                let _ = self.finish_pattern(one.start)?;
                                Ok(ThompsonRef { start: one.start, end: match_state_id })
                            }))?;
                            self.patch(unanchored_prefix.end, compiled.start)?;
                            let nfa = self
                                .builder
                                .borrow_mut()
                                .build(compiled.start, unanchored_prefix.start)?;

                            debug!("HIR-to-NFA compilation complete, config: {:?}", self.config);
                            Ok(nfa)
                        }
                        /// Compile an arbitrary HIR expression.
                        fn c(&self, expr: &Hir) -> Result<ThompsonRef, BuildError> {
                            use regex_syntax::hir::{Class, HirKind::*};

                            match *expr.kind() {
                                Empty => self.c_empty(),
                                Literal(hir::Literal(ref bytes)) => self.c_literal(bytes),
                                Class(Class::Bytes(ref c)) => self.c_byte_class(c),
                                Class(Class::Unicode(ref c)) => self.c_unicode_class(c),
                                Look(ref look) => self.c_look(look),
                                Repetition(ref rep) => self.c_repetition(rep),
                                Capture(ref c) => self.c_cap(c.index, c.name.as_deref(), &c.sub),
                                Concat(ref es) => self.c_concat(es.iter().map(|e| self.c(e))),
                                Alternation(ref es) => self.c_alt_slice(es),
                            }
                        }
                        /// Compile a concatenation of the sub-expressions yielded by the given
                        fn c_concat<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
                        where
                            I: DoubleEndedIterator<Item = Result<ThompsonRef, BuildError>>,
                        {
                            let first = if self.is_reverse() { it.next_back() } else { it.next() };
                            let ThompsonRef { start, mut end } = match first {
                                Some(result) => result?,
                                None => return self.c_empty(),
                            };
                            loop {
                                let next =
                                    if self.is_reverse() { it.next_back() } else { it.next() };
                                let compiled = match next {
                                    Some(result) => result?,
                                    None => break,
                                };
                                self.patch(end, compiled.start)?;
                                end = compiled.end;
                            }
                            Ok(ThompsonRef { start, end })
                        }
                        /// Compile an alternation of the given HIR values.
                        fn c_alt_slice(&self, exprs: &[Hir]) -> Result<ThompsonRef, BuildError> {
                            // self.c_alt_iter(exprs.iter().map(|e| self.c(e)))
                            let literal_count = exprs
                                .iter()
                                .filter(|e| {
                                    matches!(*e.kind(), hir::HirKind::Literal(hir::Literal(_)))
                                })
                                .count();
                            if literal_count <= 1 || literal_count < exprs.len() {
                                return self.c_alt_iter(exprs.iter().map(|e| self.c(e)));
                            }

                            let mut trie = if self.is_reverse() {
                                LiteralTrie::reverse()
                            } else {
                                LiteralTrie::forward()
                            };
                            for expr in exprs.iter() {
                                let literal = match *expr.kind() {
                                    hir::HirKind::Literal(hir::Literal(ref bytes)) => bytes,
                                    _ => unreachable!(),
                                };
                                trie.add(literal)?;
                            }
                            trie.compile(&mut self.builder.borrow_mut())
                        }
                        /// Compile an alternation, where each element yielded by the given
                        fn c_alt_iter<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
                        where
                            I: Iterator<Item = Result<ThompsonRef, BuildError>>,
                        {
                            let first = match it.next() {
                                None => return self.c_fail(),
                                Some(result) => result?,
                            };
                            let second = match it.next() {
                                None => return Ok(first),
                                Some(result) => result?,
                            };

                            let union = self.add_union()?;
                            let end = self.add_empty()?;
                            self.patch(union, first.start)?;
                            self.patch(first.end, end)?;
                            self.patch(union, second.start)?;
                            self.patch(second.end, end)?;
                            for result in it {
                                let compiled = result?;
                                self.patch(union, compiled.start)?;
                                self.patch(compiled.end, end)?;
                            }
                            Ok(ThompsonRef { start: union, end })
                        }
                        /// Compile the given capture sub-expression. `expr` should be the
                        fn c_cap(
                            &self,
                            index: u32,
                            name: Option<&str>,
                            expr: &Hir,
                        ) -> Result<ThompsonRef, BuildError> {
                            match self.config.get_which_captures() {
                                // No capture states means we always skip them.
                                WhichCaptures::None => return self.c(expr),
                                WhichCaptures::Implicit if index > 0 => return self.c(expr),
                                _ => {}
                            }

                            let start = self.add_capture_start(index, name)?;
                            let inner = self.c(expr)?;
                            let end = self.add_capture_end(index)?;
                            self.patch(start, inner.start)?;
                            self.patch(inner.end, end)?;
                            Ok(ThompsonRef { start, end })
                        }
                        /// Compile the given repetition expression. This handles all types of
                        fn c_repetition(
                            &self,
                            rep: &hir::Repetition,
                        ) -> Result<ThompsonRef, BuildError> {
                            match (rep.min, rep.max) {
                                (0, Some(1)) => self.c_zero_or_one(&rep.sub, rep.greedy),
                                (min, None) => self.c_at_least(&rep.sub, rep.greedy, min),
                                (min, Some(max)) if min == max => self.c_exactly(&rep.sub, min),
                                (min, Some(max)) => self.c_bounded(&rep.sub, rep.greedy, min, max),
                            }
                        }
                        /// Compile the given expression such that it matches at least `min` times,
                        fn c_bounded(
                            &self,
                            expr: &Hir,
                            greedy: bool,
                            min: u32,
                            max: u32,
                        ) -> Result<ThompsonRef, BuildError> {
                            let prefix = self.c_exactly(expr, min)?;
                            if min == max {
                                return Ok(prefix);
                            }
                            let empty = self.add_empty()?;
                            let mut prev_end = prefix.end;
                            for _ in min..max {
                                let union = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                let compiled = self.c(expr)?;
                                self.patch(prev_end, union)?;
                                self.patch(union, compiled.start)?;
                                self.patch(union, empty)?;
                                prev_end = compiled.end;
                            }
                            self.patch(prev_end, empty)?;
                            Ok(ThompsonRef { start: prefix.start, end: empty })
                        }
                        /// Compile the given expression such that it may be matched `n` or more
                        fn c_at_least(
                            &self,
                            expr: &Hir,
                            greedy: bool,
                            n: u32,
                        ) -> Result<ThompsonRef, BuildError> {
                            if n == 0 {
                                if expr.properties().minimum_len().map_or(false, |len| len > 0) {
                                    let union = if greedy {
                                        self.add_union()
                                    } else {
                                        self.add_union_reverse()
                                    }?;
                                    let compiled = self.c(expr)?;
                                    self.patch(union, compiled.start)?;
                                    self.patch(compiled.end, union)?;
                                    return Ok(ThompsonRef { start: union, end: union });
                                }
                                let compiled = self.c(expr)?;
                                let plus = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                self.patch(compiled.end, plus)?;
                                self.patch(plus, compiled.start)?;

                                let question = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                let empty = self.add_empty()?;
                                self.patch(question, compiled.start)?;
                                self.patch(question, empty)?;
                                self.patch(plus, empty)?;
                                Ok(ThompsonRef { start: question, end: empty })
                            } else if n == 1 {
                                let compiled = self.c(expr)?;
                                let union = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                self.patch(compiled.end, union)?;
                                self.patch(union, compiled.start)?;
                                Ok(ThompsonRef { start: compiled.start, end: union })
                            } else {
                                let prefix = self.c_exactly(expr, n - 1)?;
                                let last = self.c(expr)?;
                                let union = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                self.patch(prefix.end, last.start)?;
                                self.patch(last.end, union)?;
                                self.patch(union, last.start)?;
                                Ok(ThompsonRef { start: prefix.start, end: union })
                            }
                        }
                        /// Compile the given expression such that it may be matched zero or one
                        fn c_zero_or_one(
                            &self,
                            expr: &Hir,
                            greedy: bool,
                        ) -> Result<ThompsonRef, BuildError> {
                            let union =
                                if greedy { self.add_union() } else { self.add_union_reverse() }?;
                            let compiled = self.c(expr)?;
                            let empty = self.add_empty()?;
                            self.patch(union, compiled.start)?;
                            self.patch(union, empty)?;
                            self.patch(compiled.end, empty)?;
                            Ok(ThompsonRef { start: union, end: empty })
                        }
                        /// Compile the given HIR expression exactly `n` times.
                        fn c_exactly(
                            &self,
                            expr: &Hir,
                            n: u32,
                        ) -> Result<ThompsonRef, BuildError> {
                            let it = (0..n).map(|_| self.c(expr));
                            self.c_concat(it)
                        }
                        /// Compile the given byte oriented character class.
                        fn c_byte_class(
                            &self,
                            cls: &hir::ClassBytes,
                        ) -> Result<ThompsonRef, BuildError> {
                            let end = self.add_empty()?;
                            let mut trans = Vec::with_capacity(cls.ranges().len());
                            for r in cls.iter() {
                                trans.push(Transition {
                                    start: r.start(),
                                    end: r.end(),
                                    next: end,
                                });
                            }
                            Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
                        }
                        /// Compile the given Unicode character class.
                        fn c_unicode_class(
                            &self,
                            cls: &hir::ClassUnicode,
                        ) -> Result<ThompsonRef, BuildError> {
                            if cls.is_ascii() {
                                let end = self.add_empty()?;
                                let mut trans = Vec::with_capacity(cls.ranges().len());
                                for r in cls.iter() {
                                    trans.push(Transition {
                                        // FIXME(1.59): use the 'TryFrom<char> for u8' impl.
                                        start: u8::try_from(u32::from(r.start())).unwrap(),
                                        end: u8::try_from(u32::from(r.end())).unwrap(),
                                        next: end,
                                    });
                                }
                                Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
                            } else if self.is_reverse()
                            {
                                if !self.config.get_shrink() {
                                    self.c_unicode_class_reverse_with_suffix(cls)
                                } else {
                                    let mut trie = self.trie_state.borrow_mut();
                                    trie.clear();

                                    for rng in cls.iter() {
                                        for mut seq in Utf8Sequences::new(rng.start(), rng.end()) {
                                            seq.reverse();
                                            trie.insert(seq.as_slice());
                                        }
                                    }
                                    let mut builder = self.builder.borrow_mut();
                                    let mut utf8_state = self.utf8_state.borrow_mut();
                                    let mut utf8c =
                                        Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;
                                    trie.iter(|seq| {
                                        utf8c.add(&seq)?;
                                        Ok(())
                                    })?;
                                    utf8c.finish()
                                }
                            } else {
                                let mut builder = self.builder.borrow_mut();
                                let mut utf8_state = self.utf8_state.borrow_mut();
                                let mut utf8c =
                                    Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;
                                for rng in cls.iter() {
                                    for seq in Utf8Sequences::new(rng.start(), rng.end()) {
                                        utf8c.add(seq.as_slice())?;
                                    }
                                }
                                utf8c.finish()
                            }
                            /*
                            let it = cls
                                .iter()
                                .flat_map(|rng| Utf8Sequences::new(rng.start(), rng.end()))
                                .map(|seq| {
                                    let it = seq
                                        .as_slice()
                                        .iter()
                                        .map(|rng| self.c_range(rng.start, rng.end));
                                    self.c_concat(it)
                                });
                            self.c_alt_iter(it)
                            */
                        }
                        /// Compile the given Unicode character class in reverse with suffix
                        fn c_unicode_class_reverse_with_suffix(
                            &self,
                            cls: &hir::ClassUnicode,
                        ) -> Result<ThompsonRef, BuildError> {
                            let mut cache = self.utf8_suffix.borrow_mut();
                            cache.clear();

                            let union = self.add_union()?;
                            let alt_end = self.add_empty()?;
                            for urng in cls.iter() {
                                for seq in Utf8Sequences::new(urng.start(), urng.end()) {
                                    let mut end = alt_end;
                                    for brng in seq.as_slice() {
                                        let key = Utf8SuffixKey {
                                            from: end,
                                            start: brng.start,
                                            end: brng.end,
                                        };
                                        let hash = cache.hash(&key);
                                        if let Some(id) = cache.get(&key, hash) {
                                            end = id;
                                            continue;
                                        }

                                        let compiled = self.c_range(brng.start, brng.end)?;
                                        self.patch(compiled.end, end)?;
                                        end = compiled.start;
                                        cache.set(key, hash, end);
                                    }
                                    self.patch(union, end)?;
                                }
                            }
                            Ok(ThompsonRef { start: union, end: alt_end })
                        }
                        /// Compile the given HIR look-around assertion to an NFA look-around
                        fn c_look(&self, anchor: &hir::Look) -> Result<ThompsonRef, BuildError> {
                            let look = match *anchor {
                                hir::Look::Start => Look::Start,
                                hir::Look::End => Look::End,
                                hir::Look::StartLF => Look::StartLF,
                                hir::Look::EndLF => Look::EndLF,
                                hir::Look::StartCRLF => Look::StartCRLF,
                                hir::Look::EndCRLF => Look::EndCRLF,
                                hir::Look::WordAscii => Look::WordAscii,
                                hir::Look::WordAsciiNegate => Look::WordAsciiNegate,
                                hir::Look::WordUnicode => Look::WordUnicode,
                                hir::Look::WordUnicodeNegate => Look::WordUnicodeNegate,
                                hir::Look::WordStartAscii => Look::WordStartAscii,
                                hir::Look::WordEndAscii => Look::WordEndAscii,
                                hir::Look::WordStartUnicode => Look::WordStartUnicode,
                                hir::Look::WordEndUnicode => Look::WordEndUnicode,
                                hir::Look::WordStartHalfAscii => Look::WordStartHalfAscii,
                                hir::Look::WordEndHalfAscii => Look::WordEndHalfAscii,
                                hir::Look::WordStartHalfUnicode => Look::WordStartHalfUnicode,
                                hir::Look::WordEndHalfUnicode => Look::WordEndHalfUnicode,
                            };
                            let id = self.add_look(look)?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                        /// Compile the given byte string to a concatenation of bytes.
                        fn c_literal(&self, bytes: &[u8]) -> Result<ThompsonRef, BuildError> {
                            self.c_concat(bytes.iter().copied().map(|b| self.c_range(b, b)))
                        }
                        /// Compile a "range" state with one transition that may only be followed
                        fn c_range(&self, start: u8, end: u8) -> Result<ThompsonRef, BuildError> {
                            let id = self.add_range(start, end)?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                        /// Compile an "empty" state with one unconditional epsilon transition.
                        fn c_empty(&self) -> Result<ThompsonRef, BuildError> {
                            let id = self.add_empty()?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                        /// Compile a "fail" state that can never have any outgoing transitions.
                        fn c_fail(&self) -> Result<ThompsonRef, BuildError> {
                            let id = self.add_fail()?;
                            Ok(ThompsonRef { start: id, end: id })
                        }

                        fn patch(&self, from: StateID, to: StateID) -> Result<(), BuildError> {
                            self.builder.borrow_mut().patch(from, to)
                        }

                        fn start_pattern(&self) -> Result<PatternID, BuildError> {
                            self.builder.borrow_mut().start_pattern()
                        }

                        fn finish_pattern(
                            &self,
                            start_id: StateID,
                        ) -> Result<PatternID, BuildError> {
                            self.builder.borrow_mut().finish_pattern(start_id)
                        }

                        fn add_empty(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_empty()
                        }

                        fn add_range(&self, start: u8, end: u8) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_range(Transition {
                                start,
                                end,
                                next: StateID::ZERO,
                            })
                        }

                        fn add_sparse(
                            &self,
                            ranges: Vec<Transition>,
                        ) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_sparse(ranges)
                        }

                        fn add_look(&self, mut look: Look) -> Result<StateID, BuildError> {
                            if self.is_reverse() {
                                look = look.reversed();
                            }
                            self.builder.borrow_mut().add_look(StateID::ZERO, look)
                        }

                        fn add_union(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_union(vec![])
                        }

                        fn add_union_reverse(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_union_reverse(vec![])
                        }

                        fn add_capture_start(
                            &self,
                            capture_index: u32,
                            name: Option<&str>,
                        ) -> Result<StateID, BuildError> {
                            let name = name.map(Arc::from);
                            self.builder.borrow_mut().add_capture_start(
                                StateID::ZERO,
                                capture_index,
                                name,
                            )
                        }

                        fn add_capture_end(
                            &self,
                            capture_index: u32,
                        ) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_capture_end(StateID::ZERO, capture_index)
                        }

                        fn add_fail(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_fail()
                        }

                        fn add_match(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_match()
                        }

                        fn is_reverse(&self) -> bool {
                            self.config.get_reverse()
                        }
                    }
                    /// A value that represents the result of compiling a sub-expression of a
                    #[derive(Clone, Copy, Debug)]
                    pub struct ThompsonRef {
                        pub start: StateID,
                        pub end: StateID,
                    }
                    /// A UTF-8 compiler based on Daciuk's algorithm for compiling minimal DFAs
                    #[derive(Debug)]
                    struct Utf8Compiler<'a> {
                        builder: &'a mut Builder,
                        state: &'a mut Utf8State,
                        target: StateID,
                    }

                    #[derive(Clone, Debug)]
                    struct Utf8State {
                        compiled: Utf8BoundedMap,
                        uncompiled: Vec<Utf8Node>,
                    }

                    #[derive(Clone, Debug)]
                    struct Utf8Node {
                        trans: Vec<Transition>,
                        last: Option<Utf8LastTransition>,
                    }

                    #[derive(Clone, Debug)]
                    struct Utf8LastTransition {
                        start: u8,
                        end: u8,
                    }

                    impl Utf8State {
                        fn new() -> Utf8State {
                            Utf8State { compiled: Utf8BoundedMap::new(10_000), uncompiled: vec![] }
                        }

                        fn clear(&mut self) {
                            self.compiled.clear();
                            self.uncompiled.clear();
                        }
                    }

                    impl<'a> Utf8Compiler<'a>
                    {
                        fn new(
                            builder: &'a mut Builder,
                            state: &'a mut Utf8State,
                        ) -> Result<Utf8Compiler<'a>, BuildError> {
                            let target = builder.add_empty()?;
                            state.clear();
                            let mut utf8c = Utf8Compiler { builder, state, target };
                            utf8c.add_empty();
                            Ok(utf8c)
                        }

                        fn finish(&mut self) -> Result<ThompsonRef, BuildError> {
                            self.compile_from(0)?;
                            let node = self.pop_root();
                            let start = self.compile(node)?;
                            Ok(ThompsonRef { start, end: self.target })
                        }

                        fn add(&mut self, ranges: &[Utf8Range]) -> Result<(), BuildError> {
                            let prefix_len = ranges
                                .iter()
                                .zip(&self.state.uncompiled)
                                .take_while(|&(range, node)| {
                                    node.last.as_ref().map_or(false, |t| {
                                        (t.start, t.end) == (range.start, range.end)
                                    })
                                })
                                .count();
                            assert!(prefix_len < ranges.len());
                            self.compile_from(prefix_len)?;
                            self.add_suffix(&ranges[prefix_len..]);
                            Ok(())
                        }

                        fn compile_from(&mut self, from: usize) -> Result<(), BuildError> {
                            let mut next = self.target;
                            while from + 1 < self.state.uncompiled.len() {
                                let node = self.pop_freeze(next);
                                next = self.compile(node)?;
                            }
                            self.top_last_freeze(next);
                            Ok(())
                        }

                        fn compile(
                            &mut self,
                            node: Vec<Transition>,
                        ) -> Result<StateID, BuildError> {
                            let hash = self.state.compiled.hash(&node);
                            if let Some(id) = self.state.compiled.get(&node, hash) {
                                return Ok(id);
                            }
                            let id = self.builder.add_sparse(node.clone())?;
                            self.state.compiled.set(node, hash, id);
                            Ok(id)
                        }

                        fn add_suffix(&mut self, ranges: &[Utf8Range]) {
                            assert!(!ranges.is_empty());
                            let last = self
                                .state
                                .uncompiled
                                .len()
                                .checked_sub(1)
                                .expect("non-empty nodes");
                            assert!(self.state.uncompiled[last].last.is_none());
                            self.state.uncompiled[last].last = Some(Utf8LastTransition {
                                start: ranges[0].start,
                                end: ranges[0].end,
                            });
                            for r in &ranges[1..] {
                                self.state.uncompiled.push(Utf8Node {
                                    trans: vec![],
                                    last: Some(Utf8LastTransition { start: r.start, end: r.end }),
                                });
                            }
                        }

                        fn add_empty(&mut self) {
                            self.state.uncompiled.push(Utf8Node { trans: vec![], last: None });
                        }

                        fn pop_freeze(&mut self, next: StateID) -> Vec<Transition> {
                            let mut uncompiled = self.state.uncompiled.pop().unwrap();
                            uncompiled.set_last_transition(next);
                            uncompiled.trans
                        }

                        fn pop_root(&mut self) -> Vec<Transition> {
                            assert_eq!(self.state.uncompiled.len(), 1);
                            assert!(self.state.uncompiled[0].last.is_none());
                            self.state.uncompiled.pop().expect("non-empty nodes").trans
                        }

                        fn top_last_freeze(&mut self, next: StateID) {
                            let last = self
                                .state
                                .uncompiled
                                .len()
                                .checked_sub(1)
                                .expect("non-empty nodes");
                            self.state.uncompiled[last].set_last_transition(next);
                        }
                    }

                    impl Utf8Node {
                        fn set_last_transition(&mut self, next: StateID) {
                            if let Some(last) = self.last.take() {
                                self.trans.push(Transition {
                                    start: last.start,
                                    end: last.end,
                                    next,
                                });
                            }
                        }
                    }
                }

                pub mod error
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        captures, look,
                        primitives::{PatternID, StateID},
                    };
                    */
                    /// An error that can occurred during the construction of a thompson NFA.
                    #[derive(Clone, Debug)]
                    pub struct BuildError {
                        kind: BuildErrorKind,
                    }
                    /// The kind of error that occurred during the construction of a thompson NFA.
                    #[derive(Clone, Debug)]
                    enum BuildErrorKind {
                        /// An error that occurred while parsing a regular expression. Note that
                            Syntax(regex_syntax::Error),
                        /// An error that occurs if the capturing groups provided to an NFA builder
                        Captures(captures::GroupInfoError),
                        /// An error that occurs when an NFA contains a Unicode word boundary, but
                        Word(look::UnicodeWordBoundaryError),
                        /// An error that occurs if too many patterns were given to the NFA
                        TooManyPatterns {
                            /// The number of patterns given, which exceeds the limit.
                            given: usize,
                            /// The limit on the number of patterns.
                            limit: usize,
                        },
                        /// An error that occurs if too states are produced while building an NFA.
                        TooManyStates {
                            /// The minimum number of states that are desired, which exceeds the
                            given: usize,
                            /// The limit on the number of states.
                            limit: usize,
                        },
                        /// An error that occurs when NFA compilation exceeds a configured heap
                        ExceededSizeLimit {
                            /// The configured limit, in bytes.
                            limit: usize,
                        },
                        /// An error that occurs when an invalid capture group index is added to
                        InvalidCaptureIndex {
                            /// The invalid index that was given.
                            index: u32,
                        },
                        /// An error that occurs when one tries to build a reverse NFA with
                            UnsupportedCaptures,
                    }

                    impl BuildError {
                        /// If this error occurred because the NFA exceeded the configured size
                        pub fn size_limit(&self) -> Option<usize> {
                            match self.kind {
                                BuildErrorKind::ExceededSizeLimit { limit } => Some(limit),
                                _ => None,
                            }
                        }

                        fn kind(&self) -> &BuildErrorKind {
                            &self.kind
                        }

                            pub fn syntax(err: regex_syntax::Error) -> BuildError {
                            BuildError { kind: BuildErrorKind::Syntax(err) }
                        }

                        pub fn captures(err: captures::GroupInfoError) -> BuildError {
                            BuildError { kind: BuildErrorKind::Captures(err) }
                        }

                        pub fn word(err: look::UnicodeWordBoundaryError) -> BuildError {
                            BuildError { kind: BuildErrorKind::Word(err) }
                        }

                        pub fn too_many_patterns(given: usize) -> BuildError {
                            let limit = PatternID::LIMIT;
                            BuildError { kind: BuildErrorKind::TooManyPatterns { given, limit } }
                        }

                        pub fn too_many_states(given: usize) -> BuildError {
                            let limit = StateID::LIMIT;
                            BuildError { kind: BuildErrorKind::TooManyStates { given, limit } }
                        }

                        pub fn exceeded_size_limit(limit: usize) -> BuildError {
                            BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit } }
                        }

                        pub fn invalid_capture_index(index: u32) -> BuildError {
                            BuildError { kind: BuildErrorKind::InvalidCaptureIndex { index } }
                        }

                            pub fn unsupported_captures() -> BuildError {
                            BuildError { kind: BuildErrorKind::UnsupportedCaptures }
                        }
                    }
                    
                    impl ::error::Error for BuildError {
                        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                            match self.kind() {
                                            BuildErrorKind::Syntax(ref err) => Some(err),
                                BuildErrorKind::Captures(ref err) => Some(err),
                                _ => None,
                            }
                        }
                    }

                    impl ::fmt::Display for BuildError {
                        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                            match self.kind() {
                                            BuildErrorKind::Syntax(_) => write!(f, "error parsing regex"),
                                BuildErrorKind::Captures(_) => {
                                    write!(f, "error with capture groups")
                                }
                                BuildErrorKind::Word(_) => {
                                    write!(f, "NFA contains Unicode word boundary")
                                }
                                BuildErrorKind::TooManyPatterns { given, limit } => write!(
                                    f,
                                    "attempted to compile {given} patterns, \
                                    which exceeds the limit of {limit}",
                                ),
                                BuildErrorKind::TooManyStates { given, limit } => write!(
                                    f,
                                    "attempted to compile {given} NFA states, \
                                    which exceeds the limit of {limit}",
                                ),
                                BuildErrorKind::ExceededSizeLimit { limit } => write!(
                                    f,
                                    "heap usage during NFA compilation exceeded limit of {limit}",
                                ),
                                BuildErrorKind::InvalidCaptureIndex { index } => write!(
                                    f,
                                    "capture group index {index} is invalid \
                                    (too big or discontinuous)",
                                ),
                                            BuildErrorKind::UnsupportedCaptures => write!(
                                    f,
                                    "currently captures must be disabled when compiling \
                                    a reverse NFA",
                                ),
                            }
                        }
                    }

                }

                pub mod literal_trie
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::mem;

                    use ::{vec, vec::Vec};

                    use crate::{
                        nfa::thompson::{self, compiler::ThompsonRef, BuildError, Builder},
                        util::primitives::{IteratorIndexExt, StateID},
                    };
                    */
                    /// A trie that preserves leftmost-first match semantics.
                    #[derive(Clone)]
                    pub struct LiteralTrie {
                        /// The set of trie states. Each state contains one or more chunks, where
                        states: Vec<State>,
                        /// Whether to add literals in reverse to the trie. Useful when building
                        rev: bool,
                    }

                    impl LiteralTrie {
                        /// Create a new literal trie that adds literals in the forward direction.
                        pub fn forward() -> LiteralTrie {
                            let root = State::default();
                            LiteralTrie { states: vec![root], rev: false }
                        }
                        /// Create a new literal trie that adds literals in reverse.
                        pub fn reverse() -> LiteralTrie {
                            let root = State::default();
                            LiteralTrie { states: vec![root], rev: true }
                        }
                        /// Add the given literal to this trie.
                        pub fn add(&mut self, bytes: &[u8]) -> Result<(), BuildError> {
                            let mut prev = StateID::ZERO;
                            let mut it = bytes.iter().copied();
                            while let Some(b) = if self.rev { it.next_back() } else { it.next() } {
                                prev = self.get_or_add_state(prev, b)?;
                            }
                            self.states[prev].add_match();
                            Ok(())
                        }
                        /// If the given transition is defined, then return the next state ID.
                        fn get_or_add_state(
                            &mut self,
                            from: StateID,
                            byte: u8,
                        ) -> Result<StateID, BuildError> {
                            let active = self.states[from].active_chunk();
                            match active.binary_search_by_key(&byte, |t| t.byte) {
                                Ok(i) => Ok(active[i].next),
                                Err(i) => {
                                    // Add a new state and get its ID.
                                    let next = StateID::new(self.states.len()).map_err(|_| {
                                        BuildError::too_many_states(self.states.len())
                                    })?;
                                    self.states.push(State::default());
                                    let i = self.states[from].active_chunk_start() + i;
                                    let t = Transition { byte, next };
                                    self.states[from].transitions.insert(i, t);
                                    Ok(next)
                                }
                            }
                        }
                        /// Compile this literal trie to the NFA builder given.
                        pub fn compile(
                            &self,
                            builder: &mut Builder,
                        ) -> Result<ThompsonRef, BuildError> {
                            let end = builder.add_empty()?;
                            let mut stack = vec![];
                            let mut f = Frame::new(&self.states[StateID::ZERO]);
                            loop {
                                if let Some(t) = f.transitions.next() {
                                    if self.states[t.next].is_leaf() {
                                        f.sparse.push(thompson::Transition {
                                            start: t.byte,
                                            end: t.byte,
                                            next: end,
                                        });
                                    } else {
                                        f.sparse.push(thompson::Transition {
                                            start: t.byte,
                                            end: t.byte,
                                            next: StateID::ZERO,
                                        });
                                        stack.push(f);
                                        f = Frame::new(&self.states[t.next]);
                                    }
                                    continue;
                                }
                                if !f.sparse.is_empty() {
                                    let chunk_id = if f.sparse.len() == 1 {
                                        builder.add_range(f.sparse.pop().unwrap())?
                                    } else {
                                        let sparse = mem::replace(&mut f.sparse, vec![]);
                                        builder.add_sparse(sparse)?
                                    };
                                    f.union.push(chunk_id);
                                }
                                // Now we need to look to see if there are other chunks to visit.
                                if let Some(chunk) = f.chunks.next() {
                                    f.union.push(end);
                                    // Advance to the next chunk.
                                    f.transitions = chunk.iter();
                                    continue;
                                }
                                let start = builder.add_union(f.union)?;
                                match stack.pop() {
                                    None => {
                                        return Ok(ThompsonRef { start, end });
                                    }
                                    Some(mut parent) => {
                                        parent.sparse.last_mut().unwrap().next = start;
                                        f = parent;
                                    }
                                }
                            }
                        }
                    }

                    impl ::fmt::Debug for LiteralTrie {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            writeln!(f, "LiteralTrie(")?;
                            for (sid, state) in self.states.iter().with_state_ids() {
                                writeln!(f, "{:06?}: {:?}", sid.as_usize(), state)?;
                            }
                            writeln!(f, ")")?;
                            Ok(())
                        }
                    }
                    /// An explicit stack frame used for traversing the trie without using
                    #[derive(Debug)]
                    struct Frame<'a> {
                        /// The remaining chunks to visit for a trie state.
                        chunks: StateChunksIter<'a>,
                        /// The transitions of the current chunk that we're iterating over. Since
                        transitions: ::slice::Iter<'a, Transition>,
                        /// The NFA state IDs pointing to the start of each chunk compiled by
                        union: Vec<StateID>,
                        /// The actual NFA transitions for a single chunk in a trie state. This
                        sparse: Vec<thompson::Transition>,
                    }

                    impl<'a> Frame<'a> {
                        /// Create a new stack frame for trie traversal. This initializes the
                        fn new(state: &'a State) -> Frame<'a> {
                            let mut chunks = state.chunks();
                            // every state has at least 1 chunk
                            let chunk = chunks.next().unwrap();
                            let transitions = chunk.iter();
                            Frame { chunks, transitions, union: vec![], sparse: vec![] }
                        }
                    }
                    /// A state in a trie.
                    #[derive(Clone, Default)]
                    struct State {
                        transitions: Vec<Transition>,
                        chunks: Vec<(usize, usize)>,
                    }

                    impl State {
                        /// Mark this state as a match state and freeze the active chunk such that
                        fn add_match(&mut self) {
                            if self.transitions.is_empty() && !self.chunks.is_empty() {
                                return;
                            }
                            let chunk_start = self.active_chunk_start();
                            let chunk_end = self.transitions.len();
                            self.chunks.push((chunk_start, chunk_end));
                        }
                        /// Returns true if and only if this state is a leaf state. That is, a
                        fn is_leaf(&self) -> bool {
                            self.transitions.is_empty()
                        }
                        /// Returns an iterator over all of the chunks (including the currently
                        fn chunks(&self) -> StateChunksIter<'_> {
                            StateChunksIter {
                                transitions: &*self.transitions,
                                chunks: self.chunks.iter(),
                                active: Some(self.active_chunk()),
                            }
                        }
                        /// Returns the active chunk as a slice of transitions.
                        fn active_chunk(&self) -> &[Transition] {
                            let start = self.active_chunk_start();
                            &self.transitions[start..]
                        }
                        /// Returns the index into 'transitions' where the active chunk starts.
                        fn active_chunk_start(&self) -> usize {
                            self.chunks.last().map_or(0, |&(_, end)| end)
                        }
                    }

                    impl ::fmt::Debug for State {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut spacing = " ";
                            for (i, chunk) in self.chunks().enumerate()
                            {
                                if i > 0 {
                                    write!(f, "{spacing}MATCH")?;
                                }
                                spacing = "";
                                for (j, t) in chunk.iter().enumerate() {
                                    spacing = " ";
                                    if j == 0 && i > 0 {
                                        write!(f, " ")?;
                                    } else if j > 0 {
                                        write!(f, ", ")?;
                                    }
                                    write!(f, "{t:?}")?;
                                }
                            }
                            Ok(())
                        }
                    }
                    /// An iterator over all of the chunks in a state, including the active chunk.
                    #[derive(Debug)]
                    struct StateChunksIter<'a> {
                        transitions: &'a [Transition],
                        chunks: ::slice::Iter<'a, (usize, usize)>,
                        active: Option<&'a [Transition]>,
                    }

                    impl<'a> Iterator for StateChunksIter<'a> {
                        type Item = &'a [Transition];

                        fn next(&mut self) -> Option<&'a [Transition]> {
                            if let Some(&(start, end)) = self.chunks.next() {
                                return Some(&self.transitions[start..end]);
                            }
                            
                            if let Some(chunk) = self.active.take() {
                                return Some(chunk);
                            }
                            None
                        }
                    }
                    /// A single transition in a trie to another state.
                    #[derive(Clone, Copy)]
                    struct Transition {
                        byte: u8,
                        next: StateID,
                    }

                    impl ::fmt::Debug for Transition {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(
                                f,
                                "{:?} => {}",
                                crate::util::escape::DebugByte(self.byte),
                                self.next.as_usize()
                            )
                        }
                    }
                }

                pub mod map
                {
                    /*!
                    This module contains a couple simple and purpose built hash maps. */
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::{vec, vec::Vec};

                    use crate::{
                        nfa::thompson::Transition,
                        util::{
                            int::{Usize, U64},
                            primitives::StateID,
                        },
                    };

                    */
                    const PRIME: u64 = 1099511628211;
                    const INIT: u64 = 14695981039346656037;
                    /// A bounded hash map where the key is a sequence of NFA transitions and the
                    #[derive(Clone, Debug)]
                    pub struct Utf8BoundedMap {
                        /// The current version of this map. Only entries with matching versions
                        version: u16,
                        /// The total number of entries this map can store.
                        capacity: usize,
                        /// The actual entries, keyed by hash. Collisions between different states
                        map: Vec<Utf8BoundedEntry>,
                    }
                    /// An entry in this map.
                    #[derive(Clone, Debug, Default)]
                    struct Utf8BoundedEntry {
                        /// The version of the map used to produce this entry. If this entry's
                        version: u16,
                        /// The key, which is a sorted sequence of non-overlapping NFA transitions.
                        key: Vec<Transition>,
                        /// The state ID corresponding to the state containing the transitions in
                        val: StateID,
                    }

                    impl Utf8BoundedMap {
                        /// Create a new bounded map with the given capacity. The map will never
                        pub fn new(capacity: usize) -> Utf8BoundedMap {
                            assert!(capacity > 0);
                            Utf8BoundedMap { version: 0, capacity, map: vec![] }
                        }
                        /// Clear this map of all entries, but permit the reuse of allocation
                        pub fn clear(&mut self) {
                            if self.map.is_empty() {
                                self.map = vec![Utf8BoundedEntry::default(); self.capacity];
                            } else {
                                self.version = self.version.wrapping_add(1);
                                
                                if self.version == 0 {
                                    self.map = vec![Utf8BoundedEntry::default(); self.capacity];
                                }
                            }
                        }
                        /// Return a hash of the given transitions.
                        pub fn hash(&self, key: &[Transition]) -> usize {
                            let mut h = INIT;
                            for t in key {
                                h = (h ^ u64::from(t.start)).wrapping_mul(PRIME);
                                h = (h ^ u64::from(t.end)).wrapping_mul(PRIME);
                                h = (h ^ t.next.as_u64()).wrapping_mul(PRIME);
                            }
                            (h % self.map.len().as_u64()).as_usize()
                        }
                        /// Retrieve the cached state ID corresponding to the given key. The hash
                        pub fn get(&mut self, key: &[Transition], hash: usize) -> Option<StateID> {
                            let entry = &self.map[hash];
                            if entry.version != self.version {
                                return None;
                            }
                            // There may be a hash collision, so we need to confirm real equality.
                            if entry.key != key {
                                return None;
                            }
                            Some(entry.val)
                        }
                        /// Add a cached state to this map with the given key. Callers should
                        pub fn set(
                            &mut self,
                            key: Vec<Transition>,
                            hash: usize,
                            state_id: StateID,
                        ) {
                            self.map[hash] =
                                Utf8BoundedEntry { version: self.version, key, val: state_id };
                        }
                    }
                    /// A cache of suffixes used to modestly compress UTF-8 automata for large
                    #[derive(Clone, Debug)]
                    pub struct Utf8SuffixMap {
                        /// The current version of this map. Only entries with matching versions
                        version: u16,
                        /// The total number of entries this map can store.
                        capacity: usize,
                        /// The actual entries, keyed by hash. Collisions between different states
                        map: Vec<Utf8SuffixEntry>,
                    }
                    /// A key that uniquely identifies an NFA state. It is a triple that represents
                    #[derive(Clone, Debug, Default, Eq, PartialEq)]
                    pub struct Utf8SuffixKey {
                        pub from: StateID,
                        pub start: u8,
                        pub end: u8,
                    }
                    /// An entry in this map.
                    #[derive(Clone, Debug, Default)]
                    struct Utf8SuffixEntry {
                        /// The version of the map used to produce this entry. If this entry's
                        version: u16,
                        /// The key, which consists of a transition in a particular state.
                        key: Utf8SuffixKey,
                        /// The identifier that the transition in the key maps to.
                        val: StateID,
                    }

                    impl Utf8SuffixMap {
                        /// Create a new bounded map with the given capacity. The map will never
                        pub fn new(capacity: usize) -> Utf8SuffixMap {
                            assert!(capacity > 0);
                            Utf8SuffixMap { version: 0, capacity, map: vec![] }
                        }
                        /// Clear this map of all entries, but permit the reuse of allocation
                        pub fn clear(&mut self) {
                            if self.map.is_empty() {
                                self.map = vec![Utf8SuffixEntry::default(); self.capacity];
                            } else {
                                self.version = self.version.wrapping_add(1);
                                
                                if self.version == 0 {
                                    self.map = vec![Utf8SuffixEntry::default(); self.capacity];
                                }
                            }
                        }
                        /// Return a hash of the given transition.
                        pub fn hash(&self, key: &Utf8SuffixKey) -> usize {
                            const PRIME: u64 = 1099511628211;
                            const INIT: u64 = 14695981039346656037;

                            let mut h = INIT;
                            h = (h ^ key.from.as_u64()).wrapping_mul(PRIME);
                            h = (h ^ u64::from(key.start)).wrapping_mul(PRIME);
                            h = (h ^ u64::from(key.end)).wrapping_mul(PRIME);
                            (h % self.map.len().as_u64()).as_usize()
                        }
                        /// Retrieve the cached state ID corresponding to the given key. The hash
                        pub fn get(
                            &mut self,
                            key: &Utf8SuffixKey,
                            hash: usize,
                        ) -> Option<StateID> {
                            let entry = &self.map[hash];
                            if entry.version != self.version {
                                return None;
                            }
                            
                            if key != &entry.key {
                                return None;
                            }
                            Some(entry.val)
                        }
                        /// Add a cached state to this map with the given key. Callers should
                        pub fn set(&mut self, key: Utf8SuffixKey, hash: usize, state_id: StateID) {
                            self.map[hash] =
                                Utf8SuffixEntry { version: self.version, key, val: state_id };
                        }
                    }
                }

                pub mod nfa
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::{fmt, mem};

                    use ::{boxed::Box, format, string::String, sync::Arc, vec, vec::Vec};

                    use crate::nfa::thompson::{
                        compiler::{Compiler, Config},
                        error::BuildError,
                    };
                    use crate::{
                        nfa::thompson::builder::Builder,
                        util::{
                            alphabet::{self, ByteClassSet, ByteClasses},
                            captures::{GroupInfo, GroupInfoError},
                            look::{Look, LookMatcher, LookSet},
                            primitives::{
                                IteratorIndexExt, PatternID, PatternIDIter, SmallIndex, StateID,
                            },
                            sparse_set::SparseSet,
                        },
                    };
                    */
                    /// A byte oriented Thompson non-deterministic finite automaton (NFA).
                    #[derive(Clone)]
                    pub struct NFA(
                        Arc<Inner>,
                    );

                    impl NFA {
                        /// Parse the given regular expression using a default configuration and
                            pub fn new(pattern: &str) -> Result<NFA, BuildError> {
                            NFA::compiler().build(pattern)
                        }
                        /// Parse the given regular expressions using a default configuration and
                            pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<NFA, BuildError> {
                            NFA::compiler().build_many(patterns)
                        }
                        /// Returns an NFA with a single regex pattern that always matches at every
                        pub fn always_match() -> NFA {
                            let mut builder = Builder::new();
                            let pid = builder.start_pattern().unwrap();
                            assert_eq!(pid.as_usize(), 0);
                            let start_id =
                                builder.add_capture_start(StateID::ZERO, 0, None).unwrap();
                            let end_id = builder.add_capture_end(StateID::ZERO, 0).unwrap();
                            let match_id = builder.add_match().unwrap();
                            builder.patch(start_id, end_id).unwrap();
                            builder.patch(end_id, match_id).unwrap();
                            let pid = builder.finish_pattern(start_id).unwrap();
                            assert_eq!(pid.as_usize(), 0);
                            builder.build(start_id, start_id).unwrap()
                        }
                        /// Returns an NFA that never matches at any position.
                        pub fn never_match() -> NFA {
                            let mut builder = Builder::new();
                            let sid = builder.add_fail().unwrap();
                            builder.build(sid, sid).unwrap()
                        }
                        /// Return a default configuration for an `NFA`.
                            pub fn config() -> Config {
                            Config::new()
                        }
                        /// Return a compiler for configuring the construction of an `NFA`.
                            pub fn compiler() -> Compiler {
                            Compiler::new()
                        }
                        /// Returns an iterator over all pattern identifiers in this NFA.
                        pub fn patterns(&self) -> PatternIter<'_> {
                            PatternIter {
                                it: PatternID::iter(self.pattern_len()),
                                _marker: ::marker::PhantomData,
                            }
                        }
                        /// Returns the total number of regex patterns in this NFA.
                        #[inline]
                        pub fn pattern_len(&self) -> usize {
                            self.0.start_pattern.len()
                        }
                        /// Return the state identifier of the initial anchored state of this NFA.
                        #[inline]
                        pub fn start_anchored(&self) -> StateID {
                            self.0.start_anchored
                        }
                        /// Return the state identifier of the initial unanchored state of this
                        #[inline]
                        pub fn start_unanchored(&self) -> StateID {
                            self.0.start_unanchored
                        }
                        /// Return the state identifier of the initial anchored state for the given
                        #[inline]
                        pub fn start_pattern(&self, pid: PatternID) -> Option<StateID> {
                            self.0.start_pattern.get(pid.as_usize()).copied()
                        }
                        /// Get the byte class set for this NFA.
                        #[inline]
                        pub fn byte_class_set(&self) -> &ByteClassSet {
                            &self.0.byte_class_set
                        }
                        /// Get the byte classes for this NFA.
                        #[inline]
                        pub fn byte_classes(&self) -> &ByteClasses {
                            &self.0.byte_classes
                        }
                        /// Return a reference to the NFA state corresponding to the given ID.
                        #[inline]
                        pub fn state(&self, id: StateID) -> &State {
                            &self.states()[id]
                        }
                        /// Returns a slice of all states in this NFA.
                        #[inline]
                        pub fn states(&self) -> &[State] {
                            &self.0.states
                        }
                        /// Returns the capturing group info for this NFA.
                        #[inline]
                        pub fn group_info(&self) -> &GroupInfo {
                            &self.0.group_info()
                        }
                        /// Returns true if and only if this NFA has at least one
                        #[inline]
                        pub fn has_capture(&self) -> bool {
                            self.0.has_capture
                        }
                        /// Returns true if and only if this NFA can match the empty string.
                        #[inline]
                        pub fn has_empty(&self) -> bool {
                            self.0.has_empty
                        }
                        /// Whether UTF-8 mode is enabled for this NFA or not.
                        #[inline]
                        pub fn is_utf8(&self) -> bool {
                            self.0.utf8
                        }
                        /// Returns true when this NFA is meant to be matched in reverse.
                        #[inline]
                        pub fn is_reverse(&self) -> bool {
                            self.0.reverse
                        }
                        /// Returns true if and only if all starting states for this NFA correspond
                        #[inline]
                        pub fn is_always_start_anchored(&self) -> bool {
                            self.start_anchored() == self.start_unanchored()
                        }
                        /// Returns the look-around matcher associated with this NFA.
                        #[inline]
                        pub fn look_matcher(&self) -> &LookMatcher {
                            &self.0.look_matcher
                        }
                        /// Returns the union of all look-around assertions used throughout this
                        #[inline]
                        pub fn look_set_any(&self) -> LookSet {
                            self.0.look_set_any
                        }
                        /// Returns the union of all prefix look-around assertions for every
                        #[inline]
                        pub fn look_set_prefix_any(&self) -> LookSet {
                            self.0.look_set_prefix_any
                        }
                        /*
                        /// Returns the intersection of all prefix look-around assertions for every
                        #[inline]
                        pub fn look_set_prefix_all(&self) -> LookSet {
                            self.0.look_set_prefix_all
                        }
                        */

                        /// Returns the memory usage, in bytes, of this NFA.
                        #[inline]
                        pub fn memory_usage(&self) -> usize {
                            use ::mem::size_of;

                            size_of::<Inner>() // allocated on the heap via Arc
                                + self.0.states.len() * size_of::<State>()
                                + self.0.start_pattern.len() * size_of::<StateID>()
                                + self.0.group_info.memory_usage()
                                + self.0.memory_extra
                        }
                    }

                    impl fmt::Debug for NFA {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            self.0.fmt(f)
                        }
                    }
                    /// The "inner" part of the NFA. We split this part out so that we can easily
                    #[derive(Default)]
                    pub(super) struct Inner {
                        /// The state sequence. This sequence is guaranteed to be indexable by all
                        states: Vec<State>,
                        /// The anchored starting state of this NFA.
                        start_anchored: StateID,
                        /// The unanchored starting state of this NFA.
                        start_unanchored: StateID,
                        /// The starting states for each individual pattern. Starting at any
                        start_pattern: Vec<StateID>,
                        /// Info about the capturing groups in this NFA. This is responsible for
                        group_info: GroupInfo,
                        /// A representation of equivalence classes over the transitions in this
                        byte_class_set: ByteClassSet,
                        /// This is generated from `byte_class_set`, and essentially represents the
                        byte_classes: ByteClasses,
                        /// Whether this NFA has a `Capture` state anywhere.
                        has_capture: bool,
                        /// When the empty string is in the language matched by this NFA.
                        has_empty: bool,
                        /// Whether UTF-8 mode is enabled for this NFA. Briefly, this means that
                        utf8: bool,
                        /// Whether this NFA is meant to be matched in reverse or not.
                        reverse: bool,
                        /// The matcher to be used for look-around assertions.
                        look_matcher: LookMatcher,
                        /// The union of all look-around assertions that occur anywhere within
                        look_set_any: LookSet,
                        /// The union of all look-around assertions that occur as a zero-length
                        look_set_prefix_any: LookSet,
                        /*
                        /// The intersection of all look-around assertions that occur as a
                        look_set_prefix_all: LookSet,
                        */
                        /// Heap memory used indirectly by NFA states and other things (like the
                        memory_extra: usize,
                    }

                    impl Inner {
                        /// Runs any last finalization bits and turns this into a full NFA.
                        pub(super) fn into_nfa(mut self) -> NFA {
                            self.byte_classes = self.byte_class_set.byte_classes();
                            let mut stack = vec![];
                            let mut seen = SparseSet::new(self.states.len());
                            for &start_id in self.start_pattern.iter() {
                                stack.push(start_id);
                                seen.clear();
                                // let mut prefix_all = LookSet::full();
                                let mut prefix_any = LookSet::empty();
                                while let Some(sid) = stack.pop() {
                                    if !seen.insert(sid) {
                                        continue;
                                    }
                                    match self.states[sid] {
                                        State::ByteRange { .. }
                                        | State::Dense { .. }
                                        | State::Fail => continue,
                                        State::Sparse(_) => {
                                            continue;
                                        }
                                        State::Match { .. } => self.has_empty = true,
                                        State::Look { look, next } => {
                                            prefix_any = prefix_any.insert(look);
                                            stack.push(next);
                                        }
                                        State::Union { ref alternates } => {
                                            stack.extend(alternates.iter());
                                        }
                                        State::BinaryUnion { alt1, alt2 } => {
                                            stack.push(alt2);
                                            stack.push(alt1);
                                        }
                                        State::Capture { next, .. } => {
                                            stack.push(next);
                                        }
                                    }
                                }
                                self.look_set_prefix_any =
                                    self.look_set_prefix_any.union(prefix_any);
                            }
                            NFA(Arc::new(self))
                        }
                        /// Returns the capturing group info for this NFA.
                        pub(super) fn group_info(&self) -> &GroupInfo {
                            &self.group_info
                        }
                        /// Add the given state to this NFA after allocating a fresh identifier for
                        pub(super) fn add(&mut self, state: State) -> StateID {
                            match state {
                                State::ByteRange { ref trans } => {
                                    self.byte_class_set.set_range(trans.start, trans.end);
                                }
                                State::Sparse(ref sparse) => {
                                    for trans in sparse.transitions.iter() {
                                        self.byte_class_set.set_range(trans.start, trans.end);
                                    }
                                }
                                State::Dense { .. } => unreachable!(),
                                State::Look { look, .. } => {
                                    self.look_matcher
                                        .add_to_byteset(look, &mut self.byte_class_set);
                                    self.look_set_any = self.look_set_any.insert(look);
                                }
                                State::Capture { .. } => {
                                    self.has_capture = true;
                                }
                                State::Union { .. }
                                | State::BinaryUnion { .. }
                                | State::Fail
                                | State::Match { .. } => {}
                            }

                            let id = StateID::new(self.states.len()).unwrap();
                            self.memory_extra += state.memory_usage();
                            self.states.push(state);
                            id
                        }
                        /// Set the starting state identifiers for this NFA.
                        pub(super) fn set_starts(
                            &mut self,
                            start_anchored: StateID,
                            start_unanchored: StateID,
                            start_pattern: &[StateID],
                        ) {
                            self.start_anchored = start_anchored;
                            self.start_unanchored = start_unanchored;
                            self.start_pattern = start_pattern.to_vec();
                        }
                        /// Sets the UTF-8 mode of this NFA.
                        pub(super) fn set_utf8(&mut self, yes: bool) {
                            self.utf8 = yes;
                        }
                        /// Sets the reverse mode of this NFA.
                        pub(super) fn set_reverse(&mut self, yes: bool) {
                            self.reverse = yes;
                        }
                        /// Sets the look-around assertion matcher for this NFA.
                        pub(super) fn set_look_matcher(&mut self, m: LookMatcher) {
                            self.look_matcher = m;
                        }
                        /// Set the capturing groups for this NFA.
                        pub(super) fn set_captures(
                            &mut self,
                            captures: &[Vec<Option<Arc<str>>>],
                        ) -> Result<(), GroupInfoError> {
                            self.group_info = GroupInfo::new(
                                captures.iter().map(|x| x.iter().map(|y| y.as_ref())),
                            )?;
                            Ok(())
                        }
                        /// Remap the transitions in every state of this NFA using the given map.
                        pub(super) fn remap(&mut self, old_to_new: &[StateID]) {
                            for state in &mut self.states {
                                state.remap(old_to_new);
                            }
                            self.start_anchored = old_to_new[self.start_anchored];
                            self.start_unanchored = old_to_new[self.start_unanchored];
                            for id in self.start_pattern.iter_mut() {
                                *id = old_to_new[*id];
                            }
                        }
                    }

                    impl fmt::Debug for Inner {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            writeln!(f, "thompson::NFA(")?;
                            for (sid, state) in self.states.iter().with_state_ids() {
                                let status = if sid == self.start_anchored {
                                    '^'
                                } else if sid == self.start_unanchored {
                                    '>'
                                } else {
                                    ' '
                                };
                                writeln!(f, "{}{:06?}: {:?}", status, sid.as_usize(), state)?;
                            }
                            let pattern_len = self.start_pattern.len();
                            if pattern_len > 1 {
                                writeln!(f)?;
                                for pid in 0..pattern_len {
                                    let sid = self.start_pattern[pid];
                                    writeln!(f, "START({:06?}): {:?}", pid, sid.as_usize())?;
                                }
                            }
                            writeln!(f)?;
                            writeln!(
                                f,
                                "transition equivalence classes: {:?}",
                                self.byte_classes,
                            )?;
                            writeln!(f, ")")?;
                            Ok(())
                        }
                    }
                    /// A state in an NFA.
                    #[derive(Clone, Eq, PartialEq)]
                    pub enum State {
                        /// A state with a single transition that can only be taken if the current
                        ByteRange {
                            /// The transition from this state to the next.
                            trans: Transition,
                        },
                        /// A state with possibly many transitions represented in a sparse fashion.
                        Sparse(SparseTransitions),
                        /// A dense representation of a state with multiple transitions.
                        Dense(DenseTransitions),
                        /// A conditional epsilon transition satisfied via some sort of
                        Look {
                            /// The look-around assertion that must be satisfied before moving
                            look: Look,
                            /// The state to transition to if the look-around assertion is
                            next: StateID,
                        },
                        /// An alternation such that there exists an epsilon transition to all
                        Union {
                            /// An ordered sequence of unconditional epsilon transitions to other
                            alternates: Box<[StateID]>,
                        },
                        /// An alternation such that there exists precisely two unconditional
                        BinaryUnion {
                            /// An unconditional epsilon transition to another NFA state. This
                            alt1: StateID,
                            /// An unconditional epsilon transition to another NFA state. Matches
                            alt2: StateID,
                        },
                        /// An empty state that records a capture location.
                        Capture {
                            /// The state to transition to, unconditionally.
                            next: StateID,
                            /// The pattern ID that this capture belongs to.
                            pattern_id: PatternID,
                            /// The capture group index that this capture belongs to. Capture group
                            group_index: SmallIndex,
                            /// The slot index for this capture. Every capturing group has two
                            slot: SmallIndex,
                        },
                        /// A state that cannot be transitioned out of. This is useful for cases
                        Fail,
                        /// A match state. There is at least one such occurrence of this state for
                        Match {
                            /// The matching pattern ID.
                            pattern_id: PatternID,
                        },
                    }

                    impl State {
                        /// Returns true if and only if this state contains one or more epsilon
                        #[inline]
                        pub fn is_epsilon(&self) -> bool {
                            match *self {
                                State::ByteRange { .. }
                                | State::Sparse { .. }
                                | State::Dense { .. }
                                | State::Fail
                                | State::Match { .. } => false,
                                State::Look { .. }
                                | State::Union { .. }
                                | State::BinaryUnion { .. }
                                | State::Capture { .. } => true,
                            }
                        }
                        /// Returns the heap memory usage of this NFA state in bytes.
                        fn memory_usage(&self) -> usize {
                            match *self {
                                State::ByteRange { .. }
                                | State::Look { .. }
                                | State::BinaryUnion { .. }
                                | State::Capture { .. }
                                | State::Match { .. }
                                | State::Fail => 0,
                                State::Sparse(SparseTransitions { ref transitions }) => {
                                    transitions.len() * mem::size_of::<Transition>()
                                }
                                State::Dense { .. } => 256 * mem::size_of::<StateID>(),
                                State::Union { ref alternates } => {
                                    alternates.len() * mem::size_of::<StateID>()
                                }
                            }
                        }
                        /// Remap the transitions in this state using the given map. Namely, the
                        fn remap(&mut self, remap: &[StateID]) {
                            match *self {
                                State::ByteRange { ref mut trans } => {
                                    trans.next = remap[trans.next]
                                }
                                State::Sparse(SparseTransitions { ref mut transitions }) => {
                                    for t in transitions.iter_mut() {
                                        t.next = remap[t.next];
                                    }
                                }
                                State::Dense(DenseTransitions { ref mut transitions }) => {
                                    for sid in transitions.iter_mut() {
                                        *sid = remap[*sid];
                                    }
                                }
                                State::Look { ref mut next, .. } => *next = remap[*next],
                                State::Union { ref mut alternates } => {
                                    for alt in alternates.iter_mut() {
                                        *alt = remap[*alt];
                                    }
                                }
                                State::BinaryUnion { ref mut alt1, ref mut alt2 } => {
                                    *alt1 = remap[*alt1];
                                    *alt2 = remap[*alt2];
                                }
                                State::Capture { ref mut next, .. } => *next = remap[*next],
                                State::Fail => {}
                                State::Match { .. } => {}
                            }
                        }
                    }

                    impl fmt::Debug for State {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            match *self {
                                State::ByteRange { ref trans } => trans.fmt(f),
                                State::Sparse(SparseTransitions { ref transitions }) => {
                                    let rs = transitions
                                        .iter()
                                        .map(|t| format!("{t:?}"))
                                        .collect::<Vec<String>>()
                                        .join(", ");
                                    write!(f, "sparse({rs})")
                                }
                                State::Dense(ref dense) => {
                                    write!(f, "dense(")?;
                                    for (i, t) in dense.iter().enumerate() {
                                        if i > 0 {
                                            write!(f, ", ")?;
                                        }
                                        write!(f, "{t:?}")?;
                                    }
                                    write!(f, ")")
                                }
                                State::Look { ref look, next } => {
                                    write!(f, "{:?} => {:?}", look, next.as_usize())
                                }
                                State::Union { ref alternates } => {
                                    let alts = alternates
                                        .iter()
                                        .map(|id| format!("{:?}", id.as_usize()))
                                        .collect::<Vec<String>>()
                                        .join(", ");
                                    write!(f, "union({alts})")
                                }
                                State::BinaryUnion { alt1, alt2 } => {
                                    write!(
                                        f,
                                        "binary-union({}, {})",
                                        alt1.as_usize(),
                                        alt2.as_usize()
                                    )
                                }
                                State::Capture { next, pattern_id, group_index, slot } => {
                                    write!(
                                        f,
                                        "capture(pid={:?}, group={:?}, slot={:?}) => {:?}",
                                        pattern_id.as_usize(),
                                        group_index.as_usize(),
                                        slot.as_usize(),
                                        next.as_usize(),
                                    )
                                }
                                State::Fail => write!(f, "FAIL"),
                                State::Match { pattern_id } => {
                                    write!(f, "MATCH({:?})", pattern_id.as_usize())
                                }
                            }
                        }
                    }
                    /// A sequence of transitions used to represent a sparse state.
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    pub struct SparseTransitions {
                        /// The sorted sequence of non-overlapping transitions.
                        pub transitions: Box<[Transition]>,
                    }

                    impl SparseTransitions {
                        /// This follows the matching transition for a particular byte.
                        #[inline]
                        pub fn matches(&self, haystack: &[u8], at: usize) -> Option<StateID> {
                            haystack.get(at).and_then(|&b| self.matches_byte(b))
                        }
                        /// This follows the matching transition for any member of the alphabet.
                        #[inline]
                        pub fn matches_unit(
                            &self,
                            unit: alphabet::Unit,
                        ) -> Option<StateID> {
                            unit.as_u8().and_then(|byte| self.matches_byte(byte))
                        }
                        /// This follows the matching transition for a particular byte.
                        #[inline]
                        pub fn matches_byte(&self, byte: u8) -> Option<StateID> {
                            for t in self.transitions.iter()
                            {
                                if t.start > byte {
                                    break;
                                } else if t.matches_byte(byte) {
                                    return Some(t.next);
                                }
                            }
                            None

                            /*
                            self.transitions
                                .binary_search_by(|t| {
                                    if t.end < byte {
                                        ::cmp::Ordering::Less
                                    } else if t.start > byte {
                                        ::cmp::Ordering::Greater
                                    } else {
                                        ::cmp::Ordering::Equal
                                    }
                                })
                                .ok()
                                .map(|i| self.transitions[i].next)
                            */
                        }
                    }
                    /// A sequence of transitions used to represent a dense state.
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    pub struct DenseTransitions {
                        /// A dense representation of this state's transitions on the heap. This
                        pub transitions: Box<[StateID]>,
                    }

                    impl DenseTransitions {
                        /// This follows the matching transition for a particular byte.
                        #[inline]
                        pub fn matches(&self, haystack: &[u8], at: usize) -> Option<StateID> {
                            haystack.get(at).and_then(|&b| self.matches_byte(b))
                        }
                        /// This follows the matching transition for any member of the alphabet.
                        #[inline]
                        pub fn matches_unit(
                            &self,
                            unit: alphabet::Unit,
                        ) -> Option<StateID> {
                            unit.as_u8().and_then(|byte| self.matches_byte(byte))
                        }
                        /// This follows the matching transition for a particular byte.
                        #[inline]
                        pub fn matches_byte(&self, byte: u8) -> Option<StateID> {
                            let next = self.transitions[usize::from(byte)];
                            if next == StateID::ZERO {
                                None
                            } else {
                                Some(next)
                            }
                        }

                        /*
                        /// The dense state optimization isn't currently enabled, so permit a
                        pub fn from_sparse(sparse: &SparseTransitions) -> DenseTransitions {
                            let mut dense = vec![StateID::ZERO; 256];
                            for t in sparse.transitions.iter() {
                                for b in t.start..=t.end {
                                    dense[usize::from(b)] = t.next;
                                }
                            }
                            DenseTransitions { transitions: dense.into_boxed_slice() }
                        }
                        */

                        /// Returns an iterator over all transitions that don't point to
                        pub fn iter(&self) -> impl Iterator<Item = Transition> + '_ {
                            use crate::util::int::Usize;
                            self.transitions
                                .iter()
                                .enumerate()
                                .filter(|&(_, &sid)| sid != StateID::ZERO)
                                .map(|(byte, &next)| Transition {
                                    start: byte.as_u8(),
                                    end: byte.as_u8(),
                                    next,
                                })
                        }
                    }
                    /// A single transition to another state.
                    #[derive(Clone, Copy, Eq, Hash, PartialEq)]
                    pub struct Transition {
                        /// The inclusive start of the byte range.
                        pub start: u8,
                        /// The inclusive end of the byte range.
                        pub end: u8,
                        /// The identifier of the state to transition to.
                        pub next: StateID,
                    }

                    impl Transition {
                        /// Returns true if the position `at` in `haystack` falls in this
                        pub fn matches(&self, haystack: &[u8], at: usize) -> bool {
                            haystack.get(at).map_or(false, |&b| self.matches_byte(b))
                        }
                        /// Returns true if the given alphabet unit falls in this transition's
                        pub fn matches_unit(&self, unit: alphabet::Unit) -> bool {
                            unit.as_u8().map_or(false, |byte| self.matches_byte(byte))
                        }
                        /// Returns true if the given byte falls in this transition's range of
                        pub fn matches_byte(&self, byte: u8) -> bool {
                            self.start <= byte && byte <= self.end
                        }
                    }

                    impl fmt::Debug for Transition {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            use crate::util::escape::DebugByte;

                            let Transition { start, end, next } = *self;
                            if self.start == self.end {
                                write!(f, "{:?} => {:?}", DebugByte(start), next.as_usize())
                            } else {
                                write!(
                                    f,
                                    "{:?}-{:?} => {:?}",
                                    DebugByte(start),
                                    DebugByte(end),
                                    next.as_usize(),
                                )
                            }
                        }
                    }
                    /// An iterator over all pattern IDs in an NFA.
                    #[derive(Debug)]
                    pub struct PatternIter<'a> {
                        it: PatternIDIter,
                        /// We explicitly associate a lifetime with this iterator even though we
                        _marker: ::marker::PhantomData<&'a ()>,
                    }

                    impl<'a> Iterator for PatternIter<'a> {
                        type Item = PatternID;

                        fn next(&mut self) -> Option<PatternID> {
                            self.it.next()
                        }
                    }
                }

                pub mod pikevm
                {
                    /*!
                    An NFA backed Pike VM for executing regex searches with capturing groups. */
                    use ::
                    {
                        *,
                    };
                    /*
                    #[cfg(feature = "internal-instrument-pikevm")]
                    use ::cell::RefCell;

                    use ::{vec, vec::Vec};

                    use crate::{
                        nfa::thompson::{self, BuildError, State, NFA},
                        util::{
                            captures::Captures,
                            empty, iter,
                            prefilter::Prefilter,
                            primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},
                            search::{
                                Anchored, HalfMatch, Input, Match, MatchKind, PatternSet, Span,
                            },
                            sparse_set::SparseSet,
                        },
                    };
                    */
                    /// A simple macro for conditionally executing instrumentation logic when
                    macro_rules! instrument {
                        ($fun:expr) => {
                            #[cfg(feature = "internal-instrument-pikevm")]
                            {
                                let fun: &mut dyn FnMut(&mut Counters) = &mut $fun;
                                COUNTERS.with(|c: &RefCell<Counters>| fun(&mut *c.borrow_mut()));
                            }
                        };
                    }

                    #[cfg(feature = "internal-instrument-pikevm")]
                    std::thread_local! {
                        /// Effectively global state used to keep track of instrumentation
                        static COUNTERS: RefCell<Counters> = RefCell::new(Counters::empty());
                    }
                    /// The configuration used for building a [`PikeVM`].
                    #[derive(Clone, Debug, Default)]
                    pub struct Config {
                        match_kind: Option<MatchKind>,
                        pre: Option<Option<Prefilter>>,
                    }

                    impl Config {
                        /// Return a new default PikeVM configuration.
                        pub fn new() -> Config {
                            Config::default()
                        }
                        /// Set the desired match semantics.
                        pub fn match_kind(mut self, kind: MatchKind) -> Config {
                            self.match_kind = Some(kind);
                            self
                        }
                        /// Set a prefilter to be used whenever a start state is entered.
                        pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
                            self.pre = Some(pre);
                            self
                        }
                        /// Returns the match semantics set in this configuration.
                        pub fn get_match_kind(&self) -> MatchKind {
                            self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
                        }
                        /// Returns the prefilter set in this configuration, if one at all.
                        pub fn get_prefilter(&self) -> Option<&Prefilter> {
                            self.pre.as_ref().unwrap_or(&None).as_ref()
                        }
                        /// Overwrite the default configuration such that the options in `o` are
                        pub fn overwrite(&self, o: Config) -> Config {
                            Config {
                                match_kind: o.match_kind.or(self.match_kind),
                                pre: o.pre.or_else(|| self.pre.clone()),
                            }
                        }
                    }
                    /// A builder for a `PikeVM`.
                    #[derive(Clone, Debug)]
                    pub struct Builder {
                        config: Config,
                            thompson: thompson::Compiler,
                    }

                    impl Builder {
                        /// Create a new PikeVM builder with its default configuration.
                        pub fn new() -> Builder {
                            Builder {
                                config: Config::default(),
                                            thompson: thompson::Compiler::new(),
                            }
                        }
                        /// Build a `PikeVM` from the given pattern.
                            pub fn build(&self, pattern: &str) -> Result<PikeVM, BuildError> {
                            self.build_many(&[pattern])
                        }
                        /// Build a `PikeVM` from the given patterns.
                            pub fn build_many<P: AsRef<str>>(
                            &self,
                            patterns: &[P],
                        ) -> Result<PikeVM, BuildError> {
                            let nfa = self.thompson.build_many(patterns)?;
                            self.build_from_nfa(nfa)
                        }
                        /// Build a `PikeVM` directly from its NFA.
                        pub fn build_from_nfa(&self, nfa: NFA) -> Result<PikeVM, BuildError> {
                            nfa.look_set_any().available().map_err(BuildError::word)?;
                            Ok(PikeVM { config: self.config.clone(), nfa })
                        }
                        /// Apply the given `PikeVM` configuration options to this builder.
                        pub fn configure(&mut self, config: Config) -> &mut Builder {
                            self.config = self.config.overwrite(config);
                            self
                        }
                        /// Set the syntax configuration for this builder using
                            pub fn syntax(
                            &mut self,
                            config: crate::util::syntax::Config,
                        ) -> &mut Builder {
                            self.thompson.syntax(config);
                            self
                        }
                        /// Set the Thompson NFA configuration for this builder using
                            pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                            self.thompson.configure(config);
                            self
                        }
                    }
                    /// A virtual machine for executing regex searches with capturing groups.
                    #[derive(Clone, Debug)]
                    pub struct PikeVM {
                        config: Config,
                        nfa: NFA,
                    }

                    impl PikeVM {
                        /// Parse the given regular expression using the default configuration and
                            pub fn new(pattern: &str) -> Result<PikeVM, BuildError> {
                            PikeVM::builder().build(pattern)
                        }
                        /// Like `new`, but parses multiple patterns into a single "multi regex."
                            pub fn new_many<P: AsRef<str>>(
                            patterns: &[P],
                        ) -> Result<PikeVM, BuildError> {
                            PikeVM::builder().build_many(patterns)
                        }
                        /// Like `new`, but builds a PikeVM directly from an NFA. This is useful
                        pub fn new_from_nfa(nfa: NFA) -> Result<PikeVM, BuildError> {
                            PikeVM::builder().build_from_nfa(nfa)
                        }
                        /// Create a new `PikeVM` that matches every input.
                        pub fn always_match() -> Result<PikeVM, BuildError> {
                            let nfa = thompson::NFA::always_match();
                            PikeVM::new_from_nfa(nfa)
                        }
                        /// Create a new `PikeVM` that never matches any input.
                        pub fn never_match() -> Result<PikeVM, BuildError> {
                            let nfa = thompson::NFA::never_match();
                            PikeVM::new_from_nfa(nfa)
                        }
                        /// Return a default configuration for a `PikeVM`.
                        pub fn config() -> Config {
                            Config::new()
                        }
                        /// Return a builder for configuring the construction of a `PikeVM`.
                        pub fn builder() -> Builder {
                            Builder::new()
                        }
                        /// Create a new empty set of capturing groups that is guaranteed to be
                        pub fn create_captures(&self) -> Captures {
                            Captures::all(self.get_nfa().group_info().clone())
                        }
                        /// Create a new cache for this `PikeVM`.
                        pub fn create_cache(&self) -> Cache {
                            Cache::new(self)
                        }
                        /// Reset the given cache such that it can be used for searching with the
                        pub fn reset_cache(&self, cache: &mut Cache) {
                            cache.reset(self);
                        }
                        /// Returns the total number of patterns compiled into this `PikeVM`.
                        pub fn pattern_len(&self) -> usize {
                            self.nfa.pattern_len()
                        }
                        /// Return the config for this `PikeVM`.
                        #[inline]
                        pub fn get_config(&self) -> &Config {
                            &self.config
                        }
                        /// Returns a reference to the underlying NFA.
                        #[inline]
                        pub fn get_nfa(&self) -> &NFA {
                            &self.nfa
                        }
                    }

                    impl PikeVM {
                        /// Returns true if and only if this `PikeVM` matches the given haystack.
                        #[inline]
                        pub fn is_match<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> bool {
                            let input = input.into().earliest(true);
                            self.search_slots(cache, &input, &mut []).is_some()
                        }
                        /// Executes a leftmost forward search and returns a `Match` if one exists.
                        #[inline]
                        pub fn find<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Option<Match> {
                            let input = input.into();
                            if self.get_nfa().pattern_len() == 1 {
                                let mut slots = [None, None];
                                let pid = self.search_slots(cache, &input, &mut slots)?;
                                let start = slots[0]?.get();
                                let end = slots[1]?.get();
                                return Some(Match::new(pid, Span { start, end }));
                            }
                            let ginfo = self.get_nfa().group_info();
                            let slots_len = ginfo.implicit_slot_len();
                            let mut slots = vec![None; slots_len];
                            let pid = self.search_slots(cache, &input, &mut slots)?;
                            let start = slots[pid.as_usize() * 2]?.get();
                            let end = slots[pid.as_usize() * 2 + 1]?.get();
                            Some(Match::new(pid, Span { start, end }))
                        }
                        /// Executes a leftmost forward search and writes the spans of capturing
                        #[inline]
                        pub fn captures<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                            caps: &mut Captures,
                        ) {
                            self.search(cache, &input.into(), caps)
                        }
                        /// Returns an iterator over all non-overlapping leftmost matches in the
                        #[inline]
                        pub fn find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> FindMatches<'r, 'c, 'h> {
                            let caps = Captures::matches(self.get_nfa().group_info().clone());
                            let it = iter::Searcher::new(input.into());
                            FindMatches { re: self, cache, caps, it }
                        }
                        /// Returns an iterator over all non-overlapping `Captures` values. If no
                        #[inline]
                        pub fn captures_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> CapturesMatches<'r, 'c, 'h> {
                            let caps = self.create_captures();
                            let it = iter::Searcher::new(input.into());
                            CapturesMatches { re: self, cache, caps, it }
                        }
                    }

                    impl PikeVM {
                        /// Executes a leftmost forward search and writes the spans of capturing
                        #[inline]
                        pub fn search(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            caps: &mut Captures,
                        ) {
                            caps.set_pattern(None);
                            let pid = self.search_slots(cache, input, caps.slots_mut());
                            caps.set_pattern(pid);
                        }
                        /// Executes a leftmost forward search and writes the spans of capturing
                        #[inline]
                        pub fn search_slots(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<PatternID> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            if !utf8empty {
                                let hm = self.search_slots_imp(cache, input, slots)?;
                                return Some(hm.pattern());
                            }
                            let min = self.get_nfa().group_info().implicit_slot_len();
                            if slots.len() >= min {
                                let hm = self.search_slots_imp(cache, input, slots)?;
                                return Some(hm.pattern());
                            }
                            
                            if self.get_nfa().pattern_len() == 1 {
                                let mut enough = [None, None];
                                let got = self.search_slots_imp(cache, input, &mut enough);
                                slots.copy_from_slice(&enough[..slots.len()]);
                                return got.map(|hm| hm.pattern());
                            }
                            let mut enough = vec![None; min];
                            let got = self.search_slots_imp(cache, input, &mut enough);
                            slots.copy_from_slice(&enough[..slots.len()]);
                            got.map(|hm| hm.pattern())
                        }
                        /// This is the actual implementation of `search_slots_imp` that
                        #[inline(never)]
                        fn search_slots_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            let hm = match self.search_imp(cache, input, slots) {
                                None => return None,
                                Some(hm) if !utf8empty => return Some(hm),
                                Some(hm) => hm,
                            };
                            empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                                Ok(self
                                    .search_imp(cache, input, slots)
                                    .map(|hm| (hm, hm.offset())))
                            })
                            // OK because the PikeVM never errors.
                            .unwrap()
                        }
                        /// Writes the set of patterns that match anywhere in the given search
                        #[inline]
                        pub fn which_overlapping_matches(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            patset: &mut PatternSet,
                        ) {
                            self.which_overlapping_imp(cache, input, patset)
                        }
                    }

                    impl PikeVM {
                        /// The implementation of standard leftmost search.
                        fn search_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            cache.setup_search(slots.len());
                            if input.is_done() {
                                return None;
                            }
                            assert!(
                                input.haystack().len() < ::usize::MAX,
                                "byte slice lengths must be less than usize MAX",
                            );
                            instrument!(|c| c.reset(&self.nfa));
                            let allmatches =
                                self.config.get_match_kind().continue_past_first_match();
                            let (anchored, start_id) = match self.start_config(input) {
                                None => return None,
                                Some(config) => config,
                            };

                            let pre =
                                if anchored { None } else { self.get_config().get_prefilter() };
                            let Cache { ref mut stack, ref mut curr, ref mut next } = cache;
                            let mut hm = None;
                            let mut at = input.start();
                            while at <= input.end()
                            {
                                if curr.set.is_empty() {
                                    if hm.is_some() && !allmatches {
                                        break;
                                    }
                                    if anchored && at > input.start() {
                                        break;
                                    }
                                    if let Some(pre) = pre {
                                        let span = Span::from(at..input.end());
                                        match pre.find(input.haystack(), span) {
                                            None => break,
                                            Some(ref span) => at = span.start,
                                        }
                                    }
                                }
                                if (hm.is_none() || allmatches)
                                    && (!anchored || at == input.start())
                                {
                                    let slots = next.slot_table.all_absent();
                                    self.epsilon_closure(stack, slots, curr, input, at, start_id);
                                }
                                if let Some(pid) = self.nexts(stack, curr, next, input, at, slots)
                                {
                                    hm = Some(HalfMatch::new(pid, at));
                                }
                                if input.get_earliest() && hm.is_some() {
                                    break;
                                }
                                ::mem::swap(curr, next);
                                next.set.clear();
                                at += 1;
                            }
                            instrument!(|c| c.eprint(&self.nfa));
                            hm
                        }
                        /// The implementation for the 'which_overlapping_matches' API. Basically,
                        fn which_overlapping_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            patset: &mut PatternSet,
                        ) {

                            cache.setup_search(0);
                            if input.is_done() {
                                return;
                            }
                            assert!(
                                input.haystack().len() < ::usize::MAX,
                                "byte slice lengths must be less than usize MAX",
                            );
                            instrument!(|c| c.reset(&self.nfa));

                            let allmatches =
                                self.config.get_match_kind().continue_past_first_match();
                            let (anchored, start_id) = match self.start_config(input) {
                                None => return,
                                Some(config) => config,
                            };

                            let Cache { ref mut stack, ref mut curr, ref mut next } = cache;
                            for at in input.start()..=input.end() {
                                let any_matches = !patset.is_empty();
                                
                                if curr.set.is_empty() {
                                    if any_matches && !allmatches {
                                        break;
                                    }
                                    if anchored && at > input.start() {
                                        break;
                                    }
                                }
                                if !any_matches || allmatches {
                                    let slots = &mut [];
                                    self.epsilon_closure(stack, slots, curr, input, at, start_id);
                                }
                                self.nexts_overlapping(stack, curr, next, input, at, patset);
                                
                                if patset.is_full() || input.get_earliest() {
                                    break;
                                }
                                ::mem::swap(curr, next);
                                next.set.clear();
                            }
                            instrument!(|c| c.eprint(&self.nfa));
                        }
                        /// Process the active states in 'curr' to find the states (written to
                        #[inline( always )]
                        fn nexts(
                            &self,
                            stack: &mut Vec<FollowEpsilon>,
                            curr: &mut ActiveStates,
                            next: &mut ActiveStates,
                            input: &Input<'_>,
                            at: usize,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<PatternID> {
                            instrument!(|c| c.record_state_set(&curr.set));
                            let mut pid = None;
                            let ActiveStates { ref set, ref mut slot_table } = *curr;
                            for sid in set.iter() {
                                pid = match self.next(stack, slot_table, next, input, at, sid) {
                                    None => continue,
                                    Some(pid) => Some(pid),
                                };
                                slots.copy_from_slice(slot_table.for_state(sid));
                                
                                if !self.config.get_match_kind().continue_past_first_match() {
                                    break;
                                }
                            }
                            pid
                        }
                        /// Like 'nexts', but for the overlapping case. This doesn't write any
                        #[inline( always )]
                        fn nexts_overlapping(
                            &self,
                            stack: &mut Vec<FollowEpsilon>,
                            curr: &mut ActiveStates,
                            next: &mut ActiveStates,
                            input: &Input<'_>,
                            at: usize,
                            patset: &mut PatternSet,
                        ) {
                            instrument!(|c| c.record_state_set(&curr.set));
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            let ActiveStates { ref set, ref mut slot_table } = *curr;
                            for sid in set.iter() {
                                let pid = match self.next(stack, slot_table, next, input, at, sid)
                                {
                                    None => continue,
                                    Some(pid) => pid,
                                };
                                
                                if utf8empty && !input.is_char_boundary(at) {
                                    continue;
                                }
                                let _ = patset.try_insert(pid);
                                
                                if !self.config.get_match_kind().continue_past_first_match() {
                                    break;
                                }
                            }
                        }
                        /// Starting from 'sid', if the position 'at' in the 'input' haystack has a
                        #[inline( always )]
                        fn next(
                            &self,
                            stack: &mut Vec<FollowEpsilon>,
                            curr_slot_table: &mut SlotTable,
                            next: &mut ActiveStates,
                            input: &Input<'_>,
                            at: usize,
                            sid: StateID,
                        ) -> Option<PatternID> {
                            instrument!(|c| c.record_step(sid));
                            match *self.nfa.state(sid) {
                                State::Fail
                                | State::Look { .. }
                                | State::Union { .. }
                                | State::BinaryUnion { .. }
                                | State::Capture { .. } => None,
                                State::ByteRange { ref trans } => {
                                    if trans.matches(input.haystack(), at) {
                                        let slots = curr_slot_table.for_state(sid);
                                        let at = at.wrapping_add(1);
                                        self.epsilon_closure(
                                            stack, slots, next, input, at, trans.next,
                                        );
                                    }
                                    None
                                }
                                State::Sparse(ref sparse) => {
                                    if let Some(next_sid) = sparse.matches(input.haystack(), at) {
                                        let slots = curr_slot_table.for_state(sid);
                                        let at = at.wrapping_add(1);
                                        self.epsilon_closure(
                                            stack, slots, next, input, at, next_sid,
                                        );
                                    }
                                    None
                                }
                                State::Dense(ref dense) => {
                                    if let Some(next_sid) = dense.matches(input.haystack(), at) {
                                        let slots = curr_slot_table.for_state(sid);
                                        let at = at.wrapping_add(1);
                                        self.epsilon_closure(
                                            stack, slots, next, input, at, next_sid,
                                        );
                                    }
                                    None
                                }
                                State::Match { pattern_id } => Some(pattern_id),
                            }
                        }
                        /// Compute the epsilon closure of 'sid', writing the closure into 'next'
                        #[inline( always )]
                        fn epsilon_closure(
                            &self,
                            stack: &mut Vec<FollowEpsilon>,
                            curr_slots: &mut [Option<NonMaxUsize>],
                            next: &mut ActiveStates,
                            input: &Input<'_>,
                            at: usize,
                            sid: StateID,
                        ) {
                            instrument!(|c| {
                                c.record_closure(sid);
                                c.record_stack_push(sid);
                            });
                            stack.push(FollowEpsilon::Explore(sid));
                            while let Some(frame) = stack.pop() {
                                match frame {
                                    FollowEpsilon::RestoreCapture { slot, offset: pos } => {
                                        curr_slots[slot] = pos;
                                    }
                                    FollowEpsilon::Explore(sid) => {
                                        self.epsilon_closure_explore(
                                            stack, curr_slots, next, input, at, sid,
                                        );
                                    }
                                }
                            }
                        }
                        /// Explore all of the epsilon transitions out of 'sid'. This is mostly
                        #[inline( always )]
                        fn epsilon_closure_explore(
                            &self,
                            stack: &mut Vec<FollowEpsilon>,
                            curr_slots: &mut [Option<NonMaxUsize>],
                            next: &mut ActiveStates,
                            input: &Input<'_>,
                            at: usize,
                            mut sid: StateID,
                        ) {
                            loop {
                                instrument!(|c| c.record_set_insert(sid));
                                
                                if !next.set.insert(sid) {
                                    return;
                                }
                                match *self.nfa.state(sid) {
                                    State::Fail
                                    | State::Match { .. }
                                    | State::ByteRange { .. }
                                    | State::Sparse { .. }
                                    | State::Dense { .. } => {
                                        next.slot_table.for_state(sid).copy_from_slice(curr_slots);
                                        return;
                                    }
                                    State::Look { look, next } => {
                                        if !self.nfa.look_matcher().matches_inline(
                                            look,
                                            input.haystack(),
                                            at,
                                        ) {
                                            return;
                                        }
                                        sid = next;
                                    }
                                    State::Union { ref alternates } => {
                                        sid = match alternates.get(0) {
                                            None => return,
                                            Some(&sid) => sid,
                                        };
                                        instrument!(|c| {
                                            for &alt in &alternates[1..] {
                                                c.record_stack_push(alt);
                                            }
                                        });
                                        stack.extend(
                                            alternates[1..]
                                                .iter()
                                                .copied()
                                                .rev()
                                                .map(FollowEpsilon::Explore),
                                        );
                                    }
                                    State::BinaryUnion { alt1, alt2 } => {
                                        sid = alt1;
                                        instrument!(|c| c.record_stack_push(sid));
                                        stack.push(FollowEpsilon::Explore(alt2));
                                    }
                                    State::Capture { next, slot, .. } => {
                                        if slot.as_usize() < curr_slots.len() {
                                            instrument!(|c| c.record_stack_push(sid));
                                            stack.push(FollowEpsilon::RestoreCapture {
                                                slot,
                                                offset: curr_slots[slot],
                                            });
                                            // OK because length of a slice must fit into an isize.
                                            curr_slots[slot] = Some(NonMaxUsize::new(at).unwrap());
                                        }
                                        sid = next;
                                    }
                                }
                            }
                        }
                        /// Return the starting configuration of a PikeVM search.
                        fn start_config(&self, input: &Input<'_>) -> Option<(bool, StateID)> {
                            match input.get_anchored() {
                                Anchored::No => Some((
                                    self.nfa.is_always_start_anchored(),
                                    self.nfa.start_anchored(),
                                )),
                                Anchored::Yes => Some((true, self.nfa.start_anchored())),
                                Anchored::Pattern(pid) => {
                                    Some((true, self.nfa.start_pattern(pid)?))
                                }
                            }
                        }
                    }
                    /// An iterator over all non-overlapping matches for a particular search.
                    #[derive(Debug)]
                    pub struct FindMatches<'r, 'c, 'h> {
                        re: &'r PikeVM,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }

                    impl<'r, 'c, 'h> Iterator for FindMatches<'r, 'c, 'h> {
                        type Item = Match;

                        #[inline]
                        fn next(&mut self) -> Option<Match> {
                            // Splitting 'self' apart seems necessary to appease borrowck.
                            let FindMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            it.advance(|input| {
                                re.search(cache, input, caps);
                                Ok(caps.get_match())
                            })
                        }
                    }
                    /// An iterator over all non-overlapping leftmost matches, with their capturing
                    #[derive(Debug)]
                    pub struct CapturesMatches<'r, 'c, 'h> {
                        re: &'r PikeVM,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }

                    impl<'r, 'c, 'h> Iterator for CapturesMatches<'r, 'c, 'h> {
                        type Item = Captures;

                        #[inline]
                        fn next(&mut self) -> Option<Captures> {
                            // Splitting 'self' apart seems necessary to appease borrowck.
                            let CapturesMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            it.advance(|input| {
                                re.search(cache, input, caps);
                                Ok(caps.get_match())
                            });
                            if caps.is_match() {
                                Some(caps.clone())
                            } else {
                                None
                            }
                        }
                    }
                    /// A cache represents mutable state that a [`PikeVM`] requires during a
                    #[derive(Clone, Debug)]
                    pub struct Cache {
                        /// Stack used while computing epsilon closure. This effectively lets us
                        stack: Vec<FollowEpsilon>,
                        /// The current active states being explored for the current byte in the
                        curr: ActiveStates,
                        /// The next set of states we're building that will be explored for the
                        next: ActiveStates,
                    }

                    impl Cache {
                        /// Create a new [`PikeVM`] cache.
                        pub fn new(re: &PikeVM) -> Cache {
                            Cache {
                                stack: vec![],
                                curr: ActiveStates::new(re),
                                next: ActiveStates::new(re),
                            }
                        }
                        /// Reset this cache such that it can be used for searching with a
                        pub fn reset(&mut self, re: &PikeVM) {
                            self.curr.reset(re);
                            self.next.reset(re);
                        }
                        /// Returns the heap memory usage, in bytes, of this cache.
                        pub fn memory_usage(&self) -> usize {
                            use ::mem::size_of;
                            (self.stack.len() * size_of::<FollowEpsilon>())
                                + self.curr.memory_usage()
                                + self.next.memory_usage()
                        }
                        /// Clears this cache. This should be called at the start of every search
                        fn setup_search(&mut self, captures_slot_len: usize) {
                            self.stack.clear();
                            self.curr.setup_search(captures_slot_len);
                            self.next.setup_search(captures_slot_len);
                        }
                    }
                    /// A set of active states used to "simulate" the execution of an NFA via the
                    #[derive(Clone, Debug)]
                    struct ActiveStates {
                        /// The set of active NFA states. This set preserves insertion order, which
                        set: SparseSet,
                        /// The slots for every NFA state, where each slot stores a (possibly
                        slot_table: SlotTable,
                    }

                    impl ActiveStates {
                        /// Create a new set of active states for the given PikeVM. The active
                        fn new(re: &PikeVM) -> ActiveStates {
                            let mut active = ActiveStates {
                                set: SparseSet::new(0),
                                slot_table: SlotTable::new(),
                            };
                            active.reset(re);
                            active
                        }
                        /// Reset this set of active states such that it can be used with the given
                        fn reset(&mut self, re: &PikeVM) {
                            self.set.resize(re.get_nfa().states().len());
                            self.slot_table.reset(re);
                        }
                        /// Return the heap memory usage, in bytes, used by this set of active
                        fn memory_usage(&self) -> usize {
                            self.set.memory_usage() + self.slot_table.memory_usage()
                        }
                        /// Setup this set of active states for a new search. The given slot
                        fn setup_search(&mut self, captures_slot_len: usize) {
                            self.set.clear();
                            self.slot_table.setup_search(captures_slot_len);
                        }
                    }
                    /// A table of slots, where each row represent a state in an NFA. Thus, the
                    #[derive(Clone, Debug)]
                    struct SlotTable {
                        /// The actual table of offsets.
                        table: Vec<Option<NonMaxUsize>>,
                        /// The number of slots per state, i.e., the table's stride or the length
                        slots_per_state: usize,
                        /// The number of slots in the caller-provided 'Captures' value for the
                        slots_for_captures: usize,
                    }

                    impl SlotTable {
                        /// Create a new slot table.
                        fn new() -> SlotTable {
                            SlotTable { table: vec![], slots_for_captures: 0, slots_per_state: 0 }
                        }
                        /// Reset this slot table such that it can be used with the given PikeVM
                        fn reset(&mut self, re: &PikeVM) {
                            let nfa = re.get_nfa();
                            self.slots_per_state = nfa.group_info().slot_len();
                            self.slots_for_captures = ::cmp::max(
                                self.slots_per_state,
                                nfa.pattern_len().checked_mul(2).unwrap(),
                            );
                            let len = nfa
                                .states()
                                .len()
                                .checked_mul(self.slots_per_state)
                                // Add space to account for scratch space used during a search.
                                .and_then(|x| x.checked_add(self.slots_for_captures))
                                .expect("slot table length doesn't overflow");
                            trace!(
                                "resizing PikeVM active states table to {} entries \
                                (slots_per_state={})",
                                len,
                                self.slots_per_state,
                            );
                            self.table.resize(len, None);
                        }
                        /// Return the heap memory usage, in bytes, used by this slot table.
                        fn memory_usage(&self) -> usize {
                            self.table.len() * ::mem::size_of::<Option<NonMaxUsize>>()
                        }
                        /// Perform any per-search setup for this slot table.
                        fn setup_search(&mut self, captures_slot_len: usize) {
                            self.slots_for_captures = captures_slot_len;
                        }
                        /// Return a mutable slice of the slots for the given state.
                        fn for_state(&mut self, sid: StateID) -> &mut [Option<NonMaxUsize>] {
                            let i = sid.as_usize() * self.slots_per_state;
                            &mut self.table[i..i + self.slots_for_captures]
                        }
                        /// Return a slice of slots of appropriate length where every slot offset
                        fn all_absent(&mut self) -> &mut [Option<NonMaxUsize>] {
                            let i = self.table.len() - self.slots_for_captures;
                            &mut self.table[i..i + self.slots_for_captures]
                        }
                    }
                    /// Represents a stack frame for use while computing an epsilon closure.
                    #[derive(Clone, Debug)]
                    enum FollowEpsilon {
                        /// Explore the epsilon transitions from a state ID.
                        Explore(StateID),
                        /// Reset the given `slot` to the given `offset` (which might be `None`).
                        RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },
                    }
                    /// A set of counters that "instruments" a PikeVM search. To enable this, you
                    #[cfg(feature = "internal-instrument-pikevm")]
                    #[derive(Clone, Debug)]
                    struct Counters {
                        /// The number of times the NFA is in a particular permutation of states.
                        state_sets: alloc::collections::BTreeMap<Vec<StateID>, u64>,
                        /// The number of times 'step' is called for a particular state ID (which
                        steps: Vec<u64>,
                        /// The number of times an epsilon closure was computed for a state.
                        closures: Vec<u64>,
                        /// The number of times a particular state ID is pushed on to a stack while
                        stack_pushes: Vec<u64>,
                        /// The number of times a particular state ID is inserted into a sparse set
                        set_inserts: Vec<u64>,
                    }

                    #[cfg(feature = "internal-instrument-pikevm")]
                    impl Counters {
                        fn empty() -> Counters {
                            Counters {
                                state_sets: alloc::collections::BTreeMap::new(),
                                steps: vec![],
                                closures: vec![],
                                stack_pushes: vec![],
                                set_inserts: vec![],
                            }
                        }

                        fn reset(&mut self, nfa: &NFA) {
                            let len = nfa.states().len();

                            self.state_sets.clear();

                            self.steps.clear();
                            self.steps.resize(len, 0);

                            self.closures.clear();
                            self.closures.resize(len, 0);

                            self.stack_pushes.clear();
                            self.stack_pushes.resize(len, 0);

                            self.set_inserts.clear();
                            self.set_inserts.resize(len, 0);
                        }

                        fn eprint(&self, nfa: &NFA) {
                            trace!("===== START PikeVM Instrumentation Output =====");
                            const LIMIT: usize = 20;
                            let mut set_counts =
                                self.state_sets.iter().collect::<Vec<(&Vec<StateID>, &u64)>>();
                            set_counts.sort_by_key(|(_, &count)| ::cmp::Reverse(count));
                            trace!("## PikeVM frequency of state sets (top {LIMIT})");
                            for (set, count) in set_counts.iter().take(LIMIT) {
                                trace!("{set:?}: {count}");
                            }
                            
                            if set_counts.len() > LIMIT {
                                trace!(
                                    "... {} sets omitted (out of {} total)",
                                    set_counts.len() - LIMIT,
                                    set_counts.len(),
                                );
                            }

                            trace!("");
                            trace!("## PikeVM total frequency of events");
                            trace!(
                                "steps: {}, closures: {}, stack-pushes: {}, set-inserts: {}",
                                self.steps.iter().copied().sum::<u64>(),
                                self.closures.iter().copied().sum::<u64>(),
                                self.stack_pushes.iter().copied().sum::<u64>(),
                                self.set_inserts.iter().copied().sum::<u64>(),
                            );

                            trace!("");
                            trace!("## PikeVM frequency of events broken down by state");
                            for sid in 0..self.steps.len() {
                                trace!(
                                    "{:06}: steps: {}, closures: {}, \
                                    stack-pushes: {}, set-inserts: {}",
                                    sid,
                                    self.steps[sid],
                                    self.closures[sid],
                                    self.stack_pushes[sid],
                                    self.set_inserts[sid],
                                );
                            }

                            trace!("");
                            trace!("## NFA debug display");
                            trace!("{nfa:?}");
                            trace!("===== END PikeVM Instrumentation Output =====");
                        }

                        fn record_state_set(&mut self, set: &SparseSet) {
                            let set = set.iter().collect::<Vec<StateID>>();
                            *self.state_sets.entry(set).or_insert(0) += 1;
                        }

                        fn record_step(&mut self, sid: StateID) {
                            self.steps[sid] += 1;
                        }

                        fn record_closure(&mut self, sid: StateID) {
                            self.closures[sid] += 1;
                        }

                        fn record_stack_push(&mut self, sid: StateID) {
                            self.stack_pushes[sid] += 1;
                        }

                        fn record_set_insert(&mut self, sid: StateID) {
                            self.set_inserts[sid] += 1;
                        }
                    }
                }

                pub mod range_trie
                {
                    /*! 
                     The range trie is just like a trie in that it is a special case of a deterministic finite state machine. */
                    use ::
                    {
                        *,
                    };
                    /*
                    se ::{cell::RefCell, fmt, mem, ops::RangeInclusive};

                    use ::{format, string::String, vec, vec::Vec};

                    use regex_syntax::utf8::Utf8Range;

                    use crate::util::primitives::StateID;
                    */
                    /// There is only one final state in this trie. Every sequence of byte ranges
                    const FINAL: StateID = StateID::ZERO;
                    /// The root state of the trie.
                    const ROOT: StateID = StateID::new_unchecked(1);
                    /// A range trie represents an ordered set of sequences of bytes.
                    #[derive(Clone)]
                    pub struct RangeTrie {
                        /// The states in this trie. The first is always the shared final state.
                        states: Vec<State>,
                        /// A free-list of states. When a range trie is cleared, all of its states
                        free: Vec<State>,
                        /// A stack for traversing this trie to yield sequences of byte ranges in
                        iter_stack: RefCell<Vec<NextIter>>,
                        /// A buffer that stores the current sequence during iteration.
                        iter_ranges: RefCell<Vec<Utf8Range>>,
                        /// A stack used for traversing the trie in order to (deeply) duplicate
                        dupe_stack: Vec<NextDupe>,
                        /// A stack used for traversing the trie during insertion of a new
                        insert_stack: Vec<NextInsert>,
                    }
                    /// A single state in this trie.
                    #[derive(Clone)]
                    struct State {
                        /// A sorted sequence of non-overlapping transitions to other states. Each
                        transitions: Vec<Transition>,
                    }
                    /// A transition is a single range of bytes. If a particular byte is in this
                    #[derive(Clone)]
                    struct Transition {
                        /// The byte range.
                        range: Utf8Range,
                        /// The next state to transition to.
                        next_id: StateID,
                    }

                    impl RangeTrie {
                        /// Create a new empty range trie.
                        pub fn new() -> RangeTrie {
                            let mut trie = RangeTrie {
                                states: vec![],
                                free: vec![],
                                iter_stack: RefCell::new(vec![]),
                                iter_ranges: RefCell::new(vec![]),
                                dupe_stack: vec![],
                                insert_stack: vec![],
                            };
                            trie.clear();
                            trie
                        }
                        /// Clear this range trie such that it is empty. Clearing a range trie
                        pub fn clear(&mut self) {
                            self.free.append(&mut self.states);
                            self.add_empty(); // final
                            self.add_empty(); // root
                        }
                        /// Iterate over all of the sequences of byte ranges in this trie, and
                        pub fn iter<E, F: FnMut(&[Utf8Range]) -> Result<(), E>>(
                            &self,
                            mut f: F,
                        ) -> Result<(), E> {
                            let mut stack = self.iter_stack.borrow_mut();
                            stack.clear();
                            let mut ranges = self.iter_ranges.borrow_mut();
                            ranges.clear();
                            stack.push(NextIter { state_id: ROOT, tidx: 0 });
                            while let Some(NextIter { mut state_id, mut tidx }) = stack.pop() {
                                loop {
                                    let state = self.state(state_id);
                                    if tidx >= state.transitions.len() {
                                        ranges.pop();
                                        break;
                                    }

                                    let t = &state.transitions[tidx];
                                    ranges.push(t.range);
                                    if t.next_id == FINAL {
                                        f(&ranges)?;
                                        ranges.pop();
                                        tidx += 1;
                                    } else {
                                        stack.push(NextIter { state_id, tidx: tidx + 1 });
                                        state_id = t.next_id;
                                        tidx = 0;
                                    }
                                }
                            }
                            Ok(())
                        }
                        /// Inserts a new sequence of ranges into this trie.
                        pub fn insert(&mut self, ranges: &[Utf8Range]) {
                            assert!(!ranges.is_empty());
                            assert!(ranges.len() <= 4);

                            let mut stack = ::mem::replace(&mut self.insert_stack, vec![]);
                            stack.clear();

                            stack.push(NextInsert::new(ROOT, ranges));
                            while let Some(next) = stack.pop() {
                                let (state_id, ranges) = (next.state_id(), next.ranges());
                                assert!(!ranges.is_empty());

                                let (mut new, rest) = (ranges[0], &ranges[1..]);
                                let mut i = self.state(state_id).find(new);
                                
                                if i == self.state(state_id).transitions.len() {
                                    let next_id = NextInsert::push(self, &mut stack, rest);
                                    self.add_transition(state_id, new, next_id);
                                    continue;
                                }
                                'OUTER: loop {
                                    let old = self.state(state_id).transitions[i].clone();
                                    let split = match Split::new(old.range, new) {
                                        Some(split) => split,
                                        None => {
                                            let next_id = NextInsert::push(self, &mut stack, rest);
                                            self.add_transition_at(i, state_id, new, next_id);
                                            continue;
                                        }
                                    };
                                    let splits = split.as_slice();
                                    if splits.len() == 1 {
                                        // ... but only if we have anything left to do.
                                        if !rest.is_empty() {
                                            stack.push(NextInsert::new(old.next_id, rest));
                                        }
                                        break;
                                    }
                                    let mut first = true;
                                    let mut add_trans =
                                        |trie: &mut RangeTrie, pos, from, range, to| {
                                            if first {
                                                trie.set_transition_at(pos, from, range, to);
                                                first = false;
                                            } else {
                                                trie.add_transition_at(pos, from, range, to);
                                            }
                                        };
                                    for (j, &srange) in splits.iter().enumerate() {
                                        match srange {
                                            SplitRange::Old(r) => {
                                                let dup_id = self.duplicate(old.next_id);
                                                add_trans(self, i, state_id, r, dup_id);
                                            }
                                            SplitRange::New(r) => {
                                                {
                                                    let trans = &self.state(state_id).transitions;
                                                    if j + 1 == splits.len()
                                                        && i < trans.len()
                                                        && intersects(r, trans[i].range)
                                                    {
                                                        new = r;
                                                        continue 'OUTER;
                                                    }
                                                }
                                                let next_id =
                                                    NextInsert::push(self, &mut stack, rest);
                                                add_trans(self, i, state_id, r, next_id);
                                            }
                                            SplitRange::Both(r) => {
                                                if !rest.is_empty() {
                                                    stack.push(NextInsert::new(old.next_id, rest));
                                                }
                                                add_trans(self, i, state_id, r, old.next_id);
                                            }
                                        }
                                        i += 1;
                                    }
                                    break;
                                }
                            }
                            self.insert_stack = stack;
                        }

                        pub fn add_empty(&mut self) -> StateID {
                            let id = match StateID::try_from(self.states.len()) {
                                Ok(id) => id,
                                Err(_) => {
                                    panic!("too many sequences added to range trie");
                                }
                            };
                            if let Some(mut state) = self.free.pop() {
                                state.clear();
                                self.states.push(state);
                            } else {
                                self.states.push(State { transitions: vec![] });
                            }
                            id
                        }
                        /// Performs a deep clone of the given state and returns the duplicate's
                        fn duplicate(&mut self, old_id: StateID) -> StateID {
                            if old_id == FINAL {
                                return FINAL;
                            }

                            let mut stack = mem::replace(&mut self.dupe_stack, vec![]);
                            stack.clear();

                            let new_id = self.add_empty();
                            stack.push(NextDupe { old_id, new_id });
                            while let Some(NextDupe { old_id, new_id }) = stack.pop() {
                                for i in 0..self.state(old_id).transitions.len() {
                                    let t = self.state(old_id).transitions[i].clone();
                                    if t.next_id == FINAL {
                                        self.add_transition(new_id, t.range, FINAL);
                                        continue;
                                    }

                                    let new_child_id = self.add_empty();
                                    self.add_transition(new_id, t.range, new_child_id);
                                    stack.push(NextDupe {
                                        old_id: t.next_id,
                                        new_id: new_child_id,
                                    });
                                }
                            }
                            self.dupe_stack = stack;
                            new_id
                        }
                        /// Adds the given transition to the given state.
                        fn add_transition(
                            &mut self,
                            from_id: StateID,
                            range: Utf8Range,
                            next_id: StateID,
                        ) {
                            self.state_mut(from_id)
                                .transitions
                                .push(Transition { range, next_id });
                        }
                        /// Like `add_transition`, except this inserts the transition just before
                        fn add_transition_at(
                            &mut self,
                            i: usize,
                            from_id: StateID,
                            range: Utf8Range,
                            next_id: StateID,
                        ) {
                            self.state_mut(from_id)
                                .transitions
                                .insert(i, Transition { range, next_id });
                        }
                        /// Overwrites the transition at position i with the given transition.
                        fn set_transition_at(
                            &mut self,
                            i: usize,
                            from_id: StateID,
                            range: Utf8Range,
                            next_id: StateID,
                        ) {
                            self.state_mut(from_id).transitions[i] = Transition { range, next_id };
                        }
                        /// Return an immutable borrow for the state with the given ID.
                        fn state(&self, id: StateID) -> &State {
                            &self.states[id]
                        }
                        /// Return a mutable borrow for the state with the given ID.
                        fn state_mut(&mut self, id: StateID) -> &mut State {
                            &mut self.states[id]
                        }
                    }

                    impl State {
                        /// Find the position at which the given range should be inserted in this
                        fn find(&self, range: Utf8Range) -> usize {
                            /// Returns the position `i` at which `pred(xs[i])` first returns true
                            fn binary_search<T, F>(xs: &[T], mut pred: F) -> usize
                            where
                                F: FnMut(&T) -> bool,
                            {
                                let (mut left, mut right) = (0, xs.len());
                                while left < right {
                                    // Overflow is impossible because xs.len() <= 256.
                                    let mid = (left + right) / 2;
                                    if pred(&xs[mid]) {
                                        right = mid;
                                    } else {
                                        left = mid + 1;
                                    }
                                }
                                left
                            }
                            binary_search(&self.transitions, |t| range.start <= t.range.end)
                        }
                        /// Clear this state such that it has zero transitions.
                        fn clear(&mut self) {
                            self.transitions.clear();
                        }
                    }
                    /// The next state to process during duplication.
                    #[derive(Clone, Debug)]
                    struct NextDupe {
                        /// The state we want to duplicate.
                        old_id: StateID,
                        /// The ID of the new state that is a duplicate of old_id.
                        new_id: StateID,
                    }
                    /// The next state (and its corresponding transition) that we want to visit
                    #[derive(Clone, Debug)]
                    struct NextIter {
                        state_id: StateID,
                        tidx: usize,
                    }
                    /// The next state to process during insertion and any remaining ranges that we
                    #[derive(Clone, Debug)]
                    struct NextInsert {
                        /// The next state to begin inserting ranges. This state should be the
                        state_id: StateID,
                        /// The ranges to insert. We used a fixed-size array here to avoid an
                        ranges: [Utf8Range; 4],
                        /// The number of valid ranges in the above array.
                        len: u8,
                    }

                    impl NextInsert {
                        /// Create the next item to visit. The given state ID should correspond
                        fn new(state_id: StateID, ranges: &[Utf8Range]) -> NextInsert {
                            let len = ranges.len();
                            assert!(len > 0);
                            assert!(len <= 4);

                            let mut tmp = [Utf8Range { start: 0, end: 0 }; 4];
                            tmp[..len].copy_from_slice(ranges);
                            NextInsert { state_id, ranges: tmp, len: u8::try_from(len).unwrap() }
                        }
                        /// Push a new empty state to visit along with any remaining ranges that
                        fn push(
                            trie: &mut RangeTrie,
                            stack: &mut Vec<NextInsert>,
                            ranges: &[Utf8Range],
                        ) -> StateID {
                            if ranges.is_empty() {
                                FINAL
                            } else {
                                let next_id = trie.add_empty();
                                stack.push(NextInsert::new(next_id, ranges));
                                next_id
                            }
                        }
                        /// Return the ID of the state to visit.
                        fn state_id(&self) -> StateID {
                            self.state_id
                        }
                        /// Return the remaining ranges to insert.
                        fn ranges(&self) -> &[Utf8Range] {
                            &self.ranges[..usize::try_from(self.len).unwrap()]
                        }
                    }
                    /// Split represents a partitioning of two ranges into one or more ranges. This
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    struct Split {
                        partitions: [SplitRange; 3],
                        len: usize,
                    }
                    /// A tagged range indicating how it was derived from a pair of ranges.
                    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                    enum SplitRange {
                        Old(Utf8Range),
                        New(Utf8Range),
                        Both(Utf8Range),
                    }

                    impl Split {
                        /// Create a partitioning of the given ranges.
                        fn new(o: Utf8Range, n: Utf8Range) -> Option<Split> {
                            let range = |r: RangeInclusive<u8>| Utf8Range {
                                start: *r.start(),
                                end: *r.end(),
                            };
                            let old = |r| SplitRange::Old(range(r));
                            let new = |r| SplitRange::New(range(r));
                            let both = |r| SplitRange::Both(range(r));

                            // Use same names as the comment above to make it easier to compare.
                            let (a, b, x, y) = (o.start, o.end, n.start, n.end);

                            if b < x || y < a {
                                // case 1, case 2
                                None
                            } else if a == x && b == y {
                                // case 3
                                Some(Split::parts1(both(a..=b)))
                            } else if a == x && b < y {
                                // case 4
                                Some(Split::parts2(both(a..=b), new(b + 1..=y)))
                            } else if b == y && a > x {
                                // case 5
                                Some(Split::parts2(new(x..=a - 1), both(a..=b)))
                            } else if x == a && y < b {
                                // case 6
                                Some(Split::parts2(both(x..=y), old(y + 1..=b)))
                            } else if y == b && x > a {
                                // case 7
                                Some(Split::parts2(old(a..=x - 1), both(x..=y)))
                            } else if a > x && b < y {
                                // case 8
                                Some(Split::parts3(new(x..=a - 1), both(a..=b), new(b + 1..=y)))
                            } else if x > a && y < b {
                                // case 9
                                Some(Split::parts3(old(a..=x - 1), both(x..=y), old(y + 1..=b)))
                            } else if b == x && a < y {
                                // case 10
                                Some(Split::parts3(old(a..=b - 1), both(b..=b), new(b + 1..=y)))
                            } else if y == a && x < b {
                                // case 11
                                Some(Split::parts3(new(x..=y - 1), both(y..=y), old(y + 1..=b)))
                            } else if b > x && b < y {
                                // case 12
                                Some(Split::parts3(old(a..=x - 1), both(x..=b), new(b + 1..=y)))
                            } else if y > a && y < b {
                                // case 13
                                Some(Split::parts3(new(x..=a - 1), both(a..=y), old(y + 1..=b)))
                            } else {
                                unreachable!()
                            }
                        }
                        /// Create a new split with a single partition. This only occurs when two
                        fn parts1(r1: SplitRange) -> Split {
                            // This value doesn't matter since it is never accessed.
                            let nada = SplitRange::Old(Utf8Range { start: 0, end: 0 });
                            Split { partitions: [r1, nada, nada], len: 1 }
                        }
                        /// Create a new split with two partitions.
                        fn parts2(r1: SplitRange, r2: SplitRange) -> Split {
                            // This value doesn't matter since it is never accessed.
                            let nada = SplitRange::Old(Utf8Range { start: 0, end: 0 });
                            Split { partitions: [r1, r2, nada], len: 2 }
                        }
                        /// Create a new split with three partitions.
                        fn parts3(r1: SplitRange, r2: SplitRange, r3: SplitRange) -> Split {
                            Split { partitions: [r1, r2, r3], len: 3 }
                        }
                        /// Return the partitions in this split as a slice.
                        fn as_slice(&self) -> &[SplitRange] {
                            &self.partitions[..self.len]
                        }
                    }

                    impl fmt::Debug for RangeTrie {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            writeln!(f)?;
                            for (i, state) in self.states.iter().enumerate() {
                                let status = if i == FINAL.as_usize() { '*' } else { ' ' };
                                writeln!(f, "{status}{i:06}: {state:?}")?;
                            }
                            Ok(())
                        }
                    }

                    impl fmt::Debug for State {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let rs = self
                                .transitions
                                .iter()
                                .map(|t| format!("{t:?}"))
                                .collect::<Vec<String>>()
                                .join(", ");
                            write!(f, "{rs}")
                        }
                    }

                    impl fmt::Debug for Transition {
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            if self.range.start == self.range.end {
                                write!(
                                    f,
                                    "{:02X} => {:02X}",
                                    self.range.start,
                                    self.next_id.as_usize(),
                                )
                            } else {
                                write!(
                                    f,
                                    "{:02X}-{:02X} => {:02X}",
                                    self.range.start,
                                    self.range.end,
                                    self.next_id.as_usize(),
                                )
                            }
                        }
                    }
                    /// Returns true if and only if the given ranges intersect.
                    fn intersects(r1: Utf8Range, r2: Utf8Range) -> bool {
                        !(r1.end < r2.start || r2.end < r1.start)
                    }
                }

            }
        }

        pub mod util
        {
            /*!
            A collection of modules that provide APIs that are useful across many regex engines. */
            use ::
            {
                *,
            };
            /*
            */
            pub mod alphabet
            {
                /*!
                This module provides APIs for dealing with the alphabets of finite state machines. */
                use ::
                {
                    *,
                };
                /*
                use crate::util::{
                    escape::DebugByte,
                    wire::{self, DeserializeError, SerializeError},
                };
                */
                /// Unit represents a single unit of haystack for DFA based regex engines.
                #[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]
                pub struct Unit(UnitKind);

                #[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]
                enum UnitKind
                {
                    /// Represents a byte value, or more typically, an equivalence class
                    U8(u8),
                    /// Represents the "end of input" sentinel. We regrettably use a `u16`
                    EOI(u16),
                }

                impl Unit
                {
                    /// Create a new haystack unit from a byte value.
                    pub fn u8(byte: u8) -> Unit {
                        Unit(UnitKind::U8(byte))
                    }
                    /// Create a new "end of input" haystack unit.
                    pub fn eoi(num_byte_equiv_classes: usize) -> Unit {
                        assert!(
                            num_byte_equiv_classes <= 256,
                            "max number of byte-based equivalent classes is 256, but got \
                            {num_byte_equiv_classes}",
                        );
                        Unit(UnitKind::EOI(u16::try_from(num_byte_equiv_classes).unwrap()))
                    }
                    /// If this unit is not an "end of input" sentinel, then returns its
                    pub fn as_u8(self) -> Option<u8> {
                        match self.0 {
                            UnitKind::U8(b) => Some(b),
                            UnitKind::EOI(_) => None,
                        }
                    }
                    /// If this unit is an "end of input" sentinel, then return the underlying
                    pub fn as_eoi(self) -> Option<u16> {
                        match self.0 {
                            UnitKind::U8(_) => None,
                            UnitKind::EOI(sentinel) => Some(sentinel),
                        }
                    }
                    /// Return this unit as a `usize`, regardless of whether it is a byte value
                    pub fn as_usize(self) -> usize {
                        match self.0 {
                            UnitKind::U8(b) => usize::from(b),
                            UnitKind::EOI(eoi) => usize::from(eoi),
                        }
                    }
                    /// Returns true if and only of this unit is a byte value equivalent to the
                    pub fn is_byte(self, byte: u8) -> bool {
                        self.as_u8().map_or(false, |b| b == byte)
                    }
                    /// Returns true when this unit represents an "end of input" sentinel.
                    pub fn is_eoi(self) -> bool {
                        self.as_eoi().is_some()
                    }
                    /// Returns true when this unit corresponds to an ASCII word byte.
                    pub fn is_word_byte(self) -> bool {
                        self.as_u8().map_or(false, crate::util::utf8::is_word_byte)
                    }
                }

                impl ::fmt::Debug for Unit {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        match self.0 {
                            UnitKind::U8(b) => write!(f, "{:?}", DebugByte(b)),
                            UnitKind::EOI(_) => write!(f, "EOI"),
                        }
                    }
                }
                /// A representation of byte oriented equivalence classes.
                #[derive(Clone, Copy)]
                pub struct ByteClasses([u8; 256]);

                impl ByteClasses
                {
                    /// Creates a new set of equivalence classes where all bytes are mapped to
                    #[inline] pub fn empty() -> ByteClasses {
                        ByteClasses([0; 256])
                    }
                    /// Creates a new set of equivalence classes where each byte belongs to
                    #[inline] pub fn singletons() -> ByteClasses {
                        let mut classes = ByteClasses::empty();
                        for b in 0..=255 {
                            classes.set(b, b);
                        }
                        classes
                    }
                    /// Deserializes a byte class map from the given slice. If the slice is of
                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(ByteClasses, usize), DeserializeError> {
                        wire::check_slice_len(slice, 256, "byte class map")?;
                        let mut classes = ByteClasses::empty();
                        for (b, &class) in slice[..256].iter().enumerate() {
                            classes.set(u8::try_from(b).unwrap(), class);
                        }
                        for &b in classes.0.iter()
                        {
                            if usize::from(b) >= classes.alphabet_len() {
                                return Err(DeserializeError::generic(
                                    "found equivalence class greater than alphabet len",
                                ));
                            }
                        }
                        Ok((classes, 256))
                    }
                    /// Writes this byte class map to the given byte buffer. if the given
                    pub fn write_to(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("byte class map"));
                        }
                        for b in 0..=255 {
                            dst[0] = self.get(b);
                            dst = &mut dst[1..];
                        }
                        Ok(nwrite)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize {
                        256
                    }
                    /// Set the equivalence class for the given byte.
                    #[inline] pub fn set(&mut self, byte: u8, class: u8) {
                        self.0[usize::from(byte)] = class;
                    }
                    /// Get the equivalence class for the given byte.
                    #[inline] pub fn get(&self, byte: u8) -> u8 {
                        self.0[usize::from(byte)]
                    }
                    /// Get the equivalence class for the given haystack unit and return the
                    #[inline] pub fn get_by_unit(&self, unit: Unit) -> usize {
                        match unit.0 {
                            UnitKind::U8(b) => usize::from(self.get(b)),
                            UnitKind::EOI(b) => usize::from(b),
                        }
                    }
                    /// Create a unit that represents the "end of input" sentinel based on the
                    #[inline] pub fn eoi(&self) -> Unit {
                        Unit::eoi(self.alphabet_len().checked_sub(1).unwrap())
                    }
                    /// Return the total number of elements in the alphabet represented by
                    #[inline] pub fn alphabet_len(&self) -> usize {
                        usize::from(self.0[255]) + 1 + 1
                    }
                    /// Returns the stride, as a base-2 exponent, required for these
                    #[inline] pub fn stride2(&self) -> usize {
                        let zeros = self.alphabet_len().next_power_of_two().trailing_zeros();
                        usize::try_from(zeros).unwrap()
                    }
                    /// Returns true if and only if every byte in this class maps to its own
                    #[inline] pub fn is_singleton(&self) -> bool {
                        self.alphabet_len() == 257
                    }
                    /// Returns an iterator over all equivalence classes in this set.
                    #[inline] pub fn iter(&self) -> ByteClassIter<'_> {
                        ByteClassIter { classes: self, i: 0 }
                    }
                    /// Returns an iterator over a sequence of representative bytes from each
                    pub fn representatives<R: ::ops::RangeBounds<u8>>(
                        &self,
                        range: R,
                    ) -> ByteClassRepresentatives<'_> {
                        use ::ops::Bound;

                        let cur_byte = match range.start_bound() {
                            Bound::Included(&i) => usize::from(i),
                            Bound::Excluded(&i) => usize::from(i).checked_add(1).unwrap(),
                            Bound::Unbounded => 0,
                        };
                        let end_byte = match range.end_bound() {
                            Bound::Included(&i) => {
                                Some(usize::from(i).checked_add(1).unwrap())
                            }
                            Bound::Excluded(&i) => Some(usize::from(i)),
                            Bound::Unbounded => None,
                        };
                        assert_ne!(
                            cur_byte,
                            usize::MAX,
                            "start range must be less than usize::MAX",
                        );
                        ByteClassRepresentatives {
                            classes: self,
                            cur_byte,
                            end_byte,
                            last_class: None,
                        }
                    }
                    /// Returns an iterator of the bytes in the given equivalence class.
                    #[inline] pub fn elements(&self, class: Unit) -> ByteClassElements<'_> {
                        ByteClassElements { classes: self, class, byte: 0 }
                    }
                    /// Returns an iterator of byte ranges in the given equivalence class.
                    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges<'_> {
                        ByteClassElementRanges { elements: self.elements(class), range: None }
                    }
                }

                impl Default for ByteClasses {
                    fn default() -> ByteClasses {
                        ByteClasses::singletons()
                    }
                }

                impl ::fmt::Debug for ByteClasses {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        if self.is_singleton() {
                            write!(f, "ByteClasses({{singletons}})")
                        } else {
                            write!(f, "ByteClasses(")?;
                            for (i, class) in self.iter().enumerate()
                            {
                                if i > 0 {
                                    write!(f, ", ")?;
                                }
                                write!(f, "{:?} => [", class.as_usize())?;
                                for (start, end) in self.element_ranges(class) {
                                    if start == end {
                                        write!(f, "{start:?}")?;
                                    } else {
                                        write!(f, "{start:?}-{end:?}")?;
                                    }
                                }
                                write!(f, "]")?;
                            }
                            write!(f, ")")
                        }
                    }
                }
                /// An iterator over each equivalence class.
                #[derive(Debug)]
                pub struct ByteClassIter<'a> {
                    classes: &'a ByteClasses,
                    i: usize,
                }

                impl<'a> Iterator for ByteClassIter<'a> {
                    type Item = Unit;

                    fn next(&mut self) -> Option<Unit> {
                        if self.i + 1 == self.classes.alphabet_len() {
                            self.i += 1;
                            Some(self.classes.eoi())
                        } else if self.i < self.classes.alphabet_len() {
                            let class = u8::try_from(self.i).unwrap();
                            self.i += 1;
                            Some(Unit::u8(class))
                        } else {
                            None
                        }
                    }
                }
                /// An iterator over representative bytes from each equivalence class.
                #[derive(Debug)]
                pub struct ByteClassRepresentatives<'a> {
                    classes: &'a ByteClasses,
                    cur_byte: usize,
                    end_byte: Option<usize>,
                    last_class: Option<u8>,
                }

                impl<'a> Iterator for ByteClassRepresentatives<'a> {
                    type Item = Unit;

                    fn next(&mut self) -> Option<Unit> {
                        while self.cur_byte < self.end_byte.unwrap_or(256) {
                            let byte = u8::try_from(self.cur_byte).unwrap();
                            let class = self.classes.get(byte);
                            self.cur_byte += 1;

                            if self.last_class != Some(class) {
                                self.last_class = Some(class);
                                return Some(Unit::u8(byte));
                            }
                        }
                        
                        if self.cur_byte != usize::MAX && self.end_byte.is_none() {
                            self.cur_byte = usize::MAX;
                            return Some(self.classes.eoi());
                        }
                        None
                    }
                }
                /// An iterator over all elements in an equivalence class.
                #[derive(Debug)]
                pub struct ByteClassElements<'a> {
                    classes: &'a ByteClasses,
                    class: Unit,
                    byte: usize,
                }

                impl<'a> Iterator for ByteClassElements<'a> {
                    type Item = Unit;

                    fn next(&mut self) -> Option<Unit> {
                        while self.byte < 256 {
                            let byte = u8::try_from(self.byte).unwrap();
                            self.byte += 1;
                            if self.class.is_byte(self.classes.get(byte)) {
                                return Some(Unit::u8(byte));
                            }
                        }
                        
                        if self.byte < 257 {
                            self.byte += 1;
                            if self.class.is_eoi() {
                                return Some(Unit::eoi(256));
                            }
                        }
                        None
                    }
                }
                /// An iterator over all elements in an equivalence class expressed as a
                #[derive(Debug)]
                struct ByteClassElementRanges<'a> {
                    elements: ByteClassElements<'a>,
                    range: Option<(Unit, Unit)>,
                }

                impl<'a> Iterator for ByteClassElementRanges<'a> {
                    type Item = (Unit, Unit);

                    fn next(&mut self) -> Option<(Unit, Unit)> {
                        loop {
                            let element = match self.elements.next() {
                                None => return self.range.take(),
                                Some(element) => element,
                            };
                            match self.range.take() {
                                None => {
                                    self.range = Some((element, element));
                                }
                                Some((start, end)) => {
                                    if end.as_usize() + 1 != element.as_usize()
                                        || element.is_eoi()
                                    {
                                        self.range = Some((element, element));
                                        return Some((start, end));
                                    }
                                    self.range = Some((start, element));
                                }
                            }
                        }
                    }
                }
                /// A partitioning of bytes into equivalence classes.
                #[derive(Clone, Debug)]
                pub struct ByteClassSet(ByteSet);

                impl Default for ByteClassSet {
                    fn default() -> ByteClassSet {
                        ByteClassSet::empty()
                    }
                }

                impl ByteClassSet
                {
                    /// Create a new set of byte classes where all bytes are part of the same
                    pub fn empty() -> Self {
                        ByteClassSet(ByteSet::empty())
                    }
                    /// Indicate the range of byte given (inclusive) can discriminate a
                    pub fn set_range(&mut self, start: u8, end: u8) {
                        debug_assert!(start <= end);
                        
                        if start > 0 {
                            self.0.add(start - 1);
                        }
                        self.0.add(end);
                    }
                    /// Add the contiguous ranges in the set given to this byte class set.
                    pub fn add_set(&mut self, set: &ByteSet) {
                        for (start, end) in set.iter_ranges() {
                            self.set_range(start, end);
                        }
                    }
                    /// Convert this boolean set to a map that maps all byte values to their
                    pub fn byte_classes(&self) -> ByteClasses {
                        let mut classes = ByteClasses::empty();
                        let mut class = 0u8;
                        let mut b = 0u8;

                        loop
                        {
                            classes.set(b, class);
                            if b == 255 {
                                break;
                            }
                            
                            if self.0.contains(b) {
                                class = class.checked_add(1).unwrap();
                            }
                            b = b.checked_add(1).unwrap();
                        }
                        classes
                    }
                }
                /// A simple set of bytes that is reasonably cheap to copy and allocation free.
                #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
                pub struct ByteSet {
                    bits: BitSet,
                }
                /// The representation of a byte set. Split out so that we can define a
                #[derive(Clone, Copy, Default, Eq, PartialEq)]
                struct BitSet([u128; 2]);

                impl ByteSet
                {
                    /// Create an empty set of bytes.
                    pub fn empty() -> ByteSet {
                        ByteSet { bits: BitSet([0; 2]) }
                    }
                    /// Add a byte to this set.
                    pub fn add(&mut self, byte: u8) {
                        let bucket = byte / 128;
                        let bit = byte % 128;
                        self.bits.0[usize::from(bucket)] |= 1 << bit;
                    }
                    /// Remove a byte from this set.
                    pub fn remove(&mut self, byte: u8) {
                        let bucket = byte / 128;
                        let bit = byte % 128;
                        self.bits.0[usize::from(bucket)] &= !(1 << bit);
                    }
                    /// Return true if and only if the given byte is in this set.
                    pub fn contains(&self, byte: u8) -> bool {
                        let bucket = byte / 128;
                        let bit = byte % 128;
                        self.bits.0[usize::from(bucket)] & (1 << bit) > 0
                    }
                    /// Return true if and only if the given inclusive range of bytes is in
                    pub fn contains_range(&self, start: u8, end: u8) -> bool {
                        (start..=end).all(|b| self.contains(b))
                    }
                    /// Returns an iterator over all bytes in this set.
                    pub fn iter(&self) -> ByteSetIter<'_> {
                        ByteSetIter { set: self, b: 0 }
                    }
                    /// Returns an iterator over all contiguous ranges of bytes in this set.
                    pub fn iter_ranges(&self) -> ByteSetRangeIter<'_> {
                        ByteSetRangeIter { set: self, b: 0 }
                    }
                    /// Return true if and only if this set is empty.
                    #[inline( always )]
                    pub fn is_empty(&self) -> bool {
                        self.bits.0 == [0, 0]
                    }
                    /// Deserializes a byte set from the given slice. If the slice is of
                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(ByteSet, usize), DeserializeError> {
                        use ::mem::size_of;

                        wire::check_slice_len(slice, 2 * size_of::<u128>(), "byte set")?;
                        let mut nread = 0;
                        let (low, nr) = wire::try_read_u128(slice, "byte set low bucket")?;
                        nread += nr;
                        let (high, nr) = wire::try_read_u128(slice, "byte set high bucket")?;
                        nread += nr;
                        Ok((ByteSet { bits: BitSet([low, high]) }, nread))
                    }
                    /// Writes this byte set to the given byte buffer. If the given buffer is
                    pub fn write_to<E: crate::util::wire::Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        use ::mem::size_of;

                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("byte set"));
                        }
                        let mut nw = 0;
                        E::write_u128(self.bits.0[0], &mut dst[nw..]);
                        nw += size_of::<u128>();
                        E::write_u128(self.bits.0[1], &mut dst[nw..]);
                        nw += size_of::<u128>();
                        assert_eq!(nwrite, nw, "expected to write certain number of bytes",);
                        assert_eq!(
                            nw % 8,
                            0,
                            "expected to write multiple of 8 bytes for byte set",
                        );
                        Ok(nw)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize {
                        2 * ::mem::size_of::<u128>()
                    }
                }

                impl ::fmt::Debug for BitSet {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let mut fmtd = f.debug_set();
                        for b in 0u8..=255 {
                            if (ByteSet { bits: *self }).contains(b) {
                                fmtd.entry(&b);
                            }
                        }
                        fmtd.finish()
                    }
                }

                #[derive(Debug)]
                pub struct ByteSetIter<'a> {
                    set: &'a ByteSet,
                    b: usize,
                }

                impl<'a> Iterator for ByteSetIter<'a> {
                    type Item = u8;

                    fn next(&mut self) -> Option<u8> {
                        while self.b <= 255 {
                            let b = u8::try_from(self.b).unwrap();
                            self.b += 1;
                            if self.set.contains(b) {
                                return Some(b);
                            }
                        }
                        None
                    }
                }

                #[derive(Debug)]
                pub struct ByteSetRangeIter<'a> {
                    set: &'a ByteSet,
                    b: usize,
                }

                impl<'a> Iterator for ByteSetRangeIter<'a> {
                    type Item = (u8, u8);

                    fn next(&mut self) -> Option<(u8, u8)> {
                        let asu8 = |n: usize| u8::try_from(n).unwrap();
                        while self.b <= 255 {
                            let start = asu8(self.b);
                            self.b += 1;
                            if !self.set.contains(start) {
                                continue;
                            }

                            let mut end = start;
                            while self.b <= 255 && self.set.contains(asu8(self.b)) {
                                end = asu8(self.b);
                                self.b += 1;
                            }
                            return Some((start, end));
                        }
                        None
                    }
                }
            }

            pub mod captures
            {
                /*!
                Provides types for dealing with capturing groups. */
                use ::
                {
                    *,
                };
                /*
                use ::{string::String, sync::Arc, vec, vec::Vec};

                use crate::util::{
                    interpolate,
                    primitives::{
                        NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex,
                    },
                    search::{Match, Span},
                };
                */
                /// The span offsets of capturing groups after a match has been found.
                #[derive(Clone)]
                pub struct Captures
                {
                    /// The group info that these capture groups are coupled to. This is what
                    group_info: GroupInfo,
                    /// The ID of the pattern that matched. Regex engines must set this to
                    pid: Option<PatternID>,
                    /// The slot values, i.e., submatch offsets.
                    slots: Vec<Option<NonMaxUsize>>,
                }

                impl Captures
                {
                    /// Create new storage for the offsets of all matching capturing groups.
                    pub fn all(group_info: GroupInfo) -> Captures {
                        let slots = group_info.slot_len();
                        Captures { group_info, pid: None, slots: vec![None; slots] }
                    }
                    /// Create new storage for only the full match spans of a pattern. This
                    pub fn matches(group_info: GroupInfo) -> Captures {
                        let slots = group_info.pattern_len().checked_mul(2).unwrap();
                        Captures { group_info, pid: None, slots: vec![None; slots] }
                    }
                    /// Create new storage for only tracking which pattern matched. No offsets
                    pub fn empty(group_info: GroupInfo) -> Captures {
                        Captures { group_info, pid: None, slots: vec![] }
                    }
                    /// Returns true if and only if this capturing group represents a match.
                    #[inline] pub fn is_match(&self) -> bool {
                        self.pid.is_some()
                    }
                    /// Returns the identifier of the pattern that matched when this
                    #[inline] pub fn pattern(&self) -> Option<PatternID> {
                        self.pid
                    }
                    /// Returns the pattern ID and the span of the match, if one occurred.
                    #[inline] pub fn get_match(&self) -> Option<Match> {
                        Some(Match::new(self.pattern()?, self.get_group(0)?))
                    }
                    /// Returns the span of a capturing group match corresponding to the group
                    #[inline] pub fn get_group(&self, index: usize) -> Option<Span> {
                        let pid = self.pattern()?;
                        let (slot_start, slot_end) = if self.group_info().pattern_len() == 1 {
                            (index.checked_mul(2)?, index.checked_mul(2)?.checked_add(1)?)
                        } else {
                            self.group_info().slots(pid, index)?
                        };
                        let start = self.slots.get(slot_start).copied()??;
                        let end = self.slots.get(slot_end).copied()??;
                        Some(Span { start: start.get(), end: end.get() })
                    }
                    /// Returns the span of a capturing group match corresponding to the group
                    pub fn get_group_by_name(&self, name: &str) -> Option<Span> {
                        let index = self.group_info().to_index(self.pattern()?, name)?;
                        self.get_group(index)
                    }
                    /// Returns an iterator of possible spans for every capturing group in the
                    pub fn iter(&self) -> CapturesPatternIter<'_> {
                        let names = self
                            .pattern()
                            .map_or(GroupInfoPatternNames::empty().enumerate(), |pid| {
                                self.group_info().pattern_names(pid).enumerate()
                            });
                        CapturesPatternIter { caps: self, names }
                    }
                    /// Return the total number of capturing groups for the matching pattern.
                    pub fn group_len(&self) -> usize {
                        let pid = match self.pattern() {
                            None => return 0,
                            Some(pid) => pid,
                        };
                        self.group_info().group_len(pid)
                    }
                    /// Returns a reference to the underlying group info on which these
                    pub fn group_info(&self) -> &GroupInfo {
                        &self.group_info
                    }
                    /// Interpolates the capture references in `replacement` with the
                    pub fn interpolate_string(
                        &self,
                        haystack: &str,
                        replacement: &str,
                    ) -> String {
                        let mut dst = String::new();
                        self.interpolate_string_into(haystack, replacement, &mut dst);
                        dst
                    }
                    /// Interpolates the capture references in `replacement` with the
                    pub fn interpolate_string_into(
                        &self,
                        haystack: &str,
                        replacement: &str,
                        dst: &mut String,
                    ) {
                        interpolate::string(
                            replacement,
                            |index, dst| {
                                let span = match self.get_group(index) {
                                    None => return,
                                    Some(span) => span,
                                };
                                dst.push_str(&haystack[span]);
                            },
                            |name| self.group_info().to_index(self.pattern()?, name),
                            dst,
                        );
                    }
                    /// Interpolates the capture references in `replacement` with the
                    pub fn interpolate_bytes(
                        &self,
                        haystack: &[u8],
                        replacement: &[u8],
                    ) -> Vec<u8> {
                        let mut dst = vec![];
                        self.interpolate_bytes_into(haystack, replacement, &mut dst);
                        dst
                    }
                    /// Interpolates the capture references in `replacement` with the
                    pub fn interpolate_bytes_into(
                        &self,
                        haystack: &[u8],
                        replacement: &[u8],
                        dst: &mut Vec<u8>,
                    ) {
                        interpolate::bytes(
                            replacement,
                            |index, dst| {
                                let span = match self.get_group(index) {
                                    None => return,
                                    Some(span) => span,
                                };
                                dst.extend_from_slice(&haystack[span]);
                            },
                            |name| self.group_info().to_index(self.pattern()?, name),
                            dst,
                        );
                    }
                    /// This is a convenience routine for extracting the substrings
                    pub fn extract<'h, const N: usize>(
                        &self,
                        haystack: &'h str,
                    ) -> (&'h str, [&'h str; N]) {
                        let mut matched = self.iter().flatten();
                        let whole_match = &haystack[matched.next().expect("a match")];
                        let group_matches = [0; N].map(|_| {
                            let sp = matched.next().expect("too few matching groups");
                            &haystack[sp]
                        });
                        (whole_match, group_matches)
                    }
                    /// This is a convenience routine for extracting the substrings
                    pub fn extract_bytes<'h, const N: usize>(
                        &self,
                        haystack: &'h [u8],
                    ) -> (&'h [u8], [&'h [u8]; N]) {
                        let mut matched = self.iter().flatten();
                        let whole_match = &haystack[matched.next().expect("a match")];
                        let group_matches = [0; N].map(|_| {
                            let sp = matched.next().expect("too few matching groups");
                            &haystack[sp]
                        });
                        (whole_match, group_matches)
                    }
                }
                /// Lower level "slot" oriented APIs. One does not typically need to use these
                impl Captures
                {
                    /// Clear this `Captures` value.
                    #[inline] pub fn clear(&mut self) {
                        self.pid = None;
                        for slot in self.slots.iter_mut() {
                            *slot = None;
                        }
                    }
                    /// Set the pattern on this `Captures` value.
                    #[inline] pub fn set_pattern(&mut self, pid: Option<PatternID>) {
                        self.pid = pid;
                    }
                    /// Returns the underlying slots, where each slot stores a single offset.
                    #[inline] pub fn slots(&self) -> &[Option<NonMaxUsize>] {
                        &self.slots
                    }
                    /// Returns the underlying slots as a mutable slice, where each slot stores
                    #[inline] pub fn slots_mut(&mut self) -> &mut [Option<NonMaxUsize>] {
                        &mut self.slots
                    }
                }

                impl ::fmt::Debug for Captures {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let mut dstruct = f.debug_struct("Captures");
                        dstruct.field("pid", &self.pid);
                        
                        if let Some(pid) = self.pid {
                            dstruct.field("spans", &CapturesDebugMap { pid, caps: self });
                        }
                        dstruct.finish()
                    }
                }
                /// A little helper type to provide a nice map-like debug representation for
                struct CapturesDebugMap<'a> {
                    pid: PatternID,
                    caps: &'a Captures,
                }

                impl<'a> ::fmt::Debug for CapturesDebugMap<'a> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        struct Key<'a>(usize, Option<&'a str>);

                        impl<'a> ::fmt::Debug for Key<'a> {
                            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                                write!(f, "{}", self.0)?;
                                
                                if let Some(name) = self.1 {
                                    write!(f, "/{name:?}")?;
                                }
                                Ok(())
                            }
                        }

                        let mut map = f.debug_map();
                        let names = self.caps.group_info().pattern_names(self.pid);
                        for (group_index, maybe_name) in names.enumerate() {
                            let key = Key(group_index, maybe_name);
                            match self.caps.get_group(group_index) {
                                None => map.entry(&key, &None::<()>),
                                Some(span) => map.entry(&key, &span),
                            };
                        }
                        map.finish()
                    }
                }
                /// An iterator over all capturing groups in a `Captures` value.
                #[derive(Clone, Debug)]
                pub struct CapturesPatternIter<'a> {
                    caps: &'a Captures,
                    names: ::iter::Enumerate<GroupInfoPatternNames<'a>>,
                }

                impl<'a> Iterator for CapturesPatternIter<'a> {
                    type Item = Option<Span>;

                    fn next(&mut self) -> Option<Option<Span>> {
                        let (group_index, _) = self.names.next()?;
                        Some(self.caps.get_group(group_index))
                    }

                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.names.size_hint()
                    }

                    fn count(self) -> usize {
                        self.names.count()
                    }
                }

                impl<'a> ExactSizeIterator for CapturesPatternIter<'a> {}
                impl<'a> ::iter::FusedIterator for CapturesPatternIter<'a> {}
                /// Represents information about capturing groups in a compiled regex.
                #[derive(Clone, Debug, Default)]
                pub struct GroupInfo(Arc<GroupInfoInner>);

                impl GroupInfo
                {
                    /// Creates a new group info from a sequence of patterns, where each
                    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>
                    where
                        P: IntoIterator<Item = G>,
                        G: IntoIterator<Item = Option<N>>,
                        N: AsRef<str>,
                    {
                        let mut group_info = GroupInfoInner {
                            slot_ranges: vec![],
                            name_to_index: vec![],
                            index_to_name: vec![],
                            memory_extra: 0,
                        };
                        for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {
                            let pid = PatternID::new(pattern_index)
                                .map_err(GroupInfoError::too_many_patterns)?;

                            let mut groups_iter = groups.into_iter().enumerate();
                            match groups_iter.next() {
                                None => return Err(GroupInfoError::missing_groups(pid)),
                                Some((_, Some(_))) => {
                                    return Err(GroupInfoError::first_must_be_unnamed(pid))
                                }
                                Some((_, None)) => {}
                            }
                            group_info.add_first_group(pid);
                            for (group_index, maybe_name) in groups_iter {
                                let group = SmallIndex::new(group_index).map_err(|_| {
                                    GroupInfoError::too_many_groups(pid, group_index)
                                })?;
                                group_info.add_explicit_group(pid, group, maybe_name)?;
                            }
                        }
                        group_info.fixup_slot_ranges()?;
                        Ok(GroupInfo(Arc::new(group_info)))
                    }
                    /// This creates an empty `GroupInfo`.
                    pub fn empty() -> GroupInfo {
                        GroupInfo::new(::iter::empty::<[Option<&str>; 0]>())
                            .expect("empty group info is always valid")
                    }
                    /// Return the capture group index corresponding to the given name in the
                    #[inline] pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {
                        let indices = self.0.name_to_index.get(pid.as_usize())?;
                        indices.get(name).cloned().map(|i| i.as_usize())
                    }
                    /// Return the capture name for the given index and given pattern. If the
                    #[inline] pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {
                        let pattern_names = self.0.index_to_name.get(pid.as_usize())?;
                        pattern_names.get(group_index)?.as_deref()
                    }
                    /// Return an iterator of all capture groups and their names (if present)
                    #[inline] pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {
                        GroupInfoPatternNames {
                            it: self
                                .0
                                .index_to_name
                                .get(pid.as_usize())
                                .map(|indices| indices.iter())
                                .unwrap_or([].iter()),
                        }
                    }
                    /// Return an iterator of all capture groups for all patterns supported by
                    #[inline] pub fn all_names(&self) -> GroupInfoAllNames<'_> {
                        GroupInfoAllNames {
                            group_info: self,
                            pids: PatternID::iter(self.pattern_len()),
                            current_pid: None,
                            names: None,
                        }
                    }
                    /// Returns the starting and ending slot corresponding to the given
                    #[inline] pub fn slots(
                        &self,
                        pid: PatternID,
                        group_index: usize,
                    ) -> Option<(usize, usize)> {
                        self.slot(pid, group_index).map(|start| (start, start + 1))
                    }
                    /// Returns the starting slot corresponding to the given capturing group
                    #[inline] pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {
                        if group_index >= self.group_len(pid) {
                            return None;
                        }
                        
                        if group_index == 0 {
                            Some(pid.as_usize() * 2)
                        } else {
                            let (start, _) = self.0.slot_ranges[pid];
                            Some(start.as_usize() + ((group_index - 1) * 2))
                        }
                    }
                    /// Returns the total number of patterns in this `GroupInfo`.
                    #[inline] pub fn pattern_len(&self) -> usize {
                        self.0.pattern_len()
                    }
                    /// Return the number of capture groups in a pattern.
                    #[inline] pub fn group_len(&self, pid: PatternID) -> usize {
                        self.0.group_len(pid)
                    }
                    /// Return the total number of capture groups across all patterns.
                    #[inline] pub fn all_group_len(&self) -> usize {
                        self.slot_len() / 2
                    }
                    /// Returns the total number of slots in this `GroupInfo` across all
                    #[inline] pub fn slot_len(&self) -> usize {
                        self.0.small_slot_len().as_usize()
                    }
                    /// Returns the total number of slots for implicit capturing groups.
                    #[inline] pub fn implicit_slot_len(&self) -> usize {
                        self.pattern_len() * 2
                    }
                    /// Returns the total number of slots for explicit capturing groups.
                    #[inline] pub fn explicit_slot_len(&self) -> usize {
                        self.slot_len().saturating_sub(self.implicit_slot_len())
                    }
                    /// Returns the memory usage, in bytes, of this `GroupInfo`.
                    #[inline] pub fn memory_usage(&self) -> usize {
                        use ::mem::size_of as s;

                        s::<GroupInfoInner>()
                            + self.0.slot_ranges.len() * s::<(SmallIndex, SmallIndex)>()
                            + self.0.name_to_index.len() * s::<CaptureNameMap>()
                            + self.0.index_to_name.len() * s::<Vec<Option<Arc<str>>>>()
                            + self.0.memory_extra
                    }
                }
                /// A map from capture group name to its corresponding capture group index.
                type CaptureNameMap = ::collections::HashMap<Arc<str>, SmallIndex>;
                /// The inner guts of `GroupInfo`. This type only exists so that it can
                #[derive(Debug, Default)]
                struct GroupInfoInner {
                    slot_ranges: Vec<(SmallIndex, SmallIndex)>,
                    name_to_index: Vec<CaptureNameMap>,
                    index_to_name: Vec<Vec<Option<Arc<str>>>>,
                    memory_extra: usize,
                }

                impl GroupInfoInner
                {
                    /// This adds the first unnamed group for the given pattern ID. The given
                    fn add_first_group(&mut self, pid: PatternID) {
                        assert_eq!(pid.as_usize(), self.slot_ranges.len());
                        assert_eq!(pid.as_usize(), self.name_to_index.len());
                        assert_eq!(pid.as_usize(), self.index_to_name.len());
                        let slot_start = self.small_slot_len();
                        self.slot_ranges.push((slot_start, slot_start));
                        self.name_to_index.push(CaptureNameMap::new());
                        self.index_to_name.push(vec![None]);
                        self.memory_extra += ::mem::size_of::<Option<Arc<str>>>();
                    }
                    /// Add an explicit capturing group for the given pattern with the given
                    fn add_explicit_group<N: AsRef<str>>
                    (
                        &mut self,
                        pid: PatternID,
                        group: SmallIndex,
                        maybe_name: Option<N>,
                    ) -> Result<(), GroupInfoError> {
                        let end = &mut self.slot_ranges[pid].1;
                        *end = SmallIndex::new(end.as_usize() + 2).map_err(|_| {
                            GroupInfoError::too_many_groups(pid, group.as_usize())
                        })?;
                        
                        if let Some(name) = maybe_name {
                            let name = Arc::<str>::from(name.as_ref());
                            if self.name_to_index[pid].contains_key(&*name) {
                                return Err(GroupInfoError::duplicate(pid, &name));
                            }
                            let len = name.len();
                            self.name_to_index[pid].insert(Arc::clone(&name), group);
                            self.index_to_name[pid].push(Some(name));
                            // Adds the memory used by the Arc<str> in both maps.
                            self.memory_extra +=
                                2 * (len + ::mem::size_of::<Option<Arc<str>>>());
                            self.memory_extra += ::mem::size_of::<SmallIndex>();
                        } else {
                            self.index_to_name[pid].push(None);
                            self.memory_extra += ::mem::size_of::<Option<Arc<str>>>();
                        }
                        assert_eq!(group.one_more(), self.group_len(pid));
                        // And is also in line with the 'index_to_name' map.
                        assert_eq!(group.one_more(), self.index_to_name[pid].len());
                        Ok(())
                    }
                    /// This corrects the slot ranges to account for the slots corresponding
                    fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {
                        use crate::util::primitives::IteratorIndexExt;
                        let offset = self.pattern_len().checked_mul(2).unwrap();
                        for (pid, &mut (ref mut start, ref mut end)) in
                            self.slot_ranges.iter_mut().with_pattern_ids()
                        {
                            let group_len = 1 + ((end.as_usize() - start.as_usize()) / 2);
                            let new_end = match end.as_usize().checked_add(offset) {
                                Some(new_end) => new_end,
                                None => {
                                    return Err(GroupInfoError::too_many_groups(
                                        pid, group_len,
                                    ))
                                }
                            };
                            *end = SmallIndex::new(new_end).map_err(|_| {
                                GroupInfoError::too_many_groups(pid, group_len)
                            })?;
                            // Since start <= end, if end is valid then start must be too.
                            *start = SmallIndex::new(start.as_usize() + offset).unwrap();
                        }
                        Ok(())
                    }
                    /// Return the total number of patterns represented by this capture slot
                    fn pattern_len(&self) -> usize {
                        self.slot_ranges.len()
                    }
                    /// Return the total number of capturing groups for the given pattern. If
                    fn group_len(&self, pid: PatternID) -> usize {
                        let (start, end) = match self.slot_ranges.get(pid.as_usize()) {
                            None => return 0,
                            Some(range) => range,
                        };
                        1 + ((end.as_usize() - start.as_usize()) / 2)
                    }
                    /// Return the total number of slots in this capture slot info as a
                    fn small_slot_len(&self) -> SmallIndex {
                        self.slot_ranges.last().map_or(SmallIndex::ZERO, |&(_, end)| end)
                    }
                }
                /// An error that may occur when building a `GroupInfo`.
                #[derive(Clone, Debug)]
                pub struct GroupInfoError {
                    kind: GroupInfoErrorKind,
                }
                /// The kind of error that occurs when building a `GroupInfo` fails.
                #[derive(Clone, Debug)]
                enum GroupInfoErrorKind
                {
                    /// This occurs when too many patterns have been added. i.e., It would
                    TooManyPatterns { err: PatternIDError },
                    /// This occurs when too many capturing groups have been added for a
                    TooManyGroups {
                        /// The ID of the pattern that had too many groups.
                        pattern: PatternID,
                        /// The minimum number of groups that the caller has tried to add for
                        minimum: usize,
                    },
                    /// An error that occurs when a pattern has no capture groups. Either the
                    MissingGroups {
                        /// The ID of the pattern that had no capturing groups.
                        pattern: PatternID,
                    },
                    /// An error that occurs when one tries to provide a name for the capture
                    FirstMustBeUnnamed {
                        /// The ID of the pattern that was found to have a named first
                        pattern: PatternID,
                    },
                    /// An error that occurs when duplicate capture group names for the same
                    Duplicate {
                        /// The pattern in which the duplicate capture group name was found.
                        pattern: PatternID,
                        /// The duplicate name.
                        name: String,
                    },
                }

                impl GroupInfoError {
                    fn too_many_patterns(err: PatternIDError) -> GroupInfoError {
                        GroupInfoError { kind: GroupInfoErrorKind::TooManyPatterns { err } }
                    }

                    fn too_many_groups(pattern: PatternID, minimum: usize) -> GroupInfoError {
                        GroupInfoError {
                            kind: GroupInfoErrorKind::TooManyGroups { pattern, minimum },
                        }
                    }

                    fn missing_groups(pattern: PatternID) -> GroupInfoError {
                        GroupInfoError { kind: GroupInfoErrorKind::MissingGroups { pattern } }
                    }

                    fn first_must_be_unnamed(pattern: PatternID) -> GroupInfoError {
                        GroupInfoError {
                            kind: GroupInfoErrorKind::FirstMustBeUnnamed { pattern },
                        }
                    }

                    fn duplicate(pattern: PatternID, name: &str) -> GroupInfoError {
                        GroupInfoError {
                            kind: GroupInfoErrorKind::Duplicate {
                                pattern,
                                name: String::from(name),
                            },
                        }
                    }
                }
                
                impl ::error::Error for GroupInfoError {
                    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                        match self.kind {
                            GroupInfoErrorKind::TooManyPatterns { .. }
                            | GroupInfoErrorKind::TooManyGroups { .. }
                            | GroupInfoErrorKind::MissingGroups { .. }
                            | GroupInfoErrorKind::FirstMustBeUnnamed { .. }
                            | GroupInfoErrorKind::Duplicate { .. } => None,
                        }
                    }
                }

                impl ::fmt::Display for GroupInfoError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        use self::GroupInfoErrorKind::*;

                        match self.kind {
                            TooManyPatterns { ref err } => {
                                write!(f, "too many patterns to build capture info: {err}")
                            }
                            TooManyGroups { pattern, minimum } => {
                                write!(
                                    f,
                                    "too many capture groups (at least {}) were \
                                    found for pattern {}",
                                    minimum,
                                    pattern.as_usize()
                                )
                            }
                            MissingGroups { pattern } => write!(
                                f,
                                "no capturing groups found for pattern {} \
                                (either all patterns have zero groups or all patterns have \
                                at least one group)",
                                pattern.as_usize(),
                            ),
                            FirstMustBeUnnamed { pattern } => write!(
                                f,
                                "first capture group (at index 0) for pattern {} has a name \
                                (it must be unnamed)",
                                pattern.as_usize(),
                            ),
                            Duplicate { pattern, ref name } => write!(
                                f,
                                "duplicate capture group name '{}' found for pattern {}",
                                name,
                                pattern.as_usize(),
                            ),
                        }
                    }
                }
                /// An iterator over capturing groups and their names for a specific pattern.
                #[derive(Clone, Debug)]
                pub struct GroupInfoPatternNames<'a> {
                    it: ::slice::Iter<'a, Option<Arc<str>>>,
                }

                impl GroupInfoPatternNames<'static> {
                    fn empty() -> GroupInfoPatternNames<'static> {
                        GroupInfoPatternNames { it: [].iter() }
                    }
                }

                impl<'a> Iterator for GroupInfoPatternNames<'a> {
                    type Item = Option<&'a str>;

                    fn next(&mut self) -> Option<Option<&'a str>> {
                        self.it.next().map(|x| x.as_deref())
                    }

                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.it.size_hint()
                    }

                    fn count(self) -> usize {
                        self.it.count()
                    }
                }

                impl<'a> ExactSizeIterator for GroupInfoPatternNames<'a> {}
                impl<'a> ::iter::FusedIterator for GroupInfoPatternNames<'a> {}
                /// An iterator over capturing groups and their names for a `GroupInfo`.
                #[derive(Debug)]
                pub struct GroupInfoAllNames<'a> {
                    group_info: &'a GroupInfo,
                    pids: PatternIDIter,
                    current_pid: Option<PatternID>,
                    names: Option<::iter::Enumerate<GroupInfoPatternNames<'a>>>,
                }

                impl<'a> Iterator for GroupInfoAllNames<'a> {
                    type Item = (PatternID, usize, Option<&'a str>);

                    fn next(&mut self) -> Option<(PatternID, usize, Option<&'a str>)> {
                        if self.group_info.0.index_to_name.is_empty() {
                            return None;
                        }
                        
                        if self.current_pid.is_none() {
                            self.current_pid = Some(self.pids.next()?);
                        }
                        let pid = self.current_pid.unwrap();
                        
                        if self.names.is_none() {
                            self.names = Some(self.group_info.pattern_names(pid).enumerate());
                        }
                        let (group_index, name) = match self.names.as_mut().unwrap().next() {
                            Some((group_index, name)) => (group_index, name),
                            None => {
                                self.current_pid = None;
                                self.names = None;
                                return self.next();
                            }
                        };
                        Some((pid, group_index, name))
                    }
                }
            }

            pub mod escape
            {
                /*!
                Provides convenience routines for escaping raw bytes. */
                use ::
                {
                    *,
                };
                /*
                use crate::util::utf8;
                */
                /// Provides a convenient `Debug` implementation for a `u8`.
                #[derive(Clone, Copy)]
                pub struct DebugByte(pub u8);

                impl ::fmt::Debug for DebugByte {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.0 == b' ' {
                            return write!(f, "' '");
                        }
                        // 10 bytes is enough to cover any output from ascii::escape_default.
                        let mut bytes = [0u8; 10];
                        let mut len = 0;
                        for (i, mut b) in ::ascii::escape_default(self.0).enumerate() {
                            // capitalize \xab to \xAB
                            if i >= 2 && b'a' <= b && b <= b'f' {
                                b -= 32;
                            }
                            bytes[len] = b;
                            len += 1;
                        }
                        write!(f, "{}", ::str::from_utf8(&bytes[..len]).unwrap())
                    }
                }
                /// Provides a convenient `Debug` implementation for `&[u8]`.
                pub struct DebugHaystack<'a>(pub &'a [u8]);

                impl<'a> ::fmt::Debug for DebugHaystack<'a> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "\"")?;
                        // This is a sad re-implementation of a similar impl found in bstr.
                        let mut bytes = self.0;
                        while let Some(result) = utf8::decode(bytes) {
                            let ch = match result {
                                Ok(ch) => ch,
                                Err(byte) => {
                                    write!(f, r"\x{byte:02x}")?;
                                    bytes = &bytes[1..];
                                    continue;
                                }
                            };
                            bytes = &bytes[ch.len_utf8()..];
                            match ch {
                                '\0' => write!(f, "\\0")?,
                                // ASCII control characters except \0, \n, \r, \t
                                '\x01'..='\x08'
                                | '\x0b'
                                | '\x0c'
                                | '\x0e'..='\x19'
                                | '\x7f' => {
                                    write!(f, "\\x{:02x}", u32::from(ch))?;
                                }
                                '\n' | '\r' | '\t' | _ => {
                                    write!(f, "{}", ch.escape_debug())?;
                                }
                            }
                        }
                        write!(f, "\"")?;
                        Ok(())
                    }
                }
            }

            pub mod interpolate
            {
                /*!
                Provides routines for interpolating capture group references. */
                use ::
                {
                    *,
                };
                /*
                use ::{string::String, vec::Vec};
                use crate::util::memchr::memchr;
                */
                /// Accepts a replacement string and interpolates capture references with their
                pub fn string(
                    mut replacement: &str,
                    mut append: impl FnMut(usize, &mut String),
                    mut name_to_index: impl FnMut(&str) -> Option<usize>,
                    dst: &mut String,
                ) {
                    while !replacement.is_empty() {
                        match memchr(b'$', replacement.as_bytes()) {
                            None => break,
                            Some(i) => {
                                dst.push_str(&replacement[..i]);
                                replacement = &replacement[i..];
                            }
                        }
                        // Handle escaping of '$'.
                        if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {
                            dst.push_str("$");
                            replacement = &replacement[2..];
                            continue;
                        }
                        debug_assert!(!replacement.is_empty());
                        let cap_ref = match find_cap_ref(replacement.as_bytes()) {
                            Some(cap_ref) => cap_ref,
                            None => {
                                dst.push_str("$");
                                replacement = &replacement[1..];
                                continue;
                            }
                        };
                        replacement = &replacement[cap_ref.end..];
                        match cap_ref.cap {
                            Ref::Number(i) => append(i, dst),
                            Ref::Named(name) => {
                                if let Some(i) = name_to_index(name) {
                                    append(i, dst);
                                }
                            }
                        }
                    }
                    dst.push_str(replacement);
                }
                /// Accepts a replacement byte string and interpolates capture references with
                pub fn bytes(
                    mut replacement: &[u8],
                    mut append: impl FnMut(usize, &mut Vec<u8>),
                    mut name_to_index: impl FnMut(&str) -> Option<usize>,
                    dst: &mut Vec<u8>,
                ) {
                    while !replacement.is_empty() {
                        match memchr(b'$', replacement) {
                            None => break,
                            Some(i) => {
                                dst.extend_from_slice(&replacement[..i]);
                                replacement = &replacement[i..];
                            }
                        }
                        // Handle escaping of '$'.
                        if replacement.get(1).map_or(false, |&b| b == b'$') {
                            dst.push(b'$');
                            replacement = &replacement[2..];
                            continue;
                        }
                        debug_assert!(!replacement.is_empty());
                        let cap_ref = match find_cap_ref(replacement) {
                            Some(cap_ref) => cap_ref,
                            None => {
                                dst.push(b'$');
                                replacement = &replacement[1..];
                                continue;
                            }
                        };
                        replacement = &replacement[cap_ref.end..];
                        match cap_ref.cap {
                            Ref::Number(i) => append(i, dst),
                            Ref::Named(name) => {
                                if let Some(i) = name_to_index(name) {
                                    append(i, dst);
                                }
                            }
                        }
                    }
                    dst.extend_from_slice(replacement);
                }
                /// `CaptureRef` represents a reference to a capture group inside some text.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                struct CaptureRef<'a> {
                    cap: Ref<'a>,
                    end: usize,
                }
                /// A reference to a capture group in some text.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                enum Ref<'a> {
                    Named(&'a str),
                    Number(usize),
                }

                impl<'a> From<&'a str> for Ref<'a> {
                    fn from(x: &'a str) -> Ref<'a> {
                        Ref::Named(x)
                    }
                }

                impl From<usize> for Ref<'static> {
                    fn from(x: usize) -> Ref<'static> {
                        Ref::Number(x)
                    }
                }
                /// Parses a possible reference to a capture group name in the given text,
                fn find_cap_ref(replacement: &[u8]) -> Option<CaptureRef<'_>>
                {
                    let mut i = 0;
                    let rep: &[u8] = replacement;
                    if rep.len() <= 1 || rep[0] != b'$' {
                        return None;
                    }
                    i += 1;
                    if rep[i] == b'{' {
                        return find_cap_ref_braced(rep, i + 1);
                    }
                    let mut cap_end = i;
                    
                    while rep.get(cap_end).copied().map_or(false, is_valid_cap_letter) {
                        cap_end += 1;
                    }
                    if cap_end == i {
                        return None;
                    }
                    let cap = ::str::from_utf8(&rep[i..cap_end])
                        .expect("valid UTF-8 capture name");
                    Some(CaptureRef {
                        cap: match cap.parse::<usize>() {
                            Ok(i) => Ref::Number(i),
                            Err(_) => Ref::Named(cap),
                        },
                        end: cap_end,
                    })
                }
                /// Looks for a braced reference, e.g., `${foo1}`. This assumes that an opening
                fn find_cap_ref_braced(rep: &[u8], mut i: usize) -> Option<CaptureRef<'_>> {
                    assert_eq!(b'{', rep[i.checked_sub(1).unwrap()]);
                    let start = i;
                    
                    while rep.get(i).map_or(false, |&b| b != b'}') {
                        i += 1;
                    }
                    if !rep.get(i).map_or(false, |&b| b == b'}') {
                        return None;
                    }
                    let cap = match ::str::from_utf8(&rep[start..i]) {
                        Err(_) => return None,
                        Ok(cap) => cap,
                    };
                    Some(CaptureRef {
                        cap: match cap.parse::<usize>() {
                            Ok(i) => Ref::Number(i),
                            Err(_) => Ref::Named(cap),
                        },
                        end: i + 1,
                    })
                }
            }

            pub mod iter
            {
                /*!
                Generic helpers for iteration of matches from a regex engine in a haystack. */
                use ::
                {
                    *,
                };
                /*
                use crate::util::captures::Captures;
                use crate::util::search::{HalfMatch, Input, Match, MatchError};
                */
                /// A searcher for creating iterators and performing lower level iteration.
                #[derive(Clone, Debug)]
                pub struct Searcher<'h>
                {
                    /// The input parameters to give to each regex engine call.
                    input: Input<'h>,
                    /// Records the end offset of the most recent match. This is necessary to
                    last_match_end: Option<usize>,
                }

                impl<'h> Searcher<'h>
                {
                    /// Create a new fallible non-overlapping matches iterator.
                    pub fn new(input: Input<'h>) -> Searcher<'h> {
                        Searcher { input, last_match_end: None }
                    }
                    /// Returns the current `Input` used by this searcher.
                    pub fn input<'s>(&'s self) -> &'s Input<'h> {
                        &self.input
                    }
                    /// Return the next half match for an infallible search if one exists, and
                    #[inline] pub fn advance_half<F>(&mut self, finder: F) -> Option<HalfMatch>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>,
                    {
                        match self.try_advance_half(finder) {
                            Ok(m) => m,
                            Err(err) => panic!(
                                "unexpected regex half find error: {err}\n\
                                to handle find errors, use 'try' or 'search' methods",
                            ),
                        }
                    }
                    /// Return the next match for an infallible search if one exists, and
                    #[inline] pub fn advance<F>(&mut self, finder: F) -> Option<Match>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                    {
                        match self.try_advance(finder) {
                            Ok(m) => m,
                            Err(err) => panic!(
                                "unexpected regex find error: {err}\n\
                                to handle find errors, use 'try' or 'search' methods",
                            ),
                        }
                    }
                    /// Return the next half match for a fallible search if one exists, and
                    #[inline] pub fn try_advance_half<F>
                    (
                        &mut self,
                        mut finder: F,
                    ) -> Result<Option<HalfMatch>, MatchError>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>,
                    {
                        let mut m = match finder(&self.input)? {
                            None => return Ok(None),
                            Some(m) => m,
                        };
                        
                        if Some(m.offset()) == self.last_match_end {
                            m = match self.handle_overlapping_empty_half_match(m, finder)? {
                                None => return Ok(None),
                                Some(m) => m,
                            };
                        }
                        self.input.set_start(m.offset());
                        self.last_match_end = Some(m.offset());
                        Ok(Some(m))
                    }
                    /// Return the next match for a fallible search if one exists, and advance
                    #[inline] pub fn try_advance<F>
                    (
                        &mut self,
                        mut finder: F,
                    ) -> Result<Option<Match>, MatchError>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                    {
                        let mut m = match finder(&self.input)? {
                            None => return Ok(None),
                            Some(m) => m,
                        };
                        
                        if m.is_empty() && Some(m.end()) == self.last_match_end {
                            m = match self.handle_overlapping_empty_match(m, finder)? {
                                None => return Ok(None),
                                Some(m) => m,
                            };
                        }
                        self.input.set_start(m.end());
                        self.last_match_end = Some(m.end());
                        Ok(Some(m))
                    }
                    /// Given a closure that executes a single search, return an iterator over
                    #[inline] pub fn into_half_matches_iter<F>(
                        self,
                        finder: F,
                    ) -> TryHalfMatchesIter<'h, F>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>,
                    {
                        TryHalfMatchesIter { it: self, finder }
                    }
                    /// Given a closure that executes a single search, return an iterator over
                    #[inline] pub fn into_matches_iter<F>(self, finder: F) -> TryMatchesIter<'h, F>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                    {
                        TryMatchesIter { it: self, finder }
                    }
                    /// Given a closure that executes a single search, return an iterator over
                        #[inline] pub fn into_captures_iter<F>(
                        self,
                        caps: Captures,
                        finder: F,
                    ) -> TryCapturesIter<'h, F>
                    where
                        F: FnMut(&Input<'_>, &mut Captures) -> Result<(), MatchError>,
                    {
                        TryCapturesIter { it: self, caps, finder }
                    }
                    /// Handles the special case of a match that begins where the previous
                    #[cold]
                    #[inline(never)]
                    fn handle_overlapping_empty_half_match<F>
                    (
                        &mut self,
                        _: HalfMatch,
                        mut finder: F,
                    ) -> Result<Option<HalfMatch>, MatchError>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>,
                    {
                        self.input.set_start(self.input.start().checked_add(1).unwrap());
                        finder(&self.input)
                    }
                    /// Handles the special case of an empty match by ensuring that 1) the
                    #[cold]
                    #[inline(never)]
                    fn handle_overlapping_empty_match<F>
                    (
                        &mut self,
                        m: Match,
                        mut finder: F,
                    ) -> Result<Option<Match>, MatchError>
                    where
                        F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                    {
                        assert!(m.is_empty());
                        self.input.set_start(self.input.start().checked_add(1).unwrap());
                        finder(&self.input)
                    }
                }
                /// An iterator over all non-overlapping half matches for a fallible search.
                pub struct TryHalfMatchesIter<'h, F> {
                    it: Searcher<'h>,
                    finder: F,
                }

                impl<'h, F> TryHalfMatchesIter<'h, F>
                {
                    /// Return an infallible version of this iterator.
                    pub fn infallible(self) -> HalfMatchesIter<'h, F> {
                        HalfMatchesIter(self)
                    }
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h> {
                        self.it.input()
                    }
                }

                impl<'h, F> Iterator for TryHalfMatchesIter<'h, F> where
                    F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>,
                {
                    type Item = Result<HalfMatch, MatchError>;

                    #[inline]
                    fn next(&mut self) -> Option<Result<HalfMatch, MatchError>> {
                        self.it.try_advance_half(&mut self.finder).transpose()
                    }
                }

                impl<'h, F> ::fmt::Debug for TryHalfMatchesIter<'h, F> {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        f.debug_struct("TryHalfMatchesIter")
                            .field("it", &self.it)
                            .field("finder", &"<closure>")
                            .finish()
                    }
                }
                /// An iterator over all non-overlapping half matches for an infallible search.
                #[derive(Debug)]
                pub struct HalfMatchesIter<'h, F>(TryHalfMatchesIter<'h, F>);

                impl<'h, F> HalfMatchesIter<'h, F>
                {
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h> {
                        self.0.it.input()
                    }
                }

                impl<'h, F> Iterator for HalfMatchesIter<'h, F> where
                    F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>,
                {
                    type Item = HalfMatch;

                    #[inline]
                    fn next(&mut self) -> Option<HalfMatch> {
                        match self.0.next()? {
                            Ok(m) => Some(m),
                            Err(err) => panic!(
                                "unexpected regex half find error: {err}\n\
                                to handle find errors, use 'try' or 'search' methods",
                            ),
                        }
                    }
                }
                /// An iterator over all non-overlapping matches for a fallible search.
                pub struct TryMatchesIter<'h, F> {
                    it: Searcher<'h>,
                    finder: F,
                }

                impl<'h, F> TryMatchesIter<'h, F>
                {
                    /// Return an infallible version of this iterator.
                    pub fn infallible(self) -> MatchesIter<'h, F> {
                        MatchesIter(self)
                    }
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h> {
                        self.it.input()
                    }
                }

                impl<'h, F> Iterator for TryMatchesIter<'h, F> where
                    F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                {
                    type Item = Result<Match, MatchError>;

                    #[inline]
                    fn next(&mut self) -> Option<Result<Match, MatchError>> {
                        self.it.try_advance(&mut self.finder).transpose()
                    }
                }

                impl<'h, F> ::fmt::Debug for TryMatchesIter<'h, F> {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        f.debug_struct("TryMatchesIter")
                            .field("it", &self.it)
                            .field("finder", &"<closure>")
                            .finish()
                    }
                }
                /// An iterator over all non-overlapping matches for an infallible search.
                #[derive(Debug)]
                pub struct MatchesIter<'h, F>(TryMatchesIter<'h, F>);

                impl<'h, F> MatchesIter<'h, F>
                {
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h> {
                        self.0.it.input()
                    }
                }

                impl<'h, F> Iterator for MatchesIter<'h, F> where
                    F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                {
                    type Item = Match;

                    #[inline]
                    fn next(&mut self) -> Option<Match> {
                        match self.0.next()? {
                            Ok(m) => Some(m),
                            Err(err) => panic!(
                                "unexpected regex find error: {err}\n\
                                to handle find errors, use 'try' or 'search' methods",
                            ),
                        }
                    }
                }
                /// An iterator over all non-overlapping captures for a fallible search.
                pub struct TryCapturesIter<'h, F> {
                    it: Searcher<'h>,
                    caps: Captures,
                    finder: F,
                }

                impl<'h, F> TryCapturesIter<'h, F>
                {
                    /// Return an infallible version of this iterator.
                    pub fn infallible(self) -> CapturesIter<'h, F> {
                        CapturesIter(self)
                    }
                }

                impl<'h, F> Iterator for TryCapturesIter<'h, F> where
                    F: FnMut(&Input<'_>, &mut Captures) -> Result<(), MatchError>,
                {
                    type Item = Result<Captures, MatchError>;

                    #[inline]
                    fn next(&mut self) -> Option<Result<Captures, MatchError>> {
                        let TryCapturesIter { ref mut it, ref mut caps, ref mut finder } =
                            *self;
                        let result = it
                            .try_advance(|input| {
                                (finder)(input, caps)?;
                                Ok(caps.get_match())
                            })
                            .transpose()?;
                        match result {
                            Ok(_) => Some(Ok(caps.clone())),
                            Err(err) => Some(Err(err)),
                        }
                    }
                }

                impl<'h, F> ::fmt::Debug for TryCapturesIter<'h, F> {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        f.debug_struct("TryCapturesIter")
                            .field("it", &self.it)
                            .field("caps", &self.caps)
                            .field("finder", &"<closure>")
                            .finish()
                    }
                }
                /// An iterator over all non-overlapping captures for an infallible search.
                #[derive(Debug)]
                pub struct CapturesIter<'h, F>(TryCapturesIter<'h, F>);

                impl<'h, F> Iterator for CapturesIter<'h, F> where
                    F: FnMut(&Input<'_>, &mut Captures) -> Result<(), MatchError>,
                {
                    type Item = Captures;

                    #[inline]
                    fn next(&mut self) -> Option<Captures> {
                        match self.0.next()? {
                            Ok(m) => Some(m),
                            Err(err) => panic!(
                                "unexpected regex captures error: {err}\n\
                                to handle find errors, use 'try' or 'search' methods",
                            ),
                        }
                    }
                }
            }

            pub mod lazy
            {
                /*!
                A lazily initialized value for safe sharing between threads. */
                use ::
                {
                    *,
                };
                /*
                */
                /// A lazily initialized value that implements `Deref` for `T`.
                pub struct Lazy<T, F = fn() -> T>(lazy::Lazy<T, F>);

                impl<T, F> Lazy<T, F>
                {
                    /// Create a new `Lazy` value that is initialized via the given function.
                    pub const fn new(create: F) -> Lazy<T, F> {
                        Lazy(lazy::Lazy::new(create))
                    }
                }

                impl<T, F: Fn() -> T> Lazy<T, F>
                {
                    /// Return a reference to the lazily initialized value.
                    pub fn get(this: &Lazy<T, F>) -> &T {
                        this.0.get()
                    }
                }

                impl<T, F: Fn() -> T> ::ops::Deref for Lazy<T, F>
                {
                    type Target = T;

                    fn deref(&self) -> &T {
                        Lazy::get(self)
                    }
                }

                impl<T: fmt::Debug, F: Fn() -> T> fmt::Debug for Lazy<T, F>
                {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        self.0.fmt(f)
                    }
                }

                mod lazy
                {
                    use ::{
                        fmt,
                        marker::PhantomData,
                        sync::atomic::{AtomicPtr, Ordering},
                    };

                    use ::boxed::Box;
                    /// A non-std lazy initialized value.
                    pub(super) struct Lazy<T, F> {
                        data: AtomicPtr<T>,
                        create: F,
                        owned: PhantomData<Box<T>>,
                    }
                    unsafe impl<T: Send + Sync, F: Send + Sync> Sync for Lazy<T, F> {}

                    impl<T, F> Lazy<T, F> {
                        /// Create a new alloc but non-std lazy value that is racily
                        pub(super) const fn new(create: F) -> Lazy<T, F> {
                            Lazy {
                                data: AtomicPtr::new(::ptr::null_mut()),
                                create,
                                owned: PhantomData,
                            }
                        }
                    }

                    impl<T, F: Fn() -> T> Lazy<T, F> {
                        /// Get the underlying lazy value. If it hasn't been initialized
                        pub(super) fn get(&self) -> &T {
                            if let Some(data) = self.poll() {
                                return data;
                            }
                            let data = (self.create)();
                            let mut ptr = Box::into_raw(Box::new(data));
                            let result = self.data.compare_exchange(
                                ::ptr::null_mut(),
                                ptr,
                                Ordering::AcqRel,
                                Ordering::Acquire,
                            );
                            if let Err(old) = result {
                                drop(unsafe { Box::from_raw(ptr) });
                                ptr = old;
                            }
                            unsafe { &*ptr }
                        }
                        /// If this lazy value has been initialized successfully, then return
                        fn poll(&self) -> Option<&T> {
                            let ptr = self.data.load(Ordering::Acquire);
                            if ptr.is_null() {
                                return None;
                            }
                            Some(unsafe { &*ptr })
                        }
                    }

                    impl<T: fmt::Debug, F: Fn() -> T> fmt::Debug for Lazy<T, F>
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                            f.debug_struct("Lazy").field("data", &self.poll()).finish()
                        }
                    }

                    impl<T, F> Drop for Lazy<T, F>
                    {
                        fn drop(&mut self) {
                            let ptr = *self.data.get_mut();
                            if !ptr.is_null() {
                                drop(unsafe { Box::from_raw(ptr) });
                            }
                        }
                    }
                }
            }

            pub mod look
            {
                /*!
                Types and routines for working with look-around assertions. */
                use ::
                {
                    *,
                };
                /*
                use crate::util::{escape::DebugByte, utf8};
                */
                /// A look-around assertion.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum Look
                {
                    /// Match the beginning of text. Specifically, this matches at the starting
                    Start = 1 << 0,
                    /// Match the end of text. Specifically, this matches at the ending
                    End = 1 << 1,
                    /// Match the beginning of a line or the beginning of text. Specifically,
                    StartLF = 1 << 2,
                    /// Match the end of a line or the end of text. Specifically, this matches
                    EndLF = 1 << 3,
                    /// Match the beginning of a line or the beginning of text. Specifically,
                    StartCRLF = 1 << 4,
                    /// Match the end of a line or the end of text. Specifically, this matches
                    EndCRLF = 1 << 5,
                    /// Match an ASCII-only word boundary. That is, this matches a position
                    WordAscii = 1 << 6,
                    /// Match an ASCII-only negation of a word boundary.
                    WordAsciiNegate = 1 << 7,
                    /// Match a Unicode-aware word boundary. That is, this matches a position
                    WordUnicode = 1 << 8,
                    /// Match a Unicode-aware negation of a word boundary.
                    WordUnicodeNegate = 1 << 9,
                    /// Match the start of an ASCII-only word boundary. That is, this matches a
                    WordStartAscii = 1 << 10,
                    /// Match the end of an ASCII-only word boundary. That is, this matches
                    WordEndAscii = 1 << 11,
                    /// Match the start of a Unicode word boundary. That is, this matches a
                    WordStartUnicode = 1 << 12,
                    /// Match the end of a Unicode word boundary. That is, this matches a
                    WordEndUnicode = 1 << 13,
                    /// Match the start half of an ASCII-only word boundary. That is, this
                    WordStartHalfAscii = 1 << 14,
                    /// Match the end half of an ASCII-only word boundary. That is, this
                    WordEndHalfAscii = 1 << 15,
                    /// Match the start half of a Unicode word boundary. That is, this matches
                    WordStartHalfUnicode = 1 << 16,
                    /// Match the end half of a Unicode word boundary. That is, this matches
                    WordEndHalfUnicode = 1 << 17,
                }

                impl Look
                {
                    /// Flip the look-around assertion to its equivalent for reverse searches.
                    #[inline] pub const fn reversed(self) -> Look {
                        match self {
                            Look::Start => Look::End,
                            Look::End => Look::Start,
                            Look::StartLF => Look::EndLF,
                            Look::EndLF => Look::StartLF,
                            Look::StartCRLF => Look::EndCRLF,
                            Look::EndCRLF => Look::StartCRLF,
                            Look::WordAscii => Look::WordAscii,
                            Look::WordAsciiNegate => Look::WordAsciiNegate,
                            Look::WordUnicode => Look::WordUnicode,
                            Look::WordUnicodeNegate => Look::WordUnicodeNegate,
                            Look::WordStartAscii => Look::WordEndAscii,
                            Look::WordEndAscii => Look::WordStartAscii,
                            Look::WordStartUnicode => Look::WordEndUnicode,
                            Look::WordEndUnicode => Look::WordStartUnicode,
                            Look::WordStartHalfAscii => Look::WordEndHalfAscii,
                            Look::WordEndHalfAscii => Look::WordStartHalfAscii,
                            Look::WordStartHalfUnicode => Look::WordEndHalfUnicode,
                            Look::WordEndHalfUnicode => Look::WordStartHalfUnicode,
                        }
                    }
                    /// Return the underlying representation of this look-around enumeration
                    #[inline] pub const fn as_repr(self) -> u32 {
                        self as u32
                    }
                    /// Given the underlying representation of a `Look` value, return the
                    #[inline] pub const fn from_repr(repr: u32) -> Option<Look> {
                        match repr {
                            0b00_0000_0000_0000_0001 => Some(Look::Start),
                            0b00_0000_0000_0000_0010 => Some(Look::End),
                            0b00_0000_0000_0000_0100 => Some(Look::StartLF),
                            0b00_0000_0000_0000_1000 => Some(Look::EndLF),
                            0b00_0000_0000_0001_0000 => Some(Look::StartCRLF),
                            0b00_0000_0000_0010_0000 => Some(Look::EndCRLF),
                            0b00_0000_0000_0100_0000 => Some(Look::WordAscii),
                            0b00_0000_0000_1000_0000 => Some(Look::WordAsciiNegate),
                            0b00_0000_0001_0000_0000 => Some(Look::WordUnicode),
                            0b00_0000_0010_0000_0000 => Some(Look::WordUnicodeNegate),
                            0b00_0000_0100_0000_0000 => Some(Look::WordStartAscii),
                            0b00_0000_1000_0000_0000 => Some(Look::WordEndAscii),
                            0b00_0001_0000_0000_0000 => Some(Look::WordStartUnicode),
                            0b00_0010_0000_0000_0000 => Some(Look::WordEndUnicode),
                            0b00_0100_0000_0000_0000 => Some(Look::WordStartHalfAscii),
                            0b00_1000_0000_0000_0000 => Some(Look::WordEndHalfAscii),
                            0b01_0000_0000_0000_0000 => Some(Look::WordStartHalfUnicode),
                            0b10_0000_0000_0000_0000 => Some(Look::WordEndHalfUnicode),
                            _ => None,
                        }
                    }
                    /// Returns a convenient single codepoint representation of this
                    #[inline] pub const fn as_char(self) -> char {
                        match self {
                            Look::Start => 'A',
                            Look::End => 'z',
                            Look::StartLF => '^',
                            Look::EndLF => '$',
                            Look::StartCRLF => 'r',
                            Look::EndCRLF => 'R',
                            Look::WordAscii => 'b',
                            Look::WordAsciiNegate => 'B',
                            Look::WordUnicode => '𝛃',
                            Look::WordUnicodeNegate => '𝚩',
                            Look::WordStartAscii => '<',
                            Look::WordEndAscii => '>',
                            Look::WordStartUnicode => '〈',
                            Look::WordEndUnicode => '〉',
                            Look::WordStartHalfAscii => '◁',
                            Look::WordEndHalfAscii => '▷',
                            Look::WordStartHalfUnicode => '◀',
                            Look::WordEndHalfUnicode => '▶',
                        }
                    }
                }
                /// LookSet is a memory-efficient set of look-around assertions.
                #[derive(Clone, Copy, Default, Eq, PartialEq)]
                pub struct LookSet
                {
                    /// The underlying representation this set is exposed to make it possible
                    pub bits: u32,
                }

                impl LookSet
                {
                    /// Create an empty set of look-around assertions.
                    #[inline] pub fn empty() -> LookSet {
                        LookSet { bits: 0 }
                    }
                    /// Create a full set of look-around assertions.
                    #[inline] pub fn full() -> LookSet {
                        LookSet { bits: !0 }
                    }
                    /// Create a look-around set containing the look-around assertion given.
                    #[inline] pub fn singleton(look: Look) -> LookSet {
                        LookSet::empty().insert(look)
                    }
                    /// Returns the total number of look-around assertions in this set.
                    #[inline] pub fn len(self) -> usize {
                        usize::try_from(self.bits.count_ones()).unwrap()
                    }
                    /// Returns true if and only if this set is empty.
                    #[inline] pub fn is_empty(self) -> bool {
                        self.len() == 0
                    }
                    /// Returns true if and only if the given look-around assertion is in this
                    #[inline] pub fn contains(self, look: Look) -> bool {
                        self.bits & look.as_repr() != 0
                    }
                    /// Returns true if and only if this set contains any anchor assertions.
                    #[inline] pub fn contains_anchor(&self) -> bool {
                        self.contains_anchor_haystack() || self.contains_anchor_line()
                    }
                    /// Returns true if and only if this set contains any "start/end of
                    #[inline] pub fn contains_anchor_haystack(&self) -> bool {
                        self.contains(Look::Start) || self.contains(Look::End)
                    }
                    /// Returns true if and only if this set contains any "start/end of line"
                    #[inline] pub fn contains_anchor_line(&self) -> bool {
                        self.contains(Look::StartLF)
                            || self.contains(Look::EndLF)
                            || self.contains(Look::StartCRLF)
                            || self.contains(Look::EndCRLF)
                    }
                    /// Returns true if and only if this set contains any "start/end of line"
                    #[inline] pub fn contains_anchor_lf(&self) -> bool {
                        self.contains(Look::StartLF) || self.contains(Look::EndLF)
                    }
                    /// Returns true if and only if this set contains any "start/end of line"
                    #[inline] pub fn contains_anchor_crlf(&self) -> bool {
                        self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)
                    }
                    /// Returns true if and only if this set contains any word boundary or
                    #[inline] pub fn contains_word(self) -> bool {
                        self.contains_word_unicode() || self.contains_word_ascii()
                    }
                    /// Returns true if and only if this set contains any Unicode word boundary
                    #[inline] pub fn contains_word_unicode(self) -> bool {
                        self.contains(Look::WordUnicode)
                            || self.contains(Look::WordUnicodeNegate)
                            || self.contains(Look::WordStartUnicode)
                            || self.contains(Look::WordEndUnicode)
                            || self.contains(Look::WordStartHalfUnicode)
                            || self.contains(Look::WordEndHalfUnicode)
                    }
                    /// Returns true if and only if this set contains any ASCII word boundary
                    #[inline] pub fn contains_word_ascii(self) -> bool {
                        self.contains(Look::WordAscii)
                            || self.contains(Look::WordAsciiNegate)
                            || self.contains(Look::WordStartAscii)
                            || self.contains(Look::WordEndAscii)
                            || self.contains(Look::WordStartHalfAscii)
                            || self.contains(Look::WordEndHalfAscii)
                    }
                    /// Returns an iterator over all of the look-around assertions in this set.
                    #[inline] pub fn iter(self) -> LookSetIter {
                        LookSetIter { set: self }
                    }
                    /// Return a new set that is equivalent to the original, but with the given
                    #[inline] pub fn insert(self, look: Look) -> LookSet {
                        LookSet { bits: self.bits | look.as_repr() }
                    }
                    /// Updates this set in place with the result of inserting the given
                    #[inline] pub fn set_insert(&mut self, look: Look) {
                        *self = self.insert(look);
                    }
                    /// Return a new set that is equivalent to the original, but with the given
                    #[inline] pub fn remove(self, look: Look) -> LookSet {
                        LookSet { bits: self.bits & !look.as_repr() }
                    }
                    /// Updates this set in place with the result of removing the given
                    #[inline] pub fn set_remove(&mut self, look: Look) {
                        *self = self.remove(look);
                    }
                    /// Returns a new set that is the result of subtracting the given set from
                    #[inline] pub fn subtract(self, other: LookSet) -> LookSet {
                        LookSet { bits: self.bits & !other.bits }
                    }
                    /// Updates this set in place with the result of subtracting the given set
                    #[inline] pub fn set_subtract(&mut self, other: LookSet) {
                        *self = self.subtract(other);
                    }
                    /// Returns a new set that is the union of this and the one given.
                    #[inline] pub fn union(self, other: LookSet) -> LookSet {
                        LookSet { bits: self.bits | other.bits }
                    }
                    /// Updates this set in place with the result of unioning it with the one
                    #[inline] pub fn set_union(&mut self, other: LookSet) {
                        *self = self.union(other);
                    }
                    /// Returns a new set that is the intersection of this and the one given.
                    #[inline] pub fn intersect(self, other: LookSet) -> LookSet {
                        LookSet { bits: self.bits & other.bits }
                    }
                    /// Updates this set in place with the result of intersecting it with the
                    #[inline] pub fn set_intersect(&mut self, other: LookSet) {
                        *self = self.intersect(other);
                    }
                    /// Return a `LookSet` from the slice given as a native endian 32-bit
                    #[inline] pub fn read_repr(slice: &[u8]) -> LookSet {
                        let bits = u32::from_ne_bytes(slice[..4].try_into().unwrap());
                        LookSet { bits }
                    }
                    /// Write a `LookSet` as a native endian 32-bit integer to the beginning
                    #[inline] pub fn write_repr(self, slice: &mut [u8]) {
                        let raw = self.bits.to_ne_bytes();
                        slice[0] = raw[0];
                        slice[1] = raw[1];
                        slice[2] = raw[2];
                        slice[3] = raw[3];
                    }
                    /// Checks that all assertions in this set can be matched.
                    pub fn available(self) -> Result<(), UnicodeWordBoundaryError> {
                        if self.contains_word_unicode() {
                            UnicodeWordBoundaryError::check()?;
                        }
                        Ok(())
                    }
                }

                impl ::fmt::Debug for LookSet {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.is_empty() {
                            return write!(f, "∅");
                        }
                        for look in self.iter() {
                            write!(f, "{}", look.as_char())?;
                        }
                        Ok(())
                    }
                }
                /// An iterator over all look-around assertions in a [`LookSet`].
                #[derive(Clone, Debug)]
                pub struct LookSetIter {
                    set: LookSet,
                }

                impl Iterator for LookSetIter {
                    type Item = Look;

                    #[inline]
                    fn next(&mut self) -> Option<Look> {
                        if self.set.is_empty() {
                            return None;
                        }
                        let bit = u16::try_from(self.set.bits.trailing_zeros()).unwrap();
                        let look = Look::from_repr(1 << bit)?;
                        self.set = self.set.remove(look);
                        Some(look)
                    }
                }
                /// A matcher for look-around assertions.
                #[derive(Clone, Debug)]
                pub struct LookMatcher {
                    lineterm: DebugByte,
                }

                impl LookMatcher
                {
                    /// Creates a new default matcher for look-around assertions.
                    pub fn new() -> LookMatcher {
                        LookMatcher { lineterm: DebugByte(b'\n') }
                    }
                    /// Sets the line terminator for use with `(?m:^)` and `(?m:$)`.
                    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {
                        self.lineterm.0 = byte;
                        self
                    }
                    /// Returns the line terminator that was configured for this matcher.
                    pub fn get_line_terminator(&self) -> u8 {
                        self.lineterm.0
                    }
                    /// Returns true when the position `at` in `haystack` satisfies the given
                    #[inline] pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {
                        self.matches_inline(look, haystack, at)
                    }
                    /// Like `matches`, but forcefully inlined.
                    #[inline( always )]
                    pub fn matches_inline(
                        &self,
                        look: Look,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        match look {
                            Look::Start => self.is_start(haystack, at),
                            Look::End => self.is_end(haystack, at),
                            Look::StartLF => self.is_start_lf(haystack, at),
                            Look::EndLF => self.is_end_lf(haystack, at),
                            Look::StartCRLF => self.is_start_crlf(haystack, at),
                            Look::EndCRLF => self.is_end_crlf(haystack, at),
                            Look::WordAscii => self.is_word_ascii(haystack, at),
                            Look::WordAsciiNegate => self.is_word_ascii_negate(haystack, at),
                            Look::WordUnicode => self.is_word_unicode(haystack, at).unwrap(),
                            Look::WordUnicodeNegate => {
                                self.is_word_unicode_negate(haystack, at).unwrap()
                            }
                            Look::WordStartAscii => self.is_word_start_ascii(haystack, at),
                            Look::WordEndAscii => self.is_word_end_ascii(haystack, at),
                            Look::WordStartUnicode => {
                                self.is_word_start_unicode(haystack, at).unwrap()
                            }
                            Look::WordEndUnicode => {
                                self.is_word_end_unicode(haystack, at).unwrap()
                            }
                            Look::WordStartHalfAscii => {
                                self.is_word_start_half_ascii(haystack, at)
                            }
                            Look::WordEndHalfAscii => {
                                self.is_word_end_half_ascii(haystack, at)
                            }
                            Look::WordStartHalfUnicode => {
                                self.is_word_start_half_unicode(haystack, at).unwrap()
                            }
                            Look::WordEndHalfUnicode => {
                                self.is_word_end_half_unicode(haystack, at).unwrap()
                            }
                        }
                    }
                    /// Returns true when _all_ of the assertions in the given set match at the
                    #[inline] pub fn matches_set(
                        &self,
                        set: LookSet,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        self.matches_set_inline(set, haystack, at)
                    }
                    /// Like `LookSet::matches`, but forcefully inlined for perf.
                    #[inline( always )]
                    pub fn matches_set_inline(
                        &self,
                        set: LookSet,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        if set.contains(Look::Start) {
                            if !self.is_start(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::End) {
                            if !self.is_end(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::StartLF) {
                            if !self.is_start_lf(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::EndLF) {
                            if !self.is_end_lf(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::StartCRLF) {
                            if !self.is_start_crlf(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::EndCRLF) {
                            if !self.is_end_crlf(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordAscii) {
                            if !self.is_word_ascii(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordAsciiNegate) {
                            if !self.is_word_ascii_negate(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordUnicode) {
                            if !self.is_word_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordUnicodeNegate) {
                            if !self.is_word_unicode_negate(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordStartAscii) {
                            if !self.is_word_start_ascii(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordEndAscii) {
                            if !self.is_word_end_ascii(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordStartUnicode) {
                            if !self.is_word_start_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordEndUnicode) {
                            if !self.is_word_end_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordStartHalfAscii) {
                            if !self.is_word_start_half_ascii(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordEndHalfAscii) {
                            if !self.is_word_end_half_ascii(haystack, at) {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordStartHalfUnicode) {
                            if !self.is_word_start_half_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        
                        if set.contains(Look::WordEndHalfUnicode) {
                            if !self.is_word_end_half_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        true
                    }
                    /// Split up the given byte classes into equivalence classes in a way that
                        pub fn add_to_byteset(
                        &self,
                        look: Look,
                        set: &mut crate::util::alphabet::ByteClassSet,
                    ) {
                        match look {
                            Look::Start | Look::End => {}
                            Look::StartLF | Look::EndLF => {
                                set.set_range(self.lineterm.0, self.lineterm.0);
                            }
                            Look::StartCRLF | Look::EndCRLF => {
                                set.set_range(b'\r', b'\r');
                                set.set_range(b'\n', b'\n');
                            }
                            Look::WordAscii
                            | Look::WordAsciiNegate
                            | Look::WordUnicode
                            | Look::WordUnicodeNegate
                            | Look::WordStartAscii
                            | Look::WordEndAscii
                            | Look::WordStartUnicode
                            | Look::WordEndUnicode
                            | Look::WordStartHalfAscii
                            | Look::WordEndHalfAscii
                            | Look::WordStartHalfUnicode
                            | Look::WordEndHalfUnicode => {
                                let iswb = utf8::is_word_byte;
                                let asu8 = |b: u16| u8::try_from(b).unwrap();
                                let mut b1: u16 = 0;
                                let mut b2: u16;
                                while b1 <= 255 {
                                    b2 = b1 + 1;
                                    while b2 <= 255 && iswb(asu8(b1)) == iswb(asu8(b2)) {
                                        b2 += 1;
                                    }
                                    assert!(b2 <= 256);
                                    set.set_range(asu8(b1), asu8(b2.checked_sub(1).unwrap()));
                                    b1 = b2;
                                }
                            }
                        }
                    }
                    /// Returns true when [`Look::Start`] is satisfied `at` the given position
                    #[inline] pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {
                        at == 0
                    }
                    /// Returns true when [`Look::End`] is satisfied `at` the given position in
                    #[inline] pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {
                        at == haystack.len()
                    }
                    /// Returns true when [`Look::StartLF`] is satisfied `at` the given
                    #[inline] pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_start(haystack, at) || haystack[at - 1] == self.lineterm.0
                    }
                    /// Returns true when [`Look::EndLF`] is satisfied `at` the given position
                    #[inline] pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_end(haystack, at) || haystack[at] == self.lineterm.0
                    }
                    /// Returns true when [`Look::StartCRLF`] is satisfied `at` the given
                    #[inline] pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_start(haystack, at)
                            || haystack[at - 1] == b'\n'
                            || (haystack[at - 1] == b'\r'
                                && (at >= haystack.len() || haystack[at] != b'\n'))
                    }
                    /// Returns true when [`Look::EndCRLF`] is satisfied `at` the given
                    #[inline] pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_end(haystack, at)
                            || haystack[at] == b'\r'
                            || (haystack[at] == b'\n'
                                && (at == 0 || haystack[at - 1] != b'\r'))
                    }
                    /// Returns true when [`Look::WordAscii`] is satisfied `at` the given
                    #[inline] pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        word_before != word_after
                    }
                    /// Returns true when [`Look::WordAsciiNegate`] is satisfied `at` the given
                    #[inline] pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {
                        !self.is_word_ascii(haystack, at)
                    }
                    /// Returns true when [`Look::WordUnicode`] is satisfied `at` the given
                    #[inline] pub fn is_word_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = is_word_char::rev(haystack, at)?;
                        let word_after = is_word_char::fwd(haystack, at)?;
                        Ok(word_before != word_after)
                    }
                    /// Returns true when [`Look::WordUnicodeNegate`] is satisfied `at` the
                    #[inline] pub fn is_word_unicode_negate(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = at > 0
                            && match utf8::decode_last(&haystack[..at]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::rev(haystack, at)?,
                            };
                        let word_after = at < haystack.len()
                            && match utf8::decode(&haystack[at..]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::fwd(haystack, at)?,
                            };
                        Ok(word_before == word_after)
                    }
                    /// Returns true when [`Look::WordStartAscii`] is satisfied `at` the given
                    #[inline] pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        !word_before && word_after
                    }
                    /// Returns true when [`Look::WordEndAscii`] is satisfied `at` the given
                    #[inline] pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        word_before && !word_after
                    }
                    /// Returns true when [`Look::WordStartUnicode`] is satisfied `at` the
                    #[inline] pub fn is_word_start_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = is_word_char::rev(haystack, at)?;
                        let word_after = is_word_char::fwd(haystack, at)?;
                        Ok(!word_before && word_after)
                    }
                    /// Returns true when [`Look::WordEndUnicode`] is satisfied `at` the
                    #[inline] pub fn is_word_end_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = is_word_char::rev(haystack, at)?;
                        let word_after = is_word_char::fwd(haystack, at)?;
                        Ok(word_before && !word_after)
                    }
                    /// Returns true when [`Look::WordStartHalfAscii`] is satisfied `at` the
                    #[inline] pub fn is_word_start_half_ascii(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        !word_before
                    }
                    /// Returns true when [`Look::WordEndHalfAscii`] is satisfied `at` the
                    #[inline] pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        !word_after
                    }
                    /// Returns true when [`Look::WordStartHalfUnicode`] is satisfied `at` the
                    #[inline] pub fn is_word_start_half_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = at > 0
                            && match utf8::decode_last(&haystack[..at]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::rev(haystack, at)?,
                            };
                        Ok(!word_before)
                    }
                    /// Returns true when [`Look::WordEndHalfUnicode`] is satisfied `at` the
                    #[inline] pub fn is_word_end_half_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_after = at < haystack.len()
                            && match utf8::decode(&haystack[at..]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::fwd(haystack, at)?,
                            };
                        Ok(!word_after)
                    }
                }

                impl Default for LookMatcher {
                    fn default() -> LookMatcher {
                        LookMatcher::new()
                    }
                }
                /// An error that occurs when the Unicode-aware `\w` class is unavailable.
                #[derive(Clone, Debug)]
                pub struct UnicodeWordBoundaryError(());

                impl UnicodeWordBoundaryError {
                    #[cfg(not(feature = "unicode-word-boundary"))]
                    pub fn new() -> UnicodeWordBoundaryError {
                        UnicodeWordBoundaryError(())
                    }
                    /// Returns an error if and only if Unicode word boundary data is
                    pub fn check() -> Result<(), UnicodeWordBoundaryError> {
                        is_word_char::check()
                    }
                }
                
                impl ::error::Error for UnicodeWordBoundaryError {}

                impl ::fmt::Display for UnicodeWordBoundaryError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        write!(
                            f,
                            "Unicode-aware \\b and \\B are unavailable because the \
                            requisite data tables are missing, please enable the \
                            unicode-word-boundary feature"
                        )
                    }
                }

                /*
                /// A module that looks for word codepoints using lazy DFAs.
                #[cfg(all(
                    feature = "unicode-word-boundary",
                    feature = "syntax",
                    feature = "unicode-perl",
                    feature = "hybrid"
                ))]
                mod is_word_char {
                    use ::vec::Vec;

                    use crate::{
                        hybrid::dfa::{Cache, DFA},
                        nfa::thompson::NFA,
                        util::{lazy::Lazy, pool::Pool, primitives::StateID},
                        Anchored, Input,
                    };

                    pub(super) fn check() -> Result<(), super::UnicodeWordBoundaryError> { Ok(()) }

                    #[inline( always )]
                    pub(super) fn fwd(
                        haystack: &[u8],
                        mut at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        static WORD: Lazy<DFA> = Lazy::new(|| DFA::new(r"\w").unwrap());
                        static CACHE: Lazy<Pool<Cache>> =
                            Lazy::new(|| Pool::new(|| WORD.create_cache()));
                        let dfa = Lazy::get(&WORD);
                        let mut cache = Lazy::get(&CACHE).get();
                        let mut sid = dfa
                            .start_state_forward(
                                &mut cache,
                                &Input::new("").anchored(Anchored::Yes),
                            )
                            .unwrap();
                        while at < haystack.len() {
                            let byte = haystack[at];
                            sid = dfa.next_state(&mut cache, sid, byte).unwrap();
                            at += 1;
                            if sid.is_tagged()
                            {
                                if sid.is_match() {
                                    return Ok(true);
                                } else if sid.is_dead() {
                                    return Ok(false);
                                }
                            }
                        }
                        Ok(dfa.next_eoi_state(&mut cache, sid).unwrap().is_match())
                    }

                    #[inline( always )]
                    pub(super) fn rev(
                        haystack: &[u8],
                        mut at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        static WORD: Lazy<DFA> = Lazy::new(|| {
                            DFA::builder()
                                .thompson(NFA::config().reverse(true))
                                .build(r"\w")
                                .unwrap()
                        });
                        static CACHE: Lazy<Pool<Cache>> =
                            Lazy::new(|| Pool::new(|| WORD.create_cache()));
                        let dfa = Lazy::get(&WORD);
                        let mut cache = Lazy::get(&CACHE).get();
                        let mut sid = dfa
                            .start_state_reverse(
                                &mut cache,
                                &Input::new("").anchored(Anchored::Yes),
                            )
                            .unwrap();
                        while at > 0 {
                            at -= 1;
                            let byte = haystack[at];
                            sid = dfa.next_state(&mut cache, sid, byte).unwrap();
                            if sid.is_tagged()
                            {
                                if sid.is_match() {
                                    return Ok(true);
                                } else if sid.is_dead() {
                                    return Ok(false);
                                }
                            }
                        }
                        Ok(dfa.next_eoi_state(&mut cache, sid).unwrap().is_match())
                    }
                }
                */

                /*
                /// A module that looks for word codepoints using fully compiled DFAs.
                #[cfg(all(
                    feature = "unicode-word-boundary",
                    feature = "syntax",
                    feature = "unicode-perl",
                    feature = "dfa-build"
                ))]
                mod is_word_char {
                    use ::vec::Vec;

                    use crate::{
                        dfa::{dense::DFA, Automaton, StartKind},
                        nfa::thompson::NFA,
                        util::{lazy::Lazy, primitives::StateID},
                        Anchored, Input,
                    };

                    pub(super) fn check() -> Result<(), super::UnicodeWordBoundaryError> { Ok(()) }

                    #[inline( always )]
                    pub(super) fn fwd(
                        haystack: &[u8],
                        mut at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        static WORD: Lazy<(DFA<Vec<u32>>, StateID)> = Lazy::new(|| {
                            let dfa = DFA::builder()
                                .configure(DFA::config().start_kind(StartKind::Anchored))
                                .build(r"\w")
                                .unwrap();
                            // OK because our regex has no look-around.
                            let start_id = dfa.universal_start_state(Anchored::Yes).unwrap();
                            (dfa, start_id)
                        });
                        let &(ref dfa, mut sid) = Lazy::get(&WORD);
                        while at < haystack.len() {
                            let byte = haystack[at];
                            sid = dfa.next_state(sid, byte);
                            at += 1;
                            if dfa.is_special_state(sid) {
                                if dfa.is_match_state(sid) {
                                    return Ok(true);
                                } else if dfa.is_dead_state(sid) {
                                    return Ok(false);
                                }
                            }
                        }
                        Ok(dfa.is_match_state(dfa.next_eoi_state(sid)))
                    }

                    #[inline( always )]
                    pub(super) fn rev(
                        haystack: &[u8],
                        mut at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        static WORD: Lazy<(DFA<Vec<u32>>, StateID)> = Lazy::new(|| {
                            let dfa = DFA::builder()
                                .configure(DFA::config().start_kind(StartKind::Anchored))
                                .thompson(NFA::config().reverse(true).shrink(false))
                                .build(r"\w")
                                .unwrap();
                            // OK because our regex has no look-around.
                            let start_id = dfa.universal_start_state(Anchored::Yes).unwrap();
                            (dfa, start_id)
                        });
                        let &(ref dfa, mut sid) = Lazy::get(&WORD);
                        while at > 0 {
                            at -= 1;
                            let byte = haystack[at];
                            sid = dfa.next_state(sid, byte);
                            if dfa.is_special_state(sid) {
                                if dfa.is_match_state(sid) {
                                    return Ok(true);
                                } else if dfa.is_dead_state(sid) {
                                    return Ok(false);
                                }
                            }
                        }
                        Ok(dfa.is_match_state(dfa.next_eoi_state(sid)))
                    }
                }
                */

                /// A module that looks for word codepoints using regex-syntax's data tables.
                #[cfg(all(
                    feature = "unicode-word-boundary",
                    feature = "syntax",
                    feature = "unicode-perl",
                ))]
                mod is_word_char {
                    use regex_syntax::try_is_word_character;

                    use crate::util::utf8;

                    pub(super) fn check() -> Result<(), super::UnicodeWordBoundaryError> { Ok(()) }

                    #[inline( always )]
                    pub(super) fn fwd(
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Ok(match utf8::decode(&haystack[at..]) {
                            None | Some(Err(_)) => false,
                            Some(Ok(ch)) => try_is_word_character(ch).expect(
                                "since unicode-word-boundary, syntax and unicode-perl \
                                are all enabled, it is expected that \
                                try_is_word_character succeeds",
                            ),
                        })
                    }

                    #[inline( always )]
                    pub(super) fn rev(
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Ok(match utf8::decode_last(&haystack[..at]) {
                            None | Some(Err(_)) => false,
                            Some(Ok(ch)) => try_is_word_character(ch).expect(
                                "since unicode-word-boundary, syntax and unicode-perl \
                                are all enabled, it is expected that \
                                try_is_word_character succeeds",
                            ),
                        })
                    }
                }
                /// A module that looks for word codepoints using regex-automata's data tables
                #[cfg(all(
                    feature = "unicode-word-boundary",
                    not(all(feature = "syntax", feature = "unicode-perl")),
                ))]
                mod is_word_char {
                    use crate::util::utf8;

                    pub(super) fn check() -> Result<(), super::UnicodeWordBoundaryError> { Ok(()) }

                    #[inline( always )]
                    pub(super) fn fwd(
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Ok(match utf8::decode(&haystack[at..]) {
                            None | Some(Err(_)) => false,
                            Some(Ok(ch)) => is_word_character(ch),
                        })
                    }

                    #[inline( always )]
                    pub(super) fn rev(
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Ok(match utf8::decode_last(&haystack[..at]) {
                            None | Some(Err(_)) => false,
                            Some(Ok(ch)) => is_word_character(ch),
                        })
                    }
                }
                /// A module that always returns an error if Unicode word boundaries are
                #[cfg(not(feature = "unicode-word-boundary"))]
                mod is_word_char {
                    pub(super) fn check() -> Result<(), super::UnicodeWordBoundaryError> {
                        Err(super::UnicodeWordBoundaryError::new())
                    }

                    #[inline( always )]
                    pub(super) fn fwd(
                        _bytes: &[u8],
                        _at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Err(super::UnicodeWordBoundaryError::new())
                    }

                    #[inline( always )]
                    pub(super) fn rev(
                        _bytes: &[u8],
                        _at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Err(super::UnicodeWordBoundaryError::new())
                    }
                }
            }

            pub mod pool
            {
                /*!
                This module provides a relatively simple thread-safe pool of reusable objects.*/
                use ::
                {
                    *,
                };
                /*
                */
                /// A thread safe pool that works in an `alloc`-only context.
                pub struct Pool<T, F = fn() -> T>(alloc::boxed::Box<inner::Pool<T, F>>);

                impl<T, F> Pool<T, F>
                {
                    /// Create a new pool. The given closure is used to create values in
                    pub fn new(create: F) -> Pool<T, F> {
                        Pool(alloc::boxed::Box::new(inner::Pool::new(create)))
                    }
                }

                impl<T: Send, F: Fn() -> T> Pool<T, F>
                {
                    /// Get a value from the pool. The caller is guaranteed to have
                    #[inline] pub fn get(&self) -> PoolGuard<'_, T, F> {
                        PoolGuard(self.0.get())
                    }
                }

                impl<T: ::fmt::Debug, F> ::fmt::Debug for Pool<T, F> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        f.debug_tuple("Pool").field(&self.0).finish()
                    }
                }
                /// A guard that is returned when a caller requests a value from the pool.
                pub struct PoolGuard<'a, T: Send, F: Fn() -> T>(inner::PoolGuard<'a, T, F>);

                impl<'a, T: Send, F: Fn() -> T> PoolGuard<'a, T, F>
                {
                    /// Consumes this guard and puts it back into the pool.
                    #[inline] pub fn put(this: PoolGuard<'_, T, F>) {
                        inner::PoolGuard::put(this.0);
                    }
                }

                impl<'a, T: Send, F: Fn() -> T> ::ops::Deref for PoolGuard<'a, T, F> {
                    type Target = T;

                    #[inline]
                    fn deref(&self) -> &T {
                        self.0.value()
                    }
                }

                impl<'a, T: Send, F: Fn() -> T> ::ops::DerefMut for PoolGuard<'a, T, F> {
                    #[inline]
                    fn deref_mut(&mut self) -> &mut T {
                        self.0.value_mut()
                    }
                }

                impl<'a, T: Send + ::fmt::Debug, F: Fn() -> T> ::fmt::Debug
                    for PoolGuard<'a, T, F>
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        f.debug_tuple("PoolGuard").field(&self.0).finish()
                    }
                }
                
                mod inner {
                    use ::{
                        cell::UnsafeCell,
                        panic::{RefUnwindSafe, UnwindSafe},
                        sync::atomic::{AtomicUsize, Ordering},
                    };

                    use ::{boxed::Box, vec, vec::Vec};

                    use std::{sync::Mutex, thread_local};
                    /// An atomic counter used to allocate thread IDs.
                    static COUNTER: AtomicUsize = AtomicUsize::new(3);
                    /// A thread ID indicating that there is no owner. This is the initial
                    static THREAD_ID_UNOWNED: usize = 0;
                    /// A thread ID indicating that the special owner value is in use and not
                    static THREAD_ID_INUSE: usize = 1;
                    /// This sentinel is used to indicate that a guard has already been dropped
                    static THREAD_ID_DROPPED: usize = 2;
                    /// The number of stacks we use inside of the pool. These are only used for
                    const MAX_POOL_STACKS: usize = 8;

                    thread_local!(
                        /// A thread local used to assign an ID to a thread.
                        static THREAD_ID: usize = {
                            let next = COUNTER.fetch_add(1, Ordering::Relaxed);
                            if next == 0 {
                                panic!("regex: thread ID allocation space exhausted");
                            }
                            next
                        };
                    );
                    /// This puts each stack in the pool below into its own cache line. This is
                    #[derive(Debug)]
                    #[repr(C, align(64))]
                    struct CacheLine<T>(T);
                    /// A thread safe pool utilizing std-only features.
                    pub(super) struct Pool<T, F> {
                        /// A function to create more T values when stack is empty and a caller
                        create: F,
                        /// Multiple stacks of T values to hand out. These are used when a Pool
                        stacks: Vec<CacheLine<Mutex<Vec<Box<T>>>>>,
                        /// The ID of the thread that owns this pool. The owner is the thread
                        owner: AtomicUsize,
                        /// A value to return when the caller is in the same thread that
                        owner_val: UnsafeCell<Option<T>>,
                    }
                    unsafe impl<T: Send, F: Send + Sync> Sync for Pool<T, F> {}
                    impl<T: UnwindSafe, F: UnwindSafe + RefUnwindSafe> UnwindSafe for Pool<T, F> {}
                    impl<T: UnwindSafe, F: UnwindSafe + RefUnwindSafe> RefUnwindSafe
                        for Pool<T, F>
                    {
                    }

                    impl<T, F> Pool<T, F> {
                        /// Create a new pool. The given closure is used to create values in
                        pub(super) fn new(create: F) -> Pool<T, F> {
                            let mut stacks = Vec::with_capacity(MAX_POOL_STACKS);
                            for _ in 0..stacks.capacity() {
                                stacks.push(CacheLine(Mutex::new(vec![])));
                            }
                            let owner = AtomicUsize::new(THREAD_ID_UNOWNED);
                            let owner_val = UnsafeCell::new(None); // init'd on first access
                            Pool { create, stacks, owner, owner_val }
                        }
                    }

                    impl<T: Send, F: Fn() -> T> Pool<T, F> {
                        /// Get a value from the pool. This may block if another thread is also
                        #[inline]
                        pub(super) fn get(&self) -> PoolGuard<'_, T, F> {
                            let caller = THREAD_ID.with(|id| *id);
                            let owner = self.owner.load(Ordering::Acquire);
                            if caller == owner {
                                self.owner.store(THREAD_ID_INUSE, Ordering::Release);
                                return self.guard_owned(caller);
                            }
                            self.get_slow(caller, owner)
                        }
                        /// This is the "slow" version that goes through a mutex to pop an
                        #[cold]
                        fn get_slow(
                            &self,
                            caller: usize,
                            owner: usize,
                        ) -> PoolGuard<'_, T, F> {
                            if owner == THREAD_ID_UNOWNED {
                                let res = self.owner.compare_exchange(
                                    THREAD_ID_UNOWNED,
                                    THREAD_ID_INUSE,
                                    Ordering::AcqRel,
                                    Ordering::Acquire,
                                );
                                
                                if res.is_ok() {
                                    unsafe {
                                        *self.owner_val.get() = Some((self.create)());
                                    }
                                    return self.guard_owned(caller);
                                }
                            }
                            let stack_id = caller % self.stacks.len();
                            for _ in 0..1 {
                                let mut stack = match self.stacks[stack_id].0.try_lock() {
                                    Err(_) => continue,
                                    Ok(stack) => stack,
                                };
                                
                                if let Some(value) = stack.pop() {
                                    return self.guard_stack(value);
                                }
                                drop(stack);
                                let value = Box::new((self.create)());
                                return self.guard_stack(value);
                            }
                            self.guard_stack_transient(Box::new((self.create)()))
                        }
                        /// Puts a value back into the pool. Callers don't need to call this.
                        #[inline]
                        fn put_value(&self, value: Box<T>) {
                            let caller = THREAD_ID.with(|id| *id);
                            let stack_id = caller % self.stacks.len();
                            for _ in 0..10 {
                                let mut stack = match self.stacks[stack_id].0.try_lock() {
                                    Err(_) => continue,
                                    Ok(stack) => stack,
                                };
                                stack.push(value);
                                return;
                            }
                        }
                        /// Create a guard that represents the special owned T.
                        #[inline]
                        fn guard_owned(&self, caller: usize) -> PoolGuard<'_, T, F> {
                            PoolGuard { pool: self, value: Err(caller), discard: false }
                        }
                        /// Create a guard that contains a value from the pool's stack.
                        #[inline]
                        fn guard_stack(&self, value: Box<T>) -> PoolGuard<'_, T, F> {
                            PoolGuard { pool: self, value: Ok(value), discard: false }
                        }
                        /// Create a guard that contains a value from the pool's stack with an
                        #[inline]
                        fn guard_stack_transient(&self, value: Box<T>) -> PoolGuard<'_, T, F> {
                            PoolGuard { pool: self, value: Ok(value), discard: true }
                        }
                    }

                    impl<T: ::fmt::Debug, F> ::fmt::Debug for Pool<T, F>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                            f.debug_struct("Pool")
                                .field("stacks", &self.stacks)
                                .field("owner", &self.owner)
                                .field("owner_val", &self.owner_val)
                                .finish()
                        }
                    }
                    /// A guard that is returned when a caller requests a value from the pool.
                    pub(super) struct PoolGuard<'a, T: Send, F: Fn() -> T> {
                        /// The pool that this guard is attached to.
                        pool: &'a Pool<T, F>,
                        /// This is Err when the guard represents the special "owned" value.
                        value: Result<Box<T>, usize>,
                        /// When true, the value should be discarded instead of being pushed
                        discard: bool,
                    }

                    impl<'a, T: Send, F: Fn() -> T> PoolGuard<'a, T, F> {
                        /// Return the underlying value.
                        #[inline]
                        pub(super) fn value(&self) -> &T {
                            match self.value {
                                Ok(ref v) => v,
                                Err(id) => unsafe {
                                    debug_assert_ne!(THREAD_ID_DROPPED, id);
                                    (*self.pool.owner_val.get()).as_ref().unwrap_unchecked()
                                },
                            }
                        }
                        /// Return the underlying value as a mutable borrow.
                        #[inline]
                        pub(super) fn value_mut(&mut self) -> &mut T {
                            match self.value {
                                Ok(ref mut v) => v,
                                Err(id) => unsafe {
                                    debug_assert_ne!(THREAD_ID_DROPPED, id);
                                    (*self.pool.owner_val.get()).as_mut().unwrap_unchecked()
                                },
                            }
                        }
                        /// Consumes this guard and puts it back into the pool.
                        #[inline]
                        pub(super) fn put(this: PoolGuard<'_, T, F>) {
                            let mut this = ::mem::ManuallyDrop::new(this);
                            this.put_imp();
                        }
                        /// Puts this guard back into the pool by only borrowing the guard as
                        #[inline(always)]
                        fn put_imp(&mut self) {
                            match ::mem::replace(&mut self.value, Err(THREAD_ID_DROPPED)) {
                                Ok(value) => {
                                    if self.discard {
                                        return;
                                    }
                                    self.pool.put_value(value);
                                }
                                Err(owner) => {
                                    assert_ne!(THREAD_ID_DROPPED, owner);
                                    self.pool.owner.store(owner, Ordering::Release);
                                }
                            }
                        }
                    }

                    impl<'a, T: Send, F: Fn() -> T> Drop for PoolGuard<'a, T, F> {
                        #[inline]
                        fn drop(&mut self) {
                            self.put_imp();
                        }
                    }

                    impl<'a, T: Send + ::fmt::Debug, F: Fn() -> T> ::fmt::Debug
                        for PoolGuard<'a, T, F>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            f.debug_struct("PoolGuard")
                                .field("pool", &self.pool)
                                .field("value", &self.value)
                                .finish()
                        }
                    }
                }
            }

            pub mod prefilter
            {
                /*!
                Defines a prefilter for accelerating regex searches. */
                use ::
                {
                    *,
                };
                /*
                use ::{
                    borrow::Borrow,
                    fmt::Debug,
                    panic::{RefUnwindSafe, UnwindSafe},
                };

                use ::sync::Arc;

                #[cfg(feature = "syntax")]
                use regex_syntax::hir::{literal, Hir};

                use crate::util::search::{MatchKind, Span};

                pub use crate::util::prefilter::{
                    aho_corasick::AhoCorasick,
                    byteset::ByteSet,
                    memchr::{Memchr, Memchr2, Memchr3},
                    memmem::Memmem,
                    teddy::Teddy,
                };
                */
                pub mod aho_corasick
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct AhoCorasick {
                        #[cfg(not(feature = "perf-literal-multisubstring"))]
                        _unused: (),
                        #[cfg(feature = "perf-literal-multisubstring")]
                        ac: aho_corasick::AhoCorasick,
                    }

                    impl AhoCorasick {
                        pub fn new<B: AsRef<[u8]>>(
                            kind: MatchKind,
                            needles: &[B],
                        ) -> Option<AhoCorasick> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                None
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                let ac_match_kind = match kind {
                                    MatchKind::LeftmostFirst | MatchKind::All => {
                                        aho_corasick::MatchKind::LeftmostFirst
                                    }
                                };
                                let ac_kind = if needles.len() <= 500 {
                                    aho_corasick::AhoCorasickKind::DFA
                                } else {
                                    aho_corasick::AhoCorasickKind::ContiguousNFA
                                };
                                let result = aho_corasick::AhoCorasick::builder()
                                    .kind(Some(ac_kind))
                                    .match_kind(ac_match_kind)
                                    .start_kind(aho_corasick::StartKind::Both)
                                    .prefilter(false)
                                    .build(needles);
                                let ac = match result {
                                    Ok(ac) => ac,
                                    Err(_err) => {
                                        debug!("aho-corasick prefilter failed to build: {_err}");
                                        return None;
                                    }
                                };
                                Some(AhoCorasick { ac })
                            }
                        }
                    }

                    impl PrefilterI for AhoCorasick {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                let input =
                                    aho_corasick::Input::new(haystack).span(span.start..span.end);
                                self.ac
                                    .find(input)
                                    .map(|m| Span { start: m.start(), end: m.end() })
                            }
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                let input = aho_corasick::Input::new(haystack)
                                    .anchored(aho_corasick::Anchored::Yes)
                                    .span(span.start..span.end);
                                self.ac
                                    .find(input)
                                    .map(|m| Span { start: m.start(), end: m.end() })
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                self.ac.memory_usage()
                            }
                        }

                        fn is_fast(&self) -> bool {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                false
                            }
                        }
                    }
                }
                
                pub mod byteset
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct ByteSet([bool; 256]);

                    impl ByteSet {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<ByteSet> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                None
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                let mut set = [false; 256];
                                for needle in needles.iter() {
                                    let needle = needle.as_ref();
                                    if needle.len() != 1 {
                                        return None;
                                    }
                                    set[usize::from(needle[0])] = true;
                                }
                                Some(ByteSet(set))
                            }
                        }
                    }

                    impl PrefilterI for ByteSet {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            haystack[span].iter().position(|&b| self.0[usize::from(b)]).map(|i| {
                                let start = span.start + i;
                                let end = start + 1;
                                Span { start, end }
                            })
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0[usize::from(b)] {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            0
                        }

                        fn is_fast(&self) -> bool {
                            false
                        }
                    }
                }
                
                pub mod memchr
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct Memchr(u8);

                    impl Memchr {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memchr> {
                            #[cfg(not(feature = "perf-literal-substring"))]
                            {
                                None
                            }
                            #[cfg(feature = "perf-literal-substring")]
                            {
                                if needles.len() != 1 {
                                    return None;
                                }
                                if needles[0].as_ref().len() != 1 {
                                    return None;
                                }
                                Some(Memchr(needles[0].as_ref()[0]))
                            }
                        }
                    }

                    impl PrefilterI for Memchr {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-substring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-substring")]
                            {
                                memchr::memchr(self.0, &haystack[span]).map(|i| {
                                    let start = span.start + i;
                                    let end = start + 1;
                                    Span { start, end }
                                })
                            }
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0 == b {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            0
                        }

                        fn is_fast(&self) -> bool {
                            true
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct Memchr2(u8, u8);

                    impl Memchr2 {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memchr2> {
                            #[cfg(not(feature = "perf-literal-substring"))]
                            {
                                None
                            }
                            #[cfg(feature = "perf-literal-substring")]
                            {
                                if needles.len() != 2 {
                                    return None;
                                }
                                if !needles.iter().all(|n| n.as_ref().len() == 1) {
                                    return None;
                                }
                                let b1 = needles[0].as_ref()[0];
                                let b2 = needles[1].as_ref()[0];
                                Some(Memchr2(b1, b2))
                            }
                        }
                    }

                    impl PrefilterI for Memchr2 {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-substring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-substring")]
                            {
                                memchr::memchr2(self.0, self.1, &haystack[span]).map(|i| {
                                    let start = span.start + i;
                                    let end = start + 1;
                                    Span { start, end }
                                })
                            }
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0 == b || self.1 == b {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            0
                        }

                        fn is_fast(&self) -> bool {
                            true
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct Memchr3(u8, u8, u8);

                    impl Memchr3 {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memchr3> {
                            #[cfg(not(feature = "perf-literal-substring"))]
                            {
                                None
                            }
                            #[cfg(feature = "perf-literal-substring")]
                            {
                                if needles.len() != 3 {
                                    return None;
                                }
                                if !needles.iter().all(|n| n.as_ref().len() == 1) {
                                    return None;
                                }
                                let b1 = needles[0].as_ref()[0];
                                let b2 = needles[1].as_ref()[0];
                                let b3 = needles[2].as_ref()[0];
                                Some(Memchr3(b1, b2, b3))
                            }
                        }
                    }

                    impl PrefilterI for Memchr3 {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-substring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-substring")]
                            {
                                memchr::memchr3(self.0, self.1, self.2, &haystack[span]).map(|i| {
                                    let start = span.start + i;
                                    let end = start + 1;
                                    Span { start, end }
                                })
                            }
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0 == b || self.1 == b || self.2 == b {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            0
                        }

                        fn is_fast(&self) -> bool {
                            true
                        }
                    }
                }
                
                pub mod memmem
                {
                    /*!
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                    #[derive(Clone, Debug)]
                    pub struct Memmem {
                        #[cfg(not(all(feature = "std", feature = "perf-literal-substring")))]
                        _unused: (),
                        #[cfg(all(feature = "std", feature = "perf-literal-substring"))]
                        finder: memchr::memmem::Finder<'static>,
                    }

                    impl Memmem {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memmem> {
                            #[cfg(not(all(feature = "std", feature = "perf-literal-substring")))]
                            {
                                None
                            }
                            #[cfg(all(feature = "std", feature = "perf-literal-substring"))]
                            {
                                if needles.len() != 1 {
                                    return None;
                                }
                                let needle = needles[0].as_ref();
                                let finder = memchr::memmem::Finder::new(needle).into_owned();
                                Some(Memmem { finder })
                            }
                        }
                    }

                    impl PrefilterI for Memmem {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(all(feature = "std", feature = "perf-literal-substring")))]
                            {
                                unreachable!()
                            }
                            #[cfg(all(feature = "std", feature = "perf-literal-substring"))]
                            {
                                self.finder.find(&haystack[span]).map(|i| {
                                    let start = span.start + i;
                                    let end = start + self.finder.needle().len();
                                    Span { start, end }
                                })
                            }
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(all(feature = "std", feature = "perf-literal-substring")))]
                            {
                                unreachable!()
                            }
                            #[cfg(all(feature = "std", feature = "perf-literal-substring"))]
                            {
                                let needle = self.finder.needle();
                                
                                if haystack[span].starts_with(needle) {
                                    Some(Span { end: span.start + needle.len(), ..span })
                                } else {
                                    None
                                }
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            #[cfg(not(all(feature = "std", feature = "perf-literal-substring")))]
                            {
                                unreachable!()
                            }
                            #[cfg(all(feature = "std", feature = "perf-literal-substring"))]
                            {
                                self.finder.needle().len()
                            }
                        }

                        fn is_fast(&self) -> bool {
                            #[cfg(not(all(feature = "std", feature = "perf-literal-substring")))]
                            {
                                unreachable!()
                            }
                            #[cfg(all(feature = "std", feature = "perf-literal-substring"))]
                            {
                                true
                            }
                        }
                    }
                }
                
                pub mod teddy
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct Teddy {
                        #[cfg(not(feature = "perf-literal-multisubstring"))]
                        _unused: (),
                        /// The actual Teddy searcher.
                        #[cfg(feature = "perf-literal-multisubstring")]
                        searcher: aho_corasick::packed::Searcher,
                        /// When running an anchored search, the packed searcher can't handle it so
                        #[cfg(feature = "perf-literal-multisubstring")]
                        anchored_ac: aho_corasick::dfa::DFA,
                        /// The length of the smallest literal we look for.
                        #[cfg(feature = "perf-literal-multisubstring")]
                        minimum_len: usize,
                    }

                    impl Teddy {
                        pub fn new<B: AsRef<[u8]>>(
                            kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Teddy> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                None
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                let (packed_match_kind, ac_match_kind) = match kind {
                                    MatchKind::LeftmostFirst | MatchKind::All => (
                                        aho_corasick::packed::MatchKind::LeftmostFirst,
                                        aho_corasick::MatchKind::LeftmostFirst,
                                    ),
                                };
                                let minimum_len =
                                    needles.iter().map(|n| n.as_ref().len()).min().unwrap_or(0);
                                let packed = aho_corasick::packed::Config::new()
                                    .match_kind(packed_match_kind)
                                    .builder()
                                    .extend(needles)
                                    .build()?;
                                let anchored_ac = aho_corasick::dfa::DFA::builder()
                                    .match_kind(ac_match_kind)
                                    .start_kind(aho_corasick::StartKind::Anchored)
                                    .prefilter(false)
                                    .build(needles)
                                    .ok()?;
                                Some(Teddy { searcher: packed, anchored_ac, minimum_len })
                            }
                        }
                    }

                    impl PrefilterI for Teddy {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                let ac_span =
                                    aho_corasick::Span { start: span.start, end: span.end };
                                self.searcher
                                    .find_in(haystack, ac_span)
                                    .map(|m| Span { start: m.start(), end: m.end() })
                            }
                        }

                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                use aho_corasick::automaton::Automaton;
                                let input = aho_corasick::Input::new(haystack)
                                    .anchored(aho_corasick::Anchored::Yes)
                                    .span(span.start..span.end);
                                self.anchored_ac
                                    .try_find(&input)
                                    // OK because we build the DFA with anchored support.
                                    .expect("aho-corasick DFA should never fail")
                                    .map(|m| Span { start: m.start(), end: m.end() })
                            }
                        }

                        fn memory_usage(&self) -> usize {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                use aho_corasick::automaton::Automaton;
                                self.searcher.memory_usage() + self.anchored_ac.memory_usage()
                            }
                        }

                        fn is_fast(&self) -> bool {
                            #[cfg(not(feature = "perf-literal-multisubstring"))]
                            {
                                unreachable!()
                            }
                            #[cfg(feature = "perf-literal-multisubstring")]
                            {
                                self.minimum_len >= 3
                            }
                        }
                    }
                }
                /// A prefilter for accelerating regex searches.
                #[derive(Clone, Debug)]
                pub struct Prefilter {
                    #[cfg(not(feature = "alloc"))]
                    _unused: (),
                        pre: Arc<dyn PrefilterI>,
                        is_fast: bool,
                        max_needle_len: usize,
                }

                impl Prefilter
                {
                    /// Create a new prefilter from a sequence of needles and a corresponding
                    pub fn new<B: AsRef<[u8]>>(
                        kind: MatchKind,
                        needles: &[B],
                    ) -> Option<Prefilter> {
                        Choice::new(kind, needles).and_then(|choice| {
                            let max_needle_len =
                                needles.iter().map(|b| b.as_ref().len()).max().unwrap_or(0);
                            Prefilter::from_choice(choice, max_needle_len)
                        })
                    }
                    /// This turns a prefilter selection into a `Prefilter`. That is, in turns
                    fn from_choice(
                        choice: Choice,
                        max_needle_len: usize,
                    ) -> Option<Prefilter> {
                        #[cfg(not(feature = "alloc"))]
                        {
                            None
                        }
                                {
                            let pre: Arc<dyn PrefilterI> = match choice {
                                Choice::Memchr(p) => Arc::new(p),
                                Choice::Memchr2(p) => Arc::new(p),
                                Choice::Memchr3(p) => Arc::new(p),
                                Choice::Memmem(p) => Arc::new(p),
                                Choice::Teddy(p) => Arc::new(p),
                                Choice::ByteSet(p) => Arc::new(p),
                                Choice::AhoCorasick(p) => Arc::new(p),
                            };
                            let is_fast = pre.is_fast();
                            Some(Prefilter { pre, is_fast, max_needle_len })
                        }
                    }
                    /// This attempts to extract prefixes from the given `Hir` expression for
                    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {
                        Prefilter::from_hirs_prefix(kind, &[hir])
                    }
                    /// This attempts to extract prefixes from the given `Hir` expressions for
                    pub fn from_hirs_prefix<H: Borrow<Hir>>(
                        kind: MatchKind,
                        hirs: &[H],
                    ) -> Option<Prefilter> {
                        prefixes(kind, hirs)
                            .literals()
                            .and_then(|lits| Prefilter::new(kind, lits))
                    }
                    /// Run this prefilter on `haystack[span.start..end]` and return a matching
                    #[inline] pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                        #[cfg(not(feature = "alloc"))]
                        {
                            unreachable!()
                        }
                                {
                            self.pre.find(haystack, span)
                        }
                    }
                    /// Returns the span of a prefix of `haystack[span.start..span.end]` if
                    #[inline] pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                        #[cfg(not(feature = "alloc"))]
                        {
                            unreachable!()
                        }
                                {
                            self.pre.prefix(haystack, span)
                        }
                    }
                    /// Returns the heap memory, in bytes, used by the underlying prefilter.
                    #[inline] pub fn memory_usage(&self) -> usize {
                        #[cfg(not(feature = "alloc"))]
                        {
                            unreachable!()
                        }
                                {
                            self.pre.memory_usage()
                        }
                    }
                    /// Return the length of the longest needle
                    #[inline] pub fn max_needle_len(&self) -> usize {
                        #[cfg(not(feature = "alloc"))]
                        {
                            unreachable!()
                        }
                                {
                            self.max_needle_len
                        }
                    }
                    /// Implementations might return true here if they believe themselves to
                    #[inline] pub fn is_fast(&self) -> bool {
                        #[cfg(not(feature = "alloc"))]
                        {
                            unreachable!()
                        }
                                {
                            self.is_fast
                        }
                    }
                }
                /// A trait for abstracting over prefilters. Basically, a prefilter is
                pub trait PrefilterI:
                    Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static
               
                {
                    /// Run this prefilter on `haystack[span.start..end]` and return a matching
                    fn find(&self, haystack: &[u8], span: Span) -> Option<Span>;
                    /// Returns the span of a prefix of `haystack[span.start..span.end]` if
                    fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span>;
                    /// Returns the heap memory, in bytes, used by the underlying prefilter.
                    fn memory_usage(&self) -> usize;
                    /// Implementations might return true here if they believe themselves to
                    fn is_fast(&self) -> bool;
                }

                impl<P: PrefilterI + ?Sized> PrefilterI for Arc<P> {
                    #[inline( always )]
                    fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                        (**self).find(haystack, span)
                    }

                    #[inline( always )]
                    fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                        (**self).prefix(haystack, span)
                    }

                    #[inline( always )]
                    fn memory_usage(&self) -> usize {
                        (**self).memory_usage()
                    }

                    #[inline( always )]
                    fn is_fast(&self) -> bool {
                        (&**self).is_fast()
                    }
                }
                /// A type that encapsulates the selection of a prefilter algorithm from a
                #[derive(Clone, Debug)]
                pub enum Choice {
                    Memchr(Memchr),
                    Memchr2(Memchr2),
                    Memchr3(Memchr3),
                    Memmem(Memmem),
                    Teddy(Teddy),
                    ByteSet(ByteSet),
                    AhoCorasick(AhoCorasick),
                }

                impl Choice
                {
                    /// Select what is believed to be the best prefilter algorithm for the
                    pub fn new<B: AsRef<[u8]>>(
                        kind: MatchKind,
                        needles: &[B],
                    ) -> Option<Choice> {
                        if needles.len() == 0 {
                            debug!("prefilter building failed: found empty set of literals");
                            
                            return None;
                        }
                        
                        if needles.iter().any(|n| n.as_ref().is_empty()) {
                            debug!("prefilter building failed: literals match empty string");
                            
                            return None;
                        }
                        
                        if let Some(pre) = Memchr::new(kind, needles) {
                            debug!("prefilter built: memchr");
                            
                            return Some(Choice::Memchr(pre));
                        }
                        
                        if let Some(pre) = Memchr2::new(kind, needles) {
                            debug!("prefilter built: memchr2");
                            
                            return Some(Choice::Memchr2(pre));
                        }
                        
                        if let Some(pre) = Memchr3::new(kind, needles) {
                            debug!("prefilter built: memchr3");
                            
                            return Some(Choice::Memchr3(pre));
                        }
                        
                        if let Some(pre) = Memmem::new(kind, needles) {
                            debug!("prefilter built: memmem");
                            
                            return Some(Choice::Memmem(pre));
                        }
                        
                        if let Some(pre) = Teddy::new(kind, needles) {
                            debug!("prefilter built: teddy");
                            
                            return Some(Choice::Teddy(pre));
                        }
                        
                        if let Some(pre) = ByteSet::new(kind, needles) {
                            debug!("prefilter built: byteset");
                            
                            return Some(Choice::ByteSet(pre));
                        }
                        
                        if let Some(pre) = AhoCorasick::new(kind, needles) {
                            debug!("prefilter built: aho-corasick");
                            
                            return Some(Choice::AhoCorasick(pre));
                        }
                        debug!("prefilter building failed: no strategy could be found");
                        None
                    }
                }
                /// Extracts all of the prefix literals from the given HIR expressions into a
                #[cfg(feature = "syntax")]
                pub fn prefixes<H>(kind: MatchKind, hirs: &[H]) -> literal::Seq where
                    H: ::borrow::Borrow<Hir>,
               
                {
                    let mut extractor = literal::Extractor::new();
                    extractor.kind(literal::ExtractKind::Prefix);

                    let mut prefixes = literal::Seq::empty();
                    
                    for hir in hirs {
                        prefixes.union(&mut extractor.extract(hir.borrow()));
                    }
                    debug!(
                        "prefixes (len={:?}, exact={:?}) extracted before optimization: {:?}",
                        prefixes.len(),
                        prefixes.is_exact(),
                        prefixes
                    );
                    match kind {
                        MatchKind::All => {
                            prefixes.sort();
                            prefixes.dedup();
                        }
                        MatchKind::LeftmostFirst => {
                            prefixes.optimize_for_prefix_by_preference();
                        }
                    }
                    debug!(
                        "prefixes (len={:?}, exact={:?}) extracted after optimization: {:?}",
                        prefixes.len(),
                        prefixes.is_exact(),
                        prefixes
                    );
                    prefixes
                }
                /// Like `prefixes`, but for all suffixes of all matches for the given HIRs.
                #[cfg(feature = "syntax")]
                pub fn suffixes<H>(kind: MatchKind, hirs: &[H]) -> literal::Seq where
                    H: ::borrow::Borrow<Hir>,
               
                {
                    let mut extractor = literal::Extractor::new();
                    extractor.kind(literal::ExtractKind::Suffix);

                    let mut suffixes = literal::Seq::empty();
                    
                    for hir in hirs {
                        suffixes.union(&mut extractor.extract(hir.borrow()));
                    }
                    debug!(
                        "suffixes (len={:?}, exact={:?}) extracted before optimization: {:?}",
                        suffixes.len(),
                        suffixes.is_exact(),
                        suffixes
                    );
                    match kind {
                        MatchKind::All => {
                            suffixes.sort();
                            suffixes.dedup();
                        }
                        MatchKind::LeftmostFirst => {
                            suffixes.optimize_for_suffix_by_preference();
                        }
                    }
                    debug!(
                        "suffixes (len={:?}, exact={:?}) extracted after optimization: {:?}",
                        suffixes.len(),
                        suffixes.is_exact(),
                        suffixes
                    );
                    suffixes
                }
            }

            pub mod primitives
            {
                /*!
                Lower level primitive types that are useful in a variety of circumstances. */
                use ::
                {
                    *,
                };
                /*
                use ::num::NonZeroUsize;

                use ::vec::Vec;

                use crate::util::int::{Usize, U16, U32, U64};
                */
                /// A `usize` that can never be `usize::MAX`.
                #[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]
                #[repr(transparent)]
                pub struct NonMaxUsize(NonZeroUsize);

                impl NonMaxUsize
                {
                    /// Create a new `NonMaxUsize` from the given value.
                    #[inline] pub fn new(value: usize) -> Option<NonMaxUsize> {
                        NonZeroUsize::new(value.wrapping_add(1)).map(NonMaxUsize)
                    }
                    /// Return the underlying `usize` value. The returned value is guaranteed
                    #[inline] pub fn get(self) -> usize {
                        self.0.get().wrapping_sub(1)
                    }
                }
                impl ::fmt::Debug for NonMaxUsize {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "{:?}", self.get())
                    }
                }
                /// A type that represents a "small" index.
                #[derive(
                    Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
                )]
                #[repr(transparent)]
                pub struct SmallIndex(u32);

                impl SmallIndex
                {
                    /// The maximum index value.
                    #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
                    pub const MAX: SmallIndex =
                        // FIXME: Use as_usize() once const functions in traits are stable.
                        SmallIndex::new_unchecked(::i32::MAX as usize - 1);
                    /// The maximum index value.
                    #[cfg(target_pointer_width = "16")]
                    pub const MAX: SmallIndex =
                        SmallIndex::new_unchecked(::isize::MAX - 1);
                    /// The total number of values that can be represented as a small index.
                    pub const LIMIT: usize = SmallIndex::MAX.as_usize() + 1;
                    /// The zero index value.
                    pub const ZERO: SmallIndex = SmallIndex::new_unchecked(0);
                    /// The number of bytes that a single small index uses in memory.
                    pub const SIZE: usize = ::mem::size_of::<SmallIndex>();
                    /// Create a new small index.
                    #[inline] pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> {
                        SmallIndex::try_from(index)
                    }
                    /// Create a new small index without checking whether the given value
                    #[inline] pub const fn new_unchecked(index: usize) -> SmallIndex {
                        // FIXME: Use as_u32() once const functions in traits are stable.
                        SmallIndex(index as u32)
                    }
                    /// Like [`SmallIndex::new`], but panics if the given index is not valid.
                    #[inline] pub fn must(index: usize) -> SmallIndex {
                        SmallIndex::new(index).expect("invalid small index")
                    }
                    /// Return this small index as a `usize`. This is guaranteed to never
                    #[inline] pub const fn as_usize(&self) -> usize {
                        // FIXME: Use as_usize() once const functions in traits are stable.
                        self.0 as usize
                    }
                    /// Return this small index as a `u64`. This is guaranteed to never
                    #[inline] pub const fn as_u64(&self) -> u64 {
                        // FIXME: Use u64::from() once const functions in traits are stable.
                        self.0 as u64
                    }
                    /// Return the internal `u32` of this small index. This is guaranteed to
                    #[inline] pub const fn as_u32(&self) -> u32 {
                        self.0
                    }
                    /// Return the internal `u32` of this small index represented as an `i32`.
                    #[inline] pub const fn as_i32(&self) -> i32 {
                        // This is OK because we guarantee that our max value is <= i32::MAX.
                        self.0 as i32
                    }
                    /// Returns one more than this small index as a usize.
                    #[inline] pub fn one_more(&self) -> usize {
                        self.as_usize() + 1
                    }
                    /// Decode this small index from the bytes given using the native endian
                    #[inline] pub fn from_ne_bytes(
                        bytes: [u8; 4],
                    ) -> Result<SmallIndex, SmallIndexError> {
                        let id = u32::from_ne_bytes(bytes);
                        
                        if id > SmallIndex::MAX.as_u32() {
                            return Err(SmallIndexError { attempted: u64::from(id) });
                        }
                        Ok(SmallIndex::new_unchecked(id.as_usize()))
                    }
                    /// Decode this small index from the bytes given using the native endian
                    #[inline] pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> SmallIndex {
                        SmallIndex::new_unchecked(u32::from_ne_bytes(bytes).as_usize())
                    }
                    /// Return the underlying small index integer as raw bytes in native endian
                    #[inline] pub fn to_ne_bytes(&self) -> [u8; 4] {
                        self.0.to_ne_bytes()
                    }
                }

                impl<T> ::ops::Index<SmallIndex> for [T] {
                    type Output = T;

                    #[inline]
                    fn index(&self, index: SmallIndex) -> &T {
                        &self[index.as_usize()]
                    }
                }

                impl<T> ::ops::IndexMut<SmallIndex> for [T] {
                    #[inline]
                    fn index_mut(&mut self, index: SmallIndex) -> &mut T {
                        &mut self[index.as_usize()]
                    }
                }

                impl<T> ::ops::Index<SmallIndex> for Vec<T> {
                    type Output = T;

                    #[inline]
                    fn index(&self, index: SmallIndex) -> &T {
                        &self[index.as_usize()]
                    }
                }

                impl<T> ::ops::IndexMut<SmallIndex> for Vec<T> {
                    #[inline]
                    fn index_mut(&mut self, index: SmallIndex) -> &mut T {
                        &mut self[index.as_usize()]
                    }
                }

                impl From<u8> for SmallIndex {
                    fn from(index: u8) -> SmallIndex {
                        SmallIndex::new_unchecked(usize::from(index))
                    }
                }

                impl TryFrom<u16> for SmallIndex {
                    type Error = SmallIndexError;

                    fn try_from(index: u16) -> Result<SmallIndex, SmallIndexError> {
                        if u32::from(index) > SmallIndex::MAX.as_u32() {
                            return Err(SmallIndexError { attempted: u64::from(index) });
                        }
                        Ok(SmallIndex::new_unchecked(index.as_usize()))
                    }
                }

                impl TryFrom<u32> for SmallIndex {
                    type Error = SmallIndexError;

                    fn try_from(index: u32) -> Result<SmallIndex, SmallIndexError> {
                        if index > SmallIndex::MAX.as_u32() {
                            return Err(SmallIndexError { attempted: u64::from(index) });
                        }
                        Ok(SmallIndex::new_unchecked(index.as_usize()))
                    }
                }

                impl TryFrom<u64> for SmallIndex {
                    type Error = SmallIndexError;

                    fn try_from(index: u64) -> Result<SmallIndex, SmallIndexError> {
                        if index > SmallIndex::MAX.as_u64() {
                            return Err(SmallIndexError { attempted: index });
                        }
                        Ok(SmallIndex::new_unchecked(index.as_usize()))
                    }
                }

                impl TryFrom<usize> for SmallIndex {
                    type Error = SmallIndexError;

                    fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError> {
                        if index > SmallIndex::MAX.as_usize() {
                            return Err(SmallIndexError { attempted: index.as_u64() });
                        }
                        Ok(SmallIndex::new_unchecked(index))
                    }
                }

                #[cfg(test)]
                impl quickcheck::Arbitrary for SmallIndex {
                    fn arbitrary(gen: &mut quickcheck::Gen) -> SmallIndex {
                        use ::cmp::max;

                        let id = max(i32::MIN + 1, i32::arbitrary(gen)).abs();
                        
                        if id > SmallIndex::MAX.as_i32() {
                            SmallIndex::MAX
                        } else {
                            SmallIndex::new(usize::try_from(id).unwrap()).unwrap()
                        }
                    }
                }
                /// This error occurs when a small index could not be constructed.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct SmallIndexError {
                    attempted: u64,
                }

                impl SmallIndexError
                {
                    /// Returns the value that could not be converted to a small index.
                    pub fn attempted(&self) -> u64 {
                        self.attempted
                    }
                }
                
                impl ::error::Error for SmallIndexError {}

                impl ::fmt::Display for SmallIndexError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(
                            f,
                            "failed to create small index from {:?}, which exceeds {:?}",
                            self.attempted(),
                            SmallIndex::MAX,
                        )
                    }
                }

                #[derive(Clone, Debug)]
                pub struct SmallIndexIter {
                    rng: ::ops::Range<usize>,
                }

                impl Iterator for SmallIndexIter {
                    type Item = SmallIndex;

                    fn next(&mut self) -> Option<SmallIndex> {
                        if self.rng.start >= self.rng.end {
                            return None;
                        }
                        let next_id = self.rng.start + 1;
                        let id = ::mem::replace(&mut self.rng.start, next_id);
                        Some(SmallIndex::new_unchecked(id))
                    }
                }

                macro_rules! index_type_impls {
                    ($name:ident, $err:ident, $iter:ident, $withiter:ident) => {
                        impl $name {
                            /// The maximum value.
                            pub const MAX: $name = $name(SmallIndex::MAX);

                            /// The total number of values that can be represented.
                            pub const LIMIT: usize = SmallIndex::LIMIT;

                            /// The zero value.
                            pub const ZERO: $name = $name(SmallIndex::ZERO);

                            /// The number of bytes that a single value uses in memory.
                            pub const SIZE: usize = SmallIndex::SIZE;

                            /// Create a new value that is represented by a "small index."
                            #[inline]
                            pub fn new(value: usize) -> Result<$name, $err> {
                                SmallIndex::new(value).map($name).map_err($err)
                            }

                            /// Create a new value without checking whether the given argument
                            #[inline]
                            pub const fn new_unchecked(value: usize) -> $name {
                                $name(SmallIndex::new_unchecked(value))
                            }

                            /// Like `new`, but panics if the given value is not valid.
                            #[inline]
                            pub fn must(value: usize) -> $name {
                                $name::new(value).expect(concat!(
                                    "invalid ",
                                    stringify!($name),
                                    " value"
                                ))
                            }

                            /// Return the internal value as a `usize`. This is guaranteed to
                            #[inline]
                            pub const fn as_usize(&self) -> usize {
                                self.0.as_usize()
                            }

                            /// Return the internal value as a `u64`. This is guaranteed to
                            #[inline]
                            pub const fn as_u64(&self) -> u64 {
                                self.0.as_u64()
                            }

                            /// Return the internal value as a `u32`. This is guaranteed to
                            #[inline]
                            pub const fn as_u32(&self) -> u32 {
                                self.0.as_u32()
                            }

                            /// Return the internal value as a i32`. This is guaranteed to
                            #[inline]
                            pub const fn as_i32(&self) -> i32 {
                                self.0.as_i32()
                            }

                            /// Returns one more than this value as a usize.
                            #[inline]
                            pub fn one_more(&self) -> usize {
                                self.0.one_more()
                            }

                            /// Decode this value from the bytes given using the native endian
                            #[inline]
                            pub fn from_ne_bytes(bytes: [u8; 4]) -> Result<$name, $err> {
                                SmallIndex::from_ne_bytes(bytes).map($name).map_err($err)
                            }

                            /// Decode this value from the bytes given using the native endian
                            #[inline]
                            pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> $name {
                                $name(SmallIndex::from_ne_bytes_unchecked(bytes))
                            }

                            /// Return the underlying integer as raw bytes in native endian
                            #[inline]
                            pub fn to_ne_bytes(&self) -> [u8; 4] {
                                self.0.to_ne_bytes()
                            }

                            /// Returns an iterator over all values from 0 up to and not
                            pub fn iter(len: usize) -> $iter {
                                $iter::new(len)
                            }
                        }
                        impl ::fmt::Debug for $name {
                            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                                f.debug_tuple(stringify!($name)).field(&self.as_u32()).finish()
                            }
                        }

                        impl<T> ::ops::Index<$name> for [T] {
                            type Output = T;

                            #[inline]
                            fn index(&self, index: $name) -> &T {
                                &self[index.as_usize()]
                            }
                        }

                        impl<T> ::ops::IndexMut<$name> for [T] {
                            #[inline]
                            fn index_mut(&mut self, index: $name) -> &mut T {
                                &mut self[index.as_usize()]
                            }
                        }

                                impl<T> ::ops::Index<$name> for Vec<T> {
                            type Output = T;

                            #[inline]
                            fn index(&self, index: $name) -> &T {
                                &self[index.as_usize()]
                            }
                        }

                                impl<T> ::ops::IndexMut<$name> for Vec<T> {
                            #[inline]
                            fn index_mut(&mut self, index: $name) -> &mut T {
                                &mut self[index.as_usize()]
                            }
                        }

                        impl From<u8> for $name {
                            fn from(value: u8) -> $name {
                                $name(SmallIndex::from(value))
                            }
                        }

                        impl TryFrom<u16> for $name {
                            type Error = $err;

                            fn try_from(value: u16) -> Result<$name, $err> {
                                SmallIndex::try_from(value).map($name).map_err($err)
                            }
                        }

                        impl TryFrom<u32> for $name {
                            type Error = $err;

                            fn try_from(value: u32) -> Result<$name, $err> {
                                SmallIndex::try_from(value).map($name).map_err($err)
                            }
                        }

                        impl TryFrom<u64> for $name {
                            type Error = $err;

                            fn try_from(value: u64) -> Result<$name, $err> {
                                SmallIndex::try_from(value).map($name).map_err($err)
                            }
                        }

                        impl TryFrom<usize> for $name {
                            type Error = $err;

                            fn try_from(value: usize) -> Result<$name, $err> {
                                SmallIndex::try_from(value).map($name).map_err($err)
                            }
                        }
                        /// This error occurs when a value could not be constructed.
                        #[derive(Clone, Debug, Eq, PartialEq)]
                        pub struct $err(SmallIndexError);

                        impl $err {
                            /// Returns the value that could not be converted to an ID.
                            pub fn attempted(&self) -> u64 {
                                self.0.attempted()
                            }
                        }
                        
                        impl ::error::Error for $err {}

                        impl ::fmt::Display for $err {
                            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                                write!(
                                    f,
                                    "failed to create {} from {:?}, which exceeds {:?}",
                                    stringify!($name),
                                    self.attempted(),
                                    $name::MAX,
                                )
                            }
                        }

                        #[derive(Clone, Debug)]
                        pub struct $iter(SmallIndexIter);

                        impl $iter {
                            fn new(len: usize) -> $iter {
                                assert!(
                                    len <= $name::LIMIT,
                                    "cannot create iterator for {} when number of \
                                    elements exceed {:?}",
                                    stringify!($name),
                                    $name::LIMIT,
                                );
                                $iter(SmallIndexIter { rng: 0..len })
                            }
                        }

                        impl Iterator for $iter {
                            type Item = $name;

                            fn next(&mut self) -> Option<$name> {
                                self.0.next().map($name)
                            }
                        }
                        /// An iterator adapter that is like std::iter::Enumerate, but attaches
                        #[derive(Clone, Debug)]
                        pub struct $withiter<I> {
                            it: I,
                            ids: $iter,
                        }

                        impl<I: Iterator + ExactSizeIterator> $withiter<I> {
                            fn new(it: I) -> $withiter<I> {
                                let ids = $name::iter(it.len());
                                $withiter { it, ids }
                            }
                        }

                        impl<I: Iterator + ExactSizeIterator> Iterator for $withiter<I> {
                            type Item = ($name, I::Item);

                            fn next(&mut self) -> Option<($name, I::Item)> {
                                let item = self.it.next()?;
                                let id = self.ids.next().unwrap();
                                Some((id, item))
                            }
                        }
                    };
                }
                /// The identifier of a regex pattern, represented by a [`SmallIndex`].
                #[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]
                #[repr(transparent)]
                pub struct PatternID(SmallIndex);
                /// The identifier of a finite automaton state, represented by a
                #[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]
                #[repr(transparent)]
                pub struct StateID(SmallIndex);

                index_type_impls!(PatternID, PatternIDError, PatternIDIter, WithPatternIDIter);
                index_type_impls!(StateID, StateIDError, StateIDIter, WithStateIDIter);
                /// A utility trait that defines a couple of adapters for making it convenient
                pub trait IteratorIndexExt: Iterator {
                    fn with_pattern_ids(self) -> WithPatternIDIter<Self>
                    where
                        Self: Sized + ExactSizeIterator,
                    {
                        WithPatternIDIter::new(self)
                    }

                    fn with_state_ids(self) -> WithStateIDIter<Self>
                    where
                        Self: Sized + ExactSizeIterator,
                    {
                        WithStateIDIter::new(self)
                    }
                }

                impl<I: Iterator> IteratorIndexExt for I {}
            }

            pub mod start
            {
                /*!
                Provides helpers for dealing with start state configurations in DFAs. */
                use ::
                {
                    *,
                };
                /*
                use crate::util::{
                    look::LookMatcher,
                    search::{Anchored, Input},
                    wire::{self, DeserializeError, SerializeError},
                };
                */
                /// The configuration used to determine a DFA's start state for a search.
                #[derive(Clone, Debug)]
                pub struct Config {
                    look_behind: Option<u8>,
                    anchored: Anchored,
                }

                impl Config
                {
                    /// Create a new default start configuration.
                    pub fn new() -> Config {
                        Config { anchored: Anchored::No, look_behind: None }
                    }
                    /// A convenience routine for building a start configuration from an
                    pub fn from_input_forward(input: &Input<'_>) -> Config {
                        let look_behind = input
                            .start()
                            .checked_sub(1)
                            .and_then(|i| input.haystack().get(i).copied());
                        Config { look_behind, anchored: input.get_anchored() }
                    }
                    /// A convenience routine for building a start configuration from an
                    pub fn from_input_reverse(input: &Input<'_>) -> Config {
                        let look_behind = input.haystack().get(input.end()).copied();
                        Config { look_behind, anchored: input.get_anchored() }
                    }
                    /// Set the look-behind byte at the start of a search.
                    pub fn look_behind(mut self, byte: Option<u8>) -> Config {
                        self.look_behind = byte;
                        self
                    }
                    /// Set the anchored mode of a search.
                    pub fn anchored(mut self, mode: Anchored) -> Config {
                        self.anchored = mode;
                        self
                    }
                    /// Return the look-behind byte in this configuration, if one exists.
                    pub fn get_look_behind(&self) -> Option<u8> {
                        self.look_behind
                    }
                    /// Return the anchored mode in this configuration.
                    pub fn get_anchored(&self) -> Anchored {
                        self.anchored
                    }
                }
                /// A map from every possible byte value to its corresponding starting
                #[derive(Clone)]
                pub struct StartByteMap {
                    map: [Start; 256],
                }

                impl StartByteMap
                {
                    /// Create a new map from byte values to their corresponding starting
                    pub fn new(lookm: &LookMatcher) -> StartByteMap {
                        let mut map = [Start::NonWordByte; 256];
                        map[usize::from(b'\n')] = Start::LineLF;
                        map[usize::from(b'\r')] = Start::LineCR;
                        map[usize::from(b'_')] = Start::WordByte;

                        let mut byte = b'0';
                        while byte <= b'9' {
                            map[usize::from(byte)] = Start::WordByte;
                            byte += 1;
                        }
                        byte = b'A';
                        while byte <= b'Z' {
                            map[usize::from(byte)] = Start::WordByte;
                            byte += 1;
                        }
                        byte = b'a';
                        while byte <= b'z' {
                            map[usize::from(byte)] = Start::WordByte;
                            byte += 1;
                        }

                        let lineterm = lookm.get_line_terminator();
                        
                        if lineterm != b'\r' && lineterm != b'\n' {
                            map[usize::from(lineterm)] = Start::CustomLineTerminator;
                        }
                        StartByteMap { map }
                    }
                    /// Return the starting configuration for the given look-behind byte.
                    #[inline( always )]
                    pub fn get(&self, byte: u8) -> Start {
                        self.map[usize::from(byte)]
                    }
                    /// Deserializes a byte class map from the given slice. If the slice is of
                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(StartByteMap, usize), DeserializeError> {
                        wire::check_slice_len(slice, 256, "start byte map")?;
                        let mut map = [Start::NonWordByte; 256];
                        for (i, &repr) in slice[..256].iter().enumerate() {
                            map[i] = match Start::from_usize(usize::from(repr)) {
                                Some(start) => start,
                                None => {
                                    return Err(DeserializeError::generic(
                                        "found invalid starting configuration",
                                    ))
                                }
                            };
                        }
                        Ok((StartByteMap { map }, 256))
                    }
                    /// Writes this map to the given byte buffer. if the given buffer is too
                    pub fn write_to(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        let nwrite = self.write_to_len();
                        
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("start byte map"));
                        }
                        for (i, &start) in self.map.iter().enumerate() {
                            dst[i] = start.as_u8();
                        }
                        Ok(nwrite)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize {
                        256
                    }
                }

                impl ::fmt::Debug for StartByteMap {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        use crate::util::escape::DebugByte;

                        write!(f, "StartByteMap{{")?;
                        for byte in 0..=255 {
                            if byte > 0 {
                                write!(f, ", ")?;
                            }
                            let start = self.map[usize::from(byte)];
                            write!(f, "{:?} => {:?}", DebugByte(byte), start)?;
                        }
                        write!(f, "}}")?;
                        Ok(())
                    }
                }
                /// Represents the six possible starting configurations of a DFA search.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum Start
                {
                    /// This occurs when the starting position is not any of the ones below.
                    NonWordByte = 0,
                    /// This occurs when the byte immediately preceding the start of the search
                    WordByte = 1,
                    /// This occurs when the starting position of the search corresponds to the
                    Text = 2,
                    /// This occurs when the byte immediately preceding the start of the search
                    LineLF = 3,
                    /// This occurs when the byte immediately preceding the start of the search
                    LineCR = 4,
                    /// This occurs when a custom line terminator has been set via a
                    CustomLineTerminator = 5,
                }

                impl Start
                {
                    /// Return the starting state corresponding to the given integer. If no
                    pub fn from_usize(n: usize) -> Option<Start> {
                        match n {
                            0 => Some(Start::NonWordByte),
                            1 => Some(Start::WordByte),
                            2 => Some(Start::Text),
                            3 => Some(Start::LineLF),
                            4 => Some(Start::LineCR),
                            5 => Some(Start::CustomLineTerminator),
                            _ => None,
                        }
                    }
                    /// Returns the total number of starting state configurations.
                    pub fn len() -> usize {
                        6
                    }
                    /// Return this starting configuration as `u8` integer. It is guaranteed to
                    #[inline( always )]
                    pub fn as_u8(&self) -> u8 {
                        *self as u8
                    }
                    /// Return this starting configuration as a `usize` integer. It is
                    #[inline( always )]
                    pub fn as_usize(&self) -> usize {
                        usize::from(self.as_u8())
                    }
                }
            }

            pub mod syntax
            {
                /*!
                Utilities for dealing with the syntax of a regular expression. */
                use ::
                {
                    *,
                };
                /*
                use ::{vec, vec::Vec};

                use regex_syntax::{
                    ast,
                    hir::{self, Hir},
                    Error, ParserBuilder,
                };
                */
                /// A convenience routine for parsing a pattern into an HIR value with the
                pub fn parse(pattern: &str) -> Result<Hir, Error> {
                    parse_with(pattern, &Config::default())
                }
                /// A convenience routine for parsing many patterns into HIR value with the
                pub fn parse_many<P: AsRef<str>>(patterns: &[P]) -> Result<Vec<Hir>, Error> {
                    parse_many_with(patterns, &Config::default())
                }
                /// A convenience routine for parsing a pattern into an HIR value using a
                pub fn parse_with(pattern: &str, config: &Config) -> Result<Hir, Error>
                {
                    let mut builder = ParserBuilder::new();
                    config.apply(&mut builder);
                    builder.build().parse(pattern)
                }
                /// A convenience routine for parsing many patterns into HIR values using a
                pub fn parse_many_with<P: AsRef<str>>(
                    patterns: &[P],
                    config: &Config,
                ) -> Result<Vec<Hir>, Error>
                {
                    let mut builder = ParserBuilder::new();
                    config.apply(&mut builder);
                    let mut hirs = vec![];
                    
                    for p in patterns.iter() {
                        hirs.push(builder.build().parse(p.as_ref())?);
                    }
                    Ok(hirs)
                }
                /// A common set of configuration options that apply to the syntax of a regex.
                #[derive(Clone, Copy, Debug)]
                pub struct Config {
                    case_insensitive: bool,
                    multi_line: bool,
                    dot_matches_new_line: bool,
                    crlf: bool,
                    line_terminator: u8,
                    swap_greed: bool,
                    ignore_whitespace: bool,
                    unicode: bool,
                    utf8: bool,
                    nest_limit: u32,
                    octal: bool,
                }

                impl Config
                {
                    /// Return a new default syntax configuration.
                    pub fn new() -> Config {
                        // These defaults match the ones used in regex-syntax.
                        Config {
                            case_insensitive: false,
                            multi_line: false,
                            dot_matches_new_line: false,
                            crlf: false,
                            line_terminator: b'\n',
                            swap_greed: false,
                            ignore_whitespace: false,
                            unicode: true,
                            utf8: true,
                            nest_limit: 250,
                            octal: false,
                        }
                    }
                    /// Enable or disable the case insensitive flag by default.
                    pub fn case_insensitive(mut self, yes: bool) -> Config {
                        self.case_insensitive = yes;
                        self
                    }
                    /// Enable or disable the multi-line matching flag by default.
                    pub fn multi_line(mut self, yes: bool) -> Config {
                        self.multi_line = yes;
                        self
                    }
                    /// Enable or disable the "dot matches any character" flag by default.
                    pub fn dot_matches_new_line(mut self, yes: bool) -> Config {
                        self.dot_matches_new_line = yes;
                        self
                    }
                    /// Enable or disable the "CRLF mode" flag by default.
                    pub fn crlf(mut self, yes: bool) -> Config {
                        self.crlf = yes;
                        self
                    }
                    /// Sets the line terminator for use with `(?u-s:.)` and `(?-us:.)`.
                    pub fn line_terminator(mut self, byte: u8) -> Config {
                        self.line_terminator = byte;
                        self
                    }
                    /// Enable or disable the "swap greed" flag by default.
                    pub fn swap_greed(mut self, yes: bool) -> Config {
                        self.swap_greed = yes;
                        self
                    }
                    /// Enable verbose mode in the regular expression.
                    pub fn ignore_whitespace(mut self, yes: bool) -> Config {
                        self.ignore_whitespace = yes;
                        self
                    }
                    /// Enable or disable the Unicode flag (`u`) by default.
                    pub fn unicode(mut self, yes: bool) -> Config {
                        self.unicode = yes;
                        self
                    }
                    /// When disabled, the builder will permit the construction of a regular
                    pub fn utf8(mut self, yes: bool) -> Config {
                        self.utf8 = yes;
                        self
                    }
                    /// Set the nesting limit used for the regular expression parser.
                    pub fn nest_limit(mut self, limit: u32) -> Config {
                        self.nest_limit = limit;
                        self
                    }
                    /// Whether to support octal syntax or not.
                    pub fn octal(mut self, yes: bool) -> Config {
                        self.octal = yes;
                        self
                    }
                    /// Returns whether "unicode" mode is enabled.
                    pub fn get_unicode(&self) -> bool {
                        self.unicode
                    }
                    /// Returns whether "case insensitive" mode is enabled.
                    pub fn get_case_insensitive(&self) -> bool {
                        self.case_insensitive
                    }
                    /// Returns whether "multi line" mode is enabled.
                    pub fn get_multi_line(&self) -> bool {
                        self.multi_line
                    }
                    /// Returns whether "dot matches new line" mode is enabled.
                    pub fn get_dot_matches_new_line(&self) -> bool {
                        self.dot_matches_new_line
                    }
                    /// Returns whether "CRLF" mode is enabled.
                    pub fn get_crlf(&self) -> bool {
                        self.crlf
                    }
                    /// Returns the line terminator in this syntax configuration.
                    pub fn get_line_terminator(&self) -> u8 {
                        self.line_terminator
                    }
                    /// Returns whether "swap greed" mode is enabled.
                    pub fn get_swap_greed(&self) -> bool {
                        self.swap_greed
                    }
                    /// Returns whether "ignore whitespace" mode is enabled.
                    pub fn get_ignore_whitespace(&self) -> bool {
                        self.ignore_whitespace
                    }
                    /// Returns whether UTF-8 mode is enabled.
                    pub fn get_utf8(&self) -> bool {
                        self.utf8
                    }
                    /// Returns the "nest limit" setting.
                    pub fn get_nest_limit(&self) -> u32 {
                        self.nest_limit
                    }
                    /// Returns whether "octal" mode is enabled.
                    pub fn get_octal(&self) -> bool {
                        self.octal
                    }
                    /// Applies this configuration to the given parser.
                    pub fn apply(&self, builder: &mut ParserBuilder) {
                        builder
                            .unicode(self.unicode)
                            .case_insensitive(self.case_insensitive)
                            .multi_line(self.multi_line)
                            .dot_matches_new_line(self.dot_matches_new_line)
                            .crlf(self.crlf)
                            .line_terminator(self.line_terminator)
                            .swap_greed(self.swap_greed)
                            .ignore_whitespace(self.ignore_whitespace)
                            .utf8(self.utf8)
                            .nest_limit(self.nest_limit)
                            .octal(self.octal);
                    }
                    /// Applies this configuration to the given AST parser.
                    pub fn apply_ast(&self, builder: &mut ast::parse::ParserBuilder) {
                        builder
                            .ignore_whitespace(self.ignore_whitespace)
                            .nest_limit(self.nest_limit)
                            .octal(self.octal);
                    }
                    /// Applies this configuration to the given AST-to-HIR translator.
                    pub fn apply_hir(
                        &self,
                        builder: &mut hir::translate::TranslatorBuilder,
                    ) {
                        builder
                            .unicode(self.unicode)
                            .case_insensitive(self.case_insensitive)
                            .multi_line(self.multi_line)
                            .crlf(self.crlf)
                            .dot_matches_new_line(self.dot_matches_new_line)
                            .line_terminator(self.line_terminator)
                            .swap_greed(self.swap_greed)
                            .utf8(self.utf8);
                    }
                }

                impl Default for Config {
                    fn default() -> Config {
                        Config::new()
                    }
                }
            }

            pub mod wire
            {
                /*!
                Types and routines that support the wire format of finite automata. */
                use ::
                {
                    *,
                };
                /*
                use ::{cmp, mem::size_of};

                use ::{vec, vec::Vec};

                use crate::util::{
                    int::Pointer,
                    primitives::{PatternID, PatternIDError, StateID, StateIDError},
                };
                */
                /// A hack to align a smaller type `B` with a bigger type `T`.
                #[repr(C)]
                #[derive(Debug)]
                pub struct AlignAs<B: ?Sized, T>
                {
                    /// A zero-sized field indicating the alignment we want.
                    pub _align: [T; 0],
                    /// A possibly non-sized field containing a sequence of bytes.
                    pub bytes: B,
                }
                /// An error that occurs when serializing an object from this crate.
                #[derive(Debug)]
                pub struct SerializeError
                {
                    /// The name of the thing that a buffer is too small for.
                    what: &'static str,
                }

                impl SerializeError {
                    pub fn buffer_too_small(what: &'static str) -> SerializeError {
                        SerializeError { what }
                    }
                }

                impl ::fmt::Display for SerializeError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "destination buffer is too small to write {}", self.what)
                    }
                }
                
                impl ::error::Error for SerializeError {}
                /// An error that occurs when deserializing an object defined in this crate.
                #[derive(Debug)]
                pub struct DeserializeError(DeserializeErrorKind);

                #[derive(Debug)]
                enum DeserializeErrorKind {
                    Generic { msg: &'static str },
                    BufferTooSmall { what: &'static str },
                    InvalidUsize { what: &'static str },
                    VersionMismatch { expected: u32, found: u32 },
                    EndianMismatch { expected: u32, found: u32 },
                    AlignmentMismatch { alignment: usize, address: usize },
                    LabelMismatch { expected: &'static str },
                    ArithmeticOverflow { what: &'static str },
                    PatternID { err: PatternIDError, what: &'static str },
                    StateID { err: StateIDError, what: &'static str },
                }

                impl DeserializeError {
                    pub fn generic(msg: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::Generic { msg })
                    }

                    pub fn buffer_too_small(what: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::BufferTooSmall { what })
                    }

                    fn invalid_usize(what: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::InvalidUsize { what })
                    }

                    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::VersionMismatch {
                            expected,
                            found,
                        })
                    }

                    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::EndianMismatch {
                            expected,
                            found,
                        })
                    }

                    fn alignment_mismatch(
                        alignment: usize,
                        address: usize,
                    ) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::AlignmentMismatch {
                            alignment,
                            address,
                        })
                    }

                    fn label_mismatch(expected: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::LabelMismatch { expected })
                    }

                    fn arithmetic_overflow(what: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::ArithmeticOverflow { what })
                    }

                    fn pattern_id_error(
                        err: PatternIDError,
                        what: &'static str,
                    ) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::PatternID { err, what })
                    }

                    pub fn state_id_error(
                        err: StateIDError,
                        what: &'static str,
                    ) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::StateID { err, what })
                    }
                }
                
                impl ::error::Error for DeserializeError {}

                impl ::fmt::Display for DeserializeError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        use self::DeserializeErrorKind::*;

                        match self.0 {
                            Generic { msg } => write!(f, "{msg}"),
                            BufferTooSmall { what } => {
                                write!(f, "buffer is too small to read {what}")
                            }
                            InvalidUsize { what } => {
                                write!(f, "{what} is too big to fit in a usize")
                            }
                            VersionMismatch { expected, found } => write!(
                                f,
                                "unsupported version: \
                                expected version {expected} but found version {found}",
                            ),
                            EndianMismatch { expected, found } => write!(
                                f,
                                "endianness mismatch: expected 0x{expected:X} but \
                                got 0x{found:X}. (Are you trying to load an object \
                                serialized with a different endianness?)",
                            ),
                            AlignmentMismatch { alignment, address } => write!(
                                f,
                                "alignment mismatch: slice starts at address 0x{address:X}, \
                                which is not aligned to a {alignment} byte boundary",
                            ),
                            LabelMismatch { expected } => write!(
                                f,
                                "label mismatch: start of serialized object should \
                                contain a NUL terminated {expected:?} label, but a different \
                                label was found",
                            ),
                            ArithmeticOverflow { what } => {
                                write!(f, "arithmetic overflow for {what}")
                            }
                            PatternID { ref err, what } => {
                                write!(f, "failed to read pattern ID for {what}: {err}")
                            }
                            StateID { ref err, what } => {
                                write!(f, "failed to read state ID for {what}: {err}")
                            }
                        }
                    }
                }
                /// Safely converts a `&[u32]` to `&[StateID]` with zero cost.
                #[inline( always )] pub fn u32s_to_state_ids(slice: &[u32]) -> &[StateID] {
                    unsafe {
                        ::slice::from_raw_parts(
                            slice.as_ptr().cast::<StateID>(),
                            slice.len(),
                        )
                    }
                }
                /// Safely converts a `&mut [u32]` to `&mut [StateID]` with zero cost.
                pub fn u32s_to_state_ids_mut(slice: &mut [u32]) -> &mut [StateID] {
                    unsafe {
                        ::slice::from_raw_parts_mut(
                            slice.as_mut_ptr().cast::<StateID>(),
                            slice.len(),
                        )
                    }
                }
                /// Safely converts a `&[u32]` to `&[PatternID]` with zero cost.
                #[inline( always )] pub fn u32s_to_pattern_ids(slice: &[u32]) -> &[PatternID] {
                    unsafe {
                        ::slice::from_raw_parts(
                            slice.as_ptr().cast::<PatternID>(),
                            slice.len(),
                        )
                    }
                }
                /// Checks that the given slice has an alignment that matches `T`.
                pub fn check_alignment<T>(
                    slice: &[u8],
                ) -> Result<(), DeserializeError>
                {
                    let alignment = ::mem::align_of::<T>();
                    let address = slice.as_ptr().as_usize();
                    if address % alignment == 0 {
                        return Ok(());
                    }
                    Err(DeserializeError::alignment_mismatch(alignment, address))
                }
                /// Reads a possibly empty amount of padding, up to 7 bytes, from the beginning
                pub fn skip_initial_padding(slice: &[u8]) -> usize
                {
                    let mut nread = 0;
                    
                    while nread < 7 && nread < slice.len() && slice[nread] == 0 {
                        nread += 1;
                    }
                    nread
                }
                /// Allocate a byte buffer of the given size, along with some initial padding
                pub fn alloc_aligned_buffer<T>(size: usize) -> (Vec<u8>, usize)
                {
                    let buf = vec![0; size];
                    let align = ::mem::align_of::<T>();
                    let address = buf.as_ptr().as_usize();
                    if address % align == 0 {
                        return (buf, 0);
                    }
                    let extra = align - 1;
                    let mut buf = vec![0; size + extra];
                    let address = buf.as_ptr().as_usize();
                    if address % align == 0 {
                        buf.truncate(size);
                        return (buf, 0);
                    }
                    let padding = ((address & !(align - 1)).checked_add(align).unwrap())
                        .checked_sub(address)
                        .unwrap();
                    assert!(padding <= 7, "padding of {padding} is bigger than 7");
                    assert!(
                        padding <= extra,
                        "padding of {padding} is bigger than extra {extra} bytes",
                    );
                    buf.truncate(size + padding);
                    assert_eq!(size + padding, buf.len());
                    assert_eq!(
                        0,
                        buf[padding..].as_ptr().as_usize() % align,
                        "expected end of initial padding to be aligned to {align}",
                    );
                    (buf, padding)
                }
                /// Reads a NUL terminated label starting at the beginning of the given slice.
                pub fn read_label(
                    slice: &[u8],
                    expected_label: &'static str,
                ) -> Result<usize, DeserializeError>
                {
                    let first_nul =
                        slice[..cmp::min(slice.len(), 256)].iter().position(|&b| b == 0);
                    let first_nul = match first_nul {
                        Some(first_nul) => first_nul,
                        None => {
                            return Err(DeserializeError::generic(
                                "could not find NUL terminated label \
                                at start of serialized object",
                            ));
                        }
                    };
                    let len = first_nul + padding_len(first_nul);
                    if slice.len() < len {
                        return Err(DeserializeError::generic(
                            "could not find properly sized label at start of serialized object"
                        ));
                    }
                    if expected_label.as_bytes() != &slice[..first_nul] {
                        return Err(DeserializeError::label_mismatch(expected_label));
                    }
                    Ok(len)
                }
                /// Writes the given label to the buffer as a NUL terminated string. The label
                pub fn write_label(
                    label: &str,
                    dst: &mut [u8],
                ) -> Result<usize, SerializeError>
                {
                    let nwrite = write_label_len(label);
                    if dst.len() < nwrite {
                        return Err(SerializeError::buffer_too_small("label"));
                    }
                    dst[..label.len()].copy_from_slice(label.as_bytes());
                    
                    for i in 0..(nwrite - label.len()) {
                        dst[label.len() + i] = 0;
                    }
                    assert_eq!(nwrite % 4, 0);
                    Ok(nwrite)
                }
                /// Returns the total number of bytes (including padding) that would be written
                pub fn write_label_len(label: &str) -> usize {
                    assert!(label.len() <= 255, "label must not be longer than 255 bytes");
                    assert!(label.bytes().all(|b| b != 0), "label must not contain NUL bytes");
                    let label_len = label.len() + 1; // +1 for the NUL terminator
                    label_len + padding_len(label_len)
                }
                /// Reads the endianness check from the beginning of the given slice and
                pub fn read_endianness_check(
                    slice: &[u8],
                ) -> Result<usize, DeserializeError>
                {
                    let (n, nr) = try_read_u32(slice, "endianness check")?;
                    assert_eq!(nr, write_endianness_check_len());
                    if n != 0xFEFF {
                        return Err(DeserializeError::endian_mismatch(0xFEFF, n));
                    }
                    Ok(nr)
                }
                /// Writes 0xFEFF as an integer using the given endianness.
                pub fn write_endianness_check<E: Endian>(
                    dst: &mut [u8],
                ) -> Result<usize, SerializeError>
                {
                    let nwrite = write_endianness_check_len();
                    if dst.len() < nwrite {
                        return Err(SerializeError::buffer_too_small("endianness check"));
                    }
                    E::write_u32(0xFEFF, dst);
                    Ok(nwrite)
                }
                /// Returns the number of bytes written by the endianness check.
                pub fn write_endianness_check_len() -> usize {
                    size_of::<u32>()
                }
                /// Reads a version number from the beginning of the given slice and confirms
                pub fn read_version(
                    slice: &[u8],
                    expected_version: u32,
                ) -> Result<usize, DeserializeError>
                {
                    let (n, nr) = try_read_u32(slice, "version")?;
                    assert_eq!(nr, write_version_len());
                    if n != expected_version {
                        return Err(DeserializeError::version_mismatch(expected_version, n));
                    }
                    Ok(nr)
                }
                /// Writes the given version number to the beginning of the given slice.
                pub fn write_version<E: Endian>(
                    version: u32,
                    dst: &mut [u8],
                ) -> Result<usize, SerializeError>
                {
                    let nwrite = write_version_len();
                    if dst.len() < nwrite {
                        return Err(SerializeError::buffer_too_small("version number"));
                    }
                    E::write_u32(version, dst);
                    Ok(nwrite)
                }
                /// Returns the number of bytes written by writing the version number.
                pub fn write_version_len() -> usize {
                    size_of::<u32>()
                }
                /// Reads a pattern ID from the given slice. If the slice has insufficient
                pub fn read_pattern_id(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(PatternID, usize), DeserializeError>
                {
                    let bytes: [u8; PatternID::SIZE] =
                        slice[..PatternID::SIZE].try_into().unwrap();
                    let pid = PatternID::from_ne_bytes(bytes)
                        .map_err(|err| DeserializeError::pattern_id_error(err, what))?;
                    Ok((pid, PatternID::SIZE))
                }
                /// Reads a pattern ID from the given slice. If the slice has insufficient
                pub fn read_pattern_id_unchecked(slice: &[u8]) -> (PatternID, usize)
                {
                    let pid = PatternID::from_ne_bytes_unchecked(
                        slice[..PatternID::SIZE].try_into().unwrap(),
                    );
                    (pid, PatternID::SIZE)
                }
                /// Write the given pattern ID to the beginning of the given slice of bytes
                pub fn write_pattern_id<E: Endian>(
                    pid: PatternID,
                    dst: &mut [u8],
                ) -> usize {
                    E::write_u32(pid.as_u32(), dst);
                    PatternID::SIZE
                }
                /// Attempts to read a state ID from the given slice. If the slice has an
                pub fn try_read_state_id(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(StateID, usize), DeserializeError> {
                    if slice.len() < StateID::SIZE {
                        return Err(DeserializeError::buffer_too_small(what));
                    }
                    read_state_id(slice, what)
                }
                /// Reads a state ID from the given slice. If the slice has insufficient
                pub fn read_state_id(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(StateID, usize), DeserializeError>
                {
                    let bytes: [u8; StateID::SIZE] =
                        slice[..StateID::SIZE].try_into().unwrap();
                    let sid = StateID::from_ne_bytes(bytes)
                        .map_err(|err| DeserializeError::state_id_error(err, what))?;
                    Ok((sid, StateID::SIZE))
                }
                /// Reads a state ID from the given slice. If the slice has insufficient
                pub fn read_state_id_unchecked(slice: &[u8]) -> (StateID, usize)
                {
                    let sid = StateID::from_ne_bytes_unchecked(
                        slice[..StateID::SIZE].try_into().unwrap(),
                    );
                    (sid, StateID::SIZE)
                }
                /// Write the given state ID to the beginning of the given slice of bytes
                pub fn write_state_id<E: Endian>(
                    sid: StateID,
                    dst: &mut [u8],
                ) -> usize {
                    E::write_u32(sid.as_u32(), dst);
                    StateID::SIZE
                }
                /// Try to read a u16 as a usize from the beginning of the given slice in
                pub fn try_read_u16_as_usize(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(usize, usize), DeserializeError> {
                    try_read_u16(slice, what).and_then(|(n, nr)| {
                        usize::try_from(n)
                            .map(|n| (n, nr))
                            .map_err(|_| DeserializeError::invalid_usize(what))
                    })
                }
                /// Try to read a u32 as a usize from the beginning of the given slice in
                pub fn try_read_u32_as_usize(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(usize, usize), DeserializeError> {
                    try_read_u32(slice, what).and_then(|(n, nr)| {
                        usize::try_from(n)
                            .map(|n| (n, nr))
                            .map_err(|_| DeserializeError::invalid_usize(what))
                    })
                }
                /// Try to read a u16 from the beginning of the given slice in native endian
                pub fn try_read_u16(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(u16, usize), DeserializeError> {
                    check_slice_len(slice, size_of::<u16>(), what)?;
                    Ok((read_u16(slice), size_of::<u16>()))
                }
                /// Try to read a u32 from the beginning of the given slice in native endian
                pub fn try_read_u32(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(u32, usize), DeserializeError> {
                    check_slice_len(slice, size_of::<u32>(), what)?;
                    Ok((read_u32(slice), size_of::<u32>()))
                }
                /// Try to read a u128 from the beginning of the given slice in native endian
                pub fn try_read_u128(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(u128, usize), DeserializeError> {
                    check_slice_len(slice, size_of::<u128>(), what)?;
                    Ok((read_u128(slice), size_of::<u128>()))
                }
                /// Read a u16 from the beginning of the given slice in native endian format.
                #[inline( always )] pub fn read_u16(slice: &[u8]) -> u16
                {
                    let bytes: [u8; 2] = slice[..size_of::<u16>()].try_into().unwrap();
                    u16::from_ne_bytes(bytes)
                }
                /// Read a u32 from the beginning of the given slice in native endian format.
                #[inline( always )] pub fn read_u32(slice: &[u8]) -> u32
                {
                    let bytes: [u8; 4] = slice[..size_of::<u32>()].try_into().unwrap();
                    u32::from_ne_bytes(bytes)
                }
                /// Read a u128 from the beginning of the given slice in native endian format.
                pub fn read_u128(slice: &[u8]) -> u128
                {
                    let bytes: [u8; 16] = slice[..size_of::<u128>()].try_into().unwrap();
                    u128::from_ne_bytes(bytes)
                }
                /// Checks that the given slice has some minimal length. If it's smaller than
                pub fn check_slice_len<T>(
                    slice: &[T],
                    at_least_len: usize,
                    what: &'static str,
                ) -> Result<(), DeserializeError> {
                    if slice.len() < at_least_len {
                        return Err(DeserializeError::buffer_too_small(what));
                    }
                    Ok(())
                }
                /// Multiply the given numbers, and on overflow, return an error that includes
                pub fn mul(
                    a: usize,
                    b: usize,
                    what: &'static str,
                ) -> Result<usize, DeserializeError> {
                    match a.checked_mul(b) {
                        Some(c) => Ok(c),
                        None => Err(DeserializeError::arithmetic_overflow(what)),
                    }
                }
                /// Add the given numbers, and on overflow, return an error that includes
                pub fn add(
                    a: usize,
                    b: usize,
                    what: &'static str,
                ) -> Result<usize, DeserializeError> {
                    match a.checked_add(b) {
                        Some(c) => Ok(c),
                        None => Err(DeserializeError::arithmetic_overflow(what)),
                    }
                }
                /// Shift `a` left by `b`, and on overflow, return an error that includes
                pub fn shl(
                    a: usize,
                    b: usize,
                    what: &'static str,
                ) -> Result<usize, DeserializeError>
                {
                    let amount = u32::try_from(b)
                        .map_err(|_| DeserializeError::arithmetic_overflow(what))?;
                    match a.checked_shl(amount) {
                        Some(c) => Ok(c),
                        None => Err(DeserializeError::arithmetic_overflow(what)),
                    }
                }
                /// Returns the number of additional bytes required to add to the given length
                pub fn padding_len(non_padding_len: usize) -> usize {
                    (4 - (non_padding_len & 0b11)) & 0b11
                }
                /// A simple trait for writing code generic over endianness.
                pub trait Endian
                {
                    /// Writes a u16 to the given destination buffer in a particular
                    fn write_u16(n: u16, dst: &mut [u8]);
                    /// Writes a u32 to the given destination buffer in a particular
                    fn write_u32(n: u32, dst: &mut [u8]);
                    /// Writes a u128 to the given destination buffer in a particular
                    fn write_u128(n: u128, dst: &mut [u8]);
                }
                /// Little endian writing.
                pub enum LE {}
                /// Big endian writing.
                pub enum BE {}

                #[cfg(target_endian = "little")]
                pub type NE = LE;
                #[cfg(target_endian = "big")]
                pub type NE = BE;

                impl Endian for LE {
                    fn write_u16(n: u16, dst: &mut [u8]) {
                        dst[..2].copy_from_slice(&n.to_le_bytes());
                    }

                    fn write_u32(n: u32, dst: &mut [u8]) {
                        dst[..4].copy_from_slice(&n.to_le_bytes());
                    }

                    fn write_u128(n: u128, dst: &mut [u8]) {
                        dst[..16].copy_from_slice(&n.to_le_bytes());
                    }
                }

                impl Endian for BE {
                    fn write_u16(n: u16, dst: &mut [u8]) {
                        dst[..2].copy_from_slice(&n.to_be_bytes());
                    }

                    fn write_u32(n: u32, dst: &mut [u8]) {
                        dst[..4].copy_from_slice(&n.to_be_bytes());
                    }

                    fn write_u128(n: u128, dst: &mut [u8]) {
                        dst[..16].copy_from_slice(&n.to_be_bytes());
                    }
                }
            }

            pub mod determinize
            {
                /*!
                This module contains types and routines for implementing determinization. */
                use ::
                {
                    *,
                };
                /*
                use ::vec::Vec;

                pub use self::state::{
                    State, StateBuilderEmpty, StateBuilderMatches, StateBuilderNFA,
                };

                use crate::{
                    nfa::thompson,
                    util::{
                        alphabet,
                        look::{Look, LookSet},
                        primitives::StateID,
                        search::MatchKind,
                        sparse_set::{SparseSet, SparseSets},
                        start::Start,
                        utf8,
                    },
                };
                */
                mod state
                {
                    /*!
                    This module defines a DFA state representation and builders for constructing DFA states. */
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::mem;

                    use ::{sync::Arc, vec::Vec};

                    use crate::util::{
                        int::{I32, U32},
                        look::LookSet,
                        primitives::{PatternID, StateID},
                        wire::{self, Endian},
                    };
                    */
                    /// A DFA state that, at its core, is represented by an ordered set of NFA
                    #[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]
                    pub struct State(Arc<[u8]>);
                    /// This Borrow impl permits us to lookup any state in a map by its byte
                    impl ::borrow::Borrow<[u8]> for State {
                        fn borrow(&self) -> &[u8] {
                            &self.0
                        }
                    }

                    impl ::fmt::Debug for State {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            f.debug_tuple("State").field(&self.repr()).finish()
                        }
                    }
                    /// For docs on these routines, see the internal Repr and ReprVec types below.
                    impl State {
                        pub fn dead() -> State {
                            StateBuilderEmpty::new().into_matches().into_nfa().to_state()
                        }

                        pub fn is_match(&self) -> bool {
                            self.repr().is_match()
                        }

                        pub fn is_from_word(&self) -> bool {
                            self.repr().is_from_word()
                        }

                        pub fn is_half_crlf(&self) -> bool {
                            self.repr().is_half_crlf()
                        }

                        pub fn look_have(&self) -> LookSet {
                            self.repr().look_have()
                        }

                        pub fn look_need(&self) -> LookSet {
                            self.repr().look_need()
                        }

                        pub fn match_len(&self) -> usize {
                            self.repr().match_len()
                        }

                        pub fn match_pattern(&self, index: usize) -> PatternID {
                            self.repr().match_pattern(index)
                        }

                        pub fn match_pattern_ids(&self) -> Option<Vec<PatternID>> {
                            self.repr().match_pattern_ids()
                        }

                        #[cfg(all(test, not(miri)))]
                        pub fn iter_match_pattern_ids<F: FnMut(PatternID)>(&self, f: F) {
                            self.repr().iter_match_pattern_ids(f)
                        }

                        pub fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, f: F) {
                            self.repr().iter_nfa_state_ids(f)
                        }

                        pub fn memory_usage(&self) -> usize {
                            self.0.len()
                        }

                        fn repr(&self) -> Repr<'_> {
                            Repr(&self.0)
                        }
                    }
                    /// A state builder that represents an empty state.
                    #[derive(Clone, Debug)]
                    pub struct StateBuilderEmpty(Vec<u8>);
                    /// For docs on these routines, see the internal Repr and ReprVec types below.
                    impl StateBuilderEmpty {
                        pub fn new() -> StateBuilderEmpty {
                            StateBuilderEmpty(vec![])
                        }

                        pub fn into_matches(mut self) -> StateBuilderMatches {
                            self.0.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0, 0]);
                            StateBuilderMatches(self.0)
                        }

                        fn clear(&mut self) {
                            self.0.clear();
                        }

                        pub fn capacity(&self) -> usize {
                            self.0.capacity()
                        }
                    }
                    /// A state builder that collects assertions and pattern IDs.
                    #[derive(Clone)]
                    pub struct StateBuilderMatches(Vec<u8>);

                    impl ::fmt::Debug for StateBuilderMatches {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            f.debug_tuple("StateBuilderMatches").field(&self.repr()).finish()
                        }
                    }
                    /// For docs on these routines, see the internal Repr and ReprVec types below.
                    impl StateBuilderMatches {
                        pub fn into_nfa(mut self) -> StateBuilderNFA {
                            self.repr_vec().close_match_pattern_ids();
                            StateBuilderNFA { repr: self.0, prev_nfa_state_id: StateID::ZERO }
                        }

                        pub fn set_is_from_word(&mut self) {
                            self.repr_vec().set_is_from_word()
                        }

                        pub fn set_is_half_crlf(&mut self) {
                            self.repr_vec().set_is_half_crlf()
                        }

                        pub fn look_have(&self) -> LookSet {
                            LookSet::read_repr(&self.0[1..])
                        }

                        pub fn set_look_have(
                            &mut self,
                            set: impl FnMut(LookSet) -> LookSet,
                        ) {
                            self.repr_vec().set_look_have(set)
                        }

                        pub fn add_match_pattern_id(&mut self, pid: PatternID) {
                            self.repr_vec().add_match_pattern_id(pid)
                        }

                        fn repr(&self) -> Repr<'_> {
                            Repr(&self.0)
                        }

                        fn repr_vec(&mut self) -> ReprVec<'_> {
                            ReprVec(&mut self.0)
                        }
                    }
                    /// A state builder that collects some assertions and NFA state IDs.
                    #[derive(Clone)]
                    pub struct StateBuilderNFA {
                        repr: Vec<u8>,
                        prev_nfa_state_id: StateID,
                    }

                    impl ::fmt::Debug for StateBuilderNFA {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            f.debug_tuple("StateBuilderNFA").field(&self.repr()).finish()
                        }
                    }
                    /// For docs on these routines, see the internal Repr and ReprVec types below.
                    impl StateBuilderNFA {
                        pub fn to_state(&self) -> State {
                            State(Arc::from(&*self.repr))
                        }

                        pub fn clear(self) -> StateBuilderEmpty {
                            let mut builder = StateBuilderEmpty(self.repr);
                            builder.clear();
                            builder
                        }

                        pub fn look_need(&self) -> LookSet {
                            self.repr().look_need()
                        }

                        pub fn set_look_have(
                            &mut self,
                            set: impl FnMut(LookSet) -> LookSet,
                        ) {
                            self.repr_vec().set_look_have(set)
                        }

                        pub fn set_look_need(
                            &mut self,
                            set: impl FnMut(LookSet) -> LookSet,
                        ) {
                            self.repr_vec().set_look_need(set)
                        }

                        pub fn add_nfa_state_id(&mut self, sid: StateID) {
                            ReprVec(&mut self.repr)
                                .add_nfa_state_id(&mut self.prev_nfa_state_id, sid)
                        }

                        pub fn as_bytes(&self) -> &[u8] {
                            &self.repr
                        }

                        fn repr(&self) -> Repr<'_> {
                            Repr(&self.repr)
                        }

                        fn repr_vec(&mut self) -> ReprVec<'_> {
                            ReprVec(&mut self.repr)
                        }
                    }
                    /// Repr is a read-only view into the representation of a DFA state.
                    struct Repr<'a>(&'a [u8]);

                    impl<'a> Repr<'a> {
                        /// Returns true if and only if this is a match state.
                        fn is_match(&self) -> bool {
                            self.0[0] & (1 << 0) > 0
                        }
                        /// Returns true if and only if this state has had at least one pattern
                        fn has_pattern_ids(&self) -> bool {
                            self.0[0] & (1 << 1) > 0
                        }
                        /// Returns true if and only if this state is marked as having been created
                        fn is_from_word(&self) -> bool {
                            self.0[0] & (1 << 2) > 0
                        }
                        /// Returns true if and only if this state is marked as being inside of a
                        fn is_half_crlf(&self) -> bool {
                            self.0[0] & (1 << 3) > 0
                        }
                        /// The set of look-behind assertions that were true in the transition that
                        fn look_have(&self) -> LookSet {
                            LookSet::read_repr(&self.0[1..])
                        }
                        /// The set of look-around (both behind and ahead) assertions that appear
                        fn look_need(&self) -> LookSet {
                            LookSet::read_repr(&self.0[5..])
                        }
                        /// Returns the total number of match pattern IDs in this state.
                        fn match_len(&self) -> usize {
                            if !self.is_match() {
                                0
                            } else if !self.has_pattern_ids() {
                                1
                            } else {
                                self.encoded_pattern_len()
                            }
                        }
                        /// Returns the pattern ID for this match state at the given index.
                        fn match_pattern(&self, index: usize) -> PatternID {
                            if !self.has_pattern_ids() {
                                PatternID::ZERO
                            } else {
                                let offset = 13 + index * PatternID::SIZE;
                                wire::read_pattern_id_unchecked(&self.0[offset..]).0
                            }
                        }
                        /// Returns a copy of all match pattern IDs in this state. If this state
                        fn match_pattern_ids(&self) -> Option<Vec<PatternID>> {
                            if !self.is_match() {
                                return None;
                            }
                            let mut pids = vec![];
                            self.iter_match_pattern_ids(|pid| pids.push(pid));
                            Some(pids)
                        }
                        /// Calls the given function on every pattern ID in this state.
                        fn iter_match_pattern_ids<F: FnMut(PatternID)>(&self, mut f: F) {
                            if !self.is_match() {
                                return;
                            }
                            
                            if !self.has_pattern_ids() {
                                f(PatternID::ZERO);
                                return;
                            }
                            let mut pids = &self.0[13..self.pattern_offset_end()];
                            while !pids.is_empty() {
                                let pid = wire::read_u32(pids);
                                pids = &pids[PatternID::SIZE..];
                                f(PatternID::new_unchecked(usize::try_from(pid).unwrap()));
                            }
                        }
                        /// Calls the given function on every NFA state ID in this state.
                        fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, mut f: F) {
                            let mut sids = &self.0[self.pattern_offset_end()..];
                            let mut prev = 0i32;
                            while !sids.is_empty() {
                                let (delta, nr) = read_vari32(sids);
                                sids = &sids[nr..];
                                let sid = prev + delta;
                                prev = sid;
                                f(StateID::new_unchecked(sid.as_usize()))
                            }
                        }
                        /// Returns the offset into this state's representation where the pattern
                        fn pattern_offset_end(&self) -> usize {
                            let encoded = self.encoded_pattern_len();
                            if encoded == 0 {
                                return 9;
                            }
                            encoded.checked_mul(4).unwrap().checked_add(13).unwrap()
                        }
                        /// Returns the total number of *encoded* pattern IDs in this state.
                        fn encoded_pattern_len(&self) -> usize {
                            if !self.has_pattern_ids() {
                                return 0;
                            }
                            usize::try_from(wire::read_u32(&self.0[9..13])).unwrap()
                        }
                    }

                    impl<'a> ::fmt::Debug for Repr<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut nfa_ids = vec![];
                            self.iter_nfa_state_ids(|sid| nfa_ids.push(sid));
                            f.debug_struct("Repr")
                                .field("is_match", &self.is_match())
                                .field("is_from_word", &self.is_from_word())
                                .field("is_half_crlf", &self.is_half_crlf())
                                .field("look_have", &self.look_have())
                                .field("look_need", &self.look_need())
                                .field("match_pattern_ids", &self.match_pattern_ids())
                                .field("nfa_state_ids", &nfa_ids)
                                .finish()
                        }
                    }
                    /// ReprVec is a write-only view into the representation of a DFA state.
                    struct ReprVec<'a>(&'a mut Vec<u8>);

                    impl<'a> ReprVec<'a> {
                        /// Set this state as a match state.
                        fn set_is_match(&mut self) {
                            self.0[0] |= 1 << 0;
                        }
                        /// Set that this state has pattern IDs explicitly written to it.
                        fn set_has_pattern_ids(&mut self) {
                            self.0[0] |= 1 << 1;
                        }
                        /// Set this state as being built from a transition over a word byte.
                        fn set_is_from_word(&mut self) {
                            self.0[0] |= 1 << 2;
                        }
                        /// Set this state as having seen half of a CRLF terminator.
                        fn set_is_half_crlf(&mut self) {
                            self.0[0] |= 1 << 3;
                        }
                        /// The set of look-behind assertions that were true in the transition that
                        fn look_have(&self) -> LookSet {
                            self.repr().look_have()
                        }
                        /// The set of look-around (both behind and ahead) assertions that appear
                        fn look_need(&self) -> LookSet {
                            self.repr().look_need()
                        }
                        /// Mutate the set of look-behind assertions that were true in the
                        fn set_look_have(&mut self, mut set: impl FnMut(LookSet) -> LookSet) {
                            set(self.look_have()).write_repr(&mut self.0[1..]);
                        }
                        /// Mutate the set of look-around (both behind and ahead) assertions that
                        fn set_look_need(&mut self, mut set: impl FnMut(LookSet) -> LookSet) {
                            set(self.look_need()).write_repr(&mut self.0[5..]);
                        }
                        /// Add a pattern ID to this state. All match states must have at least
                        fn add_match_pattern_id(&mut self, pid: PatternID) {
                            if !self.repr().has_pattern_ids()
                            {
                                if pid == PatternID::ZERO {
                                    self.set_is_match();
                                    return;
                                }
                                self.0.extend(::iter::repeat(0).take(PatternID::SIZE));
                                self.set_has_pattern_ids();
                                
                                if self.repr().is_match() {
                                    write_u32(self.0, 0)
                                } else {
                                    // Otherwise, just make sure the 'is_match' bit is set.
                                    self.set_is_match();
                                }
                            }
                            write_u32(self.0, pid.as_u32());
                        }
                        /// Indicate that no more pattern IDs will be added to this state.
                        fn close_match_pattern_ids(&mut self) {
                            // If we never wrote any pattern IDs, then there's nothing to do here.
                            if !self.repr().has_pattern_ids() {
                                return;
                            }
                            let patsize = PatternID::SIZE;
                            let pattern_bytes = self.0.len() - 13;
                            assert_eq!(pattern_bytes % patsize, 0);
                            let count32 = u32::try_from(pattern_bytes / patsize).unwrap();
                            wire::NE::write_u32(count32, &mut self.0[9..13]);
                        }
                        /// Add an NFA state ID to this state. The order in which NFA states are
                        fn add_nfa_state_id(&mut self, prev: &mut StateID, sid: StateID) {
                            let delta = sid.as_i32() - prev.as_i32();
                            write_vari32(self.0, delta);
                            *prev = sid;
                        }
                        /// Return a read-only view of this state's representation.
                        fn repr(&self) -> Repr<'_> {
                            Repr(self.0.as_slice())
                        }
                    }
                    /// Write a signed 32-bit integer using zig-zag encoding.
                    fn write_vari32(data: &mut Vec<u8>, n: i32) {
                        let mut un = n.to_bits() << 1;
                        
                        if n < 0 {
                            un = !un;
                        }
                        write_varu32(data, un)
                    }
                    /// Read a signed 32-bit integer using zig-zag encoding. Also, return the
                    fn read_vari32(data: &[u8]) -> (i32, usize) {
                        let (un, i) = read_varu32(data);
                        let mut n = i32::from_bits(un >> 1);
                        
                        if un & 1 != 0 {
                            n = !n;
                        }
                        (n, i)
                    }
                    /// Write an unsigned 32-bit integer as a varint. In essence, `n` is written
                    fn write_varu32(data: &mut Vec<u8>, mut n: u32) {
                        while n >= 0b1000_0000 {
                            data.push(n.low_u8() | 0b1000_0000);
                            n >>= 7;
                        }
                        data.push(n.low_u8());
                    }
                    /// Read an unsigned 32-bit varint. Also, return the number of bytes read.
                    fn read_varu32(data: &[u8]) -> (u32, usize) {
                        let mut n: u32 = 0;
                        let mut shift: u32 = 0;
                        for (i, &b) in data.iter().enumerate()
                        {
                            if b < 0b1000_0000 {
                                return (n | (u32::from(b) << shift), i + 1);
                            }
                            n |= (u32::from(b) & 0b0111_1111) << shift;
                            shift += 7;
                        }
                        (0, 0)
                    }
                    /// Push a native-endian encoded `n` on to `dst`.
                    fn write_u32(dst: &mut Vec<u8>, n: u32) {
                        use crate::util::wire::NE;

                        let start = dst.len();
                        dst.extend(::iter::repeat(0).take(mem::size_of::<u32>()));
                        NE::write_u32(n, &mut dst[start..]);
                    }
                }
                /// Compute the set of all reachable NFA states, including the full epsilon
                pub fn next(
                    nfa: &thompson::NFA,
                    match_kind: MatchKind,
                    sparses: &mut SparseSets,
                    stack: &mut Vec<StateID>,
                    state: &State,
                    unit: alphabet::Unit,
                    empty_builder: StateBuilderEmpty,
                ) -> StateBuilderNFA {
                    sparses.clear();
                    let rev = nfa.is_reverse();
                    let lookm = nfa.look_matcher();
                    state.iter_nfa_state_ids(|nfa_id| {
                        sparses.set1.insert(nfa_id);
                    });
                    if !state.look_need().is_empty() {
                        let mut look_have = state.look_have();
                        match unit.as_u8() {
                            Some(b'\r') => {
                                if !rev || !state.is_half_crlf() {
                                    look_have = look_have.insert(Look::EndCRLF);
                                }
                            }
                            Some(b'\n') => {
                                if rev || !state.is_half_crlf() {
                                    look_have = look_have.insert(Look::EndCRLF);
                                }
                            }
                            Some(_) => {}
                            None => {
                                look_have = look_have
                                    .insert(Look::End)
                                    .insert(Look::EndLF)
                                    .insert(Look::EndCRLF);
                            }
                        }
                        
                        if unit.is_byte(lookm.get_line_terminator()) {
                            look_have = look_have.insert(Look::EndLF);
                        }
                        
                        if state.is_half_crlf()
                            && ((rev && !unit.is_byte(b'\r'))
                                || (!rev && !unit.is_byte(b'\n')))
                        {
                            look_have = look_have.insert(Look::StartCRLF);
                        }
                        
                        if state.is_from_word() == unit.is_word_byte() {
                            look_have = look_have
                                .insert(Look::WordAsciiNegate)
                                .insert(Look::WordUnicodeNegate);
                        } else {
                            look_have =
                                look_have.insert(Look::WordAscii).insert(Look::WordUnicode);
                        }
                        
                        if !unit.is_word_byte() {
                            look_have = look_have
                                .insert(Look::WordEndHalfAscii)
                                .insert(Look::WordEndHalfUnicode);
                        }
                        
                        if state.is_from_word() && !unit.is_word_byte() {
                            look_have = look_have
                                .insert(Look::WordEndAscii)
                                .insert(Look::WordEndUnicode);
                        } else if !state.is_from_word() && unit.is_word_byte() {
                            look_have = look_have
                                .insert(Look::WordStartAscii)
                                .insert(Look::WordStartUnicode);
                        }
                        
                        if !look_have
                            .subtract(state.look_have())
                            .intersect(state.look_need())
                            .is_empty()
                        {
                            for nfa_id in sparses.set1.iter() {
                                epsilon_closure(
                                    nfa,
                                    nfa_id,
                                    look_have,
                                    stack,
                                    &mut sparses.set2,
                                );
                            }
                            sparses.swap();
                            sparses.set2.clear();
                        }
                    }
                    let mut builder = empty_builder.into_matches();
                    if nfa.look_set_any().contains_anchor_line()
                        && unit.is_byte(lookm.get_line_terminator())
                    {
                        builder.set_look_have(|have| have.insert(Look::StartLF));
                    }
                    if nfa.look_set_any().contains_anchor_crlf()
                        && ((rev && unit.is_byte(b'\r')) || (!rev && unit.is_byte(b'\n')))
                    {
                        builder.set_look_have(|have| have.insert(Look::StartCRLF));
                    }
                    if nfa.look_set_any().contains_word() && !unit.is_word_byte() {
                        builder.set_look_have(|have| {
                            have.insert(Look::WordStartHalfAscii)
                                .insert(Look::WordStartHalfUnicode)
                        });
                    }
                    for nfa_id in sparses.set1.iter() {
                        match *nfa.state(nfa_id) {
                            thompson::State::Union { .. }
                            | thompson::State::BinaryUnion { .. }
                            | thompson::State::Fail
                            | thompson::State::Look { .. }
                            | thompson::State::Capture { .. } => {}
                            thompson::State::Match { pattern_id } => {
                                builder.add_match_pattern_id(pattern_id);
                                
                                if !match_kind.continue_past_first_match() {
                                    break;
                                }
                            }
                            thompson::State::ByteRange { ref trans } => {
                                if trans.matches_unit(unit) {
                                    epsilon_closure(
                                        nfa,
                                        trans.next,
                                        builder.look_have(),
                                        stack,
                                        &mut sparses.set2,
                                    );
                                }
                            }
                            thompson::State::Sparse(ref sparse) => {
                                if let Some(next) = sparse.matches_unit(unit) {
                                    epsilon_closure(
                                        nfa,
                                        next,
                                        builder.look_have(),
                                        stack,
                                        &mut sparses.set2,
                                    );
                                }
                            }
                            thompson::State::Dense(ref dense) => {
                                if let Some(next) = dense.matches_unit(unit) {
                                    epsilon_closure(
                                        nfa,
                                        next,
                                        builder.look_have(),
                                        stack,
                                        &mut sparses.set2,
                                    );
                                }
                            }
                        }
                    }
                    if !sparses.set2.is_empty() {
                        if nfa.look_set_any().contains_word() && unit.is_word_byte() {
                            builder.set_is_from_word();
                        }
                        
                        if nfa.look_set_any().contains_anchor_crlf()
                            && ((rev && unit.is_byte(b'\n')) || (!rev && unit.is_byte(b'\r')))
                        {
                            builder.set_is_half_crlf();
                        }
                    }
                    let mut builder_nfa = builder.into_nfa();
                    add_nfa_states(nfa, &sparses.set2, &mut builder_nfa);
                    builder_nfa
                }
                /// Compute the epsilon closure for the given NFA state. The epsilon closure
                pub fn epsilon_closure(
                    nfa: &thompson::NFA,
                    start_nfa_id: StateID,
                    look_have: LookSet,
                    stack: &mut Vec<StateID>,
                    set: &mut SparseSet,
                ) {
                    assert!(stack.is_empty());
                    if !nfa.state(start_nfa_id).is_epsilon() {
                        set.insert(start_nfa_id);
                        return;
                    }

                    stack.push(start_nfa_id);
                    
                    while let Some(mut id) = stack.pop() {
                        loop {
                            if !set.insert(id) {
                                break;
                            }
                            match *nfa.state(id) {
                                thompson::State::ByteRange { .. }
                                | thompson::State::Sparse { .. }
                                | thompson::State::Dense { .. }
                                | thompson::State::Fail
                                | thompson::State::Match { .. } => break,
                                thompson::State::Look { look, next } => {
                                    if !look_have.contains(look) {
                                        break;
                                    }
                                    id = next;
                                }
                                thompson::State::Union { ref alternates } => {
                                    id = match alternates.get(0) {
                                        None => break,
                                        Some(&id) => id,
                                    };
                                    stack.extend(alternates[1..].iter().rev());
                                }
                                thompson::State::BinaryUnion { alt1, alt2 } => {
                                    id = alt1;
                                    stack.push(alt2);
                                }
                                thompson::State::Capture { next, .. } => {
                                    id = next;
                                }
                            }
                        }
                    }
                }
                /// Add the NFA state IDs in the given `set` to the given DFA builder state.
                pub fn add_nfa_states(
                    nfa: &thompson::NFA,
                    set: &SparseSet,
                    builder: &mut StateBuilderNFA,
                ) {
                    for nfa_id in set.iter() {
                        match *nfa.state(nfa_id) {
                            thompson::State::ByteRange { .. } => {
                                builder.add_nfa_state_id(nfa_id);
                            }
                            thompson::State::Sparse { .. } => {
                                builder.add_nfa_state_id(nfa_id);
                            }
                            thompson::State::Dense { .. } => {
                                builder.add_nfa_state_id(nfa_id);
                            }
                            thompson::State::Look { look, .. } => {
                                builder.add_nfa_state_id(nfa_id);
                                builder.set_look_need(|need| need.insert(look));
                            }
                            thompson::State::Union { .. }
                            | thompson::State::BinaryUnion { .. } => {
                                builder.add_nfa_state_id(nfa_id);
                            }
                            thompson::State::Capture { .. } => {}
                            thompson::State::Fail => {
                                builder.add_nfa_state_id(nfa_id);
                            }
                            thompson::State::Match { .. } => {
                                builder.add_nfa_state_id(nfa_id);
                            }
                        }
                    }
                    if builder.look_need().is_empty() {
                        builder.set_look_have(|_| LookSet::empty());
                    }
                }
                /// Sets the appropriate look-behind assertions on the given state based on
                pub fn set_lookbehind_from_start(
                    nfa: &thompson::NFA,
                    start: &Start,
                    builder: &mut StateBuilderMatches,
                )
                {
                    let rev = nfa.is_reverse();
                    let lineterm = nfa.look_matcher().get_line_terminator();
                    let lookset = nfa.look_set_any();
                    match *start {
                        Start::NonWordByte => {
                            if lookset.contains_word() {
                                builder.set_look_have(|have| {
                                    have.insert(Look::WordStartHalfAscii)
                                        .insert(Look::WordStartHalfUnicode)
                                });
                            }
                        }
                        Start::WordByte => {
                            if lookset.contains_word() {
                                builder.set_is_from_word();
                            }
                        }
                        Start::Text => {
                            if lookset.contains_anchor_haystack() {
                                builder.set_look_have(|have| have.insert(Look::Start));
                            }
                            
                            if lookset.contains_anchor_line() {
                                builder.set_look_have(|have| {
                                    have.insert(Look::StartLF).insert(Look::StartCRLF)
                                });
                            }
                            
                            if lookset.contains_word() {
                                builder.set_look_have(|have| {
                                    have.insert(Look::WordStartHalfAscii)
                                        .insert(Look::WordStartHalfUnicode)
                                });
                            }
                        }
                        Start::LineLF => {
                            if rev {
                                if lookset.contains_anchor_crlf() {
                                    builder.set_is_half_crlf();
                                }
                                if lookset.contains_anchor_line() {
                                    builder.set_look_have(|have| have.insert(Look::StartLF));
                                }
                            } else {
                                if lookset.contains_anchor_line() {
                                    builder.set_look_have(|have| have.insert(Look::StartCRLF));
                                }
                            }
                            
                            if lookset.contains_anchor_line() && lineterm == b'\n' {
                                builder.set_look_have(|have| have.insert(Look::StartLF));
                            }
                            
                            if lookset.contains_word() {
                                builder.set_look_have(|have| {
                                    have.insert(Look::WordStartHalfAscii)
                                        .insert(Look::WordStartHalfUnicode)
                                });
                            }
                        }
                        Start::LineCR => {
                            if lookset.contains_anchor_crlf()
                            {
                                if rev {
                                    builder.set_look_have(|have| have.insert(Look::StartCRLF));
                                } else {
                                    builder.set_is_half_crlf();
                                }
                            }
                            
                            if lookset.contains_anchor_line() && lineterm == b'\r' {
                                builder.set_look_have(|have| have.insert(Look::StartLF));
                            }
                            
                            if lookset.contains_word() {
                                builder.set_look_have(|have| {
                                    have.insert(Look::WordStartHalfAscii)
                                        .insert(Look::WordStartHalfUnicode)
                                });
                            }
                        }
                        Start::CustomLineTerminator => {
                            if lookset.contains_anchor_line() {
                                builder.set_look_have(|have| have.insert(Look::StartLF));
                            }
                            
                            if lookset.contains_word()
                            {
                                if utf8::is_word_byte(lineterm) {
                                    builder.set_is_from_word();
                                } else {
                                    builder.set_look_have(|have| {
                                        have.insert(Look::WordStartHalfAscii)
                                            .insert(Look::WordStartHalfUnicode)
                                    });
                                }
                            }
                        }
                    }
                }
            }

            pub mod empty
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

            }

            pub mod int
            {
                /*!
                This module provides several integer oriented traits for converting between
                both fixed size integers and integers whose size varies based on the target
                (like `usize`).*/
                use ::
                {
                    *,
                };
                /*                
                */
                pub trait U8 {
                    fn as_usize(self) -> usize;
                }

                impl U8 for u8 {
                    fn as_usize(self) -> usize {
                        usize::from(self)
                    }
                }

                pub trait U16 {
                    fn as_usize(self) -> usize;
                    fn low_u8(self) -> u8;
                    fn high_u8(self) -> u8;
                }

                impl U16 for u16 {
                    fn as_usize(self) -> usize {
                        usize::from(self)
                    }

                    fn low_u8(self) -> u8 {
                        self as u8
                    }

                    fn high_u8(self) -> u8 {
                        (self >> 8) as u8
                    }
                }

                pub trait U32 {
                    fn as_usize(self) -> usize;
                    fn low_u8(self) -> u8;
                    fn low_u16(self) -> u16;
                    fn high_u16(self) -> u16;
                }

                impl U32 for u32 {
                    fn as_usize(self) -> usize {
                        #[cfg(debug_assertions)]
                        {
                            usize::try_from(self).expect("u32 overflowed usize")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as usize
                        }
                    }

                    fn low_u8(self) -> u8 {
                        self as u8
                    }

                    fn low_u16(self) -> u16 {
                        self as u16
                    }

                    fn high_u16(self) -> u16 {
                        (self >> 16) as u16
                    }
                }

                pub trait U64 {
                    fn as_usize(self) -> usize;
                    fn low_u8(self) -> u8;
                    fn low_u16(self) -> u16;
                    fn low_u32(self) -> u32;
                    fn high_u32(self) -> u32;
                }

                impl U64 for u64 {
                    fn as_usize(self) -> usize {
                        #[cfg(debug_assertions)]
                        {
                            usize::try_from(self).expect("u64 overflowed usize")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as usize
                        }
                    }

                    fn low_u8(self) -> u8 {
                        self as u8
                    }

                    fn low_u16(self) -> u16 {
                        self as u16
                    }

                    fn low_u32(self) -> u32 {
                        self as u32
                    }

                    fn high_u32(self) -> u32 {
                        (self >> 32) as u32
                    }
                }

                pub trait I32 {
                    fn as_usize(self) -> usize;
                    fn to_bits(self) -> u32;
                    fn from_bits(n: u32) -> i32;
                }

                impl I32 for i32 {
                    fn as_usize(self) -> usize {
                        #[cfg(debug_assertions)]
                        {
                            usize::try_from(self).expect("i32 overflowed usize")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as usize
                        }
                    }

                    fn to_bits(self) -> u32 {
                        self as u32
                    }

                    fn from_bits(n: u32) -> i32 {
                        n as i32
                    }
                }

                pub trait Usize {
                    fn as_u8(self) -> u8;
                    fn as_u16(self) -> u16;
                    fn as_u32(self) -> u32;
                    fn as_u64(self) -> u64;
                }

                impl Usize for usize {
                    fn as_u8(self) -> u8 {
                        #[cfg(debug_assertions)]
                        {
                            u8::try_from(self).expect("usize overflowed u8")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as u8
                        }
                    }

                    fn as_u16(self) -> u16 {
                        #[cfg(debug_assertions)]
                        {
                            u16::try_from(self).expect("usize overflowed u16")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as u16
                        }
                    }

                    fn as_u32(self) -> u32 {
                        #[cfg(debug_assertions)]
                        {
                            u32::try_from(self).expect("usize overflowed u32")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as u32
                        }
                    }

                    fn as_u64(self) -> u64 {
                        #[cfg(debug_assertions)]
                        {
                            u64::try_from(self).expect("usize overflowed u64")
                        }
                        #[cfg(not(debug_assertions))]
                        {
                            self as u64
                        }
                    }
                }

                pub trait Pointer {
                    fn as_usize(self) -> usize;
                }

                impl<T> Pointer for *const T {
                    fn as_usize(self) -> usize {
                        self as usize
                    }
                }

            }

            pub mod memchr
            {
                /*!
                This module defines simple wrapper routines for the memchr functions from the
                `memchr` crate. Basically, when the `memchr` crate is available, we use it,
                otherwise we use a naive implementation which is still pretty fast. */
                use ::
                {
                    *,
                };
                /*
                pub use self::inner::*;
                */
                #[cfg(feature = "perf-literal-substring")]
                pub(super) mod inner {
                    #[inline( always )]
                    pub fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
                        memchr::memchr(n1, haystack)
                    }

                    #[inline( always )]
                    pub fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
                        memchr::memchr2(n1, n2, haystack)
                    }

                    #[inline( always )]
                    pub fn memchr3(
                        n1: u8,
                        n2: u8,
                        n3: u8,
                        haystack: &[u8],
                    ) -> Option<usize> {
                        memchr::memchr3(n1, n2, n3, haystack)
                    }

                    #[inline( always )]
                    pub fn memrchr(n1: u8, haystack: &[u8]) -> Option<usize> {
                        memchr::memrchr(n1, haystack)
                    }

                    #[inline( always )]
                    pub fn memrchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
                        memchr::memrchr2(n1, n2, haystack)
                    }

                    #[inline( always )]
                    pub fn memrchr3(
                        n1: u8,
                        n2: u8,
                        n3: u8,
                        haystack: &[u8],
                    ) -> Option<usize> {
                        memchr::memrchr3(n1, n2, n3, haystack)
                    }
                }

                #[cfg(not(feature = "perf-literal-substring"))]
                pub(super) mod inner {
                    #[inline( always )]
                    pub fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
                        haystack.iter().position(|&b| b == n1)
                    }

                    #[inline( always )]
                    pub fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
                        haystack.iter().position(|&b| b == n1 || b == n2)
                    }

                    #[inline( always )]
                    pub fn memchr3(
                        n1: u8,
                        n2: u8,
                        n3: u8,
                        haystack: &[u8],
                    ) -> Option<usize> {
                        haystack.iter().position(|&b| b == n1 || b == n2 || b == n3)
                    }

                    #[inline( always )]
                    pub fn memrchr(n1: u8, haystack: &[u8]) -> Option<usize> {
                        haystack.iter().rposition(|&b| b == n1)
                    }

                    #[inline( always )]
                    pub fn memrchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
                        haystack.iter().rposition(|&b| b == n1 || b == n2)
                    }

                    #[inline( always )]
                    pub fn memrchr3(
                        n1: u8,
                        n2: u8,
                        n3: u8,
                        haystack: &[u8],
                    ) -> Option<usize> {
                        haystack.iter().rposition(|&b| b == n1 || b == n2 || b == n3)
                    }
                }
            }

            pub mod search
            {
                /*!
                Types and routines that support the search APIs of most regex engines. */
                use ::
                {
                    *,
                };
                /*
                use ::ops::{Range, RangeBounds};
                use crate::util::{escape::DebugByte, primitives::PatternID, utf8};
                */
                /// The parameters for a regex search including the haystack to search.
                #[derive(Clone)]
                pub struct Input<'h> {
                    haystack: &'h [u8],
                    span: Span,
                    anchored: Anchored,
                    earliest: bool,
                }

                impl<'h> Input<'h>
                {
                    /// Create a new search configuration for the given haystack.
                    #[inline] pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {
                        let haystack = haystack.as_ref();
                        Input {
                            haystack,
                            span: Span { start: 0, end: haystack.len() },
                            anchored: Anchored::No,
                            earliest: false,
                        }
                    }
                    /// Set the span for this search.
                    #[inline] pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {
                        self.set_span(span);
                        self
                    }
                    /// Like `Input::span`, but accepts any range instead.
                    #[inline] pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {
                        self.set_range(range);
                        self
                    }
                    /// Sets the anchor mode of a search.
                    #[inline] pub fn anchored(mut self, mode: Anchored) -> Input<'h> {
                        self.set_anchored(mode);
                        self
                    }
                    /// Whether to execute an "earliest" search or not.
                    #[inline] pub fn earliest(mut self, yes: bool) -> Input<'h> {
                        self.set_earliest(yes);
                        self
                    }
                    /// Set the span for this search configuration.
                    #[inline] pub fn set_span<S: Into<Span>>(&mut self, span: S) {
                        let span = span.into();
                        assert!(
                            span.end <= self.haystack.len()
                                && span.start <= span.end.wrapping_add(1),
                            "invalid span {:?} for haystack of length {}",
                            span,
                            self.haystack.len(),
                        );
                        self.span = span;
                    }
                    /// Set the span for this search configuration given any range.
                    #[inline] pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {
                        use ::ops::Bound;
                        let start = match range.start_bound() {
                            Bound::Included(&i) => i,
                            // Can this case ever happen? Range syntax doesn't support it...
                            Bound::Excluded(&i) => i.checked_add(1).unwrap(),
                            Bound::Unbounded => 0,
                        };
                        let end = match range.end_bound() {
                            Bound::Included(&i) => i.checked_add(1).unwrap(),
                            Bound::Excluded(&i) => i,
                            Bound::Unbounded => self.haystack().len(),
                        };
                        self.set_span(Span { start, end });
                    }
                    /// Set the starting offset for the span for this search configuration.
                    #[inline] pub fn set_start(&mut self, start: usize) {
                        self.set_span(Span { start, ..self.get_span() });
                    }
                    /// Set the ending offset for the span for this search configuration.
                    #[inline] pub fn set_end(&mut self, end: usize) {
                        self.set_span(Span { end, ..self.get_span() });
                    }
                    /// Set the anchor mode of a search.
                    #[inline] pub fn set_anchored(&mut self, mode: Anchored) {
                        self.anchored = mode;
                    }
                    /// Set whether the search should execute in "earliest" mode or not.
                    #[inline] pub fn set_earliest(&mut self, yes: bool) {
                        self.earliest = yes;
                    }
                    /// Return a borrow of the underlying haystack as a slice of bytes.
                    #[inline] pub fn haystack(&self) -> &'h [u8] {
                        self.haystack
                    }
                    /// Return the start position of this search.
                    #[inline] pub fn start(&self) -> usize {
                        self.get_span().start
                    }
                    /// Return the end position of this search.
                    #[inline] pub fn end(&self) -> usize {
                        self.get_span().end
                    }
                    /// Return the span for this search configuration.
                    #[inline] pub fn get_span(&self) -> Span {
                        self.span
                    }
                    /// Return the span as a range for this search configuration.
                    #[inline] pub fn get_range(&self) -> Range<usize> {
                        self.get_span().range()
                    }
                    /// Return the anchored mode for this search configuration.
                    #[inline] pub fn get_anchored(&self) -> Anchored {
                        self.anchored
                    }
                    /// Return whether this search should execute in "earliest" mode.
                    #[inline] pub fn get_earliest(&self) -> bool {
                        self.earliest
                    }
                    /// Return true if and only if this search can never return any other
                    #[inline] pub fn is_done(&self) -> bool {
                        self.get_span().start > self.get_span().end
                    }
                    /// Returns true if and only if the given offset in this search's haystack
                    #[inline] pub fn is_char_boundary(&self, offset: usize) -> bool {
                        utf8::is_boundary(self.haystack(), offset)
                    }
                }

                impl<'h> ::fmt::Debug for Input<'h> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        use crate::util::escape::DebugHaystack;

                        f.debug_struct("Input")
                            .field("haystack", &DebugHaystack(self.haystack()))
                            .field("span", &self.span)
                            .field("anchored", &self.anchored)
                            .field("earliest", &self.earliest)
                            .finish()
                    }
                }

                impl<'h, H: ?Sized + AsRef<[u8]>> From<&'h H> for Input<'h> {
                    fn from(haystack: &'h H) -> Input<'h> {
                        Input::new(haystack)
                    }
                }
                /// A representation of a span reported by a regex engine.
                #[derive(Clone, Copy, Eq, Hash, PartialEq)]
                pub struct Span
                {
                    /// The start offset of the span, inclusive.
                    pub start: usize,
                    /// The end offset of the span, exclusive.
                    pub end: usize,
                }

                impl Span
                {
                    /// Returns this span as a range.
                    #[inline] pub fn range(&self) -> Range<usize> {
                        Range::from(*self)
                    }
                    /// Returns true when this span is empty. That is, when `start >= end`.
                    #[inline] pub fn is_empty(&self) -> bool {
                        self.start >= self.end
                    }
                    /// Returns the length of this span.
                    #[inline] pub fn len(&self) -> usize {
                        self.end.saturating_sub(self.start)
                    }
                    /// Returns true when the given offset is contained within this span.
                    #[inline] pub fn contains(&self, offset: usize) -> bool {
                        !self.is_empty() && self.start <= offset && offset <= self.end
                    }
                    /// Returns a new span with `offset` added to this span's `start` and `end`
                    #[inline] pub fn offset(&self, offset: usize) -> Span {
                        Span { start: self.start + offset, end: self.end + offset }
                    }
                }

                impl ::fmt::Debug for Span {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "{}..{}", self.start, self.end)
                    }
                }

                impl ::ops::Index<Span> for [u8] {
                    type Output = [u8];

                    #[inline]
                    fn index(&self, index: Span) -> &[u8] {
                        &self[index.range()]
                    }
                }

                impl ::ops::IndexMut<Span> for [u8] {
                    #[inline]
                    fn index_mut(&mut self, index: Span) -> &mut [u8] {
                        &mut self[index.range()]
                    }
                }

                impl ::ops::Index<Span> for str {
                    type Output = str;

                    #[inline]
                    fn index(&self, index: Span) -> &str {
                        &self[index.range()]
                    }
                }

                impl From<Range<usize>> for Span {
                    #[inline]
                    fn from(range: Range<usize>) -> Span {
                        Span { start: range.start, end: range.end }
                    }
                }

                impl From<Span> for Range<usize> {
                    #[inline]
                    fn from(span: Span) -> Range<usize> {
                        Range { start: span.start, end: span.end }
                    }
                }

                impl PartialEq<Range<usize>> for Span {
                    #[inline]
                    fn eq(&self, range: &Range<usize>) -> bool {
                        self.start == range.start && self.end == range.end
                    }
                }

                impl PartialEq<Span> for Range<usize> {
                    #[inline]
                    fn eq(&self, span: &Span) -> bool {
                        self.start == span.start && self.end == span.end
                    }
                }
                /// A representation of "half" of a match reported by a DFA.
                #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
                pub struct HalfMatch
                {
                    /// The pattern ID.
                    pattern: PatternID,
                    /// The offset of the match.
                    offset: usize,
                }

                impl HalfMatch
                {
                    /// Create a new half match from a pattern ID and a byte offset.
                    #[inline] pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {
                        HalfMatch { pattern, offset }
                    }
                    /// Create a new half match from a pattern ID and a byte offset.
                    #[inline] pub fn must(pattern: usize, offset: usize) -> HalfMatch {
                        HalfMatch::new(PatternID::new(pattern).unwrap(), offset)
                    }
                    /// Returns the ID of the pattern that matched.
                    #[inline] pub fn pattern(&self) -> PatternID {
                        self.pattern
                    }
                    /// The position of the match.
                    #[inline] pub fn offset(&self) -> usize {
                        self.offset
                    }
                }
                /// A representation of a match reported by a regex engine.
                #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
                pub struct Match
                {
                    /// The pattern ID.
                    pattern: PatternID,
                    /// The underlying match span.
                    span: Span,
                }

                impl Match
                {
                    /// Create a new match from a pattern ID and a span.
                    #[inline] pub fn new<S: Into<Span>>(pattern: PatternID, span: S) -> Match {
                        let span: Span = span.into();
                        assert!(span.start <= span.end, "invalid match span");
                        Match { pattern, span }
                    }
                    /// Create a new match from a pattern ID and a byte offset span.
                    #[inline] pub fn must<S: Into<Span>>(pattern: usize, span: S) -> Match {
                        Match::new(PatternID::must(pattern), span)
                    }
                    /// Returns the ID of the pattern that matched.
                    #[inline] pub fn pattern(&self) -> PatternID {
                        self.pattern
                    }
                    /// The starting position of the match.
                    #[inline] pub fn start(&self) -> usize {
                        self.span().start
                    }
                    /// The ending position of the match.
                    #[inline] pub fn end(&self) -> usize {
                        self.span().end
                    }
                    /// Returns the match span as a range.
                    #[inline] pub fn range(&self) -> ::ops::Range<usize> {
                        self.span().range()
                    }
                    /// Returns the span for this match.
                    #[inline] pub fn span(&self) -> Span {
                        self.span
                    }
                    /// Returns true when the span in this match is empty.
                    #[inline] pub fn is_empty(&self) -> bool {
                        self.span().is_empty()
                    }
                    /// Returns the length of this match.
                    #[inline] pub fn len(&self) -> usize {
                        self.span().len()
                    }
                }
                /// A set of `PatternID`s.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct PatternSet
                {
                    /// The number of patterns set to 'true' in this set.
                    len: usize,
                    /// A map from PatternID to boolean of whether a pattern matches or not.
                    which: alloc::boxed::Box<[bool]>,
                }

                impl PatternSet
                {
                    /// Create a new set of pattern identifiers with the given capacity.
                    pub fn new(capacity: usize) -> PatternSet {
                        assert!(
                            capacity <= PatternID::LIMIT,
                            "pattern set capacity exceeds limit of {}",
                            PatternID::LIMIT,
                        );
                        PatternSet {
                            len: 0,
                            which: vec![false; capacity].into_boxed_slice(),
                        }
                    }
                    /// Clear this set such that it contains no pattern IDs.
                    pub fn clear(&mut self) {
                        self.len = 0;
                        for matched in self.which.iter_mut() {
                            *matched = false;
                        }
                    }
                    /// Return true if and only if the given pattern identifier is in this set.
                    pub fn contains(&self, pid: PatternID) -> bool {
                        pid.as_usize() < self.capacity() && self.which[pid]
                    }
                    /// Insert the given pattern identifier into this set and return `true` if
                    pub fn insert(&mut self, pid: PatternID) -> bool {
                        self.try_insert(pid)
                            .expect("PatternSet should have sufficient capacity")
                    }
                    /// Insert the given pattern identifier into this set and return `true` if
                    pub fn try_insert
                    (
                        &mut self,
                        pid: PatternID,
                    ) -> Result<bool, PatternSetInsertError> {
                        if pid.as_usize() >= self.capacity() {
                            return Err(PatternSetInsertError {
                                attempted: pid,
                                capacity: self.capacity(),
                            });
                        }
                        
                        if self.which[pid] {
                            return Ok(false);
                        }
                        self.len += 1;
                        self.which[pid] = true;
                        Ok(true)
                    }

                    /*
                    pub fn remove(&mut self, pid: PatternID) -> bool {
                        if !self.which[pid] {
                            return false;
                        }
                        self.len -= 1;
                        self.which[pid] = false;
                        true
                    }
                    */

                    /// Return true if and only if this set has no pattern identifiers in it.
                    pub fn is_empty(&self) -> bool {
                        self.len() == 0
                    }
                    /// Return true if and only if this set has the maximum number of pattern
                    pub fn is_full(&self) -> bool {
                        self.len() == self.capacity()
                    }
                    /// Returns the total number of pattern identifiers in this set.
                    pub fn len(&self) -> usize {
                        self.len
                    }
                    /// Returns the total number of pattern identifiers that may be stored
                    pub fn capacity(&self) -> usize {
                        self.which.len()
                    }
                    /// Returns an iterator over all pattern identifiers in this set.
                    pub fn iter(&self) -> PatternSetIter<'_> {
                        PatternSetIter { it: self.which.iter().enumerate() }
                    }
                }
                /// An error that occurs when a `PatternID` failed to insert into a
                #[derive(Clone, Debug)]
                pub struct PatternSetInsertError {
                    attempted: PatternID,
                    capacity: usize,
                }
                
                impl ::error::Error for PatternSetInsertError {}

                impl ::fmt::Display for PatternSetInsertError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(
                            f,
                            "failed to insert pattern ID {} into pattern set \
                            with insufficient capacity of {}",
                            self.attempted.as_usize(),
                            self.capacity,
                        )
                    }
                }
                /// An iterator over all pattern identifiers in a [`PatternSet`].
                #[derive(Clone, Debug)]
                pub struct PatternSetIter<'a> {
                    it: ::iter::Enumerate<::slice::Iter<'a, bool>>,
                }

                impl<'a> Iterator for PatternSetIter<'a> {
                    type Item = PatternID;

                    fn next(&mut self) -> Option<PatternID> {
                        while let Some((index, &yes)) = self.it.next()
                        {
                            if yes {
                                return Some(PatternID::new_unchecked(index));
                            }
                        }
                        None
                    }

                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.it.size_hint()
                    }
                }

                impl<'a> DoubleEndedIterator for PatternSetIter<'a> {
                    fn next_back(&mut self) -> Option<PatternID> {
                        while let Some((index, &yes)) = self.it.next_back()
                        {
                            if yes {
                                return Some(PatternID::new_unchecked(index));
                            }
                        }
                        None
                    }
                }
                /// The type of anchored search to perform.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum Anchored
                {
                    /// Run an unanchored search. This means a match may occur anywhere at or
                    No,
                    /// Run an anchored search. This means that a match must begin at the
                    Yes,
                    /// Run an anchored search for a specific pattern. This means that a match
                    Pattern(PatternID),
                }

                impl Anchored
                {
                    /// Returns true if and only if this anchor mode corresponds to any kind of
                    #[inline] pub fn is_anchored(&self) -> bool {
                        matches!(*self, Anchored::Yes | Anchored::Pattern(_))
                    }
                    /// Returns the pattern ID associated with this configuration if it is an
                    #[inline] pub fn pattern(&self) -> Option<PatternID> {
                        match *self {
                            Anchored::Pattern(pid) => Some(pid),
                            _ => None,
                        }
                    }
                }
                /// The kind of match semantics to use for a regex pattern.
                #[non_exhaustive]
                #[derive(Clone, Copy, Default, Debug, Eq, PartialEq)]
                pub enum MatchKind
                {
                    /// Report all possible matches.
                    All,
                    /// Report only the leftmost matches. When multiple leftmost matches exist,
                    #[default]
                    LeftmostFirst,
                }

                impl MatchKind {
                        pub fn continue_past_first_match(&self) -> bool {
                        *self == MatchKind::All
                    }
                }
                /// An error indicating that a search stopped before reporting whether a
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct MatchError(
                    #[cfg(feature = "alloc")] alloc::boxed::Box<MatchErrorKind>,
                    #[cfg(not(feature = "alloc"))] MatchErrorKind,
                );

                impl MatchError
                {
                    /// Create a new error value with the given kind.
                    pub fn new(kind: MatchErrorKind) -> MatchError {
                                {
                            MatchError(alloc::boxed::Box::new(kind))
                        }
                        #[cfg(not(feature = "alloc"))]
                        {
                            MatchError(kind)
                        }
                    }
                    /// Returns a reference to the underlying error kind.
                    pub fn kind(&self) -> &MatchErrorKind {
                        &self.0
                    }
                    /// Create a new "quit" error. The given `byte` corresponds to the value
                    pub fn quit(byte: u8, offset: usize) -> MatchError {
                        MatchError::new(MatchErrorKind::Quit { byte, offset })
                    }
                    /// Create a new "gave up" error. The given `offset` corresponds to the
                    pub fn gave_up(offset: usize) -> MatchError {
                        MatchError::new(MatchErrorKind::GaveUp { offset })
                    }
                    /// Create a new "haystack too long" error. The given `len` corresponds to
                    pub fn haystack_too_long(len: usize) -> MatchError {
                        MatchError::new(MatchErrorKind::HaystackTooLong { len })
                    }
                    /// Create a new "unsupported anchored" error. This occurs when the caller
                    pub fn unsupported_anchored(mode: Anchored) -> MatchError {
                        MatchError::new(MatchErrorKind::UnsupportedAnchored { mode })
                    }
                }
                /// The underlying kind of a [`MatchError`].
                #[non_exhaustive]
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub enum MatchErrorKind
                {
                    /// The search saw a "quit" byte at which it was instructed to stop
                    Quit {
                        /// The "quit" byte that was observed that caused the search to stop.
                        byte: u8,
                        /// The offset at which the quit byte was observed.
                        offset: usize,
                    },
                    /// The search, based on heuristics, determined that it would be better
                    GaveUp {
                        /// The offset at which the search stopped. This corresponds to the
                        offset: usize,
                    },
                    /// This error occurs if the haystack given to the regex engine was too
                    HaystackTooLong {
                        /// The length of the haystack that exceeded the limit.
                        len: usize,
                    },
                    /// An error indicating that a particular type of anchored search was
                    UnsupportedAnchored {
                        /// The anchored mode given that is unsupported.
                        mode: Anchored,
                    },
                }
                
                impl ::error::Error for MatchError {}

                impl ::fmt::Display for MatchError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        match *self.kind() {
                            MatchErrorKind::Quit { byte, offset } => write!(
                                f,
                                "quit search after observing byte {:?} at offset {}",
                                DebugByte(byte),
                                offset,
                            ),
                            MatchErrorKind::GaveUp { offset } => {
                                write!(f, "gave up searching at offset {offset}")
                            }
                            MatchErrorKind::HaystackTooLong { len } => {
                                write!(f, "haystack of length {len} is too long")
                            }
                            MatchErrorKind::UnsupportedAnchored { mode: Anchored::Yes } => {
                                write!(f, "anchored searches are not supported or enabled")
                            }
                            MatchErrorKind::UnsupportedAnchored { mode: Anchored::No } => {
                                write!(f, "unanchored searches are not supported or enabled")
                            }
                            MatchErrorKind::UnsupportedAnchored {
                                mode: Anchored::Pattern(pid),
                            } => {
                                write!(
                                    f,
                                    "anchored searches for a specific pattern ({}) are \
                                    not supported or enabled",
                                    pid.as_usize(),
                                )
                            }
                        }
                    }
                }
            }

            pub mod sparse_set
            {
                /*!
                This module defines a sparse set data structure. */
                use ::
                {
                    *,
                };
                /*
                use ::{vec, vec::Vec};
                use crate::util::primitives::StateID;
                */
                /// A pair of sparse sets.
                #[derive(Clone, Debug)]
                pub struct SparseSets {
                    pub set1: SparseSet,
                    pub set2: SparseSet,
                }

                impl SparseSets
                {
                    /// Create a new pair of sparse sets where each set has the given capacity.
                    pub fn new(capacity: usize) -> SparseSets {
                        SparseSets {
                            set1: SparseSet::new(capacity),
                            set2: SparseSet::new(capacity),
                        }
                    }
                    /// Resizes these sparse sets to have the new capacity given.
                    #[inline] pub fn resize(&mut self, new_capacity: usize) {
                        self.set1.resize(new_capacity);
                        self.set2.resize(new_capacity);
                    }
                    /// Clear both sparse sets.
                    pub fn clear(&mut self) {
                        self.set1.clear();
                        self.set2.clear();
                    }
                    /// Swap set1 with set2.
                    pub fn swap(&mut self) {
                        ::mem::swap(&mut self.set1, &mut self.set2);
                    }
                    /// Returns the memory usage, in bytes, used by this pair of sparse sets.
                    pub fn memory_usage(&self) -> usize {
                        self.set1.memory_usage() + self.set2.memory_usage()
                    }
                }
                /// A sparse set used for representing ordered NFA states.
                #[derive(Clone)]
                pub struct SparseSet
                {
                    /// The number of elements currently in this set.
                    len: usize,
                    /// Dense contains the ids in the order in which they were inserted.
                    dense: Vec<StateID>,
                    /// Sparse maps ids to their location in dense.
                    sparse: Vec<StateID>,
                }

                impl SparseSet
                {
                    /// Create a new sparse set with the given capacity.
                    #[inline] pub fn new(capacity: usize) -> SparseSet {
                        let mut set = SparseSet { len: 0, dense: vec![], sparse: vec![] };
                        set.resize(capacity);
                        set
                    }
                    /// Resizes this sparse set to have the new capacity given.
                    #[inline] pub fn resize(&mut self, new_capacity: usize) {
                        assert!(
                            new_capacity <= StateID::LIMIT,
                            "sparse set capacity cannot exceed {:?}",
                            StateID::LIMIT
                        );
                        self.clear();
                        self.dense.resize(new_capacity, StateID::ZERO);
                        self.sparse.resize(new_capacity, StateID::ZERO);
                    }
                    /// Returns the capacity of this set.
                    #[inline] pub fn capacity(&self) -> usize {
                        self.dense.len()
                    }
                    /// Returns the number of elements in this set.
                    #[inline] pub fn len(&self) -> usize {
                        self.len
                    }
                    /// Returns true if and only if this set is empty.
                    #[inline] pub fn is_empty(&self) -> bool {
                        self.len() == 0
                    }
                    /// Insert the state ID value into this set and return true if the given
                    #[inline( always )]
                    pub fn insert(&mut self, id: StateID) -> bool {
                        if self.contains(id) {
                            return false;
                        }

                        let i = self.len();
                        assert!(
                            i < self.capacity(),
                            "{:?} exceeds capacity of {:?} when inserting {:?}",
                            i,
                            self.capacity(),
                            id,
                        );
                        let index = StateID::new_unchecked(i);
                        self.dense[index] = id;
                        self.sparse[id] = index;
                        self.len += 1;
                        true
                    }
                    /// Returns true if and only if this set contains the given value.
                    #[inline] pub fn contains(&self, id: StateID) -> bool {
                        let index = self.sparse[id];
                        index.as_usize() < self.len() && self.dense[index] == id
                    }
                    /// Clear this set such that it has no members.
                    #[inline] pub fn clear(&mut self) {
                        self.len = 0;
                    }

                    #[inline] pub fn iter(&self) -> SparseSetIter<'_> {
                        SparseSetIter(self.dense[..self.len()].iter())
                    }
                    /// Returns the heap memory usage, in bytes, used by this sparse set.
                    #[inline] pub fn memory_usage(&self) -> usize {
                        self.dense.len() * StateID::SIZE + self.sparse.len() * StateID::SIZE
                    }
                }

                impl ::fmt::Debug for SparseSet {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let elements: Vec<StateID> = self.iter().collect();
                        f.debug_tuple("SparseSet").field(&elements).finish()
                    }
                }
                /// An iterator over all elements in a sparse set.
                #[derive(Debug)]
                pub struct SparseSetIter<'a>(::slice::Iter<'a, StateID>);

                impl<'a> Iterator for SparseSetIter<'a> {
                    type Item = StateID;

                    #[inline( always )]
                    fn next(&mut self) -> Option<StateID> {
                        self.0.next().copied()
                    }
                }
            }

            pub mod unicode_data
            {
                /*!
                This cfg should match the one in src/util/look.rs that uses perl_word. */
                use ::
                {
                    *,
                };
                /*
                */
                pub mod perl_word
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */

                    pub const PERL_WORD: &'static [(char, char)] = &[
                        ('0', '9'),
                        ('A', 'Z'),
                        ('_', '_'),
                        ('a', 'z'),
                        ('ª', 'ª'),
                        ('µ', 'µ'),
                        ('º', 'º'),
                        ('À', 'Ö'),
                        ('Ø', 'ö'),
                        ('ø', 'ˁ'),
                        ('ˆ', 'ˑ'),
                        ('ˠ', 'ˤ'),
                        ('ˬ', 'ˬ'),
                        ('ˮ', 'ˮ'),
                        ('\u{300}', 'ʹ'),
                        ('Ͷ', 'ͷ'),
                        ('ͺ', 'ͽ'),
                        ('Ϳ', 'Ϳ'),
                        ('Ά', 'Ά'),
                        ('Έ', 'Ί'),
                        ('Ό', 'Ό'),
                        ('Ύ', 'Ρ'),
                        ('Σ', 'ϵ'),
                        ('Ϸ', 'ҁ'),
                        ('\u{483}', 'ԯ'),
                        ('Ա', 'Ֆ'),
                        ('ՙ', 'ՙ'),
                        ('ՠ', 'ֈ'),
                        ('\u{591}', '\u{5bd}'),
                        ('\u{5bf}', '\u{5bf}'),
                        ('\u{5c1}', '\u{5c2}'),
                        ('\u{5c4}', '\u{5c5}'),
                        ('\u{5c7}', '\u{5c7}'),
                        ('א', 'ת'),
                        ('ׯ', 'ײ'),
                        ('\u{610}', '\u{61a}'),
                        ('ؠ', '٩'),
                        ('ٮ', 'ۓ'),
                        ('ە', '\u{6dc}'),
                        ('\u{6df}', '\u{6e8}'),
                        ('\u{6ea}', 'ۼ'),
                        ('ۿ', 'ۿ'),
                        ('ܐ', '\u{74a}'),
                        ('ݍ', 'ޱ'),
                        ('߀', 'ߵ'),
                        ('ߺ', 'ߺ'),
                        ('\u{7fd}', '\u{7fd}'),
                        ('ࠀ', '\u{82d}'),
                        ('ࡀ', '\u{85b}'),
                        ('ࡠ', 'ࡪ'),
                        ('ࡰ', 'ࢇ'),
                        ('ࢉ', 'ࢎ'),
                        ('\u{897}', '\u{8e1}'),
                        ('\u{8e3}', '\u{963}'),
                        ('०', '९'),
                        ('ॱ', 'ঃ'),
                        ('অ', 'ঌ'),
                        ('এ', 'ঐ'),
                        ('ও', 'ন'),
                        ('প', 'র'),
                        ('ল', 'ল'),
                        ('শ', 'হ'),
                        ('\u{9bc}', '\u{9c4}'),
                        ('ে', 'ৈ'),
                        ('ো', 'ৎ'),
                        ('\u{9d7}', '\u{9d7}'),
                        ('ড়', 'ঢ়'),
                        ('য়', '\u{9e3}'),
                        ('০', 'ৱ'),
                        ('ৼ', 'ৼ'),
                        ('\u{9fe}', '\u{9fe}'),
                        ('\u{a01}', 'ਃ'),
                        ('ਅ', 'ਊ'),
                        ('ਏ', 'ਐ'),
                        ('ਓ', 'ਨ'),
                        ('ਪ', 'ਰ'),
                        ('ਲ', 'ਲ਼'),
                        ('ਵ', 'ਸ਼'),
                        ('ਸ', 'ਹ'),
                        ('\u{a3c}', '\u{a3c}'),
                        ('ਾ', '\u{a42}'),
                        ('\u{a47}', '\u{a48}'),
                        ('\u{a4b}', '\u{a4d}'),
                        ('\u{a51}', '\u{a51}'),
                        ('ਖ਼', 'ੜ'),
                        ('ਫ਼', 'ਫ਼'),
                        ('੦', '\u{a75}'),
                        ('\u{a81}', 'ઃ'),
                        ('અ', 'ઍ'),
                        ('એ', 'ઑ'),
                        ('ઓ', 'ન'),
                        ('પ', 'ર'),
                        ('લ', 'ળ'),
                        ('વ', 'હ'),
                        ('\u{abc}', '\u{ac5}'),
                        ('\u{ac7}', 'ૉ'),
                        ('ો', '\u{acd}'),
                        ('ૐ', 'ૐ'),
                        ('ૠ', '\u{ae3}'),
                        ('૦', '૯'),
                        ('ૹ', '\u{aff}'),
                        ('\u{b01}', 'ଃ'),
                        ('ଅ', 'ଌ'),
                        ('ଏ', 'ଐ'),
                        ('ଓ', 'ନ'),
                        ('ପ', 'ର'),
                        ('ଲ', 'ଳ'),
                        ('ଵ', 'ହ'),
                        ('\u{b3c}', '\u{b44}'),
                        ('େ', 'ୈ'),
                        ('ୋ', '\u{b4d}'),
                        ('\u{b55}', '\u{b57}'),
                        ('ଡ଼', 'ଢ଼'),
                        ('ୟ', '\u{b63}'),
                        ('୦', '୯'),
                        ('ୱ', 'ୱ'),
                        ('\u{b82}', 'ஃ'),
                        ('அ', 'ஊ'),
                        ('எ', 'ஐ'),
                        ('ஒ', 'க'),
                        ('ங', 'ச'),
                        ('ஜ', 'ஜ'),
                        ('ஞ', 'ட'),
                        ('ண', 'த'),
                        ('ந', 'ப'),
                        ('ம', 'ஹ'),
                        ('\u{bbe}', 'ூ'),
                        ('ெ', 'ை'),
                        ('ொ', '\u{bcd}'),
                        ('ௐ', 'ௐ'),
                        ('\u{bd7}', '\u{bd7}'),
                        ('௦', '௯'),
                        ('\u{c00}', 'ఌ'),
                        ('ఎ', 'ఐ'),
                        ('ఒ', 'న'),
                        ('ప', 'హ'),
                        ('\u{c3c}', 'ౄ'),
                        ('\u{c46}', '\u{c48}'),
                        ('\u{c4a}', '\u{c4d}'),
                        ('\u{c55}', '\u{c56}'),
                        ('ౘ', 'ౚ'),
                        ('ౝ', 'ౝ'),
                        ('ౠ', '\u{c63}'),
                        ('౦', '౯'),
                        ('ಀ', 'ಃ'),
                        ('ಅ', 'ಌ'),
                        ('ಎ', 'ಐ'),
                        ('ಒ', 'ನ'),
                        ('ಪ', 'ಳ'),
                        ('ವ', 'ಹ'),
                        ('\u{cbc}', 'ೄ'),
                        ('\u{cc6}', '\u{cc8}'),
                        ('\u{cca}', '\u{ccd}'),
                        ('\u{cd5}', '\u{cd6}'),
                        ('ೝ', 'ೞ'),
                        ('ೠ', '\u{ce3}'),
                        ('೦', '೯'),
                        ('ೱ', 'ೳ'),
                        ('\u{d00}', 'ഌ'),
                        ('എ', 'ഐ'),
                        ('ഒ', '\u{d44}'),
                        ('െ', 'ൈ'),
                        ('ൊ', 'ൎ'),
                        ('ൔ', '\u{d57}'),
                        ('ൟ', '\u{d63}'),
                        ('൦', '൯'),
                        ('ൺ', 'ൿ'),
                        ('\u{d81}', 'ඃ'),
                        ('අ', 'ඖ'),
                        ('ක', 'න'),
                        ('ඳ', 'ර'),
                        ('ල', 'ල'),
                        ('ව', 'ෆ'),
                        ('\u{dca}', '\u{dca}'),
                        ('\u{dcf}', '\u{dd4}'),
                        ('\u{dd6}', '\u{dd6}'),
                        ('ෘ', '\u{ddf}'),
                        ('෦', '෯'),
                        ('ෲ', 'ෳ'),
                        ('ก', '\u{e3a}'),
                        ('เ', '\u{e4e}'),
                        ('๐', '๙'),
                        ('ກ', 'ຂ'),
                        ('ຄ', 'ຄ'),
                        ('ຆ', 'ຊ'),
                        ('ຌ', 'ຣ'),
                        ('ລ', 'ລ'),
                        ('ວ', 'ຽ'),
                        ('ເ', 'ໄ'),
                        ('ໆ', 'ໆ'),
                        ('\u{ec8}', '\u{ece}'),
                        ('໐', '໙'),
                        ('ໜ', 'ໟ'),
                        ('ༀ', 'ༀ'),
                        ('\u{f18}', '\u{f19}'),
                        ('༠', '༩'),
                        ('\u{f35}', '\u{f35}'),
                        ('\u{f37}', '\u{f37}'),
                        ('\u{f39}', '\u{f39}'),
                        ('༾', 'ཇ'),
                        ('ཉ', 'ཬ'),
                        ('\u{f71}', '\u{f84}'),
                        ('\u{f86}', '\u{f97}'),
                        ('\u{f99}', '\u{fbc}'),
                        ('\u{fc6}', '\u{fc6}'),
                        ('က', '၉'),
                        ('ၐ', '\u{109d}'),
                        ('Ⴀ', 'Ⴥ'),
                        ('Ⴧ', 'Ⴧ'),
                        ('Ⴭ', 'Ⴭ'),
                        ('ა', 'ჺ'),
                        ('ჼ', 'ቈ'),
                        ('ቊ', 'ቍ'),
                        ('ቐ', 'ቖ'),
                        ('ቘ', 'ቘ'),
                        ('ቚ', 'ቝ'),
                        ('በ', 'ኈ'),
                        ('ኊ', 'ኍ'),
                        ('ነ', 'ኰ'),
                        ('ኲ', 'ኵ'),
                        ('ኸ', 'ኾ'),
                        ('ዀ', 'ዀ'),
                        ('ዂ', 'ዅ'),
                        ('ወ', 'ዖ'),
                        ('ዘ', 'ጐ'),
                        ('ጒ', 'ጕ'),
                        ('ጘ', 'ፚ'),
                        ('\u{135d}', '\u{135f}'),
                        ('ᎀ', 'ᎏ'),
                        ('Ꭰ', 'Ᏽ'),
                        ('ᏸ', 'ᏽ'),
                        ('ᐁ', 'ᙬ'),
                        ('ᙯ', 'ᙿ'),
                        ('ᚁ', 'ᚚ'),
                        ('ᚠ', 'ᛪ'),
                        ('ᛮ', 'ᛸ'),
                        ('ᜀ', '\u{1715}'),
                        ('ᜟ', '\u{1734}'),
                        ('ᝀ', '\u{1753}'),
                        ('ᝠ', 'ᝬ'),
                        ('ᝮ', 'ᝰ'),
                        ('\u{1772}', '\u{1773}'),
                        ('ក', '\u{17d3}'),
                        ('ៗ', 'ៗ'),
                        ('ៜ', '\u{17dd}'),
                        ('០', '៩'),
                        ('\u{180b}', '\u{180d}'),
                        ('\u{180f}', '᠙'),
                        ('ᠠ', 'ᡸ'),
                        ('ᢀ', 'ᢪ'),
                        ('ᢰ', 'ᣵ'),
                        ('ᤀ', 'ᤞ'),
                        ('\u{1920}', 'ᤫ'),
                        ('ᤰ', '\u{193b}'),
                        ('᥆', 'ᥭ'),
                        ('ᥰ', 'ᥴ'),
                        ('ᦀ', 'ᦫ'),
                        ('ᦰ', 'ᧉ'),
                        ('᧐', '᧙'),
                        ('ᨀ', '\u{1a1b}'),
                        ('ᨠ', '\u{1a5e}'),
                        ('\u{1a60}', '\u{1a7c}'),
                        ('\u{1a7f}', '᪉'),
                        ('᪐', '᪙'),
                        ('ᪧ', 'ᪧ'),
                        ('\u{1ab0}', '\u{1ace}'),
                        ('\u{1b00}', 'ᭌ'),
                        ('᭐', '᭙'),
                        ('\u{1b6b}', '\u{1b73}'),
                        ('\u{1b80}', '\u{1bf3}'),
                        ('ᰀ', '\u{1c37}'),
                        ('᱀', '᱉'),
                        ('ᱍ', 'ᱽ'),
                        ('ᲀ', 'ᲊ'),
                        ('Ა', 'Ჺ'),
                        ('Ჽ', 'Ჿ'),
                        ('\u{1cd0}', '\u{1cd2}'),
                        ('\u{1cd4}', 'ᳺ'),
                        ('ᴀ', 'ἕ'),
                        ('Ἐ', 'Ἕ'),
                        ('ἠ', 'ὅ'),
                        ('Ὀ', 'Ὅ'),
                        ('ὐ', 'ὗ'),
                        ('Ὑ', 'Ὑ'),
                        ('Ὓ', 'Ὓ'),
                        ('Ὕ', 'Ὕ'),
                        ('Ὗ', 'ώ'),
                        ('ᾀ', 'ᾴ'),
                        ('ᾶ', 'ᾼ'),
                        ('ι', 'ι'),
                        ('ῂ', 'ῄ'),
                        ('ῆ', 'ῌ'),
                        ('ῐ', 'ΐ'),
                        ('ῖ', 'Ί'),
                        ('ῠ', 'Ῥ'),
                        ('ῲ', 'ῴ'),
                        ('ῶ', 'ῼ'),
                        ('\u{200c}', '\u{200d}'),
                        ('‿', '⁀'),
                        ('⁔', '⁔'),
                        ('ⁱ', 'ⁱ'),
                        ('ⁿ', 'ⁿ'),
                        ('ₐ', 'ₜ'),
                        ('\u{20d0}', '\u{20f0}'),
                        ('ℂ', 'ℂ'),
                        ('ℇ', 'ℇ'),
                        ('ℊ', 'ℓ'),
                        ('ℕ', 'ℕ'),
                        ('ℙ', 'ℝ'),
                        ('ℤ', 'ℤ'),
                        ('Ω', 'Ω'),
                        ('ℨ', 'ℨ'),
                        ('K', 'ℭ'),
                        ('ℯ', 'ℹ'),
                        ('ℼ', 'ℿ'),
                        ('ⅅ', 'ⅉ'),
                        ('ⅎ', 'ⅎ'),
                        ('Ⅰ', 'ↈ'),
                        ('Ⓐ', 'ⓩ'),
                        ('Ⰰ', 'ⳤ'),
                        ('Ⳬ', 'ⳳ'),
                        ('ⴀ', 'ⴥ'),
                        ('ⴧ', 'ⴧ'),
                        ('ⴭ', 'ⴭ'),
                        ('ⴰ', 'ⵧ'),
                        ('ⵯ', 'ⵯ'),
                        ('\u{2d7f}', 'ⶖ'),
                        ('ⶠ', 'ⶦ'),
                        ('ⶨ', 'ⶮ'),
                        ('ⶰ', 'ⶶ'),
                        ('ⶸ', 'ⶾ'),
                        ('ⷀ', 'ⷆ'),
                        ('ⷈ', 'ⷎ'),
                        ('ⷐ', 'ⷖ'),
                        ('ⷘ', 'ⷞ'),
                        ('\u{2de0}', '\u{2dff}'),
                        ('ⸯ', 'ⸯ'),
                        ('々', '〇'),
                        ('〡', '\u{302f}'),
                        ('〱', '〵'),
                        ('〸', '〼'),
                        ('ぁ', 'ゖ'),
                        ('\u{3099}', '\u{309a}'),
                        ('ゝ', 'ゟ'),
                        ('ァ', 'ヺ'),
                        ('ー', 'ヿ'),
                        ('ㄅ', 'ㄯ'),
                        ('ㄱ', 'ㆎ'),
                        ('ㆠ', 'ㆿ'),
                        ('ㇰ', 'ㇿ'),
                        ('㐀', '䶿'),
                        ('一', 'ꒌ'),
                        ('ꓐ', 'ꓽ'),
                        ('ꔀ', 'ꘌ'),
                        ('ꘐ', 'ꘫ'),
                        ('Ꙁ', '\u{a672}'),
                        ('\u{a674}', '\u{a67d}'),
                        ('ꙿ', '\u{a6f1}'),
                        ('ꜗ', 'ꜟ'),
                        ('Ꜣ', 'ꞈ'),
                        ('Ꞌ', 'ꟍ'),
                        ('Ꟑ', 'ꟑ'),
                        ('ꟓ', 'ꟓ'),
                        ('ꟕ', 'Ƛ'),
                        ('ꟲ', 'ꠧ'),
                        ('\u{a82c}', '\u{a82c}'),
                        ('ꡀ', 'ꡳ'),
                        ('ꢀ', '\u{a8c5}'),
                        ('꣐', '꣙'),
                        ('\u{a8e0}', 'ꣷ'),
                        ('ꣻ', 'ꣻ'),
                        ('ꣽ', '\u{a92d}'),
                        ('ꤰ', '\u{a953}'),
                        ('ꥠ', 'ꥼ'),
                        ('\u{a980}', '\u{a9c0}'),
                        ('ꧏ', '꧙'),
                        ('ꧠ', 'ꧾ'),
                        ('ꨀ', '\u{aa36}'),
                        ('ꩀ', 'ꩍ'),
                        ('꩐', '꩙'),
                        ('ꩠ', 'ꩶ'),
                        ('ꩺ', 'ꫂ'),
                        ('ꫛ', 'ꫝ'),
                        ('ꫠ', 'ꫯ'),
                        ('ꫲ', '\u{aaf6}'),
                        ('ꬁ', 'ꬆ'),
                        ('ꬉ', 'ꬎ'),
                        ('ꬑ', 'ꬖ'),
                        ('ꬠ', 'ꬦ'),
                        ('ꬨ', 'ꬮ'),
                        ('ꬰ', 'ꭚ'),
                        ('ꭜ', 'ꭩ'),
                        ('ꭰ', 'ꯪ'),
                        ('꯬', '\u{abed}'),
                        ('꯰', '꯹'),
                        ('가', '힣'),
                        ('ힰ', 'ퟆ'),
                        ('ퟋ', 'ퟻ'),
                        ('豈', '舘'),
                        ('並', '龎'),
                        ('ﬀ', 'ﬆ'),
                        ('ﬓ', 'ﬗ'),
                        ('יִ', 'ﬨ'),
                        ('שׁ', 'זּ'),
                        ('טּ', 'לּ'),
                        ('מּ', 'מּ'),
                        ('נּ', 'סּ'),
                        ('ףּ', 'פּ'),
                        ('צּ', 'ﮱ'),
                        ('ﯓ', 'ﴽ'),
                        ('ﵐ', 'ﶏ'),
                        ('ﶒ', 'ﷇ'),
                        ('ﷰ', 'ﷻ'),
                        ('\u{fe00}', '\u{fe0f}'),
                        ('\u{fe20}', '\u{fe2f}'),
                        ('︳', '︴'),
                        ('﹍', '﹏'),
                        ('ﹰ', 'ﹴ'),
                        ('ﹶ', 'ﻼ'),
                        ('０', '９'),
                        ('Ａ', 'Ｚ'),
                        ('＿', '＿'),
                        ('ａ', 'ｚ'),
                        ('ｦ', 'ﾾ'),
                        ('ￂ', 'ￇ'),
                        ('ￊ', 'ￏ'),
                        ('ￒ', 'ￗ'),
                        ('ￚ', 'ￜ'),
                        ('𐀀', '𐀋'),
                        ('𐀍', '𐀦'),
                        ('𐀨', '𐀺'),
                        ('𐀼', '𐀽'),
                        ('𐀿', '𐁍'),
                        ('𐁐', '𐁝'),
                        ('𐂀', '𐃺'),
                        ('𐅀', '𐅴'),
                        ('\u{101fd}', '\u{101fd}'),
                        ('𐊀', '𐊜'),
                        ('𐊠', '𐋐'),
                        ('\u{102e0}', '\u{102e0}'),
                        ('𐌀', '𐌟'),
                        ('𐌭', '𐍊'),
                        ('𐍐', '\u{1037a}'),
                        ('𐎀', '𐎝'),
                        ('𐎠', '𐏃'),
                        ('𐏈', '𐏏'),
                        ('𐏑', '𐏕'),
                        ('𐐀', '𐒝'),
                        ('𐒠', '𐒩'),
                        ('𐒰', '𐓓'),
                        ('𐓘', '𐓻'),
                        ('𐔀', '𐔧'),
                        ('𐔰', '𐕣'),
                        ('𐕰', '𐕺'),
                        ('𐕼', '𐖊'),
                        ('𐖌', '𐖒'),
                        ('𐖔', '𐖕'),
                        ('𐖗', '𐖡'),
                        ('𐖣', '𐖱'),
                        ('𐖳', '𐖹'),
                        ('𐖻', '𐖼'),
                        ('𐗀', '𐗳'),
                        ('𐘀', '𐜶'),
                        ('𐝀', '𐝕'),
                        ('𐝠', '𐝧'),
                        ('𐞀', '𐞅'),
                        ('𐞇', '𐞰'),
                        ('𐞲', '𐞺'),
                        ('𐠀', '𐠅'),
                        ('𐠈', '𐠈'),
                        ('𐠊', '𐠵'),
                        ('𐠷', '𐠸'),
                        ('𐠼', '𐠼'),
                        ('𐠿', '𐡕'),
                        ('𐡠', '𐡶'),
                        ('𐢀', '𐢞'),
                        ('𐣠', '𐣲'),
                        ('𐣴', '𐣵'),
                        ('𐤀', '𐤕'),
                        ('𐤠', '𐤹'),
                        ('𐦀', '𐦷'),
                        ('𐦾', '𐦿'),
                        ('𐨀', '\u{10a03}'),
                        ('\u{10a05}', '\u{10a06}'),
                        ('\u{10a0c}', '𐨓'),
                        ('𐨕', '𐨗'),
                        ('𐨙', '𐨵'),
                        ('\u{10a38}', '\u{10a3a}'),
                        ('\u{10a3f}', '\u{10a3f}'),
                        ('𐩠', '𐩼'),
                        ('𐪀', '𐪜'),
                        ('𐫀', '𐫇'),
                        ('𐫉', '\u{10ae6}'),
                        ('𐬀', '𐬵'),
                        ('𐭀', '𐭕'),
                        ('𐭠', '𐭲'),
                        ('𐮀', '𐮑'),
                        ('𐰀', '𐱈'),
                        ('𐲀', '𐲲'),
                        ('𐳀', '𐳲'),
                        ('𐴀', '\u{10d27}'),
                        ('𐴰', '𐴹'),
                        ('𐵀', '𐵥'),
                        ('\u{10d69}', '\u{10d6d}'),
                        ('𐵯', '𐶅'),
                        ('𐺀', '𐺩'),
                        ('\u{10eab}', '\u{10eac}'),
                        ('𐺰', '𐺱'),
                        ('𐻂', '𐻄'),
                        ('\u{10efc}', '𐼜'),
                        ('𐼧', '𐼧'),
                        ('𐼰', '\u{10f50}'),
                        ('𐽰', '\u{10f85}'),
                        ('𐾰', '𐿄'),
                        ('𐿠', '𐿶'),
                        ('𑀀', '\u{11046}'),
                        ('𑁦', '𑁵'),
                        ('\u{1107f}', '\u{110ba}'),
                        ('\u{110c2}', '\u{110c2}'),
                        ('𑃐', '𑃨'),
                        ('𑃰', '𑃹'),
                        ('\u{11100}', '\u{11134}'),
                        ('𑄶', '𑄿'),
                        ('𑅄', '𑅇'),
                        ('𑅐', '\u{11173}'),
                        ('𑅶', '𑅶'),
                        ('\u{11180}', '𑇄'),
                        ('\u{111c9}', '\u{111cc}'),
                        ('𑇎', '𑇚'),
                        ('𑇜', '𑇜'),
                        ('𑈀', '𑈑'),
                        ('𑈓', '\u{11237}'),
                        ('\u{1123e}', '\u{11241}'),
                        ('𑊀', '𑊆'),
                        ('𑊈', '𑊈'),
                        ('𑊊', '𑊍'),
                        ('𑊏', '𑊝'),
                        ('𑊟', '𑊨'),
                        ('𑊰', '\u{112ea}'),
                        ('𑋰', '𑋹'),
                        ('\u{11300}', '𑌃'),
                        ('𑌅', '𑌌'),
                        ('𑌏', '𑌐'),
                        ('𑌓', '𑌨'),
                        ('𑌪', '𑌰'),
                        ('𑌲', '𑌳'),
                        ('𑌵', '𑌹'),
                        ('\u{1133b}', '𑍄'),
                        ('𑍇', '𑍈'),
                        ('𑍋', '\u{1134d}'),
                        ('𑍐', '𑍐'),
                        ('\u{11357}', '\u{11357}'),
                        ('𑍝', '𑍣'),
                        ('\u{11366}', '\u{1136c}'),
                        ('\u{11370}', '\u{11374}'),
                        ('𑎀', '𑎉'),
                        ('𑎋', '𑎋'),
                        ('𑎎', '𑎎'),
                        ('𑎐', '𑎵'),
                        ('𑎷', '\u{113c0}'),
                        ('\u{113c2}', '\u{113c2}'),
                        ('\u{113c5}', '\u{113c5}'),
                        ('\u{113c7}', '𑏊'),
                        ('𑏌', '𑏓'),
                        ('\u{113e1}', '\u{113e2}'),
                        ('𑐀', '𑑊'),
                        ('𑑐', '𑑙'),
                        ('\u{1145e}', '𑑡'),
                        ('𑒀', '𑓅'),
                        ('𑓇', '𑓇'),
                        ('𑓐', '𑓙'),
                        ('𑖀', '\u{115b5}'),
                        ('𑖸', '\u{115c0}'),
                        ('𑗘', '\u{115dd}'),
                        ('𑘀', '\u{11640}'),
                        ('𑙄', '𑙄'),
                        ('𑙐', '𑙙'),
                        ('𑚀', '𑚸'),
                        ('𑛀', '𑛉'),
                        ('𑛐', '𑛣'),
                        ('𑜀', '𑜚'),
                        ('\u{1171d}', '\u{1172b}'),
                        ('𑜰', '𑜹'),
                        ('𑝀', '𑝆'),
                        ('𑠀', '\u{1183a}'),
                        ('𑢠', '𑣩'),
                        ('𑣿', '𑤆'),
                        ('𑤉', '𑤉'),
                        ('𑤌', '𑤓'),
                        ('𑤕', '𑤖'),
                        ('𑤘', '𑤵'),
                        ('𑤷', '𑤸'),
                        ('\u{1193b}', '\u{11943}'),
                        ('𑥐', '𑥙'),
                        ('𑦠', '𑦧'),
                        ('𑦪', '\u{119d7}'),
                        ('\u{119da}', '𑧡'),
                        ('𑧣', '𑧤'),
                        ('𑨀', '\u{11a3e}'),
                        ('\u{11a47}', '\u{11a47}'),
                        ('𑩐', '\u{11a99}'),
                        ('𑪝', '𑪝'),
                        ('𑪰', '𑫸'),
                        ('𑯀', '𑯠'),
                        ('𑯰', '𑯹'),
                        ('𑰀', '𑰈'),
                        ('𑰊', '\u{11c36}'),
                        ('\u{11c38}', '𑱀'),
                        ('𑱐', '𑱙'),
                        ('𑱲', '𑲏'),
                        ('\u{11c92}', '\u{11ca7}'),
                        ('𑲩', '\u{11cb6}'),
                        ('𑴀', '𑴆'),
                        ('𑴈', '𑴉'),
                        ('𑴋', '\u{11d36}'),
                        ('\u{11d3a}', '\u{11d3a}'),
                        ('\u{11d3c}', '\u{11d3d}'),
                        ('\u{11d3f}', '\u{11d47}'),
                        ('𑵐', '𑵙'),
                        ('𑵠', '𑵥'),
                        ('𑵧', '𑵨'),
                        ('𑵪', '𑶎'),
                        ('\u{11d90}', '\u{11d91}'),
                        ('𑶓', '𑶘'),
                        ('𑶠', '𑶩'),
                        ('𑻠', '𑻶'),
                        ('\u{11f00}', '𑼐'),
                        ('𑼒', '\u{11f3a}'),
                        ('𑼾', '\u{11f42}'),
                        ('𑽐', '\u{11f5a}'),
                        ('𑾰', '𑾰'),
                        ('𒀀', '𒎙'),
                        ('𒐀', '𒑮'),
                        ('𒒀', '𒕃'),
                        ('𒾐', '𒿰'),
                        ('𓀀', '𓐯'),
                        ('\u{13440}', '\u{13455}'),
                        ('𓑠', '𔏺'),
                        ('𔐀', '𔙆'),
                        ('𖄀', '𖄹'),
                        ('𖠀', '𖨸'),
                        ('𖩀', '𖩞'),
                        ('𖩠', '𖩩'),
                        ('𖩰', '𖪾'),
                        ('𖫀', '𖫉'),
                        ('𖫐', '𖫭'),
                        ('\u{16af0}', '\u{16af4}'),
                        ('𖬀', '\u{16b36}'),
                        ('𖭀', '𖭃'),
                        ('𖭐', '𖭙'),
                        ('𖭣', '𖭷'),
                        ('𖭽', '𖮏'),
                        ('𖵀', '𖵬'),
                        ('𖵰', '𖵹'),
                        ('𖹀', '𖹿'),
                        ('𖼀', '𖽊'),
                        ('\u{16f4f}', '𖾇'),
                        ('\u{16f8f}', '𖾟'),
                        ('𖿠', '𖿡'),
                        ('𖿣', '\u{16fe4}'),
                        ('\u{16ff0}', '\u{16ff1}'),
                        ('𗀀', '𘟷'),
                        ('𘠀', '𘳕'),
                        ('𘳿', '𘴈'),
                        ('𚿰', '𚿳'),
                        ('𚿵', '𚿻'),
                        ('𚿽', '𚿾'),
                        ('𛀀', '𛄢'),
                        ('𛄲', '𛄲'),
                        ('𛅐', '𛅒'),
                        ('𛅕', '𛅕'),
                        ('𛅤', '𛅧'),
                        ('𛅰', '𛋻'),
                        ('𛰀', '𛱪'),
                        ('𛱰', '𛱼'),
                        ('𛲀', '𛲈'),
                        ('𛲐', '𛲙'),
                        ('\u{1bc9d}', '\u{1bc9e}'),
                        ('𜳰', '𜳹'),
                        ('\u{1cf00}', '\u{1cf2d}'),
                        ('\u{1cf30}', '\u{1cf46}'),
                        ('\u{1d165}', '\u{1d169}'),
                        ('\u{1d16d}', '\u{1d172}'),
                        ('\u{1d17b}', '\u{1d182}'),
                        ('\u{1d185}', '\u{1d18b}'),
                        ('\u{1d1aa}', '\u{1d1ad}'),
                        ('\u{1d242}', '\u{1d244}'),
                        ('𝐀', '𝑔'),
                        ('𝑖', '𝒜'),
                        ('𝒞', '𝒟'),
                        ('𝒢', '𝒢'),
                        ('𝒥', '𝒦'),
                        ('𝒩', '𝒬'),
                        ('𝒮', '𝒹'),
                        ('𝒻', '𝒻'),
                        ('𝒽', '𝓃'),
                        ('𝓅', '𝔅'),
                        ('𝔇', '𝔊'),
                        ('𝔍', '𝔔'),
                        ('𝔖', '𝔜'),
                        ('𝔞', '𝔹'),
                        ('𝔻', '𝔾'),
                        ('𝕀', '𝕄'),
                        ('𝕆', '𝕆'),
                        ('𝕊', '𝕐'),
                        ('𝕒', '𝚥'),
                        ('𝚨', '𝛀'),
                        ('𝛂', '𝛚'),
                        ('𝛜', '𝛺'),
                        ('𝛼', '𝜔'),
                        ('𝜖', '𝜴'),
                        ('𝜶', '𝝎'),
                        ('𝝐', '𝝮'),
                        ('𝝰', '𝞈'),
                        ('𝞊', '𝞨'),
                        ('𝞪', '𝟂'),
                        ('𝟄', '𝟋'),
                        ('𝟎', '𝟿'),
                        ('\u{1da00}', '\u{1da36}'),
                        ('\u{1da3b}', '\u{1da6c}'),
                        ('\u{1da75}', '\u{1da75}'),
                        ('\u{1da84}', '\u{1da84}'),
                        ('\u{1da9b}', '\u{1da9f}'),
                        ('\u{1daa1}', '\u{1daaf}'),
                        ('𝼀', '𝼞'),
                        ('𝼥', '𝼪'),
                        ('\u{1e000}', '\u{1e006}'),
                        ('\u{1e008}', '\u{1e018}'),
                        ('\u{1e01b}', '\u{1e021}'),
                        ('\u{1e023}', '\u{1e024}'),
                        ('\u{1e026}', '\u{1e02a}'),
                        ('𞀰', '𞁭'),
                        ('\u{1e08f}', '\u{1e08f}'),
                        ('𞄀', '𞄬'),
                        ('\u{1e130}', '𞄽'),
                        ('𞅀', '𞅉'),
                        ('𞅎', '𞅎'),
                        ('𞊐', '\u{1e2ae}'),
                        ('𞋀', '𞋹'),
                        ('𞓐', '𞓹'),
                        ('𞗐', '𞗺'),
                        ('𞟠', '𞟦'),
                        ('𞟨', '𞟫'),
                        ('𞟭', '𞟮'),
                        ('𞟰', '𞟾'),
                        ('𞠀', '𞣄'),
                        ('\u{1e8d0}', '\u{1e8d6}'),
                        ('𞤀', '𞥋'),
                        ('𞥐', '𞥙'),
                        ('𞸀', '𞸃'),
                        ('𞸅', '𞸟'),
                        ('𞸡', '𞸢'),
                        ('𞸤', '𞸤'),
                        ('𞸧', '𞸧'),
                        ('𞸩', '𞸲'),
                        ('𞸴', '𞸷'),
                        ('𞸹', '𞸹'),
                        ('𞸻', '𞸻'),
                        ('𞹂', '𞹂'),
                        ('𞹇', '𞹇'),
                        ('𞹉', '𞹉'),
                        ('𞹋', '𞹋'),
                        ('𞹍', '𞹏'),
                        ('𞹑', '𞹒'),
                        ('𞹔', '𞹔'),
                        ('𞹗', '𞹗'),
                        ('𞹙', '𞹙'),
                        ('𞹛', '𞹛'),
                        ('𞹝', '𞹝'),
                        ('𞹟', '𞹟'),
                        ('𞹡', '𞹢'),
                        ('𞹤', '𞹤'),
                        ('𞹧', '𞹪'),
                        ('𞹬', '𞹲'),
                        ('𞹴', '𞹷'),
                        ('𞹹', '𞹼'),
                        ('𞹾', '𞹾'),
                        ('𞺀', '𞺉'),
                        ('𞺋', '𞺛'),
                        ('𞺡', '𞺣'),
                        ('𞺥', '𞺩'),
                        ('𞺫', '𞺻'),
                        ('🄰', '🅉'),
                        ('🅐', '🅩'),
                        ('🅰', '🆉'),
                        ('🯰', '🯹'),
                        ('𠀀', '𪛟'),
                        ('𪜀', '𫜹'),
                        ('𫝀', '𫠝'),
                        ('𫠠', '𬺡'),
                        ('𬺰', '𮯠'),
                        ('𮯰', '𮹝'),
                        ('丽', '𪘀'),
                        ('𰀀', '𱍊'),
                        ('𱍐', '𲎯'),
                        ('\u{e0100}', '\u{e01ef}'),
                    ];
                }
            }

            pub mod utf8
            {
                /*!
                Utilities for dealing with UTF-8. */
                use ::
                {
                    *,
                };
                /*
                */
                /// Decodes the next UTF-8 encoded codepoint from the given byte slice.
                #[inline( always )] pub fn decode(bytes: &[u8]) -> Option<Result<char, u8>> {
                    if bytes.is_empty() {
                        return None;
                    }
                    let len = match len(bytes[0]) {
                        None => return Some(Err(bytes[0])),
                        Some(len) if len > bytes.len() => return Some(Err(bytes[0])),
                        Some(1) => return Some(Ok(char::from(bytes[0]))),
                        Some(len) => len,
                    };
                    match ::str::from_utf8(&bytes[..len]) {
                        Ok(s) => Some(Ok(s.chars().next().unwrap())),
                        Err(_) => Some(Err(bytes[0])),
                    }
                }
                /// Decodes the last UTF-8 encoded codepoint from the given byte slice.
                #[inline( always )] pub fn decode_last(bytes: &[u8]) -> Option<Result<char, u8>> {
                    if bytes.is_empty() {
                        return None;
                    }
                    let mut start = bytes.len() - 1;
                    let limit = bytes.len().saturating_sub(4);
                    
                    while start > limit && !is_leading_or_invalid_byte(bytes[start]) {
                        start -= 1;
                    }
                    match decode(&bytes[start..]) {
                        None => None,
                        Some(Ok(ch)) => Some(Ok(ch)),
                        Some(Err(_)) => Some(Err(bytes[bytes.len() - 1])),
                    }
                }
                /// Given a UTF-8 leading byte, this returns the total number of code units
                #[inline( always )] fn len(byte: u8) -> Option<usize> {
                    match byte {
                        0b0000_0000..=0b0111_1111 => Some(1),
                        0b1000_0000..=0b1011_1111 => None,
                        0b1100_0000..=0b1101_1111 => Some(2),
                        0b1110_0000..=0b1110_1111 => Some(3),
                        0b1111_0000..=0b1111_0111 => Some(4),
                        _ => None,
                    }
                }
            }
        }
    }

    pub mod builders
    {
        /*
        This module defines an internal builder that encapsulates all interaction with meta::Regex construction, 
        and then 4 public API builders that wrap around it. */
        use ::
        {
            regex::
            {
                automata::
                {
                    meta::{ self },
                    nfa::thompson::{ WhichCaptures },
                    util::{ syntax }, MatchKind,
                },
                error::{ Error },
            },
            string::{ String, ToString },
            sync::{ Arc },
            vec::{ self, Vec },
            *,
        };
        /*
        */
        /// A builder for constructing a `Regex`, `bytes::Regex`, `RegexSet` or a `bytes::RegexSet`.
        #[derive(Clone, Debug)]
        struct Builder
        {
            pats: Vec<String>,
            metac: meta::Config,
            syntaxc: syntax::Config,
        }

        impl Default for Builder 
        {
            fn default() -> Builder
            {
                let metac = meta::Config::new()
                    .nfa_size_limit(Some(10 * (1 << 20)))
                    .hybrid_cache_capacity(2 * (1 << 20));
                Builder { pats: vec![], metac, syntaxc: syntax::Config::default() }
            }
        }

        impl Builder 
        {
            fn new<I, S>(patterns: I) -> Builder where
                S: AsRef<str>,
                I: IntoIterator<Item = S>,
           
            {
                let mut b = Builder::default();
                b.pats.extend(patterns.into_iter().map(|p| p.as_ref().to_string()));
                b
            }

            fn build_one_string(&self) -> Result<crate::Regex, Error> {
                assert_eq!(1, self.pats.len());
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::LeftmostFirst)
                    .utf8_empty(true);
                let syntaxc = self.syntaxc.clone().utf8(true);
                let pattern = Arc::from(self.pats[0].as_str());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build(&pattern)
                    .map(|meta| crate::Regex { meta, pattern })
                    .map_err(Error::from_meta_build_error)
            }

            fn build_one_bytes(&self) -> Result<crate::bytes::Regex, Error> {
                assert_eq!(1, self.pats.len());
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::LeftmostFirst)
                    .utf8_empty(false);
                let syntaxc = self.syntaxc.clone().utf8(false);
                let pattern = Arc::from(self.pats[0].as_str());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build(&pattern)
                    .map(|meta| crate::bytes::Regex { meta, pattern })
                    .map_err(Error::from_meta_build_error)
            }

            fn build_many_string(&self) -> Result<crate::RegexSet, Error>
           
            {
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::All)
                    .utf8_empty(true)
                    .which_captures(WhichCaptures::None);
                let syntaxc = self.syntaxc.clone().utf8(true);
                let patterns = Arc::from(self.pats.as_slice());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build_many(&patterns)
                    .map(|meta| crate::RegexSet { meta, patterns })
                    .map_err(Error::from_meta_build_error)
            }

            fn build_many_bytes(&self) -> Result<crate::bytes::RegexSet, Error>
           
            {
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::All)
                    .utf8_empty(false)
                    .which_captures(WhichCaptures::None);
                let syntaxc = self.syntaxc.clone().utf8(false);
                let patterns = Arc::from(self.pats.as_slice());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build_many(&patterns)
                    .map(|meta| crate::bytes::RegexSet { meta, patterns })
                    .map_err(Error::from_meta_build_error)
            }

            fn case_insensitive(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.case_insensitive(yes);
                self
            }

            fn multi_line(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.multi_line(yes);
                self
            }

            fn dot_matches_new_line(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.dot_matches_new_line(yes);
                self
            }

            fn crlf(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.crlf(yes);
                self
            }

            fn line_terminator(&mut self, byte: u8) -> &mut Builder {
                self.metac = self.metac.clone().line_terminator(byte);
                self.syntaxc = self.syntaxc.line_terminator(byte);
                self
            }

            fn swap_greed(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.swap_greed(yes);
                self
            }

            fn ignore_whitespace(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.ignore_whitespace(yes);
                self
            }

            fn unicode(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.unicode(yes);
                self
            }

            fn octal(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.octal(yes);
                self
            }

            fn size_limit(&mut self, limit: usize) -> &mut Builder {
                self.metac = self.metac.clone().nfa_size_limit(Some(limit));
                self
            }

            fn dfa_size_limit(&mut self, limit: usize) -> &mut Builder {
                self.metac = self.metac.clone().hybrid_cache_capacity(limit);
                self
            }

            fn nest_limit(&mut self, limit: u32) -> &mut Builder {
                self.syntaxc = self.syntaxc.nest_limit(limit);
                self
            }
        }

        pub mod string
        {
            use ::regex::{error::Error, Regex, RegexSet};

            use super::Builder;
            /// A configurable builder for a [`Regex`].
            #[derive(Clone, Debug)]
            pub struct RegexBuilder
            {
                builder: Builder,
            }

            impl RegexBuilder
            {
                /// Create a new builder with a default configuration for the given
                pub fn new(pattern: &str) -> RegexBuilder { RegexBuilder { builder: Builder::new([pattern]) } }
                /// Compiles the pattern given to `RegexBuilder::new` with the
                pub fn build(&self) -> Result<Regex, Error>
                { self.builder.build_one_string() }
                /// This configures Unicode mode for the entire pattern.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.unicode(yes);
                    self
                }
                /// This configures whether to enable case insensitive matching for the entire pattern.
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.case_insensitive(yes);
                    self
                }
                /// This configures multi-line mode for the entire pattern.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.multi_line(yes);
                    self
                }
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line
                (
                    &mut self,
                    yes: bool,
                ) -> &mut RegexBuilder
                {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
                /// This configures CRLF mode for the entire pattern.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.crlf(yes);
                    self
                }
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder
                {
                    self.builder.line_terminator(byte);
                    self
                }
                /// This configures swap-greed mode for the entire pattern.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.swap_greed(yes);
                    self
                }
                /// This configures verbose mode for the entire pattern.
                pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.ignore_whitespace(yes);
                    self
                }
                /// This configures octal mode for the entire pattern.
                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.octal(yes);
                    self
                }
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexBuilder
                {
                    self.builder.size_limit(bytes);
                    self
                }
                /// Set the approximate capacity, in bytes, of the cache of transitions used by the lazy DFA.
                pub fn dfa_size_limit(&mut self, bytes: usize) -> &mut RegexBuilder
                {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder
                {
                    self.builder.nest_limit(limit);
                    self
                }
            }
            /// A configurable builder for a [`RegexSet`].
            #[derive(Clone, Debug)]
            pub struct RegexSetBuilder
            {
                builder: Builder,
            }

            impl RegexSetBuilder
           
            {
                /// Create a new builder with a default configuration for the given
                pub fn new<I, S>(patterns: I) -> RegexSetBuilder where
                    I: IntoIterator<Item = S>,
                    S: AsRef<str>,
                {
                    RegexSetBuilder { builder: Builder::new(patterns) }
                }
                /// Compiles the patterns given to `RegexSetBuilder::new` with the
                pub fn build(&self) -> Result<RegexSet, Error>
                { self.builder.build_many_string()
                }
                /// This configures Unicode mode for the all of the patterns.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.unicode(yes);
                    self
                }
                /// This configures whether to enable case insensitive matching for all
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.case_insensitive(yes);
                    self
                }
                /// This configures multi-line mode for all of the patterns.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.multi_line(yes);
                    self
                }
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line
                
                (
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder
                {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
                /// This configures CRLF mode for all of the patterns.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.crlf(yes);
                    self
                }
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexSetBuilder
                {
                    self.builder.line_terminator(byte);
                    self
                }
                /// This configures swap-greed mode for all of the patterns.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.swap_greed(yes);
                    self
                }
                /// This configures verbose mode for all of the patterns.
                pub fn ignore_whitespace
                
                (
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder
                {
                    self.builder.ignore_whitespace(yes);
                    self
                }
                /// This configures octal mode for all of the patterns.
                pub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.octal(yes);
                    self
                }
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexSetBuilder
                {
                    self.builder.size_limit(bytes);
                    self
                }
                /// Set the approximate capacity, in bytes, of the cache of transitions
                pub fn dfa_size_limit
                
                (
                    &mut self,
                    bytes: usize,
                ) -> &mut RegexSetBuilder
                {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexSetBuilder
                {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        }

        pub mod bytes 
        {
            use ::regex::
            {
                bytes::{Regex, RegexSet},
                error::Error,
            };

            use super::Builder;
            /// A configurable builder for a [`Regex`].
            #[derive(Clone, Debug)]
            pub struct RegexBuilder {
                builder: Builder,
            }

            impl RegexBuilder
            {
                /// Create a new builder with a default configuration for the given
                pub fn new(pattern: &str) -> RegexBuilder {
                    RegexBuilder { builder: Builder::new([pattern]) }
                }
                /// Compiles the pattern given to `RegexBuilder::new` with the
                pub fn build(&self) -> Result<Regex, Error>
                { self.builder.build_one_bytes()
                }
                /// This configures Unicode mode for the entire pattern.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.unicode(yes);
                    self
                }
                /// This configures whether to enable case insensitive matching for the
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.case_insensitive(yes);
                    self
                }
                /// This configures multi-line mode for the entire pattern.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.multi_line(yes);
                    self
                }
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line
                (
                    &mut self,
                    yes: bool,
                ) -> &mut RegexBuilder
                {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
                /// This configures CRLF mode for the entire pattern.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.crlf(yes);
                    self
                }
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder
                {
                    self.builder.line_terminator(byte);
                    self
                }
                /// This configures swap-greed mode for the entire pattern.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.swap_greed(yes);
                    self
                }
                /// This configures verbose mode for the entire pattern.
                pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.ignore_whitespace(yes);
                    self
                }
                /// This configures octal mode for the entire pattern.
                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder
                {
                    self.builder.octal(yes);
                    self
                }
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexBuilder
                {
                    self.builder.size_limit(bytes);
                    self
                }
                /// Set the approximate capacity, in bytes, of the cache of transitions
                pub fn dfa_size_limit(&mut self, bytes: usize) -> &mut RegexBuilder
                {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder
                {
                    self.builder.nest_limit(limit);
                    self
                }
            }
            /// A configurable builder for a [`RegexSet`].
            #[derive(Clone, Debug)]
            pub struct RegexSetBuilder
            {
                builder: Builder,
            }

            impl RegexSetBuilder
            {
                /// Create a new builder with a default configuration for the given
                pub fn new<I, S>(patterns: I) -> RegexSetBuilder where
                    I: IntoIterator<Item = S>,
                    S: AsRef<str>,
                {
                    RegexSetBuilder { builder: Builder::new(patterns) }
                }
                /// Compiles the patterns given to `RegexSetBuilder::new` with the
                pub fn build(&self) -> Result<RegexSet, Error> { self.builder.build_many_bytes() }
                /// This configures Unicode mode for the all of the patterns.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.unicode(yes);
                    self
                }
                /// This configures whether to enable case insensitive matching for all
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.case_insensitive(yes);
                    self
                }
                /// This configures multi-line mode for all of the patterns.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.multi_line(yes);
                    self
                }
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line
                (
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder
                {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
                /// This configures CRLF mode for all of the patterns.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.crlf(yes);
                    self
                }
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexSetBuilder
                {
                    self.builder.line_terminator(byte);
                    self
                }
                /// This configures swap-greed mode for all of the patterns.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.swap_greed(yes);
                    self
                }
                /// This configures verbose mode for all of the patterns.
                pub fn ignore_whitespace
                (
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder
                {
                    self.builder.ignore_whitespace(yes);
                    self
                }
                /// This configures octal mode for all of the patterns.
                pub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder
                {
                    self.builder.octal(yes);
                    self
                }
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexSetBuilder
                {
                    self.builder.size_limit(bytes);
                    self
                }
                /// Set the approximate capacity, in bytes, of the cache of transitions
                pub fn dfa_size_limit
                (
                    &mut self,
                    bytes: usize,
                ) -> &mut RegexSetBuilder
                {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexSetBuilder
                {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        }
    } pub use self::builders::string::*;

    pub mod bytes
    {
        /*!
        Search for regex matches in `&[u8]` haystacks. */
        pub use ::regex::{builders::bytes::*, regex::bytes::*, regexset::bytes::*};
    }

    pub mod error
    {
        use ::
        {
            regex::automata::meta,
            string::{String, ToString},
            *,
        };
        /*
        */
        /// An error that occurred during parsing or compiling a regular expression.
        #[non_exhaustive]
        #[derive(Clone, PartialEq)]
        pub enum Error
        {
            /// A syntax error.
            Syntax(String),
            /// The compiled program exceeded the set size limit.
            CompiledTooBig(usize),
        }

        impl Error
        {
            pub fn from_meta_build_error(err: meta::BuildError) -> Error
            {
                if let Some(size_limit) = err.size_limit() { Error::CompiledTooBig(size_limit)  }

                else if let Some(ref err) = err.syntax_error() { Error::Syntax(err.to_string()) }

                else { Error::Syntax(err.to_string()) }
            }
        }
        
        impl ::error::Error for Error
        {
            fn description(&self) -> &str
            {
                match *self
                {
                    Error::Syntax(ref err) => err,
                    Error::CompiledTooBig(_) => "compiled program too big",
                }
            }
        }

        impl ::fmt::Display for Error
        {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
            {
                match *self
                {
                    Error::Syntax(ref err) => err.fmt(f),
                    Error::CompiledTooBig(limit) => write!(
                        f,
                        "Compiled regex exceeds size limit of {limit} bytes."
                    ),
                }
            }
        }
        
        impl ::fmt::Debug for Error
        {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
            {
                match *self
                {
                    Error::Syntax(ref err) =>
                    {
                        let hr: String = ::iter::repeat('~').take(79).collect();
                        writeln!(f, "Syntax(")?;
                        writeln!(f, "{hr}")?;
                        writeln!(f, "{err}")?;
                        writeln!(f, "{hr}")?;
                        write!(f, ")")?;
                        Ok(())
                    }

                    Error::CompiledTooBig(limit) => { f.debug_tuple("CompiledTooBig").field(&limit).finish() }
                }
            }
        }
    } pub use self::error::Error;

    pub mod find_byte
    {
        use ::
        {
            *,
        };
        /*
        */
        /// Searches for the given needle in the given haystack.
        pub fn find_byte(needle: u8, haystack: &[u8]) -> Option<usize>
        {
            fn imp(needle: u8, haystack: &[u8]) -> Option<usize> 
            {
                ::mem::chr::memchr(needle, haystack)
            }

            imp(needle, haystack)
        }

    }

    pub mod pattern
    {
        use ::
        {
            *,
        };
        /*
        */
    }

    pub mod regex
    {
        use ::
        {
            *,
        };
        /*
        */
        pub mod bytes
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use ::{borrow::Cow, string::String, sync::Arc, vec::Vec};

            use ::regex::automata::{meta, util::captures, Input, PatternID};

            use crate::{bytes::RegexBuilder, error::Error};
            */
            /// A compiled regular expression for searching Unicode haystacks.
            #[derive(Clone)]
            pub struct Regex {
                pub meta: meta::Regex,
                pub pattern: Arc<str>,
            }

            impl ::fmt::Display for Regex
            {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }

            impl ::fmt::Debug for Regex
            {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_tuple("Regex").field(&self.as_str()).finish()
                }
            }

            impl ::str::FromStr for Regex {
                type Err = Error;
                /// Attempts to parse a string into a regular expression
                fn from_str(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }

            impl TryFrom<&str> for Regex {
                type Error = Error;
                /// Attempts to parse a string into a regular expression
                fn try_from(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }

            impl TryFrom<String> for Regex {
                type Error = Error;
                /// Attempts to parse a string into a regular expression
                fn try_from(s: String) -> Result<Regex, Error> {
                    Regex::new(&s)
                }
            }
            /// Core regular expression methods.
            impl Regex
            {
                /// Compiles a regular expression. Once compiled, it can be used repeatedly
                pub fn new(re: &str) -> Result<Regex, Error>
                { RegexBuilder::new(re).build() }
                /// Returns true if and only if there is a match for the regex anywhere
                #[inline] pub fn is_match(&self, haystack: &[u8]) -> bool
                { self.is_match_at(haystack, 0) }
                /// This routine searches for the first match of this regex in the
                #[inline] pub fn find<'h>(&self, haystack: &'h [u8]) -> Option<Match<'h>>
                { self.find_at(haystack, 0) }
                /// Returns an iterator that yields successive non-overlapping matches in
                #[inline] pub fn find_iter<'r, 'h>(&'r self, haystack: &'h [u8]) -> Matches<'r, 'h>
                { Matches { haystack, it: self.meta.find_iter(haystack) } }
                /// This routine searches for the first match of this regex in the haystack
                #[inline] pub fn captures<'h>(&self, haystack: &'h [u8]) -> Option<Captures<'h>>
                { self.captures_at(haystack, 0) }
                /// Returns an iterator that yields successive non-overlapping matches in
                #[inline] pub fn captures_iter<'r, 'h>
                (
                    &'r self,
                    haystack: &'h [u8],
                ) -> CaptureMatches<'r, 'h>
                { CaptureMatches { haystack, it: self.meta.captures_iter(haystack) } }
                /// Returns an iterator of substrings of the haystack given, delimited by a
                #[inline] pub fn split<'r, 'h>(&'r self, haystack: &'h [u8]) -> Split<'r, 'h>
                { Split { haystack, it: self.meta.split(haystack) } }
                /// Returns an iterator of at most `limit` substrings of the haystack
                #[inline] pub fn splitn<'r, 'h>
                (
                    &'r self,
                    haystack: &'h [u8],
                    limit: usize,
                ) -> SplitN<'r, 'h>
                { SplitN { haystack, it: self.meta.splitn(haystack, limit) } }
                /// Replaces the leftmost-first match in the given haystack with the
                #[inline] pub fn replace<'h, R: Replacer>
                (
                    &self,
                    haystack: &'h [u8],
                    rep: R,
                ) -> Cow<'h, [u8]>
                { self.replacen(haystack, 1, rep) }
                /// Replaces all non-overlapping matches in the haystack with the
                #[inline] pub fn replace_all<'h, R: Replacer>
                (
                    &self,
                    haystack: &'h [u8],
                    rep: R,
                ) -> Cow<'h, [u8]>
                { self.replacen(haystack, 0, rep) }
                /// Replaces at most `limit` non-overlapping matches in the haystack with
                #[inline] pub fn replacen<'h, R: Replacer>
                (
                    &self,
                    haystack: &'h [u8],
                    limit: usize,
                    mut rep: R,
                ) -> Cow<'h, [u8]> {
                    if let Some(rep) = rep.no_expansion() {
                        let mut it = self.find_iter(haystack).enumerate().peekable();
                        
                        if it.peek().is_none() {
                            return Cow::Borrowed(haystack);
                        }
                        let mut new = Vec::with_capacity(haystack.len());
                        let mut last_match = 0;
                        for (i, m) in it {
                            new.extend_from_slice(&haystack[last_match..m.start()]);
                            new.extend_from_slice(&rep);
                            last_match = m.end();
                            if limit > 0 && i >= limit - 1 {
                                break;
                            }
                        }
                        new.extend_from_slice(&haystack[last_match..]);
                        return Cow::Owned(new);
                    }
                    let mut it = self.captures_iter(haystack).enumerate().peekable();
                    if it.peek().is_none() {
                        return Cow::Borrowed(haystack);
                    }
                    let mut new = Vec::with_capacity(haystack.len());
                    let mut last_match = 0;
                    
                    for (i, cap) in it {
                        // unwrap on 0 is OK because captures only reports matches
                        let m = cap.get(0).unwrap();
                        new.extend_from_slice(&haystack[last_match..m.start()]);
                        rep.replace_append(&cap, &mut new);
                        last_match = m.end();
                        
                        if limit > 0 && i >= limit - 1 {
                            break;
                        }
                    }
                    new.extend_from_slice(&haystack[last_match..]);
                    Cow::Owned(new)
                }
            }
            /// A group of advanced or "lower level" search methods. Some methods permit
            impl Regex           
            {
                /// Returns the end byte offset of the first match in the haystack given.
                #[inline] pub fn shortest_match(&self, haystack: &[u8]) -> Option<usize>
                { self.shortest_match_at(haystack, 0)
                }
                /// Returns the same as `shortest_match`, but starts the search at the
                #[inline] pub fn shortest_match_at
                (
                    &self,
                    haystack: &[u8],
                    start: usize,
                ) -> Option<usize>
                {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).map(|hm| hm.offset())
                }
                /// Returns the same as [`Regex::is_match`], but starts the search at the
                #[inline] pub fn is_match_at(&self, haystack: &[u8], start: usize) -> bool
                { self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                }
                /// Returns the same as [`Regex::find`], but starts the search at the given
                #[inline] pub fn find_at<'h>
                (
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>>
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.find(input).map(|m| Match::new(haystack, m.start(), m.end()))
                }
                /// Returns the same as [`Regex::captures`], but starts the search at the
                #[inline] pub fn captures_at<'h>
                (
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Captures<'h>>
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut caps = self.meta.create_captures();
                    self.meta.captures(input, &mut caps);
                    if caps.is_match() {
                        let static_captures_len = self.static_captures_len();
                        Some(Captures { haystack, caps, static_captures_len })
                    }
                    
                    else { None }
                }
                /// This is like [`Regex::captures`], but writes the byte offsets of each
                #[inline] pub fn captures_read<'h>
                (
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                ) -> Option<Match<'h>>
                { self.captures_read_at(locs, haystack, 0)
                }
                /// Returns the same as [`Regex::captures_read`], but starts the search at
                #[inline] pub fn captures_read_at<'h>
                (
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>>
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.search_captures(&input, &mut locs.0);
                    locs.0.get_match().map(|m| Match::new(haystack, m.start(), m.end()))
                }
                /// An undocumented alias for `captures_read_at`.
                #[inline] pub fn read_captures_at<'h>
                (
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>>
                { self.captures_read_at(locs, haystack, start)
                }
            }
            /// Auxiliary methods.
            impl Regex
            {
                /// Returns the original string of this regex.
                #[inline] pub fn as_str(&self) -> &str {
                    &self.pattern
                }
                /// Returns an iterator over the capture names in this regex.
                #[inline] pub fn capture_names(&self) -> CaptureNames<'_> {
                    CaptureNames(self.meta.group_info().pattern_names(PatternID::ZERO))
                }
                /// Returns the number of captures groups in this regex.
                #[inline] pub fn captures_len(&self) -> usize {
                    self.meta.group_info().group_len(PatternID::ZERO)
                }
                /// Returns the total number of capturing groups that appear in every
                #[inline] pub fn static_captures_len(&self) -> Option<usize>
                { self.meta.static_captures_len()
                }
                /// Returns a fresh allocated set of capture locations that can
                #[inline] pub fn capture_locations(&self) -> CaptureLocations {
                    CaptureLocations(self.meta.create_captures())
                }
                /// An alias for `capture_locations` to preserve backward compatibility.
                #[inline] pub fn locations(&self) -> CaptureLocations {
                    self.capture_locations()
                }
            }
            /// Represents a single match of a regex in a haystack.
            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Match<'h> {
                haystack: &'h [u8],
                start: usize,
                end: usize,
            }

            impl<'h> Match<'h>
            {
                /// Returns the byte offset of the start of the match in the haystack. The
                #[inline] pub fn start(&self) -> usize {
                    self.start
                }
                /// Returns the byte offset of the end of the match in the haystack. The
                #[inline] pub fn end(&self) -> usize {
                    self.end
                }
                /// Returns true if and only if this match has a length of zero.
                #[inline] pub fn is_empty(&self) -> bool
                { self.start == self.end
                }
                /// Returns the length, in bytes, of this match.
                #[inline] pub fn len(&self) -> usize {
                    self.end - self.start
                }
                /// Returns the range over the starting and ending byte offsets of the
                #[inline] pub fn range(&self) -> ::ops::Range<usize>
                { self.start..self.end
                }
                /// Returns the substring of the haystack that matched.
                #[inline] pub fn as_bytes(&self) -> &'h [u8] {
                    &self.haystack[self.range()]
                }
                /// Creates a new match from the given haystack and byte offsets.
                #[inline] fn new(haystack: &'h [u8], start: usize, end: usize) -> Match<'h> {
                    Match { haystack, start, end }
                }
            }

            impl<'h> ::fmt::Debug for Match<'h>
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    use ::regex::automata::util::escape::DebugHaystack;

                    let mut fmt = f.debug_struct("Match");
                    fmt.field("start", &self.start)
                        .field("end", &self.end)
                        .field("bytes", &DebugHaystack(&self.as_bytes()));

                    fmt.finish()
                }
            }

            impl<'h> From<Match<'h>> for &'h [u8]
            {
                fn from(m: Match<'h>) -> &'h [u8] {
                    m.as_bytes()
                }
            }

            impl<'h> From<Match<'h>> for ::ops::Range<usize>
           
            {
                fn from(m: Match<'h>) -> ::ops::Range<usize> {
                    m.range()
                }
            }
            /// Represents the capture groups for a single match.
            pub struct Captures<'h> {
                haystack: &'h [u8],
                caps: captures::Captures,
                static_captures_len: Option<usize>,
            }

            impl<'h> Captures<'h>
            {
                /// Returns the `Match` associated with the capture group at index `i`. If
                #[inline] pub fn get(&self, i: usize) -> Option<Match<'h>>
                { self.caps
                        .get_group(i)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
                /// Returns the `Match` associated with the capture group named `name`. If
                #[inline] pub fn name(&self, name: &str) -> Option<Match<'h>>
                { self.caps
                        .get_group_by_name(name)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
                /// This is a convenience routine for extracting the substrings
                pub fn extract<const N: usize>(&self) -> (&'h [u8], [&'h [u8]; N])
                {
                    let len = self
                        .static_captures_len
                        .expect("number of capture groups can vary in a match")
                        .checked_sub(1)
                        .expect("number of groups is always greater than zero");
                    assert_eq!(N, len, "asked for {N} groups, but must ask for {len}");
                    self.caps.extract_bytes(self.haystack)
                }
                /// Expands all instances of `$ref` in `replacement` to the corresponding
                #[inline] pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {
                    self.caps.interpolate_bytes_into(self.haystack, replacement, dst);
                }
                /// Returns an iterator over all capture groups. This includes both
                #[inline] pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> {
                    SubCaptureMatches { haystack: self.haystack, it: self.caps.iter() }
                }
                /// Returns the total number of capture groups. This includes both
                #[inline] pub fn len(&self) -> usize {
                    self.caps.group_len()
                }
            }

            impl<'h> ::fmt::Debug for Captures<'h>
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    /// A little helper type to provide a nice map-like debug
                    struct CapturesDebugMap<'a> {
                        caps: &'a Captures<'a>,
                    }

                    impl<'a> ::fmt::Debug for CapturesDebugMap<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut map = f.debug_map();
                            let names =
                                self.caps.caps.group_info().pattern_names(PatternID::ZERO);
                            for (group_index, maybe_name) in names.enumerate() {
                                let key = Key(group_index, maybe_name);
                                match self.caps.get(group_index) {
                                    None => map.entry(&key, &None::<()>),
                                    Some(mat) => map.entry(&key, &Value(mat)),
                                };
                            }
                            map.finish()
                        }
                    }

                    struct Key<'a>(usize, Option<&'a str>);

                    impl<'a> ::fmt::Debug for Key<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(f, "{}", self.0)?;
                            if let Some(name) = self.1 {
                                write!(f, "/{name:?}")?;
                            }
                            Ok(())
                        }
                    }

                    struct Value<'a>(Match<'a>);

                    impl<'a> ::fmt::Debug for Value<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            use ::regex::automata::util::escape::DebugHaystack;

                            write!(
                                f,
                                "{}..{}/{:?}",
                                self.0.start(),
                                self.0.end(),
                                DebugHaystack(self.0.as_bytes())
                            )
                        }
                    }

                    f.debug_tuple("Captures")
                        .field(&CapturesDebugMap { caps: self })
                        .finish()
                }
            }
            /// Get a matching capture group's haystack substring by index.
            impl<'h> ::ops::Index<usize> for Captures<'h> {
                type Output = [u8];
                fn index<'a>(&'a self, i: usize) -> &'a [u8] {
                    self.get(i)
                        .map(|m| m.as_bytes())
                        .unwrap_or_else(|| panic!("no group at index '{}'", i))
                }
            }
            /// Get a matching capture group's haystack substring by name.
            impl<'h, 'n> ::ops::Index<&'n str> for Captures<'h> {
                type Output = [u8];

                fn index<'a>(&'a self, name: &'n str) -> &'a [u8] {
                    self.name(name)
                        .map(|m| m.as_bytes())
                        .unwrap_or_else(|| panic!("no group named '{}'", name))
                }
            }
            /// A low level representation of the byte offsets of each capture group.
            #[derive(Clone, Debug)]
            pub struct CaptureLocations(captures::Captures);
            /// A type alias for `CaptureLocations` for backwards compatibility.
            #[doc(hidden)]
            pub type Locations = CaptureLocations;

            impl CaptureLocations
            {
                /// Returns the start and end byte offsets of the capture group at index
                #[inline] pub fn get(&self, i: usize) -> Option<(usize, usize)>
                { self.0.get_group(i).map(|sp| (sp.start, sp.end))
                }
                /// Returns the total number of capture groups (even if they didn't match).
                #[inline] pub fn len(&self) -> usize {
                    self.0.group_info().group_len(PatternID::ZERO)
                }
                /// An alias for the `get` method for backwards compatibility.
                #[inline] pub fn pos(&self, i: usize) -> Option<(usize, usize)>
                { self.get(i)
                }
            }
            /// An iterator over all non-overlapping matches in a haystack.
            #[derive(Debug)]
            pub struct Matches<'r, 'h> {
                haystack: &'h [u8],
                it: meta::FindMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Matches<'r, 'h> {
                type Item = Match<'h>;

                #[inline] fn next(&mut self) -> Option<Match<'h>>
                { self.it
                        .next()
                        .map(|sp| Match::new(self.haystack, sp.start(), sp.end()))
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for Matches<'r, 'h> {}
            /// An iterator over all non-overlapping capture matches in a haystack.
            #[derive(Debug)]
            pub struct CaptureMatches<'r, 'h> {
                haystack: &'h [u8],
                it: meta::CapturesMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for CaptureMatches<'r, 'h> {
                type Item = Captures<'h>;

                #[inline] fn next(&mut self) -> Option<Captures<'h>>
                {
                    let static_captures_len = self.it.regex().static_captures_len();
                    self.it.next().map(|caps| Captures {
                        haystack: self.haystack,
                        caps,
                        static_captures_len,
                    })
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for CaptureMatches<'r, 'h> {}
            /// An iterator over all substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct Split<'r, 'h> {
                haystack: &'h [u8],
                it: meta::Split<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Split<'r, 'h> {
                type Item = &'h [u8];

                #[inline] fn next(&mut self) -> Option<&'h [u8]>
                { self.it.next().map(|span| &self.haystack[span])
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}
            /// An iterator over at most `N` substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct SplitN<'r, 'h> {
                haystack: &'h [u8],
                it: meta::SplitN<'r, 'h>,
            }

            impl<'r, 'h> Iterator for SplitN<'r, 'h> {
                type Item = &'h [u8];

                #[inline] fn next(&mut self) -> Option<&'h [u8]>
                { self.it.next().map(|span| &self.haystack[span])
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}
            /// An iterator over the names of all capture groups in a regex.
            #[derive(Clone, Debug)]
            pub struct CaptureNames<'r>(captures::GroupInfoPatternNames<'r>);

            impl<'r> Iterator for CaptureNames<'r> {
                type Item = Option<&'r str>;

                #[inline] fn next(&mut self) -> Option<Option<&'r str>>
                { self.0.next()
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }

                #[inline] fn count(self) -> usize {
                    self.0.count()
                }
            }

            impl<'r> ExactSizeIterator for CaptureNames<'r> {}

            impl<'r> ::iter::FusedIterator for CaptureNames<'r> {}
            /// An iterator over all group matches in a [`Captures`] value.
            #[derive(Clone, Debug)]
            pub struct SubCaptureMatches<'c, 'h> {
                haystack: &'h [u8],
                it: captures::CapturesPatternIter<'c>,
            }

            impl<'c, 'h> Iterator for SubCaptureMatches<'c, 'h> {
                type Item = Option<Match<'h>>;

                #[inline] fn next(&mut self) -> Option<Option<Match<'h>>>
                { self.it.next().map(|group| {
                        group.map(|sp| Match::new(self.haystack, sp.start, sp.end))
                    })
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'c, 'h> ExactSizeIterator for SubCaptureMatches<'c, 'h> {}

            impl<'c, 'h> ::iter::FusedIterator for SubCaptureMatches<'c, 'h> {}
            /// A trait for types that can be used to replace matches in a haystack.
            pub trait Replacer
            {
                /// Appends possibly empty data to `dst` to replace the current match.
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>);
                /// Return a fixed unchanging replacement byte string.
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {
                    None
                }
                /// Returns a type that implements `Replacer`, but that borrows and wraps
                fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {
                    ReplacerRef(self)
                }
            }

            impl<'a, const N: usize> Replacer for &'a [u8; N]
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(&**self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl<const N: usize> Replacer for [u8; N]
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(&*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for &'a [u8]
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for &'a Vec<u8>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl Replacer for Vec<u8>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for Cow<'a, [u8]>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self.as_ref(), dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for &'a Cow<'a, [u8]>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self.as_ref(), dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }

            impl<F, T> Replacer for F where
                F: FnMut(&Captures<'_>) -> T,
                T: AsRef<[u8]>,
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    dst.extend_from_slice((*self)(caps).as_ref());
                }
            }
            /// A by-reference adaptor for a [`Replacer`].
            #[derive(Debug)]
            pub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);

            impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    self.0.replace_append(caps, dst)
                }

                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>>
                { self.0.no_expansion()
                }
            }
            /// A helper type for forcing literal string replacement.
            #[derive(Clone, Debug)]
            pub struct NoExpand<'s>(pub &'s [u8]);

            impl<'s> Replacer for NoExpand<'s>
           
            {
                fn replace_append(&mut self, _: &Captures<'_>, dst: &mut Vec<u8>) {
                    dst.extend_from_slice(self.0);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    Some(Cow::Borrowed(self.0))
                }
            }
            /// Quickly checks the given replacement string for whether interpolation
            fn no_expansion<T: AsRef<[u8]>>(replacement: &T) -> Option<Cow<'_, [u8]>>
           
            {
                let replacement = replacement.as_ref();
                match crate::find_byte::find_byte(b'$', replacement) {
                    Some(_) => None,
                    None => Some(Cow::Borrowed(replacement)),
                }
            }
        }

        pub mod string
        {
            use ::
            {
                borrow::{ Cow },
                regex::
                {
                    automata::{ meta, util::captures, Input, PatternID },
                    syntax::{ error::Error, RegexBuilder },
                },
                string::{ String },
                sync::{ Arc },
                *,
            };
            /*
            */
            /// A compiled regular expression for searching Unicode haystacks.
            #[derive(Clone)]
            pub struct Regex
            {
                pub meta: meta::Regex,
                pub pattern: Arc<str>,
            }

            impl ::fmt::Display for Regex
            {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }

            impl ::fmt::Debug for Regex
            {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_tuple("Regex").field(&self.as_str()).finish()
                }
            }

            impl ::str::FromStr for Regex {
                type Err = Error;
                /// Attempts to parse a string into a regular expression
                fn from_str(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }

            impl TryFrom<&str> for Regex {
                type Error = Error;
                /// Attempts to parse a string into a regular expression
                fn try_from(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }

            impl TryFrom<String> for Regex {
                type Error = Error;
                /// Attempts to parse a string into a regular expression
                fn try_from(s: String) -> Result<Regex, Error> {
                    Regex::new(&s)
                }
            }
            /// Core regular expression methods.
            impl Regex
            {
                /// Compiles a regular expression. Once compiled, it can be used repeatedly
                pub fn new(re: &str) -> Result<Regex, Error> {
                    RegexBuilder::new(re).build()
                }
                /// Returns true if and only if there is a match for the regex anywhere
                #[inline] pub fn is_match(&self, haystack: &str) -> bool
                { self.is_match_at(haystack, 0)
                }
                /// This routine searches for the first match of this regex in the
                #[inline] pub fn find<'h>(&self, haystack: &'h str) -> Option<Match<'h>>
                { self.find_at(haystack, 0)
                }
                /// Returns an iterator that yields successive non-overlapping matches in
                #[inline] pub fn find_iter<'r, 'h>(&'r self, haystack: &'h str) -> Matches<'r, 'h> {
                    Matches { haystack, it: self.meta.find_iter(haystack) }
                }
                /// This routine searches for the first match of this regex in the haystack
                #[inline] pub fn captures<'h>(&self, haystack: &'h str) -> Option<Captures<'h>>
                { self.captures_at(haystack, 0)
                }
                /// Returns an iterator that yields successive non-overlapping matches in
                #[inline] pub fn captures_iter<'r, 'h>(
                    &'r self,
                    haystack: &'h str,
                ) -> CaptureMatches<'r, 'h> {
                    CaptureMatches { haystack, it: self.meta.captures_iter(haystack) }
                }
                /// Returns an iterator of substrings of the haystack given, delimited by a
                #[inline] pub fn split<'r, 'h>(&'r self, haystack: &'h str) -> Split<'r, 'h> {
                    Split { haystack, it: self.meta.split(haystack) }
                }
                /// Returns an iterator of at most `limit` substrings of the haystack
                #[inline] pub fn splitn<'r, 'h>(
                    &'r self,
                    haystack: &'h str,
                    limit: usize,
                ) -> SplitN<'r, 'h> {
                    SplitN { haystack, it: self.meta.splitn(haystack, limit) }
                }
                /// Replaces the leftmost-first match in the given haystack with the
                #[inline] pub fn replace<'h, R: Replacer>
                (
                    &self,
                    haystack: &'h str,
                    rep: R,
                ) -> Cow<'h, str>
                { self.replacen(haystack, 1, rep)
                }
                /// Replaces all non-overlapping matches in the haystack with the
                #[inline] pub fn replace_all<'h, R: Replacer>
                (
                    &self,
                    haystack: &'h str,
                    rep: R,
                ) -> Cow<'h, str>
                { self.replacen(haystack, 0, rep)
                }
                /// Replaces at most `limit` non-overlapping matches in the haystack with
                #[inline] pub fn replacen<'h, R: Replacer>
                (
                    &self,
                    haystack: &'h str,
                    limit: usize,
                    mut rep: R,
                ) -> Cow<'h, str> {
                    if let Some(rep) = rep.no_expansion() {
                        let mut it = self.find_iter(haystack).enumerate().peekable();
                        
                        if it.peek().is_none() {
                            return Cow::Borrowed(haystack);
                        }
                        let mut new = String::with_capacity(haystack.len());
                        let mut last_match = 0;
                        for (i, m) in it {
                            new.push_str(&haystack[last_match..m.start()]);
                            new.push_str(&rep);
                            last_match = m.end();
                            if limit > 0 && i >= limit - 1 {
                                break;
                            }
                        }
                        new.push_str(&haystack[last_match..]);
                        return Cow::Owned(new);
                    }
                    let mut it = self.captures_iter(haystack).enumerate().peekable();
                    if it.peek().is_none() {
                        return Cow::Borrowed(haystack);
                    }
                    let mut new = String::with_capacity(haystack.len());
                    let mut last_match = 0;
                    
                    for (i, cap) in it {
                        // unwrap on 0 is OK because captures only reports matches
                        let m = cap.get(0).unwrap();
                        new.push_str(&haystack[last_match..m.start()]);
                        rep.replace_append(&cap, &mut new);
                        last_match = m.end();
                        
                        if limit > 0 && i >= limit - 1 {
                            break;
                        }
                    }
                    new.push_str(&haystack[last_match..]);
                    Cow::Owned(new)
                }
            }
            /// A group of advanced or "lower level" search methods. Some methods permit
            impl Regex
            {
                /// Returns the end byte offset of the first match in the haystack given.
                #[inline] pub fn shortest_match(&self, haystack: &str) -> Option<usize>
                { self.shortest_match_at(haystack, 0)
                }
                /// Returns the same as [`Regex::shortest_match`], but starts the search at
                #[inline] pub fn shortest_match_at
                (
                    &self,
                    haystack: &str,
                    start: usize,
                ) -> Option<usize>
                {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).map(|hm| hm.offset())
                }
                /// Returns the same as [`Regex::is_match`], but starts the search at the
                #[inline] pub fn is_match_at(&self, haystack: &str, start: usize) -> bool
                {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).is_some()
                }
                /// Returns the same as [`Regex::find`], but starts the search at the given
                #[inline] pub fn find_at<'h>
                (
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>>
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta
                        .search(&input)
                        .map(|m| Match::new(haystack, m.start(), m.end()))
                }
                /// Returns the same as [`Regex::captures`], but starts the search at the
                #[inline] pub fn captures_at<'h>
                (
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Captures<'h>>
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut caps = self.meta.create_captures();
                    self.meta.search_captures(&input, &mut caps);
                    if caps.is_match() {
                        let static_captures_len = self.static_captures_len();
                        Some(Captures { haystack, caps, static_captures_len })
                    }
                    
                    else { None }
                }
                /// This is like [`Regex::captures`], but writes the byte offsets of each
                #[inline] pub fn captures_read<'h>
                (
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                ) -> Option<Match<'h>>
                { self.captures_read_at(locs, haystack, 0)
                }
                /// Returns the same as [`Regex::captures_read`], but starts the search at
                #[inline] pub fn captures_read_at<'h>
                (
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>>
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.search_captures(&input, &mut locs.0);
                    locs.0.get_match().map(|m| Match::new(haystack, m.start(), m.end()))
                }
                /// An undocumented alias for `captures_read_at`.
                #[inline] pub fn read_captures_at<'h>
                (
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>>
                { self.captures_read_at(locs, haystack, start)
                }
            }
            /// Auxiliary methods.
            impl Regex
            {
                /// Returns the original string of this regex.
                #[inline] pub fn as_str(&self) -> &str {
                    &self.pattern
                }
                /// Returns an iterator over the capture names in this regex.
                #[inline] pub fn capture_names(&self) -> CaptureNames<'_> {
                    CaptureNames(self.meta.group_info().pattern_names(PatternID::ZERO))
                }
                /// Returns the number of captures groups in this regex.
                #[inline] pub fn captures_len(&self) -> usize {
                    self.meta.group_info().group_len(PatternID::ZERO)
                }
                /// Returns the total number of capturing groups that appear in every
                #[inline] pub fn static_captures_len(&self) -> Option<usize>
                { self.meta.static_captures_len()
                }
                /// Returns a fresh allocated set of capture locations that can
                #[inline] pub fn capture_locations(&self) -> CaptureLocations {
                    CaptureLocations(self.meta.create_captures())
                }
                /// An alias for `capture_locations` to preserve backward compatibility.
                #[inline] pub fn locations(&self) -> CaptureLocations {
                    self.capture_locations()
                }
            }
            /// Represents a single match of a regex in a haystack.
            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Match<'h> {
                haystack: &'h str,
                start: usize,
                end: usize,
            }

            impl<'h> Match<'h>
            {
                /// Returns the byte offset of the start of the match in the haystack. The
                #[inline] pub fn start(&self) -> usize {
                    self.start
                }
                /// Returns the byte offset of the end of the match in the haystack. The
                #[inline] pub fn end(&self) -> usize {
                    self.end
                }
                /// Returns true if and only if this match has a length of zero.
                #[inline] pub fn is_empty(&self) -> bool
                { self.start == self.end
                }
                /// Returns the length, in bytes, of this match.
                #[inline] pub fn len(&self) -> usize {
                    self.end - self.start
                }
                /// Returns the range over the starting and ending byte offsets of the
                #[inline] pub fn range(&self) -> ::ops::Range<usize>
                { self.start..self.end
                }
                /// Returns the substring of the haystack that matched.
                #[inline] pub fn as_str(&self) -> &'h str {
                    &self.haystack[self.range()]
                }
                /// Creates a new match from the given haystack and byte offsets.
                #[inline] fn new(haystack: &'h str, start: usize, end: usize) -> Match<'h> {
                    Match { haystack, start, end }
                }
            }

            impl<'h> ::fmt::Debug for Match<'h>
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    f.debug_struct("Match")
                        .field("start", &self.start)
                        .field("end", &self.end)
                        .field("string", &self.as_str())
                        .finish()
                }
            }

            impl<'h> From<Match<'h>> for &'h str
            {
                fn from(m: Match<'h>) -> &'h str {
                    m.as_str()
                }
            }

            impl<'h> From<Match<'h>> for ::ops::Range<usize>
           
            {
                fn from(m: Match<'h>) -> ::ops::Range<usize> {
                    m.range()
                }
            }
            /// Represents the capture groups for a single match.
            pub struct Captures<'h> {
                haystack: &'h str,
                caps: captures::Captures,
                static_captures_len: Option<usize>,
            }

            impl<'h> Captures<'h>
            {
                /// Returns the `Match` associated with the capture group at index `i`. If
                #[inline] pub fn get(&self, i: usize) -> Option<Match<'h>>
                { self.caps
                        .get_group(i)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
                /// Returns the `Match` associated with the capture group named `name`. If
                #[inline] pub fn name(&self, name: &str) -> Option<Match<'h>>
                { self.caps
                        .get_group_by_name(name)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
                /// This is a convenience routine for extracting the substrings
                pub fn extract<const N: usize>(&self) -> (&'h str, [&'h str; N])
                {
                    let len = self
                        .static_captures_len
                        .expect("number of capture groups can vary in a match")
                        .checked_sub(1)
                        .expect("number of groups is always greater than zero");
                    assert_eq!(N, len, "asked for {N} groups, but must ask for {len}");
                    self.caps.extract(self.haystack)
                }
                /// Expands all instances of `$ref` in `replacement` to the corresponding
                #[inline] pub fn expand(&self, replacement: &str, dst: &mut String) {
                    self.caps.interpolate_string_into(self.haystack, replacement, dst);
                }
                /// Returns an iterator over all capture groups. This includes both
                #[inline] pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> {
                    SubCaptureMatches { haystack: self.haystack, it: self.caps.iter() }
                }
                /// Returns the total number of capture groups. This includes both
                #[inline] pub fn len(&self) -> usize {
                    self.caps.group_len()
                }
            }

            impl<'h> ::fmt::Debug for Captures<'h>
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    /// A little helper type to provide a nice map-like debug
                    struct CapturesDebugMap<'a> {
                        caps: &'a Captures<'a>,
                    }

                    impl<'a> ::fmt::Debug for CapturesDebugMap<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut map = f.debug_map();
                            let names =
                                self.caps.caps.group_info().pattern_names(PatternID::ZERO);
                            for (group_index, maybe_name) in names.enumerate() {
                                let key = Key(group_index, maybe_name);
                                match self.caps.get(group_index) {
                                    None => map.entry(&key, &None::<()>),
                                    Some(mat) => map.entry(&key, &Value(mat)),
                                };
                            }
                            map.finish()
                        }
                    }

                    struct Key<'a>(usize, Option<&'a str>);

                    impl<'a> ::fmt::Debug for Key<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(f, "{}", self.0)?;
                            if let Some(name) = self.1 {
                                write!(f, "/{name:?}")?;
                            }
                            Ok(())
                        }
                    }

                    struct Value<'a>(Match<'a>);

                    impl<'a> ::fmt::Debug for Value<'a>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(
                                f,
                                "{}..{}/{:?}",
                                self.0.start(),
                                self.0.end(),
                                self.0.as_str()
                            )
                        }
                    }

                    f.debug_tuple("Captures")
                        .field(&CapturesDebugMap { caps: self })
                        .finish()
                }
            }
            /// Get a matching capture group's haystack substring by index.
            impl<'h> ::ops::Index<usize> for Captures<'h> {
                type Output = str;
                fn index<'a>(&'a self, i: usize) -> &'a str {
                    self.get(i)
                        .map(|m| m.as_str())
                        .unwrap_or_else(|| panic!("no group at index '{}'", i))
                }
            }
            /// Get a matching capture group's haystack substring by name.
            impl<'h, 'n> ::ops::Index<&'n str> for Captures<'h> {
                type Output = str;

                fn index<'a>(&'a self, name: &'n str) -> &'a str {
                    self.name(name)
                        .map(|m| m.as_str())
                        .unwrap_or_else(|| panic!("no group named '{}'", name))
                }
            }
            /// A low level representation of the byte offsets of each capture group.
            #[derive(Clone, Debug)]
            pub struct CaptureLocations(captures::Captures);
            /// A type alias for `CaptureLocations` for backwards compatibility.
            #[doc(hidden)]
            pub type Locations = CaptureLocations;

            impl CaptureLocations
            {
                /// Returns the start and end byte offsets of the capture group at index
                #[inline] pub fn get(&self, i: usize) -> Option<(usize, usize)>
                { self.0.get_group(i).map(|sp| (sp.start, sp.end))
                }
                /// Returns the total number of capture groups (even if they didn't match).
                #[inline] pub fn len(&self) -> usize {
                    self.0.group_info().group_len(PatternID::ZERO)
                }
                /// An alias for the `get` method for backwards compatibility.
                #[inline] pub fn pos(&self, i: usize) -> Option<(usize, usize)>
                { self.get(i)
                }
            }
            /// An iterator over all non-overlapping matches in a haystack.
            #[derive(Debug)]
            pub struct Matches<'r, 'h> {
                haystack: &'h str,
                it: meta::FindMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Matches<'r, 'h> {
                type Item = Match<'h>;

                #[inline] fn next(&mut self) -> Option<Match<'h>>
                { self.it
                        .next()
                        .map(|sp| Match::new(self.haystack, sp.start(), sp.end()))
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for Matches<'r, 'h> {}
            /// An iterator over all non-overlapping capture matches in a haystack.
            #[derive(Debug)]
            pub struct CaptureMatches<'r, 'h> {
                haystack: &'h str,
                it: meta::CapturesMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for CaptureMatches<'r, 'h> {
                type Item = Captures<'h>;

                #[inline] fn next(&mut self) -> Option<Captures<'h>>
                {
                    let static_captures_len = self.it.regex().static_captures_len();
                    self.it.next().map(|caps| Captures {
                        haystack: self.haystack,
                        caps,
                        static_captures_len,
                    })
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for CaptureMatches<'r, 'h> {}
            /// An iterator over all substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct Split<'r, 'h> {
                haystack: &'h str,
                it: meta::Split<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Split<'r, 'h> {
                type Item = &'h str;

                #[inline] fn next(&mut self) -> Option<&'h str>
                { self.it.next().map(|span| &self.haystack[span])
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}
            /// An iterator over at most `N` substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct SplitN<'r, 'h> {
                haystack: &'h str,
                it: meta::SplitN<'r, 'h>,
            }

            impl<'r, 'h> Iterator for SplitN<'r, 'h> {
                type Item = &'h str;

                #[inline] fn next(&mut self) -> Option<&'h str>
                { self.it.next().map(|span| &self.haystack[span])
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}
            /// An iterator over the names of all capture groups in a regex.
            #[derive(Clone, Debug)]
            pub struct CaptureNames<'r>(captures::GroupInfoPatternNames<'r>);

            impl<'r> Iterator for CaptureNames<'r> {
                type Item = Option<&'r str>;

                #[inline] fn next(&mut self) -> Option<Option<&'r str>>
                { self.0.next()
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }

                #[inline] fn count(self) -> usize {
                    self.0.count()
                }
            }

            impl<'r> ExactSizeIterator for CaptureNames<'r> {}

            impl<'r> ::iter::FusedIterator for CaptureNames<'r> {}
            /// An iterator over all group matches in a [`Captures`] value.
            #[derive(Clone, Debug)]
            pub struct SubCaptureMatches<'c, 'h> {
                haystack: &'h str,
                it: captures::CapturesPatternIter<'c>,
            }

            impl<'c, 'h> Iterator for SubCaptureMatches<'c, 'h> {
                type Item = Option<Match<'h>>;

                #[inline] fn next(&mut self) -> Option<Option<Match<'h>>>
                { self.it.next().map(|group| {
                        group.map(|sp| Match::new(self.haystack, sp.start, sp.end))
                    })
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'c, 'h> ExactSizeIterator for SubCaptureMatches<'c, 'h> {}

            impl<'c, 'h> ::iter::FusedIterator for SubCaptureMatches<'c, 'h> {}
            /// A trait for types that can be used to replace matches in a haystack.
            pub trait Replacer
            {
                /// Appends possibly empty data to `dst` to replace the current match.
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String);
                /// Return a fixed unchanging replacement string.
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, str>> {
                    None
                }
                /// Returns a type that implements `Replacer`, but that borrows and wraps
                fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {
                    ReplacerRef(self)
                }
            }

            impl<'a> Replacer for &'a str
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    caps.expand(*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for &'a String
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_str().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }

            impl Replacer for String
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_str().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for Cow<'a, str>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_ref().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }

            impl<'a> Replacer for &'a Cow<'a, str>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_ref().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }

            impl<F, T> Replacer for F where
                F: FnMut(&Captures<'_>) -> T,
                T: AsRef<str>,
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    dst.push_str((*self)(caps).as_ref());
                }
            }
            /// A by-reference adaptor for a [`Replacer`].
            #[derive(Debug)]
            pub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);

            impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R>
           
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.0.replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>>
                { self.0.no_expansion()
                }
            }
            /// A helper type for forcing literal string replacement.
            #[derive(Clone, Debug)]
            pub struct NoExpand<'s>(pub &'s str);

            impl<'s> Replacer for NoExpand<'s>
            {
                fn replace_append(&mut self, _: &Captures<'_>, dst: &mut String) { dst.push_str(self.0); }
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { Some(Cow::Borrowed(self.0)) }
            }
            /// Quickly checks the given replacement string for whether interpolation
            fn no_expansion<T: AsRef<str>>(replacement: &T) -> Option<Cow<'_, str>>
            {
                let replacement = replacement.as_ref();
                match ::regex::find_byte::find_byte(b'$', replacement.as_bytes()) {
                    Some(_) => None,
                    None => Some(Cow::Borrowed(replacement)),
                }
            }
        }

    } pub use self::regex::string::*;

    pub mod regexset
    {
        use ::
        {
            *,
        };
        /*
        */
        pub mod bytes
        {
            /*!
            */
            use ::
            {
                regex::
                {
                    automata::{ meta, Input, PatternID, PatternSet, PatternSetIter },
                    bytes::RegexSetBuilder, Error,
                },
                string::{ String },
                *,
            };
            /*
            */
            /// Match multiple, possibly overlapping, regexes in a single search.
            #[derive(Clone)]
            pub struct RegexSet
            {
                pub meta: meta::Regex,
                pub patterns: alloc::sync::Arc<[String]>,
            }

            impl RegexSet
            {
                /// Create a new regex set with the given regular expressions.
                pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error> where
                    S: AsRef<str>,
                    I: IntoIterator<Item = S>,
                {
                    RegexSetBuilder::new(exprs).build()
                }
                /// Create a new empty regex set.
                pub fn empty() -> RegexSet
                {
                    let empty: [&str; 0] = [];
                    RegexSetBuilder::new(empty).build().unwrap()
                }
                /// Returns true if and only if one of the regexes in this set matches
                #[inline] pub fn is_match(&self, haystack: &[u8]) -> bool
                { self.is_match_at(haystack, 0)
                }
                /// Returns true if and only if one of the regexes in this set matches the
                #[inline] pub fn is_match_at(&self, haystack: &[u8], start: usize) -> bool
                { self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                }
                /// Returns the set of regexes that match in the given haystack.
                #[inline] pub fn matches(&self, haystack: &[u8]) -> SetMatches {
                    self.matches_at(haystack, 0)
                }
                /// Returns the set of regexes that match in the given haystack.
                #[inline] pub fn matches_at(&self, haystack: &[u8], start: usize) -> SetMatches
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    SetMatches(patset)
                }
                /// Returns the same as matches, but starts the search at the given
                #[inline] pub fn matches_read_at
                (
                    &self,
                    matches: &mut [bool],
                    haystack: &[u8],
                    start: usize,
                ) -> bool
                {
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    let mut input = Input::new(haystack);
                    input.set_start(start);
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    
                    for pid in patset.iter() {
                        matches[pid] = true;
                    }
                    !patset.is_empty()
                }
                /// An alias for `matches_read_at` to preserve backward compatibility.
                #[inline] pub fn read_matches_at
                
                (
                    &self,
                    matches: &mut [bool],
                    haystack: &[u8],
                    start: usize,
                ) -> bool
                { self.matches_read_at(matches, haystack, start)
                }
                /// Returns the total number of regexes in this set.
                #[inline] pub fn len(&self) -> usize {
                    self.meta.pattern_len()
                }
                /// Returns `true` if this set contains no regexes.
                #[inline] pub fn is_empty(&self) -> bool
                { self.meta.pattern_len() == 0
                }
                /// Returns the regex patterns that this regex set was constructed from.
                #[inline] pub fn patterns(&self) -> &[String] {
                    &self.patterns
                }
            }

            impl Default for RegexSet
            {
                fn default() -> Self {
                    RegexSet::empty()
                }
            }
            /// A set of matches returned by a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatches(PatternSet);

            impl SetMatches
            {
                /// Whether this set contains any matches.
                #[inline] pub fn matched_any(&self) -> bool {
                    !self.0.is_empty()
                }
                /// Whether all patterns in this set matched.
                pub fn matched_all(&self) -> bool
                { self.0.is_full()
                }
                /// Whether the regex at the given index matched.
                #[inline] pub fn matched(&self, index: usize) -> bool
                { self.0.contains(PatternID::new_unchecked(index))
                }
                /// The total number of regexes in the set that created these matches.
                #[inline] pub fn len(&self) -> usize {
                    self.0.capacity()
                }
                /// Returns an iterator over the indices of the regexes that matched.
                #[inline] pub fn iter(&self) -> SetMatchesIter<'_> {
                    SetMatchesIter(self.0.iter())
                }
            }

            impl IntoIterator for SetMatches {
                type IntoIter = SetMatchesIntoIter;
                type Item = usize;

                fn into_iter(self) -> Self::IntoIter
                {
                    let it = 0..self.0.capacity();
                    SetMatchesIntoIter { patset: self.0, it }
                }
            }

            impl<'a> IntoIterator for &'a SetMatches {
                type IntoIter = SetMatchesIter<'a>;
                type Item = usize;

                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            /// An owned iterator over the set of matches from a regex set.
            #[derive(Debug)]
            pub struct SetMatchesIntoIter {
                patset: PatternSet,
                it: ::ops::Range<usize>,
            }

            impl Iterator for SetMatchesIntoIter {
                type Item = usize;

                fn next(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next()?;
                        
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }

            impl DoubleEndedIterator for SetMatchesIntoIter
            {
                fn next_back(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next_back()?;
                        
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }
            }

            impl ::iter::FusedIterator for SetMatchesIntoIter {}
            /// A borrowed iterator over the set of matches from a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatchesIter<'a>(PatternSetIter<'a>);

            impl<'a> Iterator for SetMatchesIter<'a> {
                type Item = usize;

                fn next(&mut self) -> Option<usize>
                { self.0.next().map(|pid| pid.as_usize())
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            }

            impl<'a> DoubleEndedIterator for SetMatchesIter<'a>
           
            {
                fn next_back(&mut self) -> Option<usize>
                { self.0.next_back().map(|pid| pid.as_usize())
                }
            }

            impl<'a> ::iter::FusedIterator for SetMatchesIter<'a> {}

            impl ::fmt::Debug for RegexSet
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "RegexSet({:?})", self.patterns())
                }
            }
        }

        pub mod string
        {
            /*!
            */
            use ::
            {
                regex::
                {
                    automata::{ meta, Input, PatternID, PatternSet, PatternSetIter },
                    Error, RegexSetBuilder,
                },
                string::{ String },
                *,
            };
            /*
            */
            /// Match multiple, possibly overlapping, regexes in a single search.
            #[derive(Clone)]
            pub struct RegexSet {
                pub meta: meta::Regex,
                pub patterns: alloc::sync::Arc<[String]>,
            }

            impl RegexSet
            {
                /// Create a new regex set with the given regular expressions.
                pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error> where
                    S: AsRef<str>,
                    I: IntoIterator<Item = S>,
                {
                    RegexSetBuilder::new(exprs).build()
                }
                /// Create a new empty regex set.
                pub fn empty() -> RegexSet
                {
                    let empty: [&str; 0] = [];
                    RegexSetBuilder::new(empty).build().unwrap()
                }
                /// Returns true if and only if one of the regexes in this set matches
                #[inline] pub fn is_match(&self, haystack: &str) -> bool
                { self.is_match_at(haystack, 0)
                }
                /// Returns true if and only if one of the regexes in this set matches the
                #[inline] pub fn is_match_at(&self, haystack: &str, start: usize) -> bool
                { self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                }
                /// Returns the set of regexes that match in the given haystack.
                #[inline] pub fn matches(&self, haystack: &str) -> SetMatches {
                    self.matches_at(haystack, 0)
                }
                /// Returns the set of regexes that match in the given haystack.
                #[inline] pub fn matches_at(&self, haystack: &str, start: usize) -> SetMatches
                {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    SetMatches(patset)
                }
                /// Returns the same as matches, but starts the search at the given
                #[inline] pub fn matches_read_at
                (
                    &self,
                    matches: &mut [bool],
                    haystack: &str,
                    start: usize,
                ) -> bool
                {
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    let mut input = Input::new(haystack);
                    input.set_start(start);
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    
                    for pid in patset.iter() {
                        matches[pid] = true;
                    }
                    !patset.is_empty()
                }
                /// An alias for `matches_read_at` to preserve backward compatibility.
                #[inline] pub fn read_matches_at
                (
                    &self,
                    matches: &mut [bool],
                    haystack: &str,
                    start: usize,
                ) -> bool
                { self.matches_read_at(matches, haystack, start)
                }
                /// Returns the total number of regexes in this set.
                #[inline] pub fn len(&self) -> usize {
                    self.meta.pattern_len()
                }
                /// Returns `true` if this set contains no regexes.
                #[inline] pub fn is_empty(&self) -> bool
                { self.meta.pattern_len() == 0
                }
                /// Returns the regex patterns that this regex set was constructed from.
                #[inline] pub fn patterns(&self) -> &[String] {
                    &self.patterns
                }
            }

            impl Default for RegexSet
            {
                fn default() -> Self {
                    RegexSet::empty()
                }
            }
            /// A set of matches returned by a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatches(PatternSet);

            impl SetMatches
            {
                /// Whether this set contains any matches.
                #[inline] pub fn matched_any(&self) -> bool {
                    !self.0.is_empty()
                }
                /// Whether all patterns in this set matched.
                pub fn matched_all(&self) -> bool
                { self.0.is_full()
                }
                /// Whether the regex at the given index matched.
                #[inline] pub fn matched(&self, index: usize) -> bool
                { self.0.contains(PatternID::new_unchecked(index))
                }
                /// The total number of regexes in the set that created these matches.
                #[inline] pub fn len(&self) -> usize {
                    self.0.capacity()
                }
                /// Returns an iterator over the indices of the regexes that matched.
                #[inline] pub fn iter(&self) -> SetMatchesIter<'_> {
                    SetMatchesIter(self.0.iter())
                }
            }

            impl IntoIterator for SetMatches {
                type IntoIter = SetMatchesIntoIter;
                type Item = usize;

                fn into_iter(self) -> Self::IntoIter
                {
                    let it = 0..self.0.capacity();
                    SetMatchesIntoIter { patset: self.0, it }
                }
            }

            impl<'a> IntoIterator for &'a SetMatches {
                type IntoIter = SetMatchesIter<'a>;
                type Item = usize;

                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            /// An owned iterator over the set of matches from a regex set.
            #[derive(Debug)]
            pub struct SetMatchesIntoIter {
                patset: PatternSet,
                it: ::ops::Range<usize>,
            }

            impl Iterator for SetMatchesIntoIter {
                type Item = usize;

                fn next(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next()?;
                        
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }

            impl DoubleEndedIterator for SetMatchesIntoIter
            {
                fn next_back(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next_back()?;
                        
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }
            }

            impl ::iter::FusedIterator for SetMatchesIntoIter {}
            /// A borrowed iterator over the set of matches from a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatchesIter<'a>(PatternSetIter<'a>);

            impl<'a> Iterator for SetMatchesIter<'a> {
                type Item = usize;

                fn next(&mut self) -> Option<usize>
                { self.0.next().map(|pid| pid.as_usize())
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            }

            impl<'a> DoubleEndedIterator for SetMatchesIter<'a>
           
            {
                fn next_back(&mut self) -> Option<usize>
                { self.0.next_back().map(|pid| pid.as_usize())
                }
            }

            impl<'a> ::iter::FusedIterator for SetMatchesIter<'a> {}

            impl ::fmt::Debug for RegexSet
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "RegexSet({:?})", self.patterns())
                }
            }
        }
    } pub use self::regexset::string::*;

    pub mod syntax
    {
        /*!
        This crate provides a robust regular expression parser. */
        use ::
        {
            string::{ String },
            *,
        };

        pub use self::
        {
            error::Error,
            parser::{parse, Parser, ParserBuilder},
            unicode::UnicodeWordError,
        };
        /*
        */
        pub mod ast
        {
            /*!
            Defines an abstract syntax for regular expressions. */
            use ::
            {
                cmp::{ Ordering },
                boxed::{ Box },
                regex::syntax::{ ast::visitor::{ visit, Visitor }, },
                string::{ String },
                vec::{ self, Vec },
                *,
            };
            /*
            */
            pub mod parse    
            {
                /*!
                This module provides a regular expression parser. */
                use ::
                {
                    borrow::{ Borrow },
                    boxed::{ Box },
                    cell::{ Cell, RefCell },
                    regex::syntax::
                    {
                        ast::{self, Ast, Position, Span},
                        either::Either,
                        is_escapeable_character, is_meta_character,
                    },
                    string::{ String, ToString },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                type Result<T> = ::result::Result<T, ast::Error>;
                /// A primitive is an expression with no sub-expressions. This includes
                #[derive(Clone, Debug, Eq, PartialEq)]
                enum Primitive {
                    Literal(ast::Literal),
                    Assertion(ast::Assertion),
                    Dot(Span),
                    Perl(ast::ClassPerl),
                    Unicode(ast::ClassUnicode),
                }

                impl Primitive
                {
                    /// Return the span of this primitive.
                    fn span(&self) -> &Span {
                        match *self {
                            Primitive::Literal(ref x) => &x.span,
                            Primitive::Assertion(ref x) => &x.span,
                            Primitive::Dot(ref span) => span,
                            Primitive::Perl(ref x) => &x.span,
                            Primitive::Unicode(ref x) => &x.span,
                        }
                    }
                    /// Convert this primitive into a proper AST.
                    fn into_ast(self) -> Ast {
                        match self {
                            Primitive::Literal(lit) => Ast::literal(lit),
                            Primitive::Assertion(assert) => Ast::assertion(assert),
                            Primitive::Dot(span) => Ast::dot(span),
                            Primitive::Perl(cls) => Ast::class_perl(cls),
                            Primitive::Unicode(cls) => Ast::class_unicode(cls),
                        }
                    }
                    /// Convert this primitive into an item in a character class.
                    fn into_class_set_item<P: Borrow<Parser>>(
                        self,
                        p: &ParserI<'_, P>,
                    ) -> Result<ast::ClassSetItem> {
                        use self::Primitive::*;
                        use ::regex::syntax::ast::ClassSetItem;

                        match self {
                            Literal(lit) => Ok(ClassSetItem::Literal(lit)),
                            Perl(cls) => Ok(ClassSetItem::Perl(cls)),
                            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),
                            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),
                        }
                    }
                    /// Convert this primitive into a literal in a character class. In
                    fn into_class_literal<P: Borrow<Parser>>(
                        self,
                        p: &ParserI<'_, P>,
                    ) -> Result<ast::Literal> {
                        use self::Primitive::*;

                        match self {
                            Literal(lit) => Ok(lit),
                            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),
                        }
                    }
                }
                /// A builder for a regular expression parser.
                #[derive(Clone, Debug)]
                pub struct ParserBuilder {
                    ignore_whitespace: bool,
                    nest_limit: u32,
                    octal: bool,
                    empty_min_range: bool,
                }

                impl Default for ParserBuilder {
                    fn default() -> ParserBuilder {
                        ParserBuilder::new()
                    }
                }

                impl ParserBuilder
                {
                    /// Create a new parser builder with a default configuration.
                    pub fn new() -> ParserBuilder {
                        ParserBuilder {
                            ignore_whitespace: false,
                            nest_limit: 250,
                            octal: false,
                            empty_min_range: false,
                        }
                    }
                    /// Build a parser from this configuration with the given pattern.
                    pub fn build(&self) -> Parser {
                        Parser {
                            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),
                            capture_index: Cell::new(0),
                            nest_limit: self.nest_limit,
                            octal: self.octal,
                            empty_min_range: self.empty_min_range,
                            initial_ignore_whitespace: self.ignore_whitespace,
                            ignore_whitespace: Cell::new(self.ignore_whitespace),
                            comments: RefCell::new(vec![]),
                            stack_group: RefCell::new(vec![]),
                            stack_class: RefCell::new(vec![]),
                            capture_names: RefCell::new(vec![]),
                            scratch: RefCell::new(String::new()),
                        }
                    }
                    /// Set the nesting limit for this parser.
                    pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {
                        self.nest_limit = limit;
                        self
                    }
                    /// Whether to support octal syntax or not.
                    pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {
                        self.octal = yes;
                        self
                    }
                    /// Enable verbose mode in the regular expression.
                    pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {
                        self.ignore_whitespace = yes;
                        self
                    }
                    /// Allow using `{,n}` as an equivalent to `{0,n}`.
                    pub fn empty_min_range(&mut self, yes: bool) -> &mut ParserBuilder {
                        self.empty_min_range = yes;
                        self
                    }
                }
                /// A regular expression parser.
                #[derive(Clone, Debug)]
                pub struct Parser
                {
                    /// The current position of the parser.
                    pos: Cell<Position>,
                    /// The current capture index.
                    capture_index: Cell<u32>,
                    /// The maximum number of open parens/brackets allowed. If the parser
                    nest_limit: u32,
                    /// Whether to support octal syntax or not. When `false`, the parser will
                    octal: bool,
                    /// The initial setting for `ignore_whitespace` as provided by
                    initial_ignore_whitespace: bool,
                    /// Whether the parser supports `{,n}` repetitions as an equivalent to
                    empty_min_range: bool,
                    /// Whether whitespace should be ignored. When enabled, comments are
                    ignore_whitespace: Cell<bool>,
                    /// A list of comments, in order of appearance.
                    comments: RefCell<Vec<ast::Comment>>,
                    /// A stack of grouped sub-expressions, including alternations.
                    stack_group: RefCell<Vec<GroupState>>,
                    /// A stack of nested character classes. This is only non-empty when
                    stack_class: RefCell<Vec<ClassState>>,
                    /// A sorted sequence of capture names. This is used to detect duplicate
                    capture_names: RefCell<Vec<ast::CaptureName>>,
                    /// A scratch buffer used in various places. Mostly this is used to
                    scratch: RefCell<String>,
                }
                /// ParserI is the internal parser implementation.
                #[derive(Clone, Debug)]
                struct ParserI<'s, P>
                {
                    /// The parser state/configuration.
                    parser: P,
                    /// The full regular expression provided by the user.
                    pattern: &'s str,
                }
                /// GroupState represents a single stack frame while parsing nested groups
                #[derive(Clone, Debug)]
                enum GroupState
                {
                    /// This state is pushed whenever an opening group is found.
                    Group {
                        /// The concatenation immediately preceding the opening group.
                        concat: ast::Concat,
                        /// The group that has been opened. Its sub-AST is always empty.
                        group: ast::Group,
                        /// Whether this group has the `x` flag enabled or not.
                        ignore_whitespace: bool,
                    },
                    /// This state is pushed whenever a new alternation branch is found. If
                    Alternation(ast::Alternation),
                }
                /// ClassState represents a single stack frame while parsing character classes.
                #[derive(Clone, Debug)]
                enum ClassState
                {
                    /// This state is pushed whenever an opening bracket is found.
                    Open {
                        /// The union of class items immediately preceding this class.
                        union: ast::ClassSetUnion,
                        /// The class that has been opened. Typically this just corresponds
                        set: ast::ClassBracketed,
                    },
                    /// This state is pushed when a operator is seen. When popped, the stored
                    Op {
                        /// The type of the operation, i.e., &&, -- or ~~.
                        kind: ast::ClassSetBinaryOpKind,
                        /// The left-hand side of the operator.
                        lhs: ast::ClassSet,
                    },
                }

                impl Parser
                {
                    /// Create a new parser with a default configuration.
                    pub fn new() -> Parser {
                        ParserBuilder::new().build()
                    }
                    /// Parse the regular expression into an abstract syntax tree.
                    pub fn parse(&mut self, pattern: &str) -> Result<Ast> {
                        ParserI::new(self, pattern).parse()
                    }
                    /// Parse the regular expression and return an abstract syntax tree with
                    pub fn parse_with_comments
                    (
                        &mut self,
                        pattern: &str,
                    ) -> Result<ast::WithComments> {
                        ParserI::new(self, pattern).parse_with_comments()
                    }
                    /// Reset the internal state of a parser.
                    fn reset(&self) {
                        self.pos.set(Position { offset: 0, line: 1, column: 1 });
                        self.ignore_whitespace.set(self.initial_ignore_whitespace);
                        self.comments.borrow_mut().clear();
                        self.stack_group.borrow_mut().clear();
                        self.stack_class.borrow_mut().clear();
                    }
                }

                impl<'s, P: Borrow<Parser>> ParserI<'s, P>
                {
                    /// Build an internal parser from a parser configuration and a pattern.
                    fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {
                        ParserI { parser, pattern }
                    }
                    /// Return a reference to the parser state.
                    fn parser(&self) -> &Parser {
                        self.parser.borrow()
                    }
                    /// Return a reference to the pattern being parsed.
                    fn pattern(&self) -> &str {
                        self.pattern
                    }
                    /// Create a new error with the given span and error type.
                    fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {
                        ast::Error { kind, pattern: self.pattern().to_string(), span }
                    }
                    /// Return the current offset of the parser.
                    fn offset(&self) -> usize {
                        self.parser().pos.get().offset
                    }
                    /// Return the current line number of the parser.
                    fn line(&self) -> usize {
                        self.parser().pos.get().line
                    }
                    /// Return the current column of the parser.
                    fn column(&self) -> usize {
                        self.parser().pos.get().column
                    }
                    /// Return the next capturing index. Each subsequent call increments the
                    fn next_capture_index(&self, span: Span) -> Result<u32> {
                        let current = self.parser().capture_index.get();
                        let i = current.checked_add(1).ok_or_else(|| {
                            self.error(span, ast::ErrorKind::CaptureLimitExceeded)
                        })?;
                        self.parser().capture_index.set(i);
                        Ok(i)
                    }
                    /// Adds the given capture name to this parser. If this capture name has
                    fn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()> {
                        let mut names = self.parser().capture_names.borrow_mut();
                        match names
                            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())
                        {
                            Err(i) => {
                                names.insert(i, cap.clone());
                                Ok(())
                            }
                            Ok(i) => Err(self.error(
                                cap.span,
                                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },
                            )),
                        }
                    }
                    /// Return whether the parser should ignore whitespace or not.
                    fn ignore_whitespace(&self) -> bool {
                        self.parser().ignore_whitespace.get()
                    }
                    /// Return the character at the current position of the parser.
                    fn char(&self) -> char {
                        self.char_at(self.offset())
                    }
                    /// Return the character at the given position.
                    fn char_at(&self, i: usize) -> char {
                        self.pattern()[i..]
                            .chars()
                            .next()
                            .unwrap_or_else(|| panic!("expected char at offset {}", i))
                    }
                    /// Bump the parser to the next Unicode scalar value.
                    fn bump(&self) -> bool {
                        if self.is_eof() {
                            return false;
                        }
                        let Position { mut offset, mut line, mut column } = self.pos();
                        
                        if self.char() == '\n' {
                            line = line.checked_add(1).unwrap();
                            column = 1;
                        } else {
                            column = column.checked_add(1).unwrap();
                        }
                        offset += self.char().len_utf8();
                        self.parser().pos.set(Position { offset, line, column });
                        self.pattern()[self.offset()..].chars().next().is_some()
                    }
                    /// If the substring starting at the current position of the parser has
                    fn bump_if(&self, prefix: &str) -> bool {
                        if self.pattern()[self.offset()..].starts_with(prefix) {
                            for _ in 0..prefix.chars().count() {
                                self.bump();
                            }
                            true
                        } else {
                            false
                        }
                    }
                    /// Returns true if and only if the parser is positioned at a look-around
                    fn is_lookaround_prefix(&self) -> bool {
                        self.bump_if("?=")
                            || self.bump_if("?!")
                            || self.bump_if("?<=")
                            || self.bump_if("?<!")
                    }
                    /// Bump the parser, and if the `x` flag is enabled, bump through any
                    fn bump_and_bump_space(&self) -> bool {
                        if !self.bump() {
                            return false;
                        }
                        self.bump_space();
                        !self.is_eof()
                    }
                    /// If the `x` flag is enabled (i.e., whitespace insensitivity with
                    fn bump_space(&self) {
                        if !self.ignore_whitespace() {
                            return;
                        }
                        while !self.is_eof()
                        {
                            if self.char().is_whitespace() {
                                self.bump();
                            } else if self.char() == '#' {
                                let start = self.pos();
                                let mut comment_text = String::new();
                                self.bump();
                                while !self.is_eof() {
                                    let c = self.char();
                                    self.bump();
                                    if c == '\n' {
                                        break;
                                    }
                                    comment_text.push(c);
                                }
                                let comment = ast::Comment {
                                    span: Span::new(start, self.pos()),
                                    comment: comment_text,
                                };
                                self.parser().comments.borrow_mut().push(comment);
                            } else {
                                break;
                            }
                        }
                    }
                    /// Peek at the next character in the input without advancing the parser.
                    fn peek(&self) -> Option<char> {
                        if self.is_eof() {
                            return None;
                        }
                        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()
                    }
                    /// Like peek, but will ignore spaces when the parser is in whitespace
                    fn peek_space(&self) -> Option<char> {
                        if !self.ignore_whitespace() {
                            return self.peek();
                        }
                        
                        if self.is_eof() {
                            return None;
                        }
                        let mut start = self.offset() + self.char().len_utf8();
                        let mut in_comment = false;
                        for (i, c) in self.pattern()[start..].char_indices()
                        {
                            if c.is_whitespace() {
                                continue;
                            } else if !in_comment && c == '#' {
                                in_comment = true;
                            } else if in_comment && c == '\n' {
                                in_comment = false;
                            } else {
                                start += i;
                                break;
                            }
                        }
                        self.pattern()[start..].chars().next()
                    }
                    /// Returns true if the next call to `bump` would return false.
                    fn is_eof(&self) -> bool {
                        self.offset() == self.pattern().len()
                    }
                    /// Return the current position of the parser, which includes the offset,
                    fn pos(&self) -> Position {
                        self.parser().pos.get()
                    }
                    /// Create a span at the current position of the parser. Both the start
                    fn span(&self) -> Span {
                        Span::splat(self.pos())
                    }
                    /// Create a span that covers the current character.
                    fn span_char(&self) -> Span {
                        let mut next = Position {
                            offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),
                            line: self.line(),
                            column: self.column().checked_add(1).unwrap(),
                        };
                        
                        if self.char() == '\n' {
                            next.line += 1;
                            next.column = 1;
                        }
                        Span::new(self.pos(), next)
                    }
                    /// Parse and push a single alternation on to the parser's internal stack.
                    #[inline(never)]
                    fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
                        assert_eq!(self.char(), '|');
                        concat.span.end = self.pos();
                        self.push_or_add_alternation(concat);
                        self.bump();
                        Ok(ast::Concat { span: self.span(), asts: vec![] })
                    }
                    /// Pushes or adds the given branch of an alternation to the parser's
                    fn push_or_add_alternation(&self, concat: ast::Concat) {
                        use self::GroupState::*;

                        let mut stack = self.parser().stack_group.borrow_mut();
                        
                        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {
                            alts.asts.push(concat.into_ast());
                            return;
                        }
                        stack.push(Alternation(ast::Alternation {
                            span: Span::new(concat.span.start, self.pos()),
                            asts: vec![concat.into_ast()],
                        }));
                    }
                    /// Parse and push a group AST (and its parent concatenation) on to the
                    #[inline(never)]
                    fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
                        assert_eq!(self.char(), '(');
                        match self.parse_group()? {
                            Either::Left(set) => {
                                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);
                                
                                if let Some(v) = ignore {
                                    self.parser().ignore_whitespace.set(v);
                                }

                                concat.asts.push(Ast::flags(set));
                                Ok(concat)
                            }
                            Either::Right(group) => {
                                let old_ignore_whitespace = self.ignore_whitespace();
                                let new_ignore_whitespace = group
                                    .flags()
                                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))
                                    .unwrap_or(old_ignore_whitespace);
                                self.parser().stack_group.borrow_mut().push(
                                    GroupState::Group {
                                        concat,
                                        group,
                                        ignore_whitespace: old_ignore_whitespace,
                                    },
                                );
                                self.parser().ignore_whitespace.set(new_ignore_whitespace);
                                Ok(ast::Concat { span: self.span(), asts: vec![] })
                            }
                        }
                    }
                    /// Pop a group AST from the parser's internal stack and set the group's
                    #[inline(never)]
                    fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {
                        use self::GroupState::*;

                        assert_eq!(self.char(), ')');
                        let mut stack = self.parser().stack_group.borrow_mut();
                        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack
                            .pop()
                        {
                            Some(Group { concat, group, ignore_whitespace }) => {
                                (concat, group, ignore_whitespace, None)
                            }
                            Some(Alternation(alt)) => match stack.pop() {
                                Some(Group { concat, group, ignore_whitespace }) => {
                                    (concat, group, ignore_whitespace, Some(alt))
                                }
                                None | Some(Alternation(_)) => {
                                    return Err(self.error(
                                        self.span_char(),
                                        ast::ErrorKind::GroupUnopened,
                                    ));
                                }
                            },
                            None => {
                                return Err(self
                                    .error(self.span_char(), ast::ErrorKind::GroupUnopened));
                            }
                        };
                        self.parser().ignore_whitespace.set(ignore_whitespace);
                        group_concat.span.end = self.pos();
                        self.bump();
                        group.span.end = self.pos();
                        match alt {
                            Some(mut alt) => {
                                alt.span.end = group_concat.span.end;
                                alt.asts.push(group_concat.into_ast());
                                group.ast = Box::new(alt.into_ast());
                            }
                            None => {
                                group.ast = Box::new(group_concat.into_ast());
                            }
                        }
                        prior_concat.asts.push(Ast::group(group));
                        Ok(prior_concat)
                    }
                    /// Pop the last state from the parser's internal stack, if it exists, and
                    #[inline(never)]
                    fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {
                        concat.span.end = self.pos();
                        let mut stack = self.parser().stack_group.borrow_mut();
                        let ast = match stack.pop() {
                            None => Ok(concat.into_ast()),
                            Some(GroupState::Alternation(mut alt)) => {
                                alt.span.end = self.pos();
                                alt.asts.push(concat.into_ast());
                                Ok(Ast::alternation(alt))
                            }
                            Some(GroupState::Group { group, .. }) => {
                                return Err(
                                    self.error(group.span, ast::ErrorKind::GroupUnclosed)
                                );
                            }
                        };
                        // If we try to pop again, there should be nothing.
                        match stack.pop() {
                            None => ast,
                            Some(GroupState::Alternation(_)) => {
                                unreachable!()
                            }
                            Some(GroupState::Group { group, .. }) => {
                                Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))
                            }
                        }
                    }
                    /// Parse the opening of a character class and push the current class
                    #[inline(never)]
                    fn push_class_open(
                        &self,
                        parent_union: ast::ClassSetUnion,
                    ) -> Result<ast::ClassSetUnion> {
                        assert_eq!(self.char(), '[');

                        let (nested_set, nested_union) = self.parse_set_class_open()?;
                        self.parser()
                            .stack_class
                            .borrow_mut()
                            .push(ClassState::Open { union: parent_union, set: nested_set });
                        Ok(nested_union)
                    }
                    /// Parse the end of a character class set and pop the character class
                    #[inline(never)]
                    fn pop_class(
                        &self,
                        nested_union: ast::ClassSetUnion,
                    ) -> Result<Either<ast::ClassSetUnion, ast::ClassBracketed>> {
                        assert_eq!(self.char(), ']');

                        let item = ast::ClassSet::Item(nested_union.into_item());
                        let prevset = self.pop_class_op(item);
                        let mut stack = self.parser().stack_class.borrow_mut();
                        match stack.pop() {
                            None => {
                                panic!("unexpected empty character class stack")
                            }
                            Some(ClassState::Op { .. }) => {
                                panic!("unexpected ClassState::Op")
                            }
                            Some(ClassState::Open { mut union, mut set }) => {
                                self.bump();
                                set.span.end = self.pos();
                                set.kind = prevset;
                                
                                if stack.is_empty() {
                                    Ok(Either::Right(set))
                                } else {
                                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));
                                    Ok(Either::Left(union))
                                }
                            }
                        }
                    }
                    /// Return an "unclosed class" error whose span points to the most
                    #[inline(never)]
                    fn unclosed_class_error(&self) -> ast::Error {
                        for state in self.parser().stack_class.borrow().iter().rev()
                        {
                            if let ClassState::Open { ref set, .. } = *state {
                                return self.error(set.span, ast::ErrorKind::ClassUnclosed);
                            }
                        }
                        panic!("no open character class found")
                    }
                    /// Push the current set of class items on to the class parser's stack as
                    #[inline(never)]
                    fn push_class_op(
                        &self,
                        next_kind: ast::ClassSetBinaryOpKind,
                        next_union: ast::ClassSetUnion,
                    ) -> ast::ClassSetUnion {
                        let item = ast::ClassSet::Item(next_union.into_item());
                        let new_lhs = self.pop_class_op(item);
                        self.parser()
                            .stack_class
                            .borrow_mut()
                            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });
                        ast::ClassSetUnion { span: self.span(), items: vec![] }
                    }
                    /// Pop a character class set from the character class parser stack. If the
                    #[inline(never)]
                    fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {
                        let mut stack = self.parser().stack_class.borrow_mut();
                        let (kind, lhs) = match stack.pop() {
                            Some(ClassState::Op { kind, lhs }) => (kind, lhs),
                            Some(state @ ClassState::Open { .. }) => {
                                stack.push(state);
                                return rhs;
                            }
                            None => unreachable!(),
                        };
                        let span = Span::new(lhs.span().start, rhs.span().end);
                        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
                            span,
                            kind,
                            lhs: Box::new(lhs),
                            rhs: Box::new(rhs),
                        })
                    }
                }

                impl<'s, P: Borrow<Parser>> ParserI<'s, P>
                {
                    /// Parse the regular expression into an abstract syntax tree.
                    fn parse(&self) -> Result<Ast> {
                        self.parse_with_comments().map(|astc| astc.ast)
                    }
                    /// Parse the regular expression and return an abstract syntax tree with
                    fn parse_with_comments(&self) -> Result<ast::WithComments> {
                        assert_eq!(self.offset(), 0, "parser can only be used once");
                        self.parser().reset();
                        let mut concat = ast::Concat { span: self.span(), asts: vec![] };

                        loop
                        {
                            self.bump_space();
                            if self.is_eof() {
                                break;
                            }
                            match self.char() {
                                '(' => concat = self.push_group(concat)?,
                                ')' => concat = self.pop_group(concat)?,
                                '|' => concat = self.push_alternate(concat)?,
                                '[' => {
                                    let class = self.parse_set_class()?;
                                    concat.asts.push(Ast::class_bracketed(class));
                                }
                                '?' => {
                                    concat = self.parse_uncounted_repetition(
                                        concat,
                                        ast::RepetitionKind::ZeroOrOne,
                                    )?;
                                }
                                '*' => {
                                    concat = self.parse_uncounted_repetition(
                                        concat,
                                        ast::RepetitionKind::ZeroOrMore,
                                    )?;
                                }
                                '+' => {
                                    concat = self.parse_uncounted_repetition(
                                        concat,
                                        ast::RepetitionKind::OneOrMore,
                                    )?;
                                }
                                '{' => {
                                    concat = self.parse_counted_repetition(concat)?;
                                }
                                _ => concat.asts.push(self.parse_primitive()?.into_ast()),
                            }
                        }
                        let ast = self.pop_group_end(concat)?;
                        NestLimiter::new(self).check(&ast)?;
                        Ok(ast::WithComments {
                            ast,
                            comments: mem::replace(
                                &mut *self.parser().comments.borrow_mut(),
                                vec![],
                            ),
                        })
                    }
                    /// Parses an uncounted repetition operation. An uncounted repetition
                    #[inline(never)]
                    fn parse_uncounted_repetition(
                        &self,
                        mut concat: ast::Concat,
                        kind: ast::RepetitionKind,
                    ) -> Result<ast::Concat> {
                        assert!(
                            self.char() == '?' || self.char() == '*' || self.char() == '+'
                        );
                        let op_start = self.pos();
                        let ast = match concat.asts.pop() {
                            Some(ast) => ast,
                            None => {
                                return Err(
                                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                        };
                        match ast {
                            Ast::Empty(_) | Ast::Flags(_) => {
                                return Err(
                                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                            _ => {}
                        }
                        let mut greedy = true;
                        
                        if self.bump() && self.char() == '?' {
                            greedy = false;
                            self.bump();
                        }
                        concat.asts.push(Ast::repetition(ast::Repetition {
                            span: ast.span().with_end(self.pos()),
                            op: ast::RepetitionOp {
                                span: Span::new(op_start, self.pos()),
                                kind,
                            },
                            greedy,
                            ast: Box::new(ast),
                        }));
                        Ok(concat)
                    }
                    /// Parses a counted repetition operation. A counted repetition operator
                    #[inline(never)]
                    fn parse_counted_repetition(
                        &self,
                        mut concat: ast::Concat,
                    ) -> Result<ast::Concat> {
                        assert!(self.char() == '{');
                        let start = self.pos();
                        let ast = match concat.asts.pop() {
                            Some(ast) => ast,
                            None => {
                                return Err(
                                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                        };
                        match ast {
                            Ast::Empty(_) | Ast::Flags(_) => {
                                return Err(
                                    self.error(self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                            _ => {}
                        }
                        
                        if !self.bump_and_bump_space() {
                            return Err(self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::RepetitionCountUnclosed,
                            ));
                        }
                        let count_start = specialize_err(
                            self.parse_decimal(),
                            ast::ErrorKind::DecimalEmpty,
                            ast::ErrorKind::RepetitionCountDecimalEmpty,
                        );
                        
                        if self.is_eof() {
                            return Err(self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::RepetitionCountUnclosed,
                            ));
                        }
                        let range = if self.char() == ',' {
                            if !self.bump_and_bump_space() {
                                return Err(self.error(
                                    Span::new(start, self.pos()),
                                    ast::ErrorKind::RepetitionCountUnclosed,
                                ));
                            }
                            
                            if self.char() != '}' {
                                let count_start = match count_start {
                                    Ok(c) => c,
                                    Err(err)
                                        if err.kind
                                            == ast::ErrorKind::RepetitionCountDecimalEmpty =>
                                    {
                                        if self.parser().empty_min_range {
                                            0
                                        } else {
                                            return Err(err);
                                        }
                                    }
                                    err => err?,
                                };
                                let count_end = specialize_err(
                                    self.parse_decimal(),
                                    ast::ErrorKind::DecimalEmpty,
                                    ast::ErrorKind::RepetitionCountDecimalEmpty,
                                )?;
                                ast::RepetitionRange::Bounded(count_start, count_end)
                            } else {
                                ast::RepetitionRange::AtLeast(count_start?)
                            }
                        } else {
                            ast::RepetitionRange::Exactly(count_start?)
                        };

                        if self.is_eof() || self.char() != '}' {
                            return Err(self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::RepetitionCountUnclosed,
                            ));
                        }

                        let mut greedy = true;
                        
                        if self.bump_and_bump_space() && self.char() == '?' {
                            greedy = false;
                            self.bump();
                        }

                        let op_span = Span::new(start, self.pos());
                        
                        if !range.is_valid() {
                            return Err(
                                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)
                            );
                        }
                        concat.asts.push(Ast::repetition(ast::Repetition {
                            span: ast.span().with_end(self.pos()),
                            op: ast::RepetitionOp {
                                span: op_span,
                                kind: ast::RepetitionKind::Range(range),
                            },
                            greedy,
                            ast: Box::new(ast),
                        }));
                        Ok(concat)
                    }
                    /// Parse a group (which contains a sub-expression) or a set of flags.
                    #[inline(never)]
                    fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {
                        assert_eq!(self.char(), '(');
                        let open_span = self.span_char();
                        self.bump();
                        self.bump_space();
                        
                        if self.is_lookaround_prefix() {
                            return Err(self.error(
                                Span::new(open_span.start, self.span().end),
                                ast::ErrorKind::UnsupportedLookAround,
                            ));
                        }
                        let inner_span = self.span();
                        let mut starts_with_p = true;
                        
                        if self.bump_if("?P<") || {
                            starts_with_p = false;
                            self.bump_if("?<")
                        } {
                            let capture_index = self.next_capture_index(open_span)?;
                            let name = self.parse_capture_name(capture_index)?;
                            Ok(Either::Right(ast::Group {
                                span: open_span,
                                kind: ast::GroupKind::CaptureName { starts_with_p, name },
                                ast: Box::new(Ast::empty(self.span())),
                            }))
                        } else if self.bump_if("?") {
                            if self.is_eof() {
                                return Err(
                                    self.error(open_span, ast::ErrorKind::GroupUnclosed)
                                );
                            }
                            let flags = self.parse_flags()?;
                            let char_end = self.char();
                            self.bump();
                            if char_end == ')' {
                                if flags.items.is_empty() {
                                    return Err(self.error(
                                        inner_span,
                                        ast::ErrorKind::RepetitionMissing,
                                    ));
                                }
                                Ok(Either::Left(ast::SetFlags {
                                    span: Span { end: self.pos(), ..open_span },
                                    flags,
                                }))
                            } else {
                                assert_eq!(char_end, ':');
                                Ok(Either::Right(ast::Group {
                                    span: open_span,
                                    kind: ast::GroupKind::NonCapturing(flags),
                                    ast: Box::new(Ast::empty(self.span())),
                                }))
                            }
                        } else {
                            let capture_index = self.next_capture_index(open_span)?;
                            Ok(Either::Right(ast::Group {
                                span: open_span,
                                kind: ast::GroupKind::CaptureIndex(capture_index),
                                ast: Box::new(Ast::empty(self.span())),
                            }))
                        }
                    }
                    /// Parses a capture group name. Assumes that the parser is positioned at
                    #[inline(never)]
                    fn parse_capture_name(
                        &self,
                        capture_index: u32,
                    ) -> Result<ast::CaptureName> {
                        if self.is_eof() {
                            return Err(self
                                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
                        }
                        let start = self.pos();

                        loop
                        {
                            if self.char() == '>' {
                                break;
                            }
                            
                            if !is_capture_char(self.char(), self.pos() == start) {
                                return Err(self.error(
                                    self.span_char(),
                                    ast::ErrorKind::GroupNameInvalid,
                                ));
                            }
                            
                            if !self.bump() {
                                break;
                            }
                        }
                        let end = self.pos();
                        
                        if self.is_eof() {
                            return Err(self
                                .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
                        }
                        assert_eq!(self.char(), '>');
                        self.bump();
                        let name = &self.pattern()[start.offset..end.offset];
                        
                        if name.is_empty() {
                            return Err(self.error(
                                Span::new(start, start),
                                ast::ErrorKind::GroupNameEmpty,
                            ));
                        }
                        let capname = ast::CaptureName {
                            span: Span::new(start, end),
                            name: name.to_string(),
                            index: capture_index,
                        };
                        self.add_capture_name(&capname)?;
                        Ok(capname)
                    }
                    /// Parse a sequence of flags starting at the current character.
                    #[inline(never)]
                    fn parse_flags(&self) -> Result<ast::Flags> {
                        let mut flags = ast::Flags { span: self.span(), items: vec![] };
                        let mut last_was_negation = None;
                        while self.char() != ':' && self.char() != ')' {
                            if self.char() == '-' {
                                last_was_negation = Some(self.span_char());
                                let item = ast::FlagsItem {
                                    span: self.span_char(),
                                    kind: ast::FlagsItemKind::Negation,
                                };
                                
                                if let Some(i) = flags.add_item(item) {
                                    return Err(self.error(
                                        self.span_char(),
                                        ast::ErrorKind::FlagRepeatedNegation {
                                            original: flags.items[i].span,
                                        },
                                    ));
                                }
                            } else {
                                last_was_negation = None;
                                let item = ast::FlagsItem {
                                    span: self.span_char(),
                                    kind: ast::FlagsItemKind::Flag(self.parse_flag()?),
                                };
                                
                                if let Some(i) = flags.add_item(item) {
                                    return Err(self.error(
                                        self.span_char(),
                                        ast::ErrorKind::FlagDuplicate {
                                            original: flags.items[i].span,
                                        },
                                    ));
                                }
                            }
                            
                            if !self.bump() {
                                return Err(
                                    self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)
                                );
                            }
                        }
                        
                        if let Some(span) = last_was_negation {
                            return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));
                        }
                        flags.span.end = self.pos();
                        Ok(flags)
                    }
                    /// Parse the current character as a flag. Do not advance the parser.
                    #[inline(never)]
                    fn parse_flag(&self) -> Result<ast::Flag> {
                        match self.char() {
                            'i' => Ok(ast::Flag::CaseInsensitive),
                            'm' => Ok(ast::Flag::MultiLine),
                            's' => Ok(ast::Flag::DotMatchesNewLine),
                            'U' => Ok(ast::Flag::SwapGreed),
                            'u' => Ok(ast::Flag::Unicode),
                            'R' => Ok(ast::Flag::CRLF),
                            'x' => Ok(ast::Flag::IgnoreWhitespace),
                            _ => {
                                Err(self
                                    .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))
                            }
                        }
                    }
                    /// Parse a primitive AST. e.g., A literal, non-set character class or
                    fn parse_primitive(&self) -> Result<Primitive> {
                        match self.char() {
                            '\\' => self.parse_escape(),
                            '.' => {
                                let ast = Primitive::Dot(self.span_char());
                                self.bump();
                                Ok(ast)
                            }
                            '^' => {
                                let ast = Primitive::Assertion(ast::Assertion {
                                    span: self.span_char(),
                                    kind: ast::AssertionKind::StartLine,
                                });
                                self.bump();
                                Ok(ast)
                            }
                            '$' => {
                                let ast = Primitive::Assertion(ast::Assertion {
                                    span: self.span_char(),
                                    kind: ast::AssertionKind::EndLine,
                                });
                                self.bump();
                                Ok(ast)
                            }
                            c => {
                                let ast = Primitive::Literal(ast::Literal {
                                    span: self.span_char(),
                                    kind: ast::LiteralKind::Verbatim,
                                    c,
                                });
                                self.bump();
                                Ok(ast)
                            }
                        }
                    }
                    /// Parse an escape sequence as a primitive AST.
                    #[inline(never)]
                    fn parse_escape(&self) -> Result<Primitive> {
                        assert_eq!(self.char(), '\\');
                        let start = self.pos();
                        
                        if !self.bump() {
                            return Err(self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::EscapeUnexpectedEof,
                            ));
                        }
                        let c = self.char();
                        // Put some of the more complicated routines into helpers.
                        match c {
                            '0'..='7' => {
                                if !self.parser().octal {
                                    return Err(self.error(
                                        Span::new(start, self.span_char().end),
                                        ast::ErrorKind::UnsupportedBackreference,
                                    ));
                                }
                                let mut lit = self.parse_octal();
                                lit.span.start = start;
                                return Ok(Primitive::Literal(lit));
                            }
                            '8'..='9' if !self.parser().octal => {
                                return Err(self.error(
                                    Span::new(start, self.span_char().end),
                                    ast::ErrorKind::UnsupportedBackreference,
                                ));
                            }
                            'x' | 'u' | 'U' => {
                                let mut lit = self.parse_hex()?;
                                lit.span.start = start;
                                return Ok(Primitive::Literal(lit));
                            }
                            'p' | 'P' => {
                                let mut cls = self.parse_unicode_class()?;
                                cls.span.start = start;
                                return Ok(Primitive::Unicode(cls));
                            }
                            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {
                                let mut cls = self.parse_perl_class();
                                cls.span.start = start;
                                return Ok(Primitive::Perl(cls));
                            }
                            _ => {}
                        }

                        // Handle all of the one letter sequences inline.
                        self.bump();
                        let span = Span::new(start, self.pos());
                        
                        if is_meta_character(c) {
                            return Ok(Primitive::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Meta,
                                c,
                            }));
                        }
                        
                        if is_escapeable_character(c) {
                            return Ok(Primitive::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Superfluous,
                                c,
                            }));
                        }
                        let special = |kind, c| {
                            Ok(Primitive::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Special(kind),
                                c,
                            }))
                        };
                        match c {
                            'a' => special(ast::SpecialLiteralKind::Bell, '\x07'),
                            'f' => special(ast::SpecialLiteralKind::FormFeed, '\x0C'),
                            't' => special(ast::SpecialLiteralKind::Tab, '\t'),
                            'n' => special(ast::SpecialLiteralKind::LineFeed, '\n'),
                            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\r'),
                            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\x0B'),
                            'A' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::StartText,
                            })),
                            'z' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::EndText,
                            })),
                            'b' => {
                                let mut wb = ast::Assertion {
                                    span,
                                    kind: ast::AssertionKind::WordBoundary,
                                };
                                
                                if !self.is_eof() && self.char() == '{' {
                                    if let Some(kind) =
                                        self.maybe_parse_special_word_boundary(start)?
                                    {
                                        wb.kind = kind;
                                        wb.span.end = self.pos();
                                    }
                                }
                                Ok(Primitive::Assertion(wb))
                            }
                            'B' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::NotWordBoundary,
                            })),
                            '<' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::WordBoundaryStartAngle,
                            })),
                            '>' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::WordBoundaryEndAngle,
                            })),
                            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),
                        }
                    }
                    /// Attempt to parse a specialty word boundary. That is, `\b{start}`,
                    fn maybe_parse_special_word_boundary(
                        &self,
                        wb_start: Position,
                    ) -> Result<Option<ast::AssertionKind>> {
                        assert_eq!(self.char(), '{');

                        let is_valid_char = |c| match c {
                            'A'..='Z' | 'a'..='z' | '-' => true,
                            _ => false,
                        };
                        let start = self.pos();
                        
                        if !self.bump_and_bump_space() {
                            return Err(self.error(
                                Span::new(wb_start, self.pos()),
                                ast::ErrorKind::SpecialWordOrRepetitionUnexpectedEof,
                            ));
                        }
                        let start_contents = self.pos();
                        
                        if !is_valid_char(self.char()) {
                            self.parser().pos.set(start);
                            
                            return Ok(None);
                        }

                        // Now collect up our chars until we see a '}'.
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();
                        while !self.is_eof() && is_valid_char(self.char()) {
                            scratch.push(self.char());
                            self.bump_and_bump_space();
                        }
                        
                        if self.is_eof() || self.char() != '}' {
                            return Err(self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::SpecialWordBoundaryUnclosed,
                            ));
                        }
                        let end = self.pos();
                        self.bump();
                        let kind = match scratch.as_str() {
                            "start" => ast::AssertionKind::WordBoundaryStart,
                            "end" => ast::AssertionKind::WordBoundaryEnd,
                            "start-half" => ast::AssertionKind::WordBoundaryStartHalf,
                            "end-half" => ast::AssertionKind::WordBoundaryEndHalf,
                            _ => {
                                return Err(self.error(
                                    Span::new(start_contents, end),
                                    ast::ErrorKind::SpecialWordBoundaryUnrecognized,
                                ))
                            }
                        };
                        Ok(Some(kind))
                    }
                    /// Parse an octal representation of a Unicode codepoint up to 3 digits
                    #[inline(never)]
                    fn parse_octal(&self) -> ast::Literal {
                        assert!(self.parser().octal);
                        assert!('0' <= self.char() && self.char() <= '7');
                        let start = self.pos();
                        // Parse up to two more digits.
                        while self.bump()
                            && '0' <= self.char()
                            && self.char() <= '7'
                            && self.pos().offset - start.offset <= 2
                        {}
                        let end = self.pos();
                        let octal = &self.pattern()[start.offset..end.offset];
                        let codepoint =
                            u32::from_str_radix(octal, 8).expect("valid octal number");
                        let c = char::from_u32(codepoint).expect("Unicode scalar value");
                        ast::Literal {
                            span: Span::new(start, end),
                            kind: ast::LiteralKind::Octal,
                            c,
                        }
                    }
                    /// Parse a hex representation of a Unicode codepoint. This handles both
                    #[inline(never)]
                    fn parse_hex(&self) -> Result<ast::Literal> {
                        assert!(
                            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'
                        );

                        let hex_kind = match self.char() {
                            'x' => ast::HexLiteralKind::X,
                            'u' => ast::HexLiteralKind::UnicodeShort,
                            _ => ast::HexLiteralKind::UnicodeLong,
                        };
                        
                        if !self.bump_and_bump_space() {
                            return Err(
                                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)
                            );
                        }
                        
                        if self.char() == '{' {
                            self.parse_hex_brace(hex_kind)
                        } else {
                            self.parse_hex_digits(hex_kind)
                        }
                    }
                    /// Parse an N-digit hex representation of a Unicode codepoint. This
                    #[inline(never)]
                    fn parse_hex_digits(
                        &self,
                        kind: ast::HexLiteralKind,
                    ) -> Result<ast::Literal> {
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        let start = self.pos();
                        for i in 0..kind.digits()
                        {
                            if i > 0 && !self.bump_and_bump_space() {
                                return Err(self
                                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));
                            }
                            
                            if !is_hex(self.char()) {
                                return Err(self.error(
                                    self.span_char(),
                                    ast::ErrorKind::EscapeHexInvalidDigit,
                                ));
                            }
                            scratch.push(self.char());
                        }
                        self.bump_and_bump_space();
                        let end = self.pos();
                        let hex = scratch.as_str();
                        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {
                            None => Err(self.error(
                                Span::new(start, end),
                                ast::ErrorKind::EscapeHexInvalid,
                            )),
                            Some(c) => Ok(ast::Literal {
                                span: Span::new(start, end),
                                kind: ast::LiteralKind::HexFixed(kind),
                                c,
                            }),
                        }
                    }
                    /// Parse a hex representation of any Unicode scalar value. This expects
                    #[inline(never)]
                    fn parse_hex_brace(
                        &self,
                        kind: ast::HexLiteralKind,
                    ) -> Result<ast::Literal> {
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        let brace_pos = self.pos();
                        let start = self.span_char().end;
                        while self.bump_and_bump_space() && self.char() != '}' {
                            if !is_hex(self.char()) {
                                return Err(self.error(
                                    self.span_char(),
                                    ast::ErrorKind::EscapeHexInvalidDigit,
                                ));
                            }
                            scratch.push(self.char());
                        }
                        
                        if self.is_eof() {
                            return Err(self.error(
                                Span::new(brace_pos, self.pos()),
                                ast::ErrorKind::EscapeUnexpectedEof,
                            ));
                        }
                        let end = self.pos();
                        let hex = scratch.as_str();
                        assert_eq!(self.char(), '}');
                        self.bump_and_bump_space();

                        if hex.is_empty() {
                            return Err(self.error(
                                Span::new(brace_pos, self.pos()),
                                ast::ErrorKind::EscapeHexEmpty,
                            ));
                        }
                        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {
                            None => Err(self.error(
                                Span::new(start, end),
                                ast::ErrorKind::EscapeHexInvalid,
                            )),
                            Some(c) => Ok(ast::Literal {
                                span: Span::new(start, self.pos()),
                                kind: ast::LiteralKind::HexBrace(kind),
                                c,
                            }),
                        }
                    }
                    /// Parse a decimal number into a u32 while trimming leading and trailing
                    fn parse_decimal(&self) -> Result<u32> {
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        while !self.is_eof() && self.char().is_whitespace() {
                            self.bump();
                        }
                        let start = self.pos();
                        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {
                            scratch.push(self.char());
                            self.bump_and_bump_space();
                        }
                        let span = Span::new(start, self.pos());
                        while !self.is_eof() && self.char().is_whitespace() {
                            self.bump_and_bump_space();
                        }
                        let digits = scratch.as_str();
                        
                        if digits.is_empty() {
                            return Err(self.error(span, ast::ErrorKind::DecimalEmpty));
                        }
                        match u32::from_str_radix(digits, 10).ok() {
                            Some(n) => Ok(n),
                            None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),
                        }
                    }
                    /// Parse a standard character class consisting primarily of characters or
                    #[inline(never)]
                    fn parse_set_class(&self) -> Result<ast::ClassBracketed> {
                        assert_eq!(self.char(), '[');

                        let mut union =
                            ast::ClassSetUnion { span: self.span(), items: vec![] };

                        loop
                        {
                            self.bump_space();
                            if self.is_eof() {
                                return Err(self.unclosed_class_error());
                            }
                            match self.char() {
                                '[' => {
                                    if !self.parser().stack_class.borrow().is_empty() {
                                        if let Some(cls) = self.maybe_parse_ascii_class() {
                                            union.push(ast::ClassSetItem::Ascii(cls));
                                            continue;
                                        }
                                    }
                                    union = self.push_class_open(union)?;
                                }
                                ']' => match self.pop_class(union)? {
                                    Either::Left(nested_union) => {
                                        union = nested_union;
                                    }
                                    Either::Right(class) => return Ok(class),
                                },
                                '&' if self.peek() == Some('&') => {
                                    assert!(self.bump_if("&&"));
                                    union = self.push_class_op(
                                        ast::ClassSetBinaryOpKind::Intersection,
                                        union,
                                    );
                                }
                                '-' if self.peek() == Some('-') => {
                                    assert!(self.bump_if("--"));
                                    union = self.push_class_op(
                                        ast::ClassSetBinaryOpKind::Difference,
                                        union,
                                    );
                                }
                                '~' if self.peek() == Some('~') => {
                                    assert!(self.bump_if("~~"));
                                    union = self.push_class_op(
                                        ast::ClassSetBinaryOpKind::SymmetricDifference,
                                        union,
                                    );
                                }
                                _ => {
                                    union.push(self.parse_set_class_range()?);
                                }
                            }
                        }
                    }
                    /// Parse a single primitive item in a character class set. The item to
                    #[inline(never)]
                    fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {
                        let prim1 = self.parse_set_class_item()?;
                        self.bump_space();
                        
                        if self.is_eof() {
                            return Err(self.unclosed_class_error());
                        }
                        
                        if self.char() != '-'
                            || self.peek_space() == Some(']')
                            || self.peek_space() == Some('-')
                        {
                            return prim1.into_class_set_item(self);
                        }
                        
                        if !self.bump_and_bump_space() {
                            return Err(self.unclosed_class_error());
                        }
                        let prim2 = self.parse_set_class_item()?;
                        let range = ast::ClassSetRange {
                            span: Span::new(prim1.span().start, prim2.span().end),
                            start: prim1.into_class_literal(self)?,
                            end: prim2.into_class_literal(self)?,
                        };
                        
                        if !range.is_valid() {
                            return Err(
                                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)
                            );
                        }
                        Ok(ast::ClassSetItem::Range(range))
                    }
                    /// Parse a single item in a character class as a primitive, where the
                    #[inline(never)]
                    fn parse_set_class_item(&self) -> Result<Primitive> {
                        if self.char() == '\\' {
                            self.parse_escape()
                        } else {
                            let x = Primitive::Literal(ast::Literal {
                                span: self.span_char(),
                                kind: ast::LiteralKind::Verbatim,
                                c: self.char(),
                            });
                            self.bump();
                            Ok(x)
                        }
                    }
                    /// Parses the opening of a character class set. This includes the opening
                    #[inline(never)]
                    fn parse_set_class_open(
                        &self,
                    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {
                        assert_eq!(self.char(), '[');
                        let start = self.pos();
                        
                        if !self.bump_and_bump_space() {
                            return Err(self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::ClassUnclosed,
                            ));
                        }

                        let negated = if self.char() != '^' {
                            false
                        } else {
                            if !self.bump_and_bump_space() {
                                return Err(self.error(
                                    Span::new(start, self.pos()),
                                    ast::ErrorKind::ClassUnclosed,
                                ));
                            }
                            true
                        };
                        // Accept any number of `-` as literal `-`.
                        let mut union =
                            ast::ClassSetUnion { span: self.span(), items: vec![] };
                        while self.char() == '-' {
                            union.push(ast::ClassSetItem::Literal(ast::Literal {
                                span: self.span_char(),
                                kind: ast::LiteralKind::Verbatim,
                                c: '-',
                            }));
                            if !self.bump_and_bump_space() {
                                return Err(self.error(
                                    Span::new(start, start),
                                    ast::ErrorKind::ClassUnclosed,
                                ));
                            }
                        }
                        
                        if union.items.is_empty() && self.char() == ']' {
                            union.push(ast::ClassSetItem::Literal(ast::Literal {
                                span: self.span_char(),
                                kind: ast::LiteralKind::Verbatim,
                                c: ']',
                            }));
                            if !self.bump_and_bump_space() {
                                return Err(self.error(
                                    Span::new(start, self.pos()),
                                    ast::ErrorKind::ClassUnclosed,
                                ));
                            }
                        }
                        let set = ast::ClassBracketed {
                            span: Span::new(start, self.pos()),
                            negated,
                            kind: ast::ClassSet::union(ast::ClassSetUnion {
                                span: Span::new(union.span.start, union.span.start),
                                items: vec![],
                            }),
                        };
                        Ok((set, union))
                    }
                    /// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.
                    #[inline(never)]
                    fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {
                        assert_eq!(self.char(), '[');
                        // If parsing fails, then we back up the parser to this starting point.
                        let start = self.pos();
                        let mut negated = false;
                        
                        if !self.bump() || self.char() != ':' {
                            self.parser().pos.set(start);
                            
                            return None;
                        }
                        
                        if !self.bump() {
                            self.parser().pos.set(start);
                            
                            return None;
                        }
                        
                        if self.char() == '^' {
                            negated = true;
                            if !self.bump() {
                                self.parser().pos.set(start);
                                return None;
                            }
                        }
                        let name_start = self.offset();
                        while self.char() != ':' && self.bump() {}
                        
                        if self.is_eof() {
                            self.parser().pos.set(start);
                            
                            return None;
                        }
                        let name = &self.pattern()[name_start..self.offset()];
                        
                        if !self.bump_if(":]") {
                            self.parser().pos.set(start);
                            
                            return None;
                        }
                        let kind = match ast::ClassAsciiKind::from_name(name) {
                            Some(kind) => kind,
                            None => {
                                self.parser().pos.set(start);
                                return None;
                            }
                        };
                        Some(ast::ClassAscii {
                            span: Span::new(start, self.pos()),
                            kind,
                            negated,
                        })
                    }
                    /// Parse a Unicode class in either the single character notation, `\pN`
                    #[inline(never)]
                    fn parse_unicode_class(&self) -> Result<ast::ClassUnicode> {
                        assert!(self.char() == 'p' || self.char() == 'P');

                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        let negated = self.char() == 'P';
                        
                        if !self.bump_and_bump_space() {
                            return Err(
                                self.error(self.span(), ast::ErrorKind::EscapeUnexpectedEof)
                            );
                        }
                        let (start, kind) = if self.char() == '{' {
                            let start = self.span_char().end;
                            while self.bump_and_bump_space() && self.char() != '}' {
                                scratch.push(self.char());
                            }
                            
                            if self.is_eof() {
                                return Err(self
                                    .error(self.span(), ast::ErrorKind::EscapeUnexpectedEof));
                            }
                            assert_eq!(self.char(), '}');
                            self.bump();

                            let name = scratch.as_str();
                            if let Some(i) = name.find("!=") {
                                (
                                    start,
                                    ast::ClassUnicodeKind::NamedValue {
                                        op: ast::ClassUnicodeOpKind::NotEqual,
                                        name: name[..i].to_string(),
                                        value: name[i + 2..].to_string(),
                                    },
                                )
                            } else if let Some(i) = name.find(':') {
                                (
                                    start,
                                    ast::ClassUnicodeKind::NamedValue {
                                        op: ast::ClassUnicodeOpKind::Colon,
                                        name: name[..i].to_string(),
                                        value: name[i + 1..].to_string(),
                                    },
                                )
                            } else if let Some(i) = name.find('=') {
                                (
                                    start,
                                    ast::ClassUnicodeKind::NamedValue {
                                        op: ast::ClassUnicodeOpKind::Equal,
                                        name: name[..i].to_string(),
                                        value: name[i + 1..].to_string(),
                                    },
                                )
                            } else {
                                (start, ast::ClassUnicodeKind::Named(name.to_string()))
                            }
                        } else {
                            let start = self.pos();
                            let c = self.char();
                            if c == '\\' {
                                return Err(self.error(
                                    self.span_char(),
                                    ast::ErrorKind::UnicodeClassInvalid,
                                ));
                            }
                            self.bump_and_bump_space();
                            let kind = ast::ClassUnicodeKind::OneLetter(c);
                            (start, kind)
                        };
                        Ok(ast::ClassUnicode {
                            span: Span::new(start, self.pos()),
                            negated,
                            kind,
                        })
                    }
                    /// Parse a Perl character class, e.g., `\d` or `\W`. This assumes the
                    #[inline(never)]
                    fn parse_perl_class(&self) -> ast::ClassPerl {
                        let c = self.char();
                        let span = self.span_char();
                        self.bump();
                        let (negated, kind) = match c {
                            'd' => (false, ast::ClassPerlKind::Digit),
                            'D' => (true, ast::ClassPerlKind::Digit),
                            's' => (false, ast::ClassPerlKind::Space),
                            'S' => (true, ast::ClassPerlKind::Space),
                            'w' => (false, ast::ClassPerlKind::Word),
                            'W' => (true, ast::ClassPerlKind::Word),
                            c => panic!("expected valid Perl class but got '{}'", c),
                        };
                        ast::ClassPerl { span, kind, negated }
                    }
                }
                /// A type that traverses a fully parsed Ast and checks whether its depth
                #[derive(Debug)]
                struct NestLimiter<'p, 's, P>
                {
                    /// The parser that is checking the nest limit.
                    p: &'p ParserI<'s, P>,
                    /// The current depth while walking an Ast.
                    depth: u32,
                }

                impl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P> {
                    fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> {
                        NestLimiter { p, depth: 0 }
                    }

                    #[inline(never)]
                    fn check(self, ast: &Ast) -> Result<()> {
                        ast::visit(ast, self)
                    }

                    fn increment_depth(&mut self, span: &Span) -> Result<()> {
                        let new = self.depth.checked_add(1).ok_or_else(|| {
                            self.p.error(
                                span.clone(),
                                ast::ErrorKind::NestLimitExceeded(u32::MAX),
                            )
                        })?;
                        let limit = self.p.parser().nest_limit;
                        
                        if new > limit {
                            return Err(self.p.error(
                                span.clone(),
                                ast::ErrorKind::NestLimitExceeded(limit),
                            ));
                        }
                        self.depth = new;
                        Ok(())
                    }

                    fn decrement_depth(&mut self) {
                        self.depth = self.depth.checked_sub(1).unwrap();
                    }
                }

                impl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {
                    type Output = ();
                    type Err = ast::Error;

                    fn finish(self) -> Result<()> { Ok(()) }

                    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {
                        let span = match *ast {
                            Ast::Empty(_)
                            | Ast::Flags(_)
                            | Ast::Literal(_)
                            | Ast::Dot(_)
                            | Ast::Assertion(_)
                            | Ast::ClassUnicode(_)
                            | Ast::ClassPerl(_) => {
                                // These are all base cases, so we don't increment depth.
                                return Ok(());
                            }
                            Ast::ClassBracketed(ref x) => &x.span,
                            Ast::Repetition(ref x) => &x.span,
                            Ast::Group(ref x) => &x.span,
                            Ast::Alternation(ref x) => &x.span,
                            Ast::Concat(ref x) => &x.span,
                        };
                        self.increment_depth(span)
                    }

                    fn visit_post(&mut self, ast: &Ast) -> Result<()> {
                        match *ast {
                            Ast::Empty(_)
                            | Ast::Flags(_)
                            | Ast::Literal(_)
                            | Ast::Dot(_)
                            | Ast::Assertion(_)
                            | Ast::ClassUnicode(_)
                            | Ast::ClassPerl(_) => {
                                // These are all base cases, so we don't decrement depth.
                                Ok(())
                            }
                            Ast::ClassBracketed(_)
                            | Ast::Repetition(_)
                            | Ast::Group(_)
                            | Ast::Alternation(_)
                            | Ast::Concat(_) => {
                                self.decrement_depth();
                                Ok(())
                            }
                        }
                    }

                    fn visit_class_set_item_pre
                    (
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        let span = match *ast {
                            ast::ClassSetItem::Empty(_)
                            | ast::ClassSetItem::Literal(_)
                            | ast::ClassSetItem::Range(_)
                            | ast::ClassSetItem::Ascii(_)
                            | ast::ClassSetItem::Unicode(_)
                            | ast::ClassSetItem::Perl(_) => {
                                // These are all base cases, so we don't increment depth.
                                return Ok(());
                            }
                            ast::ClassSetItem::Bracketed(ref x) => &x.span,
                            ast::ClassSetItem::Union(ref x) => &x.span,
                        };
                        self.increment_depth(span)
                    }

                    fn visit_class_set_item_post
                    (
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        match *ast {
                            ast::ClassSetItem::Empty(_)
                            | ast::ClassSetItem::Literal(_)
                            | ast::ClassSetItem::Range(_)
                            | ast::ClassSetItem::Ascii(_)
                            | ast::ClassSetItem::Unicode(_)
                            | ast::ClassSetItem::Perl(_) => {
                                // These are all base cases, so we don't decrement depth.
                                Ok(())
                            }
                            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {
                                self.decrement_depth();
                                Ok(())
                            }
                        }
                    }

                    fn visit_class_set_binary_op_pre
                    (
                        &mut self,
                        ast: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        self.increment_depth(&ast.span)
                    }

                    fn visit_class_set_binary_op_post
                    (
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        self.decrement_depth();
                        Ok(())
                    }
                }
                /// When the result is an error, transforms the ast::ErrorKind from the source
                fn specialize_err<T>(
                    result: Result<T>,
                    from: ast::ErrorKind,
                    to: ast::ErrorKind,
                ) -> Result<T> {
                    if let Err(e) = result {
                        if e.kind == from {
                            Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })
                        } else {
                            Err(e)
                        }
                    } else {
                        result
                    }
                }

                #[cfg(test)]
                mod tests {
                    use ::ops::Range;

                    use ::format;

                    use super::*;
                    macro_rules! assert_eq {
                        ($left:expr, $right:expr) => {{
                            match (&$left, &$right) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        panic!(
                                            "assertion failed: `(left == right)`\n\n\
                                            left:  `{:?}`\nright: `{:?}`\n\n",
                                            left_val, right_val
                                        )
                                    }
                                }
                            }
                        }};
                    }
                    #[derive(Clone, Debug)]
                    struct TestError {
                        span: Span,
                        kind: ast::ErrorKind,
                    }

                    impl PartialEq<ast::Error> for TestError {
                        fn eq(&self, other: &ast::Error) -> bool {
                            self.span == other.span && self.kind == other.kind
                        }
                    }

                    impl PartialEq<TestError> for ast::Error {
                        fn eq(&self, other: &TestError) -> bool {
                            self.span == other.span && self.kind == other.kind
                        }
                    }

                    fn s(str: &str) -> String {
                        str.to_string()
                    }

                    fn parser(pattern: &str) -> ParserI<'_, Parser> {
                        ParserI::new(Parser::new(), pattern)
                    }

                    fn parser_octal(pattern: &str) -> ParserI<'_, Parser> {
                        let parser = ParserBuilder::new().octal(true).build();
                        ParserI::new(parser, pattern)
                    }

                    fn parser_empty_min_range(pattern: &str) -> ParserI<'_, Parser> {
                        let parser = ParserBuilder::new().empty_min_range(true).build();
                        ParserI::new(parser, pattern)
                    }

                    fn parser_nest_limit(
                        pattern: &str,
                        nest_limit: u32,
                    ) -> ParserI<'_, Parser> {
                        let p = ParserBuilder::new().nest_limit(nest_limit).build();
                        ParserI::new(p, pattern)
                    }

                    fn parser_ignore_whitespace(pattern: &str) -> ParserI<'_, Parser> {
                        let p = ParserBuilder::new().ignore_whitespace(true).build();
                        ParserI::new(p, pattern)
                    }
                    /// Short alias for creating a new span.
                    fn nspan(start: Position, end: Position) -> Span {
                        Span::new(start, end)
                    }
                    /// Short alias for creating a new position.
                    fn npos(offset: usize, line: usize, column: usize) -> Position {
                        Position::new(offset, line, column)
                    }
                    /// Create a new span from the given offset range. This assumes a single
                    fn span(range: Range<usize>) -> Span {
                        let start = Position::new(range.start, 1, range.start + 1);
                        let end = Position::new(range.end, 1, range.end + 1);
                        Span::new(start, end)
                    }
                    /// Create a new span for the corresponding byte range in the given string.
                    fn span_range(subject: &str, range: Range<usize>) -> Span {
                        let start = Position {
                            offset: range.start,
                            line: 1 + subject[..range.start].matches('\n').count(),
                            column: 1 + subject[..range.start]
                                .chars()
                                .rev()
                                .position(|c| c == '\n')
                                .unwrap_or(subject[..range.start].chars().count()),
                        };
                        let end = Position {
                            offset: range.end,
                            line: 1 + subject[..range.end].matches('\n').count(),
                            column: 1 + subject[..range.end]
                                .chars()
                                .rev()
                                .position(|c| c == '\n')
                                .unwrap_or(subject[..range.end].chars().count()),
                        };
                        Span::new(start, end)
                    }
                    /// Create a verbatim literal starting at the given position.
                    fn lit(c: char, start: usize) -> Ast {
                        lit_with(c, span(start..start + c.len_utf8()))
                    }
                    /// Create a meta literal starting at the given position.
                    fn meta_lit(c: char, span: Span) -> Ast {
                        Ast::literal(ast::Literal { span, kind: ast::LiteralKind::Meta, c })
                    }
                    /// Create a verbatim literal with the given span.
                    fn lit_with(c: char, span: Span) -> Ast {
                        Ast::literal(ast::Literal {
                            span,
                            kind: ast::LiteralKind::Verbatim,
                            c,
                        })
                    }
                    /// Create a concatenation with the given range.
                    fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {
                        concat_with(span(range), asts)
                    }
                    /// Create a concatenation with the given span.
                    fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {
                        Ast::concat(ast::Concat { span, asts })
                    }
                    /// Create an alternation with the given span.
                    fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {
                        Ast::alternation(ast::Alternation { span: span(range), asts })
                    }
                    /// Create a capturing group with the given span.
                    fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {
                        Ast::group(ast::Group {
                            span: span(range),
                            kind: ast::GroupKind::CaptureIndex(index),
                            ast: Box::new(ast),
                        })
                    }
                    /// Create an ast::SetFlags.
                    fn flag_set(
                        pat: &str,
                        range: Range<usize>,
                        flag: ast::Flag,
                        negated: bool,
                    ) -> Ast {
                        let mut items = vec![ast::FlagsItem {
                            span: span_range(pat, (range.end - 2)..(range.end - 1)),
                            kind: ast::FlagsItemKind::Flag(flag),
                        }];
                        
                        if negated {
                            items.insert(
                                0,
                                ast::FlagsItem {
                                    span: span_range(pat, (range.start + 2)..(range.end - 2)),
                                    kind: ast::FlagsItemKind::Negation,
                                },
                            );
                        }
                        Ast::flags(ast::SetFlags {
                            span: span_range(pat, range.clone()),
                            flags: ast::Flags {
                                span: span_range(pat, (range.start + 2)..(range.end - 1)),
                                items,
                            },
                        })
                    }

                    #[test]
                    fn parse_nest_limit() {
                        // A nest limit of 0 still allows some types of regexes.
                        assert_eq!(
                            parser_nest_limit("", 0).parse(),
                            Ok(Ast::empty(span(0..0)))
                        );
                        assert_eq!(parser_nest_limit("a", 0).parse(), Ok(lit('a', 0)));

                        // Test repetition operations, which require one level of nesting.
                        assert_eq!(
                            parser_nest_limit("a+", 0).parse().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::NestLimitExceeded(0),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("a+", 1).parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..2),
                                op: ast::RepetitionOp {
                                    span: span(1..2),
                                    kind: ast::RepetitionKind::OneOrMore,
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser_nest_limit("(a)+", 1).parse().unwrap_err(),
                            TestError {
                                span: span(0..3),
                                kind: ast::ErrorKind::NestLimitExceeded(1),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("a+*", 1).parse().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::NestLimitExceeded(1),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("a+*", 2).parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..3),
                                op: ast::RepetitionOp {
                                    span: span(2..3),
                                    kind: ast::RepetitionKind::ZeroOrMore,
                                },
                                greedy: true,
                                ast: Box::new(Ast::repetition(ast::Repetition {
                                    span: span(0..2),
                                    op: ast::RepetitionOp {
                                        span: span(1..2),
                                        kind: ast::RepetitionKind::OneOrMore,
                                    },
                                    greedy: true,
                                    ast: Box::new(lit('a', 0)),
                                })),
                            }))
                        );

                        // Test concatenations. A concatenation requires one level of nesting.
                        assert_eq!(
                            parser_nest_limit("ab", 0).parse().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::NestLimitExceeded(0),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("ab", 1).parse(),
                            Ok(concat(0..2, vec![lit('a', 0), lit('b', 1)]))
                        );
                        assert_eq!(
                            parser_nest_limit("abc", 1).parse(),
                            Ok(concat(0..3, vec![lit('a', 0), lit('b', 1), lit('c', 2)]))
                        );

                        // Test alternations. An alternation requires one level of nesting.
                        assert_eq!(
                            parser_nest_limit("a|b", 0).parse().unwrap_err(),
                            TestError {
                                span: span(0..3),
                                kind: ast::ErrorKind::NestLimitExceeded(0),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("a|b", 1).parse(),
                            Ok(alt(0..3, vec![lit('a', 0), lit('b', 2)]))
                        );
                        assert_eq!(
                            parser_nest_limit("a|b|c", 1).parse(),
                            Ok(alt(0..5, vec![lit('a', 0), lit('b', 2), lit('c', 4)]))
                        );
                        assert_eq!(
                            parser_nest_limit("[a]", 0).parse().unwrap_err(),
                            TestError {
                                span: span(0..3),
                                kind: ast::ErrorKind::NestLimitExceeded(0),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("[a]", 1).parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..3),
                                negated: false,
                                kind: ast::ClassSet::Item(ast::ClassSetItem::Literal(
                                    ast::Literal {
                                        span: span(1..2),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: 'a',
                                    }
                                )),
                            }))
                        );
                        assert_eq!(
                            parser_nest_limit("[ab]", 1).parse().unwrap_err(),
                            TestError {
                                span: span(1..3),
                                kind: ast::ErrorKind::NestLimitExceeded(1),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("[ab[cd]]", 2).parse().unwrap_err(),
                            TestError {
                                span: span(3..7),
                                kind: ast::ErrorKind::NestLimitExceeded(2),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("[ab[cd]]", 3).parse().unwrap_err(),
                            TestError {
                                span: span(4..6),
                                kind: ast::ErrorKind::NestLimitExceeded(3),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("[a--b]", 1).parse().unwrap_err(),
                            TestError {
                                span: span(1..5),
                                kind: ast::ErrorKind::NestLimitExceeded(1),
                            }
                        );
                        assert_eq!(
                            parser_nest_limit("[a--bc]", 2).parse().unwrap_err(),
                            TestError {
                                span: span(4..6),
                                kind: ast::ErrorKind::NestLimitExceeded(2),
                            }
                        );
                    }

                    #[test]
                    fn parse_comments() {
                        let pat = "(?x)
                # This is comment 1.
                foo # This is comment 2.
                # This is comment 3.
                bar
                # This is comment 4.";
                        let astc = parser(pat).parse_with_comments().unwrap();
                        assert_eq!(
                            astc.ast,
                            concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    lit_with('f', span_range(pat, 26..27)),
                                    lit_with('o', span_range(pat, 27..28)),
                                    lit_with('o', span_range(pat, 28..29)),
                                    lit_with('b', span_range(pat, 74..75)),
                                    lit_with('a', span_range(pat, 75..76)),
                                    lit_with('r', span_range(pat, 76..77)),
                                ]
                            )
                        );
                        assert_eq!(
                            astc.comments,
                            vec![
                                ast::Comment {
                                    span: span_range(pat, 5..26),
                                    comment: s(" This is comment 1."),
                                },
                                ast::Comment {
                                    span: span_range(pat, 30..51),
                                    comment: s(" This is comment 2."),
                                },
                                ast::Comment {
                                    span: span_range(pat, 53..74),
                                    comment: s(" This is comment 3."),
                                },
                                ast::Comment {
                                    span: span_range(pat, 78..98),
                                    comment: s(" This is comment 4."),
                                },
                            ]
                        );
                    }

                    #[test]
                    fn parse_holistic() {
                        assert_eq!(parser("]").parse(), Ok(lit(']', 0)));
                        assert_eq!(
                            parser(r"\\\.\+\*\?\(\)\|\[\]\{\}\^\$\#\&\-\~").parse(),
                            Ok(concat(
                                0..36,
                                vec![
                                    meta_lit('\\', span(0..2)),
                                    meta_lit('.', span(2..4)),
                                    meta_lit('+', span(4..6)),
                                    meta_lit('*', span(6..8)),
                                    meta_lit('?', span(8..10)),
                                    meta_lit('(', span(10..12)),
                                    meta_lit(')', span(12..14)),
                                    meta_lit('|', span(14..16)),
                                    meta_lit('[', span(16..18)),
                                    meta_lit(']', span(18..20)),
                                    meta_lit('{', span(20..22)),
                                    meta_lit('}', span(22..24)),
                                    meta_lit('^', span(24..26)),
                                    meta_lit('$', span(26..28)),
                                    meta_lit('#', span(28..30)),
                                    meta_lit('&', span(30..32)),
                                    meta_lit('-', span(32..34)),
                                    meta_lit('~', span(34..36)),
                                ]
                            ))
                        );
                    }

                    #[test]
                    fn parse_ignore_whitespace() {
                        // Test that basic whitespace insensitivity works.
                        let pat = "(?x)a b";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                nspan(npos(0, 1, 1), npos(7, 1, 8)),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    lit_with('a', nspan(npos(4, 1, 5), npos(5, 1, 6))),
                                    lit_with('b', nspan(npos(6, 1, 7), npos(7, 1, 8))),
                                ]
                            ))
                        );

                        // Test that we can toggle whitespace insensitivity.
                        let pat = "(?x)a b(?-x)a b";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                nspan(npos(0, 1, 1), npos(15, 1, 16)),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    lit_with('a', nspan(npos(4, 1, 5), npos(5, 1, 6))),
                                    lit_with('b', nspan(npos(6, 1, 7), npos(7, 1, 8))),
                                    flag_set(pat, 7..12, ast::Flag::IgnoreWhitespace, true),
                                    lit_with('a', nspan(npos(12, 1, 13), npos(13, 1, 14))),
                                    lit_with(' ', nspan(npos(13, 1, 14), npos(14, 1, 15))),
                                    lit_with('b', nspan(npos(14, 1, 15), npos(15, 1, 16))),
                                ]
                            ))
                        );

                        // Test that nesting whitespace insensitive flags works.
                        let pat = "a (?x:a )a ";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..11),
                                vec![
                                    lit_with('a', span_range(pat, 0..1)),
                                    lit_with(' ', span_range(pat, 1..2)),
                                    Ast::group(ast::Group {
                                        span: span_range(pat, 2..9),
                                        kind: ast::GroupKind::NonCapturing(ast::Flags {
                                            span: span_range(pat, 4..5),
                                            items: vec![ast::FlagsItem {
                                                span: span_range(pat, 4..5),
                                                kind: ast::FlagsItemKind::Flag(
                                                    ast::Flag::IgnoreWhitespace
                                                ),
                                            },],
                                        }),
                                        ast: Box::new(lit_with('a', span_range(pat, 6..7))),
                                    }),
                                    lit_with('a', span_range(pat, 9..10)),
                                    lit_with(' ', span_range(pat, 10..11)),
                                ]
                            ))
                        );

                        // Test that whitespace after an opening paren is insignificant.
                        let pat = "(?x)( ?P<foo> a )";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    Ast::group(ast::Group {
                                        span: span_range(pat, 4..pat.len()),
                                        kind: ast::GroupKind::CaptureName {
                                            starts_with_p: true,
                                            name: ast::CaptureName {
                                                span: span_range(pat, 9..12),
                                                name: s("foo"),
                                                index: 1,
                                            }
                                        },
                                        ast: Box::new(lit_with('a', span_range(pat, 14..15))),
                                    }),
                                ]
                            ))
                        );
                        let pat = "(?x)(  a )";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    Ast::group(ast::Group {
                                        span: span_range(pat, 4..pat.len()),
                                        kind: ast::GroupKind::CaptureIndex(1),
                                        ast: Box::new(lit_with('a', span_range(pat, 7..8))),
                                    }),
                                ]
                            ))
                        );
                        let pat = "(?x)(  ?:  a )";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    Ast::group(ast::Group {
                                        span: span_range(pat, 4..pat.len()),
                                        kind: ast::GroupKind::NonCapturing(ast::Flags {
                                            span: span_range(pat, 8..8),
                                            items: vec![],
                                        }),
                                        ast: Box::new(lit_with('a', span_range(pat, 11..12))),
                                    }),
                                ]
                            ))
                        );
                        let pat = r"(?x)\x { 53 }";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    Ast::literal(ast::Literal {
                                        span: span(4..13),
                                        kind: ast::LiteralKind::HexBrace(
                                            ast::HexLiteralKind::X
                                        ),
                                        c: 'S',
                                    }),
                                ]
                            ))
                        );

                        // Test that whitespace after an escape is OK.
                        let pat = r"(?x)\ ";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    flag_set(pat, 0..4, ast::Flag::IgnoreWhitespace, false),
                                    Ast::literal(ast::Literal {
                                        span: span_range(pat, 4..6),
                                        kind: ast::LiteralKind::Superfluous,
                                        c: ' ',
                                    }),
                                ]
                            ))
                        );
                    }

                    #[test]
                    fn parse_newlines() {
                        let pat = ".\n.";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..3),
                                vec![
                                    Ast::dot(span_range(pat, 0..1)),
                                    lit_with('\n', span_range(pat, 1..2)),
                                    Ast::dot(span_range(pat, 2..3)),
                                ]
                            ))
                        );

                        let pat = "foobar\nbaz\nquux\n";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(concat_with(
                                span_range(pat, 0..pat.len()),
                                vec![
                                    lit_with('f', nspan(npos(0, 1, 1), npos(1, 1, 2))),
                                    lit_with('o', nspan(npos(1, 1, 2), npos(2, 1, 3))),
                                    lit_with('o', nspan(npos(2, 1, 3), npos(3, 1, 4))),
                                    lit_with('b', nspan(npos(3, 1, 4), npos(4, 1, 5))),
                                    lit_with('a', nspan(npos(4, 1, 5), npos(5, 1, 6))),
                                    lit_with('r', nspan(npos(5, 1, 6), npos(6, 1, 7))),
                                    lit_with('\n', nspan(npos(6, 1, 7), npos(7, 2, 1))),
                                    lit_with('b', nspan(npos(7, 2, 1), npos(8, 2, 2))),
                                    lit_with('a', nspan(npos(8, 2, 2), npos(9, 2, 3))),
                                    lit_with('z', nspan(npos(9, 2, 3), npos(10, 2, 4))),
                                    lit_with('\n', nspan(npos(10, 2, 4), npos(11, 3, 1))),
                                    lit_with('q', nspan(npos(11, 3, 1), npos(12, 3, 2))),
                                    lit_with('u', nspan(npos(12, 3, 2), npos(13, 3, 3))),
                                    lit_with('u', nspan(npos(13, 3, 3), npos(14, 3, 4))),
                                    lit_with('x', nspan(npos(14, 3, 4), npos(15, 3, 5))),
                                    lit_with('\n', nspan(npos(15, 3, 5), npos(16, 4, 1))),
                                ]
                            ))
                        );
                    }

                    #[test]
                    fn parse_uncounted_repetition() {
                        assert_eq!(
                            parser(r"a*").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..2),
                                op: ast::RepetitionOp {
                                    span: span(1..2),
                                    kind: ast::RepetitionKind::ZeroOrMore,
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a+").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..2),
                                op: ast::RepetitionOp {
                                    span: span(1..2),
                                    kind: ast::RepetitionKind::OneOrMore,
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );

                        assert_eq!(
                            parser(r"a?").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..2),
                                op: ast::RepetitionOp {
                                    span: span(1..2),
                                    kind: ast::RepetitionKind::ZeroOrOne,
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a??").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..3),
                                op: ast::RepetitionOp {
                                    span: span(1..3),
                                    kind: ast::RepetitionKind::ZeroOrOne,
                                },
                                greedy: false,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a?").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..2),
                                op: ast::RepetitionOp {
                                    span: span(1..2),
                                    kind: ast::RepetitionKind::ZeroOrOne,
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a?b").parse(),
                            Ok(concat(
                                0..3,
                                vec![
                                    Ast::repetition(ast::Repetition {
                                        span: span(0..2),
                                        op: ast::RepetitionOp {
                                            span: span(1..2),
                                            kind: ast::RepetitionKind::ZeroOrOne,
                                        },
                                        greedy: true,
                                        ast: Box::new(lit('a', 0)),
                                    }),
                                    lit('b', 2),
                                ]
                            ))
                        );
                        assert_eq!(
                            parser(r"a??b").parse(),
                            Ok(concat(
                                0..4,
                                vec![
                                    Ast::repetition(ast::Repetition {
                                        span: span(0..3),
                                        op: ast::RepetitionOp {
                                            span: span(1..3),
                                            kind: ast::RepetitionKind::ZeroOrOne,
                                        },
                                        greedy: false,
                                        ast: Box::new(lit('a', 0)),
                                    }),
                                    lit('b', 3),
                                ]
                            ))
                        );
                        assert_eq!(
                            parser(r"ab?").parse(),
                            Ok(concat(
                                0..3,
                                vec![
                                    lit('a', 0),
                                    Ast::repetition(ast::Repetition {
                                        span: span(1..3),
                                        op: ast::RepetitionOp {
                                            span: span(2..3),
                                            kind: ast::RepetitionKind::ZeroOrOne,
                                        },
                                        greedy: true,
                                        ast: Box::new(lit('b', 1)),
                                    }),
                                ]
                            ))
                        );
                        assert_eq!(
                            parser(r"(ab)?").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..5),
                                op: ast::RepetitionOp {
                                    span: span(4..5),
                                    kind: ast::RepetitionKind::ZeroOrOne,
                                },
                                greedy: true,
                                ast: Box::new(group(
                                    0..4,
                                    1,
                                    concat(1..3, vec![lit('a', 1), lit('b', 2),])
                                )),
                            }))
                        );
                        assert_eq!(
                            parser(r"|a?").parse(),
                            Ok(alt(
                                0..3,
                                vec![
                                    Ast::empty(span(0..0)),
                                    Ast::repetition(ast::Repetition {
                                        span: span(1..3),
                                        op: ast::RepetitionOp {
                                            span: span(2..3),
                                            kind: ast::RepetitionKind::ZeroOrOne,
                                        },
                                        greedy: true,
                                        ast: Box::new(lit('a', 1)),
                                    }),
                                ]
                            ))
                        );

                        assert_eq!(
                            parser(r"*").parse().unwrap_err(),
                            TestError {
                                span: span(0..0),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"(?i)*").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"(*)").parse().unwrap_err(),
                            TestError {
                                span: span(1..1),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"(?:?)").parse().unwrap_err(),
                            TestError {
                                span: span(3..3),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"+").parse().unwrap_err(),
                            TestError {
                                span: span(0..0),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"?").parse().unwrap_err(),
                            TestError {
                                span: span(0..0),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"(?)").parse().unwrap_err(),
                            TestError {
                                span: span(1..1),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"|*").parse().unwrap_err(),
                            TestError {
                                span: span(1..1),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"|+").parse().unwrap_err(),
                            TestError {
                                span: span(1..1),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"|?").parse().unwrap_err(),
                            TestError {
                                span: span(1..1),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                    }

                    #[test]
                    fn parse_counted_repetition() {
                        assert_eq!(
                            parser(r"a{5}").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..4),
                                op: ast::RepetitionOp {
                                    span: span(1..4),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Exactly(5)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a{5,}").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..5),
                                op: ast::RepetitionOp {
                                    span: span(1..5),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::AtLeast(5)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a{5,9}").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..6),
                                op: ast::RepetitionOp {
                                    span: span(1..6),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Bounded(5, 9)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a{5}?").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..5),
                                op: ast::RepetitionOp {
                                    span: span(1..5),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Exactly(5)
                                    ),
                                },
                                greedy: false,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"ab{5}").parse(),
                            Ok(concat(
                                0..5,
                                vec![
                                    lit('a', 0),
                                    Ast::repetition(ast::Repetition {
                                        span: span(1..5),
                                        op: ast::RepetitionOp {
                                            span: span(2..5),
                                            kind: ast::RepetitionKind::Range(
                                                ast::RepetitionRange::Exactly(5)
                                            ),
                                        },
                                        greedy: true,
                                        ast: Box::new(lit('b', 1)),
                                    }),
                                ]
                            ))
                        );
                        assert_eq!(
                            parser(r"ab{5}c").parse(),
                            Ok(concat(
                                0..6,
                                vec![
                                    lit('a', 0),
                                    Ast::repetition(ast::Repetition {
                                        span: span(1..5),
                                        op: ast::RepetitionOp {
                                            span: span(2..5),
                                            kind: ast::RepetitionKind::Range(
                                                ast::RepetitionRange::Exactly(5)
                                            ),
                                        },
                                        greedy: true,
                                        ast: Box::new(lit('b', 1)),
                                    }),
                                    lit('c', 5),
                                ]
                            ))
                        );

                        assert_eq!(
                            parser(r"a{ 5 }").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..6),
                                op: ast::RepetitionOp {
                                    span: span(1..6),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Exactly(5)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"a{ 5 , 9 }").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..10),
                                op: ast::RepetitionOp {
                                    span: span(1..10),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Bounded(5, 9)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser_empty_min_range(r"a{,9}").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..5),
                                op: ast::RepetitionOp {
                                    span: span(1..5),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Bounded(0, 9)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser_ignore_whitespace(r"a{5,9} ?").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..8),
                                op: ast::RepetitionOp {
                                    span: span(1..8),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Bounded(5, 9)
                                    ),
                                },
                                greedy: false,
                                ast: Box::new(lit('a', 0)),
                            }))
                        );
                        assert_eq!(
                            parser(r"\b{5,9}").parse(),
                            Ok(Ast::repetition(ast::Repetition {
                                span: span(0..7),
                                op: ast::RepetitionOp {
                                    span: span(2..7),
                                    kind: ast::RepetitionKind::Range(
                                        ast::RepetitionRange::Bounded(5, 9)
                                    ),
                                },
                                greedy: true,
                                ast: Box::new(Ast::assertion(ast::Assertion {
                                    span: span(0..2),
                                    kind: ast::AssertionKind::WordBoundary,
                                })),
                            }))
                        );

                        assert_eq!(
                            parser(r"(?i){0}").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"(?m){1,1}").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"a{]}").parse().unwrap_err(),
                            TestError {
                                span: span(2..2),
                                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,
                            }
                        );
                        assert_eq!(
                            parser(r"a{1,]}").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,
                            }
                        );
                        assert_eq!(
                            parser(r"a{").parse().unwrap_err(),
                            TestError {
                                span: span(1..2),
                                kind: ast::ErrorKind::RepetitionCountUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"a{}").parse().unwrap_err(),
                            TestError {
                                span: span(2..2),
                                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,
                            }
                        );
                        assert_eq!(
                            parser(r"a{a").parse().unwrap_err(),
                            TestError {
                                span: span(2..2),
                                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,
                            }
                        );
                        assert_eq!(
                            parser(r"a{9999999999}").parse().unwrap_err(),
                            TestError {
                                span: span(2..12),
                                kind: ast::ErrorKind::DecimalInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"a{9").parse().unwrap_err(),
                            TestError {
                                span: span(1..3),
                                kind: ast::ErrorKind::RepetitionCountUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"a{9,a").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::RepetitionCountDecimalEmpty,
                            }
                        );
                        assert_eq!(
                            parser(r"a{9,9999999999}").parse().unwrap_err(),
                            TestError {
                                span: span(4..14),
                                kind: ast::ErrorKind::DecimalInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"a{9,").parse().unwrap_err(),
                            TestError {
                                span: span(1..4),
                                kind: ast::ErrorKind::RepetitionCountUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"a{9,11").parse().unwrap_err(),
                            TestError {
                                span: span(1..6),
                                kind: ast::ErrorKind::RepetitionCountUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"a{2,1}").parse().unwrap_err(),
                            TestError {
                                span: span(1..6),
                                kind: ast::ErrorKind::RepetitionCountInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"{5}").parse().unwrap_err(),
                            TestError {
                                span: span(0..0),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                        assert_eq!(
                            parser(r"|{5}").parse().unwrap_err(),
                            TestError {
                                span: span(1..1),
                                kind: ast::ErrorKind::RepetitionMissing,
                            }
                        );
                    }

                    #[test]
                    fn parse_alternate() {
                        assert_eq!(
                            parser(r"a|b").parse(),
                            Ok(Ast::alternation(ast::Alternation {
                                span: span(0..3),
                                asts: vec![lit('a', 0), lit('b', 2)],
                            }))
                        );
                        assert_eq!(
                            parser(r"(a|b)").parse(),
                            Ok(group(
                                0..5,
                                1,
                                Ast::alternation(ast::Alternation {
                                    span: span(1..4),
                                    asts: vec![lit('a', 1), lit('b', 3)],
                                })
                            ))
                        );

                        assert_eq!(
                            parser(r"a|b|c").parse(),
                            Ok(Ast::alternation(ast::Alternation {
                                span: span(0..5),
                                asts: vec![lit('a', 0), lit('b', 2), lit('c', 4)],
                            }))
                        );
                        assert_eq!(
                            parser(r"ax|by|cz").parse(),
                            Ok(Ast::alternation(ast::Alternation {
                                span: span(0..8),
                                asts: vec![
                                    concat(0..2, vec![lit('a', 0), lit('x', 1)]),
                                    concat(3..5, vec![lit('b', 3), lit('y', 4)]),
                                    concat(6..8, vec![lit('c', 6), lit('z', 7)]),
                                ],
                            }))
                        );
                        assert_eq!(
                            parser(r"(ax|by|cz)").parse(),
                            Ok(group(
                                0..10,
                                1,
                                Ast::alternation(ast::Alternation {
                                    span: span(1..9),
                                    asts: vec![
                                        concat(1..3, vec![lit('a', 1), lit('x', 2)]),
                                        concat(4..6, vec![lit('b', 4), lit('y', 5)]),
                                        concat(7..9, vec![lit('c', 7), lit('z', 8)]),
                                    ],
                                })
                            ))
                        );
                        assert_eq!(
                            parser(r"(ax|(by|(cz)))").parse(),
                            Ok(group(
                                0..14,
                                1,
                                alt(
                                    1..13,
                                    vec![
                                        concat(1..3, vec![lit('a', 1), lit('x', 2)]),
                                        group(
                                            4..13,
                                            2,
                                            alt(
                                                5..12,
                                                vec![
                                                    concat(
                                                        5..7,
                                                        vec![lit('b', 5), lit('y', 6)]
                                                    ),
                                                    group(
                                                        8..12,
                                                        3,
                                                        concat(
                                                            9..11,
                                                            vec![lit('c', 9), lit('z', 10),]
                                                        )
                                                    ),
                                                ]
                                            )
                                        ),
                                    ]
                                )
                            ))
                        );

                        assert_eq!(
                            parser(r"|").parse(),
                            Ok(alt(
                                0..1,
                                vec![Ast::empty(span(0..0)), Ast::empty(span(1..1)),]
                            ))
                        );
                        assert_eq!(
                            parser(r"||").parse(),
                            Ok(alt(
                                0..2,
                                vec![
                                    Ast::empty(span(0..0)),
                                    Ast::empty(span(1..1)),
                                    Ast::empty(span(2..2)),
                                ]
                            ))
                        );
                        assert_eq!(
                            parser(r"a|").parse(),
                            Ok(alt(0..2, vec![lit('a', 0), Ast::empty(span(2..2)),]))
                        );
                        assert_eq!(
                            parser(r"|a").parse(),
                            Ok(alt(0..2, vec![Ast::empty(span(0..0)), lit('a', 1),]))
                        );

                        assert_eq!(
                            parser(r"(|)").parse(),
                            Ok(group(
                                0..3,
                                1,
                                alt(
                                    1..2,
                                    vec![Ast::empty(span(1..1)), Ast::empty(span(2..2)),]
                                )
                            ))
                        );
                        assert_eq!(
                            parser(r"(a|)").parse(),
                            Ok(group(
                                0..4,
                                1,
                                alt(1..3, vec![lit('a', 1), Ast::empty(span(3..3)),])
                            ))
                        );
                        assert_eq!(
                            parser(r"(|a)").parse(),
                            Ok(group(
                                0..4,
                                1,
                                alt(1..3, vec![Ast::empty(span(1..1)), lit('a', 2),])
                            ))
                        );

                        assert_eq!(
                            parser(r"a|b)").parse().unwrap_err(),
                            TestError {
                                span: span(3..4),
                                kind: ast::ErrorKind::GroupUnopened,
                            }
                        );
                        assert_eq!(
                            parser(r"(a|b").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::GroupUnclosed,
                            }
                        );
                    }

                    #[test]
                    fn parse_unsupported_lookaround() {
                        assert_eq!(
                            parser(r"(?=a)").parse().unwrap_err(),
                            TestError {
                                span: span(0..3),
                                kind: ast::ErrorKind::UnsupportedLookAround,
                            }
                        );
                        assert_eq!(
                            parser(r"(?!a)").parse().unwrap_err(),
                            TestError {
                                span: span(0..3),
                                kind: ast::ErrorKind::UnsupportedLookAround,
                            }
                        );
                        assert_eq!(
                            parser(r"(?<=a)").parse().unwrap_err(),
                            TestError {
                                span: span(0..4),
                                kind: ast::ErrorKind::UnsupportedLookAround,
                            }
                        );
                        assert_eq!(
                            parser(r"(?<!a)").parse().unwrap_err(),
                            TestError {
                                span: span(0..4),
                                kind: ast::ErrorKind::UnsupportedLookAround,
                            }
                        );
                    }

                    #[test]
                    fn parse_group() {
                        assert_eq!(
                            parser("(?i)").parse(),
                            Ok(Ast::flags(ast::SetFlags {
                                span: span(0..4),
                                flags: ast::Flags {
                                    span: span(2..3),
                                    items: vec![ast::FlagsItem {
                                        span: span(2..3),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::CaseInsensitive
                                        ),
                                    }],
                                },
                            }))
                        );
                        assert_eq!(
                            parser("(?iU)").parse(),
                            Ok(Ast::flags(ast::SetFlags {
                                span: span(0..5),
                                flags: ast::Flags {
                                    span: span(2..4),
                                    items: vec![
                                        ast::FlagsItem {
                                            span: span(2..3),
                                            kind: ast::FlagsItemKind::Flag(
                                                ast::Flag::CaseInsensitive
                                            ),
                                        },
                                        ast::FlagsItem {
                                            span: span(3..4),
                                            kind: ast::FlagsItemKind::Flag(
                                                ast::Flag::SwapGreed
                                            ),
                                        },
                                    ],
                                },
                            }))
                        );
                        assert_eq!(
                            parser("(?i-U)").parse(),
                            Ok(Ast::flags(ast::SetFlags {
                                span: span(0..6),
                                flags: ast::Flags {
                                    span: span(2..5),
                                    items: vec![
                                        ast::FlagsItem {
                                            span: span(2..3),
                                            kind: ast::FlagsItemKind::Flag(
                                                ast::Flag::CaseInsensitive
                                            ),
                                        },
                                        ast::FlagsItem {
                                            span: span(3..4),
                                            kind: ast::FlagsItemKind::Negation,
                                        },
                                        ast::FlagsItem {
                                            span: span(4..5),
                                            kind: ast::FlagsItemKind::Flag(
                                                ast::Flag::SwapGreed
                                            ),
                                        },
                                    ],
                                },
                            }))
                        );

                        assert_eq!(
                            parser("()").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..2),
                                kind: ast::GroupKind::CaptureIndex(1),
                                ast: Box::new(Ast::empty(span(1..1))),
                            }))
                        );
                        assert_eq!(
                            parser("(a)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..3),
                                kind: ast::GroupKind::CaptureIndex(1),
                                ast: Box::new(lit('a', 1)),
                            }))
                        );
                        assert_eq!(
                            parser("(())").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..4),
                                kind: ast::GroupKind::CaptureIndex(1),
                                ast: Box::new(Ast::group(ast::Group {
                                    span: span(1..3),
                                    kind: ast::GroupKind::CaptureIndex(2),
                                    ast: Box::new(Ast::empty(span(2..2))),
                                })),
                            }))
                        );

                        assert_eq!(
                            parser("(?:a)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..5),
                                kind: ast::GroupKind::NonCapturing(ast::Flags {
                                    span: span(2..2),
                                    items: vec![],
                                }),
                                ast: Box::new(lit('a', 3)),
                            }))
                        );

                        assert_eq!(
                            parser("(?i:a)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..6),
                                kind: ast::GroupKind::NonCapturing(ast::Flags {
                                    span: span(2..3),
                                    items: vec![ast::FlagsItem {
                                        span: span(2..3),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::CaseInsensitive
                                        ),
                                    },],
                                }),
                                ast: Box::new(lit('a', 4)),
                            }))
                        );
                        assert_eq!(
                            parser("(?i-U:a)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..8),
                                kind: ast::GroupKind::NonCapturing(ast::Flags {
                                    span: span(2..5),
                                    items: vec![
                                        ast::FlagsItem {
                                            span: span(2..3),
                                            kind: ast::FlagsItemKind::Flag(
                                                ast::Flag::CaseInsensitive
                                            ),
                                        },
                                        ast::FlagsItem {
                                            span: span(3..4),
                                            kind: ast::FlagsItemKind::Negation,
                                        },
                                        ast::FlagsItem {
                                            span: span(4..5),
                                            kind: ast::FlagsItemKind::Flag(
                                                ast::Flag::SwapGreed
                                            ),
                                        },
                                    ],
                                }),
                                ast: Box::new(lit('a', 6)),
                            }))
                        );

                        assert_eq!(
                            parser("(").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::GroupUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("(?").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::GroupUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("(?P").parse().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::FlagUnrecognized,
                            }
                        );
                        assert_eq!(
                            parser("(?P<").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::GroupNameUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser("(a").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::GroupUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("(()").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::GroupUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(")").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::GroupUnopened,
                            }
                        );
                        assert_eq!(
                            parser("a)").parse().unwrap_err(),
                            TestError {
                                span: span(1..2),
                                kind: ast::ErrorKind::GroupUnopened,
                            }
                        );
                    }

                    #[test]
                    fn parse_capture_name() {
                        assert_eq!(
                            parser("(?<a>z)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..7),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: false,
                                    name: ast::CaptureName {
                                        span: span(3..4),
                                        name: s("a"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(lit('z', 5)),
                            }))
                        );
                        assert_eq!(
                            parser("(?P<a>z)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..8),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: span(4..5),
                                        name: s("a"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(lit('z', 6)),
                            }))
                        );
                        assert_eq!(
                            parser("(?P<abc>z)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..10),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: span(4..7),
                                        name: s("abc"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(lit('z', 8)),
                            }))
                        );

                        assert_eq!(
                            parser("(?P<a_1>z)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..10),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: span(4..7),
                                        name: s("a_1"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(lit('z', 8)),
                            }))
                        );

                        assert_eq!(
                            parser("(?P<a.1>z)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..10),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: span(4..7),
                                        name: s("a.1"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(lit('z', 8)),
                            }))
                        );

                        assert_eq!(
                            parser("(?P<a[1]>z)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: span(0..11),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: span(4..8),
                                        name: s("a[1]"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(lit('z', 9)),
                            }))
                        );

                        assert_eq!(
                            parser("(?P<a¾>)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: Span::new(
                                    Position::new(0, 1, 1),
                                    Position::new(9, 1, 9),
                                ),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: Span::new(
                                            Position::new(4, 1, 5),
                                            Position::new(7, 1, 7),
                                        ),
                                        name: s("a¾"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(Ast::empty(Span::new(
                                    Position::new(8, 1, 8),
                                    Position::new(8, 1, 8),
                                ))),
                            }))
                        );
                        assert_eq!(
                            parser("(?P<名字>)").parse(),
                            Ok(Ast::group(ast::Group {
                                span: Span::new(
                                    Position::new(0, 1, 1),
                                    Position::new(12, 1, 9),
                                ),
                                kind: ast::GroupKind::CaptureName {
                                    starts_with_p: true,
                                    name: ast::CaptureName {
                                        span: Span::new(
                                            Position::new(4, 1, 5),
                                            Position::new(10, 1, 7),
                                        ),
                                        name: s("名字"),
                                        index: 1,
                                    }
                                },
                                ast: Box::new(Ast::empty(Span::new(
                                    Position::new(11, 1, 8),
                                    Position::new(11, 1, 8),
                                ))),
                            }))
                        );

                        assert_eq!(
                            parser("(?P<").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::GroupNameUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser("(?P<>z)").parse().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::GroupNameEmpty,
                            }
                        );
                        assert_eq!(
                            parser("(?P<a").parse().unwrap_err(),
                            TestError {
                                span: span(5..5),
                                kind: ast::ErrorKind::GroupNameUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser("(?P<ab").parse().unwrap_err(),
                            TestError {
                                span: span(6..6),
                                kind: ast::ErrorKind::GroupNameUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser("(?P<0a").parse().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<~").parse().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<abc~").parse().unwrap_err(),
                            TestError {
                                span: span(7..8),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<a>y)(?P<a>z)").parse().unwrap_err(),
                            TestError {
                                span: span(12..13),
                                kind: ast::ErrorKind::GroupNameDuplicate {
                                    original: span(4..5),
                                },
                            }
                        );
                        assert_eq!(
                            parser("(?P<5>)").parse().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<5a>)").parse().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<¾>)").parse().unwrap_err(),
                            TestError {
                                span: Span::new(
                                    Position::new(4, 1, 5),
                                    Position::new(6, 1, 6),
                                ),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<¾a>)").parse().unwrap_err(),
                            TestError {
                                span: Span::new(
                                    Position::new(4, 1, 5),
                                    Position::new(6, 1, 6),
                                ),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<☃>)").parse().unwrap_err(),
                            TestError {
                                span: Span::new(
                                    Position::new(4, 1, 5),
                                    Position::new(7, 1, 6),
                                ),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                        assert_eq!(
                            parser("(?P<a☃>)").parse().unwrap_err(),
                            TestError {
                                span: Span::new(
                                    Position::new(5, 1, 6),
                                    Position::new(8, 1, 7),
                                ),
                                kind: ast::ErrorKind::GroupNameInvalid,
                            }
                        );
                    }

                    #[test]
                    fn parse_flags() {
                        assert_eq!(
                            parser("i:").parse_flags(),
                            Ok(ast::Flags {
                                span: span(0..1),
                                items: vec![ast::FlagsItem {
                                    span: span(0..1),
                                    kind: ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive),
                                }],
                            })
                        );
                        assert_eq!(
                            parser("i)").parse_flags(),
                            Ok(ast::Flags {
                                span: span(0..1),
                                items: vec![ast::FlagsItem {
                                    span: span(0..1),
                                    kind: ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive),
                                }],
                            })
                        );

                        assert_eq!(
                            parser("isU:").parse_flags(),
                            Ok(ast::Flags {
                                span: span(0..3),
                                items: vec![
                                    ast::FlagsItem {
                                        span: span(0..1),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::CaseInsensitive
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(1..2),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::DotMatchesNewLine
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(2..3),
                                        kind: ast::FlagsItemKind::Flag(ast::Flag::SwapGreed),
                                    },
                                ],
                            })
                        );

                        assert_eq!(
                            parser("-isU:").parse_flags(),
                            Ok(ast::Flags {
                                span: span(0..4),
                                items: vec![
                                    ast::FlagsItem {
                                        span: span(0..1),
                                        kind: ast::FlagsItemKind::Negation,
                                    },
                                    ast::FlagsItem {
                                        span: span(1..2),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::CaseInsensitive
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(2..3),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::DotMatchesNewLine
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(3..4),
                                        kind: ast::FlagsItemKind::Flag(ast::Flag::SwapGreed),
                                    },
                                ],
                            })
                        );
                        assert_eq!(
                            parser("i-sU:").parse_flags(),
                            Ok(ast::Flags {
                                span: span(0..4),
                                items: vec![
                                    ast::FlagsItem {
                                        span: span(0..1),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::CaseInsensitive
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(1..2),
                                        kind: ast::FlagsItemKind::Negation,
                                    },
                                    ast::FlagsItem {
                                        span: span(2..3),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::DotMatchesNewLine
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(3..4),
                                        kind: ast::FlagsItemKind::Flag(ast::Flag::SwapGreed),
                                    },
                                ],
                            })
                        );
                        assert_eq!(
                            parser("i-sR:").parse_flags(),
                            Ok(ast::Flags {
                                span: span(0..4),
                                items: vec![
                                    ast::FlagsItem {
                                        span: span(0..1),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::CaseInsensitive
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(1..2),
                                        kind: ast::FlagsItemKind::Negation,
                                    },
                                    ast::FlagsItem {
                                        span: span(2..3),
                                        kind: ast::FlagsItemKind::Flag(
                                            ast::Flag::DotMatchesNewLine
                                        ),
                                    },
                                    ast::FlagsItem {
                                        span: span(3..4),
                                        kind: ast::FlagsItemKind::Flag(ast::Flag::CRLF),
                                    },
                                ],
                            })
                        );

                        assert_eq!(
                            parser("isU").parse_flags().unwrap_err(),
                            TestError {
                                span: span(3..3),
                                kind: ast::ErrorKind::FlagUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser("isUa:").parse_flags().unwrap_err(),
                            TestError {
                                span: span(3..4),
                                kind: ast::ErrorKind::FlagUnrecognized,
                            }
                        );
                        assert_eq!(
                            parser("isUi:").parse_flags().unwrap_err(),
                            TestError {
                                span: span(3..4),
                                kind: ast::ErrorKind::FlagDuplicate { original: span(0..1) },
                            }
                        );
                        assert_eq!(
                            parser("i-sU-i:").parse_flags().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::FlagRepeatedNegation {
                                    original: span(1..2),
                                },
                            }
                        );
                        assert_eq!(
                            parser("-)").parse_flags().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::FlagDanglingNegation,
                            }
                        );
                        assert_eq!(
                            parser("i-)").parse_flags().unwrap_err(),
                            TestError {
                                span: span(1..2),
                                kind: ast::ErrorKind::FlagDanglingNegation,
                            }
                        );
                        assert_eq!(
                            parser("iU-)").parse_flags().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::FlagDanglingNegation,
                            }
                        );
                    }

                    #[test]
                    fn parse_flag() {
                        assert_eq!(parser("i").parse_flag(), Ok(ast::Flag::CaseInsensitive));
                        assert_eq!(parser("m").parse_flag(), Ok(ast::Flag::MultiLine));
                        assert_eq!(parser("s").parse_flag(), Ok(ast::Flag::DotMatchesNewLine));
                        assert_eq!(parser("U").parse_flag(), Ok(ast::Flag::SwapGreed));
                        assert_eq!(parser("u").parse_flag(), Ok(ast::Flag::Unicode));
                        assert_eq!(parser("R").parse_flag(), Ok(ast::Flag::CRLF));
                        assert_eq!(parser("x").parse_flag(), Ok(ast::Flag::IgnoreWhitespace));

                        assert_eq!(
                            parser("a").parse_flag().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::FlagUnrecognized,
                            }
                        );
                        assert_eq!(
                            parser("☃").parse_flag().unwrap_err(),
                            TestError {
                                span: span_range("☃", 0..3),
                                kind: ast::ErrorKind::FlagUnrecognized,
                            }
                        );
                    }

                    #[test]
                    fn parse_primitive_non_escape() {
                        assert_eq!(
                            parser(r".").parse_primitive(),
                            Ok(Primitive::Dot(span(0..1)))
                        );
                        assert_eq!(
                            parser(r"^").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..1),
                                kind: ast::AssertionKind::StartLine,
                            }))
                        );
                        assert_eq!(
                            parser(r"$").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..1),
                                kind: ast::AssertionKind::EndLine,
                            }))
                        );

                        assert_eq!(
                            parser(r"a").parse_primitive(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..1),
                                kind: ast::LiteralKind::Verbatim,
                                c: 'a',
                            }))
                        );
                        assert_eq!(
                            parser(r"|").parse_primitive(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..1),
                                kind: ast::LiteralKind::Verbatim,
                                c: '|',
                            }))
                        );
                        assert_eq!(
                            parser(r"☃").parse_primitive(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span_range("☃", 0..3),
                                kind: ast::LiteralKind::Verbatim,
                                c: '☃',
                            }))
                        );
                    }

                    #[test]
                    fn parse_escape() {
                        assert_eq!(
                            parser(r"\|").parse_primitive(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..2),
                                kind: ast::LiteralKind::Meta,
                                c: '|',
                            }))
                        );
                        let specials = &[
                            (r"\a", '\x07', ast::SpecialLiteralKind::Bell),
                            (r"\f", '\x0C', ast::SpecialLiteralKind::FormFeed),
                            (r"\t", '\t', ast::SpecialLiteralKind::Tab),
                            (r"\n", '\n', ast::SpecialLiteralKind::LineFeed),
                            (r"\r", '\r', ast::SpecialLiteralKind::CarriageReturn),
                            (r"\v", '\x0B', ast::SpecialLiteralKind::VerticalTab),
                        ];
                        for &(pat, c, ref kind) in specials {
                            assert_eq!(
                                parser(pat).parse_primitive(),
                                Ok(Primitive::Literal(ast::Literal {
                                    span: span(0..2),
                                    kind: ast::LiteralKind::Special(kind.clone()),
                                    c,
                                }))
                            );
                        }
                        assert_eq!(
                            parser(r"\A").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..2),
                                kind: ast::AssertionKind::StartText,
                            }))
                        );
                        assert_eq!(
                            parser(r"\z").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..2),
                                kind: ast::AssertionKind::EndText,
                            }))
                        );
                        assert_eq!(
                            parser(r"\b").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..2),
                                kind: ast::AssertionKind::WordBoundary,
                            }))
                        );
                        assert_eq!(
                            parser(r"\b{start}").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..9),
                                kind: ast::AssertionKind::WordBoundaryStart,
                            }))
                        );
                        assert_eq!(
                            parser(r"\b{end}").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..7),
                                kind: ast::AssertionKind::WordBoundaryEnd,
                            }))
                        );
                        assert_eq!(
                            parser(r"\b{start-half}").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..14),
                                kind: ast::AssertionKind::WordBoundaryStartHalf,
                            }))
                        );
                        assert_eq!(
                            parser(r"\b{end-half}").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..12),
                                kind: ast::AssertionKind::WordBoundaryEndHalf,
                            }))
                        );
                        assert_eq!(
                            parser(r"\<").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..2),
                                kind: ast::AssertionKind::WordBoundaryStartAngle,
                            }))
                        );
                        assert_eq!(
                            parser(r"\>").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..2),
                                kind: ast::AssertionKind::WordBoundaryEndAngle,
                            }))
                        );
                        assert_eq!(
                            parser(r"\B").parse_primitive(),
                            Ok(Primitive::Assertion(ast::Assertion {
                                span: span(0..2),
                                kind: ast::AssertionKind::NotWordBoundary,
                            }))
                        );

                        // We also support superfluous escapes in most cases now too.
                        for c in ['!', '@', '%', '"', '\'', '/', ' '] {
                            let pat = format!(r"\{}", c);
                            assert_eq!(
                                parser(&pat).parse_primitive(),
                                Ok(Primitive::Literal(ast::Literal {
                                    span: span(0..2),
                                    kind: ast::LiteralKind::Superfluous,
                                    c,
                                }))
                            );
                        }
                        assert_eq!(
                            parser(r"\e").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::EscapeUnrecognized,
                            }
                        );
                        assert_eq!(
                            parser(r"\y").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::EscapeUnrecognized,
                            }
                        );
                        assert_eq!(
                            parser(r"\b{").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..3),
                                kind: ast::ErrorKind::SpecialWordOrRepetitionUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser_ignore_whitespace(r"\b{ ").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..4),
                                kind: ast::ErrorKind::SpecialWordOrRepetitionUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\b{ ").parse().unwrap_err(),
                            TestError {
                                span: span(2..4),
                                kind: ast::ErrorKind::RepetitionCountUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"\b{foo").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..6),
                                kind: ast::ErrorKind::SpecialWordBoundaryUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"\b{foo!}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..6),
                                kind: ast::ErrorKind::SpecialWordBoundaryUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"\b{foo}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..6),
                                kind: ast::ErrorKind::SpecialWordBoundaryUnrecognized,
                            }
                        );

                        // An unfinished escape is illegal.
                        assert_eq!(
                            parser(r"\").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                    }

                    #[test]
                    fn parse_unsupported_backreference() {
                        assert_eq!(
                            parser(r"\0").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::UnsupportedBackreference,
                            }
                        );
                        assert_eq!(
                            parser(r"\9").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::UnsupportedBackreference,
                            }
                        );
                    }

                    #[test]
                    fn parse_octal() {
                        for i in 0..511 {
                            let pat = format!(r"\{:o}", i);
                            assert_eq!(
                                parser_octal(&pat).parse_escape(),
                                Ok(Primitive::Literal(ast::Literal {
                                    span: span(0..pat.len()),
                                    kind: ast::LiteralKind::Octal,
                                    c: char::from_u32(i).unwrap(),
                                }))
                            );
                        }
                        assert_eq!(
                            parser_octal(r"\778").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..3),
                                kind: ast::LiteralKind::Octal,
                                c: '?',
                            }))
                        );
                        assert_eq!(
                            parser_octal(r"\7777").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..4),
                                kind: ast::LiteralKind::Octal,
                                c: '\u{01FF}',
                            }))
                        );
                        assert_eq!(
                            parser_octal(r"\778").parse(),
                            Ok(Ast::concat(ast::Concat {
                                span: span(0..4),
                                asts: vec![
                                    Ast::literal(ast::Literal {
                                        span: span(0..3),
                                        kind: ast::LiteralKind::Octal,
                                        c: '?',
                                    }),
                                    Ast::literal(ast::Literal {
                                        span: span(3..4),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '8',
                                    }),
                                ],
                            }))
                        );
                        assert_eq!(
                            parser_octal(r"\7777").parse(),
                            Ok(Ast::concat(ast::Concat {
                                span: span(0..5),
                                asts: vec![
                                    Ast::literal(ast::Literal {
                                        span: span(0..4),
                                        kind: ast::LiteralKind::Octal,
                                        c: '\u{01FF}',
                                    }),
                                    Ast::literal(ast::Literal {
                                        span: span(4..5),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '7',
                                    }),
                                ],
                            }))
                        );

                        assert_eq!(
                            parser_octal(r"\8").parse_escape().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::EscapeUnrecognized,
                            }
                        );
                    }

                    #[test]
                    fn parse_hex_two() {
                        for i in 0..256 {
                            let pat = format!(r"\x{:02x}", i);
                            assert_eq!(
                                parser(&pat).parse_escape(),
                                Ok(Primitive::Literal(ast::Literal {
                                    span: span(0..pat.len()),
                                    kind: ast::LiteralKind::HexFixed(ast::HexLiteralKind::X),
                                    c: char::from_u32(i).unwrap(),
                                }))
                            );
                        }

                        assert_eq!(
                            parser(r"\xF").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..3),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\xG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\xFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..4),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                    }

                    #[test]
                    fn parse_hex_four() {
                        for i in 0..65536 {
                            let c = match char::from_u32(i) {
                                None => continue,
                                Some(c) => c,
                            };
                            let pat = format!(r"\u{:04x}", i);
                            assert_eq!(
                                parser(&pat).parse_escape(),
                                Ok(Primitive::Literal(ast::Literal {
                                    span: span(0..pat.len()),
                                    kind: ast::LiteralKind::HexFixed(
                                        ast::HexLiteralKind::UnicodeShort
                                    ),
                                    c,
                                }))
                            );
                        }

                        assert_eq!(
                            parser(r"\uF").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..3),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\uG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\uFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..4),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\uFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\uFFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(5..6),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\uD800").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..6),
                                kind: ast::ErrorKind::EscapeHexInvalid,
                            }
                        );
                    }

                    #[test]
                    fn parse_hex_eight() {
                        for i in 0..65536 {
                            let c = match char::from_u32(i) {
                                None => continue,
                                Some(c) => c,
                            };
                            let pat = format!(r"\U{:08x}", i);
                            assert_eq!(
                                parser(&pat).parse_escape(),
                                Ok(Primitive::Literal(ast::Literal {
                                    span: span(0..pat.len()),
                                    kind: ast::LiteralKind::HexFixed(
                                        ast::HexLiteralKind::UnicodeLong
                                    ),
                                    c,
                                }))
                            );
                        }

                        assert_eq!(
                            parser(r"\UF").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..3),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\UG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..4),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(5..6),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFFFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(6..7),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFFFFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(7..8),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFFFFFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(8..9),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\UFFFFFFFG").parse_escape().unwrap_err(),
                            TestError {
                                span: span(9..10),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                    }

                    #[test]
                    fn parse_hex_brace() {
                        assert_eq!(
                            parser(r"\u{26c4}").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..8),
                                kind: ast::LiteralKind::HexBrace(
                                    ast::HexLiteralKind::UnicodeShort
                                ),
                                c: '⛄',
                            }))
                        );
                        assert_eq!(
                            parser(r"\U{26c4}").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..8),
                                kind: ast::LiteralKind::HexBrace(
                                    ast::HexLiteralKind::UnicodeLong
                                ),
                                c: '⛄',
                            }))
                        );
                        assert_eq!(
                            parser(r"\x{26c4}").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..8),
                                kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),
                                c: '⛄',
                            }))
                        );
                        assert_eq!(
                            parser(r"\x{26C4}").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..8),
                                kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),
                                c: '⛄',
                            }))
                        );
                        assert_eq!(
                            parser(r"\x{10fFfF}").parse_escape(),
                            Ok(Primitive::Literal(ast::Literal {
                                span: span(0..10),
                                kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),
                                c: '\u{10FFFF}',
                            }))
                        );

                        assert_eq!(
                            parser(r"\x").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..2),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{FF").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..5),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..4),
                                kind: ast::ErrorKind::EscapeHexEmpty,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{FGF}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(4..5),
                                kind: ast::ErrorKind::EscapeHexInvalidDigit,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{FFFFFF}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..9),
                                kind: ast::ErrorKind::EscapeHexInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{D800}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..7),
                                kind: ast::ErrorKind::EscapeHexInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"\x{FFFFFFFFF}").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..12),
                                kind: ast::ErrorKind::EscapeHexInvalid,
                            }
                        );
                    }

                    #[test]
                    fn parse_decimal() {
                        assert_eq!(parser("123").parse_decimal(), Ok(123));
                        assert_eq!(parser("0").parse_decimal(), Ok(0));
                        assert_eq!(parser("01").parse_decimal(), Ok(1));

                        assert_eq!(
                            parser("-1").parse_decimal().unwrap_err(),
                            TestError { span: span(0..0), kind: ast::ErrorKind::DecimalEmpty }
                        );
                        assert_eq!(
                            parser("").parse_decimal().unwrap_err(),
                            TestError { span: span(0..0), kind: ast::ErrorKind::DecimalEmpty }
                        );
                        assert_eq!(
                            parser("9999999999").parse_decimal().unwrap_err(),
                            TestError {
                                span: span(0..10),
                                kind: ast::ErrorKind::DecimalInvalid,
                            }
                        );
                    }

                    #[test]
                    fn parse_set_class() {
                        fn union(span: Span, items: Vec<ast::ClassSetItem>) -> ast::ClassSet {
                            ast::ClassSet::union(ast::ClassSetUnion { span, items })
                        }

                        fn intersection(
                            span: Span,
                            lhs: ast::ClassSet,
                            rhs: ast::ClassSet,
                        ) -> ast::ClassSet {
                            ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
                                span,
                                kind: ast::ClassSetBinaryOpKind::Intersection,
                                lhs: Box::new(lhs),
                                rhs: Box::new(rhs),
                            })
                        }

                        fn difference(
                            span: Span,
                            lhs: ast::ClassSet,
                            rhs: ast::ClassSet,
                        ) -> ast::ClassSet {
                            ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
                                span,
                                kind: ast::ClassSetBinaryOpKind::Difference,
                                lhs: Box::new(lhs),
                                rhs: Box::new(rhs),
                            })
                        }

                        fn symdifference(
                            span: Span,
                            lhs: ast::ClassSet,
                            rhs: ast::ClassSet,
                        ) -> ast::ClassSet {
                            ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
                                span,
                                kind: ast::ClassSetBinaryOpKind::SymmetricDifference,
                                lhs: Box::new(lhs),
                                rhs: Box::new(rhs),
                            })
                        }

                        fn itemset(item: ast::ClassSetItem) -> ast::ClassSet {
                            ast::ClassSet::Item(item)
                        }

                        fn item_ascii(cls: ast::ClassAscii) -> ast::ClassSetItem {
                            ast::ClassSetItem::Ascii(cls)
                        }

                        fn item_unicode(cls: ast::ClassUnicode) -> ast::ClassSetItem {
                            ast::ClassSetItem::Unicode(cls)
                        }

                        fn item_perl(cls: ast::ClassPerl) -> ast::ClassSetItem {
                            ast::ClassSetItem::Perl(cls)
                        }

                        fn item_bracket(cls: ast::ClassBracketed) -> ast::ClassSetItem {
                            ast::ClassSetItem::Bracketed(Box::new(cls))
                        }

                        fn lit(span: Span, c: char) -> ast::ClassSetItem {
                            ast::ClassSetItem::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Verbatim,
                                c,
                            })
                        }

                        fn empty(span: Span) -> ast::ClassSetItem {
                            ast::ClassSetItem::Empty(span)
                        }

                        fn range(span: Span, start: char, end: char) -> ast::ClassSetItem {
                            let pos1 = Position {
                                offset: span.start.offset + start.len_utf8(),
                                column: span.start.column + 1,
                                ..span.start
                            };
                            let pos2 = Position {
                                offset: span.end.offset - end.len_utf8(),
                                column: span.end.column - 1,
                                ..span.end
                            };
                            ast::ClassSetItem::Range(ast::ClassSetRange {
                                span,
                                start: ast::Literal {
                                    span: Span { end: pos1, ..span },
                                    kind: ast::LiteralKind::Verbatim,
                                    c: start,
                                },
                                end: ast::Literal {
                                    span: Span { start: pos2, ..span },
                                    kind: ast::LiteralKind::Verbatim,
                                    c: end,
                                },
                            })
                        }

                        fn alnum(span: Span, negated: bool) -> ast::ClassAscii {
                            ast::ClassAscii { span, kind: ast::ClassAsciiKind::Alnum, negated }
                        }

                        fn lower(span: Span, negated: bool) -> ast::ClassAscii {
                            ast::ClassAscii { span, kind: ast::ClassAsciiKind::Lower, negated }
                        }

                        assert_eq!(
                            parser("[[:alnum:]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..11),
                                negated: false,
                                kind: itemset(item_ascii(alnum(span(1..10), false))),
                            }))
                        );
                        assert_eq!(
                            parser("[[[:alnum:]]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..13),
                                negated: false,
                                kind: itemset(item_bracket(ast::ClassBracketed {
                                    span: span(1..12),
                                    negated: false,
                                    kind: itemset(item_ascii(alnum(span(2..11), false))),
                                })),
                            }))
                        );
                        assert_eq!(
                            parser("[[:alnum:]&&[:lower:]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..22),
                                negated: false,
                                kind: intersection(
                                    span(1..21),
                                    itemset(item_ascii(alnum(span(1..10), false))),
                                    itemset(item_ascii(lower(span(12..21), false))),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser("[[:alnum:]--[:lower:]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..22),
                                negated: false,
                                kind: difference(
                                    span(1..21),
                                    itemset(item_ascii(alnum(span(1..10), false))),
                                    itemset(item_ascii(lower(span(12..21), false))),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser("[[:alnum:]~~[:lower:]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..22),
                                negated: false,
                                kind: symdifference(
                                    span(1..21),
                                    itemset(item_ascii(alnum(span(1..10), false))),
                                    itemset(item_ascii(lower(span(12..21), false))),
                                ),
                            }))
                        );

                        assert_eq!(
                            parser("[a]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..3),
                                negated: false,
                                kind: itemset(lit(span(1..2), 'a')),
                            }))
                        );
                        assert_eq!(
                            parser(r"[a\]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..5),
                                negated: false,
                                kind: union(
                                    span(1..4),
                                    vec![
                                        lit(span(1..2), 'a'),
                                        ast::ClassSetItem::Literal(ast::Literal {
                                            span: span(2..4),
                                            kind: ast::LiteralKind::Meta,
                                            c: ']',
                                        }),
                                    ]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[a\-z]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..6),
                                negated: false,
                                kind: union(
                                    span(1..5),
                                    vec![
                                        lit(span(1..2), 'a'),
                                        ast::ClassSetItem::Literal(ast::Literal {
                                            span: span(2..4),
                                            kind: ast::LiteralKind::Meta,
                                            c: '-',
                                        }),
                                        lit(span(4..5), 'z'),
                                    ]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser("[ab]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..4),
                                negated: false,
                                kind: union(
                                    span(1..3),
                                    vec![lit(span(1..2), 'a'), lit(span(2..3), 'b'),]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser("[a-]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..4),
                                negated: false,
                                kind: union(
                                    span(1..3),
                                    vec![lit(span(1..2), 'a'), lit(span(2..3), '-'),]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser("[-a]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..4),
                                negated: false,
                                kind: union(
                                    span(1..3),
                                    vec![lit(span(1..2), '-'), lit(span(2..3), 'a'),]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[\pL]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..5),
                                negated: false,
                                kind: itemset(item_unicode(ast::ClassUnicode {
                                    span: span(1..4),
                                    negated: false,
                                    kind: ast::ClassUnicodeKind::OneLetter('L'),
                                })),
                            }))
                        );
                        assert_eq!(
                            parser(r"[\w]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..4),
                                negated: false,
                                kind: itemset(item_perl(ast::ClassPerl {
                                    span: span(1..3),
                                    kind: ast::ClassPerlKind::Word,
                                    negated: false,
                                })),
                            }))
                        );
                        assert_eq!(
                            parser(r"[a\wz]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..6),
                                negated: false,
                                kind: union(
                                    span(1..5),
                                    vec![
                                        lit(span(1..2), 'a'),
                                        item_perl(ast::ClassPerl {
                                            span: span(2..4),
                                            kind: ast::ClassPerlKind::Word,
                                            negated: false,
                                        }),
                                        lit(span(4..5), 'z'),
                                    ]
                                ),
                            }))
                        );

                        assert_eq!(
                            parser("[a-z]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..5),
                                negated: false,
                                kind: itemset(range(span(1..4), 'a', 'z')),
                            }))
                        );
                        assert_eq!(
                            parser("[a-cx-z]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..8),
                                negated: false,
                                kind: union(
                                    span(1..7),
                                    vec![
                                        range(span(1..4), 'a', 'c'),
                                        range(span(4..7), 'x', 'z'),
                                    ]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[\w&&a-cx-z]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..12),
                                negated: false,
                                kind: intersection(
                                    span(1..11),
                                    itemset(item_perl(ast::ClassPerl {
                                        span: span(1..3),
                                        kind: ast::ClassPerlKind::Word,
                                        negated: false,
                                    })),
                                    union(
                                        span(5..11),
                                        vec![
                                            range(span(5..8), 'a', 'c'),
                                            range(span(8..11), 'x', 'z'),
                                        ]
                                    ),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[a-cx-z&&\w]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..12),
                                negated: false,
                                kind: intersection(
                                    span(1..11),
                                    union(
                                        span(1..7),
                                        vec![
                                            range(span(1..4), 'a', 'c'),
                                            range(span(4..7), 'x', 'z'),
                                        ]
                                    ),
                                    itemset(item_perl(ast::ClassPerl {
                                        span: span(9..11),
                                        kind: ast::ClassPerlKind::Word,
                                        negated: false,
                                    })),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[a--b--c]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..9),
                                negated: false,
                                kind: difference(
                                    span(1..8),
                                    difference(
                                        span(1..5),
                                        itemset(lit(span(1..2), 'a')),
                                        itemset(lit(span(4..5), 'b')),
                                    ),
                                    itemset(lit(span(7..8), 'c')),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[a~~b~~c]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..9),
                                negated: false,
                                kind: symdifference(
                                    span(1..8),
                                    symdifference(
                                        span(1..5),
                                        itemset(lit(span(1..2), 'a')),
                                        itemset(lit(span(4..5), 'b')),
                                    ),
                                    itemset(lit(span(7..8), 'c')),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[\^&&^]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..7),
                                negated: false,
                                kind: intersection(
                                    span(1..6),
                                    itemset(ast::ClassSetItem::Literal(ast::Literal {
                                        span: span(1..3),
                                        kind: ast::LiteralKind::Meta,
                                        c: '^',
                                    })),
                                    itemset(lit(span(5..6), '^')),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[\&&&&]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..7),
                                negated: false,
                                kind: intersection(
                                    span(1..6),
                                    itemset(ast::ClassSetItem::Literal(ast::Literal {
                                        span: span(1..3),
                                        kind: ast::LiteralKind::Meta,
                                        c: '&',
                                    })),
                                    itemset(lit(span(5..6), '&')),
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[&&&&]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..6),
                                negated: false,
                                kind: intersection(
                                    span(1..5),
                                    intersection(
                                        span(1..3),
                                        itemset(empty(span(1..1))),
                                        itemset(empty(span(3..3))),
                                    ),
                                    itemset(empty(span(5..5))),
                                ),
                            }))
                        );

                        let pat = "[☃-⛄]";
                        assert_eq!(
                            parser(pat).parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span_range(pat, 0..9),
                                negated: false,
                                kind: itemset(ast::ClassSetItem::Range(ast::ClassSetRange {
                                    span: span_range(pat, 1..8),
                                    start: ast::Literal {
                                        span: span_range(pat, 1..4),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '☃',
                                    },
                                    end: ast::Literal {
                                        span: span_range(pat, 5..8),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '⛄',
                                    },
                                })),
                            }))
                        );

                        assert_eq!(
                            parser(r"[]]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..3),
                                negated: false,
                                kind: itemset(lit(span(1..2), ']')),
                            }))
                        );
                        assert_eq!(
                            parser(r"[]\[]").parse(),
                            Ok(Ast::class_bracketed(ast::ClassBracketed {
                                span: span(0..5),
                                negated: false,
                                kind: union(
                                    span(1..4),
                                    vec![
                                        lit(span(1..2), ']'),
                                        ast::ClassSetItem::Literal(ast::Literal {
                                            span: span(2..4),
                                            kind: ast::LiteralKind::Meta,
                                            c: '[',
                                        }),
                                    ]
                                ),
                            }))
                        );
                        assert_eq!(
                            parser(r"[\[]]").parse(),
                            Ok(concat(
                                0..5,
                                vec![
                                    Ast::class_bracketed(ast::ClassBracketed {
                                        span: span(0..4),
                                        negated: false,
                                        kind: itemset(ast::ClassSetItem::Literal(
                                            ast::Literal {
                                                span: span(1..3),
                                                kind: ast::LiteralKind::Meta,
                                                c: '[',
                                            }
                                        )),
                                    }),
                                    Ast::literal(ast::Literal {
                                        span: span(4..5),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: ']',
                                    }),
                                ]
                            ))
                        );

                        assert_eq!(
                            parser("[").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[[").parse().unwrap_err(),
                            TestError {
                                span: span(1..2),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[[-]").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[[[:alnum:]").parse().unwrap_err(),
                            TestError {
                                span: span(1..2),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser(r"[\b]").parse().unwrap_err(),
                            TestError {
                                span: span(1..3),
                                kind: ast::ErrorKind::ClassEscapeInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"[\w-a]").parse().unwrap_err(),
                            TestError {
                                span: span(1..3),
                                kind: ast::ErrorKind::ClassRangeLiteral,
                            }
                        );
                        assert_eq!(
                            parser(r"[a-\w]").parse().unwrap_err(),
                            TestError {
                                span: span(3..5),
                                kind: ast::ErrorKind::ClassRangeLiteral,
                            }
                        );
                        assert_eq!(
                            parser(r"[z-a]").parse().unwrap_err(),
                            TestError {
                                span: span(1..4),
                                kind: ast::ErrorKind::ClassRangeInvalid,
                            }
                        );

                        assert_eq!(
                            parser_ignore_whitespace("[a ").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser_ignore_whitespace("[a- ").parse().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                    }

                    #[test]
                    fn parse_set_class_open() {
                        assert_eq!(parser("[a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..1),
                                negated: false,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(1..1),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion { span: span(1..1), items: vec![] };
                            Ok((set, union))
                        });
                        assert_eq!(
                            parser_ignore_whitespace("[   a]").parse_set_class_open(),
                            {
                                let set = ast::ClassBracketed {
                                    span: span(0..4),
                                    negated: false,
                                    kind: ast::ClassSet::union(ast::ClassSetUnion {
                                        span: span(4..4),
                                        items: vec![],
                                    }),
                                };
                                let union =
                                    ast::ClassSetUnion { span: span(4..4), items: vec![] };
                                Ok((set, union))
                            }
                        );
                        assert_eq!(parser("[^a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..2),
                                negated: true,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(2..2),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion { span: span(2..2), items: vec![] };
                            Ok((set, union))
                        });
                        assert_eq!(
                            parser_ignore_whitespace("[ ^ a]").parse_set_class_open(),
                            {
                                let set = ast::ClassBracketed {
                                    span: span(0..4),
                                    negated: true,
                                    kind: ast::ClassSet::union(ast::ClassSetUnion {
                                        span: span(4..4),
                                        items: vec![],
                                    }),
                                };
                                let union =
                                    ast::ClassSetUnion { span: span(4..4), items: vec![] };
                                Ok((set, union))
                            }
                        );
                        assert_eq!(parser("[-a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..2),
                                negated: false,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(1..1),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion {
                                span: span(1..2),
                                items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                    span: span(1..2),
                                    kind: ast::LiteralKind::Verbatim,
                                    c: '-',
                                })],
                            };
                            Ok((set, union))
                        });
                        assert_eq!(
                            parser_ignore_whitespace("[ - a]").parse_set_class_open(),
                            {
                                let set = ast::ClassBracketed {
                                    span: span(0..4),
                                    negated: false,
                                    kind: ast::ClassSet::union(ast::ClassSetUnion {
                                        span: span(2..2),
                                        items: vec![],
                                    }),
                                };
                                let union = ast::ClassSetUnion {
                                    span: span(2..3),
                                    items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                        span: span(2..3),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '-',
                                    })],
                                };
                                Ok((set, union))
                            }
                        );
                        assert_eq!(parser("[^-a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..3),
                                negated: true,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(2..2),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion {
                                span: span(2..3),
                                items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                    span: span(2..3),
                                    kind: ast::LiteralKind::Verbatim,
                                    c: '-',
                                })],
                            };
                            Ok((set, union))
                        });
                        assert_eq!(parser("[--a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..3),
                                negated: false,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(1..1),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion {
                                span: span(1..3),
                                items: vec![
                                    ast::ClassSetItem::Literal(ast::Literal {
                                        span: span(1..2),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '-',
                                    }),
                                    ast::ClassSetItem::Literal(ast::Literal {
                                        span: span(2..3),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: '-',
                                    }),
                                ],
                            };
                            Ok((set, union))
                        });
                        assert_eq!(parser("[]a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..2),
                                negated: false,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(1..1),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion {
                                span: span(1..2),
                                items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                    span: span(1..2),
                                    kind: ast::LiteralKind::Verbatim,
                                    c: ']',
                                })],
                            };
                            Ok((set, union))
                        });
                        assert_eq!(
                            parser_ignore_whitespace("[ ] a]").parse_set_class_open(),
                            {
                                let set = ast::ClassBracketed {
                                    span: span(0..4),
                                    negated: false,
                                    kind: ast::ClassSet::union(ast::ClassSetUnion {
                                        span: span(2..2),
                                        items: vec![],
                                    }),
                                };
                                let union = ast::ClassSetUnion {
                                    span: span(2..3),
                                    items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                        span: span(2..3),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: ']',
                                    })],
                                };
                                Ok((set, union))
                            }
                        );
                        assert_eq!(parser("[^]a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..3),
                                negated: true,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(2..2),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion {
                                span: span(2..3),
                                items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                    span: span(2..3),
                                    kind: ast::LiteralKind::Verbatim,
                                    c: ']',
                                })],
                            };
                            Ok((set, union))
                        });
                        assert_eq!(parser("[-]a]").parse_set_class_open(), {
                            let set = ast::ClassBracketed {
                                span: span(0..2),
                                negated: false,
                                kind: ast::ClassSet::union(ast::ClassSetUnion {
                                    span: span(1..1),
                                    items: vec![],
                                }),
                            };
                            let union = ast::ClassSetUnion {
                                span: span(1..2),
                                items: vec![ast::ClassSetItem::Literal(ast::Literal {
                                    span: span(1..2),
                                    kind: ast::LiteralKind::Verbatim,
                                    c: '-',
                                })],
                            };
                            Ok((set, union))
                        });

                        assert_eq!(
                            parser("[").parse_set_class_open().unwrap_err(),
                            TestError {
                                span: span(0..1),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser_ignore_whitespace("[    ")
                                .parse_set_class_open()
                                .unwrap_err(),
                            TestError {
                                span: span(0..5),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[^").parse_set_class_open().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[]").parse_set_class_open().unwrap_err(),
                            TestError {
                                span: span(0..2),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[-").parse_set_class_open().unwrap_err(),
                            TestError {
                                span: span(0..0),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                        assert_eq!(
                            parser("[--").parse_set_class_open().unwrap_err(),
                            TestError {
                                span: span(0..0),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );

                        // See: https://github.com/rust-lang/regex/issues/792
                        assert_eq!(
                            parser("(?x)[-#]").parse_with_comments().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::ClassUnclosed,
                            }
                        );
                    }

                    #[test]
                    fn maybe_parse_ascii_class() {
                        assert_eq!(
                            parser(r"[:alnum:]").maybe_parse_ascii_class(),
                            Some(ast::ClassAscii {
                                span: span(0..9),
                                kind: ast::ClassAsciiKind::Alnum,
                                negated: false,
                            })
                        );
                        assert_eq!(
                            parser(r"[:alnum:]A").maybe_parse_ascii_class(),
                            Some(ast::ClassAscii {
                                span: span(0..9),
                                kind: ast::ClassAsciiKind::Alnum,
                                negated: false,
                            })
                        );
                        assert_eq!(
                            parser(r"[:^alnum:]").maybe_parse_ascii_class(),
                            Some(ast::ClassAscii {
                                span: span(0..10),
                                kind: ast::ClassAsciiKind::Alnum,
                                negated: true,
                            })
                        );

                        let p = parser(r"[:");
                        assert_eq!(p.maybe_parse_ascii_class(), None);
                        assert_eq!(p.offset(), 0);

                        let p = parser(r"[:^");
                        assert_eq!(p.maybe_parse_ascii_class(), None);
                        assert_eq!(p.offset(), 0);

                        let p = parser(r"[^:alnum:]");
                        assert_eq!(p.maybe_parse_ascii_class(), None);
                        assert_eq!(p.offset(), 0);

                        let p = parser(r"[:alnnum:]");
                        assert_eq!(p.maybe_parse_ascii_class(), None);
                        assert_eq!(p.offset(), 0);

                        let p = parser(r"[:alnum]");
                        assert_eq!(p.maybe_parse_ascii_class(), None);
                        assert_eq!(p.offset(), 0);

                        let p = parser(r"[:alnum:");
                        assert_eq!(p.maybe_parse_ascii_class(), None);
                        assert_eq!(p.offset(), 0);
                    }

                    #[test]
                    fn parse_unicode_class() {
                        assert_eq!(
                            parser(r"\pN").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..3),
                                negated: false,
                                kind: ast::ClassUnicodeKind::OneLetter('N'),
                            }))
                        );
                        assert_eq!(
                            parser(r"\PN").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..3),
                                negated: true,
                                kind: ast::ClassUnicodeKind::OneLetter('N'),
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{N}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..5),
                                negated: false,
                                kind: ast::ClassUnicodeKind::Named(s("N")),
                            }))
                        );
                        assert_eq!(
                            parser(r"\P{N}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..5),
                                negated: true,
                                kind: ast::ClassUnicodeKind::Named(s("N")),
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{Greek}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..9),
                                negated: false,
                                kind: ast::ClassUnicodeKind::Named(s("Greek")),
                            }))
                        );

                        assert_eq!(
                            parser(r"\p{scx:Katakana}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..16),
                                negated: false,
                                kind: ast::ClassUnicodeKind::NamedValue {
                                    op: ast::ClassUnicodeOpKind::Colon,
                                    name: s("scx"),
                                    value: s("Katakana"),
                                },
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{scx=Katakana}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..16),
                                negated: false,
                                kind: ast::ClassUnicodeKind::NamedValue {
                                    op: ast::ClassUnicodeOpKind::Equal,
                                    name: s("scx"),
                                    value: s("Katakana"),
                                },
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{scx!=Katakana}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..17),
                                negated: false,
                                kind: ast::ClassUnicodeKind::NamedValue {
                                    op: ast::ClassUnicodeOpKind::NotEqual,
                                    name: s("scx"),
                                    value: s("Katakana"),
                                },
                            }))
                        );

                        assert_eq!(
                            parser(r"\p{:}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..5),
                                negated: false,
                                kind: ast::ClassUnicodeKind::NamedValue {
                                    op: ast::ClassUnicodeOpKind::Colon,
                                    name: s(""),
                                    value: s(""),
                                },
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{=}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..5),
                                negated: false,
                                kind: ast::ClassUnicodeKind::NamedValue {
                                    op: ast::ClassUnicodeOpKind::Equal,
                                    name: s(""),
                                    value: s(""),
                                },
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{!=}").parse_escape(),
                            Ok(Primitive::Unicode(ast::ClassUnicode {
                                span: span(0..6),
                                negated: false,
                                kind: ast::ClassUnicodeKind::NamedValue {
                                    op: ast::ClassUnicodeOpKind::NotEqual,
                                    name: s(""),
                                    value: s(""),
                                },
                            }))
                        );

                        assert_eq!(
                            parser(r"\p").parse_escape().unwrap_err(),
                            TestError {
                                span: span(2..2),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\p{").parse_escape().unwrap_err(),
                            TestError {
                                span: span(3..3),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\p{N").parse_escape().unwrap_err(),
                            TestError {
                                span: span(4..4),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );
                        assert_eq!(
                            parser(r"\p{Greek").parse_escape().unwrap_err(),
                            TestError {
                                span: span(8..8),
                                kind: ast::ErrorKind::EscapeUnexpectedEof,
                            }
                        );

                        assert_eq!(
                            parser(r"\pNz").parse(),
                            Ok(Ast::concat(ast::Concat {
                                span: span(0..4),
                                asts: vec![
                                    Ast::class_unicode(ast::ClassUnicode {
                                        span: span(0..3),
                                        negated: false,
                                        kind: ast::ClassUnicodeKind::OneLetter('N'),
                                    }),
                                    Ast::literal(ast::Literal {
                                        span: span(3..4),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: 'z',
                                    }),
                                ],
                            }))
                        );
                        assert_eq!(
                            parser(r"\p{Greek}z").parse(),
                            Ok(Ast::concat(ast::Concat {
                                span: span(0..10),
                                asts: vec![
                                    Ast::class_unicode(ast::ClassUnicode {
                                        span: span(0..9),
                                        negated: false,
                                        kind: ast::ClassUnicodeKind::Named(s("Greek")),
                                    }),
                                    Ast::literal(ast::Literal {
                                        span: span(9..10),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: 'z',
                                    }),
                                ],
                            }))
                        );
                        assert_eq!(
                            parser(r"\p\{").parse().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::UnicodeClassInvalid,
                            }
                        );
                        assert_eq!(
                            parser(r"\P\{").parse().unwrap_err(),
                            TestError {
                                span: span(2..3),
                                kind: ast::ErrorKind::UnicodeClassInvalid,
                            }
                        );
                    }

                    #[test]
                    fn parse_perl_class() {
                        assert_eq!(
                            parser(r"\d").parse_escape(),
                            Ok(Primitive::Perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Digit,
                                negated: false,
                            }))
                        );
                        assert_eq!(
                            parser(r"\D").parse_escape(),
                            Ok(Primitive::Perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Digit,
                                negated: true,
                            }))
                        );
                        assert_eq!(
                            parser(r"\s").parse_escape(),
                            Ok(Primitive::Perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Space,
                                negated: false,
                            }))
                        );
                        assert_eq!(
                            parser(r"\S").parse_escape(),
                            Ok(Primitive::Perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Space,
                                negated: true,
                            }))
                        );
                        assert_eq!(
                            parser(r"\w").parse_escape(),
                            Ok(Primitive::Perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Word,
                                negated: false,
                            }))
                        );
                        assert_eq!(
                            parser(r"\W").parse_escape(),
                            Ok(Primitive::Perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Word,
                                negated: true,
                            }))
                        );

                        assert_eq!(
                            parser(r"\d").parse(),
                            Ok(Ast::class_perl(ast::ClassPerl {
                                span: span(0..2),
                                kind: ast::ClassPerlKind::Digit,
                                negated: false,
                            }))
                        );
                        assert_eq!(
                            parser(r"\dz").parse(),
                            Ok(Ast::concat(ast::Concat {
                                span: span(0..3),
                                asts: vec![
                                    Ast::class_perl(ast::ClassPerl {
                                        span: span(0..2),
                                        kind: ast::ClassPerlKind::Digit,
                                        negated: false,
                                    }),
                                    Ast::literal(ast::Literal {
                                        span: span(2..3),
                                        kind: ast::LiteralKind::Verbatim,
                                        c: 'z',
                                    }),
                                ],
                            }))
                        );
                    }
                    #[test]
                    fn regression_454_nest_too_big() {
                        let pattern = r#"
                        2(?:
                        [45]\d{3}|
                        7(?:
                            1[0-267]|
                            2[0-289]|
                            3[0-29]|
                            4[01]|
                            5[1-3]|
                            6[013]|
                            7[0178]|
                            91
                        )|
                        8(?:
                            0[125]|
                            [139][1-6]|
                            2[0157-9]|
                            41|
                            6[1-35]|
                            7[1-5]|
                            8[1-8]|
                            90
                        )|
                        9(?:
                            0[0-2]|
                            1[0-4]|
                            2[568]|
                            3[3-6]|
                            5[5-7]|
                            6[0167]|
                            7[15]|
                            8[0146-9]
                        )
                        )\d{4}
                        "#;
                        assert!(parser_nest_limit(pattern, 50).parse().is_ok());
                    }
                    #[test]
                    fn regression_455_trailing_dash_ignore_whitespace() {
                        assert!(parser("(?x)[ / - ]").parse().is_ok());
                        assert!(parser("(?x)[ a - ]").parse().is_ok());
                        assert!(parser(
                            "(?x)[
                            a
                            - ]
                        "
                        )
                        .parse()
                        .is_ok());
                        assert!(parser(
                            "(?x)[
                            a # wat
                            - ]
                        "
                        )
                        .parse()
                        .is_ok());

                        assert!(parser("(?x)[ / -").parse().is_err());
                        assert!(parser("(?x)[ / - ").parse().is_err());
                        assert!(parser(
                            "(?x)[
                            / -
                        "
                        )
                        .parse()
                        .is_err());
                        assert!(parser(
                            "(?x)[
                            / - # wat
                        "
                        )
                        .parse()
                        .is_err());
                    }
                }
            }

            pub mod print    
            {
                /*!
                This module provides a regular expression printer for `Ast`. */
                use ::
                {
                    regex::syntax::
                    {
                        ast::
                        {
                            self,
                            visitor::{self, Visitor},
                            Ast,
                        },
                    },
                    *,
                };
                /*
                */
                /// A builder for constructing a printer.
                #[derive(Clone, Debug)]
                struct PrinterBuilder
                {
                    _priv: (),
                }

                impl Default for PrinterBuilder
                {
                    fn default() -> PrinterBuilder {
                        PrinterBuilder::new()
                    }
                }

                impl PrinterBuilder
                {
                    fn new() -> PrinterBuilder {
                        PrinterBuilder { _priv: () }
                    }

                    fn build(&self) -> Printer {
                        Printer { _priv: () }
                    }
                }
                /// A printer for a regular expression abstract syntax tree.
                #[derive(Debug)]
                pub struct Printer
                {
                    _priv: (),
                }

                impl Printer
                {
                    /// Create a new printer.
                    pub fn new() -> Printer {
                        PrinterBuilder::new().build()
                    }
                    /// Print the given `Ast` to the given writer. The writer must implement
                    pub fn print<W: fmt::Write>(&mut self, ast: &Ast, wtr: W) -> fmt::Result {
                        visitor::visit(ast, Writer { wtr })
                    }
                }

                #[derive(Debug)]
                struct Writer<W>
                {
                    wtr: W,
                }

                impl<W: fmt::Write> Visitor for Writer<W>
                {
                    type Output = ();
                    type Err = fmt::Error;

                    fn finish(self) -> fmt::Result {
                        Ok(())
                    }

                    fn visit_pre(&mut self, ast: &Ast) -> fmt::Result {
                        match *ast {
                            Ast::Group(ref x) => self.fmt_group_pre(x),
                            Ast::ClassBracketed(ref x) => self.fmt_class_bracketed_pre(x),
                            _ => Ok(()),
                        }
                    }

                    fn visit_post(&mut self, ast: &Ast) -> fmt::Result {
                        match *ast {
                            Ast::Empty(_) => Ok(()),
                            Ast::Flags(ref x) => self.fmt_set_flags(x),
                            Ast::Literal(ref x) => self.fmt_literal(x),
                            Ast::Dot(_) => self.wtr.write_str("."),
                            Ast::Assertion(ref x) => self.fmt_assertion(x),
                            Ast::ClassPerl(ref x) => self.fmt_class_perl(x),
                            Ast::ClassUnicode(ref x) => self.fmt_class_unicode(x),
                            Ast::ClassBracketed(ref x) => self.fmt_class_bracketed_post(x),
                            Ast::Repetition(ref x) => self.fmt_repetition(x),
                            Ast::Group(ref x) => self.fmt_group_post(x),
                            Ast::Alternation(_) => Ok(()),
                            Ast::Concat(_) => Ok(()),
                        }
                    }

                    fn visit_alternation_in(&mut self) -> fmt::Result {
                        self.wtr.write_str("|")
                    }

                    fn visit_class_set_item_pre
                    (
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> {
                        match *ast {
                            ast::ClassSetItem::Bracketed(ref x) => {
                                self.fmt_class_bracketed_pre(x)
                            }
                            _ => Ok(()),
                        }
                    }

                    fn visit_class_set_item_post
                    (
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> {
                        use ::regex::syntax::ast::ClassSetItem::*;

                        match *ast {
                            Empty(_) => Ok(()),
                            Literal(ref x) => self.fmt_literal(x),
                            Range(ref x) => {
                                self.fmt_literal(&x.start)?;
                                self.wtr.write_str("-")?;
                                self.fmt_literal(&x.end)?;
                                Ok(())
                            }
                            Ascii(ref x) => self.fmt_class_ascii(x),
                            Unicode(ref x) => self.fmt_class_unicode(x),
                            Perl(ref x) => self.fmt_class_perl(x),
                            Bracketed(ref x) => self.fmt_class_bracketed_post(x),
                            Union(_) => Ok(()),
                        }
                    }

                    fn visit_class_set_binary_op_in
                    (
                        &mut self,
                        ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> {
                        self.fmt_class_set_binary_op_kind(&ast.kind)
                    }
                }

                impl<W: fmt::Write> Writer<W>
                {
                    fn fmt_group_pre(&mut self, ast: &ast::Group) -> fmt::Result {
                        use ::regex::syntax::ast::GroupKind::*;
                        match ast.kind {
                            CaptureIndex(_) => self.wtr.write_str("("),
                            CaptureName { ref name, starts_with_p } => {
                                let start = if starts_with_p { "(?P<" } else { "(?<" };
                                self.wtr.write_str(start)?;
                                self.wtr.write_str(&name.name)?;
                                self.wtr.write_str(">")?;
                                Ok(())
                            }
                            NonCapturing(ref flags) => {
                                self.wtr.write_str("(?")?;
                                self.fmt_flags(flags)?;
                                self.wtr.write_str(":")?;
                                Ok(())
                            }
                        }
                    }

                    fn fmt_group_post(&mut self, _ast: &ast::Group) -> fmt::Result {
                        self.wtr.write_str(")")
                    }

                    fn fmt_repetition(&mut self, ast: &ast::Repetition) -> fmt::Result {
                        use ::regex::syntax::ast::RepetitionKind::*;
                        match ast.op.kind {
                            ZeroOrOne if ast.greedy => self.wtr.write_str("?"),
                            ZeroOrOne => self.wtr.write_str("??"),
                            ZeroOrMore if ast.greedy => self.wtr.write_str("*"),
                            ZeroOrMore => self.wtr.write_str("*?"),
                            OneOrMore if ast.greedy => self.wtr.write_str("+"),
                            OneOrMore => self.wtr.write_str("+?"),
                            Range(ref x) => {
                                self.fmt_repetition_range(x)?;
                                
                                if !ast.greedy {
                                    self.wtr.write_str("?")?;
                                }
                                Ok(())
                            }
                        }
                    }

                    fn fmt_repetition_range
                    (
                        &mut self,
                        ast: &ast::RepetitionRange,
                    ) -> fmt::Result {
                        use ::regex::syntax::ast::RepetitionRange::*;
                        match *ast {
                            Exactly(x) => write!(self.wtr, "{{{}}}", x),
                            AtLeast(x) => write!(self.wtr, "{{{},}}", x),
                            Bounded(x, y) => write!(self.wtr, "{{{},{}}}", x, y),
                        }
                    }

                    fn fmt_literal(&mut self, ast: &ast::Literal) -> fmt::Result {
                        use ::regex::syntax::ast::LiteralKind::*;

                        match ast.kind {
                            Verbatim => self.wtr.write_char(ast.c),
                            Meta | Superfluous => write!(self.wtr, r"\{}", ast.c),
                            Octal => write!(self.wtr, r"\{:o}", u32::from(ast.c)),
                            HexFixed(ast::HexLiteralKind::X) => {
                                write!(self.wtr, r"\x{:02X}", u32::from(ast.c))
                            }
                            HexFixed(ast::HexLiteralKind::UnicodeShort) => {
                                write!(self.wtr, r"\u{:04X}", u32::from(ast.c))
                            }
                            HexFixed(ast::HexLiteralKind::UnicodeLong) => {
                                write!(self.wtr, r"\U{:08X}", u32::from(ast.c))
                            }
                            HexBrace(ast::HexLiteralKind::X) => {
                                write!(self.wtr, r"\x{{{:X}}}", u32::from(ast.c))
                            }
                            HexBrace(ast::HexLiteralKind::UnicodeShort) => {
                                write!(self.wtr, r"\u{{{:X}}}", u32::from(ast.c))
                            }
                            HexBrace(ast::HexLiteralKind::UnicodeLong) => {
                                write!(self.wtr, r"\U{{{:X}}}", u32::from(ast.c))
                            }
                            Special(ast::SpecialLiteralKind::Bell) => {
                                self.wtr.write_str(r"\a")
                            }
                            Special(ast::SpecialLiteralKind::FormFeed) => {
                                self.wtr.write_str(r"\f")
                            }
                            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r"\t"),
                            Special(ast::SpecialLiteralKind::LineFeed) => {
                                self.wtr.write_str(r"\n")
                            }
                            Special(ast::SpecialLiteralKind::CarriageReturn) => {
                                self.wtr.write_str(r"\r")
                            }
                            Special(ast::SpecialLiteralKind::VerticalTab) => {
                                self.wtr.write_str(r"\v")
                            }
                            Special(ast::SpecialLiteralKind::Space) => {
                                self.wtr.write_str(r"\ ")
                            }
                        }
                    }

                    fn fmt_assertion(&mut self, ast: &ast::Assertion) -> fmt::Result {
                        use ::regex::syntax::ast::AssertionKind::*;
                        match ast.kind {
                            StartLine => self.wtr.write_str("^"),
                            EndLine => self.wtr.write_str("$"),
                            StartText => self.wtr.write_str(r"\A"),
                            EndText => self.wtr.write_str(r"\z"),
                            WordBoundary => self.wtr.write_str(r"\b"),
                            NotWordBoundary => self.wtr.write_str(r"\B"),
                            WordBoundaryStart => self.wtr.write_str(r"\b{start}"),
                            WordBoundaryEnd => self.wtr.write_str(r"\b{end}"),
                            WordBoundaryStartAngle => self.wtr.write_str(r"\<"),
                            WordBoundaryEndAngle => self.wtr.write_str(r"\>"),
                            WordBoundaryStartHalf => self.wtr.write_str(r"\b{start-half}"),
                            WordBoundaryEndHalf => self.wtr.write_str(r"\b{end-half}"),
                        }
                    }

                    fn fmt_set_flags(&mut self, ast: &ast::SetFlags) -> fmt::Result {
                        self.wtr.write_str("(?")?;
                        self.fmt_flags(&ast.flags)?;
                        self.wtr.write_str(")")?;
                        Ok(())
                    }

                    fn fmt_flags(&mut self, ast: &ast::Flags) -> fmt::Result {
                        use ::regex::syntax::ast::{Flag, FlagsItemKind};

                        for item in &ast.items {
                            match item.kind {
                                FlagsItemKind::Negation => self.wtr.write_str("-"),
                                FlagsItemKind::Flag(ref flag) => match *flag {
                                    Flag::CaseInsensitive => self.wtr.write_str("i"),
                                    Flag::MultiLine => self.wtr.write_str("m"),
                                    Flag::DotMatchesNewLine => self.wtr.write_str("s"),
                                    Flag::SwapGreed => self.wtr.write_str("U"),
                                    Flag::Unicode => self.wtr.write_str("u"),
                                    Flag::CRLF => self.wtr.write_str("R"),
                                    Flag::IgnoreWhitespace => self.wtr.write_str("x"),
                                },
                            }?;
                        }
                        Ok(())
                    }

                    fn fmt_class_bracketed_pre
                    (
                        &mut self,
                        ast: &ast::ClassBracketed,
                    ) -> fmt::Result {
                        if ast.negated {
                            self.wtr.write_str("[^")
                        } else {
                            self.wtr.write_str("[")
                        }
                    }

                    fn fmt_class_bracketed_post
                    (
                        &mut self,
                        _ast: &ast::ClassBracketed,
                    ) -> fmt::Result {
                        self.wtr.write_str("]")
                    }

                    fn fmt_class_set_binary_op_kind
                    (
                        &mut self,
                        ast: &ast::ClassSetBinaryOpKind,
                    ) -> fmt::Result {
                        use ::regex::syntax::ast::ClassSetBinaryOpKind::*;
                        match *ast {
                            Intersection => self.wtr.write_str("&&"),
                            Difference => self.wtr.write_str("--"),
                            SymmetricDifference => self.wtr.write_str("~~"),
                        }
                    }

                    fn fmt_class_perl(&mut self, ast: &ast::ClassPerl) -> fmt::Result {
                        use ::regex::syntax::ast::ClassPerlKind::*;
                        match ast.kind {
                            Digit if ast.negated => self.wtr.write_str(r"\D"),
                            Digit => self.wtr.write_str(r"\d"),
                            Space if ast.negated => self.wtr.write_str(r"\S"),
                            Space => self.wtr.write_str(r"\s"),
                            Word if ast.negated => self.wtr.write_str(r"\W"),
                            Word => self.wtr.write_str(r"\w"),
                        }
                    }

                    fn fmt_class_ascii(&mut self, ast: &ast::ClassAscii) -> fmt::Result 
                    {
                        use ::regex::syntax::ast::ClassAsciiKind::*;
                        match ast.kind 
                        {
                            Alnum if ast.negated => self.wtr.write_str("[:^alnum:]"),
                            Alnum => self.wtr.write_str("[:alnum:]"),
                            Alpha if ast.negated => self.wtr.write_str("[:^alpha:]"),
                            Alpha => self.wtr.write_str("[:alpha:]"),
                            Ascii if ast.negated => self.wtr.write_str("[:^ascii:]"),
                            Ascii => self.wtr.write_str("[:ascii:]"),
                            Blank if ast.negated => self.wtr.write_str("[:^blank:]"),
                            Blank => self.wtr.write_str("[:blank:]"),
                            Cntrl if ast.negated => self.wtr.write_str("[:^cntrl:]"),
                            Cntrl => self.wtr.write_str("[:cntrl:]"),
                            Digit if ast.negated => self.wtr.write_str("[:^digit:]"),
                            Digit => self.wtr.write_str("[:digit:]"),
                            Graph if ast.negated => self.wtr.write_str("[:^graph:]"),
                            Graph => self.wtr.write_str("[:graph:]"),
                            Lower if ast.negated => self.wtr.write_str("[:^lower:]"),
                            Lower => self.wtr.write_str("[:lower:]"),
                            Print if ast.negated => self.wtr.write_str("[:^print:]"),
                            Print => self.wtr.write_str("[:print:]"),
                            Punct if ast.negated => self.wtr.write_str("[:^punct:]"),
                            Punct => self.wtr.write_str("[:punct:]"),
                            Space if ast.negated => self.wtr.write_str("[:^space:]"),
                            Space => self.wtr.write_str("[:space:]"),
                            Upper if ast.negated => self.wtr.write_str("[:^upper:]"),
                            Upper => self.wtr.write_str("[:upper:]"),
                            Word if ast.negated => self.wtr.write_str("[:^word:]"),
                            Word => self.wtr.write_str("[:word:]"),
                            Xdigit if ast.negated => self.wtr.write_str("[:^xdigit:]"),
                            Xdigit => self.wtr.write_str("[:xdigit:]"),
                        }
                    }

                    fn fmt_class_unicode(&mut self, ast: &ast::ClassUnicode) -> fmt::Result 
                    {
                        use ::regex::syntax::ast::ClassUnicodeKind::*;
                        use ::regex::syntax::ast::ClassUnicodeOpKind::*;

                        if ast.negated { self.wtr.write_str(r"\P")?; }
                        else { self.wtr.write_str(r"\p")?; }

                        match ast.kind
                        {
                            OneLetter(c) => self.wtr.write_char(c),
                            Named(ref x) => write!(self.wtr, "{{{}}}", x),
                            NamedValue { op: Equal, ref name, ref value } =>
                            { write!(self.wtr, "{{{}={}}}", name, value) }

                            NamedValue { op: Colon, ref name, ref value } =>
                            { write!(self.wtr, "{{{}:{}}}", name, value) }
                            
                            NamedValue { op: NotEqual, ref name, ref value } =>
                            { write!(self.wtr, "{{{}!={}}}", name, value) }
                        }
                    }
                }
            }

            pub mod visitor    
            {
                /*!
                */
                use ::
                {
                    regex::syntax::{ ast::{ self, Ast }, },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                /// A trait for visiting an abstract syntax tree (AST) in depth first order.
                pub trait Visitor
                {
                    /// The result of visiting an AST.
                    type Output;
                    /// An error that visiting an AST might return.
                    type Err;
                    /// All implementors of `Visitor` must provide a `finish` method, which
                    fn finish(self) -> Result<Self::Output, Self::Err>;
                    /// This method is called before beginning traversal of the AST.
                    fn start(&mut self) {}
                    /// This method is called on an `Ast` before descending into child `Ast`
                    fn visit_pre(&mut self, _ast: &Ast) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called on an `Ast` after descending all of its child
                    fn visit_post(&mut self, _ast: &Ast) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called between child nodes of an
                    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called between child nodes of a concatenation.
                    fn visit_concat_in(&mut self) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called on every [`ClassSetItem`](ast::ClassSetItem)
                    fn visit_class_set_item_pre
                    (
                        &mut self,
                        _ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called on every [`ClassSetItem`](ast::ClassSetItem)
                    fn visit_class_set_item_post
                    (
                        &mut self,
                        _ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called on every
                    fn visit_class_set_binary_op_pre
                    (
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called on every
                    fn visit_class_set_binary_op_post
                    (
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called between the left hand and right hand child nodes
                    fn visit_class_set_binary_op_in
                    (
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { Ok(()) }
                }
                /// Executes an implementation of `Visitor` in constant stack space.
                pub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> {
                    HeapVisitor::new().visit(ast, visitor)
                }
                /// HeapVisitor visits every item in an `Ast` recursively using constant stack
                struct HeapVisitor<'a>
                {
                    /// A stack of `Ast` nodes. This is roughly analogous to the call stack
                    stack: Vec<(&'a Ast, Frame<'a>)>,
                    /// Similar to the `Ast` stack above, but is used only for character
                    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,
                }
                /// Represents a single stack frame while performing structural induction over
                enum Frame<'a>
                {
                    /// A stack frame allocated just before descending into a repetition
                    Repetition(&'a ast::Repetition),
                    /// A stack frame allocated just before descending into a group's child
                    Group(&'a ast::Group),
                    /// The stack frame used while visiting every child node of a concatenation
                    Concat {
                        /// The child node we are currently visiting.
                        head: &'a Ast,
                        /// The remaining child nodes to visit (which may be empty).
                        tail: &'a [Ast],
                    },
                    /// The stack frame used while visiting every child node of an alternation
                    Alternation {
                        /// The child node we are currently visiting.
                        head: &'a Ast,
                        /// The remaining child nodes to visit (which may be empty).
                        tail: &'a [Ast],
                    },
                }
                /// Represents a single stack frame while performing structural induction over
                enum ClassFrame<'a>
                {
                    /// The stack frame used while visiting every child node of a union of
                    Union {
                        /// The child node we are currently visiting.
                        head: &'a ast::ClassSetItem,
                        /// The remaining child nodes to visit (which may be empty).
                        tail: &'a [ast::ClassSetItem],
                    },
                    /// The stack frame used while a binary class operation.
                    Binary { op: &'a ast::ClassSetBinaryOp },
                    /// A stack frame allocated just before descending into a binary operator's
                    BinaryLHS {
                        op: &'a ast::ClassSetBinaryOp,
                        lhs: &'a ast::ClassSet,
                        rhs: &'a ast::ClassSet,
                    },
                    /// A stack frame allocated just before descending into a binary operator's
                    BinaryRHS { op: &'a ast::ClassSetBinaryOp, rhs: &'a ast::ClassSet },
                }
                /// A representation of the inductive step when performing structural induction
                enum ClassInduct<'a> {
                    Item(&'a ast::ClassSetItem),
                    BinaryOp(&'a ast::ClassSetBinaryOp),
                }

                impl<'a> HeapVisitor<'a> {
                    fn new() -> HeapVisitor<'a> {
                        HeapVisitor { stack: vec![], stack_class: vec![] }
                    }

                    fn visit<V: Visitor>
                    (
                        &mut self,
                        mut ast: &'a Ast,
                        mut visitor: V,
                    ) -> Result<V::Output, V::Err> {
                        self.stack.clear();
                        self.stack_class.clear();

                        visitor.start();

                        loop
                        {
                            visitor.visit_pre(ast)?;
                            if let Some(x) = self.induct(ast, &mut visitor)? {
                                let child = x.child();
                                self.stack.push((ast, x));
                                ast = child;
                                continue;
                            }
                            visitor.visit_post(ast)?;
                            loop {
                                let (post_ast, frame) = match self.stack.pop() {
                                    None => return visitor.finish(),
                                    Some((post_ast, frame)) => (post_ast, frame),
                                };
                                
                                if let Some(x) = self.pop(frame) {
                                    match x {
                                        Frame::Alternation { .. } => {
                                            visitor.visit_alternation_in()?;
                                        }
                                        Frame::Concat { .. } => {
                                            visitor.visit_concat_in()?;
                                        }
                                        _ => {}
                                    }
                                    ast = x.child();
                                    self.stack.push((post_ast, x));
                                    break;
                                }
                                visitor.visit_post(post_ast)?;
                            }
                        }
                    }
                    /// Build a stack frame for the given AST if one is needed (which occurs if
                    fn induct<V: Visitor>
                    (
                        &mut self,
                        ast: &'a Ast,
                        visitor: &mut V,
                    ) -> Result<Option<Frame<'a>>, V::Err> {
                        Ok(match *ast {
                            Ast::ClassBracketed(ref x) => {
                                self.visit_class(x, visitor)?;
                                None
                            }
                            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),
                            Ast::Group(ref x) => Some(Frame::Group(x)),
                            Ast::Concat(ref x) if x.asts.is_empty() => None,
                            Ast::Concat(ref x) => {
                                Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })
                            }
                            Ast::Alternation(ref x) if x.asts.is_empty() => None,
                            Ast::Alternation(ref x) => Some(Frame::Alternation {
                                head: &x.asts[0],
                                tail: &x.asts[1..],
                            }),
                            _ => None,
                        })
                    }
                    /// Pops the given frame. If the frame has an additional inductive step,
                    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {
                        match induct {
                            Frame::Repetition(_) => None,
                            Frame::Group(_) => None,
                            Frame::Concat { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })
                                }
                            }
                            Frame::Alternation { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Alternation {
                                        head: &tail[0],
                                        tail: &tail[1..],
                                    })
                                }
                            }
                        }
                    }

                    fn visit_class<V: Visitor>
                    (
                        &mut self,
                        ast: &'a ast::ClassBracketed,
                        visitor: &mut V,
                    ) -> Result<(), V::Err> {
                        let mut ast = ClassInduct::from_bracketed(ast);

                        loop
                        {
                            self.visit_class_pre(&ast, visitor)?;
                            if let Some(x) = self.induct_class(&ast) {
                                let child = x.child();
                                self.stack_class.push((ast, x));
                                ast = child;
                                continue;
                            }
                            self.visit_class_post(&ast, visitor)?;
                            loop {
                                let (post_ast, frame) = match self.stack_class.pop() {
                                    None => return Ok(()),
                                    Some((post_ast, frame)) => (post_ast, frame),
                                };
                                
                                if let Some(x) = self.pop_class(frame) {
                                    if let ClassFrame::BinaryRHS { ref op, .. } = x {
                                        visitor.visit_class_set_binary_op_in(op)?;
                                    }
                                    ast = x.child();
                                    self.stack_class.push((post_ast, x));
                                    break;
                                }
                                self.visit_class_post(&post_ast, visitor)?;
                            }
                        }
                    }
                    /// Call the appropriate `Visitor` methods given an inductive step.
                    fn visit_class_pre<V: Visitor>(
                        &self,
                        ast: &ClassInduct<'a>,
                        visitor: &mut V,
                    ) -> Result<(), V::Err> {
                        match *ast {
                            ClassInduct::Item(item) => {
                                visitor.visit_class_set_item_pre(item)?;
                            }
                            ClassInduct::BinaryOp(op) => {
                                visitor.visit_class_set_binary_op_pre(op)?;
                            }
                        }
                        Ok(())
                    }
                    /// Call the appropriate `Visitor` methods given an inductive step.
                    fn visit_class_post<V: Visitor>(
                        &self,
                        ast: &ClassInduct<'a>,
                        visitor: &mut V,
                    ) -> Result<(), V::Err> {
                        match *ast {
                            ClassInduct::Item(item) => {
                                visitor.visit_class_set_item_post(item)?;
                            }
                            ClassInduct::BinaryOp(op) => {
                                visitor.visit_class_set_binary_op_post(op)?;
                            }
                        }
                        Ok(())
                    }
                    /// Build a stack frame for the given class node if one is needed (which
                    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {
                        match *ast {
                            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {
                                match x.kind {
                                    ast::ClassSet::Item(ref item) => {
                                        Some(ClassFrame::Union { head: item, tail: &[] })
                                    }
                                    ast::ClassSet::BinaryOp(ref op) => {
                                        Some(ClassFrame::Binary { op })
                                    }
                                }
                            }
                            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {
                                if x.items.is_empty() {
                                    None
                                } else {
                                    Some(ClassFrame::Union {
                                        head: &x.items[0],
                                        tail: &x.items[1..],
                                    })
                                }
                            }
                            ClassInduct::BinaryOp(op) => {
                                Some(ClassFrame::BinaryLHS { op, lhs: &op.lhs, rhs: &op.rhs })
                            }
                            _ => None,
                        }
                    }
                    /// Pops the given frame. If the frame has an additional inductive step,
                    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {
                        match induct {
                            ClassFrame::Union { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(ClassFrame::Union {
                                        head: &tail[0],
                                        tail: &tail[1..],
                                    })
                                }
                            }
                            ClassFrame::Binary { .. } => None,
                            ClassFrame::BinaryLHS { op, rhs, .. } => {
                                Some(ClassFrame::BinaryRHS { op, rhs })
                            }
                            ClassFrame::BinaryRHS { .. } => None,
                        }
                    }
                }

                impl<'a> Frame<'a>
                {
                    /// Perform the next inductive step on this frame and return the next
                    fn child(&self) -> &'a Ast {
                        match *self {
                            Frame::Repetition(rep) => &rep.ast,
                            Frame::Group(group) => &group.ast,
                            Frame::Concat { head, .. } => head,
                            Frame::Alternation { head, .. } => head,
                        }
                    }
                }

                impl<'a> ClassFrame<'a>
                {
                    /// Perform the next inductive step on this frame and return the next
                    fn child(&self) -> ClassInduct<'a> {
                        match *self {
                            ClassFrame::Union { head, .. } => ClassInduct::Item(head),
                            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),
                            ClassFrame::BinaryLHS { ref lhs, .. } => {
                                ClassInduct::from_set(lhs)
                            }
                            ClassFrame::BinaryRHS { ref rhs, .. } => {
                                ClassInduct::from_set(rhs)
                            }
                        }
                    }
                }

                impl<'a> ClassInduct<'a> {
                    fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> {
                        ClassInduct::from_set(&ast.kind)
                    }

                    fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {
                        match *ast {
                            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),
                            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),
                        }
                    }
                }

                impl<'a> ::fmt::Debug for ClassFrame<'a> {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        let x = match *self {
                            ClassFrame::Union { .. } => "Union",
                            ClassFrame::Binary { .. } => "Binary",
                            ClassFrame::BinaryLHS { .. } => "BinaryLHS",
                            ClassFrame::BinaryRHS { .. } => "BinaryRHS",
                        };
                        write!(f, "{}", x)
                    }
                }

                impl<'a> ::fmt::Debug for ClassInduct<'a> {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        let x = match *self {
                            ClassInduct::Item(it) => match *it {
                                ast::ClassSetItem::Empty(_) => "Item(Empty)",
                                ast::ClassSetItem::Literal(_) => "Item(Literal)",
                                ast::ClassSetItem::Range(_) => "Item(Range)",
                                ast::ClassSetItem::Ascii(_) => "Item(Ascii)",
                                ast::ClassSetItem::Perl(_) => "Item(Perl)",
                                ast::ClassSetItem::Unicode(_) => "Item(Unicode)",
                                ast::ClassSetItem::Bracketed(_) => "Item(Bracketed)",
                                ast::ClassSetItem::Union(_) => "Item(Union)",
                            },
                            ClassInduct::BinaryOp(it) => match it.kind {
                                ast::ClassSetBinaryOpKind::Intersection => {
                                    "BinaryOp(Intersection)"
                                }
                                ast::ClassSetBinaryOpKind::Difference => {
                                    "BinaryOp(Difference)"
                                }
                                ast::ClassSetBinaryOpKind::SymmetricDifference => {
                                    "BinaryOp(SymmetricDifference)"
                                }
                            },
                        };
                        write!(f, "{}", x)
                    }
                }
            }
            /// An error that occurred while parsing a regular expression into an abstract
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Error
            {
                /// The kind of error.
                kind: ErrorKind,
                /// The original pattern that the parser generated the error from. Every
                pattern: String,
                /// The span of this error.
                span: Span,
            }

            impl Error
            {
                /// Return the type of this error.
                pub fn kind(&self) -> &ErrorKind {
                    &self.kind
                }
                /// The original pattern string in which this error occurred.
                pub fn pattern(&self) -> &str {
                    &self.pattern
                }
                /// Return the span at which this error occurred.
                pub fn span(&self) -> &Span {
                    &self.span
                }
                /// Return an auxiliary span. This span exists only for some errors that
                pub fn auxiliary_span(&self) -> Option<&Span> {
                    use self::ErrorKind::*;
                    match self.kind {
                        FlagDuplicate { ref original } => Some(original),
                        FlagRepeatedNegation { ref original, .. } => Some(original),
                        GroupNameDuplicate { ref original, .. } => Some(original),
                        _ => None,
                    }
                }
            }
            /// The type of an error that occurred while building an AST.
            #[non_exhaustive]
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ErrorKind
            {
                /// The capturing group limit was exceeded.
                CaptureLimitExceeded,
                /// An invalid escape sequence was found in a character class set.
                ClassEscapeInvalid,
                /// An invalid character class range was found. An invalid range is any
                ClassRangeInvalid,
                /// An invalid range boundary was found in a character class. Range
                ClassRangeLiteral,
                /// An opening `[` was found with no corresponding closing `]`.
                ClassUnclosed,
                /// Note that this error variant is no longer used. Namely, a decimal
                DecimalEmpty,
                /// An invalid decimal number was given where one was expected.
                DecimalInvalid,
                /// A bracketed hex literal was empty.
                EscapeHexEmpty,
                /// A bracketed hex literal did not correspond to a Unicode scalar value.
                EscapeHexInvalid,
                /// An invalid hexadecimal digit was found.
                EscapeHexInvalidDigit,
                /// EOF was found before an escape sequence was completed.
                EscapeUnexpectedEof,
                /// An unrecognized escape sequence.
                EscapeUnrecognized,
                /// A dangling negation was used when setting flags, e.g., `i-`.
                FlagDanglingNegation,
                /// A flag was used twice, e.g., `i-i`.
                FlagDuplicate
                {
                    /// The position of the original flag. The error position
                    original: Span,
                },
                /// The negation operator was used twice, e.g., `-i-s`.
                FlagRepeatedNegation
                {
                    /// The position of the original negation operator. The error position
                    original: Span,
                },
                /// Expected a flag but got EOF, e.g., `(?`.
                FlagUnexpectedEof,
                /// Unrecognized flag, e.g., `a`.
                FlagUnrecognized,
                /// A duplicate capture name was found.
                GroupNameDuplicate
                {
                    /// The position of the initial occurrence of the capture name. The
                    original: Span,
                },
                /// A capture group name is empty, e.g., `(?P<>abc)`.
                GroupNameEmpty,
                /// An invalid character was seen for a capture group name. This includes
                GroupNameInvalid,
                /// A closing `>` could not be found for a capture group name.
                GroupNameUnexpectedEof,
                /// An unclosed group, e.g., `(ab`.
                GroupUnclosed,
                /// An unopened group, e.g., `ab)`.
                GroupUnopened,
                /// The nest limit was exceeded. The limit stored here is the limit
                NestLimitExceeded(u32),
                /// The range provided in a counted repetition operator is invalid. The
                RepetitionCountInvalid,
                /// An opening `{` was not followed by a valid decimal value.
                RepetitionCountDecimalEmpty,
                /// An opening `{` was found with no corresponding closing `}`.
                RepetitionCountUnclosed,
                /// A repetition operator was applied to a missing sub-expression. This
                RepetitionMissing,
                /// The special word boundary syntax, `\b{something}`, was used, but
                SpecialWordBoundaryUnclosed,
                /// The special word boundary syntax, `\b{something}`, was used, but
                SpecialWordBoundaryUnrecognized,
                /// The syntax `\b{` was observed, but afterwards the end of the pattern
                SpecialWordOrRepetitionUnexpectedEof,
                /// The Unicode class is not valid. This typically occurs when a `\p` is
                UnicodeClassInvalid,
                /// When octal support is disabled, this error is produced when an octal
                UnsupportedBackreference,
                /// When syntax similar to PCRE's look-around is used, this error is
                UnsupportedLookAround,
            }
            
            impl ::error::Error for Error {}

            impl ::fmt::Display for Error
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    crate::error::Formatter::from(self).fmt(f)
                }
            }

            impl ::fmt::Display for ErrorKind
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    use self::ErrorKind::*;
                    match *self {
                        CaptureLimitExceeded => write!(
                            f,
                            "exceeded the maximum number of \
                            capturing groups ({})",
                            u32::MAX
                        ),
                        ClassEscapeInvalid => {
                            write!(f, "invalid escape sequence found in character class")
                        }
                        ClassRangeInvalid => write!(
                            f,
                            "invalid character class range, \
                            the start must be <= the end"
                        ),
                        ClassRangeLiteral => {
                            write!(f, "invalid range boundary, must be a literal")
                        }
                        ClassUnclosed => write!(f, "unclosed character class"),
                        DecimalEmpty => write!(f, "decimal literal empty"),
                        DecimalInvalid => write!(f, "decimal literal invalid"),
                        EscapeHexEmpty => write!(f, "hexadecimal literal empty"),
                        EscapeHexInvalid => {
                            write!(f, "hexadecimal literal is not a Unicode scalar value")
                        }
                        EscapeHexInvalidDigit => write!(f, "invalid hexadecimal digit"),
                        EscapeUnexpectedEof => write!(
                            f,
                            "incomplete escape sequence, \
                            reached end of pattern prematurely"
                        ),
                        EscapeUnrecognized => write!(f, "unrecognized escape sequence"),
                        FlagDanglingNegation => {
                            write!(f, "dangling flag negation operator")
                        }
                        FlagDuplicate { .. } => write!(f, "duplicate flag"),
                        FlagRepeatedNegation { .. } => {
                            write!(f, "flag negation operator repeated")
                        }
                        FlagUnexpectedEof => {
                            write!(f, "expected flag but got end of regex")
                        }
                        FlagUnrecognized => write!(f, "unrecognized flag"),
                        GroupNameDuplicate { .. } => {
                            write!(f, "duplicate capture group name")
                        }
                        GroupNameEmpty => write!(f, "empty capture group name"),
                        GroupNameInvalid => write!(f, "invalid capture group character"),
                        GroupNameUnexpectedEof => write!(f, "unclosed capture group name"),
                        GroupUnclosed => write!(f, "unclosed group"),
                        GroupUnopened => write!(f, "unopened group"),
                        NestLimitExceeded(limit) => write!(
                            f,
                            "exceed the maximum number of \
                            nested parentheses/brackets ({})",
                            limit
                        ),
                        RepetitionCountInvalid => write!(
                            f,
                            "invalid repetition count range, \
                            the start must be <= the end"
                        ),
                        RepetitionCountDecimalEmpty => {
                            write!(f, "repetition quantifier expects a valid decimal")
                        }
                        RepetitionCountUnclosed => {
                            write!(f, "unclosed counted repetition")
                        }
                        RepetitionMissing => {
                            write!(f, "repetition operator missing expression")
                        }
                        SpecialWordBoundaryUnclosed => {
                            write!(
                                f,
                                "special word boundary assertion is either \
                                unclosed or contains an invalid character",
                            )
                        }
                        SpecialWordBoundaryUnrecognized => {
                            write!(
                                f,
                                "unrecognized special word boundary assertion, \
                                valid choices are: start, end, start-half \
                                or end-half",
                            )
                        }
                        SpecialWordOrRepetitionUnexpectedEof => {
                            write!(
                                f,
                                "found either the beginning of a special word \
                                boundary or a bounded repetition on a \\b with \
                                an opening brace, but no closing brace",
                            )
                        }
                        UnicodeClassInvalid => {
                            write!(f, "invalid Unicode character class")
                        }
                        UnsupportedBackreference => {
                            write!(f, "backreferences are not supported")
                        }
                        UnsupportedLookAround => write!(
                            f,
                            "look-around, including look-ahead and look-behind, \
                            is not supported"
                        ),
                    }
                }
            }
            /// Span represents the position information of a single AST item.
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub struct Span
            {
                /// The start byte offset.
                pub start: Position,
                /// The end byte offset.
                pub end: Position,
            }

            impl ::fmt::Debug for Span
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "Span({:?}, {:?})", self.start, self.end)
                }
            }

            impl Ord for Span
            {
                fn cmp(&self, other: &Span) -> Ordering {
                    (&self.start, &self.end).cmp(&(&other.start, &other.end))
                }
            }

            impl PartialOrd for Span
            {
                fn partial_cmp(&self, other: &Span) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }
            /// A single position in a regular expression.
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub struct Position
            {
                /// The absolute offset of this position, starting at `0` from the
                pub offset: usize,
                /// The line number, starting at `1`.
                pub line: usize,
                /// The approximate column number, starting at `1`.
                pub column: usize,
            }

            impl ::fmt::Debug for Position
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(
                        f,
                        "Position(o: {:?}, l: {:?}, c: {:?})",
                        self.offset, self.line, self.column
                    )
                }
            }

            impl Ord for Position
            {
                fn cmp(&self, other: &Position) -> Ordering {
                    self.offset.cmp(&other.offset)
                }
            }

            impl PartialOrd for Position
            {
                fn partial_cmp(&self, other: &Position) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Span
            {
                /// Create a new span with the given positions.
                pub fn new(start: Position, end: Position) -> Span {
                    Span { start, end }
                }
                /// Create a new span using the given position as the start and end.
                pub fn splat(pos: Position) -> Span {
                    Span::new(pos, pos)
                }
                /// Create a new span by replacing the starting the position with the one
                pub fn with_start(self, pos: Position) -> Span {
                    Span { start: pos, ..self }
                }
                /// Create a new span by replacing the ending the position with the one
                pub fn with_end(self, pos: Position) -> Span {
                    Span { end: pos, ..self }
                }
                /// Returns true if and only if this span occurs on a single line.
                pub fn is_one_line(&self) -> bool
                { self.start.line == self.end.line
                }
                /// Returns true if and only if this span is empty. That is, it points to
                pub fn is_empty(&self) -> bool
                { self.start.offset == self.end.offset
                }
            }

            impl Position
            {
                /// Create a new position with the given information.
                pub fn new(offset: usize, line: usize, column: usize) -> Position {
                    Position { offset, line, column }
                }
            }
            /// An abstract syntax tree for a singular expression along with comments
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct WithComments
            {
                /// The actual ast.
                pub ast: Ast,
                /// All comments found in the original regular expression.
                pub comments: Vec<Comment>,
            }
            /// A comment from a regular expression with an associated span.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Comment
            {
                /// The span of this comment, including the beginning `#` and ending `\n`.
                pub span: Span,
                /// The comment text, starting with the first character following the `#`
                pub comment: String,
            }
            /// An abstract syntax tree for a single regular expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum Ast
            {
                /// An empty regex that matches everything.
                Empty(Box<Span>),
                /// A set of flags, e.g., `(?is)`.
                Flags(Box<SetFlags>),
                /// A single character literal, which includes escape sequences.
                Literal(Box<Literal>),
                /// The "any character" class.
                Dot(Box<Span>),
                /// A single zero-width assertion.
                Assertion(Box<Assertion>),
                /// A single Unicode character class, e.g., `\pL` or `\p{Greek}`.
                ClassUnicode(Box<ClassUnicode>),
                /// A single perl character class, e.g., `\d` or `\W`.
                ClassPerl(Box<ClassPerl>),
                /// A single bracketed character class set, which may contain zero or more
                ClassBracketed(Box<ClassBracketed>),
                /// A repetition operator applied to an arbitrary regular expression.
                Repetition(Box<Repetition>),
                /// A grouped regular expression.
                Group(Box<Group>),
                /// An alternation of regular expressions.
                Alternation(Box<Alternation>),
                /// A concatenation of regular expressions.
                Concat(Box<Concat>),
            }

            impl Ast
            {
                /// Create an "empty" AST item.
                pub fn empty(span: Span) -> Ast {
                    Ast::Empty(Box::new(span))
                }
                /// Create a "flags" AST item.
                pub fn flags(e: SetFlags) -> Ast {
                    Ast::Flags(Box::new(e))
                }
                /// Create a "literal" AST item.
                pub fn literal(e: Literal) -> Ast {
                    Ast::Literal(Box::new(e))
                }
                /// Create a "dot" AST item.
                pub fn dot(span: Span) -> Ast {
                    Ast::Dot(Box::new(span))
                }
                /// Create a "assertion" AST item.
                pub fn assertion(e: Assertion) -> Ast {
                    Ast::Assertion(Box::new(e))
                }
                /// Create a "Unicode class" AST item.
                pub fn class_unicode(e: ClassUnicode) -> Ast {
                    Ast::ClassUnicode(Box::new(e))
                }
                /// Create a "Perl class" AST item.
                pub fn class_perl(e: ClassPerl) -> Ast {
                    Ast::ClassPerl(Box::new(e))
                }
                /// Create a "bracketed class" AST item.
                pub fn class_bracketed(e: ClassBracketed) -> Ast {
                    Ast::ClassBracketed(Box::new(e))
                }
                /// Create a "repetition" AST item.
                pub fn repetition(e: Repetition) -> Ast {
                    Ast::Repetition(Box::new(e))
                }
                /// Create a "group" AST item.
                pub fn group(e: Group) -> Ast {
                    Ast::Group(Box::new(e))
                }
                /// Create a "alternation" AST item.
                pub fn alternation(e: Alternation) -> Ast {
                    Ast::Alternation(Box::new(e))
                }
                /// Create a "concat" AST item.
                pub fn concat(e: Concat) -> Ast {
                    Ast::Concat(Box::new(e))
                }
                /// Return the span of this abstract syntax tree.
                pub fn span(&self) -> &Span {
                    match *self {
                        Ast::Empty(ref span) => span,
                        Ast::Flags(ref x) => &x.span,
                        Ast::Literal(ref x) => &x.span,
                        Ast::Dot(ref span) => span,
                        Ast::Assertion(ref x) => &x.span,
                        Ast::ClassUnicode(ref x) => &x.span,
                        Ast::ClassPerl(ref x) => &x.span,
                        Ast::ClassBracketed(ref x) => &x.span,
                        Ast::Repetition(ref x) => &x.span,
                        Ast::Group(ref x) => &x.span,
                        Ast::Alternation(ref x) => &x.span,
                        Ast::Concat(ref x) => &x.span,
                    }
                }
                /// Return true if and only if this Ast is empty.
                pub fn is_empty(&self) -> bool {
                    match *self {
                        Ast::Empty(_) => true,
                        _ => false,
                    }
                }
                /// Returns true if and only if this AST has any (including possibly empty)
                fn has_subexprs(&self) -> bool {
                    match *self {
                        Ast::Empty(_)
                        | Ast::Flags(_)
                        | Ast::Literal(_)
                        | Ast::Dot(_)
                        | Ast::Assertion(_)
                        | Ast::ClassUnicode(_)
                        | Ast::ClassPerl(_) => false,
                        Ast::ClassBracketed(_)
                        | Ast::Repetition(_)
                        | Ast::Group(_)
                        | Ast::Alternation(_)
                        | Ast::Concat(_) => true,
                    }
                }
            }
            /// Print a display representation of this Ast.
            impl ::fmt::Display for Ast
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    use ::regex::syntax::ast::print::Printer;
                    Printer::new().print(self, f)
                }
            }
            /// An alternation of regular expressions.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Alternation
            {
                /// The span of this alternation.
                pub span: Span,
                /// The alternate regular expressions.
                pub asts: Vec<Ast>,
            }

            impl Alternation
            {
                /// Return this alternation as an AST.
                pub fn into_ast(mut self) -> Ast {
                    match self.asts.len() {
                        0 => Ast::empty(self.span),
                        1 => self.asts.pop().unwrap(),
                        _ => Ast::alternation(self),
                    }
                }
            }
            /// A concatenation of regular expressions.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Concat
            {
                /// The span of this concatenation.
                pub span: Span,
                /// The concatenation regular expressions.
                pub asts: Vec<Ast>,
            }

            impl Concat
            {
                /// Return this concatenation as an AST.
                pub fn into_ast(mut self) -> Ast {
                    match self.asts.len() {
                        0 => Ast::empty(self.span),
                        1 => self.asts.pop().unwrap(),
                        _ => Ast::concat(self),
                    }
                }
            }
            /// A single literal expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Literal
            {
                /// The span of this literal.
                pub span: Span,
                /// The kind of this literal.
                pub kind: LiteralKind,
                /// The Unicode scalar value corresponding to this literal.
                pub c: char,
            }

            impl Literal
            {
                /// If this literal was written as a `\x` hex escape, then this returns
                pub fn byte(&self) -> Option<u8> 
                {
                    match self.kind {
                        LiteralKind::HexFixed(HexLiteralKind::X) => {
                            u8::try_from(self.c).ok()
                        }
                        _ => None,
                    }
                }
            }
            /// The kind of a single literal expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum LiteralKind
            {
                /// The literal is written verbatim, e.g., `a` or `☃`.
                Verbatim,
                /// The literal is written as an escape because it is otherwise a special
                Meta,
                /// The literal is written as an escape despite the fact that the escape is
                Superfluous,
                /// The literal is written as an octal escape, e.g., `\141`.
                Octal,
                /// The literal is written as a hex code with a fixed number of digits
                HexFixed(HexLiteralKind),
                /// The literal is written as a hex code with a bracketed number of
                HexBrace(HexLiteralKind),
                /// The literal is written as a specially recognized escape, e.g., `\f`
                Special(SpecialLiteralKind),
            }
            /// The type of a special literal.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum SpecialLiteralKind
            {
                /// Bell, spelled `\a` (`\x07`).
                Bell,
                /// Form feed, spelled `\f` (`\x0C`).
                FormFeed,
                /// Tab, spelled `\t` (`\x09`).
                Tab,
                /// Line feed, spelled `\n` (`\x0A`).
                LineFeed,
                /// Carriage return, spelled `\r` (`\x0D`).
                CarriageReturn,
                /// Vertical tab, spelled `\v` (`\x0B`).
                VerticalTab,
                /// Space, spelled ` ` (`\x20`). Note that this can only appear when
                Space,
            }
            /// The type of a Unicode hex literal.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum HexLiteralKind
            {
                /// A `\x` prefix. When used without brackets, this form is limited to
                X,
                /// A `\u` prefix. When used without brackets, this form is limited to
                UnicodeShort,
                /// A `\U` prefix. When used without brackets, this form is limited to
                UnicodeLong,
            }

            impl HexLiteralKind
            {
                /// The number of digits that must be used with this literal form when
                pub fn digits(&self) -> u32 {
                    match *self {
                        HexLiteralKind::X => 2,
                        HexLiteralKind::UnicodeShort => 4,
                        HexLiteralKind::UnicodeLong => 8,
                    }
                }
            }
            /// A Perl character class.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassPerl
            {
                /// The span of this class.
                pub span: Span,
                /// The kind of Perl class.
                pub kind: ClassPerlKind,
                /// Whether the class is negated or not. e.g., `\d` is not negated but
                pub negated: bool,
            }
            /// The available Perl character classes.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ClassPerlKind
            {
                /// Decimal numbers.
                Digit,
                /// Whitespace.
                Space,
                /// Word characters.
                Word,
            }
            /// An ASCII character class.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassAscii
            {
                /// The span of this class.
                pub span: Span,
                /// The kind of ASCII class.
                pub kind: ClassAsciiKind,
                /// Whether the class is negated or not. e.g., `[[:alpha:]]` is not negated
                pub negated: bool,
            }
            /// The available ASCII character classes.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ClassAsciiKind
            {
                /// `[0-9A-Za-z]`
                Alnum,
                /// `[A-Za-z]`
                Alpha,
                /// `[\x00-\x7F]`
                Ascii,
                /// `[ \t]`
                Blank,
                /// `[\x00-\x1F\x7F]`
                Cntrl,
                /// `[0-9]`
                Digit,
                /// `[!-~]`
                Graph,
                /// `[a-z]`
                Lower,
                /// `[ -~]`
                Print,
                /// `[!-/:-@\[-`{-~]`
                Punct,
                /// `[\t\n\v\f\r ]`
                Space,
                /// `[A-Z]`
                Upper,
                /// `[0-9A-Za-z_]`
                Word,
                /// `[0-9A-Fa-f]`
                Xdigit,
            }

            impl ClassAsciiKind
            {
                /// Return the corresponding ClassAsciiKind variant for the given name.
                pub fn from_name(name: &str) -> Option<ClassAsciiKind> {
                    use self::ClassAsciiKind::*;
                    match name {
                        "alnum" => Some(Alnum),
                        "alpha" => Some(Alpha),
                        "ascii" => Some(Ascii),
                        "blank" => Some(Blank),
                        "cntrl" => Some(Cntrl),
                        "digit" => Some(Digit),
                        "graph" => Some(Graph),
                        "lower" => Some(Lower),
                        "print" => Some(Print),
                        "punct" => Some(Punct),
                        "space" => Some(Space),
                        "upper" => Some(Upper),
                        "word" => Some(Word),
                        "xdigit" => Some(Xdigit),
                        _ => None,
                    }
                }
            }
            /// A Unicode character class.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassUnicode
            {
                /// The span of this class.
                pub span: Span,
                /// Whether this class is negated or not.
                pub negated: bool,
                /// The kind of Unicode class.
                pub kind: ClassUnicodeKind,
            }

            impl ClassUnicode
            {
                /// Returns true if this class has been negated.
                pub fn is_negated(&self) -> bool {
                    match self.kind {
                        ClassUnicodeKind::NamedValue {
                            op: ClassUnicodeOpKind::NotEqual,
                            ..
                        } => !self.negated,
                        _ => self.negated,
                    }
                }
            }
            /// The available forms of Unicode character classes.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ClassUnicodeKind
            {
                /// A one letter abbreviated class, e.g., `\pN`.
                OneLetter(char),
                /// A binary property, general category or script. The string may be
                Named(String),
                /// A property name and an associated value.
                NamedValue
                {
                    /// The type of Unicode op used to associate `name` with `value`.
                    op: ClassUnicodeOpKind,
                    /// The property name (which may be empty).
                    name: String,
                    /// The property value (which may be empty).
                    value: String,
                },
            }
            /// The type of op used in a Unicode character class.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ClassUnicodeOpKind
            {
                /// A property set to a specific value, e.g., `\p{scx=Katakana}`.
                Equal,
                /// A property set to a specific value using a colon, e.g.,
                Colon,
                /// A property that isn't a particular value, e.g., `\p{scx!=Katakana}`.
                NotEqual,
            }

            impl ClassUnicodeOpKind
            {
                /// Whether the op is an equality op or not.
                pub fn is_equal(&self) -> bool {
                    match *self {
                        ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,
                        _ => false,
                    }
                }
            }
            /// A bracketed character class, e.g., `[a-z0-9]`.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassBracketed
            {
                /// The span of this class.
                pub span: Span,
                /// Whether this class is negated or not. e.g., `[a]` is not negated but
                pub negated: bool,
                /// The type of this set. A set is either a normal union of things, e.g.,
                pub kind: ClassSet,
            }
            /// A character class set.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ClassSet
            {
                /// An item, which can be a single literal, range, nested character class
                Item(ClassSetItem),
                /// A single binary operation (i.e., &&, -- or ~~).
                BinaryOp(ClassSetBinaryOp),
            }

            impl ClassSet
            {
                /// Build a set from a union.
                pub fn union(ast: ClassSetUnion) -> ClassSet {
                    ClassSet::Item(ClassSetItem::Union(ast))
                }
                /// Return the span of this character class set.
                pub fn span(&self) -> &Span {
                    match *self {
                        ClassSet::Item(ref x) => x.span(),
                        ClassSet::BinaryOp(ref x) => &x.span,
                    }
                }
                /// Return true if and only if this class set is empty.
                fn is_empty(&self) -> bool {
                    match *self {
                        ClassSet::Item(ClassSetItem::Empty(_)) => true,
                        _ => false,
                    }
                }
            }
            /// A single component of a character class set.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ClassSetItem
            {
                /// An empty item.
                Empty(Span),
                /// A single literal.
                Literal(Literal),
                /// A range between two literals.
                Range(ClassSetRange),
                /// An ASCII character class, e.g., `[:alnum:]` or `[:punct:]`.
                Ascii(ClassAscii),
                /// A Unicode character class, e.g., `\pL` or `\p{Greek}`.
                Unicode(ClassUnicode),
                /// A perl character class, e.g., `\d` or `\W`.
                Perl(ClassPerl),
                /// A bracketed character class set, which may contain zero or more
                Bracketed(Box<ClassBracketed>),
                /// A union of items.
                Union(ClassSetUnion),
            }

            impl ClassSetItem
            {
                /// Return the span of this character class set item.
                pub fn span(&self) -> &Span {
                    match *self {
                        ClassSetItem::Empty(ref span) => span,
                        ClassSetItem::Literal(ref x) => &x.span,
                        ClassSetItem::Range(ref x) => &x.span,
                        ClassSetItem::Ascii(ref x) => &x.span,
                        ClassSetItem::Perl(ref x) => &x.span,
                        ClassSetItem::Unicode(ref x) => &x.span,
                        ClassSetItem::Bracketed(ref x) => &x.span,
                        ClassSetItem::Union(ref x) => &x.span,
                    }
                }
            }
            /// A single character class range in a set.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassSetRange
            {
                /// The span of this range.
                pub span: Span,
                /// The start of this range.
                pub start: Literal,
                /// The end of this range.
                pub end: Literal,
            }

            impl ClassSetRange
            {
                /// Returns true if and only if this character class range is valid.
                pub fn is_valid(&self) -> bool
                { self.start.c <= self.end.c
                }
            }
            /// A union of items inside a character class set.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassSetUnion
            {
                /// The span of the items in this operation. e.g., the `a-z0-9` in
                pub span: Span,
                /// The sequence of items that make up this union.
                pub items: Vec<ClassSetItem>,
            }

            impl ClassSetUnion
            {
                /// Push a new item in this union.
                pub fn push(&mut self, item: ClassSetItem)
                {
                    if self.items.is_empty() {
                        self.span.start = item.span().start;
                    }
                    
                    self.span.end = item.span().end;
                    self.items.push(item);
                }
                /// Return this union as a character class set item.
                pub fn into_item(mut self) -> ClassSetItem {
                    match self.items.len() {
                        0 => ClassSetItem::Empty(self.span),
                        1 => self.items.pop().unwrap(),
                        _ => ClassSetItem::Union(self),
                    }
                }
            }
            /// A Unicode character class set operation.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassSetBinaryOp
            {
                /// The span of this operation. e.g., the `a-z--[h-p]` in `[a-z--h-p]`.
                pub span: Span,
                /// The type of this set operation.
                pub kind: ClassSetBinaryOpKind,
                /// The left hand side of the operation.
                pub lhs: Box<ClassSet>,
                /// The right hand side of the operation.
                pub rhs: Box<ClassSet>,
            }
            /// The type of a Unicode character class set operation.
            #[derive(Clone, Copy, Debug, Eq, PartialEq)]
            pub enum ClassSetBinaryOpKind
            {
                /// The intersection of two sets, e.g., `\pN&&[a-z]`.
                Intersection,
                /// The difference of two sets, e.g., `\pN--[0-9]`.
                Difference,
                /// The symmetric difference of two sets. The symmetric difference is the
                SymmetricDifference,
            }
            /// A single zero-width assertion.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Assertion
            {
                /// The span of this assertion.
                pub span: Span,
                /// The assertion kind, e.g., `\b` or `^`.
                pub kind: AssertionKind,
            }
            /// An assertion kind.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum AssertionKind
            {
                /// `^`
                StartLine,
                /// `$`
                EndLine,
                /// `\A`
                StartText,
                /// `\z`
                EndText,
                /// `\b`
                WordBoundary,
                /// `\B`
                NotWordBoundary,
                /// `\b{start}`
                WordBoundaryStart,
                /// `\b{end}`
                WordBoundaryEnd,
                /// `\<` (alias for `\b{start}`)
                WordBoundaryStartAngle,
                /// `\>` (alias for `\b{end}`)
                WordBoundaryEndAngle,
                /// `\b{start-half}`
                WordBoundaryStartHalf,
                /// `\b{end-half}`
                WordBoundaryEndHalf,
            }
            /// A repetition operation applied to a regular expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Repetition
            {
                /// The span of this operation.
                pub span: Span,
                /// The actual operation.
                pub op: RepetitionOp,
                /// Whether this operation was applied greedily or not.
                pub greedy: bool,
                /// The regular expression under repetition.
                pub ast: Box<Ast>,
            }
            /// The repetition operator itself.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct RepetitionOp
            {
                /// The span of this operator. This includes things like `+`, `*?` and
                pub span: Span,
                /// The type of operation.
                pub kind: RepetitionKind,
            }
            /// The kind of a repetition operator.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum RepetitionKind
            {
                /// `?`
                ZeroOrOne,
                /// `*`
                ZeroOrMore,
                /// `+`
                OneOrMore,
                /// `{m,n}`
                Range(RepetitionRange),
            }
            /// A range repetition operator.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum RepetitionRange
            {
                /// `{m}`
                Exactly(u32),
                /// `{m,}`
                AtLeast(u32),
                /// `{m,n}`
                Bounded(u32, u32),
            }

            impl RepetitionRange
            {
                /// Returns true if and only if this repetition range is valid.
                pub fn is_valid(&self) -> bool {
                    match *self {
                        RepetitionRange::Bounded(s, e) if s > e => false,
                        _ => true,
                    }
                }
            }
            /// A grouped regular expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Group
            {
                /// The span of this group.
                pub span: Span,
                /// The kind of this group.
                pub kind: GroupKind,
                /// The regular expression in this group.
                pub ast: Box<Ast>,
            }

            impl Group
            {
                /// If this group is non-capturing, then this returns the (possibly empty)
                pub fn flags(&self) -> Option<&Flags> {
                    match self.kind {
                        GroupKind::NonCapturing(ref flags) => Some(flags),
                        _ => None,
                    }
                }
                /// Returns true if and only if this group is capturing.
                pub fn is_capturing(&self) -> bool {
                    match self.kind {
                        GroupKind::CaptureIndex(_) | GroupKind::CaptureName { .. } => true,
                        GroupKind::NonCapturing(_) => false,
                    }
                }
                /// Returns the capture index of this group, if this is a capturing group.
                pub fn capture_index(&self) -> Option<u32> {
                    match self.kind {
                        GroupKind::CaptureIndex(i) => Some(i),
                        GroupKind::CaptureName { ref name, .. } => Some(name.index),
                        GroupKind::NonCapturing(_) => None,
                    }
                }
            }
            /// The kind of a group.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum GroupKind
            {
                /// `(a)`
                CaptureIndex(u32),
                /// `(?<name>a)` or `(?P<name>a)`
                CaptureName
                {
                    /// True if the `?P<` syntax is used and false if the `?<` syntax is used.
                    starts_with_p: bool,
                    /// The capture name.
                    name: CaptureName,
                },
                /// `(?:a)` and `(?i:a)`
                NonCapturing(Flags),
            }
            /// A capture name.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct CaptureName
            {
                /// The span of this capture name.
                pub span: Span,
                /// The capture name.
                pub name: String,
                /// The capture index.
                pub index: u32,
            }
            /// A group of flags that is not applied to a particular regular expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct SetFlags
            {
                /// The span of these flags, including the grouping parentheses.
                pub span: Span,
                /// The actual sequence of flags.
                pub flags: Flags,
            }
            /// A group of flags.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Flags
            {
                /// The span of this group of flags.
                pub span: Span,
                /// A sequence of flag items. Each item is either a flag or a negation
                pub items: Vec<FlagsItem>,
            }

            impl Flags
            {
                /// Add the given item to this sequence of flags.
                pub fn add_item(&mut self, item: FlagsItem) -> Option<usize> {
                    for (i, x) in self.items.iter().enumerate() {
                        if x.kind == item.kind {
                            return Some(i);
                        }
                    }
                    
                    self.items.push(item);
                    None
                }
                /// Returns the state of the given flag in this set.
                pub fn flag_state(&self, flag: Flag) -> Option<bool>
                {
                    let mut negated = false;
                    
                    for x in &self.items {
                        match x.kind {
                            FlagsItemKind::Negation => {
                                negated = true;
                            }
                            FlagsItemKind::Flag(ref xflag) if xflag == &flag => {
                                return Some(!negated);
                            }
                            _ => {}
                        }
                    }
                    
                    None
                }
            }
            /// A single item in a group of flags.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct FlagsItem
            {
                /// The span of this item.
                pub span: Span,
                /// The kind of this item.
                pub kind: FlagsItemKind,
            }
            /// The kind of an item in a group of flags.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum FlagsItemKind
            {
                /// A negation operator applied to all subsequent flags in the enclosing
                Negation,
                /// A single flag in a group.
                Flag(Flag),
            }

            impl FlagsItemKind
            {
                /// Returns true if and only if this item is a negation operator.
                pub fn is_negation(&self) -> bool {
                    match *self {
                        FlagsItemKind::Negation => true,
                        _ => false,
                    }
                }
            }
            /// A single flag.
            #[derive(Clone, Copy, Debug, Eq, PartialEq)]
            pub enum Flag
            {
                /// `i`
                CaseInsensitive,
                /// `m`
                MultiLine,
                /// `s`
                DotMatchesNewLine,
                /// `U`
                SwapGreed,
                /// `u`
                Unicode,
                /// `R`
                CRLF,
                /// `x`
                IgnoreWhitespace,
            }
            /// A custom `Drop` impl is used for `Ast` such that it uses constant stack
            impl Drop for Ast
            {
                fn drop(&mut self) {
                    use ::mem;

                    match *self {
                        Ast::Empty(_)
                        | Ast::Flags(_)
                        | Ast::Literal(_)
                        | Ast::Dot(_)
                        | Ast::Assertion(_)
                        | Ast::ClassUnicode(_)
                        | Ast::ClassPerl(_)
                        // Bracketed classes are recursive, they get their own Drop impl.
                        | Ast::ClassBracketed(_) => return,
                        Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,
                        Ast::Group(ref x) if !x.ast.has_subexprs() => return,
                        Ast::Alternation(ref x) if x.asts.is_empty() => return,
                        Ast::Concat(ref x) if x.asts.is_empty() => return,
                        _ => {}
                    }

                    let empty_span = || Span::splat(Position::new(0, 0, 0));
                    let empty_ast = || Ast::empty(empty_span());
                    let mut stack = vec![mem::replace(self, empty_ast())];
                    
                    while let Some(mut ast) = stack.pop() {
                        match ast {
                            Ast::Empty(_)
                            | Ast::Flags(_)
                            | Ast::Literal(_)
                            | Ast::Dot(_)
                            | Ast::Assertion(_)
                            | Ast::ClassUnicode(_)
                            | Ast::ClassPerl(_)
                            | Ast::ClassBracketed(_) => {}
                            Ast::Repetition(ref mut x) => {
                                stack.push(mem::replace(&mut x.ast, empty_ast()));
                            }
                            Ast::Group(ref mut x) => {
                                stack.push(mem::replace(&mut x.ast, empty_ast()));
                            }
                            Ast::Alternation(ref mut x) => {
                                stack.extend(x.asts.drain(..));
                            }
                            Ast::Concat(ref mut x) => {
                                stack.extend(x.asts.drain(..));
                            }
                        }
                    }
                }
            }
            /// A custom `Drop` impl is used for `ClassSet` such that it uses constant
            impl Drop for ClassSet
            {
                fn drop(&mut self) {
                    use ::mem;

                    match *self {
                        ClassSet::Item(ref item) => match *item {
                            ClassSetItem::Empty(_)
                            | ClassSetItem::Literal(_)
                            | ClassSetItem::Range(_)
                            | ClassSetItem::Ascii(_)
                            | ClassSetItem::Unicode(_)
                            | ClassSetItem::Perl(_) => return,
                            ClassSetItem::Bracketed(ref x) => {
                                if x.kind.is_empty() {
                                    return;
                                }
                            }
                            ClassSetItem::Union(ref x) => {
                                if x.items.is_empty() {
                                    return;
                                }
                            }
                        },
                        ClassSet::BinaryOp(ref op) => {
                            if op.lhs.is_empty() && op.rhs.is_empty() {
                                return;
                            }
                        }
                    }

                    let empty_span = || Span::splat(Position::new(0, 0, 0));
                    let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));
                    let mut stack = vec![mem::replace(self, empty_set())];
                    
                    while let Some(mut set) = stack.pop() {
                        match set {
                            ClassSet::Item(ref mut item) => match *item {
                                ClassSetItem::Empty(_)
                                | ClassSetItem::Literal(_)
                                | ClassSetItem::Range(_)
                                | ClassSetItem::Ascii(_)
                                | ClassSetItem::Unicode(_)
                                | ClassSetItem::Perl(_) => {}
                                ClassSetItem::Bracketed(ref mut x) => {
                                    stack.push(mem::replace(&mut x.kind, empty_set()));
                                }
                                ClassSetItem::Union(ref mut x) => {
                                    stack.extend(x.items.drain(..).map(ClassSet::Item));
                                }
                            },
                            ClassSet::BinaryOp(ref mut op) => {
                                stack.push(mem::replace(&mut op.lhs, empty_set()));
                                stack.push(mem::replace(&mut op.rhs, empty_set()));
                            }
                        }
                    }
                }
            }
        }

        pub mod debug
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            /// A type that wraps a single byte with a convenient fmt::Debug impl that
            pub struct Byte(pub u8);

            impl ::fmt::Debug for Byte
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    if self.0 == b' ' {
                        return write!(f, "' '");
                    }
                    // 10 bytes is enough to cover any output from ascii::escape_default.
                    let mut bytes = [0u8; 10];
                    let mut len = 0;
                    
                    for (i, mut b) in ::ascii::escape_default(self.0).enumerate() {
                        // capitalize \xab to \xAB
                        if i >= 2 && b'a' <= b && b <= b'f' {
                            b -= 32;
                        }
                        bytes[len] = b;
                        len += 1;
                    }
                    write!(f, "{}", ::str::from_utf8(&bytes[..len]).unwrap())
                }
            }
            /// A type that provides a human readable debug impl for arbitrary bytes.
            pub struct Bytes<'a>(pub &'a [u8]);

            impl<'a> ::fmt::Debug for Bytes<'a>
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    write!(f, "\"")?;
                    // This is a sad re-implementation of a similar impl found in bstr.
                    let mut bytes = self.0;
                    
                    while let Some(result) = utf8_decode(bytes) {
                        let ch = match result {
                            Ok(ch) => ch,
                            Err(byte) => {
                                write!(f, r"\x{:02x}", byte)?;
                                bytes = &bytes[1..];
                                continue;
                            }
                        };
                        bytes = &bytes[ch.len_utf8()..];
                        match ch {
                            '\0' => write!(f, "\\0")?,
                            // ASCII control characters except \0, \n, \r, \t
                            '\x01'..='\x08'
                            | '\x0b'
                            | '\x0c'
                            | '\x0e'..='\x19'
                            | '\x7f' => {
                                write!(f, "\\x{:02x}", u32::from(ch))?;
                            }
                            '\n' | '\r' | '\t' | _ => {
                                write!(f, "{}", ch.escape_debug())?;
                            }
                        }
                    }
                    write!(f, "\"")?;
                    Ok(())
                }
            }
            /// Decodes the next UTF-8 encoded codepoint from the given byte slice.
            pub fn utf8_decode(bytes: &[u8]) -> Option<Result<char, u8>>
           
            {
                fn len(byte: u8) -> Option<usize> {
                    if byte <= 0x7F {
                        return Some(1);
                    } else if byte & 0b1100_0000 == 0b1000_0000 {
                        return None;
                    } else if byte <= 0b1101_1111 {
                        Some(2)
                    } else if byte <= 0b1110_1111 {
                        Some(3)
                    } else if byte <= 0b1111_0111 {
                        Some(4)
                    }
                    
                    else { None }
                }

                if bytes.is_empty() {
                    return None;
                }
                let len = match len(bytes[0]) {
                    None => return Some(Err(bytes[0])),
                    Some(len) if len > bytes.len() => return Some(Err(bytes[0])),
                    Some(1) => return Some(Ok(char::from(bytes[0]))),
                    Some(len) => len,
                };
                match ::str::from_utf8(&bytes[..len]) {
                    Ok(s) => Some(Ok(s.chars().next().unwrap())),
                    Err(_) => Some(Err(bytes[0])),
                }
            }

        }

        pub mod either
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            /// A simple binary sum type.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum Either<Left, Right> {
                Left(Left),
                Right(Right),
            }
        }

        pub mod error
        {
            /*!
            */
            use ::
            {
                regex::syntax::{ ast, hir },
                string::{ String, ToString, },
                vec::{ self, Vec },
                *,
            };
            /*
            */
            /// This error type encompasses any error that can be returned by this crate.
            #[non_exhaustive]
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum Error
            {
                /// An error that occurred while translating concrete syntax into abstract
                Parse(ast::Error),
                /// An error that occurred while translating abstract syntax into a high
                Translate(hir::Error),
            }

            impl From<ast::Error> for Error
            {
                fn from(err: ast::Error) -> Error {
                    Error::Parse(err)
                }
            }

            impl From<hir::Error> for Error
            {
                fn from(err: hir::Error) -> Error {
                    Error::Translate(err)
                }
            }
            
            impl ::error::Error for Error {}

            impl ::fmt::Display for Error
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    match *self {
                        Error::Parse(ref x) => x.fmt(f),
                        Error::Translate(ref x) => x.fmt(f),
                    }
                }
            }
            /// A helper type for formatting nice error messages.
            #[derive(Debug)]
            pub struct Formatter<'e, E>
            {
                /// The original regex pattern in which the error occurred.
                pattern: &'e str,
                /// The error kind. It must impl fmt::Display.
                err: &'e E,
                /// The primary span of the error.
                span: &'e ast::Span,
                /// An auxiliary and optional span, in case the error needs to point to
                aux_span: Option<&'e ast::Span>,
            }

            impl<'e> From<&'e ast::Error> for Formatter<'e, ast::ErrorKind>
           
            {
                fn from(err: &'e ast::Error) -> Self {
                    Formatter {
                        pattern: err.pattern(),
                        err: err.kind(),
                        span: err.span(),
                        aux_span: err.auxiliary_span(),
                    }
                }
            }

            impl<'e> From<&'e hir::Error> for Formatter<'e, hir::ErrorKind>
           
            {
                fn from(err: &'e hir::Error) -> Self {
                    Formatter {
                        pattern: err.pattern(),
                        err: err.kind(),
                        span: err.span(),
                        aux_span: None,
                    }
                }
            }

            impl<'e, E: ::fmt::Display> ::fmt::Display for Formatter<'e, E>
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    let spans = Spans::from_formatter(self);
                    if self.pattern.contains('\n') {
                        let divider = repeat_char('~', 79);

                        writeln!(f, "regex parse error:")?;
                        writeln!(f, "{}", divider)?;
                        let notated = spans.notate();
                        write!(f, "{}", notated)?;
                        writeln!(f, "{}", divider)?;
                        
                        if !spans.multi_line.is_empty() {
                            let mut notes = vec![];
                            for span in &spans.multi_line {
                                notes.push(format!(
                                    "on line {} (column {}) through line {} (column {})",
                                    span.start.line,
                                    span.start.column,
                                    span.end.line,
                                    span.end.column - 1
                                ));
                            }
                            writeln!(f, "{}", notes.join("\n"))?;
                        }
                        write!(f, "error: {}", self.err)?;
                    } else {
                        writeln!(f, "regex parse error:")?;
                        let notated = Spans::from_formatter(self).notate();
                        write!(f, "{}", notated)?;
                        write!(f, "error: {}", self.err)?;
                    }
                    Ok(())
                }
            }
            /// This type represents an arbitrary number of error spans in a way that makes
            struct Spans<'p>
            {
                /// The original regex pattern string.
                pattern: &'p str,
                /// The total width that should be used for line numbers. The width is
                line_number_width: usize,
                /// All error spans that occur on a single line. This sequence always has
                by_line: Vec<Vec<ast::Span>>,
                /// All error spans that occur over one or more lines. That is, the start
                multi_line: Vec<ast::Span>,
            }

            impl<'p> Spans<'p>
            {
                /// Build a sequence of spans from a formatter.
                fn from_formatter<'e, E: ::fmt::Display>(
                    fmter: &'p Formatter<'e, E>,
                ) -> Spans<'p>
                {
                    let mut line_count = fmter.pattern.lines().count();
                    if fmter.pattern.ends_with('\n') {
                        line_count += 1;
                    }
                    let line_number_width =
                        if line_count <= 1 { 0 } else { line_count.to_string().len() };
                    let mut spans = Spans {
                        pattern: &fmter.pattern,
                        line_number_width,
                        by_line: vec![vec![]; line_count],
                        multi_line: vec![],
                    };
                    spans.add(fmter.span.clone());
                    if let Some(span) = fmter.aux_span {
                        spans.add(span.clone());
                    }
                    spans
                }
                /// Add the given span to this sequence, putting it in the right place.
                fn add(&mut self, span: ast::Span)
                {
                    if span.is_one_line() {
                        let i = span.start.line - 1; // because lines are 1-indexed
                        self.by_line[i].push(span);
                        self.by_line[i].sort();
                    } else {
                        self.multi_line.push(span);
                        self.multi_line.sort();
                    }
                }
                /// Notate the pattern string with carets (`^`) pointing at each span
                fn notate(&self) -> String
                {
                    let mut notated = String::new();
                    
                    for (i, line) in self.pattern.lines().enumerate() {
                        if self.line_number_width > 0 {
                            notated.push_str(&self.left_pad_line_number(i + 1));
                            notated.push_str(": ");
                        } else {
                            notated.push_str("    ");
                        }
                        notated.push_str(line);
                        notated.push('\n');
                        
                        if let Some(notes) = self.notate_line(i) {
                            notated.push_str(&notes);
                            notated.push('\n');
                        }
                    }
                    notated
                }
                /// Return notes for the line indexed at `i` (zero-based). If there are no
                fn notate_line(&self, i: usize) -> Option<String>
                {
                    let spans = &self.by_line[i];
                    if spans.is_empty() {
                        return None;
                    }
                    let mut notes = String::new();
                    
                    for _ in 0..self.line_number_padding() {
                        notes.push(' ');
                    }
                    let mut pos = 0;
                    
                    for span in spans {
                        for _ in pos..(span.start.column - 1) {
                            notes.push(' ');
                            pos += 1;
                        }
                        let note_len = span.end.column.saturating_sub(span.start.column);
                        for _ in 0..::cmp::max(1, note_len) {
                            notes.push('^');
                            pos += 1;
                        }
                    }
                    Some(notes)
                }
                /// Left pad the given line number with spaces such that it is aligned with
                fn left_pad_line_number(&self, n: usize) -> String
                {
                    let n = n.to_string();
                    let pad = self.line_number_width.checked_sub(n.len()).unwrap();
                    let mut result = repeat_char(' ', pad);
                    result.push_str(&n);
                    result
                }
                /// Return the line number padding beginning at the start of each line of
                fn line_number_padding(&self) -> usize {
                    if self.line_number_width == 0 {
                        4
                    } else {
                        2 + self.line_number_width
                    }
                }
            }

            fn repeat_char(c: char, count: usize) -> String {
                ::iter::repeat(c).take(count).collect()
            }

        }

        pub mod hir
        {
            /*!
            Defines a high-level intermediate (HIR) representation for regular expressions. */
            use ::
            {
                boxed::{ Box },
                regex::syntax::
                {
                    ast::Span,
                    hir::{ interval::{Interval, IntervalSet, IntervalSetIter}, visitor::{visit, Visitor} },
                    unicode::{ self, CaseFoldError },
                },
                string::{ String, ToString },
                vec::{ self, Vec },
                *,
            };
            /*
            */
            pub mod interval
            {
                /*!
                his module contains an *internal* implementation of interval sets. */
                use ::
                {
                    fmt::{ Debug },
                    regex::syntax::{ unicode::{ self }, },
                    vec::{ Vec },
                    *,
                };
                /*
                */
                #[derive(Clone, Debug)]
                pub struct IntervalSet<I>
                {
                    /// A sorted set of non-overlapping ranges.
                    ranges: Vec<I>,
                    /// While not required at all for correctness, we keep track of whether an
                    folded: bool,
                }

                impl<I: Interval> Eq for IntervalSet<I> {}
                impl<I: Interval> PartialEq for IntervalSet<I> {
                    fn eq(&self, other: &IntervalSet<I>) -> bool {
                        self.ranges.eq(&other.ranges)
                    }
                }

                impl<I: Interval> IntervalSet<I>
                {
                    /// Create a new set from a sequence of intervals. Each interval is
                    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {
                        let ranges: Vec<I> = intervals.into_iter().collect();
                        // An empty set is case folded.
                        let folded = ranges.is_empty();
                        let mut set = IntervalSet { ranges, folded };
                        set.canonicalize();
                        set
                    }
                    /// Add a new interval to this set.
                    pub fn push(&mut self, interval: I) {
                        self.ranges.push(interval);
                        self.canonicalize();
                        self.folded = false;
                    }
                    /// Return an iterator over all intervals in this set.
                    pub fn iter(&self) -> IntervalSetIter<'_, I> {
                        IntervalSetIter(self.ranges.iter())
                    }
                    /// Return an immutable slice of intervals in this set.
                    pub fn intervals(&self) -> &[I] {
                        &self.ranges
                    }
                    /// Expand this interval set such that it contains all case folded
                    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {
                        if self.folded {
                            return Ok(());
                        }
                        let len = self.ranges.len();
                        for i in 0..len {
                            let range = self.ranges[i];
                            if let Err(err) = range.case_fold_simple(&mut self.ranges) {
                                self.canonicalize();
                                return Err(err);
                            }
                        }
                        self.canonicalize();
                        self.folded = true;
                        Ok(())
                    }
                    /// Union this set with the given set, in place.
                    pub fn union(&mut self, other: &IntervalSet<I>) {
                        if other.ranges.is_empty() || self.ranges == other.ranges {
                            return;
                        }
                        // This could almost certainly be done more efficiently.
                        self.ranges.extend(&other.ranges);
                        self.canonicalize();
                        self.folded = self.folded && other.folded;
                    }
                    /// Intersect this set with the given set, in place.
                    pub fn intersect(&mut self, other: &IntervalSet<I>) {
                        if self.ranges.is_empty() {
                            return;
                        }
                        
                        if other.ranges.is_empty() {
                            self.ranges.clear();
                            // An empty set is case folded.
                            self.folded = true;
                            return;
                        }
                        let drain_end = self.ranges.len();

                        let mut ita = 0..drain_end;
                        let mut itb = 0..other.ranges.len();
                        let mut a = ita.next().unwrap();
                        let mut b = itb.next().unwrap();

                        loop
                        {
                            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {
                                self.ranges.push(ab);
                            }
                            let (it, aorb) =
                                if self.ranges[a].upper() < other.ranges[b].upper() {
                                    (&mut ita, &mut a)
                                } else {
                                    (&mut itb, &mut b)
                                };
                            match it.next() {
                                Some(v) => *aorb = v,
                                None => break,
                            }
                        }
                        self.ranges.drain(..drain_end);
                        self.folded = self.folded && other.folded;
                    }
                    /// Subtract the given set from this set, in place.
                    pub fn difference(&mut self, other: &IntervalSet<I>) {
                        if self.ranges.is_empty() || other.ranges.is_empty() {
                            return;
                        }
                        let drain_end = self.ranges.len();
                        let (mut a, mut b) = (0, 0);
                        'LOOP: while a < drain_end && b < other.ranges.len()
                        {
                            if other.ranges[b].upper() < self.ranges[a].lower() {
                                b += 1;
                                continue;
                            }
                            
                            if self.ranges[a].upper() < other.ranges[b].lower() {
                                let range = self.ranges[a];
                                self.ranges.push(range);
                                a += 1;
                                continue;
                            }
                            // Otherwise, we have overlapping ranges.
                            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));
                            let mut range = self.ranges[a];
                            while b < other.ranges.len()
                                && !range.is_intersection_empty(&other.ranges[b])
                            {
                                let old_range = range;
                                range = match range.difference(&other.ranges[b]) {
                                    (None, None) => {
                                        a += 1;
                                        continue 'LOOP;
                                    }
                                    (Some(range1), None) | (None, Some(range1)) => range1,
                                    (Some(range1), Some(range2)) => {
                                        self.ranges.push(range1);
                                        range2
                                    }
                                };
                                
                                if other.ranges[b].upper() > old_range.upper() {
                                    break;
                                }
                                b += 1;
                            }
                            self.ranges.push(range);
                            a += 1;
                        }
                        while a < drain_end {
                            let range = self.ranges[a];
                            self.ranges.push(range);
                            a += 1;
                        }
                        self.ranges.drain(..drain_end);
                        self.folded = self.folded && other.folded;
                    }
                    /// Compute the symmetric difference of the two sets, in place.
                    pub fn symmetric_difference(&mut self, other: &IntervalSet<I>) {
                        // TODO(burntsushi): Fix this so that it amortizes allocation.
                        let mut intersection = self.clone();
                        intersection.intersect(other);
                        self.union(other);
                        self.difference(&intersection);
                    }
                    /// Negate this interval set.
                    pub fn negate(&mut self) {
                        if self.ranges.is_empty() {
                            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());
                            self.ranges.push(I::create(min, max));
                            // The set containing everything must case folded.
                            self.folded = true;
                            return;
                        }
                        let drain_end = self.ranges.len();
                        
                        if self.ranges[0].lower() > I::Bound::min_value() {
                            let upper = self.ranges[0].lower().decrement();
                            self.ranges.push(I::create(I::Bound::min_value(), upper));
                        }
                        for i in 1..drain_end {
                            let lower = self.ranges[i - 1].upper().increment();
                            let upper = self.ranges[i].lower().decrement();
                            self.ranges.push(I::create(lower, upper));
                        }
                        
                        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {
                            let lower = self.ranges[drain_end - 1].upper().increment();
                            self.ranges.push(I::create(lower, I::Bound::max_value()));
                        }
                        self.ranges.drain(..drain_end);
                    }
                    /// Converts this set into a canonical ordering.
                    fn canonicalize(&mut self) {
                        if self.is_canonical() {
                            return;
                        }
                        self.ranges.sort();
                        assert!(!self.ranges.is_empty());
                        let drain_end = self.ranges.len();
                        for oldi in 0..drain_end {
                            if self.ranges.len() > drain_end {
                                let (last, rest) = self.ranges.split_last_mut().unwrap();
                                
                                if let Some(union) = last.union(&rest[oldi]) {
                                    *last = union;
                                    continue;
                                }
                            }
                            let range = self.ranges[oldi];
                            self.ranges.push(range);
                        }
                        self.ranges.drain(..drain_end);
                    }
                    /// Returns true if and only if this class is in a canonical ordering.
                    fn is_canonical(&self) -> bool {
                        for pair in self.ranges.windows(2) {
                            if pair[0] >= pair[1] {
                                return false;
                            }
                            
                            if pair[0].is_contiguous(&pair[1]) {
                                return false;
                            }
                        }
                        true
                    }
                }
                /// An iterator over intervals.
                #[derive(Debug)]
                pub struct IntervalSetIter<'a, I>(slice::Iter<'a, I>);

                impl<'a, I> Iterator for IntervalSetIter<'a, I> {
                    type Item = &'a I;

                    fn next(&mut self) -> Option<&'a I> {
                        self.0.next()
                    }
                }

                pub trait Interval:
                    Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord
                {
                    type Bound: Bound;

                    fn lower(&self) -> Self::Bound;
                    fn upper(&self) -> Self::Bound;
                    fn set_lower(&mut self, bound: Self::Bound);
                    fn set_upper(&mut self, bound: Self::Bound);
                    fn case_fold_simple(
                        &self,
                        intervals: &mut Vec<Self>,
                    ) -> Result<(), unicode::CaseFoldError>;
                    /// Create a new interval.
                    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {
                        let mut int = Self::default();
                        
                        if lower <= upper {
                            int.set_lower(lower);
                            int.set_upper(upper);
                        } else {
                            int.set_lower(upper);
                            int.set_upper(lower);
                        }
                        int
                    }
                    /// Union the given overlapping range into this range.
                    fn union(&self, other: &Self) -> Option<Self> {
                        if !self.is_contiguous(other) {
                            return None;
                        }
                        let lower = cmp::min(self.lower(), other.lower());
                        let upper = cmp::max(self.upper(), other.upper());
                        Some(Self::create(lower, upper))
                    }
                    /// Intersect this range with the given range and return the result.
                    fn intersect(&self, other: &Self) -> Option<Self> {
                        let lower = cmp::max(self.lower(), other.lower());
                        let upper = cmp::min(self.upper(), other.upper());
                        
                        if lower <= upper {
                            Some(Self::create(lower, upper))
                        } else {
                            None
                        }
                    }
                    /// Subtract the given range from this range and return the resulting
                    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {
                        if self.is_subset(other) {
                            return (None, None);
                        }
                        
                        if self.is_intersection_empty(other) {
                            return (Some(self.clone()), None);
                        }
                        let add_lower = other.lower() > self.lower();
                        let add_upper = other.upper() < self.upper();
                        assert!(add_lower || add_upper);
                        let mut ret = (None, None);
                        
                        if add_lower {
                            let upper = other.lower().decrement();
                            ret.0 = Some(Self::create(self.lower(), upper));
                        }
                        
                        if add_upper {
                            let lower = other.upper().increment();
                            let range = Self::create(lower, self.upper());
                            if ret.0.is_none() {
                                ret.0 = Some(range);
                            } else {
                                ret.1 = Some(range);
                            }
                        }
                        ret
                    }
                    /// Returns true if and only if the two ranges are contiguous. Two ranges
                    fn is_contiguous(&self, other: &Self) -> bool {
                        let lower1 = self.lower().as_u32();
                        let upper1 = self.upper().as_u32();
                        let lower2 = other.lower().as_u32();
                        let upper2 = other.upper().as_u32();
                        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)
                    }
                    /// Returns true if and only if the intersection of this range and the
                    fn is_intersection_empty(&self, other: &Self) -> bool {
                        let (lower1, upper1) = (self.lower(), self.upper());
                        let (lower2, upper2) = (other.lower(), other.upper());
                        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)
                    }
                    /// Returns true if and only if this range is a subset of the other range.
                    fn is_subset(&self, other: &Self) -> bool {
                        let (lower1, upper1) = (self.lower(), self.upper());
                        let (lower2, upper2) = (other.lower(), other.upper());
                        (lower2 <= lower1 && lower1 <= upper2)
                            && (lower2 <= upper1 && upper1 <= upper2)
                    }
                }

                pub trait Bound:
                    Copy + Clone + Debug + Eq + PartialEq + PartialOrd + Ord
                {
                    fn min_value() -> Self;
                    fn max_value() -> Self;
                    fn as_u32(self) -> u32;
                    fn increment(self) -> Self;
                    fn decrement(self) -> Self;
                }

                impl Bound for u8 {
                    fn min_value() -> Self {
                        u8::MIN
                    }
                    fn max_value() -> Self {
                        u8::MAX
                    }
                    fn as_u32(self) -> u32 {
                        u32::from(self)
                    }
                    fn increment(self) -> Self {
                        self.checked_add(1).unwrap()
                    }
                    fn decrement(self) -> Self {
                        self.checked_sub(1).unwrap()
                    }
                }

                impl Bound for char {
                    fn min_value() -> Self {
                        '\x00'
                    }
                    fn max_value() -> Self {
                        '\u{10FFFF}'
                    }
                    fn as_u32(self) -> u32 {
                        u32::from(self)
                    }

                    fn increment(self) -> Self {
                        match self {
                            '\u{D7FF}' => '\u{E000}',
                            c => char::from_u32(u32::from(c).checked_add(1).unwrap()).unwrap(),
                        }
                    }

                    fn decrement(self) -> Self {
                        match self {
                            '\u{E000}' => '\u{D7FF}',
                            c => char::from_u32(u32::from(c).checked_sub(1).unwrap()).unwrap(),
                        }
                    }
                }
            }

            pub mod literal
            {
                /*!
                Provides literal extraction from `Hir` expressions. */
                use ::
                {
                    num::{ NonZeroUsize },
                    regex::syntax::hir::{self, Hir},
                    *,
                };
                /*
                */
                /// Extracts prefix or suffix literal sequences from [`Hir`] expressions.
                #[derive(Clone, Debug)]
                pub struct Extractor {
                    kind: ExtractKind,
                    limit_class: usize,
                    limit_repeat: usize,
                    limit_literal_len: usize,
                    limit_total: usize,
                }

                impl Extractor
                {
                    /// Create a new extractor with a default configuration.
                    pub fn new() -> Extractor {
                        Extractor {
                            kind: ExtractKind::Prefix,
                            limit_class: 10,
                            limit_repeat: 10,
                            limit_literal_len: 100,
                            limit_total: 250,
                        }
                    }
                    /// Execute the extractor and return a sequence of literals.
                    pub fn extract(&self, hir: &Hir) -> Seq 
                    {
                        use ::regex::syntax::hir::HirKind::*;

                        match *hir.kind() {
                            Empty | Look(_) => Seq::singleton(self::Literal::exact(vec![])),
                            Literal(hir::Literal(ref bytes)) => {
                                let mut seq =
                                    Seq::singleton(self::Literal::exact(bytes.to_vec()));
                                self.enforce_literal_len(&mut seq);
                                seq
                            }
                            Class(hir::Class::Unicode(ref cls)) => {
                                self.extract_class_unicode(cls)
                            }
                            Class(hir::Class::Bytes(ref cls)) => self.extract_class_bytes(cls),
                            Repetition(ref rep) => self.extract_repetition(rep),
                            Capture(hir::Capture { ref sub, .. }) => self.extract(sub),
                            Concat(ref hirs) => match self.kind {
                                ExtractKind::Prefix => self.extract_concat(hirs.iter()),
                                ExtractKind::Suffix => self.extract_concat(hirs.iter().rev()),
                            },
                            Alternation(ref hirs) => {
                                self.extract_alternation(hirs.iter())
                            }
                        }
                    }
                    /// Set the kind of literal sequence to extract from an [`Hir`] expression.
                    pub fn kind(&mut self, kind: ExtractKind) -> &mut Extractor {
                        self.kind = kind;
                        self
                    }
                    /// Configure a limit on the length of the sequence that is permitted for
                    pub fn limit_class(&mut self, limit: usize) -> &mut Extractor {
                        self.limit_class = limit;
                        self
                    }
                    /// Configure a limit on the total number of repetitions that is permitted
                    pub fn limit_repeat(&mut self, limit: usize) -> &mut Extractor {
                        self.limit_repeat = limit;
                        self
                    }
                    /// Configure a limit on the maximum length of any literal in a sequence.
                    pub fn limit_literal_len(&mut self, limit: usize) -> &mut Extractor {
                        self.limit_literal_len = limit;
                        self
                    }
                    /// Configure a limit on the total number of literals that will be
                    pub fn limit_total(&mut self, limit: usize) -> &mut Extractor {
                        self.limit_total = limit;
                        self
                    }
                    /// Extract a sequence from the given concatenation. Sequences from each of
                    fn extract_concat<'a, I: Iterator<Item = &'a Hir>>(&self, it: I) -> Seq {
                        let mut seq = Seq::singleton(self::Literal::exact(vec![]));
                        for hir in it {
                            if seq.is_inexact() {
                                break;
                            }
                            seq = self.cross(seq, &mut self.extract(hir));
                        }
                        seq
                    }
                    /// Extract a sequence from the given alternation.
                    fn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(
                        &self,
                        it: I,
                    ) -> Seq {
                        let mut seq = Seq::empty();
                        for hir in it {
                            if !seq.is_finite() {
                                break;
                            }
                            seq = self.union(seq, &mut self.extract(hir));
                        }
                        seq
                    }
                    /// Extract a sequence of literals from the given repetition. We do our
                    fn extract_repetition(&self, rep: &hir::Repetition) -> Seq {
                        let mut subseq = self.extract(&rep.sub);
                        match *rep {
                            hir::Repetition { min: 0, max, greedy, .. } => {
                                if max != Some(1) {
                                    subseq.make_inexact();
                                }
                                let mut empty = Seq::singleton(Literal::exact(vec![]));
                                
                                if !greedy {
                                    mem::swap(&mut subseq, &mut empty);
                                }
                                self.union(subseq, &mut empty)
                            }
                            hir::Repetition { min, max: Some(max), .. } if min == max => {
                                assert!(min > 0); // handled above
                                let limit =
                                    u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);
                                let mut seq = Seq::singleton(Literal::exact(vec![]));
                                for _ in 0..cmp::min(min, limit) {
                                    if seq.is_inexact() {
                                        break;
                                    }
                                    seq = self.cross(seq, &mut subseq.clone());
                                }
                                if usize::try_from(min).is_err() || min > limit {
                                    seq.make_inexact();
                                }
                                seq
                            }
                            hir::Repetition { min, .. } => {
                                assert!(min > 0); // handled above
                                let limit =
                                    u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);
                                let mut seq = Seq::singleton(Literal::exact(vec![]));
                                for _ in 0..cmp::min(min, limit) {
                                    if seq.is_inexact() {
                                        break;
                                    }
                                    seq = self.cross(seq, &mut subseq.clone());
                                }
                                seq.make_inexact();
                                seq
                            }
                        }
                    }
                    /// Convert the given Unicode class into a sequence of literals if the
                    fn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq {
                        if self.class_over_limit_unicode(cls) {
                            return Seq::infinite();
                        }
                        let mut seq = Seq::empty();
                        for r in cls.iter() {
                            for ch in r.start()..=r.end() {
                                seq.push(Literal::from(ch));
                            }
                        }
                        self.enforce_literal_len(&mut seq);
                        seq
                    }
                    /// Convert the given byte class into a sequence of literals if the class
                    fn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq {
                        if self.class_over_limit_bytes(cls) {
                            return Seq::infinite();
                        }
                        let mut seq = Seq::empty();
                        for r in cls.iter() {
                            for b in r.start()..=r.end() {
                                seq.push(Literal::from(b));
                            }
                        }
                        self.enforce_literal_len(&mut seq);
                        seq
                    }
                    /// Returns true if the given Unicode class exceeds the configured limits
                    fn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool {
                        let mut count = 0;
                        for r in cls.iter()
                        {
                            if count > self.limit_class {
                                return true;
                            }
                            count += r.len();
                        }
                        count > self.limit_class
                    }
                    /// Returns true if the given byte class exceeds the configured limits on
                    fn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool {
                        let mut count = 0;
                        for r in cls.iter()
                        {
                            if count > self.limit_class {
                                return true;
                            }
                            count += r.len();
                        }
                        count > self.limit_class
                    }
                    /// Compute the cross product of the two sequences if the result would be
                    fn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
                        if seq1.max_cross_len(seq2).map_or(false, |len| len > self.limit_total)
                        {
                            seq2.make_infinite();
                        }
                        
                        if let ExtractKind::Suffix = self.kind {
                            seq1.cross_reverse(seq2);
                        } else {
                            seq1.cross_forward(seq2);
                        }
                        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
                        self.enforce_literal_len(&mut seq1);
                        seq1
                    }
                    /// Union the two sequences if the result would be within configured
                    fn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
                        if seq1.max_union_len(seq2).map_or(false, |len| len > self.limit_total)
                        {
                            match self.kind {
                                ExtractKind::Prefix => {
                                    seq1.keep_first_bytes(4);
                                    seq2.keep_first_bytes(4);
                                }
                                ExtractKind::Suffix => {
                                    seq1.keep_last_bytes(4);
                                    seq2.keep_last_bytes(4);
                                }
                            }
                            seq1.dedup();
                            seq2.dedup();
                            if seq1
                                .max_union_len(seq2)
                                .map_or(false, |len| len > self.limit_total)
                            {
                                seq2.make_infinite();
                            }
                        }
                        seq1.union(seq2);
                        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
                        seq1
                    }
                    /// Applies the literal length limit to the given sequence. If none of the
                    fn enforce_literal_len(&self, seq: &mut Seq) {
                        let len = self.limit_literal_len;
                        match self.kind {
                            ExtractKind::Prefix => seq.keep_first_bytes(len),
                            ExtractKind::Suffix => seq.keep_last_bytes(len),
                        }
                    }
                }

                impl Default for Extractor {
                    fn default() -> Extractor {
                        Extractor::new()
                    }
                }
                /// The kind of literals to extract from an [`Hir`] expression.
                #[non_exhaustive]
                #[derive(Clone, Debug)]
                pub enum ExtractKind
                {
                    /// Extracts only prefix literals from a regex.
                    Prefix,
                    /// Extracts only suffix literals from a regex.
                    Suffix,
                }

                impl ExtractKind
                {
                    /// Returns true if this kind is the `Prefix` variant.
                    pub fn is_prefix(&self) -> bool {
                        matches!(*self, ExtractKind::Prefix)
                    }
                    /// Returns true if this kind is the `Suffix` variant.
                    pub fn is_suffix(&self) -> bool {
                        matches!(*self, ExtractKind::Suffix)
                    }
                }

                impl Default for ExtractKind {
                    fn default() -> ExtractKind {
                        ExtractKind::Prefix
                    }
                }
                /// A sequence of literals.
                #[derive(Clone, Eq, PartialEq)]
                pub struct Seq
                {
                    /// The members of this seq.
                    literals: Option<Vec<Literal>>,
                }

                impl Seq
                {
                    /// Returns an empty sequence.
                    #[inline] pub fn empty() -> Seq {
                        Seq { literals: Some(vec![]) }
                    }
                    /// Returns a sequence of literals without a finite size and may contain
                    #[inline] pub fn infinite() -> Seq {
                        Seq { literals: None }
                    }
                    /// Returns a sequence containing a single literal.
                    #[inline] pub fn singleton(lit: Literal) -> Seq {
                        Seq { literals: Some(vec![lit]) }
                    }
                    /// Returns a sequence of exact literals from the given byte strings.
                    #[inline] pub fn new<I, B>(it: I) -> Seq
                    where
                        I: IntoIterator<Item = B>,
                        B: AsRef<[u8]>,
                    {
                        it.into_iter().map(|b| Literal::exact(b.as_ref())).collect()
                    }
                    /// If this is a finite sequence, return its members as a slice of
                    #[inline] pub fn literals(&self) -> Option<&[Literal]> {
                        self.literals.as_deref()
                    }
                    /// Push a literal to the end of this sequence.
                    #[inline] pub fn push(&mut self, lit: Literal) {
                        let lits = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        
                        if lits.last().map_or(false, |m| m == &lit) {
                            return;
                        }
                        lits.push(lit);
                    }
                    /// Make all of the literals in this sequence inexact.
                    #[inline] pub fn make_inexact(&mut self) {
                        let lits = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        for lit in lits.iter_mut() {
                            lit.make_inexact();
                        }
                    }
                    /// Converts this sequence to an infinite sequence.
                    #[inline] pub fn make_infinite(&mut self) {
                        self.literals = None;
                    }
                    /// Modify this sequence to contain the cross product between it and the
                    #[inline] pub fn cross_forward(&mut self, other: &mut Seq) {
                        let (lits1, lits2) = match self.cross_preamble(other) {
                            None => return,
                            Some((lits1, lits2)) => (lits1, lits2),
                        };
                        let newcap = lits1.len().saturating_mul(lits2.len());
                        for selflit in mem::replace(lits1, Vec::with_capacity(newcap)) {
                            if !selflit.is_exact() {
                                lits1.push(selflit);
                                continue;
                            }
                            
                            for otherlit in lits2.iter() {
                                let mut newlit = Literal::exact(Vec::with_capacity(
                                    selflit.len() + otherlit.len(),
                                ));
                                newlit.extend(&selflit);
                                newlit.extend(&otherlit);
                                
                                if !otherlit.is_exact() {
                                    newlit.make_inexact();
                                }
                                lits1.push(newlit);
                            }
                        }
                        lits2.drain(..);
                        self.dedup();
                    }
                    /// Modify this sequence to contain the cross product between it and
                    #[inline] pub fn cross_reverse(&mut self, other: &mut Seq) {
                        let (lits1, lits2) = match self.cross_preamble(other) {
                            None => return,
                            Some((lits1, lits2)) => (lits1, lits2),
                        };
                        let newcap = lits1.len().saturating_mul(lits2.len());
                        let selflits = mem::replace(lits1, Vec::with_capacity(newcap));
                        for (i, otherlit) in lits2.drain(..).enumerate() {
                            for selflit in selflits.iter()
                            {
                                if !selflit.is_exact() {
                                    if i == 0 {
                                        lits1.push(selflit.clone());
                                    }
                                    continue;
                                }
                                let mut newlit = Literal::exact(Vec::with_capacity(
                                    otherlit.len() + selflit.len(),
                                ));
                                newlit.extend(&otherlit);
                                newlit.extend(&selflit);
                                
                                if !otherlit.is_exact() {
                                    newlit.make_inexact();
                                }
                                lits1.push(newlit);
                            }
                        }
                        self.dedup();
                    }
                    /// A helper function the corresponds to the subtle preamble for both
                    fn cross_preamble<'a>(
                        &'a mut self,
                        other: &'a mut Seq,
                    ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)> {
                        let lits2 = match other.literals {
                            None => {
                                if self.min_literal_len() == Some(0) {
                                    *self = Seq::infinite();
                                } else {
                                    self.make_inexact();
                                }
                                return None;
                            }
                            Some(ref mut lits) => lits,
                        };
                        let lits1 = match self.literals {
                            None => {
                                lits2.drain(..);
                                return None;
                            }
                            Some(ref mut lits) => lits,
                        };
                        Some((lits1, lits2))
                    }
                    /// Unions the `other` sequence into this one.
                    #[inline] pub fn union(&mut self, other: &mut Seq) {
                        let lits2 = match other.literals {
                            None => {
                                self.make_infinite();
                                return;
                            }
                            Some(ref mut lits) => lits.drain(..),
                        };
                        let lits1 = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        lits1.extend(lits2);
                        self.dedup();
                    }
                    /// Unions the `other` sequence into this one by splice the `other`
                    #[inline] pub fn union_into_empty(&mut self, other: &mut Seq) {
                        let lits2 = other.literals.as_mut().map(|lits| lits.drain(..));
                        let lits1 = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        let first_empty = match lits1.iter().position(|m| m.is_empty()) {
                            None => return,
                            Some(i) => i,
                        };
                        let lits2 = match lits2 {
                            None => {
                                self.literals = None;
                                return;
                            }
                            Some(lits) => lits,
                        };
                        lits1.retain(|m| !m.is_empty());
                        lits1.splice(first_empty..first_empty, lits2);
                        self.dedup();
                    }
                    /// Deduplicate adjacent equivalent literals in this sequence.
                    #[inline] pub fn dedup(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            lits.dedup_by(|lit1, lit2| {
                                if lit1.as_bytes() != lit2.as_bytes() {
                                    return false;
                                }
                                if lit1.is_exact() != lit2.is_exact() {
                                    lit1.make_inexact();
                                    lit2.make_inexact();
                                }
                                true
                            });
                        }
                    }
                    /// Sorts this sequence of literals lexicographically.
                    #[inline] pub fn sort(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            lits.sort();
                        }
                    }
                    /// Reverses all of the literals in this sequence.
                    #[inline] pub fn reverse_literals(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            for lit in lits.iter_mut() {
                                lit.reverse();
                            }
                        }
                    }
                    /// Shrinks this seq to its minimal size while respecting the preference
                    #[inline] pub fn minimize_by_preference(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            PreferenceTrie::minimize(lits, false);
                        }
                    }
                    /// Trims all literals in this seq such that only the first `len` bytes
                    #[inline] pub fn keep_first_bytes(&mut self, len: usize) {
                        if let Some(ref mut lits) = self.literals {
                            for m in lits.iter_mut() {
                                m.keep_first_bytes(len);
                            }
                        }
                    }
                    /// Trims all literals in this seq such that only the last `len` bytes
                    #[inline] pub fn keep_last_bytes(&mut self, len: usize) {
                        if let Some(ref mut lits) = self.literals {
                            for m in lits.iter_mut() {
                                m.keep_last_bytes(len);
                            }
                        }
                    }
                    /// Returns true if this sequence is finite.
                    #[inline] pub fn is_finite(&self) -> bool {
                        self.literals.is_some()
                    }
                    /// Returns true if and only if this sequence is finite and empty.
                    #[inline] pub fn is_empty(&self) -> bool {
                        self.len() == Some(0)
                    }
                    /// Returns the number of literals in this sequence if the sequence is
                    #[inline] pub fn len(&self) -> Option<usize> {
                        self.literals.as_ref().map(|lits| lits.len())
                    }
                    /// Returns true if and only if all literals in this sequence are exact.
                    #[inline] pub fn is_exact(&self) -> bool {
                        self.literals().map_or(false, |lits| lits.iter().all(|x| x.is_exact()))
                    }
                    /// Returns true if and only if all literals in this sequence are inexact.
                    #[inline] pub fn is_inexact(&self) -> bool {
                        self.literals().map_or(true, |lits| lits.iter().all(|x| !x.is_exact()))
                    }
                    /// Return the maximum length of the sequence that would result from
                    #[inline] pub fn max_union_len(&self, other: &Seq) -> Option<usize> {
                        let len1 = self.len()?;
                        let len2 = other.len()?;
                        Some(len1.saturating_add(len2))
                    }
                    /// Return the maximum length of the sequence that would result from the
                    #[inline] pub fn max_cross_len(&self, other: &Seq) -> Option<usize> {
                        let len1 = self.len()?;
                        let len2 = other.len()?;
                        Some(len1.saturating_mul(len2))
                    }
                    /// Returns the length of the shortest literal in this sequence.
                    #[inline] pub fn min_literal_len(&self) -> Option<usize> {
                        self.literals.as_ref()?.iter().map(|x| x.len()).min()
                    }
                    /// Returns the length of the longest literal in this sequence.
                    #[inline] pub fn max_literal_len(&self) -> Option<usize> {
                        self.literals.as_ref()?.iter().map(|x| x.len()).max()
                    }
                    /// Returns the longest common prefix from this seq.
                    #[inline] pub fn longest_common_prefix(&self) -> Option<&[u8]> {
                        let lits = match self.literals {
                            None => return None,
                            Some(ref lits) => lits,
                        };
                        
                        if lits.len() == 0 {
                            return None;
                        }
                        let base = lits[0].as_bytes();
                        let mut len = base.len();
                        for m in lits.iter().skip(1) {
                            len = m
                                .as_bytes()
                                .iter()
                                .zip(base[..len].iter())
                                .take_while(|&(a, b)| a == b)
                                .count();
                            if len == 0 {
                                return Some(&[]);
                            }
                        }
                        Some(&base[..len])
                    }
                    /// Returns the longest common suffix from this seq.
                    #[inline] pub fn longest_common_suffix(&self) -> Option<&[u8]> {
                        let lits = match self.literals {
                            None => return None,
                            Some(ref lits) => lits,
                        };
                        
                        if lits.len() == 0 {
                            return None;
                        }
                        let base = lits[0].as_bytes();
                        let mut len = base.len();
                        for m in lits.iter().skip(1) {
                            len = m
                                .as_bytes()
                                .iter()
                                .rev()
                                .zip(base[base.len() - len..].iter().rev())
                                .take_while(|&(a, b)| a == b)
                                .count();
                            if len == 0 {
                                return Some(&[]);
                            }
                        }
                        Some(&base[base.len() - len..])
                    }
                    /// Optimizes this seq while treating its literals as prefixes and
                    #[inline] pub fn optimize_for_prefix_by_preference(&mut self) {
                        self.optimize_by_preference(true);
                    }
                    /// Optimizes this seq while treating its literals as suffixes and
                    #[inline] pub fn optimize_for_suffix_by_preference(&mut self) {
                        self.optimize_by_preference(false);
                    }

                    fn optimize_by_preference(&mut self, prefix: bool) {
                        let origlen = match self.len() {
                            None => return,
                            Some(len) => len,
                        };
                        // Just give up now if our sequence contains an empty string.
                        if self.min_literal_len().map_or(false, |len| len == 0) {
                            self.make_infinite();
                            return;
                        }
                        
                        if prefix {
                            if let Some(ref mut lits) = self.literals {
                                PreferenceTrie::minimize(lits, true);
                            }
                        }
                        let fix = if prefix {
                            self.longest_common_prefix()
                        } else {
                            self.longest_common_suffix()
                        };
                        
                        if let Some(fix) = fix {
                            if prefix
                                && origlen > 1
                                && fix.len() >= 1
                                && fix.len() <= 3
                                && rank(fix[0]) < 200
                            {
                                self.keep_first_bytes(1);
                                self.dedup();
                                return;
                            }
                            let isfast =
                                self.is_exact() && self.len().map_or(false, |len| len <= 16);
                            let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);
                            if usefix {
                                if prefix {
                                    self.keep_first_bytes(fix.len());
                                } else {
                                    self.keep_last_bytes(fix.len());
                                }
                                self.dedup();
                                assert_eq!(Some(1), self.len());
                            }
                        }
                        let exact: Option<Seq> =
                            if self.is_exact() { Some(self.clone()) } else { None };
                        const ATTEMPTS: [(usize, usize); 5] =
                            [(5, 10), (4, 10), (3, 64), (2, 64), (1, 10)];
                        for (keep, limit) in ATTEMPTS {
                            let len = match self.len() {
                                None => break,
                                Some(len) => len,
                            };
                            if len <= limit {
                                break;
                            }
                            
                            if prefix {
                                self.keep_first_bytes(keep);
                            } else {
                                self.keep_last_bytes(keep);
                            }
                            
                            if prefix {
                                if let Some(ref mut lits) = self.literals {
                                    PreferenceTrie::minimize(lits, true);
                                }
                            }
                        }
                        
                        if let Some(lits) = self.literals()
                        {
                            if lits.iter().any(|lit| lit.is_poisonous()) {
                                self.make_infinite();
                            }
                        }
                        
                        if let Some(exact) = exact {
                            if !self.is_finite() {
                                *self = exact;
                                return;
                            }
                            
                            if self.min_literal_len().map_or(true, |len| len <= 2) {
                                *self = exact;
                                return;
                            }
                            
                            if self.len().map_or(true, |len| len > 64) {
                                *self = exact;
                                return;
                            }
                        }
                    }
                }

                impl ::fmt::Debug for Seq {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "Seq")?;
                        
                        if let Some(lits) = self.literals() {
                            f.debug_list().entries(lits.iter()).finish()
                        } else {
                            write!(f, "[∞]")
                        }
                    }
                }

                impl FromIterator<Literal> for Seq {
                    fn from_iter<T: IntoIterator<Item = Literal>>(it: T) -> Seq {
                        let mut seq = Seq::empty();
                        for literal in it {
                            seq.push(literal);
                        }
                        seq
                    }
                }
                /// A single literal extracted from an [`Hir`] expression.
                #[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]
                pub struct Literal {
                    bytes: Vec<u8>,
                    exact: bool,
                }

                impl Literal
                {
                    /// Returns a new exact literal containing the bytes given.
                    #[inline] pub fn exact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
                        Literal { bytes: bytes.into(), exact: true }
                    }
                    /// Returns a new inexact literal containing the bytes given.
                    #[inline] pub fn inexact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
                        Literal { bytes: bytes.into(), exact: false }
                    }
                    /// Returns the bytes in this literal.
                    #[inline] pub fn as_bytes(&self) -> &[u8] {
                        &self.bytes
                    }
                    /// Yields ownership of the bytes inside this literal.
                    #[inline] pub fn into_bytes(self) -> Vec<u8> {
                        self.bytes
                    }
                    /// Returns the length of this literal in bytes.
                    #[inline] pub fn len(&self) -> usize {
                        self.as_bytes().len()
                    }
                    /// Returns true if and only if this literal has zero bytes.
                    #[inline] pub fn is_empty(&self) -> bool {
                        self.len() == 0
                    }
                    /// Returns true if and only if this literal is exact.
                    #[inline] pub fn is_exact(&self) -> bool {
                        self.exact
                    }
                    /// Marks this literal as inexact.
                    #[inline] pub fn make_inexact(&mut self) {
                        self.exact = false;
                    }
                    /// Reverse the bytes in this literal.
                    #[inline] pub fn reverse(&mut self) {
                        self.bytes.reverse();
                    }
                    /// Extend this literal with the literal given.
                    #[inline] pub fn extend(&mut self, lit: &Literal) {
                        if !self.is_exact() {
                            return;
                        }
                        self.bytes.extend_from_slice(&lit.bytes);
                    }
                    /// Trims this literal such that only the first `len` bytes remain. If
                    #[inline] pub fn keep_first_bytes(&mut self, len: usize) {
                        if len >= self.len() {
                            return;
                        }
                        self.make_inexact();
                        self.bytes.truncate(len);
                    }
                    /// Trims this literal such that only the last `len` bytes remain. If this
                    #[inline] pub fn keep_last_bytes(&mut self, len: usize) {
                        if len >= self.len() {
                            return;
                        }
                        self.make_inexact();
                        self.bytes.drain(..self.len() - len);
                    }
                    /// Returns true if it is believe that this literal is likely to match very
                    fn is_poisonous(&self) -> bool {
                        self.is_empty() || (self.len() == 1 && rank(self.as_bytes()[0]) >= 250)
                    }
                }

                impl From<u8> for Literal {
                    fn from(byte: u8) -> Literal {
                        Literal::exact(vec![byte])
                    }
                }

                impl From<char> for Literal {
                    fn from(ch: char) -> Literal {
                        use ::string::ToString;
                        Literal::exact(ch.encode_utf8(&mut [0; 4]).to_string())
                    }
                }

                impl AsRef<[u8]> for Literal {
                    fn as_ref(&self) -> &[u8] {
                        self.as_bytes()
                    }
                }

                impl ::fmt::Debug for Literal {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let tag = if self.exact { "E" } else { "I" };
                        f.debug_tuple(tag)
                            .field(&crate::debug::Bytes(self.as_bytes()))
                            .finish()
                    }
                }
                /// A "preference" trie that rejects literals that will never match when
                #[derive(Debug)]
                struct PreferenceTrie
                {
                    /// The states in this trie. The index of a state in this vector is its ID.
                    states: Vec<State>,
                    /// This vec indicates which states are match states. It always has
                    matches: Vec<Option<NonZeroUsize>>,
                    /// The index to allocate to the next literal added to this trie. Starts at
                    next_literal_index: usize,
                }
                /// A single state in a trie. Uses a sparse representation for its transitions.
                #[derive(Debug, Default)]
                struct State
                {
                    /// Sparse representation of the transitions out of this state. Transitions
                    trans: Vec<(u8, usize)>,
                }

                impl PreferenceTrie
                {
                    /// Minimizes the given sequence of literals while preserving preference
                    fn minimize(literals: &mut Vec<Literal>, keep_exact: bool) {
                        let mut trie = PreferenceTrie {
                            states: vec![],
                            matches: vec![],
                            next_literal_index: 1,
                        };
                        let mut make_inexact = vec![];
                        literals.retain_mut(|lit| match trie.insert(lit.as_bytes()) {
                            Ok(_) => true,
                            Err(i) => {
                                if !keep_exact {
                                    make_inexact.push(i.checked_sub(1).unwrap());
                                }
                                false
                            }
                        });
                        for i in make_inexact {
                            literals[i].make_inexact();
                        }
                    }
                    /// Returns `Ok` if the given byte string is accepted into this trie and
                    fn insert(&mut self, bytes: &[u8]) -> Result<usize, usize> {
                        let mut prev = self.root();
                        
                        if let Some(idx) = self.matches[prev] {
                            return Err(idx.get());
                        }
                        for &b in bytes.iter() {
                            match self.states[prev].trans.binary_search_by_key(&b, |t| t.0) {
                                Ok(i) => {
                                    prev = self.states[prev].trans[i].1;
                                    if let Some(idx) = self.matches[prev] {
                                        return Err(idx.get());
                                    }
                                }
                                Err(i) => {
                                    let next = self.create_state();
                                    self.states[prev].trans.insert(i, (b, next));
                                    prev = next;
                                }
                            }
                        }
                        let idx = self.next_literal_index;
                        self.next_literal_index += 1;
                        self.matches[prev] = NonZeroUsize::new(idx);
                        Ok(idx)
                    }
                    /// Returns the root state ID, and if it doesn't exist, creates it.
                    fn root(&mut self) -> usize {
                        if !self.states.is_empty() {
                            0
                        } else {
                            self.create_state()
                        }
                    }
                    /// Creates a new empty state and returns its ID.
                    fn create_state(&mut self) -> usize {
                        let id = self.states.len();
                        self.states.push(State::default());
                        self.matches.push(None);
                        id
                    }
                }
                /// Returns the "rank" of the given byte.
                pub fn rank(byte: u8) -> u8 {
                    crate::rank::BYTE_FREQUENCIES[usize::from(byte)]
                }
            }

            pub mod print
            {
                /*!
                This module provides a regular expression printer for `Hir`. */
                use ::
                {
                    regex::syntax::
                    {
                        hir::
                        {
                            self,
                            visitor::{self, Visitor},
                            Hir, HirKind,
                        },
                        is_meta_character,
                    },
                    *,
                };
                /*
                */
                /// A builder for constructing a printer.
                #[derive(Clone, Debug)]
                struct PrinterBuilder
                {
                    _priv: (),
                }

                impl Default for PrinterBuilder
                {
                    fn default() -> PrinterBuilder {
                        PrinterBuilder::new()
                    }
                }

                impl PrinterBuilder
                {
                    fn new() -> PrinterBuilder {
                        PrinterBuilder { _priv: () }
                    }

                    fn build(&self) -> Printer {
                        Printer { _priv: () }
                    }
                }
                /// A printer for a regular expression's high-level intermediate
                #[derive(Debug)]
                pub struct Printer 
                {
                    _priv: (),
                }

                impl Printer
                {
                    /// Create a new printer.
                    pub fn new() -> Printer {
                        PrinterBuilder::new().build()
                    }
                    /// Print the given `Ast` to the given writer. The writer must implement
                    pub fn print<W: fmt::Write>(&mut self, hir: &Hir, wtr: W) -> fmt::Result {
                        visitor::visit(hir, Writer { wtr })
                    }
                }

                #[derive(Debug)]
                struct Writer<W> 
                {
                    wtr: W,
                }

                impl<W: fmt::Write> Visitor for Writer<W> 
                {
                    type Output = ();
                    type Err = fmt::Error;

                    fn finish(self) -> fmt::Result {
                        Ok(())
                    }

                    fn visit_pre(&mut self, hir: &Hir) -> fmt::Result {
                        match *hir.kind() {
                            HirKind::Empty => {
                                self.wtr.write_str(r"(?:)")?;
                            }
                            // Repetition operators are strictly suffix oriented.
                            HirKind::Repetition(_) => {}
                            HirKind::Literal(hir::Literal(ref bytes)) => {
                                let result = ::str::from_utf8(bytes);
                                let len = result.map_or(bytes.len(), |s| s.chars().count());
                                
                                if len > 1 {
                                    self.wtr.write_str(r"(?:")?;
                                }
                                match result {
                                    Ok(string) => {
                                        for c in string.chars() {
                                            self.write_literal_char(c)?;
                                        }
                                    }
                                    Err(_) => {
                                        for &b in bytes.iter() {
                                            self.write_literal_byte(b)?;
                                        }
                                    }
                                }
                                if len > 1 {
                                    self.wtr.write_str(r")")?;
                                }
                            }
                            HirKind::Class(hir::Class::Unicode(ref cls)) => {
                                if cls.ranges().is_empty() {
                                    return self.wtr.write_str("[a&&b]");
                                }
                                self.wtr.write_str("[")?;
                                for range in cls.iter() {
                                    if range.start() == range.end() {
                                        self.write_literal_char(range.start())?;
                                    } else if u32::from(range.start()) + 1
                                        == u32::from(range.end())
                                    {
                                        self.write_literal_char(range.start())?;
                                        self.write_literal_char(range.end())?;
                                    } else {
                                        self.write_literal_char(range.start())?;
                                        self.wtr.write_str("-")?;
                                        self.write_literal_char(range.end())?;
                                    }
                                }
                                self.wtr.write_str("]")?;
                            }
                            HirKind::Class(hir::Class::Bytes(ref cls)) => {
                                if cls.ranges().is_empty() {
                                    return self.wtr.write_str("[a&&b]");
                                }
                                self.wtr.write_str("(?-u:[")?;
                                for range in cls.iter() {
                                    if range.start() == range.end() {
                                        self.write_literal_class_byte(range.start())?;
                                    } else if range.start() + 1 == range.end() {
                                        self.write_literal_class_byte(range.start())?;
                                        self.write_literal_class_byte(range.end())?;
                                    } else {
                                        self.write_literal_class_byte(range.start())?;
                                        self.wtr.write_str("-")?;
                                        self.write_literal_class_byte(range.end())?;
                                    }
                                }
                                self.wtr.write_str("])")?;
                            }
                            HirKind::Look(ref look) => match *look {
                                hir::Look::Start => {
                                    self.wtr.write_str(r"\A")?;
                                }
                                hir::Look::End => {
                                    self.wtr.write_str(r"\z")?;
                                }
                                hir::Look::StartLF => {
                                    self.wtr.write_str("(?m:^)")?;
                                }
                                hir::Look::EndLF => {
                                    self.wtr.write_str("(?m:$)")?;
                                }
                                hir::Look::StartCRLF => {
                                    self.wtr.write_str("(?mR:^)")?;
                                }
                                hir::Look::EndCRLF => {
                                    self.wtr.write_str("(?mR:$)")?;
                                }
                                hir::Look::WordAscii => {
                                    self.wtr.write_str(r"(?-u:\b)")?;
                                }
                                hir::Look::WordAsciiNegate => {
                                    self.wtr.write_str(r"(?-u:\B)")?;
                                }
                                hir::Look::WordUnicode => {
                                    self.wtr.write_str(r"\b")?;
                                }
                                hir::Look::WordUnicodeNegate => {
                                    self.wtr.write_str(r"\B")?;
                                }
                                hir::Look::WordStartAscii => {
                                    self.wtr.write_str(r"(?-u:\b{start})")?;
                                }
                                hir::Look::WordEndAscii => {
                                    self.wtr.write_str(r"(?-u:\b{end})")?;
                                }
                                hir::Look::WordStartUnicode => {
                                    self.wtr.write_str(r"\b{start}")?;
                                }
                                hir::Look::WordEndUnicode => {
                                    self.wtr.write_str(r"\b{end}")?;
                                }
                                hir::Look::WordStartHalfAscii => {
                                    self.wtr.write_str(r"(?-u:\b{start-half})")?;
                                }
                                hir::Look::WordEndHalfAscii => {
                                    self.wtr.write_str(r"(?-u:\b{end-half})")?;
                                }
                                hir::Look::WordStartHalfUnicode => {
                                    self.wtr.write_str(r"\b{start-half}")?;
                                }
                                hir::Look::WordEndHalfUnicode => {
                                    self.wtr.write_str(r"\b{end-half}")?;
                                }
                            },
                            HirKind::Capture(hir::Capture { ref name, .. }) => {
                                self.wtr.write_str("(")?;
                                
                                if let Some(ref name) = *name {
                                    write!(self.wtr, "?P<{}>", name)?;
                                }
                            }
                            HirKind::Concat(_) | HirKind::Alternation(_) => {
                                self.wtr.write_str(r"(?:")?;
                            }
                        }
                        Ok(())
                    }

                    fn visit_post(&mut self, hir: &Hir) -> fmt::Result {
                        match *hir.kind() {
                            // Handled during visit_pre
                            HirKind::Empty
                            | HirKind::Literal(_)
                            | HirKind::Class(_)
                            | HirKind::Look(_) => {}
                            HirKind::Repetition(ref x) => {
                                match (x.min, x.max) {
                                    (0, Some(1)) => {
                                        self.wtr.write_str("?")?;
                                    }
                                    (0, None) => {
                                        self.wtr.write_str("*")?;
                                    }
                                    (1, None) => {
                                        self.wtr.write_str("+")?;
                                    }
                                    (1, Some(1)) => {
                                        // 'a{1}' and 'a{1}?' are exactly equivalent to 'a'.
                                        return Ok(());
                                    }
                                    (m, None) => {
                                        write!(self.wtr, "{{{},}}", m)?;
                                    }
                                    (m, Some(n)) if m == n => {
                                        write!(self.wtr, "{{{}}}", m)?;
                                        // a{m} and a{m}? are always exactly equivalent.
                                        return Ok(());
                                    }
                                    (m, Some(n)) => {
                                        write!(self.wtr, "{{{},{}}}", m, n)?;
                                    }
                                }
                                if !x.greedy {
                                    self.wtr.write_str("?")?;
                                }
                            }
                            HirKind::Capture(_)
                            | HirKind::Concat(_)
                            | HirKind::Alternation(_) => {
                                self.wtr.write_str(r")")?;
                            }
                        }
                        Ok(())
                    }

                    fn visit_alternation_in(&mut self) -> fmt::Result {
                        self.wtr.write_str("|")
                    }
                }

                impl<W: fmt::Write> Writer<W> 
                {
                    fn write_literal_char(&mut self, c: char) -> fmt::Result {
                        if is_meta_character(c) {
                            self.wtr.write_str("\\")?;
                        }
                        self.wtr.write_char(c)
                    }

                    fn write_literal_byte(&mut self, b: u8) -> fmt::Result {
                        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {
                            self.write_literal_char(char::try_from(b).unwrap())
                        } else {
                            write!(self.wtr, "(?-u:\\x{:02X})", b)
                        }
                    }

                    fn write_literal_class_byte(&mut self, b: u8) -> fmt::Result {
                        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {
                            self.write_literal_char(char::try_from(b).unwrap())
                        } else {
                            write!(self.wtr, "\\x{:02X}", b)
                        }
                    }
                }
            }

            pub mod translate
            {
                /*!
                Defines a translator that converts an `Ast` to an `Hir`. */
                use ::
                {
                    cell::{ Cell, RefCell },
                    boxed::Box,
                    regex::syntax::
                    {
                        ast::{self, Ast, Span, Visitor},
                        either::Either,
                        hir::{self, Error, ErrorKind, Hir, HirKind},
                        unicode::{self, ClassQuery},
                    },
                    string::ToString,                    
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                type Result<T> = ::result::Result<T, Error>;
                /// A builder for constructing an AST->HIR translator.
                #[derive(Clone, Debug)]
                pub struct TranslatorBuilder
                {
                    utf8: bool,
                    line_terminator: u8,
                    flags: Flags,
                }

                impl Default for TranslatorBuilder
                {
                    fn default() -> TranslatorBuilder {
                        TranslatorBuilder::new()
                    }
                }

                impl TranslatorBuilder
                {
                    /// Create a new translator builder with a default configuration.
                    pub fn new() -> TranslatorBuilder {
                        TranslatorBuilder {
                            utf8: true,
                            line_terminator: b'\n',
                            flags: Flags::default(),
                        }
                    }
                    /// Build a translator using the current configuration.
                    pub fn build(&self) -> Translator {
                        Translator {
                            stack: RefCell::new(vec![]),
                            flags: Cell::new(self.flags),
                            utf8: self.utf8,
                            line_terminator: self.line_terminator,
                        }
                    }
                    /// When disabled, translation will permit the construction of a regular
                    pub fn utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {
                        self.utf8 = yes;
                        self
                    }
                    /// Sets the line terminator for use with `(?u-s:.)` and `(?-us:.)`.
                    pub fn line_terminator(&mut self, byte: u8) -> &mut TranslatorBuilder {
                        self.line_terminator = byte;
                        self
                    }
                    /// Enable or disable the case insensitive flag (`i`) by default.
                    pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {
                        self.flags.case_insensitive = if yes { Some(true) } else { None };
                        self
                    }
                    /// Enable or disable the multi-line matching flag (`m`) by default.
                    pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {
                        self.flags.multi_line = if yes { Some(true) } else { None };
                        self
                    }
                    /// Enable or disable the "dot matches any character" flag (`s`) by
                    pub fn dot_matches_new_line
                    (
                        &mut self,
                        yes: bool,
                    ) -> &mut TranslatorBuilder {
                        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };
                        self
                    }
                    /// Enable or disable the CRLF mode flag (`R`) by default.
                    pub fn crlf(&mut self, yes: bool) -> &mut TranslatorBuilder {
                        self.flags.crlf = if yes { Some(true) } else { None };
                        self
                    }
                    /// Enable or disable the "swap greed" flag (`U`) by default.
                    pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {
                        self.flags.swap_greed = if yes { Some(true) } else { None };
                        self
                    }
                    /// Enable or disable the Unicode flag (`u`) by default.
                    pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {
                        self.flags.unicode = if yes { None } else { Some(false) };
                        self
                    }
                }
                /// A translator maps abstract syntax to a high level intermediate
                #[derive(Clone, Debug)]
                pub struct Translator
                {
                    /// Our call stack, but on the heap.
                    stack: RefCell<Vec<HirFrame>>,
                    /// The current flag settings.
                    flags: Cell<Flags>,
                    /// Whether we're allowed to produce HIR that can match arbitrary bytes.
                    utf8: bool,
                    /// The line terminator to use for `.`.
                    line_terminator: u8,
                }

                impl Translator
                {
                    /// Create a new translator using the default configuration.
                    pub fn new() -> Translator {
                        TranslatorBuilder::new().build()
                    }
                    /// Translate the given abstract syntax tree (AST) into a high level
                    pub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir> {
                        ast::visit(ast, TranslatorI::new(self, pattern))
                    }
                }
                /// An HirFrame is a single stack frame, represented explicitly, which is
                #[derive(Clone, Debug)]
                enum HirFrame
                {
                    /// An arbitrary HIR expression. These get pushed whenever we hit a base
                    Expr(Hir),
                    /// A literal that is being constructed, character by character, from the
                    Literal(Vec<u8>),
                    /// A Unicode character class. This frame is mutated as we descend into
                    ClassUnicode(hir::ClassUnicode),
                    /// A byte-oriented character class. This frame is mutated as we descend
                    ClassBytes(hir::ClassBytes),
                    /// This is pushed whenever a repetition is observed. After visiting every
                    Repetition,
                    /// This is pushed on to the stack upon first seeing any kind of capture,
                    Group {
                        /// The old active flags when this group was opened.
                        old_flags: Flags,
                    },
                    /// This is pushed whenever a concatenation is observed. After visiting
                    Concat,
                    /// This is pushed whenever an alternation is observed. After visiting
                    Alternation,
                    /// This is pushed immediately before each sub-expression in an
                    AlternationBranch,
                }

                impl HirFrame
                {
                    /// Assert that the current stack frame is an Hir expression and return it.
                    fn unwrap_expr(self) -> Hir {
                        match self {
                            HirFrame::Expr(expr) => expr,
                            HirFrame::Literal(lit) => Hir::literal(lit),
                            _ => panic!("tried to unwrap expr from HirFrame, got: {:?}", self),
                        }
                    }
                    /// Assert that the current stack frame is a Unicode class expression and
                    fn unwrap_class_unicode(self) -> hir::ClassUnicode {
                        match self {
                            HirFrame::ClassUnicode(cls) => cls,
                            _ => panic!(
                                "tried to unwrap Unicode class \
                                from HirFrame, got: {:?}",
                                self
                            ),
                        }
                    }
                    /// Assert that the current stack frame is a byte class expression and
                    fn unwrap_class_bytes(self) -> hir::ClassBytes {
                        match self {
                            HirFrame::ClassBytes(cls) => cls,
                            _ => panic!(
                                "tried to unwrap byte class \
                                from HirFrame, got: {:?}",
                                self
                            ),
                        }
                    }
                    /// Assert that the current stack frame is a repetition sentinel. If it
                    fn unwrap_repetition(self) {
                        match self {
                            HirFrame::Repetition => {}
                            _ => {
                                panic!(
                                    "tried to unwrap repetition from HirFrame, got: {:?}",
                                    self
                                )
                            }
                        }
                    }
                    /// Assert that the current stack frame is a group indicator and return
                    fn unwrap_group(self) -> Flags {
                        match self {
                            HirFrame::Group { old_flags } => old_flags,
                            _ => {
                                panic!("tried to unwrap group from HirFrame, got: {:?}", self)
                            }
                        }
                    }
                    /// Assert that the current stack frame is an alternation pipe sentinel. If
                    fn unwrap_alternation_pipe(self) {
                        match self {
                            HirFrame::AlternationBranch => {}
                            _ => {
                                panic!(
                                    "tried to unwrap alt pipe from HirFrame, got: {:?}",
                                    self
                                )
                            }
                        }
                    }
                }

                impl<'t, 'p> Visitor for TranslatorI<'t, 'p>
                {
                    type Output = Hir;
                    type Err = Error;

                    fn finish(self) -> Result<Hir> {
                        // ... otherwise, we should have exactly one HIR on the stack.
                        assert_eq!(self.trans().stack.borrow().len(), 1);
                        Ok(self.pop().unwrap().unwrap_expr())
                    }

                    fn visit_pre(&mut self, ast: &Ast) -> Result<()> {
                        match *ast {
                            Ast::ClassBracketed(_) => {
                                if self.flags().unicode() {
                                    let cls = hir::ClassUnicode::empty();
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let cls = hir::ClassBytes::empty();
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            Ast::Repetition(_) => self.push(HirFrame::Repetition),
                            Ast::Group(ref x) => {
                                let old_flags = x
                                    .flags()
                                    .map(|ast| self.set_flags(ast))
                                    .unwrap_or_else(|| self.flags());
                                self.push(HirFrame::Group { old_flags });
                            }
                            Ast::Concat(_) => {
                                self.push(HirFrame::Concat);
                            }
                            Ast::Alternation(ref x) => {
                                self.push(HirFrame::Alternation);
                                
                                if !x.asts.is_empty() {
                                    self.push(HirFrame::AlternationBranch);
                                }
                            }
                            _ => {}
                        }
                        Ok(())
                    }

                    fn visit_post(&mut self, ast: &Ast) -> Result<()> {
                        match *ast {
                            Ast::Empty(_) => {
                                self.push(HirFrame::Expr(Hir::empty()));
                            }
                            Ast::Flags(ref x) => {
                                self.set_flags(&x.flags);
                                self.push(HirFrame::Expr(Hir::empty()));
                            }
                            Ast::Literal(ref x) => match self.ast_literal_to_scalar(x)? {
                                Either::Right(byte) => self.push_byte(byte),
                                Either::Left(ch) => match self.case_fold_char(x.span, ch)? {
                                    None => self.push_char(ch),
                                    Some(expr) => self.push(HirFrame::Expr(expr)),
                                },
                            },
                            Ast::Dot(ref span) => {
                                self.push(HirFrame::Expr(self.hir_dot(**span)?));
                            }
                            Ast::Assertion(ref x) => {
                                self.push(HirFrame::Expr(self.hir_assertion(x)?));
                            }
                            Ast::ClassPerl(ref x) => {
                                if self.flags().unicode() {
                                    let cls = self.hir_perl_unicode_class(x)?;
                                    let hcls = hir::Class::Unicode(cls);
                                    self.push(HirFrame::Expr(Hir::class(hcls)));
                                } else {
                                    let cls = self.hir_perl_byte_class(x)?;
                                    let hcls = hir::Class::Bytes(cls);
                                    self.push(HirFrame::Expr(Hir::class(hcls)));
                                }
                            }
                            Ast::ClassUnicode(ref x) => {
                                let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);
                                self.push(HirFrame::Expr(Hir::class(cls)));
                            }
                            Ast::ClassBracketed(ref ast) => {
                                if self.flags().unicode() {
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    self.unicode_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls,
                                    )?;
                                    let expr = Hir::class(hir::Class::Unicode(cls));
                                    self.push(HirFrame::Expr(expr));
                                } else {
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    self.bytes_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls,
                                    )?;
                                    let expr = Hir::class(hir::Class::Bytes(cls));
                                    self.push(HirFrame::Expr(expr));
                                }
                            }
                            Ast::Repetition(ref x) => {
                                let expr = self.pop().unwrap().unwrap_expr();
                                self.pop().unwrap().unwrap_repetition();
                                self.push(HirFrame::Expr(self.hir_repetition(x, expr)));
                            }
                            Ast::Group(ref x) => {
                                let expr = self.pop().unwrap().unwrap_expr();
                                let old_flags = self.pop().unwrap().unwrap_group();
                                self.trans().flags.set(old_flags);
                                self.push(HirFrame::Expr(self.hir_capture(x, expr)));
                            }
                            Ast::Concat(_) => {
                                let mut exprs = vec![];
                                while let Some(expr) = self.pop_concat_expr() {
                                    if !matches!(*expr.kind(), HirKind::Empty) {
                                        exprs.push(expr);
                                    }
                                }
                                exprs.reverse();
                                self.push(HirFrame::Expr(Hir::concat(exprs)));
                            }
                            Ast::Alternation(_) => {
                                let mut exprs = vec![];
                                while let Some(expr) = self.pop_alt_expr() {
                                    self.pop().unwrap().unwrap_alternation_pipe();
                                    exprs.push(expr);
                                }
                                exprs.reverse();
                                self.push(HirFrame::Expr(Hir::alternation(exprs)));
                            }
                        }
                        Ok(())
                    }

                    fn visit_alternation_in(&mut self) -> Result<()> {
                        self.push(HirFrame::AlternationBranch);
                        Ok(())
                    }

                    fn visit_class_set_item_pre
                    (
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        match *ast {
                            ast::ClassSetItem::Bracketed(_) => {
                                if self.flags().unicode() {
                                    let cls = hir::ClassUnicode::empty();
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let cls = hir::ClassBytes::empty();
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            _ => {}
                        }
                        Ok(())
                    }

                    fn visit_class_set_item_post
                    (
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        match *ast {
                            ast::ClassSetItem::Empty(_) => {}
                            ast::ClassSetItem::Literal(ref x) => {
                                if self.flags().unicode() {
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    let byte = self.class_literal_byte(x)?;
                                    cls.push(hir::ClassBytesRange::new(byte, byte));
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Range(ref x) => {
                                if self.flags().unicode() {
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    let start = self.class_literal_byte(&x.start)?;
                                    let end = self.class_literal_byte(&x.end)?;
                                    cls.push(hir::ClassBytesRange::new(start, end));
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Ascii(ref x) => {
                                if self.flags().unicode() {
                                    let xcls = self.hir_ascii_unicode_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let xcls = self.hir_ascii_byte_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Unicode(ref x) => {
                                let xcls = self.hir_unicode_class(x)?;
                                let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                cls.union(&xcls);
                                self.push(HirFrame::ClassUnicode(cls));
                            }
                            ast::ClassSetItem::Perl(ref x) => {
                                if self.flags().unicode() {
                                    let xcls = self.hir_perl_unicode_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let xcls = self.hir_perl_byte_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Bracketed(ref ast) => {
                                if self.flags().unicode() {
                                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();
                                    self.unicode_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls1,
                                    )?;

                                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();
                                    cls2.union(&cls1);
                                    self.push(HirFrame::ClassUnicode(cls2));
                                } else {
                                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();
                                    self.bytes_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls1,
                                    )?;

                                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();
                                    cls2.union(&cls1);
                                    self.push(HirFrame::ClassBytes(cls2));
                                }
                            }
                            // This is handled automatically by the visitor.
                            ast::ClassSetItem::Union(_) => {}
                        }
                        Ok(())
                    }

                    fn visit_class_set_binary_op_pre
                    (
                        &mut self,
                        _op: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        if self.flags().unicode() {
                            let cls = hir::ClassUnicode::empty();
                            self.push(HirFrame::ClassUnicode(cls));
                        } else {
                            let cls = hir::ClassBytes::empty();
                            self.push(HirFrame::ClassBytes(cls));
                        }
                        Ok(())
                    }

                    fn visit_class_set_binary_op_in
                    (
                        &mut self,
                        _op: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        if self.flags().unicode() {
                            let cls = hir::ClassUnicode::empty();
                            self.push(HirFrame::ClassUnicode(cls));
                        } else {
                            let cls = hir::ClassBytes::empty();
                            self.push(HirFrame::ClassBytes(cls));
                        }
                        Ok(())
                    }

                    fn visit_class_set_binary_op_post
                    (
                        &mut self,
                        op: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        use ::regex::syntax::ast::ClassSetBinaryOpKind::*;

                        if self.flags().unicode() {
                            let mut rhs = self.pop().unwrap().unwrap_class_unicode();
                            let mut lhs = self.pop().unwrap().unwrap_class_unicode();
                            let mut cls = self.pop().unwrap().unwrap_class_unicode();
                            if self.flags().case_insensitive() {
                                rhs.try_case_fold_simple().map_err(|_| {
                                    self.error(
                                        op.rhs.span().clone(),
                                        ErrorKind::UnicodeCaseUnavailable,
                                    )
                                })?;
                                lhs.try_case_fold_simple().map_err(|_| {
                                    self.error(
                                        op.lhs.span().clone(),
                                        ErrorKind::UnicodeCaseUnavailable,
                                    )
                                })?;
                            }
                            match op.kind {
                                Intersection => lhs.intersect(&rhs),
                                Difference => lhs.difference(&rhs),
                                SymmetricDifference => lhs.symmetric_difference(&rhs),
                            }
                            cls.union(&lhs);
                            self.push(HirFrame::ClassUnicode(cls));
                        } else {
                            let mut rhs = self.pop().unwrap().unwrap_class_bytes();
                            let mut lhs = self.pop().unwrap().unwrap_class_bytes();
                            let mut cls = self.pop().unwrap().unwrap_class_bytes();
                            if self.flags().case_insensitive() {
                                rhs.case_fold_simple();
                                lhs.case_fold_simple();
                            }
                            match op.kind {
                                Intersection => lhs.intersect(&rhs),
                                Difference => lhs.difference(&rhs),
                                SymmetricDifference => lhs.symmetric_difference(&rhs),
                            }
                            cls.union(&lhs);
                            self.push(HirFrame::ClassBytes(cls));
                        }
                        Ok(())
                    }
                }
                /// The internal implementation of a translator.
                #[derive(Clone, Debug)]
                struct TranslatorI<'t, 'p>
                {
                    trans: &'t Translator,
                    pattern: &'p str,
                }

                impl<'t, 'p> TranslatorI<'t, 'p>
                {
                    /// Build a new internal translator.
                    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {
                        TranslatorI { trans, pattern }
                    }
                    /// Return a reference to the underlying translator.
                    fn trans(&self) -> &Translator {
                        &self.trans
                    }
                    /// Push the given frame on to the call stack.
                    fn push(&self, frame: HirFrame) {
                        self.trans().stack.borrow_mut().push(frame);
                    }
                    /// Push the given literal char on to the call stack.
                    fn push_char(&self, ch: char) {
                        let mut buf = [0; 4];
                        let bytes = ch.encode_utf8(&mut buf).as_bytes();
                        let mut stack = self.trans().stack.borrow_mut();
                        
                        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {
                            literal.extend_from_slice(bytes);
                        } else {
                            stack.push(HirFrame::Literal(bytes.to_vec()));
                        }
                    }
                    /// Push the given literal byte on to the call stack.
                    fn push_byte(&self, byte: u8) {
                        let mut stack = self.trans().stack.borrow_mut();
                        
                        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {
                            literal.push(byte);
                        } else {
                            stack.push(HirFrame::Literal(vec![byte]));
                        }
                    }
                    /// Pop the top of the call stack. If the call stack is empty, return None.
                    fn pop(&self) -> Option<HirFrame> {
                        self.trans().stack.borrow_mut().pop()
                    }
                    /// Pop an HIR expression from the top of the stack for a concatenation.
                    fn pop_concat_expr(&self) -> Option<Hir> {
                        let frame = self.pop()?;
                        match frame {
                            HirFrame::Concat => None,
                            HirFrame::Expr(expr) => Some(expr),
                            HirFrame::Literal(lit) => Some(Hir::literal(lit)),
                            HirFrame::ClassUnicode(_) => {
                                unreachable!("expected expr or concat, got Unicode class")
                            }
                            HirFrame::ClassBytes(_) => {
                                unreachable!("expected expr or concat, got byte class")
                            }
                            HirFrame::Repetition => {
                                unreachable!("expected expr or concat, got repetition")
                            }
                            HirFrame::Group { .. } => {
                                unreachable!("expected expr or concat, got group")
                            }
                            HirFrame::Alternation => {
                                unreachable!("expected expr or concat, got alt marker")
                            }
                            HirFrame::AlternationBranch => {
                                unreachable!("expected expr or concat, got alt branch marker")
                            }
                        }
                    }
                    /// Pop an HIR expression from the top of the stack for an alternation.
                    fn pop_alt_expr(&self) -> Option<Hir> {
                        let frame = self.pop()?;
                        match frame {
                            HirFrame::Alternation => None,
                            HirFrame::Expr(expr) => Some(expr),
                            HirFrame::Literal(lit) => Some(Hir::literal(lit)),
                            HirFrame::ClassUnicode(_) => {
                                unreachable!("expected expr or alt, got Unicode class")
                            }
                            HirFrame::ClassBytes(_) => {
                                unreachable!("expected expr or alt, got byte class")
                            }
                            HirFrame::Repetition => {
                                unreachable!("expected expr or alt, got repetition")
                            }
                            HirFrame::Group { .. } => {
                                unreachable!("expected expr or alt, got group")
                            }
                            HirFrame::Concat => {
                                unreachable!("expected expr or alt, got concat marker")
                            }
                            HirFrame::AlternationBranch => {
                                unreachable!("expected expr or alt, got alt branch marker")
                            }
                        }
                    }
                    /// Create a new error with the given span and error type.
                    fn error(&self, span: Span, kind: ErrorKind) -> Error {
                        Error { kind, pattern: self.pattern.to_string(), span }
                    }
                    /// Return a copy of the active flags.
                    fn flags(&self) -> Flags {
                        self.trans().flags.get()
                    }
                    /// Set the flags of this translator from the flags set in the given AST.
                    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {
                        let old_flags = self.flags();
                        let mut new_flags = Flags::from_ast(ast_flags);
                        new_flags.merge(&old_flags);
                        self.trans().flags.set(new_flags);
                        old_flags
                    }
                    /// Convert an Ast literal to its scalar representation.
                    fn ast_literal_to_scalar(
                        &self,
                        lit: &ast::Literal,
                    ) -> Result<Either<char, u8>> {
                        if self.flags().unicode() {
                            return Ok(Either::Left(lit.c));
                        }
                        let byte = match lit.byte() {
                            None => return Ok(Either::Left(lit.c)),
                            Some(byte) => byte,
                        };
                        
                        if byte <= 0x7F {
                            return Ok(Either::Left(char::try_from(byte).unwrap()));
                        }
                        
                        if self.trans().utf8 {
                            return Err(self.error(lit.span, ErrorKind::InvalidUtf8));
                        }
                        Ok(Either::Right(byte))
                    }

                    fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {
                        if !self.flags().case_insensitive() {
                            return Ok(None);
                        }
                        
                        if self.flags().unicode() {
                            // If case folding won't do anything, then don't bother trying.
                            let map = unicode::SimpleCaseFolder::new()
                                .map(|f| f.overlaps(c, c))
                                .map_err(|_| {
                                    self.error(span, ErrorKind::UnicodeCaseUnavailable)
                                })?;
                            if !map {
                                return Ok(None);
                            }
                            let mut cls =
                                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(
                                    c, c,
                                )]);
                            cls.try_case_fold_simple().map_err(|_| {
                                self.error(span, ErrorKind::UnicodeCaseUnavailable)
                            })?;
                            Ok(Some(Hir::class(hir::Class::Unicode(cls))))
                        } else {
                            if !c.is_ascii() {
                                return Ok(None);
                            }
                            // If case folding won't do anything, then don't bother trying.
                            match c {
                                'A'..='Z' | 'a'..='z' => {}
                                _ => return Ok(None),
                            }
                            let mut cls =
                                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(
                                    u8::try_from(c).unwrap(),
                                    u8::try_from(c).unwrap(),
                                )]);
                            cls.case_fold_simple();
                            Ok(Some(Hir::class(hir::Class::Bytes(cls))))
                        }
                    }

                    fn hir_dot(&self, span: Span) -> Result<Hir> {
                        let (utf8, lineterm, flags) =
                            (self.trans().utf8, self.trans().line_terminator, self.flags());
                        
                        if utf8 && (!flags.unicode() || !lineterm.is_ascii()) {
                            return Err(self.error(span, ErrorKind::InvalidUtf8));
                        }
                        let dot = if flags.dot_matches_new_line()
                        {
                            if flags.unicode() {
                                hir::Dot::AnyChar
                            } else {
                                hir::Dot::AnyByte
                            }
                        } else {
                            if flags.unicode()
                            {
                                if flags.crlf() {
                                    hir::Dot::AnyCharExceptCRLF
                                } else {
                                    if !lineterm.is_ascii() {
                                        return Err(
                                            self.error(span, ErrorKind::InvalidLineTerminator)
                                        );
                                    }
                                    hir::Dot::AnyCharExcept(char::from(lineterm))
                                }
                            } else {
                                if flags.crlf() {
                                    hir::Dot::AnyByteExceptCRLF
                                } else {
                                    hir::Dot::AnyByteExcept(lineterm)
                                }
                            }
                        };
                        Ok(Hir::dot(dot))
                    }

                    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {
                        let unicode = self.flags().unicode();
                        let multi_line = self.flags().multi_line();
                        let crlf = self.flags().crlf();
                        Ok(match asst.kind {
                            ast::AssertionKind::StartLine => Hir::look(if multi_line {
                                if crlf {
                                    hir::Look::StartCRLF
                                } else {
                                    hir::Look::StartLF
                                }
                            } else {
                                hir::Look::Start
                            }),
                            ast::AssertionKind::EndLine => Hir::look(if multi_line {
                                if crlf {
                                    hir::Look::EndCRLF
                                } else {
                                    hir::Look::EndLF
                                }
                            } else {
                                hir::Look::End
                            }),
                            ast::AssertionKind::StartText => Hir::look(hir::Look::Start),
                            ast::AssertionKind::EndText => Hir::look(hir::Look::End),
                            ast::AssertionKind::WordBoundary => Hir::look(if unicode {
                                hir::Look::WordUnicode
                            } else {
                                hir::Look::WordAscii
                            }),
                            ast::AssertionKind::NotWordBoundary => Hir::look(if unicode {
                                hir::Look::WordUnicodeNegate
                            } else {
                                hir::Look::WordAsciiNegate
                            }),
                            ast::AssertionKind::WordBoundaryStart
                            | ast::AssertionKind::WordBoundaryStartAngle => {
                                Hir::look(if unicode {
                                    hir::Look::WordStartUnicode
                                } else {
                                    hir::Look::WordStartAscii
                                })
                            }
                            ast::AssertionKind::WordBoundaryEnd
                            | ast::AssertionKind::WordBoundaryEndAngle => {
                                Hir::look(if unicode {
                                    hir::Look::WordEndUnicode
                                } else {
                                    hir::Look::WordEndAscii
                                })
                            }
                            ast::AssertionKind::WordBoundaryStartHalf => {
                                Hir::look(if unicode {
                                    hir::Look::WordStartHalfUnicode
                                } else {
                                    hir::Look::WordStartHalfAscii
                                })
                            }
                            ast::AssertionKind::WordBoundaryEndHalf => Hir::look(if unicode {
                                hir::Look::WordEndHalfUnicode
                            } else {
                                hir::Look::WordEndHalfAscii
                            }),
                        })
                    }

                    fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {
                        let (index, name) = match group.kind {
                            ast::GroupKind::CaptureIndex(index) => (index, None),
                            ast::GroupKind::CaptureName { ref name, .. } => {
                                (name.index, Some(name.name.clone().into_boxed_str()))
                            }
                            ast::GroupKind::NonCapturing(_) => return expr,
                        };
                        Hir::capture(hir::Capture { index, name, sub: Box::new(expr) })
                    }

                    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir 
                    {
                        let (min, max) = match rep.op.kind 
                        {
                            ast::RepetitionKind::ZeroOrOne => (0, Some(1)),
                            ast::RepetitionKind::ZeroOrMore => (0, None),
                            ast::RepetitionKind::OneOrMore => (1, None),
                            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {
                                (m, Some(m))
                            }
                            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {
                                (m, None)
                            }
                            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(
                                m,
                                n,
                            )) => (m, Some(n)),
                        };

                        let greedy = if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };

                        Hir::repetition
                        (
                            hir::Repetition 
                            {
                                min,
                                max,
                                greedy,
                                sub: Box::new(expr),
                            }
                        )
                    }

                    fn hir_unicode_class
                    (
                        &self,
                        ast_class: &ast::ClassUnicode,
                    ) -> Result<hir::ClassUnicode>
                    {
                        use ::regex::syntax::ast::ClassUnicodeKind::*;

                        if !self.flags().unicode()
                        {
                            return Err
                            (
                                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)
                            );
                        }

                        let query = match ast_class.kind
                        {
                            OneLetter(name) => ClassQuery::OneLetter(name),
                            Named(ref name) => ClassQuery::Binary(name),
                            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue
                            {
                                property_name: name,
                                property_value: value,
                            },
                        };

                        let mut result = self.convert_unicode_class_error( &ast_class.span, unicode::class(query) );
                        
                        if let Ok(ref mut class) = result
                        {
                            self.unicode_fold_and_negate
                            (
                                &ast_class.span,
                                ast_class.negated,
                                class,
                            )?;
                        }

                        result
                    }

                    fn hir_ascii_unicode_class
                    (
                        &self,
                        ast: &ast::ClassAscii,
                    ) -> Result<hir::ClassUnicode> 
                    {
                        let mut cls = hir::ClassUnicode::new
                        (
                            ascii_class_as_chars(&ast.kind)
                            .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),
                        );

                        self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
                        Ok(cls)
                    }

                    fn hir_ascii_byte_class
                    (
                        &self,
                        ast: &ast::ClassAscii,
                    ) -> Result<hir::ClassBytes>
                    {
                        let mut cls = hir::ClassBytes::new
                        (
                            ascii_class(&ast.kind)
                            .map(|(s, e)| hir::ClassBytesRange::new(s, e))
                        );

                        self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
                        Ok(cls)
                    }

                    fn hir_perl_unicode_class
                    (
                        &self,
                        ast_class: &ast::ClassPerl,
                    ) -> Result<hir::ClassUnicode> 
                    {
                        use ::regex::syntax::ast::ClassPerlKind::*;

                        assert!(self.flags().unicode());
                        
                        let result = match ast_class.kind
                        {
                            Digit => unicode::perl_digit(),
                            Space => unicode::perl_space(),
                            Word => unicode::perl_word(),
                        };

                        let mut class = self.convert_unicode_class_error(&ast_class.span, result)?;
                        
                        if ast_class.negated { class.negate(); }

                        Ok(class)
                    }

                    fn hir_perl_byte_class
                    (
                        &self,
                        ast_class: &ast::ClassPerl,
                    ) -> Result<hir::ClassBytes>
                    {
                        use ::regex::syntax::ast::ClassPerlKind::*;

                        assert!(!self.flags().unicode());
                        let mut class = match ast_class.kind
                        {
                            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),
                            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),
                            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),
                        };
                        
                        if ast_class.negated { class.negate(); }
                        
                        if self.trans().utf8 && !class.is_ascii()
                        { return Err(self.error(ast_class.span, ErrorKind::InvalidUtf8)); }

                        Ok(class)
                    }
                    /// Converts the given Unicode specific error to an HIR translation error.
                    fn convert_unicode_class_error
                    (
                        &self,
                        span: &Span,
                        result: ::result::Result<hir::ClassUnicode, unicode::Error>,
                    ) -> Result<hir::ClassUnicode>
                    {
                        result.map_err(|err|
                        {
                            let sp = span.clone();
                            match err
                            {
                                unicode::Error::PropertyNotFound =>
                                { self.error(sp, ErrorKind::UnicodePropertyNotFound) }

                                unicode::Error::PropertyValueNotFound =>
                                { self.error(sp, ErrorKind::UnicodePropertyValueNotFound) }

                                unicode::Error::PerlClassNotFound =>
                                { self.error(sp, ErrorKind::UnicodePerlClassNotFound) }
                            }
                        })
                    }

                    fn unicode_fold_and_negate
                    (
                        &self,
                        span: &Span,
                        negated: bool,
                        class: &mut hir::ClassUnicode,
                    ) -> Result<()>
                    {
                        if self.flags().case_insensitive()
                        {
                            class.try_case_fold_simple().map_err(|_|
                            {
                                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)
                            })?;
                        }
                        
                        if negated { class.negate(); }

                        Ok(())
                    }

                    fn bytes_fold_and_negate
                    (
                        &self,
                        span: &Span,
                        negated: bool,
                        class: &mut hir::ClassBytes,
                    ) -> Result<()> 
                    {
                        if self.flags().case_insensitive() { class.case_fold_simple(); }
                        
                        if negated { class.negate(); }
                        
                        if self.trans().utf8 && !class.is_ascii()
                        { return Err(self.error(span.clone(), ErrorKind::InvalidUtf8)); }

                        Ok(())
                    }
                    /// Return a scalar byte value suitable for use as a literal in a byte
                    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8>
                    {
                        match self.ast_literal_to_scalar(ast)?
                        {
                            Either::Right(byte) => Ok(byte),
                            Either::Left(ch) =>
                            {
                                if ch.is_ascii() { Ok(u8::try_from(ch).unwrap()) }
                                else { Err(self.error(ast.span, ErrorKind::UnicodeNotAllowed)) }
                            }
                        }
                    }
                }
                /// A translator's representation of a regular expression's flags at any given
                #[derive(Clone, Copy, Debug, Default)]
                struct Flags
                {
                    case_insensitive: Option<bool>,
                    multi_line: Option<bool>,
                    dot_matches_new_line: Option<bool>,
                    swap_greed: Option<bool>,
                    unicode: Option<bool>,
                    crlf: Option<bool>,
                }

                impl Flags
                {
                    fn from_ast(ast: &ast::Flags) -> Flags
                    {
                        let mut flags = Flags::default();
                        let mut enable = true;
                        
                        for item in &ast.items
                        {
                            match item.kind
                            {
                                ast::FlagsItemKind::Negation => 
                                { enable = false; }

                                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => 
                                { flags.case_insensitive = Some(enable); }

                                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => 
                                { flags.multi_line = Some(enable); }

                                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) =>
                                { flags.dot_matches_new_line = Some(enable); }

                                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) =>
                                { flags.swap_greed = Some(enable); }

                                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => { flags.unicode = Some(enable); }

                                ast::FlagsItemKind::Flag(ast::Flag::CRLF) => { flags.crlf = Some(enable); }

                                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}
                            }
                        }

                        flags
                    }

                    fn merge(&mut self, previous: &Flags)
                    {
                        if self.case_insensitive.is_none() { self.case_insensitive = previous.case_insensitive; }
                        
                        if self.multi_line.is_none() { self.multi_line = previous.multi_line; }
                        
                        if self.dot_matches_new_line.is_none()
                        { self.dot_matches_new_line = previous.dot_matches_new_line; }
                        
                        if self.swap_greed.is_none() { self.swap_greed = previous.swap_greed; }
                        
                        if self.unicode.is_none() { self.unicode = previous.unicode; }
                        
                        if self.crlf.is_none() { self.crlf = previous.crlf; }
                    }

                    fn case_insensitive(&self) -> bool { self.case_insensitive.unwrap_or(false) }

                    fn multi_line(&self) -> bool { self.multi_line.unwrap_or(false) }

                    fn dot_matches_new_line(&self) -> bool { self.dot_matches_new_line.unwrap_or(false) }

                    fn swap_greed(&self) -> bool { self.swap_greed.unwrap_or(false) }

                    fn unicode(&self) -> bool { self.unicode.unwrap_or(true) }

                    fn crlf(&self) -> bool { self.crlf.unwrap_or(false) }
                }

                fn hir_ascii_class_bytes(kind: &ast::ClassAsciiKind) -> hir::ClassBytes
                {
                    let ranges: Vec<_> = ascii_class(kind)
                    .map(|(s, e)| hir::ClassBytesRange::new(s, e))
                    .collect();

                    hir::ClassBytes::new(ranges)
                }

                fn ascii_class(kind: &ast::ClassAsciiKind) -> impl Iterator<Item = (u8, u8)>
                {
                    use ::regex::syntax::ast::ClassAsciiKind::*;

                    let slice: &'static [(u8, u8)] = match *kind 
                    {
                        Alnum => &[(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')],
                        Alpha => &[(b'A', b'Z'), (b'a', b'z')],
                        Ascii => &[(b'\x00', b'\x7F')],
                        Blank => &[(b'\t', b'\t'), (b' ', b' ')],
                        Cntrl => &[(b'\x00', b'\x1F'), (b'\x7F', b'\x7F')],
                        Digit => &[(b'0', b'9')],
                        Graph => &[(b'!', b'~')],
                        Lower => &[(b'a', b'z')],
                        Print => &[(b' ', b'~')],
                        Punct => &[(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')],
                        Space => &
                        [
                            (b'\t', b'\t'),
                            (b'\n', b'\n'),
                            (b'\x0B', b'\x0B'),
                            (b'\x0C', b'\x0C'),
                            (b'\r', b'\r'),
                            (b' ', b' '),
                        ],
                        Upper => &[(b'A', b'Z')],
                        Word => &[(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')],
                        Xdigit => &[(b'0', b'9'), (b'A', b'F'), (b'a', b'f')],
                    };

                    slice.iter().copied()
                }

                fn ascii_class_as_chars( kind: &ast::ClassAsciiKind ) -> impl Iterator<Item = (char, char)> 
                { ascii_class(kind).map(|(s, e)| (char::from(s), char::from(e))) }
            }

            pub mod visitor
            {
                /*!
                */
                use ::
                {
                    regex::syntax::{ hir::{ self, Hir, HirKind }, },
                    vec::{ self, Vec },
                    *,
                };
                /*
                */
                /// A trait for visiting the high-level IR (HIR) in depth first order.
                pub trait Visitor
                {
                    /// The result of visiting an HIR.
                    type Output;
                    /// An error that visiting an HIR might return.
                    type Err;
                    /// All implementors of `Visitor` must provide a `finish` method, which
                    fn finish(self) -> Result<Self::Output, Self::Err>;
                    /// This method is called before beginning traversal of the HIR.
                    fn start(&mut self) {}
                    /// This method is called on an `Hir` before descending into child `Hir`
                    fn visit_pre(&mut self, _hir: &Hir) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called on an `Hir` after descending all of its child
                    fn visit_post(&mut self, _hir: &Hir) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called between child nodes of an alternation.
                    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> { Ok(()) }
                    /// This method is called between child nodes of a concatenation.
                    fn visit_concat_in(&mut self) -> Result<(), Self::Err> { Ok(()) }
                }
                /// Executes an implementation of `Visitor` in constant stack space.
                pub fn visit<V: Visitor>(hir: &Hir, visitor: V) -> Result<V::Output, V::Err>
                { HeapVisitor::new().visit(hir, visitor) }
                /// HeapVisitor visits every item in an `Hir` recursively using constant stack
                struct HeapVisitor<'a>
                {
                    /// A stack of `Hir` nodes. This is roughly analogous to the call stack
                    stack: Vec<(&'a Hir, Frame<'a>)>,
                }
                /// Represents a single stack frame while performing structural induction over
                enum Frame<'a>
                {
                    /// A stack frame allocated just before descending into a repetition
                    Repetition(&'a hir::Repetition),
                    /// A stack frame allocated just before descending into a capture's child
                    Capture(&'a hir::Capture),
                    /// The stack frame used while visiting every child node of a concatenation
                    Concat
                    {
                        /// The child node we are currently visiting.
                        head: &'a Hir,
                        /// The remaining child nodes to visit (which may be empty).
                        tail: &'a [Hir],
                    },
                    /// The stack frame used while visiting every child node of an alternation
                    Alternation
                    {
                        /// The child node we are currently visiting.
                        head: &'a Hir,
                        /// The remaining child nodes to visit (which may be empty).
                        tail: &'a [Hir],
                    },
                }

                impl<'a> HeapVisitor<'a>
                {
                    fn new() -> HeapVisitor<'a> { HeapVisitor { stack: vec![] } }

                    fn visit<V: Visitor>
                    (
                        &mut self,
                        mut hir: &'a Hir,
                        mut visitor: V,
                    ) -> Result<V::Output, V::Err>
                    {
                        self.stack.clear();

                        visitor.start();

                        loop
                        {
                            visitor.visit_pre(hir)?;
                            if let Some(x) = self.induct(hir) {
                                let child = x.child();
                                self.stack.push((hir, x));
                                hir = child;
                                continue;
                            }
                            visitor.visit_post(hir)?;
                            loop {
                                let (post_hir, frame) = match self.stack.pop() {
                                    None => return visitor.finish(),
                                    Some((post_hir, frame)) => (post_hir, frame),
                                };
                                
                                if let Some(x) = self.pop(frame) {
                                    match x {
                                        Frame::Alternation { .. } => {
                                            visitor.visit_alternation_in()?;
                                        }
                                        Frame::Concat { .. } => {
                                            visitor.visit_concat_in()?;
                                        }
                                        _ => {}
                                    }
                                    hir = x.child();
                                    self.stack.push((post_hir, x));
                                    break;
                                }
                                visitor.visit_post(post_hir)?;
                            }
                        }
                    }
                    /// Build a stack frame for the given HIR if one is needed (which occurs if
                    fn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>> {
                        match *hir.kind() {
                            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),
                            HirKind::Capture(ref x) => Some(Frame::Capture(x)),
                            HirKind::Concat(ref x) if x.is_empty() => None,
                            HirKind::Concat(ref x) => {
                                Some(Frame::Concat { head: &x[0], tail: &x[1..] })
                            }
                            HirKind::Alternation(ref x) if x.is_empty() => None,
                            HirKind::Alternation(ref x) => {
                                Some(Frame::Alternation { head: &x[0], tail: &x[1..] })
                            }
                            _ => None,
                        }
                    }
                    /// Pops the given frame. If the frame has an additional inductive step,
                    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {
                        match induct {
                            Frame::Repetition(_) => None,
                            Frame::Capture(_) => None,
                            Frame::Concat { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })
                                }
                            }
                            Frame::Alternation { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Alternation {
                                        head: &tail[0],
                                        tail: &tail[1..],
                                    })
                                }
                            }
                        }
                    }
                }

                impl<'a> Frame<'a>
                {
                    /// Perform the next inductive step on this frame and return the next
                    fn child(&self) -> &'a Hir {
                        match *self {
                            Frame::Repetition(rep) => &rep.sub,
                            Frame::Capture(capture) => &capture.sub,
                            Frame::Concat { head, .. } => head,
                            Frame::Alternation { head, .. } => head,
                        }
                    }
                }
            }
            /// An error that can occur while translating an `Ast` to a `Hir`.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Error
            {
                /// The kind of error.
                kind: ErrorKind,
                /// The original pattern that the translator's Ast was parsed from. Every
                pattern: String,
                /// The span of this error, derived from the Ast given to the translator.
                span: Span,
            }

            impl Error
            {
                /// Return the type of this error.
                pub fn kind(&self) -> &ErrorKind {
                    &self.kind
                }
                /// The original pattern string in which this error occurred.
                pub fn pattern(&self) -> &str {
                    &self.pattern
                }
                /// Return the span at which this error occurred.
                pub fn span(&self) -> &Span {
                    &self.span
                }
            }
            /// The type of an error that occurred while building an `Hir`.
            #[non_exhaustive]
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum ErrorKind
            {
                /// This error occurs when a Unicode feature is used when Unicode
                UnicodeNotAllowed,
                /// This error occurs when translating a pattern that could match a byte
                InvalidUtf8,
                /// This error occurs when one uses a non-ASCII byte for a line terminator,
                InvalidLineTerminator,
                /// This occurs when an unrecognized Unicode property name could not
                UnicodePropertyNotFound,
                /// This occurs when an unrecognized Unicode property value could not
                UnicodePropertyValueNotFound,
                /// This occurs when a Unicode-aware Perl character class (`\w`, `\s` or
                UnicodePerlClassNotFound,
                /// This occurs when the Unicode simple case mapping tables are not
                UnicodeCaseUnavailable,
            }
            
            impl ::error::Error for Error {}

            impl ::fmt::Display for Error
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    crate::error::Formatter::from(self).fmt(f)
                }
            }

            impl ::fmt::Display for ErrorKind
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    use self::ErrorKind::*;

                    let msg = match *self {
                        UnicodeNotAllowed => "Unicode not allowed here",
                        InvalidUtf8 => "pattern can match invalid UTF-8",
                        InvalidLineTerminator => "invalid line terminator, must be ASCII",
                        UnicodePropertyNotFound => "Unicode property not found",
                        UnicodePropertyValueNotFound => "Unicode property value not found",
                        UnicodePerlClassNotFound => {
                            "Unicode-aware Perl class not found \
                            (make sure the unicode-perl feature is enabled)"
                        }
                        UnicodeCaseUnavailable => {
                            "Unicode-aware case insensitivity matching is not available \
                            (make sure the unicode-case feature is enabled)"
                        }
                    };
                    f.write_str(msg)
                }
            }
            /// A high-level intermediate representation (HIR) for a regular expression.
            #[derive(Clone, Eq, PartialEq)]
            pub struct Hir
            {
                /// The underlying HIR kind.
                kind: HirKind,
                /// Analysis info about this HIR, computed during construction.
                props: Properties,
            }
            /// Methods for accessing the underlying `HirKind` and `Properties`.
            impl Hir
            {
                /// Returns a reference to the underlying HIR kind.
                pub fn kind(&self) -> &HirKind {
                    &self.kind
                }
                /// Consumes ownership of this HIR expression and returns its underlying
                pub fn into_kind(mut self) -> HirKind {
                    ::mem::replace(&mut self.kind, HirKind::Empty)
                }
                /// Returns the properties computed for this `Hir`.
                pub fn properties(&self) -> &Properties {
                    &self.props
                }
                /// Splits this HIR into its constituent parts.
                fn into_parts(mut self) -> (HirKind, Properties) {
                    (
                        ::mem::replace(&mut self.kind, HirKind::Empty),
                        ::mem::replace(&mut self.props, Properties::empty()),
                    )
                }
            }
            /// Smart constructors for HIR values.
            impl Hir
            {
                /// Returns an empty HIR expression.
                #[inline] pub fn empty() -> Hir
                {
                    let props = Properties::empty();
                    Hir { kind: HirKind::Empty, props }
                }
                /// Returns an HIR expression that can never match anything. That is,
                #[inline] pub fn fail() -> Hir
                {
                    let class = Class::Bytes(ClassBytes::empty());
                    let props = Properties::class(&class);
                    Hir { kind: HirKind::Class(class), props }
                }
                /// Creates a literal HIR expression.
                #[inline] pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir
                {
                    let bytes = lit.into();
                    if bytes.is_empty() {
                        return Hir::empty();
                    }

                    let lit = Literal(bytes);
                    let props = Properties::literal(&lit);
                    Hir { kind: HirKind::Literal(lit), props }
                }
                /// Creates a class HIR expression. The class may either be defined over
                #[inline] pub fn class(class: Class) -> Hir {
                    if class.is_empty() {
                        return Hir::fail();
                    } else if let Some(bytes) = class.literal() {
                        return Hir::literal(bytes);
                    }
                    let props = Properties::class(&class);
                    Hir { kind: HirKind::Class(class), props }
                }
                /// Creates a look-around assertion HIR expression.
                #[inline] pub fn look(look: Look) -> Hir
                {
                    let props = Properties::look(look);
                    Hir { kind: HirKind::Look(look), props }
                }
                /// Creates a repetition HIR expression.
                #[inline] pub fn repetition(mut rep: Repetition) -> Hir {
                    if rep.sub.properties().maximum_len() == Some(0) {
                        rep.min = cmp::min(rep.min, 1);
                        rep.max = rep.max.map(|n| cmp::min(n, 1)).or(Some(1));
                    }
                    if rep.min == 0 && rep.max == Some(0) {
                        return Hir::empty();
                    } else if rep.min == 1 && rep.max == Some(1) {
                        return *rep.sub;
                    }
                    let props = Properties::repetition(&rep);
                    Hir { kind: HirKind::Repetition(rep), props }
                }
                /// Creates a capture HIR expression.
                #[inline] pub fn capture(capture: Capture) -> Hir
                {
                    let props = Properties::capture(&capture);
                    Hir { kind: HirKind::Capture(capture), props }
                }
                /// Returns the concatenation of the given expressions.
                pub fn concat(subs: Vec<Hir>) -> Hir
                {
                    let mut new = vec![];
                    let mut prior_lit: Option<Vec<u8>> = None;
                    
                    for sub in subs {
                        let (kind, props) = sub.into_parts();
                        match kind {
                            HirKind::Literal(Literal(bytes)) => {
                                if let Some(ref mut prior_bytes) = prior_lit {
                                    prior_bytes.extend_from_slice(&bytes);
                                } else {
                                    prior_lit = Some(bytes.to_vec());
                                }
                            }
                            HirKind::Concat(subs2) => {
                                for sub2 in subs2 {
                                    let (kind2, props2) = sub2.into_parts();
                                    match kind2 {
                                        HirKind::Literal(Literal(bytes)) => {
                                            if let Some(ref mut prior_bytes) = prior_lit {
                                                prior_bytes.extend_from_slice(&bytes);
                                            } else {
                                                prior_lit = Some(bytes.to_vec());
                                            }
                                        }
                                        kind2 => {
                                            if let Some(prior_bytes) = prior_lit.take() {
                                                new.push(Hir::literal(prior_bytes));
                                            }
                                            new.push(Hir { kind: kind2, props: props2 });
                                        }
                                    }
                                }
                            }
                            // We can just skip empty HIRs.
                            HirKind::Empty => {}
                            kind => {
                                if let Some(prior_bytes) = prior_lit.take() {
                                    new.push(Hir::literal(prior_bytes));
                                }
                                new.push(Hir { kind, props });
                            }
                        }
                    }
                    if let Some(prior_bytes) = prior_lit.take() {
                        new.push(Hir::literal(prior_bytes));
                    }
                    if new.is_empty() {
                        return Hir::empty();
                    } else if new.len() == 1 {
                        return new.pop().unwrap();
                    }
                    let props = Properties::concat(&new);
                    Hir { kind: HirKind::Concat(new), props }
                }
                /// Returns the alternation of the given expressions.
                pub fn alternation(subs: Vec<Hir>) -> Hir
                {
                    let mut new = Vec::with_capacity(subs.len());
                    
                    for sub in subs {
                        let (kind, props) = sub.into_parts();
                        match kind {
                            HirKind::Alternation(subs2) => {
                                new.extend(subs2);
                            }
                            kind => {
                                new.push(Hir { kind, props });
                            }
                        }
                    }
                    if new.is_empty() {
                        return Hir::fail();
                    } else if new.len() == 1 {
                        return new.pop().unwrap();
                    }
                    if let Some(singletons) = singleton_chars(&new) {
                        let it = singletons
                            .into_iter()
                            .map(|ch| ClassUnicodeRange { start: ch, end: ch });
                        return Hir::class(Class::Unicode(ClassUnicode::new(it)));
                    }
                    if let Some(singletons) = singleton_bytes(&new) {
                        let it = singletons
                            .into_iter()
                            .map(|b| ClassBytesRange { start: b, end: b });
                        return Hir::class(Class::Bytes(ClassBytes::new(it)));
                    }
                    if let Some(cls) = class_chars(&new) {
                        return Hir::class(cls);
                    }
                    if let Some(cls) = class_bytes(&new) {
                        return Hir::class(cls);
                    }
                    new = match lift_common_prefix(new) {
                        Ok(hir) => return hir,
                        Err(unchanged) => unchanged,
                    };
                    let props = Properties::alternation(&new);
                    Hir { kind: HirKind::Alternation(new), props }
                }
                /// Returns an HIR expression for `.`.
                #[inline] pub fn dot(dot: Dot) -> Hir {
                    match dot {
                        Dot::AnyChar => Hir::class(Class::Unicode(ClassUnicode::new([
                            ClassUnicodeRange::new('\0', '\u{10FFFF}'),
                        ]))),
                        Dot::AnyByte => Hir::class(Class::Bytes(ClassBytes::new([
                            ClassBytesRange::new(b'\0', b'\xFF'),
                        ]))),
                        Dot::AnyCharExcept(ch) => {
                            let mut cls =
                                ClassUnicode::new([ClassUnicodeRange::new(ch, ch)]);
                            cls.negate();
                            Hir::class(Class::Unicode(cls))
                        }
                        Dot::AnyCharExceptLF => {
                            Hir::class(Class::Unicode(ClassUnicode::new([
                                ClassUnicodeRange::new('\0', '\x09'),
                                ClassUnicodeRange::new('\x0B', '\u{10FFFF}'),
                            ])))
                        }
                        Dot::AnyCharExceptCRLF => {
                            Hir::class(Class::Unicode(ClassUnicode::new([
                                ClassUnicodeRange::new('\0', '\x09'),
                                ClassUnicodeRange::new('\x0B', '\x0C'),
                                ClassUnicodeRange::new('\x0E', '\u{10FFFF}'),
                            ])))
                        }
                        Dot::AnyByteExcept(byte) => {
                            let mut cls =
                                ClassBytes::new([ClassBytesRange::new(byte, byte)]);
                            cls.negate();
                            Hir::class(Class::Bytes(cls))
                        }
                        Dot::AnyByteExceptLF => {
                            Hir::class(Class::Bytes(ClassBytes::new([
                                ClassBytesRange::new(b'\0', b'\x09'),
                                ClassBytesRange::new(b'\x0B', b'\xFF'),
                            ])))
                        }
                        Dot::AnyByteExceptCRLF => {
                            Hir::class(Class::Bytes(ClassBytes::new([
                                ClassBytesRange::new(b'\0', b'\x09'),
                                ClassBytesRange::new(b'\x0B', b'\x0C'),
                                ClassBytesRange::new(b'\x0E', b'\xFF'),
                            ])))
                        }
                    }
                }
            }
            /// The underlying kind of an arbitrary [`Hir`] expression.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub enum HirKind
            {
                /// The empty regular expression, which matches everything, including the
                Empty,
                /// A literal string that matches exactly these bytes.
                Literal(Literal),
                /// A single character class that matches any of the characters in the
                Class(Class),
                /// A look-around assertion. A look-around match always has zero length.
                Look(Look),
                /// A repetition operation applied to a sub-expression.
                Repetition(Repetition),
                /// A capturing group, which contains a sub-expression.
                Capture(Capture),
                /// A concatenation of expressions.
                Concat(Vec<Hir>),
                /// An alternation of expressions.
                Alternation(Vec<Hir>),
            }

            impl HirKind
            {
                /// Returns a slice of this kind's sub-expressions, if any.
                pub fn subs(&self) -> &[Hir] {
                    use ::slice::from_ref;

                    match *self {
                        HirKind::Empty
                        | HirKind::Literal(_)
                        | HirKind::Class(_)
                        | HirKind::Look(_) => &[],
                        HirKind::Repetition(Repetition { ref sub, .. }) => from_ref(sub),
                        HirKind::Capture(Capture { ref sub, .. }) => from_ref(sub),
                        HirKind::Concat(ref subs) => subs,
                        HirKind::Alternation(ref subs) => subs,
                    }
                }
            }

            impl ::fmt::Debug for Hir
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    self.kind.fmt(f)
                }
            }
            /// Print a display representation of this Hir.
            impl ::fmt::Display for Hir
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    crate::hir::print::Printer::new().print(self, f)
                }
            }
            /// The high-level intermediate representation of a literal.
            #[derive(Clone, Eq, PartialEq)]
            pub struct Literal(pub Box<[u8]>);

            impl ::fmt::Debug for Literal
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    crate::debug::Bytes(&self.0).fmt(f)
                }
            }
            /// The high-level intermediate representation of a character class.
            #[derive(Clone, Eq, PartialEq)]
            pub enum Class
            {
                /// A set of characters represented by Unicode scalar values.
                Unicode(ClassUnicode),
                /// A set of characters represented by arbitrary bytes (one byte per
                Bytes(ClassBytes),
            }

            impl Class
            {
                /// Apply Unicode simple case folding to this character class, in place.
                pub fn case_fold_simple(&mut self) {
                    match *self {
                        Class::Unicode(ref mut x) => x.case_fold_simple(),
                        Class::Bytes(ref mut x) => x.case_fold_simple(),
                    }
                }
                /// Apply Unicode simple case folding to this character class, in place.
                pub fn try_case_fold_simple
                (
                    &mut self,
                ) -> ::result::Result<(), CaseFoldError> {
                    match *self {
                        Class::Unicode(ref mut x) => x.try_case_fold_simple()?,
                        Class::Bytes(ref mut x) => x.case_fold_simple(),
                    }
                    Ok(())
                }
                /// Negate this character class in place.
                pub fn negate(&mut self) {
                    match *self {
                        Class::Unicode(ref mut x) => x.negate(),
                        Class::Bytes(ref mut x) => x.negate(),
                    }
                }
                /// Returns true if and only if this character class will only ever match
                pub fn is_utf8(&self) -> bool {
                    match *self {
                        Class::Unicode(_) => true,
                        Class::Bytes(ref x) => x.is_ascii(),
                    }
                }
                /// Returns the length, in bytes, of the smallest string matched by this
                pub fn minimum_len(&self) -> Option<usize> {
                    match *self {
                        Class::Unicode(ref x) => x.minimum_len(),
                        Class::Bytes(ref x) => x.minimum_len(),
                    }
                }
                /// Returns the length, in bytes, of the longest string matched by this
                pub fn maximum_len(&self) -> Option<usize> {
                    match *self {
                        Class::Unicode(ref x) => x.maximum_len(),
                        Class::Bytes(ref x) => x.maximum_len(),
                    }
                }
                /// Returns true if and only if this character class is empty. That is,
                pub fn is_empty(&self) -> bool {
                    match *self {
                        Class::Unicode(ref x) => x.ranges().is_empty(),
                        Class::Bytes(ref x) => x.ranges().is_empty(),
                    }
                }
                /// If this class consists of exactly one element (whether a codepoint or a
                pub fn literal(&self) -> Option<Vec<u8>> {
                    match *self {
                        Class::Unicode(ref x) => x.literal(),
                        Class::Bytes(ref x) => x.literal(),
                    }
                }
            }

            impl ::fmt::Debug for Class
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    use ::regex::syntax::debug::Byte;

                    let mut fmter = f.debug_set();
                    match *self {
                        Class::Unicode(ref cls) => {
                            for r in cls.ranges().iter() {
                                fmter.entry(&(r.start..=r.end));
                            }
                        }
                        Class::Bytes(ref cls) => {
                            for r in cls.ranges().iter() {
                                fmter.entry(&(Byte(r.start)..=Byte(r.end)));
                            }
                        }
                    }
                    fmter.finish()
                }
            }
            /// A set of characters represented by Unicode scalar values.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassUnicode {
                set: IntervalSet<ClassUnicodeRange>,
            }

            impl ClassUnicode
            {
                /// Create a new class from a sequence of ranges.
                pub fn new<I>(ranges: I) -> ClassUnicode where
                    I: IntoIterator<Item = ClassUnicodeRange>,
                {
                    ClassUnicode { set: IntervalSet::new(ranges) }
                }
                /// Create a new class with no ranges.
                pub fn empty() -> ClassUnicode {
                    ClassUnicode::new(vec![])
                }
                /// Add a new range to this set.
                pub fn push(&mut self, range: ClassUnicodeRange) {
                    self.set.push(range);
                }
                /// Return an iterator over all ranges in this class.
                pub fn iter(&self) -> ClassUnicodeIter<'_> {
                    ClassUnicodeIter(self.set.iter())
                }
                /// Return the underlying ranges as a slice.
                pub fn ranges(&self) -> &[ClassUnicodeRange] {
                    self.set.intervals()
                }
                /// Expand this character class such that it contains all case folded
                pub fn case_fold_simple(&mut self) {
                    self.set
                        .case_fold_simple()
                        .expect("unicode-case feature must be enabled");
                }
                /// Expand this character class such that it contains all case folded
                pub fn try_case_fold_simple
                (
                    &mut self,
                ) -> ::result::Result<(), CaseFoldError>
                { self.set.case_fold_simple()
                }
                /// Negate this character class.
                pub fn negate(&mut self) {
                    self.set.negate();
                }
                /// Union this character class with the given character class, in place.
                pub fn union(&mut self, other: &ClassUnicode) {
                    self.set.union(&other.set);
                }
                /// Intersect this character class with the given character class, in
                pub fn intersect(&mut self, other: &ClassUnicode) {
                    self.set.intersect(&other.set);
                }
                /// Subtract the given character class from this character class, in place.
                pub fn difference(&mut self, other: &ClassUnicode) {
                    self.set.difference(&other.set);
                }
                /// Compute the symmetric difference of the given character classes, in
                pub fn symmetric_difference(&mut self, other: &ClassUnicode) {
                    self.set.symmetric_difference(&other.set);
                }
                /// Returns true if and only if this character class will either match
                pub fn is_ascii(&self) -> bool
                { self.set.intervals().last().map_or(true, |r| r.end <= '\x7F')
                }
                /// Returns the length, in bytes, of the smallest string matched by this
                pub fn minimum_len(&self) -> Option<usize>
                {
                    let first = self.ranges().get(0)?;
                    // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().
                    Some(first.start.len_utf8())
                }
                /// Returns the length, in bytes, of the longest string matched by this
                pub fn maximum_len(&self) -> Option<usize>
                {
                    let last = self.ranges().last()?;
                    // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().
                    Some(last.end.len_utf8())
                }
                /// If this class consists of exactly one codepoint, then return it as
                pub fn literal(&self) -> Option<Vec<u8>>
                {
                    let rs = self.ranges();
                    if rs.len() == 1 && rs[0].start == rs[0].end {
                        Some(rs[0].start.encode_utf8(&mut [0; 4]).to_string().into_bytes())
                    }
                    
                    else { None }
                }
                /// If this class consists of only ASCII ranges, then return its
                pub fn to_byte_class(&self) -> Option<ClassBytes> {
                    if !self.is_ascii() {
                        return None;
                    }
                    Some(ClassBytes::new(self.ranges().iter().map(|r| {
                        ClassBytesRange {
                            start: u8::try_from(r.start).unwrap(),
                            end: u8::try_from(r.end).unwrap(),
                        }
                    })))
                }
            }
            /// An iterator over all ranges in a Unicode character class.
            #[derive(Debug)]
            pub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);

            impl<'a> Iterator for ClassUnicodeIter<'a> {
                type Item = &'a ClassUnicodeRange;

                fn next(&mut self) -> Option<&'a ClassUnicodeRange>
                { self.0.next()
                }
            }
            /// A single range of characters represented by Unicode scalar values.
            #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
            pub struct ClassUnicodeRange {
                start: char,
                end: char,
            }

            impl ::fmt::Debug for ClassUnicodeRange
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    let start = if !self.start.is_whitespace() && !self.start.is_control()
                    {
                        self.start.to_string()
                    } else {
                        format!("0x{:X}", u32::from(self.start))
                    };
                    let end = if !self.end.is_whitespace() && !self.end.is_control() {
                        self.end.to_string()
                    } else {
                        format!("0x{:X}", u32::from(self.end))
                    };
                    f.debug_struct("ClassUnicodeRange")
                        .field("start", &start)
                        .field("end", &end)
                        .finish()
                }
            }

            impl Interval for ClassUnicodeRange {
                type Bound = char;

                #[inline] fn lower(&self) -> char {
                    self.start
                }
                #[inline] fn upper(&self) -> char {
                    self.end
                }
                #[inline] fn set_lower(&mut self, bound: char) {
                    self.start = bound;
                }
                #[inline] fn set_upper(&mut self, bound: char) {
                    self.end = bound;
                }
                /// Apply simple case folding to this Unicode scalar value range.
                fn case_fold_simple
                (
                    &self,
                    ranges: &mut Vec<ClassUnicodeRange>,
                ) -> Result<(), unicode::CaseFoldError>
                {
                    let mut folder = unicode::SimpleCaseFolder::new()?;
                    if !folder.overlaps(self.start, self.end) {
                        return Ok(());
                    }
                    let (start, end) = (u32::from(self.start), u32::from(self.end));
                    
                    for cp in (start..=end).filter_map(char::from_u32) {
                        for &cp_folded in folder.mapping(cp) {
                            ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));
                        }
                    }
                    Ok(())
                }
            }

            impl ClassUnicodeRange
            {
                /// Create a new Unicode scalar value range for a character class.
                pub fn new(start: char, end: char) -> ClassUnicodeRange {
                    ClassUnicodeRange::create(start, end)
                }
                /// Return the start of this range.
                pub fn start(&self) -> char {
                    self.start
                }
                /// Return the end of this range.
                pub fn end(&self) -> char {
                    self.end
                }
                /// Returns the number of codepoints in this range.
                pub fn len(&self) -> usize
                {
                    let diff = 1 + u32::from(self.end) - u32::from(self.start);
                    usize::try_from(diff).expect("char class len fits in usize")
                }
            }
            /// A set of characters represented by arbitrary bytes.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct ClassBytes {
                set: IntervalSet<ClassBytesRange>,
            }

            impl ClassBytes
            {
                /// Create a new class from a sequence of ranges.
                pub fn new<I>(ranges: I) -> ClassBytes where
                    I: IntoIterator<Item = ClassBytesRange>,
                {
                    ClassBytes { set: IntervalSet::new(ranges) }
                }
                /// Create a new class with no ranges.
                pub fn empty() -> ClassBytes {
                    ClassBytes::new(vec![])
                }
                /// Add a new range to this set.
                pub fn push(&mut self, range: ClassBytesRange) {
                    self.set.push(range);
                }
                /// Return an iterator over all ranges in this class.
                pub fn iter(&self) -> ClassBytesIter<'_> {
                    ClassBytesIter(self.set.iter())
                }
                /// Return the underlying ranges as a slice.
                pub fn ranges(&self) -> &[ClassBytesRange] {
                    self.set.intervals()
                }
                /// Expand this character class such that it contains all case folded
                pub fn case_fold_simple(&mut self) {
                    self.set.case_fold_simple().expect("ASCII case folding never fails");
                }
                /// Negate this byte class.
                pub fn negate(&mut self) {
                    self.set.negate();
                }
                /// Union this byte class with the given byte class, in place.
                pub fn union(&mut self, other: &ClassBytes) {
                    self.set.union(&other.set);
                }
                /// Intersect this byte class with the given byte class, in place.
                pub fn intersect(&mut self, other: &ClassBytes) {
                    self.set.intersect(&other.set);
                }
                /// Subtract the given byte class from this byte class, in place.
                pub fn difference(&mut self, other: &ClassBytes) {
                    self.set.difference(&other.set);
                }
                /// Compute the symmetric difference of the given byte classes, in place.
                pub fn symmetric_difference(&mut self, other: &ClassBytes) {
                    self.set.symmetric_difference(&other.set);
                }
                /// Returns true if and only if this character class will either match
                pub fn is_ascii(&self) -> bool
                { self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)
                }
                /// Returns the length, in bytes, of the smallest string matched by this
                pub fn minimum_len(&self) -> Option<usize> {
                    if self.ranges().is_empty() {
                        None
                    } else {
                        Some(1)
                    }
                }
                /// Returns the length, in bytes, of the longest string matched by this
                pub fn maximum_len(&self) -> Option<usize> {
                    if self.ranges().is_empty() {
                        None
                    } else {
                        Some(1)
                    }
                }
                /// If this class consists of exactly one byte, then return it as
                pub fn literal(&self) -> Option<Vec<u8>>
                {
                    let rs = self.ranges();
                    if rs.len() == 1 && rs[0].start == rs[0].end {
                        Some(vec![rs[0].start])
                    }
                    
                    else { None }
                }
                /// If this class consists of only ASCII ranges, then return its
                pub fn to_unicode_class(&self) -> Option<ClassUnicode> {
                    if !self.is_ascii() {
                        return None;
                    }
                    Some(ClassUnicode::new(self.ranges().iter().map(|r| {
                        ClassUnicodeRange {
                            start: char::from(r.start),
                            end: char::from(r.end),
                        }
                    })))
                }
            }
            /// An iterator over all ranges in a byte character class.
            #[derive(Debug)]
            pub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);

            impl<'a> Iterator for ClassBytesIter<'a> {
                type Item = &'a ClassBytesRange;

                fn next(&mut self) -> Option<&'a ClassBytesRange>
                { self.0.next()
                }
            }
            /// A single range of characters represented by arbitrary bytes.
            #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
            pub struct ClassBytesRange {
                start: u8,
                end: u8,
            }

            impl Interval for ClassBytesRange {
                type Bound = u8;

                #[inline] fn lower(&self) -> u8 {
                    self.start
                }
                #[inline] fn upper(&self) -> u8 {
                    self.end
                }
                #[inline] fn set_lower(&mut self, bound: u8) {
                    self.start = bound;
                }
                #[inline] fn set_upper(&mut self, bound: u8) {
                    self.end = bound;
                }
                /// Apply simple case folding to this byte range. Only ASCII case mappings
                fn case_fold_simple
                (
                    &self,
                    ranges: &mut Vec<ClassBytesRange>,
                ) -> Result<(), unicode::CaseFoldError> {
                    if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {
                        let lower = cmp::max(self.start, b'a');
                        let upper = cmp::min(self.end, b'z');
                        ranges.push(ClassBytesRange::new(lower - 32, upper - 32));
                    }
                    if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {
                        let lower = cmp::max(self.start, b'A');
                        let upper = cmp::min(self.end, b'Z');
                        ranges.push(ClassBytesRange::new(lower + 32, upper + 32));
                    }
                    Ok(())
                }
            }

            impl ClassBytesRange
            {
                /// Create a new byte range for a character class.
                pub fn new(start: u8, end: u8) -> ClassBytesRange {
                    ClassBytesRange::create(start, end)
                }
                /// Return the start of this range.
                pub fn start(&self) -> u8 {
                    self.start
                }
                /// Return the end of this range.
                pub fn end(&self) -> u8 {
                    self.end
                }
                /// Returns the number of bytes in this range.
                pub fn len(&self) -> usize {
                    usize::from(self.end.checked_sub(self.start).unwrap())
                        .checked_add(1)
                        .unwrap()
                }
            }

            impl ::fmt::Debug for ClassBytesRange
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_struct("ClassBytesRange")
                        .field("start", &crate::debug::Byte(self.start))
                        .field("end", &crate::debug::Byte(self.end))
                        .finish()
                }
            }
            /// The high-level intermediate representation for a look-around assertion.
            #[derive(Clone, Copy, Debug, Eq, PartialEq)]
            pub enum Look
            {
                /// Match the beginning of text. Specifically, this matches at the starting
                Start = 1 << 0,
                /// Match the end of text. Specifically, this matches at the ending
                End = 1 << 1,
                /// Match the beginning of a line or the beginning of text. Specifically,
                StartLF = 1 << 2,
                /// Match the end of a line or the end of text. Specifically, this matches
                EndLF = 1 << 3,
                /// Match the beginning of a line or the beginning of text. Specifically,
                StartCRLF = 1 << 4,
                /// Match the end of a line or the end of text. Specifically, this matches
                EndCRLF = 1 << 5,
                /// Match an ASCII-only word boundary. That is, this matches a position
                WordAscii = 1 << 6,
                /// Match an ASCII-only negation of a word boundary.
                WordAsciiNegate = 1 << 7,
                /// Match a Unicode-aware word boundary. That is, this matches a position
                WordUnicode = 1 << 8,
                /// Match a Unicode-aware negation of a word boundary.
                WordUnicodeNegate = 1 << 9,
                /// Match the start of an ASCII-only word boundary. That is, this matches a
                WordStartAscii = 1 << 10,
                /// Match the end of an ASCII-only word boundary. That is, this matches
                WordEndAscii = 1 << 11,
                /// Match the start of a Unicode word boundary. That is, this matches a
                WordStartUnicode = 1 << 12,
                /// Match the end of a Unicode word boundary. That is, this matches a
                WordEndUnicode = 1 << 13,
                /// Match the start half of an ASCII-only word boundary. That is, this
                WordStartHalfAscii = 1 << 14,
                /// Match the end half of an ASCII-only word boundary. That is, this
                WordEndHalfAscii = 1 << 15,
                /// Match the start half of a Unicode word boundary. That is, this matches
                WordStartHalfUnicode = 1 << 16,
                /// Match the end half of a Unicode word boundary. That is, this matches
                WordEndHalfUnicode = 1 << 17,
            }

            impl Look
            {
                /// Flip the look-around assertion to its equivalent for reverse searches.
                #[inline] pub const fn reversed(self) -> Look {
                    match self {
                        Look::Start => Look::End,
                        Look::End => Look::Start,
                        Look::StartLF => Look::EndLF,
                        Look::EndLF => Look::StartLF,
                        Look::StartCRLF => Look::EndCRLF,
                        Look::EndCRLF => Look::StartCRLF,
                        Look::WordAscii => Look::WordAscii,
                        Look::WordAsciiNegate => Look::WordAsciiNegate,
                        Look::WordUnicode => Look::WordUnicode,
                        Look::WordUnicodeNegate => Look::WordUnicodeNegate,
                        Look::WordStartAscii => Look::WordEndAscii,
                        Look::WordEndAscii => Look::WordStartAscii,
                        Look::WordStartUnicode => Look::WordEndUnicode,
                        Look::WordEndUnicode => Look::WordStartUnicode,
                        Look::WordStartHalfAscii => Look::WordEndHalfAscii,
                        Look::WordEndHalfAscii => Look::WordStartHalfAscii,
                        Look::WordStartHalfUnicode => Look::WordEndHalfUnicode,
                        Look::WordEndHalfUnicode => Look::WordStartHalfUnicode,
                    }
                }
                /// Return the underlying representation of this look-around enumeration
                #[inline] pub const fn as_repr(self) -> u32 {
                    self as u32
                }
                /// Given the underlying representation of a `Look` value, return the
                #[inline] pub const fn from_repr(repr: u32) -> Option<Look> {
                    match repr {
                        0b00_0000_0000_0000_0001 => Some(Look::Start),
                        0b00_0000_0000_0000_0010 => Some(Look::End),
                        0b00_0000_0000_0000_0100 => Some(Look::StartLF),
                        0b00_0000_0000_0000_1000 => Some(Look::EndLF),
                        0b00_0000_0000_0001_0000 => Some(Look::StartCRLF),
                        0b00_0000_0000_0010_0000 => Some(Look::EndCRLF),
                        0b00_0000_0000_0100_0000 => Some(Look::WordAscii),
                        0b00_0000_0000_1000_0000 => Some(Look::WordAsciiNegate),
                        0b00_0000_0001_0000_0000 => Some(Look::WordUnicode),
                        0b00_0000_0010_0000_0000 => Some(Look::WordUnicodeNegate),
                        0b00_0000_0100_0000_0000 => Some(Look::WordStartAscii),
                        0b00_0000_1000_0000_0000 => Some(Look::WordEndAscii),
                        0b00_0001_0000_0000_0000 => Some(Look::WordStartUnicode),
                        0b00_0010_0000_0000_0000 => Some(Look::WordEndUnicode),
                        0b00_0100_0000_0000_0000 => Some(Look::WordStartHalfAscii),
                        0b00_1000_0000_0000_0000 => Some(Look::WordEndHalfAscii),
                        0b01_0000_0000_0000_0000 => Some(Look::WordStartHalfUnicode),
                        0b10_0000_0000_0000_0000 => Some(Look::WordEndHalfUnicode),
                        _ => None,
                    }
                }
                /// Returns a convenient single codepoint representation of this
                #[inline] pub const fn as_char(self) -> char {
                    match self {
                        Look::Start => 'A',
                        Look::End => 'z',
                        Look::StartLF => '^',
                        Look::EndLF => '$',
                        Look::StartCRLF => 'r',
                        Look::EndCRLF => 'R',
                        Look::WordAscii => 'b',
                        Look::WordAsciiNegate => 'B',
                        Look::WordUnicode => '𝛃',
                        Look::WordUnicodeNegate => '𝚩',
                        Look::WordStartAscii => '<',
                        Look::WordEndAscii => '>',
                        Look::WordStartUnicode => '〈',
                        Look::WordEndUnicode => '〉',
                        Look::WordStartHalfAscii => '◁',
                        Look::WordEndHalfAscii => '▷',
                        Look::WordStartHalfUnicode => '◀',
                        Look::WordEndHalfUnicode => '▶',
                    }
                }
            }
            /// The high-level intermediate representation for a capturing group.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Capture
            {
                /// The capture index of the capture.
                pub index: u32,
                /// The name of the capture, if it exists.
                pub name: Option<Box<str>>,
                /// The expression inside the capturing group, which may be empty.
                pub sub: Box<Hir>,
            }
            /// The high-level intermediate representation of a repetition operator.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Repetition
            {
                /// The minimum range of the repetition.
                pub min: u32,
                /// The maximum range of the repetition.
                pub max: Option<u32>,
                /// Whether this repetition operator is greedy or not. A greedy operator
                pub greedy: bool,
                /// The expression being repeated.
                pub sub: Box<Hir>,
            }

            impl Repetition
            {
                /// Returns a new repetition with the same `min`, `max` and `greedy`
                pub fn with(&self, sub: Hir) -> Repetition {
                    Repetition {
                        min: self.min,
                        max: self.max,
                        greedy: self.greedy,
                        sub: Box::new(sub),
                    }
                }
            }
            /// A type describing the different flavors of `.`.
            #[non_exhaustive]
            #[derive(Clone, Copy, Debug, Eq, PartialEq)]
            pub enum Dot
            {
                /// Matches the UTF-8 encoding of any Unicode scalar value.
                AnyChar,
                /// Matches any byte value.
                AnyByte,
                /// Matches the UTF-8 encoding of any Unicode scalar value except for the
                AnyCharExcept(char),
                /// Matches the UTF-8 encoding of any Unicode scalar value except for `\n`.
                AnyCharExceptLF,
                /// Matches the UTF-8 encoding of any Unicode scalar value except for `\r`
                AnyCharExceptCRLF,
                /// Matches any byte value except for the `u8` given.
                AnyByteExcept(u8),
                /// Matches any byte value except for `\n`.
                AnyByteExceptLF,
                /// Matches any byte value except for `\r` and `\n`.
                AnyByteExceptCRLF,
            }
            /// A custom `Drop` impl is used for `HirKind` such that it uses constant stack
            impl Drop for Hir
            {
                fn drop(&mut self) {
                    use ::mem;

                    match *self.kind() {
                        HirKind::Empty
                        | HirKind::Literal(_)
                        | HirKind::Class(_)
                        | HirKind::Look(_) => return,
                        HirKind::Capture(ref x) if x.sub.kind.subs().is_empty() => return,
                        HirKind::Repetition(ref x) if x.sub.kind.subs().is_empty() => {
                            return
                        }
                        HirKind::Concat(ref x) if x.is_empty() => return,
                        HirKind::Alternation(ref x) if x.is_empty() => return,
                        _ => {}
                    }

                    let mut stack = vec![mem::replace(self, Hir::empty())];
                    
                    while let Some(mut expr) = stack.pop() {
                        match expr.kind {
                            HirKind::Empty
                            | HirKind::Literal(_)
                            | HirKind::Class(_)
                            | HirKind::Look(_) => {}
                            HirKind::Capture(ref mut x) => {
                                stack.push(mem::replace(&mut x.sub, Hir::empty()));
                            }
                            HirKind::Repetition(ref mut x) => {
                                stack.push(mem::replace(&mut x.sub, Hir::empty()));
                            }
                            HirKind::Concat(ref mut x) => {
                                stack.extend(x.drain(..));
                            }
                            HirKind::Alternation(ref mut x) => {
                                stack.extend(x.drain(..));
                            }
                        }
                    }
                }
            }
            /// A type that collects various properties of an HIR value.
            #[derive(Clone, Debug, Eq, PartialEq)]
            pub struct Properties(Box<PropertiesI>);
            /// The property definition. It is split out so that we can box it, and
            #[derive(Clone, Debug, Eq, PartialEq)]
            struct PropertiesI {
                minimum_len: Option<usize>,
                maximum_len: Option<usize>,
                look_set: LookSet,
                look_set_prefix: LookSet,
                look_set_suffix: LookSet,
                look_set_prefix_any: LookSet,
                look_set_suffix_any: LookSet,
                utf8: bool,
                explicit_captures_len: usize,
                static_explicit_captures_len: Option<usize>,
                literal: bool,
                alternation_literal: bool,
            }

            impl Properties
            {
                /// Returns the length (in bytes) of the smallest string matched by this
                #[inline] pub fn minimum_len(&self) -> Option<usize>
                { self.0.minimum_len
                }
                /// Returns the length (in bytes) of the longest string matched by this
                #[inline] pub fn maximum_len(&self) -> Option<usize>
                { self.0.maximum_len
                }
                /// Returns a set of all look-around assertions that appear at least once
                #[inline] pub fn look_set(&self) -> LookSet {
                    self.0.look_set
                }
                /// Returns a set of all look-around assertions that appear as a prefix for
                #[inline] pub fn look_set_prefix(&self) -> LookSet {
                    self.0.look_set_prefix
                }
                /// Returns a set of all look-around assertions that appear as a _possible_
                #[inline] pub fn look_set_prefix_any(&self) -> LookSet {
                    self.0.look_set_prefix_any
                }
                /// Returns a set of all look-around assertions that appear as a suffix for
                #[inline] pub fn look_set_suffix(&self) -> LookSet {
                    self.0.look_set_suffix
                }
                /// Returns a set of all look-around assertions that appear as a _possible_
                #[inline] pub fn look_set_suffix_any(&self) -> LookSet {
                    self.0.look_set_suffix_any
                }
                /// Return true if and only if the corresponding HIR will always match
                #[inline] pub fn is_utf8(&self) -> bool
                { self.0.utf8
                }
                /// Returns the total number of explicit capturing groups in the
                #[inline] pub fn explicit_captures_len(&self) -> usize {
                    self.0.explicit_captures_len
                }
                /// Returns the total number of explicit capturing groups that appear in
                #[inline] pub fn static_explicit_captures_len(&self) -> Option<usize>
                { self.0.static_explicit_captures_len
                }
                /// Return true if and only if this HIR is a simple literal. This is
                #[inline] pub fn is_literal(&self) -> bool
                { self.0.literal
                }
                /// Return true if and only if this HIR is either a simple literal or an
                #[inline] pub fn is_alternation_literal(&self) -> bool
                { self.0.alternation_literal
                }
                /// Returns the total amount of heap memory usage, in bytes, used by this
                #[inline] pub fn memory_usage(&self) -> usize {
                    ::mem::size_of::<PropertiesI>()
                }
                /// Returns a new set of properties that corresponds to the union of the
                pub fn union<I, P>(props: I) -> Properties where
                    I: IntoIterator<Item = P>,
                    P: ::borrow::Borrow<Properties>,
               
                {
                    let mut it = props.into_iter().peekable();
                    let fix = if it.peek().is_none() {
                        LookSet::empty()
                    } else {
                        LookSet::full()
                    };
                    let static_explicit_captures_len =
                        it.peek().and_then(|p| p.borrow().static_explicit_captures_len());
                    let mut props = PropertiesI {
                        minimum_len: None,
                        maximum_len: None,
                        look_set: LookSet::empty(),
                        look_set_prefix: fix,
                        look_set_suffix: fix,
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len,
                        literal: false,
                        alternation_literal: true,
                    };
                    let (mut min_poisoned, mut max_poisoned) = (false, false);
                    // Handle properties that need to visit every child hir.
                    for prop in it {
                        let p = prop.borrow();
                        props.look_set.set_union(p.look_set());
                        props.look_set_prefix.set_intersect(p.look_set_prefix());
                        props.look_set_suffix.set_intersect(p.look_set_suffix());
                        props.look_set_prefix_any.set_union(p.look_set_prefix_any());
                        props.look_set_suffix_any.set_union(p.look_set_suffix_any());
                        props.utf8 = props.utf8 && p.is_utf8();
                        props.explicit_captures_len = props
                            .explicit_captures_len
                            .saturating_add(p.explicit_captures_len());
                        
                        if props.static_explicit_captures_len
                            != p.static_explicit_captures_len()
                        {
                            props.static_explicit_captures_len = None;
                        }
                        props.alternation_literal =
                            props.alternation_literal && p.is_literal();
                        
                        if !min_poisoned {
                            if let Some(xmin) = p.minimum_len()
                            {
                                if props.minimum_len.map_or(true, |pmin| xmin < pmin) {
                                    props.minimum_len = Some(xmin);
                                }
                            } else {
                                props.minimum_len = None;
                                min_poisoned = true;
                            }
                        }
                        
                        if !max_poisoned {
                            if let Some(xmax) = p.maximum_len()
                            {
                                if props.maximum_len.map_or(true, |pmax| xmax > pmax) {
                                    props.maximum_len = Some(xmax);
                                }
                            } else {
                                props.maximum_len = None;
                                max_poisoned = true;
                            }
                        }
                    }
                    Properties(Box::new(props))
                }
            }

            impl Properties
            {
                /// Create a new set of HIR properties for an empty regex.
                fn empty() -> Properties
                {
                    let inner = PropertiesI {
                        minimum_len: Some(0),
                        maximum_len: Some(0),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: false,
                        alternation_literal: false,
                    };
                    Properties(Box::new(inner))
                }
                /// Create a new set of HIR properties for a literal regex.
                fn literal(lit: &Literal) -> Properties
                {
                    let inner = PropertiesI {
                        minimum_len: Some(lit.0.len()),
                        maximum_len: Some(lit.0.len()),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: ::str::from_utf8(&lit.0).is_ok(),
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: true,
                        alternation_literal: true,
                    };
                    Properties(Box::new(inner))
                }
                /// Create a new set of HIR properties for a character class.
                fn class(class: &Class) -> Properties
                {
                    let inner = PropertiesI {
                        minimum_len: class.minimum_len(),
                        maximum_len: class.maximum_len(),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: class.is_utf8(),
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: false,
                        alternation_literal: false,
                    };
                    Properties(Box::new(inner))
                }
                /// Create a new set of HIR properties for a look-around assertion.
                fn look(look: Look) -> Properties
                {
                    let inner = PropertiesI {
                        minimum_len: Some(0),
                        maximum_len: Some(0),
                        look_set: LookSet::singleton(look),
                        look_set_prefix: LookSet::singleton(look),
                        look_set_suffix: LookSet::singleton(look),
                        look_set_prefix_any: LookSet::singleton(look),
                        look_set_suffix_any: LookSet::singleton(look),
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: false,
                        alternation_literal: false,
                    };
                    Properties(Box::new(inner))
                }
                /// Create a new set of HIR properties for a repetition.
                fn repetition(rep: &Repetition) -> Properties
                {
                    let p = rep.sub.properties();
                    let minimum_len = p.minimum_len().map(|child_min| {
                        let rep_min = usize::try_from(rep.min).unwrap_or(usize::MAX);
                        child_min.saturating_mul(rep_min)
                    });
                    let maximum_len = rep.max.and_then(|rep_max| {
                        let rep_max = usize::try_from(rep_max).ok()?;
                        let child_max = p.maximum_len()?;
                        child_max.checked_mul(rep_max)
                    });

                    let mut inner = PropertiesI {
                        minimum_len,
                        maximum_len,
                        look_set: p.look_set(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: p.look_set_prefix_any(),
                        look_set_suffix_any: p.look_set_suffix_any(),
                        utf8: p.is_utf8(),
                        explicit_captures_len: p.explicit_captures_len(),
                        static_explicit_captures_len: p.static_explicit_captures_len(),
                        literal: false,
                        alternation_literal: false,
                    };
                    if rep.min > 0 {
                        inner.look_set_prefix = p.look_set_prefix();
                        inner.look_set_suffix = p.look_set_suffix();
                    }
                    if rep.min == 0
                        && inner.static_explicit_captures_len.map_or(false, |len| len > 0)
                    {
                        if rep.max == Some(0) {
                            inner.static_explicit_captures_len = Some(0);
                        } else {
                            inner.static_explicit_captures_len = None;
                        }
                    }
                    Properties(Box::new(inner))
                }
                /// Create a new set of HIR properties for a capture.
                fn capture(capture: &Capture) -> Properties
                {
                    let p = capture.sub.properties();
                    Properties(Box::new(PropertiesI {
                        explicit_captures_len: p.explicit_captures_len().saturating_add(1),
                        static_explicit_captures_len: p
                            .static_explicit_captures_len()
                            .map(|len| len.saturating_add(1)),
                        literal: false,
                        alternation_literal: false,
                        ..*p.0.clone()
                    }))
                }
                /// Create a new set of HIR properties for a concatenation.
                fn concat(concat: &[Hir]) -> Properties
                {
                    let mut props = PropertiesI {
                        minimum_len: Some(0),
                        maximum_len: Some(0),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: true,
                        alternation_literal: true,
                    };
                    // Handle properties that need to visit every child hir.
                    for x in concat.iter() {
                        let p = x.properties();
                        props.look_set.set_union(p.look_set());
                        props.utf8 = props.utf8 && p.is_utf8();
                        props.explicit_captures_len = props
                            .explicit_captures_len
                            .saturating_add(p.explicit_captures_len());
                        props.static_explicit_captures_len = p
                            .static_explicit_captures_len()
                            .and_then(|len1| {
                                Some((len1, props.static_explicit_captures_len?))
                            })
                            .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));
                        props.literal = props.literal && p.is_literal();
                        props.alternation_literal =
                            props.alternation_literal && p.is_alternation_literal();
                        
                        if let Some(minimum_len) = props.minimum_len {
                            match p.minimum_len() {
                                None => props.minimum_len = None,
                                Some(len) => {
                                    props.minimum_len =
                                        Some(minimum_len.saturating_add(len));
                                }
                            }
                        }
                        
                        if let Some(maximum_len) = props.maximum_len {
                            match p.maximum_len() {
                                None => props.maximum_len = None,
                                Some(len) => {
                                    props.maximum_len = maximum_len.checked_add(len)
                                }
                            }
                        }
                    }
                    let mut it = concat.iter();
                    
                    while let Some(x) = it.next() {
                        props.look_set_prefix.set_union(x.properties().look_set_prefix());
                        props
                            .look_set_prefix_any
                            .set_union(x.properties().look_set_prefix_any());
                        
                        if x.properties().maximum_len().map_or(true, |x| x > 0) {
                            break;
                        }
                    }
                    // Same thing for the suffix properties, but in reverse.
                    let mut it = concat.iter().rev();
                    
                    while let Some(x) = it.next() {
                        props.look_set_suffix.set_union(x.properties().look_set_suffix());
                        props
                            .look_set_suffix_any
                            .set_union(x.properties().look_set_suffix_any());
                        
                        if x.properties().maximum_len().map_or(true, |x| x > 0) {
                            break;
                        }
                    }
                    Properties(Box::new(props))
                }
                /// Create a new set of HIR properties for a concatenation.
                fn alternation(alts: &[Hir]) -> Properties {
                    Properties::union(alts.iter().map(|hir| hir.properties()))
                }
            }
            /// A set of look-around assertions.
            #[derive(Clone, Copy, Default, Eq, PartialEq)]
            pub struct LookSet
            {
                /// The underlying representation this set is exposed to make it possible
                pub bits: u32,
            }

            impl LookSet
            {
                /// Create an empty set of look-around assertions.
                #[inline] pub fn empty() -> LookSet {
                    LookSet { bits: 0 }
                }
                /// Create a full set of look-around assertions.
                #[inline] pub fn full() -> LookSet {
                    LookSet { bits: !0 }
                }
                /// Create a look-around set containing the look-around assertion given.
                #[inline] pub fn singleton(look: Look) -> LookSet {
                    LookSet::empty().insert(look)
                }
                /// Returns the total number of look-around assertions in this set.
                #[inline] pub fn len(self) -> usize {
                    usize::try_from(self.bits.count_ones()).unwrap()
                }
                /// Returns true if and only if this set is empty.
                #[inline] pub fn is_empty(self) -> bool
                { self.len() == 0
                }
                /// Returns true if and only if the given look-around assertion is in this
                #[inline] pub fn contains(self, look: Look) -> bool
                { self.bits & look.as_repr() != 0
                }
                /// Returns true if and only if this set contains any anchor assertions.
                #[inline] pub fn contains_anchor(&self) -> bool
                { self.contains_anchor_haystack() || self.contains_anchor_line()
                }
                /// Returns true if and only if this set contains any "start/end of
                #[inline] pub fn contains_anchor_haystack(&self) -> bool
                { self.contains(Look::Start) || self.contains(Look::End)
                }
                /// Returns true if and only if this set contains any "start/end of line"
                #[inline] pub fn contains_anchor_line(&self) -> bool
                { self.contains(Look::StartLF)
                        || self.contains(Look::EndLF)
                        || self.contains(Look::StartCRLF)
                        || self.contains(Look::EndCRLF)
                }
                /// Returns true if and only if this set contains any "start/end of line"
                #[inline] pub fn contains_anchor_lf(&self) -> bool
                { self.contains(Look::StartLF) || self.contains(Look::EndLF)
                }
                /// Returns true if and only if this set contains any "start/end of line"
                #[inline] pub fn contains_anchor_crlf(&self) -> bool
                { self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)
                }
                /// Returns true if and only if this set contains any word boundary or
                #[inline] pub fn contains_word(self) -> bool
                { self.contains_word_unicode() || self.contains_word_ascii()
                }
                /// Returns true if and only if this set contains any Unicode word boundary
                #[inline] pub fn contains_word_unicode(self) -> bool
                { self.contains(Look::WordUnicode)
                        || self.contains(Look::WordUnicodeNegate)
                        || self.contains(Look::WordStartUnicode)
                        || self.contains(Look::WordEndUnicode)
                        || self.contains(Look::WordStartHalfUnicode)
                        || self.contains(Look::WordEndHalfUnicode)
                }
                /// Returns true if and only if this set contains any ASCII word boundary
                #[inline] pub fn contains_word_ascii(self) -> bool
                { self.contains(Look::WordAscii)
                        || self.contains(Look::WordAsciiNegate)
                        || self.contains(Look::WordStartAscii)
                        || self.contains(Look::WordEndAscii)
                        || self.contains(Look::WordStartHalfAscii)
                        || self.contains(Look::WordEndHalfAscii)
                }
                /// Returns an iterator over all of the look-around assertions in this set.
                #[inline] pub fn iter(self) -> LookSetIter {
                    LookSetIter { set: self }
                }
                /// Return a new set that is equivalent to the original, but with the given
                #[inline] pub fn insert(self, look: Look) -> LookSet {
                    LookSet { bits: self.bits | look.as_repr() }
                }
                /// Updates this set in place with the result of inserting the given
                #[inline] pub fn set_insert(&mut self, look: Look) {
                    *self = self.insert(look);
                }
                /// Return a new set that is equivalent to the original, but with the given
                #[inline] pub fn remove(self, look: Look) -> LookSet {
                    LookSet { bits: self.bits & !look.as_repr() }
                }
                /// Updates this set in place with the result of removing the given
                #[inline] pub fn set_remove(&mut self, look: Look) {
                    *self = self.remove(look);
                }
                /// Returns a new set that is the result of subtracting the given set from
                #[inline] pub fn subtract(self, other: LookSet) -> LookSet {
                    LookSet { bits: self.bits & !other.bits }
                }
                /// Updates this set in place with the result of subtracting the given set
                #[inline] pub fn set_subtract(&mut self, other: LookSet) {
                    *self = self.subtract(other);
                }
                /// Returns a new set that is the union of this and the one given.
                #[inline] pub fn union(self, other: LookSet) -> LookSet {
                    LookSet { bits: self.bits | other.bits }
                }
                /// Updates this set in place with the result of unioning it with the one
                #[inline] pub fn set_union(&mut self, other: LookSet) {
                    *self = self.union(other);
                }
                /// Returns a new set that is the intersection of this and the one given.
                #[inline] pub fn intersect(self, other: LookSet) -> LookSet {
                    LookSet { bits: self.bits & other.bits }
                }
                /// Updates this set in place with the result of intersecting it with the
                #[inline] pub fn set_intersect(&mut self, other: LookSet) {
                    *self = self.intersect(other);
                }
                /// Return a `LookSet` from the slice given as a native endian 32-bit
                #[inline] pub fn read_repr(slice: &[u8]) -> LookSet
                {
                    let bits = u32::from_ne_bytes(slice[..4].try_into().unwrap());
                    LookSet { bits }
                }
                /// Write a `LookSet` as a native endian 32-bit integer to the beginning
                #[inline] pub fn write_repr(self, slice: &mut [u8])
                {
                    let raw = self.bits.to_ne_bytes();
                    slice[0] = raw[0];
                    slice[1] = raw[1];
                    slice[2] = raw[2];
                    slice[3] = raw[3];
                }
            }

            impl ::fmt::Debug for LookSet
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    if self.is_empty() {
                        return write!(f, "∅");
                    }
                    for look in self.iter() {
                        write!(f, "{}", look.as_char())?;
                    }
                    Ok(())
                }
            }
            /// An iterator over all look-around assertions in a [`LookSet`].
            #[derive(Clone, Debug)]
            pub struct LookSetIter {
                set: LookSet,
            }

            impl Iterator for LookSetIter {
                type Item = Look;

                #[inline] fn next(&mut self) -> Option<Look> {
                    if self.set.is_empty() {
                        return None;
                    }
                    let bit = u16::try_from(self.set.bits.trailing_zeros()).unwrap();
                    let look = Look::from_repr(1 << bit)?;
                    self.set = self.set.remove(look);
                    Some(look)
                }
            }
            /// Given a sequence of HIR values where each value corresponds to a Unicode
            fn class_chars(hirs: &[Hir]) -> Option<Class>
           
            {
                let mut cls = ClassUnicode::new(vec![]);
                
                for hir in hirs.iter() {
                    match *hir.kind() {
                        HirKind::Class(Class::Unicode(ref cls2)) => {
                            cls.union(cls2);
                        }
                        HirKind::Class(Class::Bytes(ref cls2)) => {
                            cls.union(&cls2.to_unicode_class()?);
                        }
                        _ => return None,
                    };
                }
                Some(Class::Unicode(cls))
            }
            /// Given a sequence of HIR values where each value corresponds to a byte class
            fn class_bytes(hirs: &[Hir]) -> Option<Class>
           
            {
                let mut cls = ClassBytes::new(vec![]);
                
                for hir in hirs.iter() {
                    match *hir.kind() {
                        HirKind::Class(Class::Unicode(ref cls2)) => {
                            cls.union(&cls2.to_byte_class()?);
                        }
                        HirKind::Class(Class::Bytes(ref cls2)) => {
                            cls.union(cls2);
                        }
                        _ => return None,
                    };
                }
                Some(Class::Bytes(cls))
            }
            /// Given a sequence of HIR values where each value corresponds to a literal
            fn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>>
           
            {
                let mut singletons = vec![];
                
                for hir in hirs.iter()
                {
                    let literal = match *hir.kind() {
                        HirKind::Literal(Literal(ref bytes)) => bytes,
                        _ => return None,
                    };
                    let ch = match crate::debug::utf8_decode(literal) {
                        None => return None,
                        Some(Err(_)) => return None,
                        Some(Ok(ch)) => ch,
                    };
                    if literal.len() != ch.len_utf8() {
                        return None;
                    }
                    singletons.push(ch);
                }
                Some(singletons)
            }
            /// Given a sequence of HIR values where each value corresponds to a literal
            fn singleton_bytes(hirs: &[Hir]) -> Option<Vec<u8>>
           
            {
                let mut singletons = vec![];
                
                for hir in hirs.iter()
                {
                    let literal = match *hir.kind() {
                        HirKind::Literal(Literal(ref bytes)) => bytes,
                        _ => return None,
                    };
                    if literal.len() != 1 {
                        return None;
                    }
                    singletons.push(literal[0]);
                }
                Some(singletons)
            }
            /// Looks for a common prefix in the list of alternation branches given. If one
            fn lift_common_prefix(hirs: Vec<Hir>) -> Result<Hir, Vec<Hir>> {
                if hirs.len() <= 1 {
                    return Err(hirs);
                }
                let mut prefix = match hirs[0].kind() {
                    HirKind::Concat(ref xs) => &**xs,
                    _ => return Err(hirs),
                };
                if prefix.is_empty() {
                    return Err(hirs);
                }
                for h in hirs.iter().skip(1)
                {
                    let concat = match h.kind() {
                        HirKind::Concat(ref xs) => xs,
                        _ => return Err(hirs),
                    };
                    let common_len = prefix
                        .iter()
                        .zip(concat.iter())
                        .take_while(|(x, y)| x == y)
                        .count();
                    prefix = &prefix[..common_len];
                    if prefix.is_empty() {
                        return Err(hirs);
                    }
                }
                let len = prefix.len();
                assert_ne!(0, len);
                let mut prefix_concat = vec![];
                let mut suffix_alts = vec![];
                
                for h in hirs
                {
                    let mut concat = match h.into_kind() {
                        HirKind::Concat(xs) => xs,
                        _ => unreachable!(),
                    };
                    suffix_alts.push(Hir::concat(concat.split_off(len)));
                    if prefix_concat.is_empty() {
                        prefix_concat = concat;
                    }
                }
                let mut concat = prefix_concat;
                concat.push(Hir::alternation(suffix_alts));
                Ok(Hir::concat(concat))
            }
        }

        pub mod parser
        {
            /*!
            */
            use ::
            {
                regex::syntax::{ ast, hir, Error },
                *,
            };
            /*
            */
            /// A convenience routine for parsing a regex using default options.
            pub fn parse(pattern: &str) -> Result<hir::Hir, Error> {
                Parser::new().parse(pattern)
            }
            /// A builder for a regular expression parser.
            #[derive(Clone, Debug, Default)]
            pub struct ParserBuilder {
                ast: ast::parse::ParserBuilder,
                hir: hir::translate::TranslatorBuilder,
            }

            impl ParserBuilder
            {
                /// Create a new parser builder with a default configuration.
                pub fn new() -> ParserBuilder {
                    ParserBuilder::default()
                }
                /// Build a parser from this configuration with the given pattern.
                pub fn build(&self) -> Parser {
                    Parser { ast: self.ast.build(), hir: self.hir.build() }
                }
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {
                    self.ast.nest_limit(limit);
                    self
                }
                /// Whether to support octal syntax or not.
                pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.ast.octal(yes);
                    self
                }
                /// When disabled, translation will permit the construction of a regular
                pub fn utf8(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.utf8(yes);
                    self
                }
                /// Enable verbose mode in the regular expression.
                pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.ast.ignore_whitespace(yes);
                    self
                }
                /// Enable or disable the case insensitive flag by default.
                pub fn case_insensitive(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.case_insensitive(yes);
                    self
                }
                /// Enable or disable the multi-line matching flag by default.
                pub fn multi_line(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.multi_line(yes);
                    self
                }
                /// Enable or disable the "dot matches any character" flag by default.
                pub fn dot_matches_new_line(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.dot_matches_new_line(yes);
                    self
                }
                /// Enable or disable the CRLF mode flag by default.
                pub fn crlf(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.crlf(yes);
                    self
                }
                /// Sets the line terminator for use with `(?u-s:.)` and `(?-us:.)`.
                pub fn line_terminator(&mut self, byte: u8) -> &mut ParserBuilder {
                    self.hir.line_terminator(byte);
                    self
                }
                /// Enable or disable the "swap greed" flag by default.
                pub fn swap_greed(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.swap_greed(yes);
                    self
                }
                /// Enable or disable the Unicode flag (`u`) by default.
                pub fn unicode(&mut self, yes: bool) -> &mut ParserBuilder {
                    self.hir.unicode(yes);
                    self
                }
            }
            /// A convenience parser for regular expressions.
            #[derive(Clone, Debug)]
            pub struct Parser {
                ast: ast::parse::Parser,
                hir: hir::translate::Translator,
            }

            impl Parser
            {
                /// Create a new parser with a default configuration.
                pub fn new() -> Parser {
                    ParserBuilder::new().build()
                }
                /// Parse the regular expression into a high level intermediate
                pub fn parse(&mut self, pattern: &str) -> Result<hir::Hir, Error>
                {
                    let ast = self.ast.parse(pattern)?;
                    let hir = self.hir.translate(pattern, &ast)?;
                    Ok(hir)
                }
            }
        }

        pub mod rank
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BYTE_FREQUENCIES: [u8; 256] = [
                55,  // '\x00'
                52,  // '\x01'
                51,  // '\x02'
                50,  // '\x03'
                49,  // '\x04'
                48,  // '\x05'
                47,  // '\x06'
                46,  // '\x07'
                45,  // '\x08'
                103, // '\t'
                242, // '\n'
                66,  // '\x0b'
                67,  // '\x0c'
                229, // '\r'
                44,  // '\x0e'
                43,  // '\x0f'
                42,  // '\x10'
                41,  // '\x11'
                40,  // '\x12'
                39,  // '\x13'
                38,  // '\x14'
                37,  // '\x15'
                36,  // '\x16'
                35,  // '\x17'
                34,  // '\x18'
                33,  // '\x19'
                56,  // '\x1a'
                32,  // '\x1b'
                31,  // '\x1c'
                30,  // '\x1d'
                29,  // '\x1e'
                28,  // '\x1f'
                255, // ' '
                148, // '!'
                164, // '"'
                149, // '#'
                136, // '$'
                160, // '%'
                155, // '&'
                173, // "'"
                221, // '('
                222, // ')'
                134, // '*'
                122, // '+'
                232, // ','
                202, // '-'
                215, // '.'
                224, // '/'
                208, // '0'
                220, // '1'
                204, // '2'
                187, // '3'
                183, // '4'
                179, // '5'
                177, // '6'
                168, // '7'
                178, // '8'
                200, // '9'
                226, // ':'
                195, // ';'
                154, // '<'
                184, // '='
                174, // '>'
                126, // '?'
                120, // '@'
                191, // 'A'
                157, // 'B'
                194, // 'C'
                170, // 'D'
                189, // 'E'
                162, // 'F'
                161, // 'G'
                150, // 'H'
                193, // 'I'
                142, // 'J'
                137, // 'K'
                171, // 'L'
                176, // 'M'
                185, // 'N'
                167, // 'O'
                186, // 'P'
                112, // 'Q'
                175, // 'R'
                192, // 'S'
                188, // 'T'
                156, // 'U'
                140, // 'V'
                143, // 'W'
                123, // 'X'
                133, // 'Y'
                128, // 'Z'
                147, // '['
                138, // '\\'
                146, // ']'
                114, // '^'
                223, // '_'
                151, // '`'
                249, // 'a'
                216, // 'b'
                238, // 'c'
                236, // 'd'
                253, // 'e'
                227, // 'f'
                218, // 'g'
                230, // 'h'
                247, // 'i'
                135, // 'j'
                180, // 'k'
                241, // 'l'
                233, // 'm'
                246, // 'n'
                244, // 'o'
                231, // 'p'
                139, // 'q'
                245, // 'r'
                243, // 's'
                251, // 't'
                235, // 'u'
                201, // 'v'
                196, // 'w'
                240, // 'x'
                214, // 'y'
                152, // 'z'
                182, // '{'
                205, // '|'
                181, // '}'
                127, // '~'
                27,  // '\x7f'
                212, // '\x80'
                211, // '\x81'
                210, // '\x82'
                213, // '\x83'
                228, // '\x84'
                197, // '\x85'
                169, // '\x86'
                159, // '\x87'
                131, // '\x88'
                172, // '\x89'
                105, // '\x8a'
                80,  // '\x8b'
                98,  // '\x8c'
                96,  // '\x8d'
                97,  // '\x8e'
                81,  // '\x8f'
                207, // '\x90'
                145, // '\x91'
                116, // '\x92'
                115, // '\x93'
                144, // '\x94'
                130, // '\x95'
                153, // '\x96'
                121, // '\x97'
                107, // '\x98'
                132, // '\x99'
                109, // '\x9a'
                110, // '\x9b'
                124, // '\x9c'
                111, // '\x9d'
                82,  // '\x9e'
                108, // '\x9f'
                118, // '\xa0'
                141, // '¡'
                113, // '¢'
                129, // '£'
                119, // '¤'
                125, // '¥'
                165, // '¦'
                117, // '§'
                92,  // '¨'
                106, // '©'
                83,  // 'ª'
                72,  // '«'
                99,  // '¬'
                93,  // '\xad'
                65,  // '®'
                79,  // '¯'
                166, // '°'
                237, // '±'
                163, // '²'
                199, // '³'
                190, // '´'
                225, // 'µ'
                209, // '¶'
                203, // '·'
                198, // '¸'
                217, // '¹'
                219, // 'º'
                206, // '»'
                234, // '¼'
                248, // '½'
                158, // '¾'
                239, // '¿'
                255, // 'À'
                255, // 'Á'
                255, // 'Â'
                255, // 'Ã'
                255, // 'Ä'
                255, // 'Å'
                255, // 'Æ'
                255, // 'Ç'
                255, // 'È'
                255, // 'É'
                255, // 'Ê'
                255, // 'Ë'
                255, // 'Ì'
                255, // 'Í'
                255, // 'Î'
                255, // 'Ï'
                255, // 'Ð'
                255, // 'Ñ'
                255, // 'Ò'
                255, // 'Ó'
                255, // 'Ô'
                255, // 'Õ'
                255, // 'Ö'
                255, // '×'
                255, // 'Ø'
                255, // 'Ù'
                255, // 'Ú'
                255, // 'Û'
                255, // 'Ü'
                255, // 'Ý'
                255, // 'Þ'
                255, // 'ß'
                255, // 'à'
                255, // 'á'
                255, // 'â'
                255, // 'ã'
                255, // 'ä'
                255, // 'å'
                255, // 'æ'
                255, // 'ç'
                255, // 'è'
                255, // 'é'
                255, // 'ê'
                255, // 'ë'
                255, // 'ì'
                255, // 'í'
                255, // 'î'
                255, // 'ï'
                255, // 'ð'
                255, // 'ñ'
                255, // 'ò'
                255, // 'ó'
                255, // 'ô'
                255, // 'õ'
                255, // 'ö'
                255, // '÷'
                255, // 'ø'
                255, // 'ù'
                255, // 'ú'
                255, // 'û'
                255, // 'ü'
                255, // 'ý'
                255, // 'þ'
                255, // 'ÿ'
            ];
        }

        pub mod unicode
        {
            /*!
            */
            use ::
            {
                regex::syntax::hir,
                string::{String, ToString},
                vec::Vec,
                *,
            };
            /*
            */
            /// An inclusive range of codepoints from a generated file (hence the static
            type Range = &'static [(char, char)];
            /// An error that occurs when dealing with Unicode.
            #[derive(Debug)]
            pub enum Error {
                PropertyNotFound,
                PropertyValueNotFound,
                // Not used when unicode-perl is enabled.
                #[allow(dead_code)]
                PerlClassNotFound,
            }
            /// An error that occurs when Unicode-aware simple case folding fails.
            #[derive(Debug)]
            pub struct CaseFoldError(());
            
            impl ::error::Error for CaseFoldError {}

            impl ::fmt::Display for CaseFoldError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(
                        f,
                        "Unicode-aware case folding is not available \
                        (probably because the unicode-case feature is not enabled)"
                    )
                }
            }
            /// An error that occurs when the Unicode-aware `\w` class is unavailable.
            #[derive(Debug)]
            pub struct UnicodeWordError(());
            
            impl ::error::Error for UnicodeWordError {}

            impl ::fmt::Display for UnicodeWordError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(
                        f,
                        "Unicode-aware \\w class is not available \
                        (probably because the unicode-perl feature is not enabled)"
                    )
                }
            }
            /// A state oriented traverser of the simple case folding table.
            #[derive(Debug)]
            pub struct SimpleCaseFolder
            {
                /// The simple case fold table. It's a sorted association list, where the
                table: &'static [(char, &'static [char])],
                /// The last codepoint that was used for a lookup.
                last: Option<char>,
                /// The index to the entry in `table` corresponding to the smallest key `k`
                next: usize,
            }

            impl SimpleCaseFolder
            {
                /// Create a new simple case folder, returning an error if the underlying
                pub fn new() -> Result<SimpleCaseFolder, CaseFoldError>
                {
                    Ok
                    (
                        SimpleCaseFolder
                        {
                            table: ::regex::unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE,
                            last: None,
                            next: 0,
                        }
                    )
                }
                /// Return the equivalence class of case folded codepoints for the given
                pub fn mapping(&mut self, c: char) -> &'static [char]
                {
                    if let Some(last) = self.last {
                        assert!(
                            last < c,
                            "got codepoint U+{:X} which occurs before \
                            last codepoint U+{:X}",
                            u32::from(c),
                            u32::from(last),
                        );
                    }
                    
                    self.last = Some(c);
                    if self.next >= self.table.len() {
                        return &[];
                    }
                    let (k, v) = self.table[self.next];
                    if k == c {
                        self.next += 1;
                        return v;
                    }
                    match self.get(c) {
                        Err(i) => {
                            self.next = i;
                            &[]
                        }
                        Ok(i) => {
                            assert!(i > self.next);
                            self.next = i + 1;
                            self.table[i].1
                        }
                    }
                }
                /// Returns true if and only if the given range overlaps with any region
                pub fn overlaps(&self, start: char, end: char) -> bool {
                    use ::cmp::Ordering;

                    assert!(start <= end);
                    self.table
                        .binary_search_by(|&(c, _)| {
                            if start <= c && c <= end {
                                Ordering::Equal
                            } else if c > end {
                                Ordering::Greater
                            } else {
                                Ordering::Less
                            }
                        })
                        .is_ok()
                }
                /// Returns the index at which `c` occurs in the simple case fold table. If
                fn get(&self, c: char) -> Result<usize, usize>
                { self.table.binary_search_by_key(&c, |&(c1, _)| c1)
                }
            }
            /// A query for finding a character class defined by Unicode. This supports
            #[derive(Debug)]
            pub enum ClassQuery<'a>
            {
                /// Return a class corresponding to a Unicode binary property, named by
                OneLetter(char),
                /// Return a class corresponding to a Unicode binary property.
                Binary(&'a str),
                /// Return a class corresponding to all codepoints whose property
                ByValue
                {
                    /// A property name.
                    property_name: &'a str,
                    /// A property value.
                    property_value: &'a str,
                },
            }

            impl<'a> ClassQuery<'a>
           
            {
                fn canonicalize(&self) -> Result<CanonicalClassQuery, Error> {
                    match *self {
                        ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),
                        ClassQuery::Binary(name) => self.canonical_binary(name),
                        ClassQuery::ByValue { property_name, property_value } => {
                            let property_name = symbolic_name_normalize(property_name);
                            let property_value = symbolic_name_normalize(property_value);

                            let canon_name = match canonical_prop(&property_name)? {
                                None => return Err(Error::PropertyNotFound),
                                Some(canon_name) => canon_name,
                            };
                            Ok(match canon_name {
                                "General_Category" => {
                                    let canon = match canonical_gencat(&property_value)? {
                                        None => return Err(Error::PropertyValueNotFound),
                                        Some(canon) => canon,
                                    };
                                    CanonicalClassQuery::GeneralCategory(canon)
                                }
                                "Script" => {
                                    let canon = match canonical_script(&property_value)? {
                                        None => return Err(Error::PropertyValueNotFound),
                                        Some(canon) => canon,
                                    };
                                    CanonicalClassQuery::Script(canon)
                                }
                                _ => {
                                    let vals = match property_values(canon_name)? {
                                        None => return Err(Error::PropertyValueNotFound),
                                        Some(vals) => vals,
                                    };
                                    let canon_val =
                                        match canonical_value(vals, &property_value) {
                                            None => {
                                                return Err(Error::PropertyValueNotFound)
                                            }
                                            Some(canon_val) => canon_val,
                                        };
                                    CanonicalClassQuery::ByValue {
                                        property_name: canon_name,
                                        property_value: canon_val,
                                    }
                                }
                            })
                        }
                    }
                }

                fn canonical_binary
                (
                    &self,
                    name: &str,
                ) -> Result<CanonicalClassQuery, Error>
                {
                    let norm = symbolic_name_normalize(name);
                    if norm != "cf" && norm != "sc" && norm != "lc" {
                        if let Some(canon) = canonical_prop(&norm)? {
                            return Ok(CanonicalClassQuery::Binary(canon));
                        }
                    }
                    if let Some(canon) = canonical_gencat(&norm)? {
                        return Ok(CanonicalClassQuery::GeneralCategory(canon));
                    }
                    if let Some(canon) = canonical_script(&norm)? {
                        return Ok(CanonicalClassQuery::Script(canon));
                    }
                    Err(Error::PropertyNotFound)
                }
            }
            /// Like ClassQuery, but its parameters have been canonicalized. This also
            #[derive(Debug, Eq, PartialEq)]
            enum CanonicalClassQuery
            {
                /// The canonical binary property name.
                Binary(&'static str),
                /// The canonical general category name.
                GeneralCategory(&'static str),
                /// The canonical script name.
                Script(&'static str),
                /// An arbitrary association between property and value, both of which
                ByValue
                {
                    /// The canonical property name.
                    property_name: &'static str,
                    /// The canonical property value.
                    property_value: &'static str,
                },
            }
            /// Looks up a Unicode class given a query. If one doesn't exist, then
            pub fn class(query: ClassQuery<'_>) -> Result<hir::ClassUnicode, Error> {
                use self::CanonicalClassQuery::*;

                match query.canonicalize()? {
                    Binary(name) => bool_property(name),
                    GeneralCategory(name) => gencat(name),
                    Script(name) => script(name),
                    ByValue { property_name: "Age", property_value } => {
                        let mut class = hir::ClassUnicode::empty();
                        for set in ages(property_value)? {
                            class.union(&hir_class(set));
                        }
                        Ok(class)
                    }
                    ByValue { property_name: "Script_Extensions", property_value } => {
                        script_extension(property_value)
                    }
                    ByValue {
                        property_name: "Grapheme_Cluster_Break",
                        property_value,
                    } => gcb(property_value),
                    ByValue { property_name: "Sentence_Break", property_value } => {
                        sb(property_value)
                    }
                    ByValue { property_name: "Word_Break", property_value } => {
                        wb(property_value)
                    }
                    _ => {
                        // What else should we support?
                        Err(Error::PropertyNotFound)
                    }
                }
            }
            /// Returns a Unicode aware class for \w.
            pub fn perl_word() -> Result<hir::ClassUnicode, Error> {
                fn imp() -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::perl_word::PERL_WORD;
                    Ok(hir_class(PERL_WORD))
                }

                imp()
            }
            /// Returns a Unicode aware class for \s.
            pub fn perl_space() -> Result<hir::ClassUnicode, Error> {
                fn imp() -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::property_bool::WHITE_SPACE;
                    Ok(hir_class(WHITE_SPACE))
                }

                imp()
            }
            /// Returns a Unicode aware class for \d.
            pub fn perl_digit() -> Result<hir::ClassUnicode, Error> {
                fn imp() -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::general_category::DECIMAL_NUMBER;
                    Ok(hir_class(DECIMAL_NUMBER))
                }

                imp()
            }
            /// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.
            pub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode
            {
                let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges
                    .iter()
                    .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))
                    .collect();
                hir::ClassUnicode::new(hir_ranges)
            }
            /// A mapping of property values for a specific property.
            type PropertyValues = &'static [(&'static str, &'static str)];

            fn canonical_gencat(
                normalized_value: &str,
            ) -> Result<Option<&'static str>, Error> {
                Ok(match normalized_value {
                    "any" => Some("Any"),
                    "assigned" => Some("Assigned"),
                    "ascii" => Some("ASCII"),
                    _ => {
                        let gencats = property_values("General_Category")?.unwrap();
                        canonical_value(gencats, normalized_value)
                    }
                })
            }

            fn canonical_script(
                normalized_value: &str,
            ) -> Result<Option<&'static str>, Error>
           
            {
                let scripts = property_values("Script")?.unwrap();
                Ok(canonical_value(scripts, normalized_value))
            }
            /// Find the canonical property name for the given normalized property name.
            fn canonical_prop(
                normalized_name: &str,
            ) -> Result<Option<&'static str>, Error> {
                fn imp(name: &str) -> Result<Option<&'static str>, Error> {
                    use ::regex::syntax::unicode_tables::property_names::PROPERTY_NAMES;

                    Ok(PROPERTY_NAMES
                        .binary_search_by_key(&name, |&(n, _)| n)
                        .ok()
                        .map(|i| PROPERTY_NAMES[i].1))
                }

                imp(normalized_name)
            }
            /// Find the canonical property value for the given normalized property
            fn canonical_value(
                vals: PropertyValues,
                normalized_value: &str,
            ) -> Option<&'static str> {
                vals.binary_search_by_key(&normalized_value, |&(n, _)| n)
                    .ok()
                    .map(|i| vals[i].1)
            }
            /// Return the table of property values for the given property name.
            fn property_values(
                canonical_property_name: &'static str,
            ) -> Result<Option<PropertyValues>, Error>
            {
                fn imp(name: &'static str) -> Result<Option<PropertyValues>, Error> {
                    use ::regex::syntax::unicode_tables::property_values::PROPERTY_VALUES;

                    Ok(PROPERTY_VALUES
                        .binary_search_by_key(&name, |&(n, _)| n)
                        .ok()
                        .map(|i| PROPERTY_VALUES[i].1))
                }

                imp(canonical_property_name)
            }
            #[allow(dead_code)]
            fn property_set(
                name_map: &'static [(&'static str, Range)],
                canonical: &'static str,
            ) -> Option<Range> {
                name_map
                    .binary_search_by_key(&canonical, |x| x.0)
                    .ok()
                    .map(|i| name_map[i].1)
            }
            /// Returns an iterator over Unicode Age sets. Each item corresponds to a set
            fn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error>
            {
                fn imp(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error>
                {
                    use ::regex::unicode_tables::age;

                    const AGES: &[(&str, Range)] = &[
                        ("V1_1", age::V1_1),
                        ("V2_0", age::V2_0),
                        ("V2_1", age::V2_1),
                        ("V3_0", age::V3_0),
                        ("V3_1", age::V3_1),
                        ("V3_2", age::V3_2),
                        ("V4_0", age::V4_0),
                        ("V4_1", age::V4_1),
                        ("V5_0", age::V5_0),
                        ("V5_1", age::V5_1),
                        ("V5_2", age::V5_2),
                        ("V6_0", age::V6_0),
                        ("V6_1", age::V6_1),
                        ("V6_2", age::V6_2),
                        ("V6_3", age::V6_3),
                        ("V7_0", age::V7_0),
                        ("V8_0", age::V8_0),
                        ("V9_0", age::V9_0),
                        ("V10_0", age::V10_0),
                        ("V11_0", age::V11_0),
                        ("V12_0", age::V12_0),
                        ("V12_1", age::V12_1),
                        ("V13_0", age::V13_0),
                        ("V14_0", age::V14_0),
                        ("V15_0", age::V15_0),
                        ("V15_1", age::V15_1),
                        ("V16_0", age::V16_0),
                    ];
                    assert_eq!(AGES.len(), age::BY_NAME.len(), "ages are out of sync");

                    let pos = AGES.iter().position(|&(age, _)| canonical_age == age);
                    match pos {
                        None => Err(Error::PropertyValueNotFound),
                        Some(i) => Ok(AGES[..=i].iter().map(|&(_, classes)| classes)),
                    }
                }

                imp(canonical_age)
            }
            /// Returns the Unicode HIR class corresponding to the given general category.
            fn gencat(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> 
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::general_category::BY_NAME;
                    match name {
                        "ASCII" => Ok(hir_class(&[('\0', '\x7F')])),
                        "Any" => Ok(hir_class(&[('\0', '\u{10FFFF}')])),
                        "Assigned" => {
                            let mut cls = gencat("Unassigned")?;
                            cls.negate();
                            Ok(cls)
                        }
                        name => property_set(BY_NAME, name)
                            .map(hir_class)
                            .ok_or(Error::PropertyValueNotFound),
                    }
                }

                match canonical_name {
                    "Decimal_Number" => perl_digit(),
                    name => imp(name),
                }
            }
            /// Returns the Unicode HIR class corresponding to the given script.
            fn script(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error> 
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::script::BY_NAME;
                    property_set(BY_NAME, name)
                        .map(hir_class)
                        .ok_or(Error::PropertyValueNotFound)
                }

                imp(canonical_name)
            }
            /// Returns the Unicode HIR class corresponding to the given script extension.
            fn script_extension(
                canonical_name: &'static str,
            ) -> Result<hir::ClassUnicode, Error>
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::script_extension::BY_NAME;
                    property_set(BY_NAME, name)
                        .map(hir_class)
                        .ok_or(Error::PropertyValueNotFound)
                }

                imp(canonical_name)
            }
            /// Returns the Unicode HIR class corresponding to the given Unicode boolean
            fn bool_property(
                canonical_name: &'static str,
            ) -> Result<hir::ClassUnicode, Error>
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error>
                {
                    use ::regex::syntax::unicode_tables::property_bool::BY_NAME;
                    property_set(BY_NAME, name)
                        .map(hir_class)
                        .ok_or(Error::PropertyNotFound)
                }

                match canonical_name {
                    "Decimal_Number" => perl_digit(),
                    "White_Space" => perl_space(),
                    name => imp(name),
                }
            }
            /// Returns the Unicode HIR class corresponding to the given grapheme cluster
            fn gcb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> 
                {
                    use ::regex::syntax::unicode_tables::grapheme_cluster_break::BY_NAME;
                    property_set(BY_NAME, name)
                        .map(hir_class)
                        .ok_or(Error::PropertyValueNotFound)
                }

                imp(canonical_name)
            }
            /// Returns the Unicode HIR class corresponding to the given word break
            fn wb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> {
                    use ::regex::syntax::unicode_tables::word_break::BY_NAME;
                    property_set(BY_NAME, name)
                        .map(hir_class)
                        .ok_or(Error::PropertyValueNotFound)
                }

                imp(canonical_name)
            }
            /// Returns the Unicode HIR class corresponding to the given sentence
            fn sb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                fn imp(name: &'static str) -> Result<hir::ClassUnicode, Error> 
                {
                    use ::regex::automata::unicode_tables::sentence_break::BY_NAME;
                    property_set(BY_NAME, name)
                    .map(hir_class)
                    .ok_or(Error::PropertyValueNotFound)
                }

                imp(canonical_name)
            }
            /// Like symbolic_name_normalize_bytes, but operates on a string.
            fn symbolic_name_normalize(x: &str) -> String
            {
                let mut tmp = x.as_bytes().to_vec();
                let len = symbolic_name_normalize_bytes(&mut tmp).len();
                tmp.truncate(len);
                String::from_utf8(tmp).unwrap()
            }
            /// Normalize the given symbolic name in place according to UAX44-LM3.
            fn symbolic_name_normalize_bytes(slice: &mut [u8]) -> &mut [u8]
            {
                let mut start = 0;
                let mut starts_with_is = false;
                if slice.len() >= 2 {
                    // Ignore any "is" prefix.
                    starts_with_is = slice[0..2] == b"is"[..]
                        || slice[0..2] == b"IS"[..]
                        || slice[0..2] == b"iS"[..]
                        || slice[0..2] == b"Is"[..];
                    if starts_with_is {
                        start = 2;
                    }
                }

                let mut next_write = 0;
                
                for i in start..slice.len()
                {
                    let b = slice[i];
                    if b == b' ' || b == b'_' || b == b'-' {
                        continue;
                    } else if b'A' <= b && b <= b'Z' {
                        slice[next_write] = b + (b'a' - b'A');
                        next_write += 1;
                    } else if b <= 0x7F {
                        slice[next_write] = b;
                        next_write += 1;
                    }
                }

                if starts_with_is && next_write == 1 && slice[0] == b'c'
                {
                    slice[0] = b'i';
                    slice[1] = b's';
                    slice[2] = b'c';
                    next_write = 3;
                }

                &mut slice[..next_write]
            }
        }

        pub mod unicode_tables
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod age
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &
                [
                    ("V10_0", V10_0),
                    ("V11_0", V11_0),
                    ("V12_0", V12_0),
                    ("V12_1", V12_1),
                    ("V13_0", V13_0),
                    ("V14_0", V14_0),
                    ("V15_0", V15_0),
                    ("V15_1", V15_1),
                    ("V16_0", V16_0),
                    ("V1_1", V1_1),
                    ("V2_0", V2_0),
                    ("V2_1", V2_1),
                    ("V3_0", V3_0),
                    ("V3_1", V3_1),
                    ("V3_2", V3_2),
                    ("V4_0", V4_0),
                    ("V4_1", V4_1),
                    ("V5_0", V5_0),
                    ("V5_1", V5_1),
                    ("V5_2", V5_2),
                    ("V6_0", V6_0),
                    ("V6_1", V6_1),
                    ("V6_2", V6_2),
                    ("V6_3", V6_3),
                    ("V7_0", V7_0),
                    ("V8_0", V8_0),
                    ("V9_0", V9_0),
                ];

                pub const V10_0: &'static [(char, char)] = &[
                    ('ࡠ', 'ࡪ'),
                    ('ৼ', '৽'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{d00}', '\u{d00}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('᳷', '᳷'),
                    ('\u{1df6}', '\u{1df9}'),
                    ('₿', '₿'),
                    ('⏿', '⏿'),
                    ('⯒', '⯒'),
                    ('⹅', '⹉'),
                    ('ㄮ', 'ㄮ'),
                    ('鿖', '鿪'),
                    ('𐌭', '𐌯'),
                    ('𑨀', '\u{11a47}'),
                    ('𑩐', '𑪃'),
                    ('𑪆', '𑪜'),
                    ('𑪞', '𑪢'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d47}'),
                    ('𑵐', '𑵙'),
                    ('𖿡', '𖿡'),
                    ('𛀂', '𛄞'),
                    ('𛅰', '𛋻'),
                    ('🉠', '🉥'),
                    ('🛓', '🛔'),
                    ('🛷', '🛸'),
                    ('🤀', '🤋'),
                    ('🤟', '🤟'),
                    ('🤨', '🤯'),
                    ('🤱', '🤲'),
                    ('🥌', '🥌'),
                    ('🥟', '🥫'),
                    ('🦒', '🦗'),
                    ('🧐', '🧦'),
                    ('𬺰', '𮯠'),
                ];

                pub const V11_0: &'static [(char, char)] = &[
                    ('ՠ', 'ՠ'),
                    ('ֈ', 'ֈ'),
                    ('ׯ', 'ׯ'),
                    ('\u{7fd}', '߿'),
                    ('\u{8d3}', '\u{8d3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('੶', '੶'),
                    ('\u{c04}', '\u{c04}'),
                    ('಄', '಄'),
                    ('ᡸ', 'ᡸ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('⮺', '⮼'),
                    ('⯓', '⯫'),
                    ('⯰', '⯾'),
                    ('⹊', '⹎'),
                    ('ㄯ', 'ㄯ'),
                    ('鿫', '鿯'),
                    ('ꞯ', 'ꞯ'),
                    ('Ꞹ', 'ꞹ'),
                    ('ꣾ', '\u{a8ff}'),
                    ('𐨴', '𐨵'),
                    ('𐩈', '𐩈'),
                    ('𐴀', '\u{10d27}'),
                    ('𐴰', '𐴹'),
                    ('𐼀', '𐼧'),
                    ('𐼰', '𐽙'),
                    ('\u{110cd}', '\u{110cd}'),
                    ('𑅄', '𑅆'),
                    ('\u{1133b}', '\u{1133b}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('𑜚', '𑜚'),
                    ('𑠀', '𑠻'),
                    ('𑪝', '𑪝'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶘'),
                    ('𑶠', '𑶩'),
                    ('𑻠', '𑻸'),
                    ('𖹀', '𖺚'),
                    ('𘟭', '𘟱'),
                    ('𝋠', '𝋳'),
                    ('𝍲', '𝍸'),
                    ('𞱱', '𞲴'),
                    ('🄯', '🄯'),
                    ('🛹', '🛹'),
                    ('🟕', '🟘'),
                    ('🥍', '🥏'),
                    ('🥬', '🥰'),
                    ('🥳', '🥶'),
                    ('🥺', '🥺'),
                    ('🥼', '🥿'),
                    ('🦘', '🦢'),
                    ('🦰', '🦹'),
                    ('🧁', '🧂'),
                    ('🧧', '🧿'),
                    ('🩠', '🩭'),
                ];

                pub const V12_0: &'static [(char, char)] = &[
                    ('౷', '౷'),
                    ('ຆ', 'ຆ'),
                    ('ຉ', 'ຉ'),
                    ('ຌ', 'ຌ'),
                    ('ຎ', 'ຓ'),
                    ('ຘ', 'ຘ'),
                    ('ຠ', 'ຠ'),
                    ('ຨ', 'ຩ'),
                    ('ຬ', 'ຬ'),
                    ('\u{eba}', '\u{eba}'),
                    ('ᳺ', 'ᳺ'),
                    ('⯉', '⯉'),
                    ('⯿', '⯿'),
                    ('⹏', '⹏'),
                    ('Ꞻ', 'ꞿ'),
                    ('Ꟃ', 'Ᶎ'),
                    ('ꭦ', 'ꭧ'),
                    ('𐿠', '𐿶'),
                    ('𑑟', '𑑟'),
                    ('𑚸', '𑚸'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '\u{119d7}'),
                    ('\u{119da}', '𑧤'),
                    ('𑪄', '𑪅'),
                    ('𑿀', '𑿱'),
                    ('𑿿', '𑿿'),
                    ('\u{13430}', '\u{13438}'),
                    ('𖽅', '𖽊'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('𖽿', '𖾇'),
                    ('𖿢', '𖿣'),
                    ('𘟲', '𘟷'),
                    ('𛅐', '𛅒'),
                    ('𛅤', '𛅧'),
                    ('𞄀', '𞄬'),
                    ('\u{1e130}', '𞄽'),
                    ('𞅀', '𞅉'),
                    ('𞅎', '𞅏'),
                    ('𞋀', '𞋹'),
                    ('𞋿', '𞋿'),
                    ('𞥋', '𞥋'),
                    ('𞴁', '𞴽'),
                    ('🅬', '🅬'),
                    ('🛕', '🛕'),
                    ('🛺', '🛺'),
                    ('🟠', '🟫'),
                    ('🤍', '🤏'),
                    ('🤿', '🤿'),
                    ('🥱', '🥱'),
                    ('🥻', '🥻'),
                    ('🦥', '🦪'),
                    ('🦮', '🦯'),
                    ('🦺', '🦿'),
                    ('🧃', '🧊'),
                    ('🧍', '🧏'),
                    ('🨀', '🩓'),
                    ('🩰', '🩳'),
                    ('🩸', '🩺'),
                    ('🪀', '🪂'),
                    ('🪐', '🪕'),
                ];

                pub const V12_1: &'static [(char, char)] = &[('㋿', '㋿')];

                pub const V13_0: &'static [(char, char)] = &[
                    ('ࢾ', 'ࣇ'),
                    ('\u{b55}', '\u{b55}'),
                    ('ഄ', 'ഄ'),
                    ('\u{d81}', '\u{d81}'),
                    ('\u{1abf}', '\u{1ac0}'),
                    ('⮗', '⮗'),
                    ('⹐', '⹒'),
                    ('ㆻ', 'ㆿ'),
                    ('䶶', '䶿'),
                    ('鿰', '鿼'),
                    ('Ꟈ', 'ꟊ'),
                    ('Ꟶ', 'ꟶ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꭨ', '꭫'),
                    ('𐆜', '𐆜'),
                    ('𐺀', '𐺩'),
                    ('\u{10eab}', '𐺭'),
                    ('𐺰', '𐺱'),
                    ('𐾰', '𐿋'),
                    ('𑅇', '𑅇'),
                    ('𑇎', '\u{111cf}'),
                    ('𑑚', '𑑚'),
                    ('𑑠', '𑑡'),
                    ('𑤀', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '𑥆'),
                    ('𑥐', '𑥙'),
                    ('𑾰', '𑾰'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𘫳', '𘳕'),
                    ('𘴀', '𘴈'),
                    ('🄍', '🄏'),
                    ('🅭', '🅯'),
                    ('🆭', '🆭'),
                    ('🛖', '🛗'),
                    ('🛻', '🛼'),
                    ('🢰', '🢱'),
                    ('🤌', '🤌'),
                    ('🥲', '🥲'),
                    ('🥷', '🥸'),
                    ('🦣', '🦤'),
                    ('🦫', '🦭'),
                    ('🧋', '🧋'),
                    ('🩴', '🩴'),
                    ('🪃', '🪆'),
                    ('🪖', '🪨'),
                    ('🪰', '🪶'),
                    ('🫀', '🫂'),
                    ('🫐', '🫖'),
                    ('🬀', '🮒'),
                    ('🮔', '🯊'),
                    ('🯰', '🯹'),
                    ('𪛗', '𪛝'),
                    ('𰀀', '𱍊'),
                ];

                pub const V14_0: &'static [(char, char)] = &[
                    ('؝', '؝'),
                    ('ࡰ', 'ࢎ'),
                    ('\u{890}', '\u{891}'),
                    ('\u{898}', '\u{89f}'),
                    ('ࢵ', 'ࢵ'),
                    ('ࣈ', '\u{8d2}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('ౝ', 'ౝ'),
                    ('ೝ', 'ೝ'),
                    ('ᜍ', 'ᜍ'),
                    ('\u{1715}', '\u{1715}'),
                    ('ᜟ', 'ᜟ'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1ac1}', '\u{1ace}'),
                    ('ᭌ', 'ᭌ'),
                    ('᭽', '᭾'),
                    ('\u{1dfa}', '\u{1dfa}'),
                    ('⃀', '⃀'),
                    ('Ⱟ', 'Ⱟ'),
                    ('ⱟ', 'ⱟ'),
                    ('⹓', '⹝'),
                    ('鿽', '鿿'),
                    ('Ꟁ', 'ꟁ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'ꟙ'),
                    ('ꟲ', 'ꟴ'),
                    ('﯂', '﯂'),
                    ('﵀', '﵏'),
                    ('﷏', '﷏'),
                    ('﷾', '﷿'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐽰', '𐾉'),
                    ('\u{11070}', '𑁵'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('𑚹', '𑚹'),
                    ('𑝀', '𑝆'),
                    ('𑪰', '𑪿'),
                    ('𒾐', '𒿲'),
                    ('𖩰', '𖪾'),
                    ('𖫀', '𖫉'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛄟', '𛄢'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('𜽐', '𜿃'),
                    ('𝇩', '𝇪'),
                    ('𝼀', '𝼞'),
                    ('𞊐', '\u{1e2ae}'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('🛝', '🛟'),
                    ('🟰', '🟰'),
                    ('🥹', '🥹'),
                    ('🧌', '🧌'),
                    ('🩻', '🩼'),
                    ('🪩', '🪬'),
                    ('🪷', '🪺'),
                    ('🫃', '🫅'),
                    ('🫗', '🫙'),
                    ('🫠', '🫧'),
                    ('🫰', '🫶'),
                    ('𪛞', '𪛟'),
                    ('𫜵', '𫜸'),
                ];

                pub const V15_0: &'static [(char, char)] = &[
                    ('ೳ', 'ೳ'),
                    ('\u{ece}', '\u{ece}'),
                    ('\u{10efd}', '\u{10eff}'),
                    ('𑈿', '\u{11241}'),
                    ('𑬀', '𑬉'),
                    ('\u{11f00}', '𑼐'),
                    ('𑼒', '\u{11f3a}'),
                    ('𑼾', '𑽙'),
                    ('𓐯', '𓐯'),
                    ('\u{13439}', '\u{13455}'),
                    ('𛄲', '𛄲'),
                    ('𛅕', '𛅕'),
                    ('𝋀', '𝋓'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('𞓐', '𞓹'),
                    ('🛜', '🛜'),
                    ('🝴', '🝶'),
                    ('🝻', '🝿'),
                    ('🟙', '🟙'),
                    ('🩵', '🩷'),
                    ('🪇', '🪈'),
                    ('🪭', '🪯'),
                    ('🪻', '🪽'),
                    ('🪿', '🪿'),
                    ('🫎', '🫏'),
                    ('🫚', '🫛'),
                    ('🫨', '🫨'),
                    ('🫷', '🫸'),
                    ('𫜹', '𫜹'),
                    ('𱍐', '𲎯'),
                ];

                pub const V15_1: &'static [(char, char)] =
                    &[('⿼', '⿿'), ('㇯', '㇯'), ('𮯰', '𮹝')];

                pub const V16_0: &'static [(char, char)] = &[
                    ('\u{897}', '\u{897}'),
                    ('᭎', '᭏'),
                    ('᭿', '᭿'),
                    ('Ᲊ', 'ᲊ'),
                    ('␧', '␩'),
                    ('㇤', '㇥'),
                    ('Ɤ', 'ꟍ'),
                    ('Ꟛ', 'Ƛ'),
                    ('𐗀', '𐗳'),
                    ('𐵀', '𐵥'),
                    ('\u{10d69}', '𐶅'),
                    ('𐶎', '𐶏'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '\u{10efc}'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏕'),
                    ('𑏗', '𑏘'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑛐', '𑛣'),
                    ('𑯀', '𑯡'),
                    ('𑯰', '𑯹'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('𓑠', '𔏺'),
                    ('𖄀', '𖄹'),
                    ('𖵀', '𖵹'),
                    ('𘳿', '𘳿'),
                    ('𜰀', '𜳹'),
                    ('𜴀', '𜺳'),
                    ('𞗐', '𞗺'),
                    ('𞗿', '𞗿'),
                    ('🢲', '🢻'),
                    ('🣀', '🣁'),
                    ('🪉', '🪉'),
                    ('🪏', '🪏'),
                    ('🪾', '🪾'),
                    ('🫆', '🫆'),
                    ('🫜', '🫜'),
                    ('🫟', '🫟'),
                    ('🫩', '🫩'),
                    ('🯋', '🯯'),
                ];

                pub const V1_1: &'static [(char, char)] = &[
                    ('\0', 'ǵ'),
                    ('Ǻ', 'ȗ'),
                    ('ɐ', 'ʨ'),
                    ('ʰ', '˞'),
                    ('ˠ', '˩'),
                    ('\u{300}', '\u{345}'),
                    ('\u{360}', '\u{361}'),
                    ('ʹ', '͵'),
                    ('ͺ', 'ͺ'),
                    (';', ';'),
                    ('΄', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ώ'),
                    ('ϐ', 'ϖ'),
                    ('Ϛ', 'Ϛ'),
                    ('Ϝ', 'Ϝ'),
                    ('Ϟ', 'Ϟ'),
                    ('Ϡ', 'Ϡ'),
                    ('Ϣ', 'ϳ'),
                    ('Ё', 'Ќ'),
                    ('Ў', 'я'),
                    ('ё', 'ќ'),
                    ('ў', '\u{486}'),
                    ('Ґ', 'ӄ'),
                    ('Ӈ', 'ӈ'),
                    ('Ӌ', 'ӌ'),
                    ('Ӑ', 'ӫ'),
                    ('Ӯ', 'ӵ'),
                    ('Ӹ', 'ӹ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', '՟'),
                    ('ա', 'և'),
                    ('։', '։'),
                    ('\u{5b0}', '\u{5b9}'),
                    ('\u{5bb}', '׃'),
                    ('א', 'ת'),
                    ('װ', '״'),
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؟', '؟'),
                    ('ء', 'غ'),
                    ('ـ', '\u{652}'),
                    ('٠', '٭'),
                    ('\u{670}', 'ڷ'),
                    ('ں', 'ھ'),
                    ('ۀ', 'ێ'),
                    ('ې', '\u{6ed}'),
                    ('۰', '۹'),
                    ('\u{901}', 'ः'),
                    ('अ', 'ह'),
                    ('\u{93c}', '\u{94d}'),
                    ('ॐ', '\u{954}'),
                    ('क़', '॰'),
                    ('\u{981}', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('০', '৺'),
                    ('\u{a02}', '\u{a02}'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', 'ੴ'),
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઋ'),
                    ('ઍ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૠ'),
                    ('૦', '૯'),
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଶ', 'ହ'),
                    ('\u{b3c}', '\u{b43}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b56}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('୦', '୰'),
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'வ'),
                    ('ஷ', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('௧', '௲'),
                    ('ఁ', 'ః'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'ళ'),
                    ('వ', 'హ'),
                    ('\u{c3e}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౠ', 'ౡ'),
                    ('౦', '౯'),
                    ('ಂ', 'ಃ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಾ', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೞ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('೦', '೯'),
                    ('ം', 'ഃ'),
                    ('അ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ന'),
                    ('പ', 'ഹ'),
                    ('\u{d3e}', '\u{d43}'),
                    ('െ', 'ൈ'),
                    ('ൊ', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('ൠ', 'ൡ'),
                    ('൦', '൯'),
                    ('ก', '\u{e3a}'),
                    ('฿', '๛'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ງ', 'ຈ'),
                    ('ຊ', 'ຊ'),
                    ('ຍ', 'ຍ'),
                    ('ດ', 'ທ'),
                    ('ນ', 'ຟ'),
                    ('ມ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ວ'),
                    ('ສ', 'ຫ'),
                    ('ອ', '\u{eb9}'),
                    ('\u{ebb}', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ecd}'),
                    ('໐', '໙'),
                    ('ໜ', 'ໝ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('ა', 'ჶ'),
                    ('჻', '჻'),
                    ('ᄀ', 'ᅙ'),
                    ('ᅟ', 'ᆢ'),
                    ('ᆨ', 'ᇹ'),
                    ('Ḁ', 'ẚ'),
                    ('Ạ', 'ỹ'),
                    ('ἀ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ῄ'),
                    ('ῆ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('῝', '`'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', '῾'),
                    ('\u{2000}', '\u{202e}'),
                    ('‰', '⁆'),
                    ('\u{206a}', '⁰'),
                    ('⁴', '₎'),
                    ('₠', '₪'),
                    ('\u{20d0}', '\u{20e1}'),
                    ('℀', 'ℸ'),
                    ('⅓', 'ↂ'),
                    ('←', '⇪'),
                    ('∀', '⋱'),
                    ('⌀', '⌀'),
                    ('⌂', '⍺'),
                    ('␀', '␤'),
                    ('⑀', '⑊'),
                    ('①', '⓪'),
                    ('─', '▕'),
                    ('■', '◯'),
                    ('☀', '☓'),
                    ('☚', '♯'),
                    ('✁', '✄'),
                    ('✆', '✉'),
                    ('✌', '✧'),
                    ('✩', '❋'),
                    ('❍', '❍'),
                    ('❏', '❒'),
                    ('❖', '❖'),
                    ('❘', '❞'),
                    ('❡', '❧'),
                    ('❶', '➔'),
                    ('➘', '➯'),
                    ('➱', '➾'),
                    ('\u{3000}', '〷'),
                    ('〿', '〿'),
                    ('ぁ', 'ゔ'),
                    ('\u{3099}', 'ゞ'),
                    ('ァ', 'ヾ'),
                    ('ㄅ', 'ㄬ'),
                    ('ㄱ', 'ㆎ'),
                    ('㆐', '㆟'),
                    ('㈀', '㈜'),
                    ('㈠', '㉃'),
                    ('㉠', '㉻'),
                    ('㉿', '㊰'),
                    ('㋀', '㋋'),
                    ('㋐', '㋾'),
                    ('㌀', '㍶'),
                    ('㍻', '㏝'),
                    ('㏠', '㏾'),
                    ('一', '龥'),
                    ('\u{e000}', '鶴'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('\u{fb1e}', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', '﴿'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('\u{fe20}', '\u{fe23}'),
                    ('︰', '﹄'),
                    ('﹉', '﹒'),
                    ('﹔', '﹦'),
                    ('﹨', '﹫'),
                    ('ﹰ', 'ﹲ'),
                    ('ﹴ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('\u{feff}', '\u{feff}'),
                    ('！', '～'),
                    ('｡', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('￠', '￦'),
                    ('￨', '￮'),
                    (' ', '\u{ffff}'),
                ];

                pub const V2_0: &'static [(char, char)] = &[
                    ('\u{591}', '\u{5a1}'),
                    ('\u{5a3}', '\u{5af}'),
                    ('\u{5c4}', '\u{5c4}'),
                    ('ༀ', 'ཇ'),
                    ('ཉ', 'ཀྵ'),
                    ('\u{f71}', 'ྋ'),
                    ('\u{f90}', '\u{f95}'),
                    ('\u{f97}', '\u{f97}'),
                    ('\u{f99}', '\u{fad}'),
                    ('\u{fb1}', '\u{fb7}'),
                    ('\u{fb9}', '\u{fb9}'),
                    ('ẛ', 'ẛ'),
                    ('₫', '₫'),
                    ('가', '힣'),
                    ('\u{1fffe}', '\u{1ffff}'),
                    ('\u{2fffe}', '\u{2ffff}'),
                    ('\u{3fffe}', '\u{3ffff}'),
                    ('\u{4fffe}', '\u{4ffff}'),
                    ('\u{5fffe}', '\u{5ffff}'),
                    ('\u{6fffe}', '\u{6ffff}'),
                    ('\u{7fffe}', '\u{7ffff}'),
                    ('\u{8fffe}', '\u{8ffff}'),
                    ('\u{9fffe}', '\u{9ffff}'),
                    ('\u{afffe}', '\u{affff}'),
                    ('\u{bfffe}', '\u{bffff}'),
                    ('\u{cfffe}', '\u{cffff}'),
                    ('\u{dfffe}', '\u{dffff}'),
                    ('\u{efffe}', '\u{10ffff}'),
                ];

                pub const V2_1: &'static [(char, char)] = &[('€', '€'), (' ', ' ')];

                pub const V3_0: &'static [(char, char)] = &[
                    ('Ƕ', 'ǹ'),
                    ('Ș', 'ȟ'),
                    ('Ȣ', 'ȳ'),
                    ('ʩ', 'ʭ'),
                    ('˟', '˟'),
                    ('˪', 'ˮ'),
                    ('\u{346}', '\u{34e}'),
                    ('\u{362}', '\u{362}'),
                    ('ϗ', 'ϗ'),
                    ('ϛ', 'ϛ'),
                    ('ϝ', 'ϝ'),
                    ('ϟ', 'ϟ'),
                    ('ϡ', 'ϡ'),
                    ('Ѐ', 'Ѐ'),
                    ('Ѝ', 'Ѝ'),
                    ('ѐ', 'ѐ'),
                    ('ѝ', 'ѝ'),
                    ('\u{488}', '\u{489}'),
                    ('Ҍ', 'ҏ'),
                    ('Ӭ', 'ӭ'),
                    ('֊', '֊'),
                    ('\u{653}', '\u{655}'),
                    ('ڸ', 'ڹ'),
                    ('ڿ', 'ڿ'),
                    ('ۏ', 'ۏ'),
                    ('ۺ', '۾'),
                    ('܀', '܍'),
                    ('\u{70f}', 'ܬ'),
                    ('\u{730}', '\u{74a}'),
                    ('ހ', '\u{7b0}'),
                    ('ං', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', '෴'),
                    ('ཪ', 'ཪ'),
                    ('\u{f96}', '\u{f96}'),
                    ('\u{fae}', '\u{fb0}'),
                    ('\u{fb8}', '\u{fb8}'),
                    ('\u{fba}', '\u{fbc}'),
                    ('྾', '࿌'),
                    ('࿏', '࿏'),
                    ('က', 'အ'),
                    ('ဣ', 'ဧ'),
                    ('ဩ', 'ဪ'),
                    ('ာ', '\u{1032}'),
                    ('\u{1036}', '\u{1039}'),
                    ('၀', '\u{1059}'),
                    ('ሀ', 'ሆ'),
                    ('ለ', 'ቆ'),
                    ('ቈ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኆ'),
                    ('ኈ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኮ'),
                    ('ኰ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዎ'),
                    ('ዐ', 'ዖ'),
                    ('ዘ', 'ዮ'),
                    ('ደ', 'ጎ'),
                    ('ጐ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ጞ'),
                    ('ጠ', 'ፆ'),
                    ('ፈ', 'ፚ'),
                    ('፡', '፼'),
                    ('Ꭰ', 'Ᏼ'),
                    ('ᐁ', 'ᙶ'),
                    ('\u{1680}', '᚜'),
                    ('ᚠ', 'ᛰ'),
                    ('ក', 'ៜ'),
                    ('០', '៩'),
                    ('᠀', '\u{180e}'),
                    ('᠐', '᠙'),
                    ('ᠠ', 'ᡷ'),
                    ('ᢀ', '\u{18a9}'),
                    ('\u{202f}', '\u{202f}'),
                    ('⁈', '⁍'),
                    ('₭', '₯'),
                    ('\u{20e2}', '\u{20e3}'),
                    ('ℹ', '℺'),
                    ('Ↄ', 'Ↄ'),
                    ('⇫', '⇳'),
                    ('⌁', '⌁'),
                    ('⍻', '⍻'),
                    ('⍽', '⎚'),
                    ('␥', '␦'),
                    ('◰', '◷'),
                    ('☙', '☙'),
                    ('♰', '♱'),
                    ('⠀', '⣿'),
                    ('⺀', '⺙'),
                    ('⺛', '⻳'),
                    ('⼀', '⿕'),
                    ('⿰', '⿻'),
                    ('〸', '〺'),
                    ('〾', '〾'),
                    ('ㆠ', 'ㆷ'),
                    ('㐀', '䶵'),
                    ('ꀀ', 'ꒌ'),
                    ('꒐', '꒡'),
                    ('꒤', '꒳'),
                    ('꒵', '꓀'),
                    ('꓂', '꓄'),
                    ('꓆', '꓆'),
                    ('יִ', 'יִ'),
                    ('\u{fff9}', '\u{fffb}'),
                ];

                pub const V3_1: &'static [(char, char)] = &[
                    ('ϴ', 'ϵ'),
                    ('\u{fdd0}', '\u{fdef}'),
                    ('𐌀', '𐌞'),
                    ('𐌠', '𐌣'),
                    ('𐌰', '𐍊'),
                    ('𐐀', '𐐥'),
                    ('𐐨', '𐑍'),
                    ('𝀀', '𝃵'),
                    ('𝄀', '𝄦'),
                    ('𝄪', '𝇝'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓀'),
                    ('𝓂', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚣'),
                    ('𝚨', '𝟉'),
                    ('𝟎', '𝟿'),
                    ('𠀀', '𪛖'),
                    ('丽', '𪘀'),
                    ('\u{e0001}', '\u{e0001}'),
                    ('\u{e0020}', '\u{e007f}'),
                ];

                pub const V3_2: &'static [(char, char)] = &[
                    ('Ƞ', 'Ƞ'),
                    ('\u{34f}', '\u{34f}'),
                    ('\u{363}', '\u{36f}'),
                    ('Ϙ', 'ϙ'),
                    ('϶', '϶'),
                    ('Ҋ', 'ҋ'),
                    ('Ӆ', 'ӆ'),
                    ('Ӊ', 'ӊ'),
                    ('Ӎ', 'ӎ'),
                    ('Ԁ', 'ԏ'),
                    ('ٮ', 'ٯ'),
                    ('ޱ', 'ޱ'),
                    ('ჷ', 'ჸ'),
                    ('ᜀ', 'ᜌ'),
                    ('ᜎ', '\u{1714}'),
                    ('ᜠ', '᜶'),
                    ('ᝀ', '\u{1753}'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('\u{1772}', '\u{1773}'),
                    ('⁇', '⁇'),
                    ('⁎', '⁒'),
                    ('⁗', '⁗'),
                    ('\u{205f}', '\u{2063}'),
                    ('ⁱ', 'ⁱ'),
                    ('₰', '₱'),
                    ('\u{20e4}', '\u{20ea}'),
                    ('ℽ', '⅋'),
                    ('⇴', '⇿'),
                    ('⋲', '⋿'),
                    ('⍼', '⍼'),
                    ('⎛', '⏎'),
                    ('⓫', '⓾'),
                    ('▖', '▟'),
                    ('◸', '◿'),
                    ('☖', '☗'),
                    ('♲', '♽'),
                    ('⚀', '⚉'),
                    ('❨', '❵'),
                    ('⟐', '⟫'),
                    ('⟰', '⟿'),
                    ('⤀', '⫿'),
                    ('〻', '〽'),
                    ('ゕ', 'ゖ'),
                    ('ゟ', '゠'),
                    ('ヿ', 'ヿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㉑', '㉟'),
                    ('㊱', '㊿'),
                    ('꒢', '꒣'),
                    ('꒴', '꒴'),
                    ('꓁', '꓁'),
                    ('꓅', '꓅'),
                    ('侮', '頻'),
                    ('﷼', '﷼'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('﹅', '﹆'),
                    ('ﹳ', 'ﹳ'),
                    ('｟', '｠'),
                ];

                pub const V4_0: &'static [(char, char)] = &[
                    ('ȡ', 'ȡ'),
                    ('ȴ', 'ȶ'),
                    ('ʮ', 'ʯ'),
                    ('˯', '˿'),
                    ('\u{350}', '\u{357}'),
                    ('\u{35d}', '\u{35f}'),
                    ('Ϸ', 'ϻ'),
                    ('\u{600}', '\u{603}'),
                    ('؍', '\u{615}'),
                    ('\u{656}', '\u{658}'),
                    ('ۮ', 'ۯ'),
                    ('ۿ', 'ۿ'),
                    ('ܭ', 'ܯ'),
                    ('ݍ', 'ݏ'),
                    ('ऄ', 'ऄ'),
                    ('ঽ', 'ঽ'),
                    ('\u{a01}', '\u{a01}'),
                    ('ਃ', 'ਃ'),
                    ('ઌ', 'ઌ'),
                    ('ૡ', '\u{ae3}'),
                    ('૱', '૱'),
                    ('ଵ', 'ଵ'),
                    ('ୱ', 'ୱ'),
                    ('௳', '௺'),
                    ('\u{cbc}', 'ಽ'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('៰', '៹'),
                    ('ᤀ', 'ᤜ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('᥀', '᥀'),
                    ('᥄', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('᧠', '᧿'),
                    ('ᴀ', 'ᵫ'),
                    ('⁓', '⁔'),
                    ('℻', '℻'),
                    ('⏏', '⏐'),
                    ('⓿', '⓿'),
                    ('☔', '☕'),
                    ('⚊', '⚑'),
                    ('⚠', '⚡'),
                    ('⬀', '⬍'),
                    ('㈝', '㈞'),
                    ('㉐', '㉐'),
                    ('㉼', '㉽'),
                    ('㋌', '㋏'),
                    ('㍷', '㍺'),
                    ('㏞', '㏟'),
                    ('㏿', '㏿'),
                    ('䷀', '䷿'),
                    ('﷽', '﷽'),
                    ('﹇', '﹈'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐄀', '𐄂'),
                    ('𐄇', '𐄳'),
                    ('𐄷', '𐄿'),
                    ('𐎀', '𐎝'),
                    ('𐎟', '𐎟'),
                    ('𐐦', '𐐧'),
                    ('𐑎', '𐒝'),
                    ('𐒠', '𐒩'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐠿'),
                    ('𝌀', '𝍖'),
                    ('𝓁', '𝓁'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const V4_1: &'static [(char, char)] = &[
                    ('ȷ', 'Ɂ'),
                    ('\u{358}', '\u{35c}'),
                    ('ϼ', 'Ͽ'),
                    ('Ӷ', 'ӷ'),
                    ('\u{5a2}', '\u{5a2}'),
                    ('\u{5c5}', '\u{5c7}'),
                    ('؋', '؋'),
                    ('؞', '؞'),
                    ('\u{659}', '\u{65e}'),
                    ('ݐ', 'ݭ'),
                    ('ॽ', 'ॽ'),
                    ('ৎ', 'ৎ'),
                    ('ஶ', 'ஶ'),
                    ('௦', '௦'),
                    ('࿐', '࿑'),
                    ('ჹ', 'ჺ'),
                    ('ჼ', 'ჼ'),
                    ('ሇ', 'ሇ'),
                    ('ቇ', 'ቇ'),
                    ('ኇ', 'ኇ'),
                    ('ኯ', 'ኯ'),
                    ('ዏ', 'ዏ'),
                    ('ዯ', 'ዯ'),
                    ('ጏ', 'ጏ'),
                    ('ጟ', 'ጟ'),
                    ('ፇ', 'ፇ'),
                    ('\u{135f}', '፠'),
                    ('ᎀ', '᎙'),
                    ('ᦀ', 'ᦩ'),
                    ('ᦰ', 'ᧉ'),
                    ('᧐', '᧙'),
                    ('᧞', '᧟'),
                    ('ᨀ', '\u{1a1b}'),
                    ('᨞', '᨟'),
                    ('ᵬ', '\u{1dc3}'),
                    ('⁕', '⁖'),
                    ('⁘', '⁞'),
                    ('ₐ', 'ₔ'),
                    ('₲', '₵'),
                    ('\u{20eb}', '\u{20eb}'),
                    ('ℼ', 'ℼ'),
                    ('⅌', '⅌'),
                    ('⏑', '⏛'),
                    ('☘', '☘'),
                    ('♾', '♿'),
                    ('⚒', '⚜'),
                    ('⚢', '⚱'),
                    ('⟀', '⟆'),
                    ('⬎', '⬓'),
                    ('Ⰰ', 'Ⱞ'),
                    ('ⰰ', 'ⱞ'),
                    ('Ⲁ', '⳪'),
                    ('⳹', 'ⴥ'),
                    ('ⴰ', 'ⵥ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('⸀', '⸗'),
                    ('⸜', '⸝'),
                    ('㇀', '㇏'),
                    ('㉾', '㉾'),
                    ('龦', '龻'),
                    ('꜀', '꜖'),
                    ('ꠀ', '꠫'),
                    ('並', '龎'),
                    ('︐', '︙'),
                    ('𐅀', '𐆊'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏕'),
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨳'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '𐩇'),
                    ('𐩐', '𐩘'),
                    ('𝈀', '𝉅'),
                    ('𝚤', '𝚥'),
                ];

                pub const V5_0: &'static [(char, char)] = &[
                    ('ɂ', 'ɏ'),
                    ('ͻ', 'ͽ'),
                    ('ӏ', 'ӏ'),
                    ('Ӻ', 'ӿ'),
                    ('Ԑ', 'ԓ'),
                    ('\u{5ba}', '\u{5ba}'),
                    ('߀', 'ߺ'),
                    ('ॻ', 'ॼ'),
                    ('ॾ', 'ॿ'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('ೱ', 'ೲ'),
                    ('\u{1b00}', 'ᭋ'),
                    ('᭐', '᭼'),
                    ('\u{1dc4}', '\u{1dca}'),
                    ('\u{1dfe}', '\u{1dff}'),
                    ('\u{20ec}', '\u{20ef}'),
                    ('⅍', 'ⅎ'),
                    ('ↄ', 'ↄ'),
                    ('⏜', '⏧'),
                    ('⚲', '⚲'),
                    ('⟇', '⟊'),
                    ('⬔', '⬚'),
                    ('⬠', '⬣'),
                    ('Ⱡ', 'ⱬ'),
                    ('ⱴ', 'ⱷ'),
                    ('ꜗ', 'ꜚ'),
                    ('꜠', '꜡'),
                    ('ꡀ', '꡷'),
                    ('𐤀', '𐤙'),
                    ('𐤟', '𐤟'),
                    ('𒀀', '𒍮'),
                    ('𒐀', '𒑢'),
                    ('𒑰', '𒑳'),
                    ('𝍠', '𝍱'),
                    ('𝟊', '𝟋'),
                ];

                pub const V5_1: &'static [(char, char)] = &[
                    ('Ͱ', 'ͳ'),
                    ('Ͷ', 'ͷ'),
                    ('Ϗ', 'Ϗ'),
                    ('\u{487}', '\u{487}'),
                    ('Ԕ', 'ԣ'),
                    ('؆', '؊'),
                    ('\u{616}', '\u{61a}'),
                    ('ػ', 'ؿ'),
                    ('ݮ', 'ݿ'),
                    ('ॱ', 'ॲ'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{b44}', '\u{b44}'),
                    ('\u{b62}', '\u{b63}'),
                    ('ௐ', 'ௐ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౙ'),
                    ('\u{c62}', '\u{c63}'),
                    ('౸', '౿'),
                    ('ഽ', 'ഽ'),
                    ('\u{d44}', '\u{d44}'),
                    ('\u{d62}', '\u{d63}'),
                    ('൰', '൵'),
                    ('൹', 'ൿ'),
                    ('ཫ', 'ཬ'),
                    ('࿎', '࿎'),
                    ('࿒', '࿔'),
                    ('ဢ', 'ဢ'),
                    ('ဨ', 'ဨ'),
                    ('ါ', 'ါ'),
                    ('\u{1033}', '\u{1035}'),
                    ('\u{103a}', 'ဿ'),
                    ('ၚ', '႙'),
                    ('႞', '႟'),
                    ('ᢪ', 'ᢪ'),
                    ('\u{1b80}', '\u{1baa}'),
                    ('ᮮ', '᮹'),
                    ('ᰀ', '\u{1c37}'),
                    ('᰻', '᱉'),
                    ('ᱍ', '᱿'),
                    ('\u{1dcb}', '\u{1de6}'),
                    ('ẜ', 'ẟ'),
                    ('Ỻ', 'ỿ'),
                    ('\u{2064}', '\u{2064}'),
                    ('\u{20f0}', '\u{20f0}'),
                    ('⅏', '⅏'),
                    ('ↅ', 'ↈ'),
                    ('⚝', '⚝'),
                    ('⚳', '⚼'),
                    ('⛀', '⛃'),
                    ('⟌', '⟌'),
                    ('⟬', '⟯'),
                    ('⬛', '⬟'),
                    ('⬤', '⭌'),
                    ('⭐', '⭔'),
                    ('Ɑ', 'Ɐ'),
                    ('ⱱ', 'ⱳ'),
                    ('ⱸ', 'ⱽ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('⸘', '⸛'),
                    ('⸞', '⸰'),
                    ('ㄭ', 'ㄭ'),
                    ('㇐', '㇣'),
                    ('龼', '鿃'),
                    ('ꔀ', 'ꘫ'),
                    ('Ꙁ', 'ꙟ'),
                    ('Ꙣ', '꙳'),
                    ('\u{a67c}', 'ꚗ'),
                    ('ꜛ', 'ꜟ'),
                    ('Ꜣ', 'ꞌ'),
                    ('ꟻ', 'ꟿ'),
                    ('ꢀ', '\u{a8c4}'),
                    ('꣎', '꣙'),
                    ('꤀', '\u{a953}'),
                    ('꥟', '꥟'),
                    ('ꨀ', '\u{aa36}'),
                    ('ꩀ', 'ꩍ'),
                    ('꩐', '꩙'),
                    ('꩜', '꩟'),
                    ('\u{fe24}', '\u{fe26}'),
                    ('𐆐', '𐆛'),
                    ('𐇐', '\u{101fd}'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐤠', '𐤹'),
                    ('𐤿', '𐤿'),
                    ('𝄩', '𝄩'),
                    ('🀀', '🀫'),
                    ('🀰', '🂓'),
                ];

                pub const V5_2: &'static [(char, char)] = &[
                    ('Ԥ', 'ԥ'),
                    ('ࠀ', '\u{82d}'),
                    ('࠰', '࠾'),
                    ('\u{900}', '\u{900}'),
                    ('ॎ', 'ॎ'),
                    ('\u{955}', '\u{955}'),
                    ('ॹ', 'ॺ'),
                    ('৻', '৻'),
                    ('࿕', '࿘'),
                    ('ႚ', '\u{109d}'),
                    ('ᅚ', 'ᅞ'),
                    ('ᆣ', 'ᆧ'),
                    ('ᇺ', 'ᇿ'),
                    ('᐀', '᐀'),
                    ('ᙷ', 'ᙿ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᦪ', 'ᦫ'),
                    ('᧚', '᧚'),
                    ('ᨠ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '᪉'),
                    ('᪐', '᪙'),
                    ('᪠', '᪭'),
                    ('\u{1cd0}', 'ᳲ'),
                    ('\u{1dfd}', '\u{1dfd}'),
                    ('₶', '₸'),
                    ('⅐', '⅒'),
                    ('↉', '↉'),
                    ('⏨', '⏨'),
                    ('⚞', '⚟'),
                    ('⚽', '⚿'),
                    ('⛄', '⛍'),
                    ('⛏', '⛡'),
                    ('⛣', '⛣'),
                    ('⛨', '⛿'),
                    ('❗', '❗'),
                    ('⭕', '⭙'),
                    ('Ɒ', 'Ɒ'),
                    ('Ȿ', 'Ɀ'),
                    ('Ⳬ', '\u{2cf1}'),
                    ('⸱', '⸱'),
                    ('㉄', '㉏'),
                    ('鿄', '鿋'),
                    ('ꓐ', '꓿'),
                    ('ꚠ', '꛷'),
                    ('꠰', '꠹'),
                    ('\u{a8e0}', 'ꣻ'),
                    ('ꥠ', 'ꥼ'),
                    ('\u{a980}', '꧍'),
                    ('ꧏ', '꧙'),
                    ('꧞', '꧟'),
                    ('ꩠ', 'ꩻ'),
                    ('ꪀ', 'ꫂ'),
                    ('ꫛ', '꫟'),
                    ('ꯀ', '\u{abed}'),
                    ('꯰', '꯹'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('恵', '舘'),
                    ('𐡀', '𐡕'),
                    ('𐡗', '𐡟'),
                    ('𐤚', '𐤛'),
                    ('𐩠', '𐩿'),
                    ('𐬀', '𐬵'),
                    ('𐬹', '𐭕'),
                    ('𐭘', '𐭲'),
                    ('𐭸', '𐭿'),
                    ('𐰀', '𐱈'),
                    ('𐹠', '𐹾'),
                    ('\u{11080}', '𑃁'),
                    ('𓀀', '𓐮'),
                    ('🄀', '🄊'),
                    ('🄐', '🄮'),
                    ('🄱', '🄱'),
                    ('🄽', '🄽'),
                    ('🄿', '🄿'),
                    ('🅂', '🅂'),
                    ('🅆', '🅆'),
                    ('🅊', '🅎'),
                    ('🅗', '🅗'),
                    ('🅟', '🅟'),
                    ('🅹', '🅹'),
                    ('🅻', '🅼'),
                    ('🅿', '🅿'),
                    ('🆊', '🆍'),
                    ('🆐', '🆐'),
                    ('🈀', '🈀'),
                    ('🈐', '🈱'),
                    ('🉀', '🉈'),
                    ('𪜀', '𫜴'),
                ];

                pub const V6_0: &'static [(char, char)] = &[
                    ('Ԧ', 'ԧ'),
                    ('ؠ', 'ؠ'),
                    ('\u{65f}', '\u{65f}'),
                    ('ࡀ', '\u{85b}'),
                    ('࡞', '࡞'),
                    ('\u{93a}', 'ऻ'),
                    ('ॏ', 'ॏ'),
                    ('\u{956}', '\u{957}'),
                    ('ॳ', 'ॷ'),
                    ('୲', '୷'),
                    ('ഩ', 'ഩ'),
                    ('ഺ', 'ഺ'),
                    ('ൎ', 'ൎ'),
                    ('ྌ', '\u{f8f}'),
                    ('࿙', '࿚'),
                    ('\u{135d}', '\u{135e}'),
                    ('ᯀ', '\u{1bf3}'),
                    ('᯼', '᯿'),
                    ('\u{1dfc}', '\u{1dfc}'),
                    ('ₕ', 'ₜ'),
                    ('₹', '₹'),
                    ('⏩', '⏳'),
                    ('⛎', '⛎'),
                    ('⛢', '⛢'),
                    ('⛤', '⛧'),
                    ('✅', '✅'),
                    ('✊', '✋'),
                    ('✨', '✨'),
                    ('❌', '❌'),
                    ('❎', '❎'),
                    ('❓', '❕'),
                    ('❟', '❠'),
                    ('➕', '➗'),
                    ('➰', '➰'),
                    ('➿', '➿'),
                    ('⟎', '⟏'),
                    ('⵰', '⵰'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('ㆸ', 'ㆺ'),
                    ('Ꙡ', 'ꙡ'),
                    ('Ɥ', 'ꞎ'),
                    ('Ꞑ', 'ꞑ'),
                    ('Ꞡ', 'ꞩ'),
                    ('ꟺ', 'ꟺ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('﮲', '﯁'),
                    ('𑀀', '𑁍'),
                    ('𑁒', '𑁯'),
                    ('𖠀', '𖨸'),
                    ('𛀀', '𛀁'),
                    ('🂠', '🂮'),
                    ('🂱', '🂾'),
                    ('🃁', '🃏'),
                    ('🃑', '🃟'),
                    ('🄰', '🄰'),
                    ('🄲', '🄼'),
                    ('🄾', '🄾'),
                    ('🅀', '🅁'),
                    ('🅃', '🅅'),
                    ('🅇', '🅉'),
                    ('🅏', '🅖'),
                    ('🅘', '🅞'),
                    ('🅠', '🅩'),
                    ('🅰', '🅸'),
                    ('🅺', '🅺'),
                    ('🅽', '🅾'),
                    ('🆀', '🆉'),
                    ('🆎', '🆏'),
                    ('🆑', '🆚'),
                    ('🇦', '🇿'),
                    ('🈁', '🈂'),
                    ('🈲', '🈺'),
                    ('🉐', '🉑'),
                    ('🌀', '🌠'),
                    ('🌰', '🌵'),
                    ('🌷', '🍼'),
                    ('🎀', '🎓'),
                    ('🎠', '🏄'),
                    ('🏆', '🏊'),
                    ('🏠', '🏰'),
                    ('🐀', '🐾'),
                    ('👀', '👀'),
                    ('👂', '📷'),
                    ('📹', '📼'),
                    ('🔀', '🔽'),
                    ('🕐', '🕧'),
                    ('🗻', '🗿'),
                    ('😁', '😐'),
                    ('😒', '😔'),
                    ('😖', '😖'),
                    ('😘', '😘'),
                    ('😚', '😚'),
                    ('😜', '😞'),
                    ('😠', '😥'),
                    ('😨', '😫'),
                    ('😭', '😭'),
                    ('😰', '😳'),
                    ('😵', '🙀'),
                    ('🙅', '🙏'),
                    ('🚀', '🛅'),
                    ('🜀', '🝳'),
                    ('𫝀', '𫠝'),
                ];

                pub const V6_1: &'static [(char, char)] = &[
                    ('֏', '֏'),
                    ('\u{604}', '\u{604}'),
                    ('ࢠ', 'ࢠ'),
                    ('ࢢ', 'ࢬ'),
                    ('\u{8e4}', '\u{8fe}'),
                    ('૰', '૰'),
                    ('ໞ', 'ໟ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ჽ', 'ჿ'),
                    ('\u{1bab}', '\u{1bad}'),
                    ('ᮺ', 'ᮿ'),
                    ('᳀', '᳇'),
                    ('ᳳ', 'ᳶ'),
                    ('⟋', '⟋'),
                    ('⟍', '⟍'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⵦ', 'ⵧ'),
                    ('⸲', '⸻'),
                    ('鿌', '鿌'),
                    ('\u{a674}', '\u{a67b}'),
                    ('\u{a69f}', '\u{a69f}'),
                    ('Ꞓ', 'ꞓ'),
                    ('Ɦ', 'Ɦ'),
                    ('ꟸ', 'ꟹ'),
                    ('ꫠ', '\u{aaf6}'),
                    ('郞', '隷'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𑃐', '𑃨'),
                    ('𑃰', '𑃹'),
                    ('\u{11100}', '\u{11134}'),
                    ('𑄶', '𑅃'),
                    ('\u{11180}', '𑇈'),
                    ('𑇐', '𑇙'),
                    ('𑚀', '\u{116b7}'),
                    ('𑛀', '𑛉'),
                    ('𖼀', '𖽄'),
                    ('𖽐', '𖽾'),
                    ('\u{16f8f}', '𖾟'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𞻰', '𞻱'),
                    ('🅪', '🅫'),
                    ('🕀', '🕃'),
                    ('😀', '😀'),
                    ('😑', '😑'),
                    ('😕', '😕'),
                    ('😗', '😗'),
                    ('😙', '😙'),
                    ('😛', '😛'),
                    ('😟', '😟'),
                    ('😦', '😧'),
                    ('😬', '😬'),
                    ('😮', '😯'),
                    ('😴', '😴'),
                ];

                pub const V6_2: &'static [(char, char)] = &[('₺', '₺')];

                pub const V6_3: &'static [(char, char)] =
                    &[('\u{61c}', '\u{61c}'), ('\u{2066}', '\u{2069}')];

                pub const V7_0: &'static [(char, char)] = &[
                    ('Ϳ', 'Ϳ'),
                    ('Ԩ', 'ԯ'),
                    ('֍', '֎'),
                    ('\u{605}', '\u{605}'),
                    ('ࢡ', 'ࢡ'),
                    ('ࢭ', 'ࢲ'),
                    ('\u{8ff}', '\u{8ff}'),
                    ('ॸ', 'ॸ'),
                    ('ঀ', 'ঀ'),
                    ('\u{c00}', '\u{c00}'),
                    ('ఴ', 'ఴ'),
                    ('\u{c81}', '\u{c81}'),
                    ('\u{d01}', '\u{d01}'),
                    ('෦', '෯'),
                    ('ᛱ', 'ᛸ'),
                    ('ᤝ', 'ᤞ'),
                    ('\u{1ab0}', '\u{1abe}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{1de7}', '\u{1df5}'),
                    ('₻', '₽'),
                    ('⏴', '⏺'),
                    ('✀', '✀'),
                    ('⭍', '⭏'),
                    ('⭚', '⭳'),
                    ('⭶', '⮕'),
                    ('⮘', '⮹'),
                    ('⮽', '⯈'),
                    ('⯊', '⯑'),
                    ('⸼', '⹂'),
                    ('Ꚙ', 'ꚝ'),
                    ('ꞔ', 'ꞟ'),
                    ('Ɜ', 'Ɬ'),
                    ('Ʞ', 'Ʇ'),
                    ('ꟷ', 'ꟷ'),
                    ('ꧠ', 'ꧾ'),
                    ('\u{aa7c}', 'ꩿ'),
                    ('ꬰ', 'ꭟ'),
                    ('ꭤ', 'ꭥ'),
                    ('\u{fe27}', '\u{fe2d}'),
                    ('𐆋', '𐆌'),
                    ('𐆠', '𐆠'),
                    ('\u{102e0}', '𐋻'),
                    ('𐌟', '𐌟'),
                    ('𐍐', '\u{1037a}'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕯', '𐕯'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐡠', '𐢞'),
                    ('𐢧', '𐢯'),
                    ('𐪀', '𐪟'),
                    ('𐫀', '\u{10ae6}'),
                    ('𐫫', '𐫶'),
                    ('𐮀', '𐮑'),
                    ('𐮙', '𐮜'),
                    ('𐮩', '𐮯'),
                    ('\u{1107f}', '\u{1107f}'),
                    ('𑅐', '𑅶'),
                    ('𑇍', '𑇍'),
                    ('𑇚', '𑇚'),
                    ('𑇡', '𑇴'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈽'),
                    ('𑊰', '\u{112ea}'),
                    ('𑋰', '𑋹'),
                    ('\u{11301}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('\u{1133c}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('𑒀', '𑓇'),
                    ('𑓐', '𑓙'),
                    ('𑖀', '\u{115b5}'),
                    ('𑖸', '𑗉'),
                    ('𑘀', '𑙄'),
                    ('𑙐', '𑙙'),
                    ('𑢠', '𑣲'),
                    ('𑣿', '𑣿'),
                    ('𑫀', '𑫸'),
                    ('𒍯', '𒎘'),
                    ('𒑣', '𒑮'),
                    ('𒑴', '𒑴'),
                    ('𖩀', '𖩞'),
                    ('𖩠', '𖩩'),
                    ('𖩮', '𖩯'),
                    ('𖫐', '𖫭'),
                    ('\u{16af0}', '𖫵'),
                    ('𖬀', '𖭅'),
                    ('𖭐', '𖭙'),
                    ('𖭛', '𖭡'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𛲜', '\u{1bca3}'),
                    ('𞠀', '𞣄'),
                    ('𞣇', '\u{1e8d6}'),
                    ('🂿', '🂿'),
                    ('🃠', '🃵'),
                    ('🄋', '🄌'),
                    ('🌡', '🌬'),
                    ('🌶', '🌶'),
                    ('🍽', '🍽'),
                    ('🎔', '🎟'),
                    ('🏅', '🏅'),
                    ('🏋', '🏎'),
                    ('🏔', '🏟'),
                    ('🏱', '🏷'),
                    ('🐿', '🐿'),
                    ('👁', '👁'),
                    ('📸', '📸'),
                    ('📽', '📾'),
                    ('🔾', '🔿'),
                    ('🕄', '🕊'),
                    ('🕨', '🕹'),
                    ('🕻', '🖣'),
                    ('🖥', '🗺'),
                    ('🙁', '🙂'),
                    ('🙐', '🙿'),
                    ('🛆', '🛏'),
                    ('🛠', '🛬'),
                    ('🛰', '🛳'),
                    ('🞀', '🟔'),
                    ('🠀', '🠋'),
                    ('🠐', '🡇'),
                    ('🡐', '🡙'),
                    ('🡠', '🢇'),
                    ('🢐', '🢭'),
                ];

                pub const V8_0: &'static [(char, char)] = &[
                    ('ࢳ', 'ࢴ'),
                    ('\u{8e3}', '\u{8e3}'),
                    ('ૹ', 'ૹ'),
                    ('ౚ', 'ౚ'),
                    ('ൟ', 'ൟ'),
                    ('Ᏽ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('₾', '₾'),
                    ('↊', '↋'),
                    ('⯬', '⯯'),
                    ('鿍', '鿕'),
                    ('\u{a69e}', '\u{a69e}'),
                    ('ꞏ', 'ꞏ'),
                    ('Ʝ', 'ꞷ'),
                    ('꣼', 'ꣽ'),
                    ('ꭠ', 'ꭣ'),
                    ('ꭰ', 'ꮿ'),
                    ('\u{fe2e}', '\u{fe2f}'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐣻', '𐣿'),
                    ('𐦼', '𐦽'),
                    ('𐧀', '𐧏'),
                    ('𐧒', '𐧿'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐳺', '𐳿'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇛', '𑇟'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊩'),
                    ('\u{11300}', '\u{11300}'),
                    ('𑍐', '𑍐'),
                    ('𑗊', '\u{115dd}'),
                    ('𑜀', '𑜙'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑜰', '𑜿'),
                    ('𒎙', '𒎙'),
                    ('𒒀', '𒕃'),
                    ('𔐀', '𔙆'),
                    ('𝇞', '𝇨'),
                    ('𝠀', '𝪋'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('🌭', '🌯'),
                    ('🍾', '🍿'),
                    ('🏏', '🏓'),
                    ('🏸', '🏿'),
                    ('📿', '📿'),
                    ('🕋', '🕏'),
                    ('🙃', '🙄'),
                    ('🛐', '🛐'),
                    ('🤐', '🤘'),
                    ('🦀', '🦄'),
                    ('🧀', '🧀'),
                    ('𫠠', '𬺡'),
                ];

                pub const V9_0: &'static [(char, char)] = &[
                    ('ࢶ', 'ࢽ'),
                    ('\u{8d4}', '\u{8e2}'),
                    ('ಀ', 'ಀ'),
                    ('൏', '൏'),
                    ('ൔ', 'ൖ'),
                    ('൘', '൞'),
                    ('൶', '൸'),
                    ('ᲀ', 'ᲈ'),
                    ('\u{1dfb}', '\u{1dfb}'),
                    ('⏻', '⏾'),
                    ('⹃', '⹄'),
                    ('Ɪ', 'Ɪ'),
                    ('\u{a8c5}', '\u{a8c5}'),
                    ('𐆍', '𐆎'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('𑐀', '𑑙'),
                    ('𑑛', '𑑛'),
                    ('𑑝', '𑑝'),
                    ('𑙠', '𑙬'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '\u{11c36}'),
                    ('\u{11c38}', '𑱅'),
                    ('𑱐', '𑱬'),
                    ('𑱰', '𑲏'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('𖿠', '𖿠'),
                    ('𗀀', '𘟬'),
                    ('𘠀', '𘫲'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('𞤀', '\u{1e94a}'),
                    ('𞥐', '𞥙'),
                    ('𞥞', '𞥟'),
                    ('🆛', '🆬'),
                    ('🈻', '🈻'),
                    ('🕺', '🕺'),
                    ('🖤', '🖤'),
                    ('🛑', '🛒'),
                    ('🛴', '🛶'),
                    ('🤙', '🤞'),
                    ('🤠', '🤧'),
                    ('🤰', '🤰'),
                    ('🤳', '🤾'),
                    ('🥀', '🥋'),
                    ('🥐', '🥞'),
                    ('🦅', '🦑'),
                ];
            }

            pub mod case_folding_simple
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const CASE_FOLDING_SIMPLE: &'static [(char, &'static [char])] = &[
                    ('A', &['a']),
                    ('B', &['b']),
                    ('C', &['c']),
                    ('D', &['d']),
                    ('E', &['e']),
                    ('F', &['f']),
                    ('G', &['g']),
                    ('H', &['h']),
                    ('I', &['i']),
                    ('J', &['j']),
                    ('K', &['k', 'K']),
                    ('L', &['l']),
                    ('M', &['m']),
                    ('N', &['n']),
                    ('O', &['o']),
                    ('P', &['p']),
                    ('Q', &['q']),
                    ('R', &['r']),
                    ('S', &['s', 'ſ']),
                    ('T', &['t']),
                    ('U', &['u']),
                    ('V', &['v']),
                    ('W', &['w']),
                    ('X', &['x']),
                    ('Y', &['y']),
                    ('Z', &['z']),
                    ('a', &['A']),
                    ('b', &['B']),
                    ('c', &['C']),
                    ('d', &['D']),
                    ('e', &['E']),
                    ('f', &['F']),
                    ('g', &['G']),
                    ('h', &['H']),
                    ('i', &['I']),
                    ('j', &['J']),
                    ('k', &['K', 'K']),
                    ('l', &['L']),
                    ('m', &['M']),
                    ('n', &['N']),
                    ('o', &['O']),
                    ('p', &['P']),
                    ('q', &['Q']),
                    ('r', &['R']),
                    ('s', &['S', 'ſ']),
                    ('t', &['T']),
                    ('u', &['U']),
                    ('v', &['V']),
                    ('w', &['W']),
                    ('x', &['X']),
                    ('y', &['Y']),
                    ('z', &['Z']),
                    ('µ', &['Μ', 'μ']),
                    ('À', &['à']),
                    ('Á', &['á']),
                    ('Â', &['â']),
                    ('Ã', &['ã']),
                    ('Ä', &['ä']),
                    ('Å', &['å', 'Å']),
                    ('Æ', &['æ']),
                    ('Ç', &['ç']),
                    ('È', &['è']),
                    ('É', &['é']),
                    ('Ê', &['ê']),
                    ('Ë', &['ë']),
                    ('Ì', &['ì']),
                    ('Í', &['í']),
                    ('Î', &['î']),
                    ('Ï', &['ï']),
                    ('Ð', &['ð']),
                    ('Ñ', &['ñ']),
                    ('Ò', &['ò']),
                    ('Ó', &['ó']),
                    ('Ô', &['ô']),
                    ('Õ', &['õ']),
                    ('Ö', &['ö']),
                    ('Ø', &['ø']),
                    ('Ù', &['ù']),
                    ('Ú', &['ú']),
                    ('Û', &['û']),
                    ('Ü', &['ü']),
                    ('Ý', &['ý']),
                    ('Þ', &['þ']),
                    ('ß', &['ẞ']),
                    ('à', &['À']),
                    ('á', &['Á']),
                    ('â', &['Â']),
                    ('ã', &['Ã']),
                    ('ä', &['Ä']),
                    ('å', &['Å', 'Å']),
                    ('æ', &['Æ']),
                    ('ç', &['Ç']),
                    ('è', &['È']),
                    ('é', &['É']),
                    ('ê', &['Ê']),
                    ('ë', &['Ë']),
                    ('ì', &['Ì']),
                    ('í', &['Í']),
                    ('î', &['Î']),
                    ('ï', &['Ï']),
                    ('ð', &['Ð']),
                    ('ñ', &['Ñ']),
                    ('ò', &['Ò']),
                    ('ó', &['Ó']),
                    ('ô', &['Ô']),
                    ('õ', &['Õ']),
                    ('ö', &['Ö']),
                    ('ø', &['Ø']),
                    ('ù', &['Ù']),
                    ('ú', &['Ú']),
                    ('û', &['Û']),
                    ('ü', &['Ü']),
                    ('ý', &['Ý']),
                    ('þ', &['Þ']),
                    ('ÿ', &['Ÿ']),
                    ('Ā', &['ā']),
                    ('ā', &['Ā']),
                    ('Ă', &['ă']),
                    ('ă', &['Ă']),
                    ('Ą', &['ą']),
                    ('ą', &['Ą']),
                    ('Ć', &['ć']),
                    ('ć', &['Ć']),
                    ('Ĉ', &['ĉ']),
                    ('ĉ', &['Ĉ']),
                    ('Ċ', &['ċ']),
                    ('ċ', &['Ċ']),
                    ('Č', &['č']),
                    ('č', &['Č']),
                    ('Ď', &['ď']),
                    ('ď', &['Ď']),
                    ('Đ', &['đ']),
                    ('đ', &['Đ']),
                    ('Ē', &['ē']),
                    ('ē', &['Ē']),
                    ('Ĕ', &['ĕ']),
                    ('ĕ', &['Ĕ']),
                    ('Ė', &['ė']),
                    ('ė', &['Ė']),
                    ('Ę', &['ę']),
                    ('ę', &['Ę']),
                    ('Ě', &['ě']),
                    ('ě', &['Ě']),
                    ('Ĝ', &['ĝ']),
                    ('ĝ', &['Ĝ']),
                    ('Ğ', &['ğ']),
                    ('ğ', &['Ğ']),
                    ('Ġ', &['ġ']),
                    ('ġ', &['Ġ']),
                    ('Ģ', &['ģ']),
                    ('ģ', &['Ģ']),
                    ('Ĥ', &['ĥ']),
                    ('ĥ', &['Ĥ']),
                    ('Ħ', &['ħ']),
                    ('ħ', &['Ħ']),
                    ('Ĩ', &['ĩ']),
                    ('ĩ', &['Ĩ']),
                    ('Ī', &['ī']),
                    ('ī', &['Ī']),
                    ('Ĭ', &['ĭ']),
                    ('ĭ', &['Ĭ']),
                    ('Į', &['į']),
                    ('į', &['Į']),
                    ('Ĳ', &['ĳ']),
                    ('ĳ', &['Ĳ']),
                    ('Ĵ', &['ĵ']),
                    ('ĵ', &['Ĵ']),
                    ('Ķ', &['ķ']),
                    ('ķ', &['Ķ']),
                    ('Ĺ', &['ĺ']),
                    ('ĺ', &['Ĺ']),
                    ('Ļ', &['ļ']),
                    ('ļ', &['Ļ']),
                    ('Ľ', &['ľ']),
                    ('ľ', &['Ľ']),
                    ('Ŀ', &['ŀ']),
                    ('ŀ', &['Ŀ']),
                    ('Ł', &['ł']),
                    ('ł', &['Ł']),
                    ('Ń', &['ń']),
                    ('ń', &['Ń']),
                    ('Ņ', &['ņ']),
                    ('ņ', &['Ņ']),
                    ('Ň', &['ň']),
                    ('ň', &['Ň']),
                    ('Ŋ', &['ŋ']),
                    ('ŋ', &['Ŋ']),
                    ('Ō', &['ō']),
                    ('ō', &['Ō']),
                    ('Ŏ', &['ŏ']),
                    ('ŏ', &['Ŏ']),
                    ('Ő', &['ő']),
                    ('ő', &['Ő']),
                    ('Œ', &['œ']),
                    ('œ', &['Œ']),
                    ('Ŕ', &['ŕ']),
                    ('ŕ', &['Ŕ']),
                    ('Ŗ', &['ŗ']),
                    ('ŗ', &['Ŗ']),
                    ('Ř', &['ř']),
                    ('ř', &['Ř']),
                    ('Ś', &['ś']),
                    ('ś', &['Ś']),
                    ('Ŝ', &['ŝ']),
                    ('ŝ', &['Ŝ']),
                    ('Ş', &['ş']),
                    ('ş', &['Ş']),
                    ('Š', &['š']),
                    ('š', &['Š']),
                    ('Ţ', &['ţ']),
                    ('ţ', &['Ţ']),
                    ('Ť', &['ť']),
                    ('ť', &['Ť']),
                    ('Ŧ', &['ŧ']),
                    ('ŧ', &['Ŧ']),
                    ('Ũ', &['ũ']),
                    ('ũ', &['Ũ']),
                    ('Ū', &['ū']),
                    ('ū', &['Ū']),
                    ('Ŭ', &['ŭ']),
                    ('ŭ', &['Ŭ']),
                    ('Ů', &['ů']),
                    ('ů', &['Ů']),
                    ('Ű', &['ű']),
                    ('ű', &['Ű']),
                    ('Ų', &['ų']),
                    ('ų', &['Ų']),
                    ('Ŵ', &['ŵ']),
                    ('ŵ', &['Ŵ']),
                    ('Ŷ', &['ŷ']),
                    ('ŷ', &['Ŷ']),
                    ('Ÿ', &['ÿ']),
                    ('Ź', &['ź']),
                    ('ź', &['Ź']),
                    ('Ż', &['ż']),
                    ('ż', &['Ż']),
                    ('Ž', &['ž']),
                    ('ž', &['Ž']),
                    ('ſ', &['S', 's']),
                    ('ƀ', &['Ƀ']),
                    ('Ɓ', &['ɓ']),
                    ('Ƃ', &['ƃ']),
                    ('ƃ', &['Ƃ']),
                    ('Ƅ', &['ƅ']),
                    ('ƅ', &['Ƅ']),
                    ('Ɔ', &['ɔ']),
                    ('Ƈ', &['ƈ']),
                    ('ƈ', &['Ƈ']),
                    ('Ɖ', &['ɖ']),
                    ('Ɗ', &['ɗ']),
                    ('Ƌ', &['ƌ']),
                    ('ƌ', &['Ƌ']),
                    ('Ǝ', &['ǝ']),
                    ('Ə', &['ə']),
                    ('Ɛ', &['ɛ']),
                    ('Ƒ', &['ƒ']),
                    ('ƒ', &['Ƒ']),
                    ('Ɠ', &['ɠ']),
                    ('Ɣ', &['ɣ']),
                    ('ƕ', &['Ƕ']),
                    ('Ɩ', &['ɩ']),
                    ('Ɨ', &['ɨ']),
                    ('Ƙ', &['ƙ']),
                    ('ƙ', &['Ƙ']),
                    ('ƚ', &['Ƚ']),
                    ('ƛ', &['Ƛ']),
                    ('Ɯ', &['ɯ']),
                    ('Ɲ', &['ɲ']),
                    ('ƞ', &['Ƞ']),
                    ('Ɵ', &['ɵ']),
                    ('Ơ', &['ơ']),
                    ('ơ', &['Ơ']),
                    ('Ƣ', &['ƣ']),
                    ('ƣ', &['Ƣ']),
                    ('Ƥ', &['ƥ']),
                    ('ƥ', &['Ƥ']),
                    ('Ʀ', &['ʀ']),
                    ('Ƨ', &['ƨ']),
                    ('ƨ', &['Ƨ']),
                    ('Ʃ', &['ʃ']),
                    ('Ƭ', &['ƭ']),
                    ('ƭ', &['Ƭ']),
                    ('Ʈ', &['ʈ']),
                    ('Ư', &['ư']),
                    ('ư', &['Ư']),
                    ('Ʊ', &['ʊ']),
                    ('Ʋ', &['ʋ']),
                    ('Ƴ', &['ƴ']),
                    ('ƴ', &['Ƴ']),
                    ('Ƶ', &['ƶ']),
                    ('ƶ', &['Ƶ']),
                    ('Ʒ', &['ʒ']),
                    ('Ƹ', &['ƹ']),
                    ('ƹ', &['Ƹ']),
                    ('Ƽ', &['ƽ']),
                    ('ƽ', &['Ƽ']),
                    ('ƿ', &['Ƿ']),
                    ('Ǆ', &['ǅ', 'ǆ']),
                    ('ǅ', &['Ǆ', 'ǆ']),
                    ('ǆ', &['Ǆ', 'ǅ']),
                    ('Ǉ', &['ǈ', 'ǉ']),
                    ('ǈ', &['Ǉ', 'ǉ']),
                    ('ǉ', &['Ǉ', 'ǈ']),
                    ('Ǌ', &['ǋ', 'ǌ']),
                    ('ǋ', &['Ǌ', 'ǌ']),
                    ('ǌ', &['Ǌ', 'ǋ']),
                    ('Ǎ', &['ǎ']),
                    ('ǎ', &['Ǎ']),
                    ('Ǐ', &['ǐ']),
                    ('ǐ', &['Ǐ']),
                    ('Ǒ', &['ǒ']),
                    ('ǒ', &['Ǒ']),
                    ('Ǔ', &['ǔ']),
                    ('ǔ', &['Ǔ']),
                    ('Ǖ', &['ǖ']),
                    ('ǖ', &['Ǖ']),
                    ('Ǘ', &['ǘ']),
                    ('ǘ', &['Ǘ']),
                    ('Ǚ', &['ǚ']),
                    ('ǚ', &['Ǚ']),
                    ('Ǜ', &['ǜ']),
                    ('ǜ', &['Ǜ']),
                    ('ǝ', &['Ǝ']),
                    ('Ǟ', &['ǟ']),
                    ('ǟ', &['Ǟ']),
                    ('Ǡ', &['ǡ']),
                    ('ǡ', &['Ǡ']),
                    ('Ǣ', &['ǣ']),
                    ('ǣ', &['Ǣ']),
                    ('Ǥ', &['ǥ']),
                    ('ǥ', &['Ǥ']),
                    ('Ǧ', &['ǧ']),
                    ('ǧ', &['Ǧ']),
                    ('Ǩ', &['ǩ']),
                    ('ǩ', &['Ǩ']),
                    ('Ǫ', &['ǫ']),
                    ('ǫ', &['Ǫ']),
                    ('Ǭ', &['ǭ']),
                    ('ǭ', &['Ǭ']),
                    ('Ǯ', &['ǯ']),
                    ('ǯ', &['Ǯ']),
                    ('Ǳ', &['ǲ', 'ǳ']),
                    ('ǲ', &['Ǳ', 'ǳ']),
                    ('ǳ', &['Ǳ', 'ǲ']),
                    ('Ǵ', &['ǵ']),
                    ('ǵ', &['Ǵ']),
                    ('Ƕ', &['ƕ']),
                    ('Ƿ', &['ƿ']),
                    ('Ǹ', &['ǹ']),
                    ('ǹ', &['Ǹ']),
                    ('Ǻ', &['ǻ']),
                    ('ǻ', &['Ǻ']),
                    ('Ǽ', &['ǽ']),
                    ('ǽ', &['Ǽ']),
                    ('Ǿ', &['ǿ']),
                    ('ǿ', &['Ǿ']),
                    ('Ȁ', &['ȁ']),
                    ('ȁ', &['Ȁ']),
                    ('Ȃ', &['ȃ']),
                    ('ȃ', &['Ȃ']),
                    ('Ȅ', &['ȅ']),
                    ('ȅ', &['Ȅ']),
                    ('Ȇ', &['ȇ']),
                    ('ȇ', &['Ȇ']),
                    ('Ȉ', &['ȉ']),
                    ('ȉ', &['Ȉ']),
                    ('Ȋ', &['ȋ']),
                    ('ȋ', &['Ȋ']),
                    ('Ȍ', &['ȍ']),
                    ('ȍ', &['Ȍ']),
                    ('Ȏ', &['ȏ']),
                    ('ȏ', &['Ȏ']),
                    ('Ȑ', &['ȑ']),
                    ('ȑ', &['Ȑ']),
                    ('Ȓ', &['ȓ']),
                    ('ȓ', &['Ȓ']),
                    ('Ȕ', &['ȕ']),
                    ('ȕ', &['Ȕ']),
                    ('Ȗ', &['ȗ']),
                    ('ȗ', &['Ȗ']),
                    ('Ș', &['ș']),
                    ('ș', &['Ș']),
                    ('Ț', &['ț']),
                    ('ț', &['Ț']),
                    ('Ȝ', &['ȝ']),
                    ('ȝ', &['Ȝ']),
                    ('Ȟ', &['ȟ']),
                    ('ȟ', &['Ȟ']),
                    ('Ƞ', &['ƞ']),
                    ('Ȣ', &['ȣ']),
                    ('ȣ', &['Ȣ']),
                    ('Ȥ', &['ȥ']),
                    ('ȥ', &['Ȥ']),
                    ('Ȧ', &['ȧ']),
                    ('ȧ', &['Ȧ']),
                    ('Ȩ', &['ȩ']),
                    ('ȩ', &['Ȩ']),
                    ('Ȫ', &['ȫ']),
                    ('ȫ', &['Ȫ']),
                    ('Ȭ', &['ȭ']),
                    ('ȭ', &['Ȭ']),
                    ('Ȯ', &['ȯ']),
                    ('ȯ', &['Ȯ']),
                    ('Ȱ', &['ȱ']),
                    ('ȱ', &['Ȱ']),
                    ('Ȳ', &['ȳ']),
                    ('ȳ', &['Ȳ']),
                    ('Ⱥ', &['ⱥ']),
                    ('Ȼ', &['ȼ']),
                    ('ȼ', &['Ȼ']),
                    ('Ƚ', &['ƚ']),
                    ('Ⱦ', &['ⱦ']),
                    ('ȿ', &['Ȿ']),
                    ('ɀ', &['Ɀ']),
                    ('Ɂ', &['ɂ']),
                    ('ɂ', &['Ɂ']),
                    ('Ƀ', &['ƀ']),
                    ('Ʉ', &['ʉ']),
                    ('Ʌ', &['ʌ']),
                    ('Ɇ', &['ɇ']),
                    ('ɇ', &['Ɇ']),
                    ('Ɉ', &['ɉ']),
                    ('ɉ', &['Ɉ']),
                    ('Ɋ', &['ɋ']),
                    ('ɋ', &['Ɋ']),
                    ('Ɍ', &['ɍ']),
                    ('ɍ', &['Ɍ']),
                    ('Ɏ', &['ɏ']),
                    ('ɏ', &['Ɏ']),
                    ('ɐ', &['Ɐ']),
                    ('ɑ', &['Ɑ']),
                    ('ɒ', &['Ɒ']),
                    ('ɓ', &['Ɓ']),
                    ('ɔ', &['Ɔ']),
                    ('ɖ', &['Ɖ']),
                    ('ɗ', &['Ɗ']),
                    ('ə', &['Ə']),
                    ('ɛ', &['Ɛ']),
                    ('ɜ', &['Ɜ']),
                    ('ɠ', &['Ɠ']),
                    ('ɡ', &['Ɡ']),
                    ('ɣ', &['Ɣ']),
                    ('ɤ', &['Ɤ']),
                    ('ɥ', &['Ɥ']),
                    ('ɦ', &['Ɦ']),
                    ('ɨ', &['Ɨ']),
                    ('ɩ', &['Ɩ']),
                    ('ɪ', &['Ɪ']),
                    ('ɫ', &['Ɫ']),
                    ('ɬ', &['Ɬ']),
                    ('ɯ', &['Ɯ']),
                    ('ɱ', &['Ɱ']),
                    ('ɲ', &['Ɲ']),
                    ('ɵ', &['Ɵ']),
                    ('ɽ', &['Ɽ']),
                    ('ʀ', &['Ʀ']),
                    ('ʂ', &['Ʂ']),
                    ('ʃ', &['Ʃ']),
                    ('ʇ', &['Ʇ']),
                    ('ʈ', &['Ʈ']),
                    ('ʉ', &['Ʉ']),
                    ('ʊ', &['Ʊ']),
                    ('ʋ', &['Ʋ']),
                    ('ʌ', &['Ʌ']),
                    ('ʒ', &['Ʒ']),
                    ('ʝ', &['Ʝ']),
                    ('ʞ', &['Ʞ']),
                    ('\u{345}', &['Ι', 'ι', 'ι']),
                    ('Ͱ', &['ͱ']),
                    ('ͱ', &['Ͱ']),
                    ('Ͳ', &['ͳ']),
                    ('ͳ', &['Ͳ']),
                    ('Ͷ', &['ͷ']),
                    ('ͷ', &['Ͷ']),
                    ('ͻ', &['Ͻ']),
                    ('ͼ', &['Ͼ']),
                    ('ͽ', &['Ͽ']),
                    ('Ϳ', &['ϳ']),
                    ('Ά', &['ά']),
                    ('Έ', &['έ']),
                    ('Ή', &['ή']),
                    ('Ί', &['ί']),
                    ('Ό', &['ό']),
                    ('Ύ', &['ύ']),
                    ('Ώ', &['ώ']),
                    ('ΐ', &['ΐ']),
                    ('Α', &['α']),
                    ('Β', &['β', 'ϐ']),
                    ('Γ', &['γ']),
                    ('Δ', &['δ']),
                    ('Ε', &['ε', 'ϵ']),
                    ('Ζ', &['ζ']),
                    ('Η', &['η']),
                    ('Θ', &['θ', 'ϑ', 'ϴ']),
                    ('Ι', &['\u{345}', 'ι', 'ι']),
                    ('Κ', &['κ', 'ϰ']),
                    ('Λ', &['λ']),
                    ('Μ', &['µ', 'μ']),
                    ('Ν', &['ν']),
                    ('Ξ', &['ξ']),
                    ('Ο', &['ο']),
                    ('Π', &['π', 'ϖ']),
                    ('Ρ', &['ρ', 'ϱ']),
                    ('Σ', &['ς', 'σ']),
                    ('Τ', &['τ']),
                    ('Υ', &['υ']),
                    ('Φ', &['φ', 'ϕ']),
                    ('Χ', &['χ']),
                    ('Ψ', &['ψ']),
                    ('Ω', &['ω', 'Ω']),
                    ('Ϊ', &['ϊ']),
                    ('Ϋ', &['ϋ']),
                    ('ά', &['Ά']),
                    ('έ', &['Έ']),
                    ('ή', &['Ή']),
                    ('ί', &['Ί']),
                    ('ΰ', &['ΰ']),
                    ('α', &['Α']),
                    ('β', &['Β', 'ϐ']),
                    ('γ', &['Γ']),
                    ('δ', &['Δ']),
                    ('ε', &['Ε', 'ϵ']),
                    ('ζ', &['Ζ']),
                    ('η', &['Η']),
                    ('θ', &['Θ', 'ϑ', 'ϴ']),
                    ('ι', &['\u{345}', 'Ι', 'ι']),
                    ('κ', &['Κ', 'ϰ']),
                    ('λ', &['Λ']),
                    ('μ', &['µ', 'Μ']),
                    ('ν', &['Ν']),
                    ('ξ', &['Ξ']),
                    ('ο', &['Ο']),
                    ('π', &['Π', 'ϖ']),
                    ('ρ', &['Ρ', 'ϱ']),
                    ('ς', &['Σ', 'σ']),
                    ('σ', &['Σ', 'ς']),
                    ('τ', &['Τ']),
                    ('υ', &['Υ']),
                    ('φ', &['Φ', 'ϕ']),
                    ('χ', &['Χ']),
                    ('ψ', &['Ψ']),
                    ('ω', &['Ω', 'Ω']),
                    ('ϊ', &['Ϊ']),
                    ('ϋ', &['Ϋ']),
                    ('ό', &['Ό']),
                    ('ύ', &['Ύ']),
                    ('ώ', &['Ώ']),
                    ('Ϗ', &['ϗ']),
                    ('ϐ', &['Β', 'β']),
                    ('ϑ', &['Θ', 'θ', 'ϴ']),
                    ('ϕ', &['Φ', 'φ']),
                    ('ϖ', &['Π', 'π']),
                    ('ϗ', &['Ϗ']),
                    ('Ϙ', &['ϙ']),
                    ('ϙ', &['Ϙ']),
                    ('Ϛ', &['ϛ']),
                    ('ϛ', &['Ϛ']),
                    ('Ϝ', &['ϝ']),
                    ('ϝ', &['Ϝ']),
                    ('Ϟ', &['ϟ']),
                    ('ϟ', &['Ϟ']),
                    ('Ϡ', &['ϡ']),
                    ('ϡ', &['Ϡ']),
                    ('Ϣ', &['ϣ']),
                    ('ϣ', &['Ϣ']),
                    ('Ϥ', &['ϥ']),
                    ('ϥ', &['Ϥ']),
                    ('Ϧ', &['ϧ']),
                    ('ϧ', &['Ϧ']),
                    ('Ϩ', &['ϩ']),
                    ('ϩ', &['Ϩ']),
                    ('Ϫ', &['ϫ']),
                    ('ϫ', &['Ϫ']),
                    ('Ϭ', &['ϭ']),
                    ('ϭ', &['Ϭ']),
                    ('Ϯ', &['ϯ']),
                    ('ϯ', &['Ϯ']),
                    ('ϰ', &['Κ', 'κ']),
                    ('ϱ', &['Ρ', 'ρ']),
                    ('ϲ', &['Ϲ']),
                    ('ϳ', &['Ϳ']),
                    ('ϴ', &['Θ', 'θ', 'ϑ']),
                    ('ϵ', &['Ε', 'ε']),
                    ('Ϸ', &['ϸ']),
                    ('ϸ', &['Ϸ']),
                    ('Ϲ', &['ϲ']),
                    ('Ϻ', &['ϻ']),
                    ('ϻ', &['Ϻ']),
                    ('Ͻ', &['ͻ']),
                    ('Ͼ', &['ͼ']),
                    ('Ͽ', &['ͽ']),
                    ('Ѐ', &['ѐ']),
                    ('Ё', &['ё']),
                    ('Ђ', &['ђ']),
                    ('Ѓ', &['ѓ']),
                    ('Є', &['є']),
                    ('Ѕ', &['ѕ']),
                    ('І', &['і']),
                    ('Ї', &['ї']),
                    ('Ј', &['ј']),
                    ('Љ', &['љ']),
                    ('Њ', &['њ']),
                    ('Ћ', &['ћ']),
                    ('Ќ', &['ќ']),
                    ('Ѝ', &['ѝ']),
                    ('Ў', &['ў']),
                    ('Џ', &['џ']),
                    ('А', &['а']),
                    ('Б', &['б']),
                    ('В', &['в', 'ᲀ']),
                    ('Г', &['г']),
                    ('Д', &['д', 'ᲁ']),
                    ('Е', &['е']),
                    ('Ж', &['ж']),
                    ('З', &['з']),
                    ('И', &['и']),
                    ('Й', &['й']),
                    ('К', &['к']),
                    ('Л', &['л']),
                    ('М', &['м']),
                    ('Н', &['н']),
                    ('О', &['о', 'ᲂ']),
                    ('П', &['п']),
                    ('Р', &['р']),
                    ('С', &['с', 'ᲃ']),
                    ('Т', &['т', 'ᲄ', 'ᲅ']),
                    ('У', &['у']),
                    ('Ф', &['ф']),
                    ('Х', &['х']),
                    ('Ц', &['ц']),
                    ('Ч', &['ч']),
                    ('Ш', &['ш']),
                    ('Щ', &['щ']),
                    ('Ъ', &['ъ', 'ᲆ']),
                    ('Ы', &['ы']),
                    ('Ь', &['ь']),
                    ('Э', &['э']),
                    ('Ю', &['ю']),
                    ('Я', &['я']),
                    ('а', &['А']),
                    ('б', &['Б']),
                    ('в', &['В', 'ᲀ']),
                    ('г', &['Г']),
                    ('д', &['Д', 'ᲁ']),
                    ('е', &['Е']),
                    ('ж', &['Ж']),
                    ('з', &['З']),
                    ('и', &['И']),
                    ('й', &['Й']),
                    ('к', &['К']),
                    ('л', &['Л']),
                    ('м', &['М']),
                    ('н', &['Н']),
                    ('о', &['О', 'ᲂ']),
                    ('п', &['П']),
                    ('р', &['Р']),
                    ('с', &['С', 'ᲃ']),
                    ('т', &['Т', 'ᲄ', 'ᲅ']),
                    ('у', &['У']),
                    ('ф', &['Ф']),
                    ('х', &['Х']),
                    ('ц', &['Ц']),
                    ('ч', &['Ч']),
                    ('ш', &['Ш']),
                    ('щ', &['Щ']),
                    ('ъ', &['Ъ', 'ᲆ']),
                    ('ы', &['Ы']),
                    ('ь', &['Ь']),
                    ('э', &['Э']),
                    ('ю', &['Ю']),
                    ('я', &['Я']),
                    ('ѐ', &['Ѐ']),
                    ('ё', &['Ё']),
                    ('ђ', &['Ђ']),
                    ('ѓ', &['Ѓ']),
                    ('є', &['Є']),
                    ('ѕ', &['Ѕ']),
                    ('і', &['І']),
                    ('ї', &['Ї']),
                    ('ј', &['Ј']),
                    ('љ', &['Љ']),
                    ('њ', &['Њ']),
                    ('ћ', &['Ћ']),
                    ('ќ', &['Ќ']),
                    ('ѝ', &['Ѝ']),
                    ('ў', &['Ў']),
                    ('џ', &['Џ']),
                    ('Ѡ', &['ѡ']),
                    ('ѡ', &['Ѡ']),
                    ('Ѣ', &['ѣ', 'ᲇ']),
                    ('ѣ', &['Ѣ', 'ᲇ']),
                    ('Ѥ', &['ѥ']),
                    ('ѥ', &['Ѥ']),
                    ('Ѧ', &['ѧ']),
                    ('ѧ', &['Ѧ']),
                    ('Ѩ', &['ѩ']),
                    ('ѩ', &['Ѩ']),
                    ('Ѫ', &['ѫ']),
                    ('ѫ', &['Ѫ']),
                    ('Ѭ', &['ѭ']),
                    ('ѭ', &['Ѭ']),
                    ('Ѯ', &['ѯ']),
                    ('ѯ', &['Ѯ']),
                    ('Ѱ', &['ѱ']),
                    ('ѱ', &['Ѱ']),
                    ('Ѳ', &['ѳ']),
                    ('ѳ', &['Ѳ']),
                    ('Ѵ', &['ѵ']),
                    ('ѵ', &['Ѵ']),
                    ('Ѷ', &['ѷ']),
                    ('ѷ', &['Ѷ']),
                    ('Ѹ', &['ѹ']),
                    ('ѹ', &['Ѹ']),
                    ('Ѻ', &['ѻ']),
                    ('ѻ', &['Ѻ']),
                    ('Ѽ', &['ѽ']),
                    ('ѽ', &['Ѽ']),
                    ('Ѿ', &['ѿ']),
                    ('ѿ', &['Ѿ']),
                    ('Ҁ', &['ҁ']),
                    ('ҁ', &['Ҁ']),
                    ('Ҋ', &['ҋ']),
                    ('ҋ', &['Ҋ']),
                    ('Ҍ', &['ҍ']),
                    ('ҍ', &['Ҍ']),
                    ('Ҏ', &['ҏ']),
                    ('ҏ', &['Ҏ']),
                    ('Ґ', &['ґ']),
                    ('ґ', &['Ґ']),
                    ('Ғ', &['ғ']),
                    ('ғ', &['Ғ']),
                    ('Ҕ', &['ҕ']),
                    ('ҕ', &['Ҕ']),
                    ('Җ', &['җ']),
                    ('җ', &['Җ']),
                    ('Ҙ', &['ҙ']),
                    ('ҙ', &['Ҙ']),
                    ('Қ', &['қ']),
                    ('қ', &['Қ']),
                    ('Ҝ', &['ҝ']),
                    ('ҝ', &['Ҝ']),
                    ('Ҟ', &['ҟ']),
                    ('ҟ', &['Ҟ']),
                    ('Ҡ', &['ҡ']),
                    ('ҡ', &['Ҡ']),
                    ('Ң', &['ң']),
                    ('ң', &['Ң']),
                    ('Ҥ', &['ҥ']),
                    ('ҥ', &['Ҥ']),
                    ('Ҧ', &['ҧ']),
                    ('ҧ', &['Ҧ']),
                    ('Ҩ', &['ҩ']),
                    ('ҩ', &['Ҩ']),
                    ('Ҫ', &['ҫ']),
                    ('ҫ', &['Ҫ']),
                    ('Ҭ', &['ҭ']),
                    ('ҭ', &['Ҭ']),
                    ('Ү', &['ү']),
                    ('ү', &['Ү']),
                    ('Ұ', &['ұ']),
                    ('ұ', &['Ұ']),
                    ('Ҳ', &['ҳ']),
                    ('ҳ', &['Ҳ']),
                    ('Ҵ', &['ҵ']),
                    ('ҵ', &['Ҵ']),
                    ('Ҷ', &['ҷ']),
                    ('ҷ', &['Ҷ']),
                    ('Ҹ', &['ҹ']),
                    ('ҹ', &['Ҹ']),
                    ('Һ', &['һ']),
                    ('һ', &['Һ']),
                    ('Ҽ', &['ҽ']),
                    ('ҽ', &['Ҽ']),
                    ('Ҿ', &['ҿ']),
                    ('ҿ', &['Ҿ']),
                    ('Ӏ', &['ӏ']),
                    ('Ӂ', &['ӂ']),
                    ('ӂ', &['Ӂ']),
                    ('Ӄ', &['ӄ']),
                    ('ӄ', &['Ӄ']),
                    ('Ӆ', &['ӆ']),
                    ('ӆ', &['Ӆ']),
                    ('Ӈ', &['ӈ']),
                    ('ӈ', &['Ӈ']),
                    ('Ӊ', &['ӊ']),
                    ('ӊ', &['Ӊ']),
                    ('Ӌ', &['ӌ']),
                    ('ӌ', &['Ӌ']),
                    ('Ӎ', &['ӎ']),
                    ('ӎ', &['Ӎ']),
                    ('ӏ', &['Ӏ']),
                    ('Ӑ', &['ӑ']),
                    ('ӑ', &['Ӑ']),
                    ('Ӓ', &['ӓ']),
                    ('ӓ', &['Ӓ']),
                    ('Ӕ', &['ӕ']),
                    ('ӕ', &['Ӕ']),
                    ('Ӗ', &['ӗ']),
                    ('ӗ', &['Ӗ']),
                    ('Ә', &['ә']),
                    ('ә', &['Ә']),
                    ('Ӛ', &['ӛ']),
                    ('ӛ', &['Ӛ']),
                    ('Ӝ', &['ӝ']),
                    ('ӝ', &['Ӝ']),
                    ('Ӟ', &['ӟ']),
                    ('ӟ', &['Ӟ']),
                    ('Ӡ', &['ӡ']),
                    ('ӡ', &['Ӡ']),
                    ('Ӣ', &['ӣ']),
                    ('ӣ', &['Ӣ']),
                    ('Ӥ', &['ӥ']),
                    ('ӥ', &['Ӥ']),
                    ('Ӧ', &['ӧ']),
                    ('ӧ', &['Ӧ']),
                    ('Ө', &['ө']),
                    ('ө', &['Ө']),
                    ('Ӫ', &['ӫ']),
                    ('ӫ', &['Ӫ']),
                    ('Ӭ', &['ӭ']),
                    ('ӭ', &['Ӭ']),
                    ('Ӯ', &['ӯ']),
                    ('ӯ', &['Ӯ']),
                    ('Ӱ', &['ӱ']),
                    ('ӱ', &['Ӱ']),
                    ('Ӳ', &['ӳ']),
                    ('ӳ', &['Ӳ']),
                    ('Ӵ', &['ӵ']),
                    ('ӵ', &['Ӵ']),
                    ('Ӷ', &['ӷ']),
                    ('ӷ', &['Ӷ']),
                    ('Ӹ', &['ӹ']),
                    ('ӹ', &['Ӹ']),
                    ('Ӻ', &['ӻ']),
                    ('ӻ', &['Ӻ']),
                    ('Ӽ', &['ӽ']),
                    ('ӽ', &['Ӽ']),
                    ('Ӿ', &['ӿ']),
                    ('ӿ', &['Ӿ']),
                    ('Ԁ', &['ԁ']),
                    ('ԁ', &['Ԁ']),
                    ('Ԃ', &['ԃ']),
                    ('ԃ', &['Ԃ']),
                    ('Ԅ', &['ԅ']),
                    ('ԅ', &['Ԅ']),
                    ('Ԇ', &['ԇ']),
                    ('ԇ', &['Ԇ']),
                    ('Ԉ', &['ԉ']),
                    ('ԉ', &['Ԉ']),
                    ('Ԋ', &['ԋ']),
                    ('ԋ', &['Ԋ']),
                    ('Ԍ', &['ԍ']),
                    ('ԍ', &['Ԍ']),
                    ('Ԏ', &['ԏ']),
                    ('ԏ', &['Ԏ']),
                    ('Ԑ', &['ԑ']),
                    ('ԑ', &['Ԑ']),
                    ('Ԓ', &['ԓ']),
                    ('ԓ', &['Ԓ']),
                    ('Ԕ', &['ԕ']),
                    ('ԕ', &['Ԕ']),
                    ('Ԗ', &['ԗ']),
                    ('ԗ', &['Ԗ']),
                    ('Ԙ', &['ԙ']),
                    ('ԙ', &['Ԙ']),
                    ('Ԛ', &['ԛ']),
                    ('ԛ', &['Ԛ']),
                    ('Ԝ', &['ԝ']),
                    ('ԝ', &['Ԝ']),
                    ('Ԟ', &['ԟ']),
                    ('ԟ', &['Ԟ']),
                    ('Ԡ', &['ԡ']),
                    ('ԡ', &['Ԡ']),
                    ('Ԣ', &['ԣ']),
                    ('ԣ', &['Ԣ']),
                    ('Ԥ', &['ԥ']),
                    ('ԥ', &['Ԥ']),
                    ('Ԧ', &['ԧ']),
                    ('ԧ', &['Ԧ']),
                    ('Ԩ', &['ԩ']),
                    ('ԩ', &['Ԩ']),
                    ('Ԫ', &['ԫ']),
                    ('ԫ', &['Ԫ']),
                    ('Ԭ', &['ԭ']),
                    ('ԭ', &['Ԭ']),
                    ('Ԯ', &['ԯ']),
                    ('ԯ', &['Ԯ']),
                    ('Ա', &['ա']),
                    ('Բ', &['բ']),
                    ('Գ', &['գ']),
                    ('Դ', &['դ']),
                    ('Ե', &['ե']),
                    ('Զ', &['զ']),
                    ('Է', &['է']),
                    ('Ը', &['ը']),
                    ('Թ', &['թ']),
                    ('Ժ', &['ժ']),
                    ('Ի', &['ի']),
                    ('Լ', &['լ']),
                    ('Խ', &['խ']),
                    ('Ծ', &['ծ']),
                    ('Կ', &['կ']),
                    ('Հ', &['հ']),
                    ('Ձ', &['ձ']),
                    ('Ղ', &['ղ']),
                    ('Ճ', &['ճ']),
                    ('Մ', &['մ']),
                    ('Յ', &['յ']),
                    ('Ն', &['ն']),
                    ('Շ', &['շ']),
                    ('Ո', &['ո']),
                    ('Չ', &['չ']),
                    ('Պ', &['պ']),
                    ('Ջ', &['ջ']),
                    ('Ռ', &['ռ']),
                    ('Ս', &['ս']),
                    ('Վ', &['վ']),
                    ('Տ', &['տ']),
                    ('Ր', &['ր']),
                    ('Ց', &['ց']),
                    ('Ւ', &['ւ']),
                    ('Փ', &['փ']),
                    ('Ք', &['ք']),
                    ('Օ', &['օ']),
                    ('Ֆ', &['ֆ']),
                    ('ա', &['Ա']),
                    ('բ', &['Բ']),
                    ('գ', &['Գ']),
                    ('դ', &['Դ']),
                    ('ե', &['Ե']),
                    ('զ', &['Զ']),
                    ('է', &['Է']),
                    ('ը', &['Ը']),
                    ('թ', &['Թ']),
                    ('ժ', &['Ժ']),
                    ('ի', &['Ի']),
                    ('լ', &['Լ']),
                    ('խ', &['Խ']),
                    ('ծ', &['Ծ']),
                    ('կ', &['Կ']),
                    ('հ', &['Հ']),
                    ('ձ', &['Ձ']),
                    ('ղ', &['Ղ']),
                    ('ճ', &['Ճ']),
                    ('մ', &['Մ']),
                    ('յ', &['Յ']),
                    ('ն', &['Ն']),
                    ('շ', &['Շ']),
                    ('ո', &['Ո']),
                    ('չ', &['Չ']),
                    ('պ', &['Պ']),
                    ('ջ', &['Ջ']),
                    ('ռ', &['Ռ']),
                    ('ս', &['Ս']),
                    ('վ', &['Վ']),
                    ('տ', &['Տ']),
                    ('ր', &['Ր']),
                    ('ց', &['Ց']),
                    ('ւ', &['Ւ']),
                    ('փ', &['Փ']),
                    ('ք', &['Ք']),
                    ('օ', &['Օ']),
                    ('ֆ', &['Ֆ']),
                    ('Ⴀ', &['ⴀ']),
                    ('Ⴁ', &['ⴁ']),
                    ('Ⴂ', &['ⴂ']),
                    ('Ⴃ', &['ⴃ']),
                    ('Ⴄ', &['ⴄ']),
                    ('Ⴅ', &['ⴅ']),
                    ('Ⴆ', &['ⴆ']),
                    ('Ⴇ', &['ⴇ']),
                    ('Ⴈ', &['ⴈ']),
                    ('Ⴉ', &['ⴉ']),
                    ('Ⴊ', &['ⴊ']),
                    ('Ⴋ', &['ⴋ']),
                    ('Ⴌ', &['ⴌ']),
                    ('Ⴍ', &['ⴍ']),
                    ('Ⴎ', &['ⴎ']),
                    ('Ⴏ', &['ⴏ']),
                    ('Ⴐ', &['ⴐ']),
                    ('Ⴑ', &['ⴑ']),
                    ('Ⴒ', &['ⴒ']),
                    ('Ⴓ', &['ⴓ']),
                    ('Ⴔ', &['ⴔ']),
                    ('Ⴕ', &['ⴕ']),
                    ('Ⴖ', &['ⴖ']),
                    ('Ⴗ', &['ⴗ']),
                    ('Ⴘ', &['ⴘ']),
                    ('Ⴙ', &['ⴙ']),
                    ('Ⴚ', &['ⴚ']),
                    ('Ⴛ', &['ⴛ']),
                    ('Ⴜ', &['ⴜ']),
                    ('Ⴝ', &['ⴝ']),
                    ('Ⴞ', &['ⴞ']),
                    ('Ⴟ', &['ⴟ']),
                    ('Ⴠ', &['ⴠ']),
                    ('Ⴡ', &['ⴡ']),
                    ('Ⴢ', &['ⴢ']),
                    ('Ⴣ', &['ⴣ']),
                    ('Ⴤ', &['ⴤ']),
                    ('Ⴥ', &['ⴥ']),
                    ('Ⴧ', &['ⴧ']),
                    ('Ⴭ', &['ⴭ']),
                    ('ა', &['Ა']),
                    ('ბ', &['Ბ']),
                    ('გ', &['Გ']),
                    ('დ', &['Დ']),
                    ('ე', &['Ე']),
                    ('ვ', &['Ვ']),
                    ('ზ', &['Ზ']),
                    ('თ', &['Თ']),
                    ('ი', &['Ი']),
                    ('კ', &['Კ']),
                    ('ლ', &['Ლ']),
                    ('მ', &['Მ']),
                    ('ნ', &['Ნ']),
                    ('ო', &['Ო']),
                    ('პ', &['Პ']),
                    ('ჟ', &['Ჟ']),
                    ('რ', &['Რ']),
                    ('ს', &['Ს']),
                    ('ტ', &['Ტ']),
                    ('უ', &['Უ']),
                    ('ფ', &['Ფ']),
                    ('ქ', &['Ქ']),
                    ('ღ', &['Ღ']),
                    ('ყ', &['Ყ']),
                    ('შ', &['Შ']),
                    ('ჩ', &['Ჩ']),
                    ('ც', &['Ც']),
                    ('ძ', &['Ძ']),
                    ('წ', &['Წ']),
                    ('ჭ', &['Ჭ']),
                    ('ხ', &['Ხ']),
                    ('ჯ', &['Ჯ']),
                    ('ჰ', &['Ჰ']),
                    ('ჱ', &['Ჱ']),
                    ('ჲ', &['Ჲ']),
                    ('ჳ', &['Ჳ']),
                    ('ჴ', &['Ჴ']),
                    ('ჵ', &['Ჵ']),
                    ('ჶ', &['Ჶ']),
                    ('ჷ', &['Ჷ']),
                    ('ჸ', &['Ჸ']),
                    ('ჹ', &['Ჹ']),
                    ('ჺ', &['Ჺ']),
                    ('ჽ', &['Ჽ']),
                    ('ჾ', &['Ჾ']),
                    ('ჿ', &['Ჿ']),
                    ('Ꭰ', &['ꭰ']),
                    ('Ꭱ', &['ꭱ']),
                    ('Ꭲ', &['ꭲ']),
                    ('Ꭳ', &['ꭳ']),
                    ('Ꭴ', &['ꭴ']),
                    ('Ꭵ', &['ꭵ']),
                    ('Ꭶ', &['ꭶ']),
                    ('Ꭷ', &['ꭷ']),
                    ('Ꭸ', &['ꭸ']),
                    ('Ꭹ', &['ꭹ']),
                    ('Ꭺ', &['ꭺ']),
                    ('Ꭻ', &['ꭻ']),
                    ('Ꭼ', &['ꭼ']),
                    ('Ꭽ', &['ꭽ']),
                    ('Ꭾ', &['ꭾ']),
                    ('Ꭿ', &['ꭿ']),
                    ('Ꮀ', &['ꮀ']),
                    ('Ꮁ', &['ꮁ']),
                    ('Ꮂ', &['ꮂ']),
                    ('Ꮃ', &['ꮃ']),
                    ('Ꮄ', &['ꮄ']),
                    ('Ꮅ', &['ꮅ']),
                    ('Ꮆ', &['ꮆ']),
                    ('Ꮇ', &['ꮇ']),
                    ('Ꮈ', &['ꮈ']),
                    ('Ꮉ', &['ꮉ']),
                    ('Ꮊ', &['ꮊ']),
                    ('Ꮋ', &['ꮋ']),
                    ('Ꮌ', &['ꮌ']),
                    ('Ꮍ', &['ꮍ']),
                    ('Ꮎ', &['ꮎ']),
                    ('Ꮏ', &['ꮏ']),
                    ('Ꮐ', &['ꮐ']),
                    ('Ꮑ', &['ꮑ']),
                    ('Ꮒ', &['ꮒ']),
                    ('Ꮓ', &['ꮓ']),
                    ('Ꮔ', &['ꮔ']),
                    ('Ꮕ', &['ꮕ']),
                    ('Ꮖ', &['ꮖ']),
                    ('Ꮗ', &['ꮗ']),
                    ('Ꮘ', &['ꮘ']),
                    ('Ꮙ', &['ꮙ']),
                    ('Ꮚ', &['ꮚ']),
                    ('Ꮛ', &['ꮛ']),
                    ('Ꮜ', &['ꮜ']),
                    ('Ꮝ', &['ꮝ']),
                    ('Ꮞ', &['ꮞ']),
                    ('Ꮟ', &['ꮟ']),
                    ('Ꮠ', &['ꮠ']),
                    ('Ꮡ', &['ꮡ']),
                    ('Ꮢ', &['ꮢ']),
                    ('Ꮣ', &['ꮣ']),
                    ('Ꮤ', &['ꮤ']),
                    ('Ꮥ', &['ꮥ']),
                    ('Ꮦ', &['ꮦ']),
                    ('Ꮧ', &['ꮧ']),
                    ('Ꮨ', &['ꮨ']),
                    ('Ꮩ', &['ꮩ']),
                    ('Ꮪ', &['ꮪ']),
                    ('Ꮫ', &['ꮫ']),
                    ('Ꮬ', &['ꮬ']),
                    ('Ꮭ', &['ꮭ']),
                    ('Ꮮ', &['ꮮ']),
                    ('Ꮯ', &['ꮯ']),
                    ('Ꮰ', &['ꮰ']),
                    ('Ꮱ', &['ꮱ']),
                    ('Ꮲ', &['ꮲ']),
                    ('Ꮳ', &['ꮳ']),
                    ('Ꮴ', &['ꮴ']),
                    ('Ꮵ', &['ꮵ']),
                    ('Ꮶ', &['ꮶ']),
                    ('Ꮷ', &['ꮷ']),
                    ('Ꮸ', &['ꮸ']),
                    ('Ꮹ', &['ꮹ']),
                    ('Ꮺ', &['ꮺ']),
                    ('Ꮻ', &['ꮻ']),
                    ('Ꮼ', &['ꮼ']),
                    ('Ꮽ', &['ꮽ']),
                    ('Ꮾ', &['ꮾ']),
                    ('Ꮿ', &['ꮿ']),
                    ('Ᏸ', &['ᏸ']),
                    ('Ᏹ', &['ᏹ']),
                    ('Ᏺ', &['ᏺ']),
                    ('Ᏻ', &['ᏻ']),
                    ('Ᏼ', &['ᏼ']),
                    ('Ᏽ', &['ᏽ']),
                    ('ᏸ', &['Ᏸ']),
                    ('ᏹ', &['Ᏹ']),
                    ('ᏺ', &['Ᏺ']),
                    ('ᏻ', &['Ᏻ']),
                    ('ᏼ', &['Ᏼ']),
                    ('ᏽ', &['Ᏽ']),
                    ('ᲀ', &['В', 'в']),
                    ('ᲁ', &['Д', 'д']),
                    ('ᲂ', &['О', 'о']),
                    ('ᲃ', &['С', 'с']),
                    ('ᲄ', &['Т', 'т', 'ᲅ']),
                    ('ᲅ', &['Т', 'т', 'ᲄ']),
                    ('ᲆ', &['Ъ', 'ъ']),
                    ('ᲇ', &['Ѣ', 'ѣ']),
                    ('ᲈ', &['Ꙋ', 'ꙋ']),
                    ('Ᲊ', &['ᲊ']),
                    ('ᲊ', &['Ᲊ']),
                    ('Ა', &['ა']),
                    ('Ბ', &['ბ']),
                    ('Გ', &['გ']),
                    ('Დ', &['დ']),
                    ('Ე', &['ე']),
                    ('Ვ', &['ვ']),
                    ('Ზ', &['ზ']),
                    ('Თ', &['თ']),
                    ('Ი', &['ი']),
                    ('Კ', &['კ']),
                    ('Ლ', &['ლ']),
                    ('Მ', &['მ']),
                    ('Ნ', &['ნ']),
                    ('Ო', &['ო']),
                    ('Პ', &['პ']),
                    ('Ჟ', &['ჟ']),
                    ('Რ', &['რ']),
                    ('Ს', &['ს']),
                    ('Ტ', &['ტ']),
                    ('Უ', &['უ']),
                    ('Ფ', &['ფ']),
                    ('Ქ', &['ქ']),
                    ('Ღ', &['ღ']),
                    ('Ყ', &['ყ']),
                    ('Შ', &['შ']),
                    ('Ჩ', &['ჩ']),
                    ('Ც', &['ც']),
                    ('Ძ', &['ძ']),
                    ('Წ', &['წ']),
                    ('Ჭ', &['ჭ']),
                    ('Ხ', &['ხ']),
                    ('Ჯ', &['ჯ']),
                    ('Ჰ', &['ჰ']),
                    ('Ჱ', &['ჱ']),
                    ('Ჲ', &['ჲ']),
                    ('Ჳ', &['ჳ']),
                    ('Ჴ', &['ჴ']),
                    ('Ჵ', &['ჵ']),
                    ('Ჶ', &['ჶ']),
                    ('Ჷ', &['ჷ']),
                    ('Ჸ', &['ჸ']),
                    ('Ჹ', &['ჹ']),
                    ('Ჺ', &['ჺ']),
                    ('Ჽ', &['ჽ']),
                    ('Ჾ', &['ჾ']),
                    ('Ჿ', &['ჿ']),
                    ('ᵹ', &['Ᵹ']),
                    ('ᵽ', &['Ᵽ']),
                    ('ᶎ', &['Ᶎ']),
                    ('Ḁ', &['ḁ']),
                    ('ḁ', &['Ḁ']),
                    ('Ḃ', &['ḃ']),
                    ('ḃ', &['Ḃ']),
                    ('Ḅ', &['ḅ']),
                    ('ḅ', &['Ḅ']),
                    ('Ḇ', &['ḇ']),
                    ('ḇ', &['Ḇ']),
                    ('Ḉ', &['ḉ']),
                    ('ḉ', &['Ḉ']),
                    ('Ḋ', &['ḋ']),
                    ('ḋ', &['Ḋ']),
                    ('Ḍ', &['ḍ']),
                    ('ḍ', &['Ḍ']),
                    ('Ḏ', &['ḏ']),
                    ('ḏ', &['Ḏ']),
                    ('Ḑ', &['ḑ']),
                    ('ḑ', &['Ḑ']),
                    ('Ḓ', &['ḓ']),
                    ('ḓ', &['Ḓ']),
                    ('Ḕ', &['ḕ']),
                    ('ḕ', &['Ḕ']),
                    ('Ḗ', &['ḗ']),
                    ('ḗ', &['Ḗ']),
                    ('Ḙ', &['ḙ']),
                    ('ḙ', &['Ḙ']),
                    ('Ḛ', &['ḛ']),
                    ('ḛ', &['Ḛ']),
                    ('Ḝ', &['ḝ']),
                    ('ḝ', &['Ḝ']),
                    ('Ḟ', &['ḟ']),
                    ('ḟ', &['Ḟ']),
                    ('Ḡ', &['ḡ']),
                    ('ḡ', &['Ḡ']),
                    ('Ḣ', &['ḣ']),
                    ('ḣ', &['Ḣ']),
                    ('Ḥ', &['ḥ']),
                    ('ḥ', &['Ḥ']),
                    ('Ḧ', &['ḧ']),
                    ('ḧ', &['Ḧ']),
                    ('Ḩ', &['ḩ']),
                    ('ḩ', &['Ḩ']),
                    ('Ḫ', &['ḫ']),
                    ('ḫ', &['Ḫ']),
                    ('Ḭ', &['ḭ']),
                    ('ḭ', &['Ḭ']),
                    ('Ḯ', &['ḯ']),
                    ('ḯ', &['Ḯ']),
                    ('Ḱ', &['ḱ']),
                    ('ḱ', &['Ḱ']),
                    ('Ḳ', &['ḳ']),
                    ('ḳ', &['Ḳ']),
                    ('Ḵ', &['ḵ']),
                    ('ḵ', &['Ḵ']),
                    ('Ḷ', &['ḷ']),
                    ('ḷ', &['Ḷ']),
                    ('Ḹ', &['ḹ']),
                    ('ḹ', &['Ḹ']),
                    ('Ḻ', &['ḻ']),
                    ('ḻ', &['Ḻ']),
                    ('Ḽ', &['ḽ']),
                    ('ḽ', &['Ḽ']),
                    ('Ḿ', &['ḿ']),
                    ('ḿ', &['Ḿ']),
                    ('Ṁ', &['ṁ']),
                    ('ṁ', &['Ṁ']),
                    ('Ṃ', &['ṃ']),
                    ('ṃ', &['Ṃ']),
                    ('Ṅ', &['ṅ']),
                    ('ṅ', &['Ṅ']),
                    ('Ṇ', &['ṇ']),
                    ('ṇ', &['Ṇ']),
                    ('Ṉ', &['ṉ']),
                    ('ṉ', &['Ṉ']),
                    ('Ṋ', &['ṋ']),
                    ('ṋ', &['Ṋ']),
                    ('Ṍ', &['ṍ']),
                    ('ṍ', &['Ṍ']),
                    ('Ṏ', &['ṏ']),
                    ('ṏ', &['Ṏ']),
                    ('Ṑ', &['ṑ']),
                    ('ṑ', &['Ṑ']),
                    ('Ṓ', &['ṓ']),
                    ('ṓ', &['Ṓ']),
                    ('Ṕ', &['ṕ']),
                    ('ṕ', &['Ṕ']),
                    ('Ṗ', &['ṗ']),
                    ('ṗ', &['Ṗ']),
                    ('Ṙ', &['ṙ']),
                    ('ṙ', &['Ṙ']),
                    ('Ṛ', &['ṛ']),
                    ('ṛ', &['Ṛ']),
                    ('Ṝ', &['ṝ']),
                    ('ṝ', &['Ṝ']),
                    ('Ṟ', &['ṟ']),
                    ('ṟ', &['Ṟ']),
                    ('Ṡ', &['ṡ', 'ẛ']),
                    ('ṡ', &['Ṡ', 'ẛ']),
                    ('Ṣ', &['ṣ']),
                    ('ṣ', &['Ṣ']),
                    ('Ṥ', &['ṥ']),
                    ('ṥ', &['Ṥ']),
                    ('Ṧ', &['ṧ']),
                    ('ṧ', &['Ṧ']),
                    ('Ṩ', &['ṩ']),
                    ('ṩ', &['Ṩ']),
                    ('Ṫ', &['ṫ']),
                    ('ṫ', &['Ṫ']),
                    ('Ṭ', &['ṭ']),
                    ('ṭ', &['Ṭ']),
                    ('Ṯ', &['ṯ']),
                    ('ṯ', &['Ṯ']),
                    ('Ṱ', &['ṱ']),
                    ('ṱ', &['Ṱ']),
                    ('Ṳ', &['ṳ']),
                    ('ṳ', &['Ṳ']),
                    ('Ṵ', &['ṵ']),
                    ('ṵ', &['Ṵ']),
                    ('Ṷ', &['ṷ']),
                    ('ṷ', &['Ṷ']),
                    ('Ṹ', &['ṹ']),
                    ('ṹ', &['Ṹ']),
                    ('Ṻ', &['ṻ']),
                    ('ṻ', &['Ṻ']),
                    ('Ṽ', &['ṽ']),
                    ('ṽ', &['Ṽ']),
                    ('Ṿ', &['ṿ']),
                    ('ṿ', &['Ṿ']),
                    ('Ẁ', &['ẁ']),
                    ('ẁ', &['Ẁ']),
                    ('Ẃ', &['ẃ']),
                    ('ẃ', &['Ẃ']),
                    ('Ẅ', &['ẅ']),
                    ('ẅ', &['Ẅ']),
                    ('Ẇ', &['ẇ']),
                    ('ẇ', &['Ẇ']),
                    ('Ẉ', &['ẉ']),
                    ('ẉ', &['Ẉ']),
                    ('Ẋ', &['ẋ']),
                    ('ẋ', &['Ẋ']),
                    ('Ẍ', &['ẍ']),
                    ('ẍ', &['Ẍ']),
                    ('Ẏ', &['ẏ']),
                    ('ẏ', &['Ẏ']),
                    ('Ẑ', &['ẑ']),
                    ('ẑ', &['Ẑ']),
                    ('Ẓ', &['ẓ']),
                    ('ẓ', &['Ẓ']),
                    ('Ẕ', &['ẕ']),
                    ('ẕ', &['Ẕ']),
                    ('ẛ', &['Ṡ', 'ṡ']),
                    ('ẞ', &['ß']),
                    ('Ạ', &['ạ']),
                    ('ạ', &['Ạ']),
                    ('Ả', &['ả']),
                    ('ả', &['Ả']),
                    ('Ấ', &['ấ']),
                    ('ấ', &['Ấ']),
                    ('Ầ', &['ầ']),
                    ('ầ', &['Ầ']),
                    ('Ẩ', &['ẩ']),
                    ('ẩ', &['Ẩ']),
                    ('Ẫ', &['ẫ']),
                    ('ẫ', &['Ẫ']),
                    ('Ậ', &['ậ']),
                    ('ậ', &['Ậ']),
                    ('Ắ', &['ắ']),
                    ('ắ', &['Ắ']),
                    ('Ằ', &['ằ']),
                    ('ằ', &['Ằ']),
                    ('Ẳ', &['ẳ']),
                    ('ẳ', &['Ẳ']),
                    ('Ẵ', &['ẵ']),
                    ('ẵ', &['Ẵ']),
                    ('Ặ', &['ặ']),
                    ('ặ', &['Ặ']),
                    ('Ẹ', &['ẹ']),
                    ('ẹ', &['Ẹ']),
                    ('Ẻ', &['ẻ']),
                    ('ẻ', &['Ẻ']),
                    ('Ẽ', &['ẽ']),
                    ('ẽ', &['Ẽ']),
                    ('Ế', &['ế']),
                    ('ế', &['Ế']),
                    ('Ề', &['ề']),
                    ('ề', &['Ề']),
                    ('Ể', &['ể']),
                    ('ể', &['Ể']),
                    ('Ễ', &['ễ']),
                    ('ễ', &['Ễ']),
                    ('Ệ', &['ệ']),
                    ('ệ', &['Ệ']),
                    ('Ỉ', &['ỉ']),
                    ('ỉ', &['Ỉ']),
                    ('Ị', &['ị']),
                    ('ị', &['Ị']),
                    ('Ọ', &['ọ']),
                    ('ọ', &['Ọ']),
                    ('Ỏ', &['ỏ']),
                    ('ỏ', &['Ỏ']),
                    ('Ố', &['ố']),
                    ('ố', &['Ố']),
                    ('Ồ', &['ồ']),
                    ('ồ', &['Ồ']),
                    ('Ổ', &['ổ']),
                    ('ổ', &['Ổ']),
                    ('Ỗ', &['ỗ']),
                    ('ỗ', &['Ỗ']),
                    ('Ộ', &['ộ']),
                    ('ộ', &['Ộ']),
                    ('Ớ', &['ớ']),
                    ('ớ', &['Ớ']),
                    ('Ờ', &['ờ']),
                    ('ờ', &['Ờ']),
                    ('Ở', &['ở']),
                    ('ở', &['Ở']),
                    ('Ỡ', &['ỡ']),
                    ('ỡ', &['Ỡ']),
                    ('Ợ', &['ợ']),
                    ('ợ', &['Ợ']),
                    ('Ụ', &['ụ']),
                    ('ụ', &['Ụ']),
                    ('Ủ', &['ủ']),
                    ('ủ', &['Ủ']),
                    ('Ứ', &['ứ']),
                    ('ứ', &['Ứ']),
                    ('Ừ', &['ừ']),
                    ('ừ', &['Ừ']),
                    ('Ử', &['ử']),
                    ('ử', &['Ử']),
                    ('Ữ', &['ữ']),
                    ('ữ', &['Ữ']),
                    ('Ự', &['ự']),
                    ('ự', &['Ự']),
                    ('Ỳ', &['ỳ']),
                    ('ỳ', &['Ỳ']),
                    ('Ỵ', &['ỵ']),
                    ('ỵ', &['Ỵ']),
                    ('Ỷ', &['ỷ']),
                    ('ỷ', &['Ỷ']),
                    ('Ỹ', &['ỹ']),
                    ('ỹ', &['Ỹ']),
                    ('Ỻ', &['ỻ']),
                    ('ỻ', &['Ỻ']),
                    ('Ỽ', &['ỽ']),
                    ('ỽ', &['Ỽ']),
                    ('Ỿ', &['ỿ']),
                    ('ỿ', &['Ỿ']),
                    ('ἀ', &['Ἀ']),
                    ('ἁ', &['Ἁ']),
                    ('ἂ', &['Ἂ']),
                    ('ἃ', &['Ἃ']),
                    ('ἄ', &['Ἄ']),
                    ('ἅ', &['Ἅ']),
                    ('ἆ', &['Ἆ']),
                    ('ἇ', &['Ἇ']),
                    ('Ἀ', &['ἀ']),
                    ('Ἁ', &['ἁ']),
                    ('Ἂ', &['ἂ']),
                    ('Ἃ', &['ἃ']),
                    ('Ἄ', &['ἄ']),
                    ('Ἅ', &['ἅ']),
                    ('Ἆ', &['ἆ']),
                    ('Ἇ', &['ἇ']),
                    ('ἐ', &['Ἐ']),
                    ('ἑ', &['Ἑ']),
                    ('ἒ', &['Ἒ']),
                    ('ἓ', &['Ἓ']),
                    ('ἔ', &['Ἔ']),
                    ('ἕ', &['Ἕ']),
                    ('Ἐ', &['ἐ']),
                    ('Ἑ', &['ἑ']),
                    ('Ἒ', &['ἒ']),
                    ('Ἓ', &['ἓ']),
                    ('Ἔ', &['ἔ']),
                    ('Ἕ', &['ἕ']),
                    ('ἠ', &['Ἠ']),
                    ('ἡ', &['Ἡ']),
                    ('ἢ', &['Ἢ']),
                    ('ἣ', &['Ἣ']),
                    ('ἤ', &['Ἤ']),
                    ('ἥ', &['Ἥ']),
                    ('ἦ', &['Ἦ']),
                    ('ἧ', &['Ἧ']),
                    ('Ἠ', &['ἠ']),
                    ('Ἡ', &['ἡ']),
                    ('Ἢ', &['ἢ']),
                    ('Ἣ', &['ἣ']),
                    ('Ἤ', &['ἤ']),
                    ('Ἥ', &['ἥ']),
                    ('Ἦ', &['ἦ']),
                    ('Ἧ', &['ἧ']),
                    ('ἰ', &['Ἰ']),
                    ('ἱ', &['Ἱ']),
                    ('ἲ', &['Ἲ']),
                    ('ἳ', &['Ἳ']),
                    ('ἴ', &['Ἴ']),
                    ('ἵ', &['Ἵ']),
                    ('ἶ', &['Ἶ']),
                    ('ἷ', &['Ἷ']),
                    ('Ἰ', &['ἰ']),
                    ('Ἱ', &['ἱ']),
                    ('Ἲ', &['ἲ']),
                    ('Ἳ', &['ἳ']),
                    ('Ἴ', &['ἴ']),
                    ('Ἵ', &['ἵ']),
                    ('Ἶ', &['ἶ']),
                    ('Ἷ', &['ἷ']),
                    ('ὀ', &['Ὀ']),
                    ('ὁ', &['Ὁ']),
                    ('ὂ', &['Ὂ']),
                    ('ὃ', &['Ὃ']),
                    ('ὄ', &['Ὄ']),
                    ('ὅ', &['Ὅ']),
                    ('Ὀ', &['ὀ']),
                    ('Ὁ', &['ὁ']),
                    ('Ὂ', &['ὂ']),
                    ('Ὃ', &['ὃ']),
                    ('Ὄ', &['ὄ']),
                    ('Ὅ', &['ὅ']),
                    ('ὑ', &['Ὑ']),
                    ('ὓ', &['Ὓ']),
                    ('ὕ', &['Ὕ']),
                    ('ὗ', &['Ὗ']),
                    ('Ὑ', &['ὑ']),
                    ('Ὓ', &['ὓ']),
                    ('Ὕ', &['ὕ']),
                    ('Ὗ', &['ὗ']),
                    ('ὠ', &['Ὠ']),
                    ('ὡ', &['Ὡ']),
                    ('ὢ', &['Ὢ']),
                    ('ὣ', &['Ὣ']),
                    ('ὤ', &['Ὤ']),
                    ('ὥ', &['Ὥ']),
                    ('ὦ', &['Ὦ']),
                    ('ὧ', &['Ὧ']),
                    ('Ὠ', &['ὠ']),
                    ('Ὡ', &['ὡ']),
                    ('Ὢ', &['ὢ']),
                    ('Ὣ', &['ὣ']),
                    ('Ὤ', &['ὤ']),
                    ('Ὥ', &['ὥ']),
                    ('Ὦ', &['ὦ']),
                    ('Ὧ', &['ὧ']),
                    ('ὰ', &['Ὰ']),
                    ('ά', &['Ά']),
                    ('ὲ', &['Ὲ']),
                    ('έ', &['Έ']),
                    ('ὴ', &['Ὴ']),
                    ('ή', &['Ή']),
                    ('ὶ', &['Ὶ']),
                    ('ί', &['Ί']),
                    ('ὸ', &['Ὸ']),
                    ('ό', &['Ό']),
                    ('ὺ', &['Ὺ']),
                    ('ύ', &['Ύ']),
                    ('ὼ', &['Ὼ']),
                    ('ώ', &['Ώ']),
                    ('ᾀ', &['ᾈ']),
                    ('ᾁ', &['ᾉ']),
                    ('ᾂ', &['ᾊ']),
                    ('ᾃ', &['ᾋ']),
                    ('ᾄ', &['ᾌ']),
                    ('ᾅ', &['ᾍ']),
                    ('ᾆ', &['ᾎ']),
                    ('ᾇ', &['ᾏ']),
                    ('ᾈ', &['ᾀ']),
                    ('ᾉ', &['ᾁ']),
                    ('ᾊ', &['ᾂ']),
                    ('ᾋ', &['ᾃ']),
                    ('ᾌ', &['ᾄ']),
                    ('ᾍ', &['ᾅ']),
                    ('ᾎ', &['ᾆ']),
                    ('ᾏ', &['ᾇ']),
                    ('ᾐ', &['ᾘ']),
                    ('ᾑ', &['ᾙ']),
                    ('ᾒ', &['ᾚ']),
                    ('ᾓ', &['ᾛ']),
                    ('ᾔ', &['ᾜ']),
                    ('ᾕ', &['ᾝ']),
                    ('ᾖ', &['ᾞ']),
                    ('ᾗ', &['ᾟ']),
                    ('ᾘ', &['ᾐ']),
                    ('ᾙ', &['ᾑ']),
                    ('ᾚ', &['ᾒ']),
                    ('ᾛ', &['ᾓ']),
                    ('ᾜ', &['ᾔ']),
                    ('ᾝ', &['ᾕ']),
                    ('ᾞ', &['ᾖ']),
                    ('ᾟ', &['ᾗ']),
                    ('ᾠ', &['ᾨ']),
                    ('ᾡ', &['ᾩ']),
                    ('ᾢ', &['ᾪ']),
                    ('ᾣ', &['ᾫ']),
                    ('ᾤ', &['ᾬ']),
                    ('ᾥ', &['ᾭ']),
                    ('ᾦ', &['ᾮ']),
                    ('ᾧ', &['ᾯ']),
                    ('ᾨ', &['ᾠ']),
                    ('ᾩ', &['ᾡ']),
                    ('ᾪ', &['ᾢ']),
                    ('ᾫ', &['ᾣ']),
                    ('ᾬ', &['ᾤ']),
                    ('ᾭ', &['ᾥ']),
                    ('ᾮ', &['ᾦ']),
                    ('ᾯ', &['ᾧ']),
                    ('ᾰ', &['Ᾰ']),
                    ('ᾱ', &['Ᾱ']),
                    ('ᾳ', &['ᾼ']),
                    ('Ᾰ', &['ᾰ']),
                    ('Ᾱ', &['ᾱ']),
                    ('Ὰ', &['ὰ']),
                    ('Ά', &['ά']),
                    ('ᾼ', &['ᾳ']),
                    ('ι', &['\u{345}', 'Ι', 'ι']),
                    ('ῃ', &['ῌ']),
                    ('Ὲ', &['ὲ']),
                    ('Έ', &['έ']),
                    ('Ὴ', &['ὴ']),
                    ('Ή', &['ή']),
                    ('ῌ', &['ῃ']),
                    ('ῐ', &['Ῐ']),
                    ('ῑ', &['Ῑ']),
                    ('ΐ', &['ΐ']),
                    ('Ῐ', &['ῐ']),
                    ('Ῑ', &['ῑ']),
                    ('Ὶ', &['ὶ']),
                    ('Ί', &['ί']),
                    ('ῠ', &['Ῠ']),
                    ('ῡ', &['Ῡ']),
                    ('ΰ', &['ΰ']),
                    ('ῥ', &['Ῥ']),
                    ('Ῠ', &['ῠ']),
                    ('Ῡ', &['ῡ']),
                    ('Ὺ', &['ὺ']),
                    ('Ύ', &['ύ']),
                    ('Ῥ', &['ῥ']),
                    ('ῳ', &['ῼ']),
                    ('Ὸ', &['ὸ']),
                    ('Ό', &['ό']),
                    ('Ὼ', &['ὼ']),
                    ('Ώ', &['ώ']),
                    ('ῼ', &['ῳ']),
                    ('Ω', &['Ω', 'ω']),
                    ('K', &['K', 'k']),
                    ('Å', &['Å', 'å']),
                    ('Ⅎ', &['ⅎ']),
                    ('ⅎ', &['Ⅎ']),
                    ('Ⅰ', &['ⅰ']),
                    ('Ⅱ', &['ⅱ']),
                    ('Ⅲ', &['ⅲ']),
                    ('Ⅳ', &['ⅳ']),
                    ('Ⅴ', &['ⅴ']),
                    ('Ⅵ', &['ⅵ']),
                    ('Ⅶ', &['ⅶ']),
                    ('Ⅷ', &['ⅷ']),
                    ('Ⅸ', &['ⅸ']),
                    ('Ⅹ', &['ⅹ']),
                    ('Ⅺ', &['ⅺ']),
                    ('Ⅻ', &['ⅻ']),
                    ('Ⅼ', &['ⅼ']),
                    ('Ⅽ', &['ⅽ']),
                    ('Ⅾ', &['ⅾ']),
                    ('Ⅿ', &['ⅿ']),
                    ('ⅰ', &['Ⅰ']),
                    ('ⅱ', &['Ⅱ']),
                    ('ⅲ', &['Ⅲ']),
                    ('ⅳ', &['Ⅳ']),
                    ('ⅴ', &['Ⅴ']),
                    ('ⅵ', &['Ⅵ']),
                    ('ⅶ', &['Ⅶ']),
                    ('ⅷ', &['Ⅷ']),
                    ('ⅸ', &['Ⅸ']),
                    ('ⅹ', &['Ⅹ']),
                    ('ⅺ', &['Ⅺ']),
                    ('ⅻ', &['Ⅻ']),
                    ('ⅼ', &['Ⅼ']),
                    ('ⅽ', &['Ⅽ']),
                    ('ⅾ', &['Ⅾ']),
                    ('ⅿ', &['Ⅿ']),
                    ('Ↄ', &['ↄ']),
                    ('ↄ', &['Ↄ']),
                    ('Ⓐ', &['ⓐ']),
                    ('Ⓑ', &['ⓑ']),
                    ('Ⓒ', &['ⓒ']),
                    ('Ⓓ', &['ⓓ']),
                    ('Ⓔ', &['ⓔ']),
                    ('Ⓕ', &['ⓕ']),
                    ('Ⓖ', &['ⓖ']),
                    ('Ⓗ', &['ⓗ']),
                    ('Ⓘ', &['ⓘ']),
                    ('Ⓙ', &['ⓙ']),
                    ('Ⓚ', &['ⓚ']),
                    ('Ⓛ', &['ⓛ']),
                    ('Ⓜ', &['ⓜ']),
                    ('Ⓝ', &['ⓝ']),
                    ('Ⓞ', &['ⓞ']),
                    ('Ⓟ', &['ⓟ']),
                    ('Ⓠ', &['ⓠ']),
                    ('Ⓡ', &['ⓡ']),
                    ('Ⓢ', &['ⓢ']),
                    ('Ⓣ', &['ⓣ']),
                    ('Ⓤ', &['ⓤ']),
                    ('Ⓥ', &['ⓥ']),
                    ('Ⓦ', &['ⓦ']),
                    ('Ⓧ', &['ⓧ']),
                    ('Ⓨ', &['ⓨ']),
                    ('Ⓩ', &['ⓩ']),
                    ('ⓐ', &['Ⓐ']),
                    ('ⓑ', &['Ⓑ']),
                    ('ⓒ', &['Ⓒ']),
                    ('ⓓ', &['Ⓓ']),
                    ('ⓔ', &['Ⓔ']),
                    ('ⓕ', &['Ⓕ']),
                    ('ⓖ', &['Ⓖ']),
                    ('ⓗ', &['Ⓗ']),
                    ('ⓘ', &['Ⓘ']),
                    ('ⓙ', &['Ⓙ']),
                    ('ⓚ', &['Ⓚ']),
                    ('ⓛ', &['Ⓛ']),
                    ('ⓜ', &['Ⓜ']),
                    ('ⓝ', &['Ⓝ']),
                    ('ⓞ', &['Ⓞ']),
                    ('ⓟ', &['Ⓟ']),
                    ('ⓠ', &['Ⓠ']),
                    ('ⓡ', &['Ⓡ']),
                    ('ⓢ', &['Ⓢ']),
                    ('ⓣ', &['Ⓣ']),
                    ('ⓤ', &['Ⓤ']),
                    ('ⓥ', &['Ⓥ']),
                    ('ⓦ', &['Ⓦ']),
                    ('ⓧ', &['Ⓧ']),
                    ('ⓨ', &['Ⓨ']),
                    ('ⓩ', &['Ⓩ']),
                    ('Ⰰ', &['ⰰ']),
                    ('Ⰱ', &['ⰱ']),
                    ('Ⰲ', &['ⰲ']),
                    ('Ⰳ', &['ⰳ']),
                    ('Ⰴ', &['ⰴ']),
                    ('Ⰵ', &['ⰵ']),
                    ('Ⰶ', &['ⰶ']),
                    ('Ⰷ', &['ⰷ']),
                    ('Ⰸ', &['ⰸ']),
                    ('Ⰹ', &['ⰹ']),
                    ('Ⰺ', &['ⰺ']),
                    ('Ⰻ', &['ⰻ']),
                    ('Ⰼ', &['ⰼ']),
                    ('Ⰽ', &['ⰽ']),
                    ('Ⰾ', &['ⰾ']),
                    ('Ⰿ', &['ⰿ']),
                    ('Ⱀ', &['ⱀ']),
                    ('Ⱁ', &['ⱁ']),
                    ('Ⱂ', &['ⱂ']),
                    ('Ⱃ', &['ⱃ']),
                    ('Ⱄ', &['ⱄ']),
                    ('Ⱅ', &['ⱅ']),
                    ('Ⱆ', &['ⱆ']),
                    ('Ⱇ', &['ⱇ']),
                    ('Ⱈ', &['ⱈ']),
                    ('Ⱉ', &['ⱉ']),
                    ('Ⱊ', &['ⱊ']),
                    ('Ⱋ', &['ⱋ']),
                    ('Ⱌ', &['ⱌ']),
                    ('Ⱍ', &['ⱍ']),
                    ('Ⱎ', &['ⱎ']),
                    ('Ⱏ', &['ⱏ']),
                    ('Ⱐ', &['ⱐ']),
                    ('Ⱑ', &['ⱑ']),
                    ('Ⱒ', &['ⱒ']),
                    ('Ⱓ', &['ⱓ']),
                    ('Ⱔ', &['ⱔ']),
                    ('Ⱕ', &['ⱕ']),
                    ('Ⱖ', &['ⱖ']),
                    ('Ⱗ', &['ⱗ']),
                    ('Ⱘ', &['ⱘ']),
                    ('Ⱙ', &['ⱙ']),
                    ('Ⱚ', &['ⱚ']),
                    ('Ⱛ', &['ⱛ']),
                    ('Ⱜ', &['ⱜ']),
                    ('Ⱝ', &['ⱝ']),
                    ('Ⱞ', &['ⱞ']),
                    ('Ⱟ', &['ⱟ']),
                    ('ⰰ', &['Ⰰ']),
                    ('ⰱ', &['Ⰱ']),
                    ('ⰲ', &['Ⰲ']),
                    ('ⰳ', &['Ⰳ']),
                    ('ⰴ', &['Ⰴ']),
                    ('ⰵ', &['Ⰵ']),
                    ('ⰶ', &['Ⰶ']),
                    ('ⰷ', &['Ⰷ']),
                    ('ⰸ', &['Ⰸ']),
                    ('ⰹ', &['Ⰹ']),
                    ('ⰺ', &['Ⰺ']),
                    ('ⰻ', &['Ⰻ']),
                    ('ⰼ', &['Ⰼ']),
                    ('ⰽ', &['Ⰽ']),
                    ('ⰾ', &['Ⰾ']),
                    ('ⰿ', &['Ⰿ']),
                    ('ⱀ', &['Ⱀ']),
                    ('ⱁ', &['Ⱁ']),
                    ('ⱂ', &['Ⱂ']),
                    ('ⱃ', &['Ⱃ']),
                    ('ⱄ', &['Ⱄ']),
                    ('ⱅ', &['Ⱅ']),
                    ('ⱆ', &['Ⱆ']),
                    ('ⱇ', &['Ⱇ']),
                    ('ⱈ', &['Ⱈ']),
                    ('ⱉ', &['Ⱉ']),
                    ('ⱊ', &['Ⱊ']),
                    ('ⱋ', &['Ⱋ']),
                    ('ⱌ', &['Ⱌ']),
                    ('ⱍ', &['Ⱍ']),
                    ('ⱎ', &['Ⱎ']),
                    ('ⱏ', &['Ⱏ']),
                    ('ⱐ', &['Ⱐ']),
                    ('ⱑ', &['Ⱑ']),
                    ('ⱒ', &['Ⱒ']),
                    ('ⱓ', &['Ⱓ']),
                    ('ⱔ', &['Ⱔ']),
                    ('ⱕ', &['Ⱕ']),
                    ('ⱖ', &['Ⱖ']),
                    ('ⱗ', &['Ⱗ']),
                    ('ⱘ', &['Ⱘ']),
                    ('ⱙ', &['Ⱙ']),
                    ('ⱚ', &['Ⱚ']),
                    ('ⱛ', &['Ⱛ']),
                    ('ⱜ', &['Ⱜ']),
                    ('ⱝ', &['Ⱝ']),
                    ('ⱞ', &['Ⱞ']),
                    ('ⱟ', &['Ⱟ']),
                    ('Ⱡ', &['ⱡ']),
                    ('ⱡ', &['Ⱡ']),
                    ('Ɫ', &['ɫ']),
                    ('Ᵽ', &['ᵽ']),
                    ('Ɽ', &['ɽ']),
                    ('ⱥ', &['Ⱥ']),
                    ('ⱦ', &['Ⱦ']),
                    ('Ⱨ', &['ⱨ']),
                    ('ⱨ', &['Ⱨ']),
                    ('Ⱪ', &['ⱪ']),
                    ('ⱪ', &['Ⱪ']),
                    ('Ⱬ', &['ⱬ']),
                    ('ⱬ', &['Ⱬ']),
                    ('Ɑ', &['ɑ']),
                    ('Ɱ', &['ɱ']),
                    ('Ɐ', &['ɐ']),
                    ('Ɒ', &['ɒ']),
                    ('Ⱳ', &['ⱳ']),
                    ('ⱳ', &['Ⱳ']),
                    ('Ⱶ', &['ⱶ']),
                    ('ⱶ', &['Ⱶ']),
                    ('Ȿ', &['ȿ']),
                    ('Ɀ', &['ɀ']),
                    ('Ⲁ', &['ⲁ']),
                    ('ⲁ', &['Ⲁ']),
                    ('Ⲃ', &['ⲃ']),
                    ('ⲃ', &['Ⲃ']),
                    ('Ⲅ', &['ⲅ']),
                    ('ⲅ', &['Ⲅ']),
                    ('Ⲇ', &['ⲇ']),
                    ('ⲇ', &['Ⲇ']),
                    ('Ⲉ', &['ⲉ']),
                    ('ⲉ', &['Ⲉ']),
                    ('Ⲋ', &['ⲋ']),
                    ('ⲋ', &['Ⲋ']),
                    ('Ⲍ', &['ⲍ']),
                    ('ⲍ', &['Ⲍ']),
                    ('Ⲏ', &['ⲏ']),
                    ('ⲏ', &['Ⲏ']),
                    ('Ⲑ', &['ⲑ']),
                    ('ⲑ', &['Ⲑ']),
                    ('Ⲓ', &['ⲓ']),
                    ('ⲓ', &['Ⲓ']),
                    ('Ⲕ', &['ⲕ']),
                    ('ⲕ', &['Ⲕ']),
                    ('Ⲗ', &['ⲗ']),
                    ('ⲗ', &['Ⲗ']),
                    ('Ⲙ', &['ⲙ']),
                    ('ⲙ', &['Ⲙ']),
                    ('Ⲛ', &['ⲛ']),
                    ('ⲛ', &['Ⲛ']),
                    ('Ⲝ', &['ⲝ']),
                    ('ⲝ', &['Ⲝ']),
                    ('Ⲟ', &['ⲟ']),
                    ('ⲟ', &['Ⲟ']),
                    ('Ⲡ', &['ⲡ']),
                    ('ⲡ', &['Ⲡ']),
                    ('Ⲣ', &['ⲣ']),
                    ('ⲣ', &['Ⲣ']),
                    ('Ⲥ', &['ⲥ']),
                    ('ⲥ', &['Ⲥ']),
                    ('Ⲧ', &['ⲧ']),
                    ('ⲧ', &['Ⲧ']),
                    ('Ⲩ', &['ⲩ']),
                    ('ⲩ', &['Ⲩ']),
                    ('Ⲫ', &['ⲫ']),
                    ('ⲫ', &['Ⲫ']),
                    ('Ⲭ', &['ⲭ']),
                    ('ⲭ', &['Ⲭ']),
                    ('Ⲯ', &['ⲯ']),
                    ('ⲯ', &['Ⲯ']),
                    ('Ⲱ', &['ⲱ']),
                    ('ⲱ', &['Ⲱ']),
                    ('Ⲳ', &['ⲳ']),
                    ('ⲳ', &['Ⲳ']),
                    ('Ⲵ', &['ⲵ']),
                    ('ⲵ', &['Ⲵ']),
                    ('Ⲷ', &['ⲷ']),
                    ('ⲷ', &['Ⲷ']),
                    ('Ⲹ', &['ⲹ']),
                    ('ⲹ', &['Ⲹ']),
                    ('Ⲻ', &['ⲻ']),
                    ('ⲻ', &['Ⲻ']),
                    ('Ⲽ', &['ⲽ']),
                    ('ⲽ', &['Ⲽ']),
                    ('Ⲿ', &['ⲿ']),
                    ('ⲿ', &['Ⲿ']),
                    ('Ⳁ', &['ⳁ']),
                    ('ⳁ', &['Ⳁ']),
                    ('Ⳃ', &['ⳃ']),
                    ('ⳃ', &['Ⳃ']),
                    ('Ⳅ', &['ⳅ']),
                    ('ⳅ', &['Ⳅ']),
                    ('Ⳇ', &['ⳇ']),
                    ('ⳇ', &['Ⳇ']),
                    ('Ⳉ', &['ⳉ']),
                    ('ⳉ', &['Ⳉ']),
                    ('Ⳋ', &['ⳋ']),
                    ('ⳋ', &['Ⳋ']),
                    ('Ⳍ', &['ⳍ']),
                    ('ⳍ', &['Ⳍ']),
                    ('Ⳏ', &['ⳏ']),
                    ('ⳏ', &['Ⳏ']),
                    ('Ⳑ', &['ⳑ']),
                    ('ⳑ', &['Ⳑ']),
                    ('Ⳓ', &['ⳓ']),
                    ('ⳓ', &['Ⳓ']),
                    ('Ⳕ', &['ⳕ']),
                    ('ⳕ', &['Ⳕ']),
                    ('Ⳗ', &['ⳗ']),
                    ('ⳗ', &['Ⳗ']),
                    ('Ⳙ', &['ⳙ']),
                    ('ⳙ', &['Ⳙ']),
                    ('Ⳛ', &['ⳛ']),
                    ('ⳛ', &['Ⳛ']),
                    ('Ⳝ', &['ⳝ']),
                    ('ⳝ', &['Ⳝ']),
                    ('Ⳟ', &['ⳟ']),
                    ('ⳟ', &['Ⳟ']),
                    ('Ⳡ', &['ⳡ']),
                    ('ⳡ', &['Ⳡ']),
                    ('Ⳣ', &['ⳣ']),
                    ('ⳣ', &['Ⳣ']),
                    ('Ⳬ', &['ⳬ']),
                    ('ⳬ', &['Ⳬ']),
                    ('Ⳮ', &['ⳮ']),
                    ('ⳮ', &['Ⳮ']),
                    ('Ⳳ', &['ⳳ']),
                    ('ⳳ', &['Ⳳ']),
                    ('ⴀ', &['Ⴀ']),
                    ('ⴁ', &['Ⴁ']),
                    ('ⴂ', &['Ⴂ']),
                    ('ⴃ', &['Ⴃ']),
                    ('ⴄ', &['Ⴄ']),
                    ('ⴅ', &['Ⴅ']),
                    ('ⴆ', &['Ⴆ']),
                    ('ⴇ', &['Ⴇ']),
                    ('ⴈ', &['Ⴈ']),
                    ('ⴉ', &['Ⴉ']),
                    ('ⴊ', &['Ⴊ']),
                    ('ⴋ', &['Ⴋ']),
                    ('ⴌ', &['Ⴌ']),
                    ('ⴍ', &['Ⴍ']),
                    ('ⴎ', &['Ⴎ']),
                    ('ⴏ', &['Ⴏ']),
                    ('ⴐ', &['Ⴐ']),
                    ('ⴑ', &['Ⴑ']),
                    ('ⴒ', &['Ⴒ']),
                    ('ⴓ', &['Ⴓ']),
                    ('ⴔ', &['Ⴔ']),
                    ('ⴕ', &['Ⴕ']),
                    ('ⴖ', &['Ⴖ']),
                    ('ⴗ', &['Ⴗ']),
                    ('ⴘ', &['Ⴘ']),
                    ('ⴙ', &['Ⴙ']),
                    ('ⴚ', &['Ⴚ']),
                    ('ⴛ', &['Ⴛ']),
                    ('ⴜ', &['Ⴜ']),
                    ('ⴝ', &['Ⴝ']),
                    ('ⴞ', &['Ⴞ']),
                    ('ⴟ', &['Ⴟ']),
                    ('ⴠ', &['Ⴠ']),
                    ('ⴡ', &['Ⴡ']),
                    ('ⴢ', &['Ⴢ']),
                    ('ⴣ', &['Ⴣ']),
                    ('ⴤ', &['Ⴤ']),
                    ('ⴥ', &['Ⴥ']),
                    ('ⴧ', &['Ⴧ']),
                    ('ⴭ', &['Ⴭ']),
                    ('Ꙁ', &['ꙁ']),
                    ('ꙁ', &['Ꙁ']),
                    ('Ꙃ', &['ꙃ']),
                    ('ꙃ', &['Ꙃ']),
                    ('Ꙅ', &['ꙅ']),
                    ('ꙅ', &['Ꙅ']),
                    ('Ꙇ', &['ꙇ']),
                    ('ꙇ', &['Ꙇ']),
                    ('Ꙉ', &['ꙉ']),
                    ('ꙉ', &['Ꙉ']),
                    ('Ꙋ', &['ᲈ', 'ꙋ']),
                    ('ꙋ', &['ᲈ', 'Ꙋ']),
                    ('Ꙍ', &['ꙍ']),
                    ('ꙍ', &['Ꙍ']),
                    ('Ꙏ', &['ꙏ']),
                    ('ꙏ', &['Ꙏ']),
                    ('Ꙑ', &['ꙑ']),
                    ('ꙑ', &['Ꙑ']),
                    ('Ꙓ', &['ꙓ']),
                    ('ꙓ', &['Ꙓ']),
                    ('Ꙕ', &['ꙕ']),
                    ('ꙕ', &['Ꙕ']),
                    ('Ꙗ', &['ꙗ']),
                    ('ꙗ', &['Ꙗ']),
                    ('Ꙙ', &['ꙙ']),
                    ('ꙙ', &['Ꙙ']),
                    ('Ꙛ', &['ꙛ']),
                    ('ꙛ', &['Ꙛ']),
                    ('Ꙝ', &['ꙝ']),
                    ('ꙝ', &['Ꙝ']),
                    ('Ꙟ', &['ꙟ']),
                    ('ꙟ', &['Ꙟ']),
                    ('Ꙡ', &['ꙡ']),
                    ('ꙡ', &['Ꙡ']),
                    ('Ꙣ', &['ꙣ']),
                    ('ꙣ', &['Ꙣ']),
                    ('Ꙥ', &['ꙥ']),
                    ('ꙥ', &['Ꙥ']),
                    ('Ꙧ', &['ꙧ']),
                    ('ꙧ', &['Ꙧ']),
                    ('Ꙩ', &['ꙩ']),
                    ('ꙩ', &['Ꙩ']),
                    ('Ꙫ', &['ꙫ']),
                    ('ꙫ', &['Ꙫ']),
                    ('Ꙭ', &['ꙭ']),
                    ('ꙭ', &['Ꙭ']),
                    ('Ꚁ', &['ꚁ']),
                    ('ꚁ', &['Ꚁ']),
                    ('Ꚃ', &['ꚃ']),
                    ('ꚃ', &['Ꚃ']),
                    ('Ꚅ', &['ꚅ']),
                    ('ꚅ', &['Ꚅ']),
                    ('Ꚇ', &['ꚇ']),
                    ('ꚇ', &['Ꚇ']),
                    ('Ꚉ', &['ꚉ']),
                    ('ꚉ', &['Ꚉ']),
                    ('Ꚋ', &['ꚋ']),
                    ('ꚋ', &['Ꚋ']),
                    ('Ꚍ', &['ꚍ']),
                    ('ꚍ', &['Ꚍ']),
                    ('Ꚏ', &['ꚏ']),
                    ('ꚏ', &['Ꚏ']),
                    ('Ꚑ', &['ꚑ']),
                    ('ꚑ', &['Ꚑ']),
                    ('Ꚓ', &['ꚓ']),
                    ('ꚓ', &['Ꚓ']),
                    ('Ꚕ', &['ꚕ']),
                    ('ꚕ', &['Ꚕ']),
                    ('Ꚗ', &['ꚗ']),
                    ('ꚗ', &['Ꚗ']),
                    ('Ꚙ', &['ꚙ']),
                    ('ꚙ', &['Ꚙ']),
                    ('Ꚛ', &['ꚛ']),
                    ('ꚛ', &['Ꚛ']),
                    ('Ꜣ', &['ꜣ']),
                    ('ꜣ', &['Ꜣ']),
                    ('Ꜥ', &['ꜥ']),
                    ('ꜥ', &['Ꜥ']),
                    ('Ꜧ', &['ꜧ']),
                    ('ꜧ', &['Ꜧ']),
                    ('Ꜩ', &['ꜩ']),
                    ('ꜩ', &['Ꜩ']),
                    ('Ꜫ', &['ꜫ']),
                    ('ꜫ', &['Ꜫ']),
                    ('Ꜭ', &['ꜭ']),
                    ('ꜭ', &['Ꜭ']),
                    ('Ꜯ', &['ꜯ']),
                    ('ꜯ', &['Ꜯ']),
                    ('Ꜳ', &['ꜳ']),
                    ('ꜳ', &['Ꜳ']),
                    ('Ꜵ', &['ꜵ']),
                    ('ꜵ', &['Ꜵ']),
                    ('Ꜷ', &['ꜷ']),
                    ('ꜷ', &['Ꜷ']),
                    ('Ꜹ', &['ꜹ']),
                    ('ꜹ', &['Ꜹ']),
                    ('Ꜻ', &['ꜻ']),
                    ('ꜻ', &['Ꜻ']),
                    ('Ꜽ', &['ꜽ']),
                    ('ꜽ', &['Ꜽ']),
                    ('Ꜿ', &['ꜿ']),
                    ('ꜿ', &['Ꜿ']),
                    ('Ꝁ', &['ꝁ']),
                    ('ꝁ', &['Ꝁ']),
                    ('Ꝃ', &['ꝃ']),
                    ('ꝃ', &['Ꝃ']),
                    ('Ꝅ', &['ꝅ']),
                    ('ꝅ', &['Ꝅ']),
                    ('Ꝇ', &['ꝇ']),
                    ('ꝇ', &['Ꝇ']),
                    ('Ꝉ', &['ꝉ']),
                    ('ꝉ', &['Ꝉ']),
                    ('Ꝋ', &['ꝋ']),
                    ('ꝋ', &['Ꝋ']),
                    ('Ꝍ', &['ꝍ']),
                    ('ꝍ', &['Ꝍ']),
                    ('Ꝏ', &['ꝏ']),
                    ('ꝏ', &['Ꝏ']),
                    ('Ꝑ', &['ꝑ']),
                    ('ꝑ', &['Ꝑ']),
                    ('Ꝓ', &['ꝓ']),
                    ('ꝓ', &['Ꝓ']),
                    ('Ꝕ', &['ꝕ']),
                    ('ꝕ', &['Ꝕ']),
                    ('Ꝗ', &['ꝗ']),
                    ('ꝗ', &['Ꝗ']),
                    ('Ꝙ', &['ꝙ']),
                    ('ꝙ', &['Ꝙ']),
                    ('Ꝛ', &['ꝛ']),
                    ('ꝛ', &['Ꝛ']),
                    ('Ꝝ', &['ꝝ']),
                    ('ꝝ', &['Ꝝ']),
                    ('Ꝟ', &['ꝟ']),
                    ('ꝟ', &['Ꝟ']),
                    ('Ꝡ', &['ꝡ']),
                    ('ꝡ', &['Ꝡ']),
                    ('Ꝣ', &['ꝣ']),
                    ('ꝣ', &['Ꝣ']),
                    ('Ꝥ', &['ꝥ']),
                    ('ꝥ', &['Ꝥ']),
                    ('Ꝧ', &['ꝧ']),
                    ('ꝧ', &['Ꝧ']),
                    ('Ꝩ', &['ꝩ']),
                    ('ꝩ', &['Ꝩ']),
                    ('Ꝫ', &['ꝫ']),
                    ('ꝫ', &['Ꝫ']),
                    ('Ꝭ', &['ꝭ']),
                    ('ꝭ', &['Ꝭ']),
                    ('Ꝯ', &['ꝯ']),
                    ('ꝯ', &['Ꝯ']),
                    ('Ꝺ', &['ꝺ']),
                    ('ꝺ', &['Ꝺ']),
                    ('Ꝼ', &['ꝼ']),
                    ('ꝼ', &['Ꝼ']),
                    ('Ᵹ', &['ᵹ']),
                    ('Ꝿ', &['ꝿ']),
                    ('ꝿ', &['Ꝿ']),
                    ('Ꞁ', &['ꞁ']),
                    ('ꞁ', &['Ꞁ']),
                    ('Ꞃ', &['ꞃ']),
                    ('ꞃ', &['Ꞃ']),
                    ('Ꞅ', &['ꞅ']),
                    ('ꞅ', &['Ꞅ']),
                    ('Ꞇ', &['ꞇ']),
                    ('ꞇ', &['Ꞇ']),
                    ('Ꞌ', &['ꞌ']),
                    ('ꞌ', &['Ꞌ']),
                    ('Ɥ', &['ɥ']),
                    ('Ꞑ', &['ꞑ']),
                    ('ꞑ', &['Ꞑ']),
                    ('Ꞓ', &['ꞓ']),
                    ('ꞓ', &['Ꞓ']),
                    ('ꞔ', &['Ꞔ']),
                    ('Ꞗ', &['ꞗ']),
                    ('ꞗ', &['Ꞗ']),
                    ('Ꞙ', &['ꞙ']),
                    ('ꞙ', &['Ꞙ']),
                    ('Ꞛ', &['ꞛ']),
                    ('ꞛ', &['Ꞛ']),
                    ('Ꞝ', &['ꞝ']),
                    ('ꞝ', &['Ꞝ']),
                    ('Ꞟ', &['ꞟ']),
                    ('ꞟ', &['Ꞟ']),
                    ('Ꞡ', &['ꞡ']),
                    ('ꞡ', &['Ꞡ']),
                    ('Ꞣ', &['ꞣ']),
                    ('ꞣ', &['Ꞣ']),
                    ('Ꞥ', &['ꞥ']),
                    ('ꞥ', &['Ꞥ']),
                    ('Ꞧ', &['ꞧ']),
                    ('ꞧ', &['Ꞧ']),
                    ('Ꞩ', &['ꞩ']),
                    ('ꞩ', &['Ꞩ']),
                    ('Ɦ', &['ɦ']),
                    ('Ɜ', &['ɜ']),
                    ('Ɡ', &['ɡ']),
                    ('Ɬ', &['ɬ']),
                    ('Ɪ', &['ɪ']),
                    ('Ʞ', &['ʞ']),
                    ('Ʇ', &['ʇ']),
                    ('Ʝ', &['ʝ']),
                    ('Ꭓ', &['ꭓ']),
                    ('Ꞵ', &['ꞵ']),
                    ('ꞵ', &['Ꞵ']),
                    ('Ꞷ', &['ꞷ']),
                    ('ꞷ', &['Ꞷ']),
                    ('Ꞹ', &['ꞹ']),
                    ('ꞹ', &['Ꞹ']),
                    ('Ꞻ', &['ꞻ']),
                    ('ꞻ', &['Ꞻ']),
                    ('Ꞽ', &['ꞽ']),
                    ('ꞽ', &['Ꞽ']),
                    ('Ꞿ', &['ꞿ']),
                    ('ꞿ', &['Ꞿ']),
                    ('Ꟁ', &['ꟁ']),
                    ('ꟁ', &['Ꟁ']),
                    ('Ꟃ', &['ꟃ']),
                    ('ꟃ', &['Ꟃ']),
                    ('Ꞔ', &['ꞔ']),
                    ('Ʂ', &['ʂ']),
                    ('Ᶎ', &['ᶎ']),
                    ('Ꟈ', &['ꟈ']),
                    ('ꟈ', &['Ꟈ']),
                    ('Ꟊ', &['ꟊ']),
                    ('ꟊ', &['Ꟊ']),
                    ('Ɤ', &['ɤ']),
                    ('Ꟍ', &['ꟍ']),
                    ('ꟍ', &['Ꟍ']),
                    ('Ꟑ', &['ꟑ']),
                    ('ꟑ', &['Ꟑ']),
                    ('Ꟗ', &['ꟗ']),
                    ('ꟗ', &['Ꟗ']),
                    ('Ꟙ', &['ꟙ']),
                    ('ꟙ', &['Ꟙ']),
                    ('Ꟛ', &['ꟛ']),
                    ('ꟛ', &['Ꟛ']),
                    ('Ƛ', &['ƛ']),
                    ('Ꟶ', &['ꟶ']),
                    ('ꟶ', &['Ꟶ']),
                    ('ꭓ', &['Ꭓ']),
                    ('ꭰ', &['Ꭰ']),
                    ('ꭱ', &['Ꭱ']),
                    ('ꭲ', &['Ꭲ']),
                    ('ꭳ', &['Ꭳ']),
                    ('ꭴ', &['Ꭴ']),
                    ('ꭵ', &['Ꭵ']),
                    ('ꭶ', &['Ꭶ']),
                    ('ꭷ', &['Ꭷ']),
                    ('ꭸ', &['Ꭸ']),
                    ('ꭹ', &['Ꭹ']),
                    ('ꭺ', &['Ꭺ']),
                    ('ꭻ', &['Ꭻ']),
                    ('ꭼ', &['Ꭼ']),
                    ('ꭽ', &['Ꭽ']),
                    ('ꭾ', &['Ꭾ']),
                    ('ꭿ', &['Ꭿ']),
                    ('ꮀ', &['Ꮀ']),
                    ('ꮁ', &['Ꮁ']),
                    ('ꮂ', &['Ꮂ']),
                    ('ꮃ', &['Ꮃ']),
                    ('ꮄ', &['Ꮄ']),
                    ('ꮅ', &['Ꮅ']),
                    ('ꮆ', &['Ꮆ']),
                    ('ꮇ', &['Ꮇ']),
                    ('ꮈ', &['Ꮈ']),
                    ('ꮉ', &['Ꮉ']),
                    ('ꮊ', &['Ꮊ']),
                    ('ꮋ', &['Ꮋ']),
                    ('ꮌ', &['Ꮌ']),
                    ('ꮍ', &['Ꮍ']),
                    ('ꮎ', &['Ꮎ']),
                    ('ꮏ', &['Ꮏ']),
                    ('ꮐ', &['Ꮐ']),
                    ('ꮑ', &['Ꮑ']),
                    ('ꮒ', &['Ꮒ']),
                    ('ꮓ', &['Ꮓ']),
                    ('ꮔ', &['Ꮔ']),
                    ('ꮕ', &['Ꮕ']),
                    ('ꮖ', &['Ꮖ']),
                    ('ꮗ', &['Ꮗ']),
                    ('ꮘ', &['Ꮘ']),
                    ('ꮙ', &['Ꮙ']),
                    ('ꮚ', &['Ꮚ']),
                    ('ꮛ', &['Ꮛ']),
                    ('ꮜ', &['Ꮜ']),
                    ('ꮝ', &['Ꮝ']),
                    ('ꮞ', &['Ꮞ']),
                    ('ꮟ', &['Ꮟ']),
                    ('ꮠ', &['Ꮠ']),
                    ('ꮡ', &['Ꮡ']),
                    ('ꮢ', &['Ꮢ']),
                    ('ꮣ', &['Ꮣ']),
                    ('ꮤ', &['Ꮤ']),
                    ('ꮥ', &['Ꮥ']),
                    ('ꮦ', &['Ꮦ']),
                    ('ꮧ', &['Ꮧ']),
                    ('ꮨ', &['Ꮨ']),
                    ('ꮩ', &['Ꮩ']),
                    ('ꮪ', &['Ꮪ']),
                    ('ꮫ', &['Ꮫ']),
                    ('ꮬ', &['Ꮬ']),
                    ('ꮭ', &['Ꮭ']),
                    ('ꮮ', &['Ꮮ']),
                    ('ꮯ', &['Ꮯ']),
                    ('ꮰ', &['Ꮰ']),
                    ('ꮱ', &['Ꮱ']),
                    ('ꮲ', &['Ꮲ']),
                    ('ꮳ', &['Ꮳ']),
                    ('ꮴ', &['Ꮴ']),
                    ('ꮵ', &['Ꮵ']),
                    ('ꮶ', &['Ꮶ']),
                    ('ꮷ', &['Ꮷ']),
                    ('ꮸ', &['Ꮸ']),
                    ('ꮹ', &['Ꮹ']),
                    ('ꮺ', &['Ꮺ']),
                    ('ꮻ', &['Ꮻ']),
                    ('ꮼ', &['Ꮼ']),
                    ('ꮽ', &['Ꮽ']),
                    ('ꮾ', &['Ꮾ']),
                    ('ꮿ', &['Ꮿ']),
                    ('ﬅ', &['ﬆ']),
                    ('ﬆ', &['ﬅ']),
                    ('Ａ', &['ａ']),
                    ('Ｂ', &['ｂ']),
                    ('Ｃ', &['ｃ']),
                    ('Ｄ', &['ｄ']),
                    ('Ｅ', &['ｅ']),
                    ('Ｆ', &['ｆ']),
                    ('Ｇ', &['ｇ']),
                    ('Ｈ', &['ｈ']),
                    ('Ｉ', &['ｉ']),
                    ('Ｊ', &['ｊ']),
                    ('Ｋ', &['ｋ']),
                    ('Ｌ', &['ｌ']),
                    ('Ｍ', &['ｍ']),
                    ('Ｎ', &['ｎ']),
                    ('Ｏ', &['ｏ']),
                    ('Ｐ', &['ｐ']),
                    ('Ｑ', &['ｑ']),
                    ('Ｒ', &['ｒ']),
                    ('Ｓ', &['ｓ']),
                    ('Ｔ', &['ｔ']),
                    ('Ｕ', &['ｕ']),
                    ('Ｖ', &['ｖ']),
                    ('Ｗ', &['ｗ']),
                    ('Ｘ', &['ｘ']),
                    ('Ｙ', &['ｙ']),
                    ('Ｚ', &['ｚ']),
                    ('ａ', &['Ａ']),
                    ('ｂ', &['Ｂ']),
                    ('ｃ', &['Ｃ']),
                    ('ｄ', &['Ｄ']),
                    ('ｅ', &['Ｅ']),
                    ('ｆ', &['Ｆ']),
                    ('ｇ', &['Ｇ']),
                    ('ｈ', &['Ｈ']),
                    ('ｉ', &['Ｉ']),
                    ('ｊ', &['Ｊ']),
                    ('ｋ', &['Ｋ']),
                    ('ｌ', &['Ｌ']),
                    ('ｍ', &['Ｍ']),
                    ('ｎ', &['Ｎ']),
                    ('ｏ', &['Ｏ']),
                    ('ｐ', &['Ｐ']),
                    ('ｑ', &['Ｑ']),
                    ('ｒ', &['Ｒ']),
                    ('ｓ', &['Ｓ']),
                    ('ｔ', &['Ｔ']),
                    ('ｕ', &['Ｕ']),
                    ('ｖ', &['Ｖ']),
                    ('ｗ', &['Ｗ']),
                    ('ｘ', &['Ｘ']),
                    ('ｙ', &['Ｙ']),
                    ('ｚ', &['Ｚ']),
                    ('𐐀', &['𐐨']),
                    ('𐐁', &['𐐩']),
                    ('𐐂', &['𐐪']),
                    ('𐐃', &['𐐫']),
                    ('𐐄', &['𐐬']),
                    ('𐐅', &['𐐭']),
                    ('𐐆', &['𐐮']),
                    ('𐐇', &['𐐯']),
                    ('𐐈', &['𐐰']),
                    ('𐐉', &['𐐱']),
                    ('𐐊', &['𐐲']),
                    ('𐐋', &['𐐳']),
                    ('𐐌', &['𐐴']),
                    ('𐐍', &['𐐵']),
                    ('𐐎', &['𐐶']),
                    ('𐐏', &['𐐷']),
                    ('𐐐', &['𐐸']),
                    ('𐐑', &['𐐹']),
                    ('𐐒', &['𐐺']),
                    ('𐐓', &['𐐻']),
                    ('𐐔', &['𐐼']),
                    ('𐐕', &['𐐽']),
                    ('𐐖', &['𐐾']),
                    ('𐐗', &['𐐿']),
                    ('𐐘', &['𐑀']),
                    ('𐐙', &['𐑁']),
                    ('𐐚', &['𐑂']),
                    ('𐐛', &['𐑃']),
                    ('𐐜', &['𐑄']),
                    ('𐐝', &['𐑅']),
                    ('𐐞', &['𐑆']),
                    ('𐐟', &['𐑇']),
                    ('𐐠', &['𐑈']),
                    ('𐐡', &['𐑉']),
                    ('𐐢', &['𐑊']),
                    ('𐐣', &['𐑋']),
                    ('𐐤', &['𐑌']),
                    ('𐐥', &['𐑍']),
                    ('𐐦', &['𐑎']),
                    ('𐐧', &['𐑏']),
                    ('𐐨', &['𐐀']),
                    ('𐐩', &['𐐁']),
                    ('𐐪', &['𐐂']),
                    ('𐐫', &['𐐃']),
                    ('𐐬', &['𐐄']),
                    ('𐐭', &['𐐅']),
                    ('𐐮', &['𐐆']),
                    ('𐐯', &['𐐇']),
                    ('𐐰', &['𐐈']),
                    ('𐐱', &['𐐉']),
                    ('𐐲', &['𐐊']),
                    ('𐐳', &['𐐋']),
                    ('𐐴', &['𐐌']),
                    ('𐐵', &['𐐍']),
                    ('𐐶', &['𐐎']),
                    ('𐐷', &['𐐏']),
                    ('𐐸', &['𐐐']),
                    ('𐐹', &['𐐑']),
                    ('𐐺', &['𐐒']),
                    ('𐐻', &['𐐓']),
                    ('𐐼', &['𐐔']),
                    ('𐐽', &['𐐕']),
                    ('𐐾', &['𐐖']),
                    ('𐐿', &['𐐗']),
                    ('𐑀', &['𐐘']),
                    ('𐑁', &['𐐙']),
                    ('𐑂', &['𐐚']),
                    ('𐑃', &['𐐛']),
                    ('𐑄', &['𐐜']),
                    ('𐑅', &['𐐝']),
                    ('𐑆', &['𐐞']),
                    ('𐑇', &['𐐟']),
                    ('𐑈', &['𐐠']),
                    ('𐑉', &['𐐡']),
                    ('𐑊', &['𐐢']),
                    ('𐑋', &['𐐣']),
                    ('𐑌', &['𐐤']),
                    ('𐑍', &['𐐥']),
                    ('𐑎', &['𐐦']),
                    ('𐑏', &['𐐧']),
                    ('𐒰', &['𐓘']),
                    ('𐒱', &['𐓙']),
                    ('𐒲', &['𐓚']),
                    ('𐒳', &['𐓛']),
                    ('𐒴', &['𐓜']),
                    ('𐒵', &['𐓝']),
                    ('𐒶', &['𐓞']),
                    ('𐒷', &['𐓟']),
                    ('𐒸', &['𐓠']),
                    ('𐒹', &['𐓡']),
                    ('𐒺', &['𐓢']),
                    ('𐒻', &['𐓣']),
                    ('𐒼', &['𐓤']),
                    ('𐒽', &['𐓥']),
                    ('𐒾', &['𐓦']),
                    ('𐒿', &['𐓧']),
                    ('𐓀', &['𐓨']),
                    ('𐓁', &['𐓩']),
                    ('𐓂', &['𐓪']),
                    ('𐓃', &['𐓫']),
                    ('𐓄', &['𐓬']),
                    ('𐓅', &['𐓭']),
                    ('𐓆', &['𐓮']),
                    ('𐓇', &['𐓯']),
                    ('𐓈', &['𐓰']),
                    ('𐓉', &['𐓱']),
                    ('𐓊', &['𐓲']),
                    ('𐓋', &['𐓳']),
                    ('𐓌', &['𐓴']),
                    ('𐓍', &['𐓵']),
                    ('𐓎', &['𐓶']),
                    ('𐓏', &['𐓷']),
                    ('𐓐', &['𐓸']),
                    ('𐓑', &['𐓹']),
                    ('𐓒', &['𐓺']),
                    ('𐓓', &['𐓻']),
                    ('𐓘', &['𐒰']),
                    ('𐓙', &['𐒱']),
                    ('𐓚', &['𐒲']),
                    ('𐓛', &['𐒳']),
                    ('𐓜', &['𐒴']),
                    ('𐓝', &['𐒵']),
                    ('𐓞', &['𐒶']),
                    ('𐓟', &['𐒷']),
                    ('𐓠', &['𐒸']),
                    ('𐓡', &['𐒹']),
                    ('𐓢', &['𐒺']),
                    ('𐓣', &['𐒻']),
                    ('𐓤', &['𐒼']),
                    ('𐓥', &['𐒽']),
                    ('𐓦', &['𐒾']),
                    ('𐓧', &['𐒿']),
                    ('𐓨', &['𐓀']),
                    ('𐓩', &['𐓁']),
                    ('𐓪', &['𐓂']),
                    ('𐓫', &['𐓃']),
                    ('𐓬', &['𐓄']),
                    ('𐓭', &['𐓅']),
                    ('𐓮', &['𐓆']),
                    ('𐓯', &['𐓇']),
                    ('𐓰', &['𐓈']),
                    ('𐓱', &['𐓉']),
                    ('𐓲', &['𐓊']),
                    ('𐓳', &['𐓋']),
                    ('𐓴', &['𐓌']),
                    ('𐓵', &['𐓍']),
                    ('𐓶', &['𐓎']),
                    ('𐓷', &['𐓏']),
                    ('𐓸', &['𐓐']),
                    ('𐓹', &['𐓑']),
                    ('𐓺', &['𐓒']),
                    ('𐓻', &['𐓓']),
                    ('𐕰', &['𐖗']),
                    ('𐕱', &['𐖘']),
                    ('𐕲', &['𐖙']),
                    ('𐕳', &['𐖚']),
                    ('𐕴', &['𐖛']),
                    ('𐕵', &['𐖜']),
                    ('𐕶', &['𐖝']),
                    ('𐕷', &['𐖞']),
                    ('𐕸', &['𐖟']),
                    ('𐕹', &['𐖠']),
                    ('𐕺', &['𐖡']),
                    ('𐕼', &['𐖣']),
                    ('𐕽', &['𐖤']),
                    ('𐕾', &['𐖥']),
                    ('𐕿', &['𐖦']),
                    ('𐖀', &['𐖧']),
                    ('𐖁', &['𐖨']),
                    ('𐖂', &['𐖩']),
                    ('𐖃', &['𐖪']),
                    ('𐖄', &['𐖫']),
                    ('𐖅', &['𐖬']),
                    ('𐖆', &['𐖭']),
                    ('𐖇', &['𐖮']),
                    ('𐖈', &['𐖯']),
                    ('𐖉', &['𐖰']),
                    ('𐖊', &['𐖱']),
                    ('𐖌', &['𐖳']),
                    ('𐖍', &['𐖴']),
                    ('𐖎', &['𐖵']),
                    ('𐖏', &['𐖶']),
                    ('𐖐', &['𐖷']),
                    ('𐖑', &['𐖸']),
                    ('𐖒', &['𐖹']),
                    ('𐖔', &['𐖻']),
                    ('𐖕', &['𐖼']),
                    ('𐖗', &['𐕰']),
                    ('𐖘', &['𐕱']),
                    ('𐖙', &['𐕲']),
                    ('𐖚', &['𐕳']),
                    ('𐖛', &['𐕴']),
                    ('𐖜', &['𐕵']),
                    ('𐖝', &['𐕶']),
                    ('𐖞', &['𐕷']),
                    ('𐖟', &['𐕸']),
                    ('𐖠', &['𐕹']),
                    ('𐖡', &['𐕺']),
                    ('𐖣', &['𐕼']),
                    ('𐖤', &['𐕽']),
                    ('𐖥', &['𐕾']),
                    ('𐖦', &['𐕿']),
                    ('𐖧', &['𐖀']),
                    ('𐖨', &['𐖁']),
                    ('𐖩', &['𐖂']),
                    ('𐖪', &['𐖃']),
                    ('𐖫', &['𐖄']),
                    ('𐖬', &['𐖅']),
                    ('𐖭', &['𐖆']),
                    ('𐖮', &['𐖇']),
                    ('𐖯', &['𐖈']),
                    ('𐖰', &['𐖉']),
                    ('𐖱', &['𐖊']),
                    ('𐖳', &['𐖌']),
                    ('𐖴', &['𐖍']),
                    ('𐖵', &['𐖎']),
                    ('𐖶', &['𐖏']),
                    ('𐖷', &['𐖐']),
                    ('𐖸', &['𐖑']),
                    ('𐖹', &['𐖒']),
                    ('𐖻', &['𐖔']),
                    ('𐖼', &['𐖕']),
                    ('𐲀', &['𐳀']),
                    ('𐲁', &['𐳁']),
                    ('𐲂', &['𐳂']),
                    ('𐲃', &['𐳃']),
                    ('𐲄', &['𐳄']),
                    ('𐲅', &['𐳅']),
                    ('𐲆', &['𐳆']),
                    ('𐲇', &['𐳇']),
                    ('𐲈', &['𐳈']),
                    ('𐲉', &['𐳉']),
                    ('𐲊', &['𐳊']),
                    ('𐲋', &['𐳋']),
                    ('𐲌', &['𐳌']),
                    ('𐲍', &['𐳍']),
                    ('𐲎', &['𐳎']),
                    ('𐲏', &['𐳏']),
                    ('𐲐', &['𐳐']),
                    ('𐲑', &['𐳑']),
                    ('𐲒', &['𐳒']),
                    ('𐲓', &['𐳓']),
                    ('𐲔', &['𐳔']),
                    ('𐲕', &['𐳕']),
                    ('𐲖', &['𐳖']),
                    ('𐲗', &['𐳗']),
                    ('𐲘', &['𐳘']),
                    ('𐲙', &['𐳙']),
                    ('𐲚', &['𐳚']),
                    ('𐲛', &['𐳛']),
                    ('𐲜', &['𐳜']),
                    ('𐲝', &['𐳝']),
                    ('𐲞', &['𐳞']),
                    ('𐲟', &['𐳟']),
                    ('𐲠', &['𐳠']),
                    ('𐲡', &['𐳡']),
                    ('𐲢', &['𐳢']),
                    ('𐲣', &['𐳣']),
                    ('𐲤', &['𐳤']),
                    ('𐲥', &['𐳥']),
                    ('𐲦', &['𐳦']),
                    ('𐲧', &['𐳧']),
                    ('𐲨', &['𐳨']),
                    ('𐲩', &['𐳩']),
                    ('𐲪', &['𐳪']),
                    ('𐲫', &['𐳫']),
                    ('𐲬', &['𐳬']),
                    ('𐲭', &['𐳭']),
                    ('𐲮', &['𐳮']),
                    ('𐲯', &['𐳯']),
                    ('𐲰', &['𐳰']),
                    ('𐲱', &['𐳱']),
                    ('𐲲', &['𐳲']),
                    ('𐳀', &['𐲀']),
                    ('𐳁', &['𐲁']),
                    ('𐳂', &['𐲂']),
                    ('𐳃', &['𐲃']),
                    ('𐳄', &['𐲄']),
                    ('𐳅', &['𐲅']),
                    ('𐳆', &['𐲆']),
                    ('𐳇', &['𐲇']),
                    ('𐳈', &['𐲈']),
                    ('𐳉', &['𐲉']),
                    ('𐳊', &['𐲊']),
                    ('𐳋', &['𐲋']),
                    ('𐳌', &['𐲌']),
                    ('𐳍', &['𐲍']),
                    ('𐳎', &['𐲎']),
                    ('𐳏', &['𐲏']),
                    ('𐳐', &['𐲐']),
                    ('𐳑', &['𐲑']),
                    ('𐳒', &['𐲒']),
                    ('𐳓', &['𐲓']),
                    ('𐳔', &['𐲔']),
                    ('𐳕', &['𐲕']),
                    ('𐳖', &['𐲖']),
                    ('𐳗', &['𐲗']),
                    ('𐳘', &['𐲘']),
                    ('𐳙', &['𐲙']),
                    ('𐳚', &['𐲚']),
                    ('𐳛', &['𐲛']),
                    ('𐳜', &['𐲜']),
                    ('𐳝', &['𐲝']),
                    ('𐳞', &['𐲞']),
                    ('𐳟', &['𐲟']),
                    ('𐳠', &['𐲠']),
                    ('𐳡', &['𐲡']),
                    ('𐳢', &['𐲢']),
                    ('𐳣', &['𐲣']),
                    ('𐳤', &['𐲤']),
                    ('𐳥', &['𐲥']),
                    ('𐳦', &['𐲦']),
                    ('𐳧', &['𐲧']),
                    ('𐳨', &['𐲨']),
                    ('𐳩', &['𐲩']),
                    ('𐳪', &['𐲪']),
                    ('𐳫', &['𐲫']),
                    ('𐳬', &['𐲬']),
                    ('𐳭', &['𐲭']),
                    ('𐳮', &['𐲮']),
                    ('𐳯', &['𐲯']),
                    ('𐳰', &['𐲰']),
                    ('𐳱', &['𐲱']),
                    ('𐳲', &['𐲲']),
                    ('𐵐', &['𐵰']),
                    ('𐵑', &['𐵱']),
                    ('𐵒', &['𐵲']),
                    ('𐵓', &['𐵳']),
                    ('𐵔', &['𐵴']),
                    ('𐵕', &['𐵵']),
                    ('𐵖', &['𐵶']),
                    ('𐵗', &['𐵷']),
                    ('𐵘', &['𐵸']),
                    ('𐵙', &['𐵹']),
                    ('𐵚', &['𐵺']),
                    ('𐵛', &['𐵻']),
                    ('𐵜', &['𐵼']),
                    ('𐵝', &['𐵽']),
                    ('𐵞', &['𐵾']),
                    ('𐵟', &['𐵿']),
                    ('𐵠', &['𐶀']),
                    ('𐵡', &['𐶁']),
                    ('𐵢', &['𐶂']),
                    ('𐵣', &['𐶃']),
                    ('𐵤', &['𐶄']),
                    ('𐵥', &['𐶅']),
                    ('𐵰', &['𐵐']),
                    ('𐵱', &['𐵑']),
                    ('𐵲', &['𐵒']),
                    ('𐵳', &['𐵓']),
                    ('𐵴', &['𐵔']),
                    ('𐵵', &['𐵕']),
                    ('𐵶', &['𐵖']),
                    ('𐵷', &['𐵗']),
                    ('𐵸', &['𐵘']),
                    ('𐵹', &['𐵙']),
                    ('𐵺', &['𐵚']),
                    ('𐵻', &['𐵛']),
                    ('𐵼', &['𐵜']),
                    ('𐵽', &['𐵝']),
                    ('𐵾', &['𐵞']),
                    ('𐵿', &['𐵟']),
                    ('𐶀', &['𐵠']),
                    ('𐶁', &['𐵡']),
                    ('𐶂', &['𐵢']),
                    ('𐶃', &['𐵣']),
                    ('𐶄', &['𐵤']),
                    ('𐶅', &['𐵥']),
                    ('𑢠', &['𑣀']),
                    ('𑢡', &['𑣁']),
                    ('𑢢', &['𑣂']),
                    ('𑢣', &['𑣃']),
                    ('𑢤', &['𑣄']),
                    ('𑢥', &['𑣅']),
                    ('𑢦', &['𑣆']),
                    ('𑢧', &['𑣇']),
                    ('𑢨', &['𑣈']),
                    ('𑢩', &['𑣉']),
                    ('𑢪', &['𑣊']),
                    ('𑢫', &['𑣋']),
                    ('𑢬', &['𑣌']),
                    ('𑢭', &['𑣍']),
                    ('𑢮', &['𑣎']),
                    ('𑢯', &['𑣏']),
                    ('𑢰', &['𑣐']),
                    ('𑢱', &['𑣑']),
                    ('𑢲', &['𑣒']),
                    ('𑢳', &['𑣓']),
                    ('𑢴', &['𑣔']),
                    ('𑢵', &['𑣕']),
                    ('𑢶', &['𑣖']),
                    ('𑢷', &['𑣗']),
                    ('𑢸', &['𑣘']),
                    ('𑢹', &['𑣙']),
                    ('𑢺', &['𑣚']),
                    ('𑢻', &['𑣛']),
                    ('𑢼', &['𑣜']),
                    ('𑢽', &['𑣝']),
                    ('𑢾', &['𑣞']),
                    ('𑢿', &['𑣟']),
                    ('𑣀', &['𑢠']),
                    ('𑣁', &['𑢡']),
                    ('𑣂', &['𑢢']),
                    ('𑣃', &['𑢣']),
                    ('𑣄', &['𑢤']),
                    ('𑣅', &['𑢥']),
                    ('𑣆', &['𑢦']),
                    ('𑣇', &['𑢧']),
                    ('𑣈', &['𑢨']),
                    ('𑣉', &['𑢩']),
                    ('𑣊', &['𑢪']),
                    ('𑣋', &['𑢫']),
                    ('𑣌', &['𑢬']),
                    ('𑣍', &['𑢭']),
                    ('𑣎', &['𑢮']),
                    ('𑣏', &['𑢯']),
                    ('𑣐', &['𑢰']),
                    ('𑣑', &['𑢱']),
                    ('𑣒', &['𑢲']),
                    ('𑣓', &['𑢳']),
                    ('𑣔', &['𑢴']),
                    ('𑣕', &['𑢵']),
                    ('𑣖', &['𑢶']),
                    ('𑣗', &['𑢷']),
                    ('𑣘', &['𑢸']),
                    ('𑣙', &['𑢹']),
                    ('𑣚', &['𑢺']),
                    ('𑣛', &['𑢻']),
                    ('𑣜', &['𑢼']),
                    ('𑣝', &['𑢽']),
                    ('𑣞', &['𑢾']),
                    ('𑣟', &['𑢿']),
                    ('𖹀', &['𖹠']),
                    ('𖹁', &['𖹡']),
                    ('𖹂', &['𖹢']),
                    ('𖹃', &['𖹣']),
                    ('𖹄', &['𖹤']),
                    ('𖹅', &['𖹥']),
                    ('𖹆', &['𖹦']),
                    ('𖹇', &['𖹧']),
                    ('𖹈', &['𖹨']),
                    ('𖹉', &['𖹩']),
                    ('𖹊', &['𖹪']),
                    ('𖹋', &['𖹫']),
                    ('𖹌', &['𖹬']),
                    ('𖹍', &['𖹭']),
                    ('𖹎', &['𖹮']),
                    ('𖹏', &['𖹯']),
                    ('𖹐', &['𖹰']),
                    ('𖹑', &['𖹱']),
                    ('𖹒', &['𖹲']),
                    ('𖹓', &['𖹳']),
                    ('𖹔', &['𖹴']),
                    ('𖹕', &['𖹵']),
                    ('𖹖', &['𖹶']),
                    ('𖹗', &['𖹷']),
                    ('𖹘', &['𖹸']),
                    ('𖹙', &['𖹹']),
                    ('𖹚', &['𖹺']),
                    ('𖹛', &['𖹻']),
                    ('𖹜', &['𖹼']),
                    ('𖹝', &['𖹽']),
                    ('𖹞', &['𖹾']),
                    ('𖹟', &['𖹿']),
                    ('𖹠', &['𖹀']),
                    ('𖹡', &['𖹁']),
                    ('𖹢', &['𖹂']),
                    ('𖹣', &['𖹃']),
                    ('𖹤', &['𖹄']),
                    ('𖹥', &['𖹅']),
                    ('𖹦', &['𖹆']),
                    ('𖹧', &['𖹇']),
                    ('𖹨', &['𖹈']),
                    ('𖹩', &['𖹉']),
                    ('𖹪', &['𖹊']),
                    ('𖹫', &['𖹋']),
                    ('𖹬', &['𖹌']),
                    ('𖹭', &['𖹍']),
                    ('𖹮', &['𖹎']),
                    ('𖹯', &['𖹏']),
                    ('𖹰', &['𖹐']),
                    ('𖹱', &['𖹑']),
                    ('𖹲', &['𖹒']),
                    ('𖹳', &['𖹓']),
                    ('𖹴', &['𖹔']),
                    ('𖹵', &['𖹕']),
                    ('𖹶', &['𖹖']),
                    ('𖹷', &['𖹗']),
                    ('𖹸', &['𖹘']),
                    ('𖹹', &['𖹙']),
                    ('𖹺', &['𖹚']),
                    ('𖹻', &['𖹛']),
                    ('𖹼', &['𖹜']),
                    ('𖹽', &['𖹝']),
                    ('𖹾', &['𖹞']),
                    ('𖹿', &['𖹟']),
                    ('𞤀', &['𞤢']),
                    ('𞤁', &['𞤣']),
                    ('𞤂', &['𞤤']),
                    ('𞤃', &['𞤥']),
                    ('𞤄', &['𞤦']),
                    ('𞤅', &['𞤧']),
                    ('𞤆', &['𞤨']),
                    ('𞤇', &['𞤩']),
                    ('𞤈', &['𞤪']),
                    ('𞤉', &['𞤫']),
                    ('𞤊', &['𞤬']),
                    ('𞤋', &['𞤭']),
                    ('𞤌', &['𞤮']),
                    ('𞤍', &['𞤯']),
                    ('𞤎', &['𞤰']),
                    ('𞤏', &['𞤱']),
                    ('𞤐', &['𞤲']),
                    ('𞤑', &['𞤳']),
                    ('𞤒', &['𞤴']),
                    ('𞤓', &['𞤵']),
                    ('𞤔', &['𞤶']),
                    ('𞤕', &['𞤷']),
                    ('𞤖', &['𞤸']),
                    ('𞤗', &['𞤹']),
                    ('𞤘', &['𞤺']),
                    ('𞤙', &['𞤻']),
                    ('𞤚', &['𞤼']),
                    ('𞤛', &['𞤽']),
                    ('𞤜', &['𞤾']),
                    ('𞤝', &['𞤿']),
                    ('𞤞', &['𞥀']),
                    ('𞤟', &['𞥁']),
                    ('𞤠', &['𞥂']),
                    ('𞤡', &['𞥃']),
                    ('𞤢', &['𞤀']),
                    ('𞤣', &['𞤁']),
                    ('𞤤', &['𞤂']),
                    ('𞤥', &['𞤃']),
                    ('𞤦', &['𞤄']),
                    ('𞤧', &['𞤅']),
                    ('𞤨', &['𞤆']),
                    ('𞤩', &['𞤇']),
                    ('𞤪', &['𞤈']),
                    ('𞤫', &['𞤉']),
                    ('𞤬', &['𞤊']),
                    ('𞤭', &['𞤋']),
                    ('𞤮', &['𞤌']),
                    ('𞤯', &['𞤍']),
                    ('𞤰', &['𞤎']),
                    ('𞤱', &['𞤏']),
                    ('𞤲', &['𞤐']),
                    ('𞤳', &['𞤑']),
                    ('𞤴', &['𞤒']),
                    ('𞤵', &['𞤓']),
                    ('𞤶', &['𞤔']),
                    ('𞤷', &['𞤕']),
                    ('𞤸', &['𞤖']),
                    ('𞤹', &['𞤗']),
                    ('𞤺', &['𞤘']),
                    ('𞤻', &['𞤙']),
                    ('𞤼', &['𞤚']),
                    ('𞤽', &['𞤛']),
                    ('𞤾', &['𞤜']),
                    ('𞤿', &['𞤝']),
                    ('𞥀', &['𞤞']),
                    ('𞥁', &['𞤟']),
                    ('𞥂', &['𞤠']),
                    ('𞥃', &['𞤡']),
                ];
            }

            pub mod general_category
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &[
                    ("Cased_Letter", CASED_LETTER),
                    ("Close_Punctuation", CLOSE_PUNCTUATION),
                    ("Connector_Punctuation", CONNECTOR_PUNCTUATION),
                    ("Control", CONTROL),
                    ("Currency_Symbol", CURRENCY_SYMBOL),
                    ("Dash_Punctuation", DASH_PUNCTUATION),
                    ("Decimal_Number", DECIMAL_NUMBER),
                    ("Enclosing_Mark", ENCLOSING_MARK),
                    ("Final_Punctuation", FINAL_PUNCTUATION),
                    ("Format", FORMAT),
                    ("Initial_Punctuation", INITIAL_PUNCTUATION),
                    ("Letter", LETTER),
                    ("Letter_Number", LETTER_NUMBER),
                    ("Line_Separator", LINE_SEPARATOR),
                    ("Lowercase_Letter", LOWERCASE_LETTER),
                    ("Mark", MARK),
                    ("Math_Symbol", MATH_SYMBOL),
                    ("Modifier_Letter", MODIFIER_LETTER),
                    ("Modifier_Symbol", MODIFIER_SYMBOL),
                    ("Nonspacing_Mark", NONSPACING_MARK),
                    ("Number", NUMBER),
                    ("Open_Punctuation", OPEN_PUNCTUATION),
                    ("Other", OTHER),
                    ("Other_Letter", OTHER_LETTER),
                    ("Other_Number", OTHER_NUMBER),
                    ("Other_Punctuation", OTHER_PUNCTUATION),
                    ("Other_Symbol", OTHER_SYMBOL),
                    ("Paragraph_Separator", PARAGRAPH_SEPARATOR),
                    ("Private_Use", PRIVATE_USE),
                    ("Punctuation", PUNCTUATION),
                    ("Separator", SEPARATOR),
                    ("Space_Separator", SPACE_SEPARATOR),
                    ("Spacing_Mark", SPACING_MARK),
                    ("Symbol", SYMBOL),
                    ("Titlecase_Letter", TITLECASE_LETTER),
                    ("Unassigned", UNASSIGNED),
                    ("Uppercase_Letter", UPPERCASE_LETTER),
                ];

                pub const CASED_LETTER: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('µ', 'µ'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ƺ'),
                    ('Ƽ', 'ƿ'),
                    ('Ǆ', 'ʓ'),
                    ('ʕ', 'ʯ'),
                    ('Ͱ', 'ͳ'),
                    ('Ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՠ', 'ֈ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჽ', 'ჿ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᴀ', 'ᴫ'),
                    ('ᵫ', 'ᵷ'),
                    ('ᵹ', 'ᶚ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℯ', 'ℴ'),
                    ('ℹ', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ↄ', 'ↄ'),
                    ('Ⰰ', 'ⱻ'),
                    ('Ȿ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('Ꙁ', 'ꙭ'),
                    ('Ꚁ', 'ꚛ'),
                    ('Ꜣ', 'ꝯ'),
                    ('ꝱ', 'ꞇ'),
                    ('Ꞌ', 'ꞎ'),
                    ('Ꞑ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('Ꟶ', 'ꟶ'),
                    ('ꟺ', 'ꟺ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭠ', 'ꭨ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('𐐀', '𐑏'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐵐', '𐵥'),
                    ('𐵰', '𐶅'),
                    ('𑢠', '𑣟'),
                    ('𖹀', '𖹿'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼉'),
                    ('𝼋', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞤀', '𞥃'),
                ];

                pub const CLOSE_PUNCTUATION: &'static [(char, char)] = &[
                    (')', ')'),
                    (']', ']'),
                    ('}', '}'),
                    ('༻', '༻'),
                    ('༽', '༽'),
                    ('᚜', '᚜'),
                    ('⁆', '⁆'),
                    ('⁾', '⁾'),
                    ('₎', '₎'),
                    ('⌉', '⌉'),
                    ('⌋', '⌋'),
                    ('〉', '〉'),
                    ('❩', '❩'),
                    ('❫', '❫'),
                    ('❭', '❭'),
                    ('❯', '❯'),
                    ('❱', '❱'),
                    ('❳', '❳'),
                    ('❵', '❵'),
                    ('⟆', '⟆'),
                    ('⟧', '⟧'),
                    ('⟩', '⟩'),
                    ('⟫', '⟫'),
                    ('⟭', '⟭'),
                    ('⟯', '⟯'),
                    ('⦄', '⦄'),
                    ('⦆', '⦆'),
                    ('⦈', '⦈'),
                    ('⦊', '⦊'),
                    ('⦌', '⦌'),
                    ('⦎', '⦎'),
                    ('⦐', '⦐'),
                    ('⦒', '⦒'),
                    ('⦔', '⦔'),
                    ('⦖', '⦖'),
                    ('⦘', '⦘'),
                    ('⧙', '⧙'),
                    ('⧛', '⧛'),
                    ('⧽', '⧽'),
                    ('⸣', '⸣'),
                    ('⸥', '⸥'),
                    ('⸧', '⸧'),
                    ('⸩', '⸩'),
                    ('⹖', '⹖'),
                    ('⹘', '⹘'),
                    ('⹚', '⹚'),
                    ('⹜', '⹜'),
                    ('〉', '〉'),
                    ('》', '》'),
                    ('」', '」'),
                    ('』', '』'),
                    ('】', '】'),
                    ('〕', '〕'),
                    ('〗', '〗'),
                    ('〙', '〙'),
                    ('〛', '〛'),
                    ('〞', '〟'),
                    ('﴾', '﴾'),
                    ('︘', '︘'),
                    ('︶', '︶'),
                    ('︸', '︸'),
                    ('︺', '︺'),
                    ('︼', '︼'),
                    ('︾', '︾'),
                    ('﹀', '﹀'),
                    ('﹂', '﹂'),
                    ('﹄', '﹄'),
                    ('﹈', '﹈'),
                    ('﹚', '﹚'),
                    ('﹜', '﹜'),
                    ('﹞', '﹞'),
                    ('）', '）'),
                    ('］', '］'),
                    ('｝', '｝'),
                    ('｠', '｠'),
                    ('｣', '｣'),
                ];

                pub const CONNECTOR_PUNCTUATION: &'static [(char, char)] = &[
                    ('_', '_'),
                    ('‿', '⁀'),
                    ('⁔', '⁔'),
                    ('︳', '︴'),
                    ('﹍', '﹏'),
                    ('＿', '＿'),
                ];

                pub const CONTROL: &'static [(char, char)] =
                    &[('\0', '\u{1f}'), ('\u{7f}', '\u{9f}')];

                pub const CURRENCY_SYMBOL: &'static [(char, char)] = &[
                    ('$', '$'),
                    ('¢', '¥'),
                    ('֏', '֏'),
                    ('؋', '؋'),
                    ('߾', '߿'),
                    ('৲', '৳'),
                    ('৻', '৻'),
                    ('૱', '૱'),
                    ('௹', '௹'),
                    ('฿', '฿'),
                    ('៛', '៛'),
                    ('₠', '⃀'),
                    ('꠸', '꠸'),
                    ('﷼', '﷼'),
                    ('﹩', '﹩'),
                    ('＄', '＄'),
                    ('￠', '￡'),
                    ('￥', '￦'),
                    ('𑿝', '𑿠'),
                    ('𞋿', '𞋿'),
                    ('𞲰', '𞲰'),
                ];

                pub const DASH_PUNCTUATION: &'static [(char, char)] = &[
                    ('-', '-'),
                    ('֊', '֊'),
                    ('־', '־'),
                    ('᐀', '᐀'),
                    ('᠆', '᠆'),
                    ('‐', '―'),
                    ('⸗', '⸗'),
                    ('⸚', '⸚'),
                    ('⸺', '⸻'),
                    ('⹀', '⹀'),
                    ('⹝', '⹝'),
                    ('〜', '〜'),
                    ('〰', '〰'),
                    ('゠', '゠'),
                    ('︱', '︲'),
                    ('﹘', '﹘'),
                    ('﹣', '﹣'),
                    ('－', '－'),
                    ('𐵮', '𐵮'),
                    ('𐺭', '𐺭'),
                ];

                pub const DECIMAL_NUMBER: &'static [(char, char)] = &[
                    ('0', '9'),
                    ('٠', '٩'),
                    ('۰', '۹'),
                    ('߀', '߉'),
                    ('०', '९'),
                    ('০', '৯'),
                    ('੦', '੯'),
                    ('૦', '૯'),
                    ('୦', '୯'),
                    ('௦', '௯'),
                    ('౦', '౯'),
                    ('೦', '೯'),
                    ('൦', '൯'),
                    ('෦', '෯'),
                    ('๐', '๙'),
                    ('໐', '໙'),
                    ('༠', '༩'),
                    ('၀', '၉'),
                    ('႐', '႙'),
                    ('០', '៩'),
                    ('᠐', '᠙'),
                    ('᥆', '᥏'),
                    ('᧐', '᧙'),
                    ('᪀', '᪉'),
                    ('᪐', '᪙'),
                    ('᭐', '᭙'),
                    ('᮰', '᮹'),
                    ('᱀', '᱉'),
                    ('᱐', '᱙'),
                    ('꘠', '꘩'),
                    ('꣐', '꣙'),
                    ('꤀', '꤉'),
                    ('꧐', '꧙'),
                    ('꧰', '꧹'),
                    ('꩐', '꩙'),
                    ('꯰', '꯹'),
                    ('０', '９'),
                    ('𐒠', '𐒩'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵉'),
                    ('𑁦', '𑁯'),
                    ('𑃰', '𑃹'),
                    ('𑄶', '𑄿'),
                    ('𑇐', '𑇙'),
                    ('𑋰', '𑋹'),
                    ('𑑐', '𑑙'),
                    ('𑓐', '𑓙'),
                    ('𑙐', '𑙙'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜰', '𑜹'),
                    ('𑣠', '𑣩'),
                    ('𑥐', '𑥙'),
                    ('𑯰', '𑯹'),
                    ('𑱐', '𑱙'),
                    ('𑵐', '𑵙'),
                    ('𑶠', '𑶩'),
                    ('𑽐', '𑽙'),
                    ('𖄰', '𖄹'),
                    ('𖩠', '𖩩'),
                    ('𖫀', '𖫉'),
                    ('𖭐', '𖭙'),
                    ('𖵰', '𖵹'),
                    ('𜳰', '𜳹'),
                    ('𝟎', '𝟿'),
                    ('𞅀', '𞅉'),
                    ('𞋰', '𞋹'),
                    ('𞓰', '𞓹'),
                    ('𞗱', '𞗺'),
                    ('𞥐', '𞥙'),
                    ('🯰', '🯹'),
                ];

                pub const ENCLOSING_MARK: &'static [(char, char)] = &[
                    ('\u{488}', '\u{489}'),
                    ('\u{1abe}', '\u{1abe}'),
                    ('\u{20dd}', '\u{20e0}'),
                    ('\u{20e2}', '\u{20e4}'),
                    ('\u{a670}', '\u{a672}'),
                ];

                pub const FINAL_PUNCTUATION: &'static [(char, char)] = &[
                    ('»', '»'),
                    ('’', '’'),
                    ('”', '”'),
                    ('›', '›'),
                    ('⸃', '⸃'),
                    ('⸅', '⸅'),
                    ('⸊', '⸊'),
                    ('⸍', '⸍'),
                    ('⸝', '⸝'),
                    ('⸡', '⸡'),
                ];

                pub const FORMAT: &'static [(char, char)] = &[
                    ('\u{ad}', '\u{ad}'),
                    ('\u{600}', '\u{605}'),
                    ('\u{61c}', '\u{61c}'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('\u{70f}', '\u{70f}'),
                    ('\u{890}', '\u{891}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('\u{180e}', '\u{180e}'),
                    ('\u{200b}', '\u{200f}'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2060}', '\u{2064}'),
                    ('\u{2066}', '\u{206f}'),
                    ('\u{feff}', '\u{feff}'),
                    ('\u{fff9}', '\u{fffb}'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110cd}', '\u{110cd}'),
                    ('\u{13430}', '\u{1343f}'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('\u{1d173}', '\u{1d17a}'),
                    ('\u{e0001}', '\u{e0001}'),
                    ('\u{e0020}', '\u{e007f}'),
                ];

                pub const INITIAL_PUNCTUATION: &'static [(char, char)] = &[
                    ('«', '«'),
                    ('‘', '‘'),
                    ('‛', '“'),
                    ('‟', '‟'),
                    ('‹', '‹'),
                    ('⸂', '⸂'),
                    ('⸄', '⸄'),
                    ('⸉', '⸉'),
                    ('⸌', '⸌'),
                    ('⸜', '⸜'),
                    ('⸠', '⸠'),
                ];

                pub const LETTER: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('Ͱ', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('ؠ', 'ي'),
                    ('ٮ', 'ٯ'),
                    ('ٱ', 'ۓ'),
                    ('ە', 'ە'),
                    ('ۥ', 'ۦ'),
                    ('ۮ', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠀ', 'ࠕ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('ࢠ', 'ࣉ'),
                    ('ऄ', 'ह'),
                    ('ऽ', 'ऽ'),
                    ('ॐ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('ॱ', 'ঀ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('ੲ', 'ੴ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ઽ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('ૹ', 'ૹ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('ୱ', 'ୱ'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ௐ', 'ௐ'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('ಀ', 'ಀ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಽ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('ೱ', 'ೲ'),
                    ('ഄ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', 'ൖ'),
                    ('ൟ', 'ൡ'),
                    ('ൺ', 'ൿ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ก', 'ะ'),
                    ('า', 'ำ'),
                    ('เ', 'ๆ'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ະ'),
                    ('າ', 'ຳ'),
                    ('ຽ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ྈ', 'ྌ'),
                    ('က', 'ဪ'),
                    ('ဿ', 'ဿ'),
                    ('ၐ', 'ၕ'),
                    ('ၚ', 'ၝ'),
                    ('ၡ', 'ၡ'),
                    ('ၥ', 'ၦ'),
                    ('ၮ', 'ၰ'),
                    ('ၵ', 'ႁ'),
                    ('ႎ', 'ႎ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛱ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ក', 'ឳ'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', 'ៜ'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢄ'),
                    ('ᢇ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('ᨀ', 'ᨖ'),
                    ('ᨠ', 'ᩔ'),
                    ('ᪧ', 'ᪧ'),
                    ('ᬅ', 'ᬳ'),
                    ('ᭅ', 'ᭌ'),
                    ('ᮃ', 'ᮠ'),
                    ('ᮮ', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᰀ', 'ᰣ'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ᴀ', 'ᶿ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℯ', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ↄ', 'ↄ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '〆'),
                    ('〱', '〵'),
                    ('〻', '〼'),
                    ('ぁ', 'ゖ'),
                    ('ゝ', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('Ꙁ', 'ꙮ'),
                    ('ꙿ', 'ꚝ'),
                    ('ꚠ', 'ꛥ'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠢ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢂ', 'ꢳ'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', 'ꣾ'),
                    ('ꤊ', 'ꤥ'),
                    ('ꤰ', 'ꥆ'),
                    ('ꥠ', 'ꥼ'),
                    ('ꦄ', 'ꦲ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧠ', 'ꧤ'),
                    ('ꧦ', 'ꧯ'),
                    ('ꧺ', 'ꧾ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꩺ'),
                    ('ꩾ', 'ꪯ'),
                    ('ꪱ', 'ꪱ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪽ'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫪ'),
                    ('ꫲ', 'ꫴ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯢ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('ｦ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍀'),
                    ('𐍂', '𐍉'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐐀', '𐒝'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '𐴣'),
                    ('𐵊', '𐵥'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀃', '𑀷'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂃', '𑂯'),
                    ('𑃐', '𑃨'),
                    ('𑄃', '𑄦'),
                    ('𑅄', '𑅄'),
                    ('𑅇', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('𑆃', '𑆲'),
                    ('𑇁', '𑇄'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈫'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '𑋞'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍡'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑐴'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '𑖮'),
                    ('𑗘', '𑗛'),
                    ('𑘀', '𑘯'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '𑚪'),
                    ('𑚸', '𑚸'),
                    ('𑜀', '𑜚'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '𑠫'),
                    ('𑢠', '𑣟'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧐'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧣'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨺', '𑨺'),
                    ('𑩐', '𑩐'),
                    ('𑩜', '𑪉'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰮'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶉'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻲'),
                    ('𑼂', '𑼂'),
                    ('𑼄', '𑼐'),
                    ('𑼒', '𑼳'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭀', '𖭃'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖽐'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓫'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞤀', '𞥃'),
                    ('𞥋', '𞥋'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const LETTER_NUMBER: &'static [(char, char)] = &[
                    ('ᛮ', 'ᛰ'),
                    ('Ⅰ', 'ↂ'),
                    ('ↅ', 'ↈ'),
                    ('〇', '〇'),
                    ('〡', '〩'),
                    ('〸', '〺'),
                    ('ꛦ', 'ꛯ'),
                    ('𐅀', '𐅴'),
                    ('𐍁', '𐍁'),
                    ('𐍊', '𐍊'),
                    ('𐏑', '𐏕'),
                    ('𒐀', '𒑮'),
                ];

                pub const LINE_SEPARATOR: &'static [(char, char)] =
                    &[('\u{2028}', '\u{2028}')];

                pub const LOWERCASE_LETTER: &'static [(char, char)] = &[
                    ('a', 'z'),
                    ('µ', 'µ'),
                    ('ß', 'ö'),
                    ('ø', 'ÿ'),
                    ('ā', 'ā'),
                    ('ă', 'ă'),
                    ('ą', 'ą'),
                    ('ć', 'ć'),
                    ('ĉ', 'ĉ'),
                    ('ċ', 'ċ'),
                    ('č', 'č'),
                    ('ď', 'ď'),
                    ('đ', 'đ'),
                    ('ē', 'ē'),
                    ('ĕ', 'ĕ'),
                    ('ė', 'ė'),
                    ('ę', 'ę'),
                    ('ě', 'ě'),
                    ('ĝ', 'ĝ'),
                    ('ğ', 'ğ'),
                    ('ġ', 'ġ'),
                    ('ģ', 'ģ'),
                    ('ĥ', 'ĥ'),
                    ('ħ', 'ħ'),
                    ('ĩ', 'ĩ'),
                    ('ī', 'ī'),
                    ('ĭ', 'ĭ'),
                    ('į', 'į'),
                    ('ı', 'ı'),
                    ('ĳ', 'ĳ'),
                    ('ĵ', 'ĵ'),
                    ('ķ', 'ĸ'),
                    ('ĺ', 'ĺ'),
                    ('ļ', 'ļ'),
                    ('ľ', 'ľ'),
                    ('ŀ', 'ŀ'),
                    ('ł', 'ł'),
                    ('ń', 'ń'),
                    ('ņ', 'ņ'),
                    ('ň', 'ŉ'),
                    ('ŋ', 'ŋ'),
                    ('ō', 'ō'),
                    ('ŏ', 'ŏ'),
                    ('ő', 'ő'),
                    ('œ', 'œ'),
                    ('ŕ', 'ŕ'),
                    ('ŗ', 'ŗ'),
                    ('ř', 'ř'),
                    ('ś', 'ś'),
                    ('ŝ', 'ŝ'),
                    ('ş', 'ş'),
                    ('š', 'š'),
                    ('ţ', 'ţ'),
                    ('ť', 'ť'),
                    ('ŧ', 'ŧ'),
                    ('ũ', 'ũ'),
                    ('ū', 'ū'),
                    ('ŭ', 'ŭ'),
                    ('ů', 'ů'),
                    ('ű', 'ű'),
                    ('ų', 'ų'),
                    ('ŵ', 'ŵ'),
                    ('ŷ', 'ŷ'),
                    ('ź', 'ź'),
                    ('ż', 'ż'),
                    ('ž', 'ƀ'),
                    ('ƃ', 'ƃ'),
                    ('ƅ', 'ƅ'),
                    ('ƈ', 'ƈ'),
                    ('ƌ', 'ƍ'),
                    ('ƒ', 'ƒ'),
                    ('ƕ', 'ƕ'),
                    ('ƙ', 'ƛ'),
                    ('ƞ', 'ƞ'),
                    ('ơ', 'ơ'),
                    ('ƣ', 'ƣ'),
                    ('ƥ', 'ƥ'),
                    ('ƨ', 'ƨ'),
                    ('ƪ', 'ƫ'),
                    ('ƭ', 'ƭ'),
                    ('ư', 'ư'),
                    ('ƴ', 'ƴ'),
                    ('ƶ', 'ƶ'),
                    ('ƹ', 'ƺ'),
                    ('ƽ', 'ƿ'),
                    ('ǆ', 'ǆ'),
                    ('ǉ', 'ǉ'),
                    ('ǌ', 'ǌ'),
                    ('ǎ', 'ǎ'),
                    ('ǐ', 'ǐ'),
                    ('ǒ', 'ǒ'),
                    ('ǔ', 'ǔ'),
                    ('ǖ', 'ǖ'),
                    ('ǘ', 'ǘ'),
                    ('ǚ', 'ǚ'),
                    ('ǜ', 'ǝ'),
                    ('ǟ', 'ǟ'),
                    ('ǡ', 'ǡ'),
                    ('ǣ', 'ǣ'),
                    ('ǥ', 'ǥ'),
                    ('ǧ', 'ǧ'),
                    ('ǩ', 'ǩ'),
                    ('ǫ', 'ǫ'),
                    ('ǭ', 'ǭ'),
                    ('ǯ', 'ǰ'),
                    ('ǳ', 'ǳ'),
                    ('ǵ', 'ǵ'),
                    ('ǹ', 'ǹ'),
                    ('ǻ', 'ǻ'),
                    ('ǽ', 'ǽ'),
                    ('ǿ', 'ǿ'),
                    ('ȁ', 'ȁ'),
                    ('ȃ', 'ȃ'),
                    ('ȅ', 'ȅ'),
                    ('ȇ', 'ȇ'),
                    ('ȉ', 'ȉ'),
                    ('ȋ', 'ȋ'),
                    ('ȍ', 'ȍ'),
                    ('ȏ', 'ȏ'),
                    ('ȑ', 'ȑ'),
                    ('ȓ', 'ȓ'),
                    ('ȕ', 'ȕ'),
                    ('ȗ', 'ȗ'),
                    ('ș', 'ș'),
                    ('ț', 'ț'),
                    ('ȝ', 'ȝ'),
                    ('ȟ', 'ȟ'),
                    ('ȡ', 'ȡ'),
                    ('ȣ', 'ȣ'),
                    ('ȥ', 'ȥ'),
                    ('ȧ', 'ȧ'),
                    ('ȩ', 'ȩ'),
                    ('ȫ', 'ȫ'),
                    ('ȭ', 'ȭ'),
                    ('ȯ', 'ȯ'),
                    ('ȱ', 'ȱ'),
                    ('ȳ', 'ȹ'),
                    ('ȼ', 'ȼ'),
                    ('ȿ', 'ɀ'),
                    ('ɂ', 'ɂ'),
                    ('ɇ', 'ɇ'),
                    ('ɉ', 'ɉ'),
                    ('ɋ', 'ɋ'),
                    ('ɍ', 'ɍ'),
                    ('ɏ', 'ʓ'),
                    ('ʕ', 'ʯ'),
                    ('ͱ', 'ͱ'),
                    ('ͳ', 'ͳ'),
                    ('ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('ΐ', 'ΐ'),
                    ('ά', 'ώ'),
                    ('ϐ', 'ϑ'),
                    ('ϕ', 'ϗ'),
                    ('ϙ', 'ϙ'),
                    ('ϛ', 'ϛ'),
                    ('ϝ', 'ϝ'),
                    ('ϟ', 'ϟ'),
                    ('ϡ', 'ϡ'),
                    ('ϣ', 'ϣ'),
                    ('ϥ', 'ϥ'),
                    ('ϧ', 'ϧ'),
                    ('ϩ', 'ϩ'),
                    ('ϫ', 'ϫ'),
                    ('ϭ', 'ϭ'),
                    ('ϯ', 'ϳ'),
                    ('ϵ', 'ϵ'),
                    ('ϸ', 'ϸ'),
                    ('ϻ', 'ϼ'),
                    ('а', 'џ'),
                    ('ѡ', 'ѡ'),
                    ('ѣ', 'ѣ'),
                    ('ѥ', 'ѥ'),
                    ('ѧ', 'ѧ'),
                    ('ѩ', 'ѩ'),
                    ('ѫ', 'ѫ'),
                    ('ѭ', 'ѭ'),
                    ('ѯ', 'ѯ'),
                    ('ѱ', 'ѱ'),
                    ('ѳ', 'ѳ'),
                    ('ѵ', 'ѵ'),
                    ('ѷ', 'ѷ'),
                    ('ѹ', 'ѹ'),
                    ('ѻ', 'ѻ'),
                    ('ѽ', 'ѽ'),
                    ('ѿ', 'ѿ'),
                    ('ҁ', 'ҁ'),
                    ('ҋ', 'ҋ'),
                    ('ҍ', 'ҍ'),
                    ('ҏ', 'ҏ'),
                    ('ґ', 'ґ'),
                    ('ғ', 'ғ'),
                    ('ҕ', 'ҕ'),
                    ('җ', 'җ'),
                    ('ҙ', 'ҙ'),
                    ('қ', 'қ'),
                    ('ҝ', 'ҝ'),
                    ('ҟ', 'ҟ'),
                    ('ҡ', 'ҡ'),
                    ('ң', 'ң'),
                    ('ҥ', 'ҥ'),
                    ('ҧ', 'ҧ'),
                    ('ҩ', 'ҩ'),
                    ('ҫ', 'ҫ'),
                    ('ҭ', 'ҭ'),
                    ('ү', 'ү'),
                    ('ұ', 'ұ'),
                    ('ҳ', 'ҳ'),
                    ('ҵ', 'ҵ'),
                    ('ҷ', 'ҷ'),
                    ('ҹ', 'ҹ'),
                    ('һ', 'һ'),
                    ('ҽ', 'ҽ'),
                    ('ҿ', 'ҿ'),
                    ('ӂ', 'ӂ'),
                    ('ӄ', 'ӄ'),
                    ('ӆ', 'ӆ'),
                    ('ӈ', 'ӈ'),
                    ('ӊ', 'ӊ'),
                    ('ӌ', 'ӌ'),
                    ('ӎ', 'ӏ'),
                    ('ӑ', 'ӑ'),
                    ('ӓ', 'ӓ'),
                    ('ӕ', 'ӕ'),
                    ('ӗ', 'ӗ'),
                    ('ә', 'ә'),
                    ('ӛ', 'ӛ'),
                    ('ӝ', 'ӝ'),
                    ('ӟ', 'ӟ'),
                    ('ӡ', 'ӡ'),
                    ('ӣ', 'ӣ'),
                    ('ӥ', 'ӥ'),
                    ('ӧ', 'ӧ'),
                    ('ө', 'ө'),
                    ('ӫ', 'ӫ'),
                    ('ӭ', 'ӭ'),
                    ('ӯ', 'ӯ'),
                    ('ӱ', 'ӱ'),
                    ('ӳ', 'ӳ'),
                    ('ӵ', 'ӵ'),
                    ('ӷ', 'ӷ'),
                    ('ӹ', 'ӹ'),
                    ('ӻ', 'ӻ'),
                    ('ӽ', 'ӽ'),
                    ('ӿ', 'ӿ'),
                    ('ԁ', 'ԁ'),
                    ('ԃ', 'ԃ'),
                    ('ԅ', 'ԅ'),
                    ('ԇ', 'ԇ'),
                    ('ԉ', 'ԉ'),
                    ('ԋ', 'ԋ'),
                    ('ԍ', 'ԍ'),
                    ('ԏ', 'ԏ'),
                    ('ԑ', 'ԑ'),
                    ('ԓ', 'ԓ'),
                    ('ԕ', 'ԕ'),
                    ('ԗ', 'ԗ'),
                    ('ԙ', 'ԙ'),
                    ('ԛ', 'ԛ'),
                    ('ԝ', 'ԝ'),
                    ('ԟ', 'ԟ'),
                    ('ԡ', 'ԡ'),
                    ('ԣ', 'ԣ'),
                    ('ԥ', 'ԥ'),
                    ('ԧ', 'ԧ'),
                    ('ԩ', 'ԩ'),
                    ('ԫ', 'ԫ'),
                    ('ԭ', 'ԭ'),
                    ('ԯ', 'ԯ'),
                    ('ՠ', 'ֈ'),
                    ('ა', 'ჺ'),
                    ('ჽ', 'ჿ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲈ'),
                    ('ᲊ', 'ᲊ'),
                    ('ᴀ', 'ᴫ'),
                    ('ᵫ', 'ᵷ'),
                    ('ᵹ', 'ᶚ'),
                    ('ḁ', 'ḁ'),
                    ('ḃ', 'ḃ'),
                    ('ḅ', 'ḅ'),
                    ('ḇ', 'ḇ'),
                    ('ḉ', 'ḉ'),
                    ('ḋ', 'ḋ'),
                    ('ḍ', 'ḍ'),
                    ('ḏ', 'ḏ'),
                    ('ḑ', 'ḑ'),
                    ('ḓ', 'ḓ'),
                    ('ḕ', 'ḕ'),
                    ('ḗ', 'ḗ'),
                    ('ḙ', 'ḙ'),
                    ('ḛ', 'ḛ'),
                    ('ḝ', 'ḝ'),
                    ('ḟ', 'ḟ'),
                    ('ḡ', 'ḡ'),
                    ('ḣ', 'ḣ'),
                    ('ḥ', 'ḥ'),
                    ('ḧ', 'ḧ'),
                    ('ḩ', 'ḩ'),
                    ('ḫ', 'ḫ'),
                    ('ḭ', 'ḭ'),
                    ('ḯ', 'ḯ'),
                    ('ḱ', 'ḱ'),
                    ('ḳ', 'ḳ'),
                    ('ḵ', 'ḵ'),
                    ('ḷ', 'ḷ'),
                    ('ḹ', 'ḹ'),
                    ('ḻ', 'ḻ'),
                    ('ḽ', 'ḽ'),
                    ('ḿ', 'ḿ'),
                    ('ṁ', 'ṁ'),
                    ('ṃ', 'ṃ'),
                    ('ṅ', 'ṅ'),
                    ('ṇ', 'ṇ'),
                    ('ṉ', 'ṉ'),
                    ('ṋ', 'ṋ'),
                    ('ṍ', 'ṍ'),
                    ('ṏ', 'ṏ'),
                    ('ṑ', 'ṑ'),
                    ('ṓ', 'ṓ'),
                    ('ṕ', 'ṕ'),
                    ('ṗ', 'ṗ'),
                    ('ṙ', 'ṙ'),
                    ('ṛ', 'ṛ'),
                    ('ṝ', 'ṝ'),
                    ('ṟ', 'ṟ'),
                    ('ṡ', 'ṡ'),
                    ('ṣ', 'ṣ'),
                    ('ṥ', 'ṥ'),
                    ('ṧ', 'ṧ'),
                    ('ṩ', 'ṩ'),
                    ('ṫ', 'ṫ'),
                    ('ṭ', 'ṭ'),
                    ('ṯ', 'ṯ'),
                    ('ṱ', 'ṱ'),
                    ('ṳ', 'ṳ'),
                    ('ṵ', 'ṵ'),
                    ('ṷ', 'ṷ'),
                    ('ṹ', 'ṹ'),
                    ('ṻ', 'ṻ'),
                    ('ṽ', 'ṽ'),
                    ('ṿ', 'ṿ'),
                    ('ẁ', 'ẁ'),
                    ('ẃ', 'ẃ'),
                    ('ẅ', 'ẅ'),
                    ('ẇ', 'ẇ'),
                    ('ẉ', 'ẉ'),
                    ('ẋ', 'ẋ'),
                    ('ẍ', 'ẍ'),
                    ('ẏ', 'ẏ'),
                    ('ẑ', 'ẑ'),
                    ('ẓ', 'ẓ'),
                    ('ẕ', 'ẝ'),
                    ('ẟ', 'ẟ'),
                    ('ạ', 'ạ'),
                    ('ả', 'ả'),
                    ('ấ', 'ấ'),
                    ('ầ', 'ầ'),
                    ('ẩ', 'ẩ'),
                    ('ẫ', 'ẫ'),
                    ('ậ', 'ậ'),
                    ('ắ', 'ắ'),
                    ('ằ', 'ằ'),
                    ('ẳ', 'ẳ'),
                    ('ẵ', 'ẵ'),
                    ('ặ', 'ặ'),
                    ('ẹ', 'ẹ'),
                    ('ẻ', 'ẻ'),
                    ('ẽ', 'ẽ'),
                    ('ế', 'ế'),
                    ('ề', 'ề'),
                    ('ể', 'ể'),
                    ('ễ', 'ễ'),
                    ('ệ', 'ệ'),
                    ('ỉ', 'ỉ'),
                    ('ị', 'ị'),
                    ('ọ', 'ọ'),
                    ('ỏ', 'ỏ'),
                    ('ố', 'ố'),
                    ('ồ', 'ồ'),
                    ('ổ', 'ổ'),
                    ('ỗ', 'ỗ'),
                    ('ộ', 'ộ'),
                    ('ớ', 'ớ'),
                    ('ờ', 'ờ'),
                    ('ở', 'ở'),
                    ('ỡ', 'ỡ'),
                    ('ợ', 'ợ'),
                    ('ụ', 'ụ'),
                    ('ủ', 'ủ'),
                    ('ứ', 'ứ'),
                    ('ừ', 'ừ'),
                    ('ử', 'ử'),
                    ('ữ', 'ữ'),
                    ('ự', 'ự'),
                    ('ỳ', 'ỳ'),
                    ('ỵ', 'ỵ'),
                    ('ỷ', 'ỷ'),
                    ('ỹ', 'ỹ'),
                    ('ỻ', 'ỻ'),
                    ('ỽ', 'ỽ'),
                    ('ỿ', 'ἇ'),
                    ('ἐ', 'ἕ'),
                    ('ἠ', 'ἧ'),
                    ('ἰ', 'ἷ'),
                    ('ὀ', 'ὅ'),
                    ('ὐ', 'ὗ'),
                    ('ὠ', 'ὧ'),
                    ('ὰ', 'ώ'),
                    ('ᾀ', 'ᾇ'),
                    ('ᾐ', 'ᾗ'),
                    ('ᾠ', 'ᾧ'),
                    ('ᾰ', 'ᾴ'),
                    ('ᾶ', 'ᾷ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῇ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'ῗ'),
                    ('ῠ', 'ῧ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῷ'),
                    ('ℊ', 'ℊ'),
                    ('ℎ', 'ℏ'),
                    ('ℓ', 'ℓ'),
                    ('ℯ', 'ℯ'),
                    ('ℴ', 'ℴ'),
                    ('ℹ', 'ℹ'),
                    ('ℼ', 'ℽ'),
                    ('ⅆ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('ↄ', 'ↄ'),
                    ('ⰰ', 'ⱟ'),
                    ('ⱡ', 'ⱡ'),
                    ('ⱥ', 'ⱦ'),
                    ('ⱨ', 'ⱨ'),
                    ('ⱪ', 'ⱪ'),
                    ('ⱬ', 'ⱬ'),
                    ('ⱱ', 'ⱱ'),
                    ('ⱳ', 'ⱴ'),
                    ('ⱶ', 'ⱻ'),
                    ('ⲁ', 'ⲁ'),
                    ('ⲃ', 'ⲃ'),
                    ('ⲅ', 'ⲅ'),
                    ('ⲇ', 'ⲇ'),
                    ('ⲉ', 'ⲉ'),
                    ('ⲋ', 'ⲋ'),
                    ('ⲍ', 'ⲍ'),
                    ('ⲏ', 'ⲏ'),
                    ('ⲑ', 'ⲑ'),
                    ('ⲓ', 'ⲓ'),
                    ('ⲕ', 'ⲕ'),
                    ('ⲗ', 'ⲗ'),
                    ('ⲙ', 'ⲙ'),
                    ('ⲛ', 'ⲛ'),
                    ('ⲝ', 'ⲝ'),
                    ('ⲟ', 'ⲟ'),
                    ('ⲡ', 'ⲡ'),
                    ('ⲣ', 'ⲣ'),
                    ('ⲥ', 'ⲥ'),
                    ('ⲧ', 'ⲧ'),
                    ('ⲩ', 'ⲩ'),
                    ('ⲫ', 'ⲫ'),
                    ('ⲭ', 'ⲭ'),
                    ('ⲯ', 'ⲯ'),
                    ('ⲱ', 'ⲱ'),
                    ('ⲳ', 'ⲳ'),
                    ('ⲵ', 'ⲵ'),
                    ('ⲷ', 'ⲷ'),
                    ('ⲹ', 'ⲹ'),
                    ('ⲻ', 'ⲻ'),
                    ('ⲽ', 'ⲽ'),
                    ('ⲿ', 'ⲿ'),
                    ('ⳁ', 'ⳁ'),
                    ('ⳃ', 'ⳃ'),
                    ('ⳅ', 'ⳅ'),
                    ('ⳇ', 'ⳇ'),
                    ('ⳉ', 'ⳉ'),
                    ('ⳋ', 'ⳋ'),
                    ('ⳍ', 'ⳍ'),
                    ('ⳏ', 'ⳏ'),
                    ('ⳑ', 'ⳑ'),
                    ('ⳓ', 'ⳓ'),
                    ('ⳕ', 'ⳕ'),
                    ('ⳗ', 'ⳗ'),
                    ('ⳙ', 'ⳙ'),
                    ('ⳛ', 'ⳛ'),
                    ('ⳝ', 'ⳝ'),
                    ('ⳟ', 'ⳟ'),
                    ('ⳡ', 'ⳡ'),
                    ('ⳣ', 'ⳤ'),
                    ('ⳬ', 'ⳬ'),
                    ('ⳮ', 'ⳮ'),
                    ('ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ꙁ', 'ꙁ'),
                    ('ꙃ', 'ꙃ'),
                    ('ꙅ', 'ꙅ'),
                    ('ꙇ', 'ꙇ'),
                    ('ꙉ', 'ꙉ'),
                    ('ꙋ', 'ꙋ'),
                    ('ꙍ', 'ꙍ'),
                    ('ꙏ', 'ꙏ'),
                    ('ꙑ', 'ꙑ'),
                    ('ꙓ', 'ꙓ'),
                    ('ꙕ', 'ꙕ'),
                    ('ꙗ', 'ꙗ'),
                    ('ꙙ', 'ꙙ'),
                    ('ꙛ', 'ꙛ'),
                    ('ꙝ', 'ꙝ'),
                    ('ꙟ', 'ꙟ'),
                    ('ꙡ', 'ꙡ'),
                    ('ꙣ', 'ꙣ'),
                    ('ꙥ', 'ꙥ'),
                    ('ꙧ', 'ꙧ'),
                    ('ꙩ', 'ꙩ'),
                    ('ꙫ', 'ꙫ'),
                    ('ꙭ', 'ꙭ'),
                    ('ꚁ', 'ꚁ'),
                    ('ꚃ', 'ꚃ'),
                    ('ꚅ', 'ꚅ'),
                    ('ꚇ', 'ꚇ'),
                    ('ꚉ', 'ꚉ'),
                    ('ꚋ', 'ꚋ'),
                    ('ꚍ', 'ꚍ'),
                    ('ꚏ', 'ꚏ'),
                    ('ꚑ', 'ꚑ'),
                    ('ꚓ', 'ꚓ'),
                    ('ꚕ', 'ꚕ'),
                    ('ꚗ', 'ꚗ'),
                    ('ꚙ', 'ꚙ'),
                    ('ꚛ', 'ꚛ'),
                    ('ꜣ', 'ꜣ'),
                    ('ꜥ', 'ꜥ'),
                    ('ꜧ', 'ꜧ'),
                    ('ꜩ', 'ꜩ'),
                    ('ꜫ', 'ꜫ'),
                    ('ꜭ', 'ꜭ'),
                    ('ꜯ', 'ꜱ'),
                    ('ꜳ', 'ꜳ'),
                    ('ꜵ', 'ꜵ'),
                    ('ꜷ', 'ꜷ'),
                    ('ꜹ', 'ꜹ'),
                    ('ꜻ', 'ꜻ'),
                    ('ꜽ', 'ꜽ'),
                    ('ꜿ', 'ꜿ'),
                    ('ꝁ', 'ꝁ'),
                    ('ꝃ', 'ꝃ'),
                    ('ꝅ', 'ꝅ'),
                    ('ꝇ', 'ꝇ'),
                    ('ꝉ', 'ꝉ'),
                    ('ꝋ', 'ꝋ'),
                    ('ꝍ', 'ꝍ'),
                    ('ꝏ', 'ꝏ'),
                    ('ꝑ', 'ꝑ'),
                    ('ꝓ', 'ꝓ'),
                    ('ꝕ', 'ꝕ'),
                    ('ꝗ', 'ꝗ'),
                    ('ꝙ', 'ꝙ'),
                    ('ꝛ', 'ꝛ'),
                    ('ꝝ', 'ꝝ'),
                    ('ꝟ', 'ꝟ'),
                    ('ꝡ', 'ꝡ'),
                    ('ꝣ', 'ꝣ'),
                    ('ꝥ', 'ꝥ'),
                    ('ꝧ', 'ꝧ'),
                    ('ꝩ', 'ꝩ'),
                    ('ꝫ', 'ꝫ'),
                    ('ꝭ', 'ꝭ'),
                    ('ꝯ', 'ꝯ'),
                    ('ꝱ', 'ꝸ'),
                    ('ꝺ', 'ꝺ'),
                    ('ꝼ', 'ꝼ'),
                    ('ꝿ', 'ꝿ'),
                    ('ꞁ', 'ꞁ'),
                    ('ꞃ', 'ꞃ'),
                    ('ꞅ', 'ꞅ'),
                    ('ꞇ', 'ꞇ'),
                    ('ꞌ', 'ꞌ'),
                    ('ꞎ', 'ꞎ'),
                    ('ꞑ', 'ꞑ'),
                    ('ꞓ', 'ꞕ'),
                    ('ꞗ', 'ꞗ'),
                    ('ꞙ', 'ꞙ'),
                    ('ꞛ', 'ꞛ'),
                    ('ꞝ', 'ꞝ'),
                    ('ꞟ', 'ꞟ'),
                    ('ꞡ', 'ꞡ'),
                    ('ꞣ', 'ꞣ'),
                    ('ꞥ', 'ꞥ'),
                    ('ꞧ', 'ꞧ'),
                    ('ꞩ', 'ꞩ'),
                    ('ꞯ', 'ꞯ'),
                    ('ꞵ', 'ꞵ'),
                    ('ꞷ', 'ꞷ'),
                    ('ꞹ', 'ꞹ'),
                    ('ꞻ', 'ꞻ'),
                    ('ꞽ', 'ꞽ'),
                    ('ꞿ', 'ꞿ'),
                    ('ꟁ', 'ꟁ'),
                    ('ꟃ', 'ꟃ'),
                    ('ꟈ', 'ꟈ'),
                    ('ꟊ', 'ꟊ'),
                    ('ꟍ', 'ꟍ'),
                    ('ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'ꟕ'),
                    ('ꟗ', 'ꟗ'),
                    ('ꟙ', 'ꟙ'),
                    ('ꟛ', 'ꟛ'),
                    ('ꟶ', 'ꟶ'),
                    ('ꟺ', 'ꟺ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭠ', 'ꭨ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('ａ', 'ｚ'),
                    ('𐐨', '𐑏'),
                    ('𐓘', '𐓻'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐳀', '𐳲'),
                    ('𐵰', '𐶅'),
                    ('𑣀', '𑣟'),
                    ('𖹠', '𖹿'),
                    ('𝐚', '𝐳'),
                    ('𝑎', '𝑔'),
                    ('𝑖', '𝑧'),
                    ('𝒂', '𝒛'),
                    ('𝒶', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝓏'),
                    ('𝓪', '𝔃'),
                    ('𝔞', '𝔷'),
                    ('𝕒', '𝕫'),
                    ('𝖆', '𝖟'),
                    ('𝖺', '𝗓'),
                    ('𝗮', '𝘇'),
                    ('𝘢', '𝘻'),
                    ('𝙖', '𝙯'),
                    ('𝚊', '𝚥'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛡'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜛'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝕'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞏'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟉'),
                    ('𝟋', '𝟋'),
                    ('𝼀', '𝼉'),
                    ('𝼋', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞤢', '𞥃'),
                ];

                pub const MARK: &'static [(char, char)] = &[
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{489}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', 'ः'),
                    ('\u{93a}', '\u{93c}'),
                    ('ा', 'ॏ'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', 'ঃ'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', 'ਃ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('\u{abc}', '\u{abc}'),
                    ('ા', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', 'ଃ'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3e}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', 'ಃ'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('ಾ', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('ೳ', 'ೳ'),
                    ('\u{d00}', 'ഃ'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d3e}', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', 'ඃ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', 'ෳ'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', '༿'),
                    ('\u{f71}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('ါ', '\u{103e}'),
                    ('ၖ', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('ၢ', 'ၤ'),
                    ('ၧ', 'ၭ'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{108d}'),
                    ('ႏ', 'ႏ'),
                    ('ႚ', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1715}'),
                    ('\u{1732}', '\u{1734}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('\u{1a17}', '\u{1a1b}'),
                    ('ᩕ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', 'ᬄ'),
                    ('\u{1b34}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', 'ᮂ'),
                    ('ᮡ', '\u{1bad}'),
                    ('\u{1be6}', '\u{1bf3}'),
                    ('ᰤ', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('᳷', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('ꠣ', 'ꠧ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꢀ', 'ꢁ'),
                    ('ꢴ', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a953}'),
                    ('\u{a980}', 'ꦃ'),
                    ('\u{a9b3}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', 'ꩍ'),
                    ('ꩻ', 'ꩽ'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('ꫫ', 'ꫯ'),
                    ('ꫵ', '\u{aaf6}'),
                    ('ꯣ', 'ꯪ'),
                    ('꯬', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('𑀀', '𑀂'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '𑂂'),
                    ('𑂰', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{11134}'),
                    ('𑅅', '𑅆'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '𑆂'),
                    ('𑆳', '\u{111c0}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇎', '\u{111cf}'),
                    ('𑈬', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112ea}'),
                    ('\u{11300}', '𑌃'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1133e}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍢', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113b8}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑐵', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b0}', '\u{114c3}'),
                    ('\u{115af}', '\u{115b5}'),
                    ('𑖸', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('𑘰', '\u{11640}'),
                    ('\u{116ab}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑠬', '\u{1183a}'),
                    ('\u{11930}', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{1193e}'),
                    ('𑥀', '𑥀'),
                    ('𑥂', '\u{11943}'),
                    ('𑧑', '\u{119d7}'),
                    ('\u{119da}', '\u{119e0}'),
                    ('𑧤', '𑧤'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '𑨹'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a99}'),
                    ('𑰯', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('𑶊', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '\u{11d97}'),
                    ('\u{11ef3}', '𑻶'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('𑼃', '𑼃'),
                    ('𑼴', '\u{11f3a}'),
                    ('𑼾', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('𖽑', '𖾇'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const MATH_SYMBOL: &'static [(char, char)] = &
                [
                    ('+', '+'),
                    ('<', '>'),
                    ('|', '|'),
                    ('~', '~'),
                    ('¬', '¬'),
                    ('±', '±'),
                    ('×', '×'),
                    ('÷', '÷'),
                    ('϶', '϶'),
                    ('؆', '؈'),
                    ('⁄', '⁄'),
                    ('⁒', '⁒'),
                    ('⁺', '⁼'),
                    ('₊', '₌'),
                    ('℘', '℘'),
                    ('⅀', '⅄'),
                    ('⅋', '⅋'),
                    ('←', '↔'),
                    ('↚', '↛'),
                    ('↠', '↠'),
                    ('↣', '↣'),
                    ('↦', '↦'),
                    ('↮', '↮'),
                    ('⇎', '⇏'),
                    ('⇒', '⇒'),
                    ('⇔', '⇔'),
                    ('⇴', '⋿'),
                    ('⌠', '⌡'),
                    ('⍼', '⍼'),
                    ('⎛', '⎳'),
                    ('⏜', '⏡'),
                    ('▷', '▷'),
                    ('◁', '◁'),
                    ('◸', '◿'),
                    ('♯', '♯'),
                    ('⟀', '⟄'),
                    ('⟇', '⟥'),
                    ('⟰', '⟿'),
                    ('⤀', '⦂'),
                    ('⦙', '⧗'),
                    ('⧜', '⧻'),
                    ('⧾', '⫿'),
                    ('⬰', '⭄'),
                    ('⭇', '⭌'),
                    ('﬩', '﬩'),
                    ('﹢', '﹢'),
                    ('﹤', '﹦'),
                    ('＋', '＋'),
                    ('＜', '＞'),
                    ('｜', '｜'),
                    ('～', '～'),
                    ('￢', '￢'),
                    ('￩', '￬'),
                    ('𐶎', '𐶏'),
                    ('𝛁', '𝛁'),
                    ('𝛛', '𝛛'),
                    ('𝛻', '𝛻'),
                    ('𝜕', '𝜕'),
                    ('𝜵', '𝜵'),
                    ('𝝏', '𝝏'),
                    ('𝝯', '𝝯'),
                    ('𝞉', '𝞉'),
                    ('𝞩', '𝞩'),
                    ('𝟃', '𝟃'),
                    ('𞻰', '𞻱'),
                ];

                pub const MODIFIER_LETTER: &'static [(char, char)] = &
                [
                    ('ʰ', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('ʹ', 'ʹ'),
                    ('ͺ', 'ͺ'),
                    ('ՙ', 'ՙ'),
                    ('ـ', 'ـ'),
                    ('ۥ', 'ۦ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('ࣉ', 'ࣉ'),
                    ('ॱ', 'ॱ'),
                    ('ๆ', 'ๆ'),
                    ('ໆ', 'ໆ'),
                    ('ჼ', 'ჼ'),
                    ('ៗ', 'ៗ'),
                    ('ᡃ', 'ᡃ'),
                    ('ᪧ', 'ᪧ'),
                    ('ᱸ', 'ᱽ'),
                    ('ᴬ', 'ᵪ'),
                    ('ᵸ', 'ᵸ'),
                    ('ᶛ', 'ᶿ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ⱼ', 'ⱽ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '々'),
                    ('〱', '〵'),
                    ('〻', '〻'),
                    ('ゝ', 'ゞ'),
                    ('ー', 'ヾ'),
                    ('ꀕ', 'ꀕ'),
                    ('ꓸ', 'ꓽ'),
                    ('ꘌ', 'ꘌ'),
                    ('ꙿ', 'ꙿ'),
                    ('ꚜ', 'ꚝ'),
                    ('ꜗ', 'ꜟ'),
                    ('ꝰ', 'ꝰ'),
                    ('ꞈ', 'ꞈ'),
                    ('ꟲ', 'ꟴ'),
                    ('ꟸ', 'ꟹ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧦ', 'ꧦ'),
                    ('ꩰ', 'ꩰ'),
                    ('ꫝ', 'ꫝ'),
                    ('ꫳ', 'ꫴ'),
                    ('ꭜ', 'ꭟ'),
                    ('ꭩ', 'ꭩ'),
                    ('ｰ', 'ｰ'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐵎', '𐵎'),
                    ('𐵯', '𐵯'),
                    ('𖭀', '𖭃'),
                    ('𖵀', '𖵂'),
                    ('𖵫', '𖵬'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𞀰', '𞁭'),
                    ('𞄷', '𞄽'),
                    ('𞓫', '𞓫'),
                    ('𞥋', '𞥋'),
                ];

                pub const MODIFIER_SYMBOL: &'static [(char, char)] = &
                [
                    ('^', '^'),
                    ('`', '`'),
                    ('¨', '¨'),
                    ('¯', '¯'),
                    ('´', '´'),
                    ('¸', '¸'),
                    ('˂', '˅'),
                    ('˒', '˟'),
                    ('˥', '˫'),
                    ('˭', '˭'),
                    ('˯', '˿'),
                    ('͵', '͵'),
                    ('΄', '΅'),
                    ('࢈', '࢈'),
                    ('᾽', '᾽'),
                    ('᾿', '῁'),
                    ('῍', '῏'),
                    ('῝', '῟'),
                    ('῭', '`'),
                    ('´', '῾'),
                    ('゛', '゜'),
                    ('꜀', '꜖'),
                    ('꜠', '꜡'),
                    ('꞉', '꞊'),
                    ('꭛', '꭛'),
                    ('꭪', '꭫'),
                    ('﮲', '﯂'),
                    ('＾', '＾'),
                    ('｀', '｀'),
                    ('￣', '￣'),
                    ('🏻', '🏿'),
                ];

                pub const NONSPACING_MARK: &'static [(char, char)] = &
                [
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{487}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', '\u{902}'),
                    ('\u{93a}', '\u{93a}'),
                    ('\u{93c}', '\u{93c}'),
                    ('\u{941}', '\u{948}'),
                    ('\u{94d}', '\u{94d}'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', '\u{981}'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9c1}', '\u{9c4}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', '\u{a02}'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('\u{a41}', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', '\u{a82}'),
                    ('\u{abc}', '\u{abc}'),
                    ('\u{ac1}', '\u{ac5}'),
                    ('\u{ac7}', '\u{ac8}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', '\u{b01}'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3f}', '\u{b3f}'),
                    ('\u{b41}', '\u{b44}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{b55}', '\u{b56}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bc0}', '\u{bc0}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{c00}', '\u{c00}'),
                    ('\u{c04}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', '\u{c40}'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', '\u{c81}'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('\u{cbf}', '\u{cbf}'),
                    ('\u{cc6}', '\u{cc6}'),
                    ('\u{ccc}', '\u{ccd}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('\u{d00}', '\u{d01}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d41}', '\u{d44}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', '\u{d81}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dd2}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('\u{f71}', '\u{f7e}'),
                    ('\u{f80}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('\u{102d}', '\u{1030}'),
                    ('\u{1032}', '\u{1037}'),
                    ('\u{1039}', '\u{103a}'),
                    ('\u{103d}', '\u{103e}'),
                    ('\u{1058}', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{1082}'),
                    ('\u{1085}', '\u{1086}'),
                    ('\u{108d}', '\u{108d}'),
                    ('\u{109d}', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1714}'),
                    ('\u{1732}', '\u{1733}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{17b7}', '\u{17bd}'),
                    ('\u{17c6}', '\u{17c6}'),
                    ('\u{17c9}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', '\u{1922}'),
                    ('\u{1927}', '\u{1928}'),
                    ('\u{1932}', '\u{1932}'),
                    ('\u{1939}', '\u{193b}'),
                    ('\u{1a17}', '\u{1a18}'),
                    ('\u{1a1b}', '\u{1a1b}'),
                    ('\u{1a56}', '\u{1a56}'),
                    ('\u{1a58}', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1a62}', '\u{1a62}'),
                    ('\u{1a65}', '\u{1a6c}'),
                    ('\u{1a73}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1abd}'),
                    ('\u{1abf}', '\u{1ace}'),
                    ('\u{1b00}', '\u{1b03}'),
                    ('\u{1b34}', '\u{1b34}'),
                    ('\u{1b36}', '\u{1b3a}'),
                    ('\u{1b3c}', '\u{1b3c}'),
                    ('\u{1b42}', '\u{1b42}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1b81}'),
                    ('\u{1ba2}', '\u{1ba5}'),
                    ('\u{1ba8}', '\u{1ba9}'),
                    ('\u{1bab}', '\u{1bad}'),
                    ('\u{1be6}', '\u{1be6}'),
                    ('\u{1be8}', '\u{1be9}'),
                    ('\u{1bed}', '\u{1bed}'),
                    ('\u{1bef}', '\u{1bf1}'),
                    ('\u{1c2c}', '\u{1c33}'),
                    ('\u{1c36}', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce0}'),
                    ('\u{1ce2}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{20d0}', '\u{20dc}'),
                    ('\u{20e1}', '\u{20e1}'),
                    ('\u{20e5}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302d}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a66f}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('\u{a825}', '\u{a826}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a951}'),
                    ('\u{a980}', '\u{a982}'),
                    ('\u{a9b3}', '\u{a9b3}'),
                    ('\u{a9b6}', '\u{a9b9}'),
                    ('\u{a9bc}', '\u{a9bd}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa2e}'),
                    ('\u{aa31}', '\u{aa32}'),
                    ('\u{aa35}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', '\u{aa4c}'),
                    ('\u{aa7c}', '\u{aa7c}'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('\u{aaec}', '\u{aaed}'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('\u{abe5}', '\u{abe5}'),
                    ('\u{abe8}', '\u{abe8}'),
                    ('\u{abed}', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('\u{11001}', '\u{11001}'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '\u{11081}'),
                    ('\u{110b3}', '\u{110b6}'),
                    ('\u{110b9}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{1112b}'),
                    ('\u{1112d}', '\u{11134}'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '\u{11181}'),
                    ('\u{111b6}', '\u{111be}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('\u{111cf}', '\u{111cf}'),
                    ('\u{1122f}', '\u{11231}'),
                    ('\u{11234}', '\u{11234}'),
                    ('\u{11236}', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112df}'),
                    ('\u{112e3}', '\u{112ea}'),
                    ('\u{11300}', '\u{11301}'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{11340}', '\u{11340}'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113bb}', '\u{113c0}'),
                    ('\u{113ce}', '\u{113ce}'),
                    ('\u{113d0}', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('\u{11438}', '\u{1143f}'),
                    ('\u{11442}', '\u{11444}'),
                    ('\u{11446}', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b3}', '\u{114b8}'),
                    ('\u{114ba}', '\u{114ba}'),
                    ('\u{114bf}', '\u{114c0}'),
                    ('\u{114c2}', '\u{114c3}'),
                    ('\u{115b2}', '\u{115b5}'),
                    ('\u{115bc}', '\u{115bd}'),
                    ('\u{115bf}', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('\u{11633}', '\u{1163a}'),
                    ('\u{1163d}', '\u{1163d}'),
                    ('\u{1163f}', '\u{11640}'),
                    ('\u{116ab}', '\u{116ab}'),
                    ('\u{116ad}', '\u{116ad}'),
                    ('\u{116b0}', '\u{116b5}'),
                    ('\u{116b7}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1171d}'),
                    ('\u{1171f}', '\u{1171f}'),
                    ('\u{11722}', '\u{11725}'),
                    ('\u{11727}', '\u{1172b}'),
                    ('\u{1182f}', '\u{11837}'),
                    ('\u{11839}', '\u{1183a}'),
                    ('\u{1193b}', '\u{1193c}'),
                    ('\u{1193e}', '\u{1193e}'),
                    ('\u{11943}', '\u{11943}'),
                    ('\u{119d4}', '\u{119d7}'),
                    ('\u{119da}', '\u{119db}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '\u{11a38}'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a56}'),
                    ('\u{11a59}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a96}'),
                    ('\u{11a98}', '\u{11a99}'),
                    ('\u{11c30}', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3d}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('\u{11caa}', '\u{11cb0}'),
                    ('\u{11cb2}', '\u{11cb3}'),
                    ('\u{11cb5}', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('\u{11d95}', '\u{11d95}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11ef3}', '\u{11ef4}'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('\u{11f36}', '\u{11f3a}'),
                    ('\u{11f40}', '\u{11f40}'),
                    ('\u{11f42}', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{16129}'),
                    ('\u{1612d}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d167}', '\u{1d169}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const NUMBER: &'static [(char, char)] = &
                [
                    ('0', '9'),
                    ('²', '³'),
                    ('¹', '¹'),
                    ('¼', '¾'),
                    ('٠', '٩'),
                    ('۰', '۹'),
                    ('߀', '߉'),
                    ('०', '९'),
                    ('০', '৯'),
                    ('৴', '৹'),
                    ('੦', '੯'),
                    ('૦', '૯'),
                    ('୦', '୯'),
                    ('୲', '୷'),
                    ('௦', '௲'),
                    ('౦', '౯'),
                    ('౸', '౾'),
                    ('೦', '೯'),
                    ('൘', '൞'),
                    ('൦', '൸'),
                    ('෦', '෯'),
                    ('๐', '๙'),
                    ('໐', '໙'),
                    ('༠', '༳'),
                    ('၀', '၉'),
                    ('႐', '႙'),
                    ('፩', '፼'),
                    ('ᛮ', 'ᛰ'),
                    ('០', '៩'),
                    ('៰', '៹'),
                    ('᠐', '᠙'),
                    ('᥆', '᥏'),
                    ('᧐', '᧚'),
                    ('᪀', '᪉'),
                    ('᪐', '᪙'),
                    ('᭐', '᭙'),
                    ('᮰', '᮹'),
                    ('᱀', '᱉'),
                    ('᱐', '᱙'),
                    ('⁰', '⁰'),
                    ('⁴', '⁹'),
                    ('₀', '₉'),
                    ('⅐', 'ↂ'),
                    ('ↅ', '↉'),
                    ('①', '⒛'),
                    ('⓪', '⓿'),
                    ('❶', '➓'),
                    ('⳽', '⳽'),
                    ('〇', '〇'),
                    ('〡', '〩'),
                    ('〸', '〺'),
                    ('㆒', '㆕'),
                    ('㈠', '㈩'),
                    ('㉈', '㉏'),
                    ('㉑', '㉟'),
                    ('㊀', '㊉'),
                    ('㊱', '㊿'),
                    ('꘠', '꘩'),
                    ('ꛦ', 'ꛯ'),
                    ('꠰', '꠵'),
                    ('꣐', '꣙'),
                    ('꤀', '꤉'),
                    ('꧐', '꧙'),
                    ('꧰', '꧹'),
                    ('꩐', '꩙'),
                    ('꯰', '꯹'),
                    ('０', '９'),
                    ('𐄇', '𐄳'),
                    ('𐅀', '𐅸'),
                    ('𐆊', '𐆋'),
                    ('𐋡', '𐋻'),
                    ('𐌠', '𐌣'),
                    ('𐍁', '𐍁'),
                    ('𐍊', '𐍊'),
                    ('𐏑', '𐏕'),
                    ('𐒠', '𐒩'),
                    ('𐡘', '𐡟'),
                    ('𐡹', '𐡿'),
                    ('𐢧', '𐢯'),
                    ('𐣻', '𐣿'),
                    ('𐤖', '𐤛'),
                    ('𐦼', '𐦽'),
                    ('𐧀', '𐧏'),
                    ('𐧒', '𐧿'),
                    ('𐩀', '𐩈'),
                    ('𐩽', '𐩾'),
                    ('𐪝', '𐪟'),
                    ('𐫫', '𐫯'),
                    ('𐭘', '𐭟'),
                    ('𐭸', '𐭿'),
                    ('𐮩', '𐮯'),
                    ('𐳺', '𐳿'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵉'),
                    ('𐹠', '𐹾'),
                    ('𐼝', '𐼦'),
                    ('𐽑', '𐽔'),
                    ('𐿅', '𐿋'),
                    ('𑁒', '𑁯'),
                    ('𑃰', '𑃹'),
                    ('𑄶', '𑄿'),
                    ('𑇐', '𑇙'),
                    ('𑇡', '𑇴'),
                    ('𑋰', '𑋹'),
                    ('𑑐', '𑑙'),
                    ('𑓐', '𑓙'),
                    ('𑙐', '𑙙'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜰', '𑜻'),
                    ('𑣠', '𑣲'),
                    ('𑥐', '𑥙'),
                    ('𑯰', '𑯹'),
                    ('𑱐', '𑱬'),
                    ('𑵐', '𑵙'),
                    ('𑶠', '𑶩'),
                    ('𑽐', '𑽙'),
                    ('𑿀', '𑿔'),
                    ('𒐀', '𒑮'),
                    ('𖄰', '𖄹'),
                    ('𖩠', '𖩩'),
                    ('𖫀', '𖫉'),
                    ('𖭐', '𖭙'),
                    ('𖭛', '𖭡'),
                    ('𖵰', '𖵹'),
                    ('𖺀', '𖺖'),
                    ('𜳰', '𜳹'),
                    ('𝋀', '𝋓'),
                    ('𝋠', '𝋳'),
                    ('𝍠', '𝍸'),
                    ('𝟎', '𝟿'),
                    ('𞅀', '𞅉'),
                    ('𞋰', '𞋹'),
                    ('𞓰', '𞓹'),
                    ('𞗱', '𞗺'),
                    ('𞣇', '𞣏'),
                    ('𞥐', '𞥙'),
                    ('𞱱', '𞲫'),
                    ('𞲭', '𞲯'),
                    ('𞲱', '𞲴'),
                    ('𞴁', '𞴭'),
                    ('𞴯', '𞴽'),
                    ('🄀', '🄌'),
                    ('🯰', '🯹'),
                ];

                pub const OPEN_PUNCTUATION: &'static [(char, char)] = &
                [
                    ('(', '('),
                    ('[', '['),
                    ('{', '{'),
                    ('༺', '༺'),
                    ('༼', '༼'),
                    ('᚛', '᚛'),
                    ('‚', '‚'),
                    ('„', '„'),
                    ('⁅', '⁅'),
                    ('⁽', '⁽'),
                    ('₍', '₍'),
                    ('⌈', '⌈'),
                    ('⌊', '⌊'),
                    ('〈', '〈'),
                    ('❨', '❨'),
                    ('❪', '❪'),
                    ('❬', '❬'),
                    ('❮', '❮'),
                    ('❰', '❰'),
                    ('❲', '❲'),
                    ('❴', '❴'),
                    ('⟅', '⟅'),
                    ('⟦', '⟦'),
                    ('⟨', '⟨'),
                    ('⟪', '⟪'),
                    ('⟬', '⟬'),
                    ('⟮', '⟮'),
                    ('⦃', '⦃'),
                    ('⦅', '⦅'),
                    ('⦇', '⦇'),
                    ('⦉', '⦉'),
                    ('⦋', '⦋'),
                    ('⦍', '⦍'),
                    ('⦏', '⦏'),
                    ('⦑', '⦑'),
                    ('⦓', '⦓'),
                    ('⦕', '⦕'),
                    ('⦗', '⦗'),
                    ('⧘', '⧘'),
                    ('⧚', '⧚'),
                    ('⧼', '⧼'),
                    ('⸢', '⸢'),
                    ('⸤', '⸤'),
                    ('⸦', '⸦'),
                    ('⸨', '⸨'),
                    ('⹂', '⹂'),
                    ('⹕', '⹕'),
                    ('⹗', '⹗'),
                    ('⹙', '⹙'),
                    ('⹛', '⹛'),
                    ('〈', '〈'),
                    ('《', '《'),
                    ('「', '「'),
                    ('『', '『'),
                    ('【', '【'),
                    ('〔', '〔'),
                    ('〖', '〖'),
                    ('〘', '〘'),
                    ('〚', '〚'),
                    ('〝', '〝'),
                    ('﴿', '﴿'),
                    ('︗', '︗'),
                    ('︵', '︵'),
                    ('︷', '︷'),
                    ('︹', '︹'),
                    ('︻', '︻'),
                    ('︽', '︽'),
                    ('︿', '︿'),
                    ('﹁', '﹁'),
                    ('﹃', '﹃'),
                    ('﹇', '﹇'),
                    ('﹙', '﹙'),
                    ('﹛', '﹛'),
                    ('﹝', '﹝'),
                    ('（', '（'),
                    ('［', '［'),
                    ('｛', '｛'),
                    ('｟', '｟'),
                    ('｢', '｢'),
                ];

                pub const OTHER: &'static [(char, char)] = &
                [
                    ('\0', '\u{1f}'),
                    ('\u{7f}', '\u{9f}'),
                    ('\u{ad}', '\u{ad}'),
                    ('\u{378}', '\u{379}'),
                    ('\u{380}', '\u{383}'),
                    ('\u{38b}', '\u{38b}'),
                    ('\u{38d}', '\u{38d}'),
                    ('\u{3a2}', '\u{3a2}'),
                    ('\u{530}', '\u{530}'),
                    ('\u{557}', '\u{558}'),
                    ('\u{58b}', '\u{58c}'),
                    ('\u{590}', '\u{590}'),
                    ('\u{5c8}', '\u{5cf}'),
                    ('\u{5eb}', '\u{5ee}'),
                    ('\u{5f5}', '\u{605}'),
                    ('\u{61c}', '\u{61c}'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('\u{70e}', '\u{70f}'),
                    ('\u{74b}', '\u{74c}'),
                    ('\u{7b2}', '\u{7bf}'),
                    ('\u{7fb}', '\u{7fc}'),
                    ('\u{82e}', '\u{82f}'),
                    ('\u{83f}', '\u{83f}'),
                    ('\u{85c}', '\u{85d}'),
                    ('\u{85f}', '\u{85f}'),
                    ('\u{86b}', '\u{86f}'),
                    ('\u{88f}', '\u{896}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('\u{984}', '\u{984}'),
                    ('\u{98d}', '\u{98e}'),
                    ('\u{991}', '\u{992}'),
                    ('\u{9a9}', '\u{9a9}'),
                    ('\u{9b1}', '\u{9b1}'),
                    ('\u{9b3}', '\u{9b5}'),
                    ('\u{9ba}', '\u{9bb}'),
                    ('\u{9c5}', '\u{9c6}'),
                    ('\u{9c9}', '\u{9ca}'),
                    ('\u{9cf}', '\u{9d6}'),
                    ('\u{9d8}', '\u{9db}'),
                    ('\u{9de}', '\u{9de}'),
                    ('\u{9e4}', '\u{9e5}'),
                    ('\u{9ff}', '\u{a00}'),
                    ('\u{a04}', '\u{a04}'),
                    ('\u{a0b}', '\u{a0e}'),
                    ('\u{a11}', '\u{a12}'),
                    ('\u{a29}', '\u{a29}'),
                    ('\u{a31}', '\u{a31}'),
                    ('\u{a34}', '\u{a34}'),
                    ('\u{a37}', '\u{a37}'),
                    ('\u{a3a}', '\u{a3b}'),
                    ('\u{a3d}', '\u{a3d}'),
                    ('\u{a43}', '\u{a46}'),
                    ('\u{a49}', '\u{a4a}'),
                    ('\u{a4e}', '\u{a50}'),
                    ('\u{a52}', '\u{a58}'),
                    ('\u{a5d}', '\u{a5d}'),
                    ('\u{a5f}', '\u{a65}'),
                    ('\u{a77}', '\u{a80}'),
                    ('\u{a84}', '\u{a84}'),
                    ('\u{a8e}', '\u{a8e}'),
                    ('\u{a92}', '\u{a92}'),
                    ('\u{aa9}', '\u{aa9}'),
                    ('\u{ab1}', '\u{ab1}'),
                    ('\u{ab4}', '\u{ab4}'),
                    ('\u{aba}', '\u{abb}'),
                    ('\u{ac6}', '\u{ac6}'),
                    ('\u{aca}', '\u{aca}'),
                    ('\u{ace}', '\u{acf}'),
                    ('\u{ad1}', '\u{adf}'),
                    ('\u{ae4}', '\u{ae5}'),
                    ('\u{af2}', '\u{af8}'),
                    ('\u{b00}', '\u{b00}'),
                    ('\u{b04}', '\u{b04}'),
                    ('\u{b0d}', '\u{b0e}'),
                    ('\u{b11}', '\u{b12}'),
                    ('\u{b29}', '\u{b29}'),
                    ('\u{b31}', '\u{b31}'),
                    ('\u{b34}', '\u{b34}'),
                    ('\u{b3a}', '\u{b3b}'),
                    ('\u{b45}', '\u{b46}'),
                    ('\u{b49}', '\u{b4a}'),
                    ('\u{b4e}', '\u{b54}'),
                    ('\u{b58}', '\u{b5b}'),
                    ('\u{b5e}', '\u{b5e}'),
                    ('\u{b64}', '\u{b65}'),
                    ('\u{b78}', '\u{b81}'),
                    ('\u{b84}', '\u{b84}'),
                    ('\u{b8b}', '\u{b8d}'),
                    ('\u{b91}', '\u{b91}'),
                    ('\u{b96}', '\u{b98}'),
                    ('\u{b9b}', '\u{b9b}'),
                    ('\u{b9d}', '\u{b9d}'),
                    ('\u{ba0}', '\u{ba2}'),
                    ('\u{ba5}', '\u{ba7}'),
                    ('\u{bab}', '\u{bad}'),
                    ('\u{bba}', '\u{bbd}'),
                    ('\u{bc3}', '\u{bc5}'),
                    ('\u{bc9}', '\u{bc9}'),
                    ('\u{bce}', '\u{bcf}'),
                    ('\u{bd1}', '\u{bd6}'),
                    ('\u{bd8}', '\u{be5}'),
                    ('\u{bfb}', '\u{bff}'),
                    ('\u{c0d}', '\u{c0d}'),
                    ('\u{c11}', '\u{c11}'),
                    ('\u{c29}', '\u{c29}'),
                    ('\u{c3a}', '\u{c3b}'),
                    ('\u{c45}', '\u{c45}'),
                    ('\u{c49}', '\u{c49}'),
                    ('\u{c4e}', '\u{c54}'),
                    ('\u{c57}', '\u{c57}'),
                    ('\u{c5b}', '\u{c5c}'),
                    ('\u{c5e}', '\u{c5f}'),
                    ('\u{c64}', '\u{c65}'),
                    ('\u{c70}', '\u{c76}'),
                    ('\u{c8d}', '\u{c8d}'),
                    ('\u{c91}', '\u{c91}'),
                    ('\u{ca9}', '\u{ca9}'),
                    ('\u{cb4}', '\u{cb4}'),
                    ('\u{cba}', '\u{cbb}'),
                    ('\u{cc5}', '\u{cc5}'),
                    ('\u{cc9}', '\u{cc9}'),
                    ('\u{cce}', '\u{cd4}'),
                    ('\u{cd7}', '\u{cdc}'),
                    ('\u{cdf}', '\u{cdf}'),
                    ('\u{ce4}', '\u{ce5}'),
                    ('\u{cf0}', '\u{cf0}'),
                    ('\u{cf4}', '\u{cff}'),
                    ('\u{d0d}', '\u{d0d}'),
                    ('\u{d11}', '\u{d11}'),
                    ('\u{d45}', '\u{d45}'),
                    ('\u{d49}', '\u{d49}'),
                    ('\u{d50}', '\u{d53}'),
                    ('\u{d64}', '\u{d65}'),
                    ('\u{d80}', '\u{d80}'),
                    ('\u{d84}', '\u{d84}'),
                    ('\u{d97}', '\u{d99}'),
                    ('\u{db2}', '\u{db2}'),
                    ('\u{dbc}', '\u{dbc}'),
                    ('\u{dbe}', '\u{dbf}'),
                    ('\u{dc7}', '\u{dc9}'),
                    ('\u{dcb}', '\u{dce}'),
                    ('\u{dd5}', '\u{dd5}'),
                    ('\u{dd7}', '\u{dd7}'),
                    ('\u{de0}', '\u{de5}'),
                    ('\u{df0}', '\u{df1}'),
                    ('\u{df5}', '\u{e00}'),
                    ('\u{e3b}', '\u{e3e}'),
                    ('\u{e5c}', '\u{e80}'),
                    ('\u{e83}', '\u{e83}'),
                    ('\u{e85}', '\u{e85}'),
                    ('\u{e8b}', '\u{e8b}'),
                    ('\u{ea4}', '\u{ea4}'),
                    ('\u{ea6}', '\u{ea6}'),
                    ('\u{ebe}', '\u{ebf}'),
                    ('\u{ec5}', '\u{ec5}'),
                    ('\u{ec7}', '\u{ec7}'),
                    ('\u{ecf}', '\u{ecf}'),
                    ('\u{eda}', '\u{edb}'),
                    ('\u{ee0}', '\u{eff}'),
                    ('\u{f48}', '\u{f48}'),
                    ('\u{f6d}', '\u{f70}'),
                    ('\u{f98}', '\u{f98}'),
                    ('\u{fbd}', '\u{fbd}'),
                    ('\u{fcd}', '\u{fcd}'),
                    ('\u{fdb}', '\u{fff}'),
                    ('\u{10c6}', '\u{10c6}'),
                    ('\u{10c8}', '\u{10cc}'),
                    ('\u{10ce}', '\u{10cf}'),
                    ('\u{1249}', '\u{1249}'),
                    ('\u{124e}', '\u{124f}'),
                    ('\u{1257}', '\u{1257}'),
                    ('\u{1259}', '\u{1259}'),
                    ('\u{125e}', '\u{125f}'),
                    ('\u{1289}', '\u{1289}'),
                    ('\u{128e}', '\u{128f}'),
                    ('\u{12b1}', '\u{12b1}'),
                    ('\u{12b6}', '\u{12b7}'),
                    ('\u{12bf}', '\u{12bf}'),
                    ('\u{12c1}', '\u{12c1}'),
                    ('\u{12c6}', '\u{12c7}'),
                    ('\u{12d7}', '\u{12d7}'),
                    ('\u{1311}', '\u{1311}'),
                    ('\u{1316}', '\u{1317}'),
                    ('\u{135b}', '\u{135c}'),
                    ('\u{137d}', '\u{137f}'),
                    ('\u{139a}', '\u{139f}'),
                    ('\u{13f6}', '\u{13f7}'),
                    ('\u{13fe}', '\u{13ff}'),
                    ('\u{169d}', '\u{169f}'),
                    ('\u{16f9}', '\u{16ff}'),
                    ('\u{1716}', '\u{171e}'),
                    ('\u{1737}', '\u{173f}'),
                    ('\u{1754}', '\u{175f}'),
                    ('\u{176d}', '\u{176d}'),
                    ('\u{1771}', '\u{1771}'),
                    ('\u{1774}', '\u{177f}'),
                    ('\u{17de}', '\u{17df}'),
                    ('\u{17ea}', '\u{17ef}'),
                    ('\u{17fa}', '\u{17ff}'),
                    ('\u{180e}', '\u{180e}'),
                    ('\u{181a}', '\u{181f}'),
                    ('\u{1879}', '\u{187f}'),
                    ('\u{18ab}', '\u{18af}'),
                    ('\u{18f6}', '\u{18ff}'),
                    ('\u{191f}', '\u{191f}'),
                    ('\u{192c}', '\u{192f}'),
                    ('\u{193c}', '\u{193f}'),
                    ('\u{1941}', '\u{1943}'),
                    ('\u{196e}', '\u{196f}'),
                    ('\u{1975}', '\u{197f}'),
                    ('\u{19ac}', '\u{19af}'),
                    ('\u{19ca}', '\u{19cf}'),
                    ('\u{19db}', '\u{19dd}'),
                    ('\u{1a1c}', '\u{1a1d}'),
                    ('\u{1a5f}', '\u{1a5f}'),
                    ('\u{1a7d}', '\u{1a7e}'),
                    ('\u{1a8a}', '\u{1a8f}'),
                    ('\u{1a9a}', '\u{1a9f}'),
                    ('\u{1aae}', '\u{1aaf}'),
                    ('\u{1acf}', '\u{1aff}'),
                    ('\u{1b4d}', '\u{1b4d}'),
                    ('\u{1bf4}', '\u{1bfb}'),
                    ('\u{1c38}', '\u{1c3a}'),
                    ('\u{1c4a}', '\u{1c4c}'),
                    ('\u{1c8b}', '\u{1c8f}'),
                    ('\u{1cbb}', '\u{1cbc}'),
                    ('\u{1cc8}', '\u{1ccf}'),
                    ('\u{1cfb}', '\u{1cff}'),
                    ('\u{1f16}', '\u{1f17}'),
                    ('\u{1f1e}', '\u{1f1f}'),
                    ('\u{1f46}', '\u{1f47}'),
                    ('\u{1f4e}', '\u{1f4f}'),
                    ('\u{1f58}', '\u{1f58}'),
                    ('\u{1f5a}', '\u{1f5a}'),
                    ('\u{1f5c}', '\u{1f5c}'),
                    ('\u{1f5e}', '\u{1f5e}'),
                    ('\u{1f7e}', '\u{1f7f}'),
                    ('\u{1fb5}', '\u{1fb5}'),
                    ('\u{1fc5}', '\u{1fc5}'),
                    ('\u{1fd4}', '\u{1fd5}'),
                    ('\u{1fdc}', '\u{1fdc}'),
                    ('\u{1ff0}', '\u{1ff1}'),
                    ('\u{1ff5}', '\u{1ff5}'),
                    ('\u{1fff}', '\u{1fff}'),
                    ('\u{200b}', '\u{200f}'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2060}', '\u{206f}'),
                    ('\u{2072}', '\u{2073}'),
                    ('\u{208f}', '\u{208f}'),
                    ('\u{209d}', '\u{209f}'),
                    ('\u{20c1}', '\u{20cf}'),
                    ('\u{20f1}', '\u{20ff}'),
                    ('\u{218c}', '\u{218f}'),
                    ('\u{242a}', '\u{243f}'),
                    ('\u{244b}', '\u{245f}'),
                    ('\u{2b74}', '\u{2b75}'),
                    ('\u{2b96}', '\u{2b96}'),
                    ('\u{2cf4}', '\u{2cf8}'),
                    ('\u{2d26}', '\u{2d26}'),
                    ('\u{2d28}', '\u{2d2c}'),
                    ('\u{2d2e}', '\u{2d2f}'),
                    ('\u{2d68}', '\u{2d6e}'),
                    ('\u{2d71}', '\u{2d7e}'),
                    ('\u{2d97}', '\u{2d9f}'),
                    ('\u{2da7}', '\u{2da7}'),
                    ('\u{2daf}', '\u{2daf}'),
                    ('\u{2db7}', '\u{2db7}'),
                    ('\u{2dbf}', '\u{2dbf}'),
                    ('\u{2dc7}', '\u{2dc7}'),
                    ('\u{2dcf}', '\u{2dcf}'),
                    ('\u{2dd7}', '\u{2dd7}'),
                    ('\u{2ddf}', '\u{2ddf}'),
                    ('\u{2e5e}', '\u{2e7f}'),
                    ('\u{2e9a}', '\u{2e9a}'),
                    ('\u{2ef4}', '\u{2eff}'),
                    ('\u{2fd6}', '\u{2fef}'),
                    ('\u{3040}', '\u{3040}'),
                    ('\u{3097}', '\u{3098}'),
                    ('\u{3100}', '\u{3104}'),
                    ('\u{3130}', '\u{3130}'),
                    ('\u{318f}', '\u{318f}'),
                    ('\u{31e6}', '\u{31ee}'),
                    ('\u{321f}', '\u{321f}'),
                    ('\u{a48d}', '\u{a48f}'),
                    ('\u{a4c7}', '\u{a4cf}'),
                    ('\u{a62c}', '\u{a63f}'),
                    ('\u{a6f8}', '\u{a6ff}'),
                    ('\u{a7ce}', '\u{a7cf}'),
                    ('\u{a7d2}', '\u{a7d2}'),
                    ('\u{a7d4}', '\u{a7d4}'),
                    ('\u{a7dd}', '\u{a7f1}'),
                    ('\u{a82d}', '\u{a82f}'),
                    ('\u{a83a}', '\u{a83f}'),
                    ('\u{a878}', '\u{a87f}'),
                    ('\u{a8c6}', '\u{a8cd}'),
                    ('\u{a8da}', '\u{a8df}'),
                    ('\u{a954}', '\u{a95e}'),
                    ('\u{a97d}', '\u{a97f}'),
                    ('\u{a9ce}', '\u{a9ce}'),
                    ('\u{a9da}', '\u{a9dd}'),
                    ('\u{a9ff}', '\u{a9ff}'),
                    ('\u{aa37}', '\u{aa3f}'),
                    ('\u{aa4e}', '\u{aa4f}'),
                    ('\u{aa5a}', '\u{aa5b}'),
                    ('\u{aac3}', '\u{aada}'),
                    ('\u{aaf7}', '\u{ab00}'),
                    ('\u{ab07}', '\u{ab08}'),
                    ('\u{ab0f}', '\u{ab10}'),
                    ('\u{ab17}', '\u{ab1f}'),
                    ('\u{ab27}', '\u{ab27}'),
                    ('\u{ab2f}', '\u{ab2f}'),
                    ('\u{ab6c}', '\u{ab6f}'),
                    ('\u{abee}', '\u{abef}'),
                    ('\u{abfa}', '\u{abff}'),
                    ('\u{d7a4}', '\u{d7af}'),
                    ('\u{d7c7}', '\u{d7ca}'),
                    ('\u{d7fc}', '\u{f8ff}'),
                    ('\u{fa6e}', '\u{fa6f}'),
                    ('\u{fada}', '\u{faff}'),
                    ('\u{fb07}', '\u{fb12}'),
                    ('\u{fb18}', '\u{fb1c}'),
                    ('\u{fb37}', '\u{fb37}'),
                    ('\u{fb3d}', '\u{fb3d}'),
                    ('\u{fb3f}', '\u{fb3f}'),
                    ('\u{fb42}', '\u{fb42}'),
                    ('\u{fb45}', '\u{fb45}'),
                    ('\u{fbc3}', '\u{fbd2}'),
                    ('\u{fd90}', '\u{fd91}'),
                    ('\u{fdc8}', '\u{fdce}'),
                    ('\u{fdd0}', '\u{fdef}'),
                    ('\u{fe1a}', '\u{fe1f}'),
                    ('\u{fe53}', '\u{fe53}'),
                    ('\u{fe67}', '\u{fe67}'),
                    ('\u{fe6c}', '\u{fe6f}'),
                    ('\u{fe75}', '\u{fe75}'),
                    ('\u{fefd}', '\u{ff00}'),
                    ('\u{ffbf}', '\u{ffc1}'),
                    ('\u{ffc8}', '\u{ffc9}'),
                    ('\u{ffd0}', '\u{ffd1}'),
                    ('\u{ffd8}', '\u{ffd9}'),
                    ('\u{ffdd}', '\u{ffdf}'),
                    ('\u{ffe7}', '\u{ffe7}'),
                    ('\u{ffef}', '\u{fffb}'),
                    ('\u{fffe}', '\u{ffff}'),
                    ('\u{1000c}', '\u{1000c}'),
                    ('\u{10027}', '\u{10027}'),
                    ('\u{1003b}', '\u{1003b}'),
                    ('\u{1003e}', '\u{1003e}'),
                    ('\u{1004e}', '\u{1004f}'),
                    ('\u{1005e}', '\u{1007f}'),
                    ('\u{100fb}', '\u{100ff}'),
                    ('\u{10103}', '\u{10106}'),
                    ('\u{10134}', '\u{10136}'),
                    ('\u{1018f}', '\u{1018f}'),
                    ('\u{1019d}', '\u{1019f}'),
                    ('\u{101a1}', '\u{101cf}'),
                    ('\u{101fe}', '\u{1027f}'),
                    ('\u{1029d}', '\u{1029f}'),
                    ('\u{102d1}', '\u{102df}'),
                    ('\u{102fc}', '\u{102ff}'),
                    ('\u{10324}', '\u{1032c}'),
                    ('\u{1034b}', '\u{1034f}'),
                    ('\u{1037b}', '\u{1037f}'),
                    ('\u{1039e}', '\u{1039e}'),
                    ('\u{103c4}', '\u{103c7}'),
                    ('\u{103d6}', '\u{103ff}'),
                    ('\u{1049e}', '\u{1049f}'),
                    ('\u{104aa}', '\u{104af}'),
                    ('\u{104d4}', '\u{104d7}'),
                    ('\u{104fc}', '\u{104ff}'),
                    ('\u{10528}', '\u{1052f}'),
                    ('\u{10564}', '\u{1056e}'),
                    ('\u{1057b}', '\u{1057b}'),
                    ('\u{1058b}', '\u{1058b}'),
                    ('\u{10593}', '\u{10593}'),
                    ('\u{10596}', '\u{10596}'),
                    ('\u{105a2}', '\u{105a2}'),
                    ('\u{105b2}', '\u{105b2}'),
                    ('\u{105ba}', '\u{105ba}'),
                    ('\u{105bd}', '\u{105bf}'),
                    ('\u{105f4}', '\u{105ff}'),
                    ('\u{10737}', '\u{1073f}'),
                    ('\u{10756}', '\u{1075f}'),
                    ('\u{10768}', '\u{1077f}'),
                    ('\u{10786}', '\u{10786}'),
                    ('\u{107b1}', '\u{107b1}'),
                    ('\u{107bb}', '\u{107ff}'),
                    ('\u{10806}', '\u{10807}'),
                    ('\u{10809}', '\u{10809}'),
                    ('\u{10836}', '\u{10836}'),
                    ('\u{10839}', '\u{1083b}'),
                    ('\u{1083d}', '\u{1083e}'),
                    ('\u{10856}', '\u{10856}'),
                    ('\u{1089f}', '\u{108a6}'),
                    ('\u{108b0}', '\u{108df}'),
                    ('\u{108f3}', '\u{108f3}'),
                    ('\u{108f6}', '\u{108fa}'),
                    ('\u{1091c}', '\u{1091e}'),
                    ('\u{1093a}', '\u{1093e}'),
                    ('\u{10940}', '\u{1097f}'),
                    ('\u{109b8}', '\u{109bb}'),
                    ('\u{109d0}', '\u{109d1}'),
                    ('\u{10a04}', '\u{10a04}'),
                    ('\u{10a07}', '\u{10a0b}'),
                    ('\u{10a14}', '\u{10a14}'),
                    ('\u{10a18}', '\u{10a18}'),
                    ('\u{10a36}', '\u{10a37}'),
                    ('\u{10a3b}', '\u{10a3e}'),
                    ('\u{10a49}', '\u{10a4f}'),
                    ('\u{10a59}', '\u{10a5f}'),
                    ('\u{10aa0}', '\u{10abf}'),
                    ('\u{10ae7}', '\u{10aea}'),
                    ('\u{10af7}', '\u{10aff}'),
                    ('\u{10b36}', '\u{10b38}'),
                    ('\u{10b56}', '\u{10b57}'),
                    ('\u{10b73}', '\u{10b77}'),
                    ('\u{10b92}', '\u{10b98}'),
                    ('\u{10b9d}', '\u{10ba8}'),
                    ('\u{10bb0}', '\u{10bff}'),
                    ('\u{10c49}', '\u{10c7f}'),
                    ('\u{10cb3}', '\u{10cbf}'),
                    ('\u{10cf3}', '\u{10cf9}'),
                    ('\u{10d28}', '\u{10d2f}'),
                    ('\u{10d3a}', '\u{10d3f}'),
                    ('\u{10d66}', '\u{10d68}'),
                    ('\u{10d86}', '\u{10d8d}'),
                    ('\u{10d90}', '\u{10e5f}'),
                    ('\u{10e7f}', '\u{10e7f}'),
                    ('\u{10eaa}', '\u{10eaa}'),
                    ('\u{10eae}', '\u{10eaf}'),
                    ('\u{10eb2}', '\u{10ec1}'),
                    ('\u{10ec5}', '\u{10efb}'),
                    ('\u{10f28}', '\u{10f2f}'),
                    ('\u{10f5a}', '\u{10f6f}'),
                    ('\u{10f8a}', '\u{10faf}'),
                    ('\u{10fcc}', '\u{10fdf}'),
                    ('\u{10ff7}', '\u{10fff}'),
                    ('\u{1104e}', '\u{11051}'),
                    ('\u{11076}', '\u{1107e}'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110c3}', '\u{110cf}'),
                    ('\u{110e9}', '\u{110ef}'),
                    ('\u{110fa}', '\u{110ff}'),
                    ('\u{11135}', '\u{11135}'),
                    ('\u{11148}', '\u{1114f}'),
                    ('\u{11177}', '\u{1117f}'),
                    ('\u{111e0}', '\u{111e0}'),
                    ('\u{111f5}', '\u{111ff}'),
                    ('\u{11212}', '\u{11212}'),
                    ('\u{11242}', '\u{1127f}'),
                    ('\u{11287}', '\u{11287}'),
                    ('\u{11289}', '\u{11289}'),
                    ('\u{1128e}', '\u{1128e}'),
                    ('\u{1129e}', '\u{1129e}'),
                    ('\u{112aa}', '\u{112af}'),
                    ('\u{112eb}', '\u{112ef}'),
                    ('\u{112fa}', '\u{112ff}'),
                    ('\u{11304}', '\u{11304}'),
                    ('\u{1130d}', '\u{1130e}'),
                    ('\u{11311}', '\u{11312}'),
                    ('\u{11329}', '\u{11329}'),
                    ('\u{11331}', '\u{11331}'),
                    ('\u{11334}', '\u{11334}'),
                    ('\u{1133a}', '\u{1133a}'),
                    ('\u{11345}', '\u{11346}'),
                    ('\u{11349}', '\u{1134a}'),
                    ('\u{1134e}', '\u{1134f}'),
                    ('\u{11351}', '\u{11356}'),
                    ('\u{11358}', '\u{1135c}'),
                    ('\u{11364}', '\u{11365}'),
                    ('\u{1136d}', '\u{1136f}'),
                    ('\u{11375}', '\u{1137f}'),
                    ('\u{1138a}', '\u{1138a}'),
                    ('\u{1138c}', '\u{1138d}'),
                    ('\u{1138f}', '\u{1138f}'),
                    ('\u{113b6}', '\u{113b6}'),
                    ('\u{113c1}', '\u{113c1}'),
                    ('\u{113c3}', '\u{113c4}'),
                    ('\u{113c6}', '\u{113c6}'),
                    ('\u{113cb}', '\u{113cb}'),
                    ('\u{113d6}', '\u{113d6}'),
                    ('\u{113d9}', '\u{113e0}'),
                    ('\u{113e3}', '\u{113ff}'),
                    ('\u{1145c}', '\u{1145c}'),
                    ('\u{11462}', '\u{1147f}'),
                    ('\u{114c8}', '\u{114cf}'),
                    ('\u{114da}', '\u{1157f}'),
                    ('\u{115b6}', '\u{115b7}'),
                    ('\u{115de}', '\u{115ff}'),
                    ('\u{11645}', '\u{1164f}'),
                    ('\u{1165a}', '\u{1165f}'),
                    ('\u{1166d}', '\u{1167f}'),
                    ('\u{116ba}', '\u{116bf}'),
                    ('\u{116ca}', '\u{116cf}'),
                    ('\u{116e4}', '\u{116ff}'),
                    ('\u{1171b}', '\u{1171c}'),
                    ('\u{1172c}', '\u{1172f}'),
                    ('\u{11747}', '\u{117ff}'),
                    ('\u{1183c}', '\u{1189f}'),
                    ('\u{118f3}', '\u{118fe}'),
                    ('\u{11907}', '\u{11908}'),
                    ('\u{1190a}', '\u{1190b}'),
                    ('\u{11914}', '\u{11914}'),
                    ('\u{11917}', '\u{11917}'),
                    ('\u{11936}', '\u{11936}'),
                    ('\u{11939}', '\u{1193a}'),
                    ('\u{11947}', '\u{1194f}'),
                    ('\u{1195a}', '\u{1199f}'),
                    ('\u{119a8}', '\u{119a9}'),
                    ('\u{119d8}', '\u{119d9}'),
                    ('\u{119e5}', '\u{119ff}'),
                    ('\u{11a48}', '\u{11a4f}'),
                    ('\u{11aa3}', '\u{11aaf}'),
                    ('\u{11af9}', '\u{11aff}'),
                    ('\u{11b0a}', '\u{11bbf}'),
                    ('\u{11be2}', '\u{11bef}'),
                    ('\u{11bfa}', '\u{11bff}'),
                    ('\u{11c09}', '\u{11c09}'),
                    ('\u{11c37}', '\u{11c37}'),
                    ('\u{11c46}', '\u{11c4f}'),
                    ('\u{11c6d}', '\u{11c6f}'),
                    ('\u{11c90}', '\u{11c91}'),
                    ('\u{11ca8}', '\u{11ca8}'),
                    ('\u{11cb7}', '\u{11cff}'),
                    ('\u{11d07}', '\u{11d07}'),
                    ('\u{11d0a}', '\u{11d0a}'),
                    ('\u{11d37}', '\u{11d39}'),
                    ('\u{11d3b}', '\u{11d3b}'),
                    ('\u{11d3e}', '\u{11d3e}'),
                    ('\u{11d48}', '\u{11d4f}'),
                    ('\u{11d5a}', '\u{11d5f}'),
                    ('\u{11d66}', '\u{11d66}'),
                    ('\u{11d69}', '\u{11d69}'),
                    ('\u{11d8f}', '\u{11d8f}'),
                    ('\u{11d92}', '\u{11d92}'),
                    ('\u{11d99}', '\u{11d9f}'),
                    ('\u{11daa}', '\u{11edf}'),
                    ('\u{11ef9}', '\u{11eff}'),
                    ('\u{11f11}', '\u{11f11}'),
                    ('\u{11f3b}', '\u{11f3d}'),
                    ('\u{11f5b}', '\u{11faf}'),
                    ('\u{11fb1}', '\u{11fbf}'),
                    ('\u{11ff2}', '\u{11ffe}'),
                    ('\u{1239a}', '\u{123ff}'),
                    ('\u{1246f}', '\u{1246f}'),
                    ('\u{12475}', '\u{1247f}'),
                    ('\u{12544}', '\u{12f8f}'),
                    ('\u{12ff3}', '\u{12fff}'),
                    ('\u{13430}', '\u{1343f}'),
                    ('\u{13456}', '\u{1345f}'),
                    ('\u{143fb}', '\u{143ff}'),
                    ('\u{14647}', '\u{160ff}'),
                    ('\u{1613a}', '\u{167ff}'),
                    ('\u{16a39}', '\u{16a3f}'),
                    ('\u{16a5f}', '\u{16a5f}'),
                    ('\u{16a6a}', '\u{16a6d}'),
                    ('\u{16abf}', '\u{16abf}'),
                    ('\u{16aca}', '\u{16acf}'),
                    ('\u{16aee}', '\u{16aef}'),
                    ('\u{16af6}', '\u{16aff}'),
                    ('\u{16b46}', '\u{16b4f}'),
                    ('\u{16b5a}', '\u{16b5a}'),
                    ('\u{16b62}', '\u{16b62}'),
                    ('\u{16b78}', '\u{16b7c}'),
                    ('\u{16b90}', '\u{16d3f}'),
                    ('\u{16d7a}', '\u{16e3f}'),
                    ('\u{16e9b}', '\u{16eff}'),
                    ('\u{16f4b}', '\u{16f4e}'),
                    ('\u{16f88}', '\u{16f8e}'),
                    ('\u{16fa0}', '\u{16fdf}'),
                    ('\u{16fe5}', '\u{16fef}'),
                    ('\u{16ff2}', '\u{16fff}'),
                    ('\u{187f8}', '\u{187ff}'),
                    ('\u{18cd6}', '\u{18cfe}'),
                    ('\u{18d09}', '\u{1afef}'),
                    ('\u{1aff4}', '\u{1aff4}'),
                    ('\u{1affc}', '\u{1affc}'),
                    ('\u{1afff}', '\u{1afff}'),
                    ('\u{1b123}', '\u{1b131}'),
                    ('\u{1b133}', '\u{1b14f}'),
                    ('\u{1b153}', '\u{1b154}'),
                    ('\u{1b156}', '\u{1b163}'),
                    ('\u{1b168}', '\u{1b16f}'),
                    ('\u{1b2fc}', '\u{1bbff}'),
                    ('\u{1bc6b}', '\u{1bc6f}'),
                    ('\u{1bc7d}', '\u{1bc7f}'),
                    ('\u{1bc89}', '\u{1bc8f}'),
                    ('\u{1bc9a}', '\u{1bc9b}'),
                    ('\u{1bca0}', '\u{1cbff}'),
                    ('\u{1ccfa}', '\u{1ccff}'),
                    ('\u{1ceb4}', '\u{1ceff}'),
                    ('\u{1cf2e}', '\u{1cf2f}'),
                    ('\u{1cf47}', '\u{1cf4f}'),
                    ('\u{1cfc4}', '\u{1cfff}'),
                    ('\u{1d0f6}', '\u{1d0ff}'),
                    ('\u{1d127}', '\u{1d128}'),
                    ('\u{1d173}', '\u{1d17a}'),
                    ('\u{1d1eb}', '\u{1d1ff}'),
                    ('\u{1d246}', '\u{1d2bf}'),
                    ('\u{1d2d4}', '\u{1d2df}'),
                    ('\u{1d2f4}', '\u{1d2ff}'),
                    ('\u{1d357}', '\u{1d35f}'),
                    ('\u{1d379}', '\u{1d3ff}'),
                    ('\u{1d455}', '\u{1d455}'),
                    ('\u{1d49d}', '\u{1d49d}'),
                    ('\u{1d4a0}', '\u{1d4a1}'),
                    ('\u{1d4a3}', '\u{1d4a4}'),
                    ('\u{1d4a7}', '\u{1d4a8}'),
                    ('\u{1d4ad}', '\u{1d4ad}'),
                    ('\u{1d4ba}', '\u{1d4ba}'),
                    ('\u{1d4bc}', '\u{1d4bc}'),
                    ('\u{1d4c4}', '\u{1d4c4}'),
                    ('\u{1d506}', '\u{1d506}'),
                    ('\u{1d50b}', '\u{1d50c}'),
                    ('\u{1d515}', '\u{1d515}'),
                    ('\u{1d51d}', '\u{1d51d}'),
                    ('\u{1d53a}', '\u{1d53a}'),
                    ('\u{1d53f}', '\u{1d53f}'),
                    ('\u{1d545}', '\u{1d545}'),
                    ('\u{1d547}', '\u{1d549}'),
                    ('\u{1d551}', '\u{1d551}'),
                    ('\u{1d6a6}', '\u{1d6a7}'),
                    ('\u{1d7cc}', '\u{1d7cd}'),
                    ('\u{1da8c}', '\u{1da9a}'),
                    ('\u{1daa0}', '\u{1daa0}'),
                    ('\u{1dab0}', '\u{1deff}'),
                    ('\u{1df1f}', '\u{1df24}'),
                    ('\u{1df2b}', '\u{1dfff}'),
                    ('\u{1e007}', '\u{1e007}'),
                    ('\u{1e019}', '\u{1e01a}'),
                    ('\u{1e022}', '\u{1e022}'),
                    ('\u{1e025}', '\u{1e025}'),
                    ('\u{1e02b}', '\u{1e02f}'),
                    ('\u{1e06e}', '\u{1e08e}'),
                    ('\u{1e090}', '\u{1e0ff}'),
                    ('\u{1e12d}', '\u{1e12f}'),
                    ('\u{1e13e}', '\u{1e13f}'),
                    ('\u{1e14a}', '\u{1e14d}'),
                    ('\u{1e150}', '\u{1e28f}'),
                    ('\u{1e2af}', '\u{1e2bf}'),
                    ('\u{1e2fa}', '\u{1e2fe}'),
                    ('\u{1e300}', '\u{1e4cf}'),
                    ('\u{1e4fa}', '\u{1e5cf}'),
                    ('\u{1e5fb}', '\u{1e5fe}'),
                    ('\u{1e600}', '\u{1e7df}'),
                    ('\u{1e7e7}', '\u{1e7e7}'),
                    ('\u{1e7ec}', '\u{1e7ec}'),
                    ('\u{1e7ef}', '\u{1e7ef}'),
                    ('\u{1e7ff}', '\u{1e7ff}'),
                    ('\u{1e8c5}', '\u{1e8c6}'),
                    ('\u{1e8d7}', '\u{1e8ff}'),
                    ('\u{1e94c}', '\u{1e94f}'),
                    ('\u{1e95a}', '\u{1e95d}'),
                    ('\u{1e960}', '\u{1ec70}'),
                    ('\u{1ecb5}', '\u{1ed00}'),
                    ('\u{1ed3e}', '\u{1edff}'),
                    ('\u{1ee04}', '\u{1ee04}'),
                    ('\u{1ee20}', '\u{1ee20}'),
                    ('\u{1ee23}', '\u{1ee23}'),
                    ('\u{1ee25}', '\u{1ee26}'),
                    ('\u{1ee28}', '\u{1ee28}'),
                    ('\u{1ee33}', '\u{1ee33}'),
                    ('\u{1ee38}', '\u{1ee38}'),
                    ('\u{1ee3a}', '\u{1ee3a}'),
                    ('\u{1ee3c}', '\u{1ee41}'),
                    ('\u{1ee43}', '\u{1ee46}'),
                    ('\u{1ee48}', '\u{1ee48}'),
                    ('\u{1ee4a}', '\u{1ee4a}'),
                    ('\u{1ee4c}', '\u{1ee4c}'),
                    ('\u{1ee50}', '\u{1ee50}'),
                    ('\u{1ee53}', '\u{1ee53}'),
                    ('\u{1ee55}', '\u{1ee56}'),
                    ('\u{1ee58}', '\u{1ee58}'),
                    ('\u{1ee5a}', '\u{1ee5a}'),
                    ('\u{1ee5c}', '\u{1ee5c}'),
                    ('\u{1ee5e}', '\u{1ee5e}'),
                    ('\u{1ee60}', '\u{1ee60}'),
                    ('\u{1ee63}', '\u{1ee63}'),
                    ('\u{1ee65}', '\u{1ee66}'),
                    ('\u{1ee6b}', '\u{1ee6b}'),
                    ('\u{1ee73}', '\u{1ee73}'),
                    ('\u{1ee78}', '\u{1ee78}'),
                    ('\u{1ee7d}', '\u{1ee7d}'),
                    ('\u{1ee7f}', '\u{1ee7f}'),
                    ('\u{1ee8a}', '\u{1ee8a}'),
                    ('\u{1ee9c}', '\u{1eea0}'),
                    ('\u{1eea4}', '\u{1eea4}'),
                    ('\u{1eeaa}', '\u{1eeaa}'),
                    ('\u{1eebc}', '\u{1eeef}'),
                    ('\u{1eef2}', '\u{1efff}'),
                    ('\u{1f02c}', '\u{1f02f}'),
                    ('\u{1f094}', '\u{1f09f}'),
                    ('\u{1f0af}', '\u{1f0b0}'),
                    ('\u{1f0c0}', '\u{1f0c0}'),
                    ('\u{1f0d0}', '\u{1f0d0}'),
                    ('\u{1f0f6}', '\u{1f0ff}'),
                    ('\u{1f1ae}', '\u{1f1e5}'),
                    ('\u{1f203}', '\u{1f20f}'),
                    ('\u{1f23c}', '\u{1f23f}'),
                    ('\u{1f249}', '\u{1f24f}'),
                    ('\u{1f252}', '\u{1f25f}'),
                    ('\u{1f266}', '\u{1f2ff}'),
                    ('\u{1f6d8}', '\u{1f6db}'),
                    ('\u{1f6ed}', '\u{1f6ef}'),
                    ('\u{1f6fd}', '\u{1f6ff}'),
                    ('\u{1f777}', '\u{1f77a}'),
                    ('\u{1f7da}', '\u{1f7df}'),
                    ('\u{1f7ec}', '\u{1f7ef}'),
                    ('\u{1f7f1}', '\u{1f7ff}'),
                    ('\u{1f80c}', '\u{1f80f}'),
                    ('\u{1f848}', '\u{1f84f}'),
                    ('\u{1f85a}', '\u{1f85f}'),
                    ('\u{1f888}', '\u{1f88f}'),
                    ('\u{1f8ae}', '\u{1f8af}'),
                    ('\u{1f8bc}', '\u{1f8bf}'),
                    ('\u{1f8c2}', '\u{1f8ff}'),
                    ('\u{1fa54}', '\u{1fa5f}'),
                    ('\u{1fa6e}', '\u{1fa6f}'),
                    ('\u{1fa7d}', '\u{1fa7f}'),
                    ('\u{1fa8a}', '\u{1fa8e}'),
                    ('\u{1fac7}', '\u{1facd}'),
                    ('\u{1fadd}', '\u{1fade}'),
                    ('\u{1faea}', '\u{1faef}'),
                    ('\u{1faf9}', '\u{1faff}'),
                    ('\u{1fb93}', '\u{1fb93}'),
                    ('\u{1fbfa}', '\u{1ffff}'),
                    ('\u{2a6e0}', '\u{2a6ff}'),
                    ('\u{2b73a}', '\u{2b73f}'),
                    ('\u{2b81e}', '\u{2b81f}'),
                    ('\u{2cea2}', '\u{2ceaf}'),
                    ('\u{2ebe1}', '\u{2ebef}'),
                    ('\u{2ee5e}', '\u{2f7ff}'),
                    ('\u{2fa1e}', '\u{2ffff}'),
                    ('\u{3134b}', '\u{3134f}'),
                    ('\u{323b0}', '\u{e00ff}'),
                    ('\u{e01f0}', '\u{10ffff}'),
                ];

                pub const OTHER_LETTER: &'static [(char, char)] = &
                [
                    ('ª', 'ª'),
                    ('º', 'º'),
                    ('ƻ', 'ƻ'),
                    ('ǀ', 'ǃ'),
                    ('ʔ', 'ʔ'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('ؠ', 'ؿ'),
                    ('ف', 'ي'),
                    ('ٮ', 'ٯ'),
                    ('ٱ', 'ۓ'),
                    ('ە', 'ە'),
                    ('ۮ', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ࠀ', 'ࠕ'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('ࢠ', 'ࣈ'),
                    ('ऄ', 'ह'),
                    ('ऽ', 'ऽ'),
                    ('ॐ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('ॲ', 'ঀ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('ੲ', 'ੴ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ઽ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('ૹ', 'ૹ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('ୱ', 'ୱ'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ௐ', 'ௐ'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('ಀ', 'ಀ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಽ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('ೱ', 'ೲ'),
                    ('ഄ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', 'ൖ'),
                    ('ൟ', 'ൡ'),
                    ('ൺ', 'ൿ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ก', 'ะ'),
                    ('า', 'ำ'),
                    ('เ', 'ๅ'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ະ'),
                    ('າ', 'ຳ'),
                    ('ຽ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ྈ', 'ྌ'),
                    ('က', 'ဪ'),
                    ('ဿ', 'ဿ'),
                    ('ၐ', 'ၕ'),
                    ('ၚ', 'ၝ'),
                    ('ၡ', 'ၡ'),
                    ('ၥ', 'ၦ'),
                    ('ၮ', 'ၰ'),
                    ('ၵ', 'ႁ'),
                    ('ႎ', 'ႎ'),
                    ('ᄀ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛱ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ក', 'ឳ'),
                    ('ៜ', 'ៜ'),
                    ('ᠠ', 'ᡂ'),
                    ('ᡄ', 'ᡸ'),
                    ('ᢀ', 'ᢄ'),
                    ('ᢇ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('ᨀ', 'ᨖ'),
                    ('ᨠ', 'ᩔ'),
                    ('ᬅ', 'ᬳ'),
                    ('ᭅ', 'ᭌ'),
                    ('ᮃ', 'ᮠ'),
                    ('ᮮ', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᰀ', 'ᰣ'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱷ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ℵ', 'ℸ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('〆', '〆'),
                    ('〼', '〼'),
                    ('ぁ', 'ゖ'),
                    ('ゟ', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ヿ', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꀔ'),
                    ('ꀖ', 'ꒌ'),
                    ('ꓐ', 'ꓷ'),
                    ('ꔀ', 'ꘋ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('ꙮ', 'ꙮ'),
                    ('ꚠ', 'ꛥ'),
                    ('ꞏ', 'ꞏ'),
                    ('ꟷ', 'ꟷ'),
                    ('ꟻ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠢ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢂ', 'ꢳ'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', 'ꣾ'),
                    ('ꤊ', 'ꤥ'),
                    ('ꤰ', 'ꥆ'),
                    ('ꥠ', 'ꥼ'),
                    ('ꦄ', 'ꦲ'),
                    ('ꧠ', 'ꧤ'),
                    ('ꧧ', 'ꧯ'),
                    ('ꧺ', 'ꧾ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꩠ', 'ꩯ'),
                    ('ꩱ', 'ꩶ'),
                    ('ꩺ', 'ꩺ'),
                    ('ꩾ', 'ꪯ'),
                    ('ꪱ', 'ꪱ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪽ'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫜ'),
                    ('ꫠ', 'ꫪ'),
                    ('ꫲ', 'ꫲ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꯀ', 'ꯢ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('ｦ', 'ｯ'),
                    ('ｱ', 'ﾝ'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍀'),
                    ('𐍂', '𐍉'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐑐', '𐒝'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐴀', '𐴣'),
                    ('𐵊', '𐵍'),
                    ('𐵏', '𐵏'),
                    ('𐺀', '𐺩'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀃', '𑀷'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂃', '𑂯'),
                    ('𑃐', '𑃨'),
                    ('𑄃', '𑄦'),
                    ('𑅄', '𑅄'),
                    ('𑅇', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('𑆃', '𑆲'),
                    ('𑇁', '𑇄'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈫'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '𑋞'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍡'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑐴'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '𑖮'),
                    ('𑗘', '𑗛'),
                    ('𑘀', '𑘯'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '𑚪'),
                    ('𑚸', '𑚸'),
                    ('𑜀', '𑜚'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '𑠫'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧐'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧣'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨺', '𑨺'),
                    ('𑩐', '𑩐'),
                    ('𑩜', '𑪉'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰮'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶉'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻲'),
                    ('𑼂', '𑼂'),
                    ('𑼄', '𑼐'),
                    ('𑼒', '𑼳'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵃', '𖵪'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖽐'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𝼊', '𝼊'),
                    ('𞄀', '𞄬'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓪'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const OTHER_NUMBER: &'static [(char, char)] = &
                [
                    ('²', '³'),
                    ('¹', '¹'),
                    ('¼', '¾'),
                    ('৴', '৹'),
                    ('୲', '୷'),
                    ('௰', '௲'),
                    ('౸', '౾'),
                    ('൘', '൞'),
                    ('൰', '൸'),
                    ('༪', '༳'),
                    ('፩', '፼'),
                    ('៰', '៹'),
                    ('᧚', '᧚'),
                    ('⁰', '⁰'),
                    ('⁴', '⁹'),
                    ('₀', '₉'),
                    ('⅐', '⅟'),
                    ('↉', '↉'),
                    ('①', '⒛'),
                    ('⓪', '⓿'),
                    ('❶', '➓'),
                    ('⳽', '⳽'),
                    ('㆒', '㆕'),
                    ('㈠', '㈩'),
                    ('㉈', '㉏'),
                    ('㉑', '㉟'),
                    ('㊀', '㊉'),
                    ('㊱', '㊿'),
                    ('꠰', '꠵'),
                    ('𐄇', '𐄳'),
                    ('𐅵', '𐅸'),
                    ('𐆊', '𐆋'),
                    ('𐋡', '𐋻'),
                    ('𐌠', '𐌣'),
                    ('𐡘', '𐡟'),
                    ('𐡹', '𐡿'),
                    ('𐢧', '𐢯'),
                    ('𐣻', '𐣿'),
                    ('𐤖', '𐤛'),
                    ('𐦼', '𐦽'),
                    ('𐧀', '𐧏'),
                    ('𐧒', '𐧿'),
                    ('𐩀', '𐩈'),
                    ('𐩽', '𐩾'),
                    ('𐪝', '𐪟'),
                    ('𐫫', '𐫯'),
                    ('𐭘', '𐭟'),
                    ('𐭸', '𐭿'),
                    ('𐮩', '𐮯'),
                    ('𐳺', '𐳿'),
                    ('𐹠', '𐹾'),
                    ('𐼝', '𐼦'),
                    ('𐽑', '𐽔'),
                    ('𐿅', '𐿋'),
                    ('𑁒', '𑁥'),
                    ('𑇡', '𑇴'),
                    ('𑜺', '𑜻'),
                    ('𑣪', '𑣲'),
                    ('𑱚', '𑱬'),
                    ('𑿀', '𑿔'),
                    ('𖭛', '𖭡'),
                    ('𖺀', '𖺖'),
                    ('𝋀', '𝋓'),
                    ('𝋠', '𝋳'),
                    ('𝍠', '𝍸'),
                    ('𞣇', '𞣏'),
                    ('𞱱', '𞲫'),
                    ('𞲭', '𞲯'),
                    ('𞲱', '𞲴'),
                    ('𞴁', '𞴭'),
                    ('𞴯', '𞴽'),
                    ('🄀', '🄌'),
                ];

                pub const OTHER_PUNCTUATION: &'static [(char, char)] = &
                [
                    ('!', '#'),
                    ('%', '\''),
                    ('*', '*'),
                    (',', ','),
                    ('.', '/'),
                    (':', ';'),
                    ('?', '@'),
                    ('\\', '\\'),
                    ('¡', '¡'),
                    ('§', '§'),
                    ('¶', '·'),
                    ('¿', '¿'),
                    (';', ';'),
                    ('·', '·'),
                    ('՚', '՟'),
                    ('։', '։'),
                    ('׀', '׀'),
                    ('׃', '׃'),
                    ('׆', '׆'),
                    ('׳', '״'),
                    ('؉', '؊'),
                    ('،', '؍'),
                    ('؛', '؛'),
                    ('؝', '؟'),
                    ('٪', '٭'),
                    ('۔', '۔'),
                    ('܀', '܍'),
                    ('߷', '߹'),
                    ('࠰', '࠾'),
                    ('࡞', '࡞'),
                    ('।', '॥'),
                    ('॰', '॰'),
                    ('৽', '৽'),
                    ('੶', '੶'),
                    ('૰', '૰'),
                    ('౷', '౷'),
                    ('಄', '಄'),
                    ('෴', '෴'),
                    ('๏', '๏'),
                    ('๚', '๛'),
                    ('༄', '༒'),
                    ('༔', '༔'),
                    ('྅', '྅'),
                    ('࿐', '࿔'),
                    ('࿙', '࿚'),
                    ('၊', '၏'),
                    ('჻', '჻'),
                    ('፠', '፨'),
                    ('᙮', '᙮'),
                    ('᛫', '᛭'),
                    ('᜵', '᜶'),
                    ('។', '៖'),
                    ('៘', '៚'),
                    ('᠀', '᠅'),
                    ('᠇', '᠊'),
                    ('᥄', '᥅'),
                    ('᨞', '᨟'),
                    ('᪠', '᪦'),
                    ('᪨', '᪭'),
                    ('᭎', '᭏'),
                    ('᭚', '᭠'),
                    ('᭽', '᭿'),
                    ('᯼', '᯿'),
                    ('᰻', '᰿'),
                    ('᱾', '᱿'),
                    ('᳀', '᳇'),
                    ('᳓', '᳓'),
                    ('‖', '‗'),
                    ('†', '‧'),
                    ('‰', '‸'),
                    ('※', '‾'),
                    ('⁁', '⁃'),
                    ('⁇', '⁑'),
                    ('⁓', '⁓'),
                    ('⁕', '⁞'),
                    ('⳹', '⳼'),
                    ('⳾', '⳿'),
                    ('⵰', '⵰'),
                    ('⸀', '⸁'),
                    ('⸆', '⸈'),
                    ('⸋', '⸋'),
                    ('⸎', '⸖'),
                    ('⸘', '⸙'),
                    ('⸛', '⸛'),
                    ('⸞', '⸟'),
                    ('⸪', '⸮'),
                    ('⸰', '⸹'),
                    ('⸼', '⸿'),
                    ('⹁', '⹁'),
                    ('⹃', '⹏'),
                    ('⹒', '⹔'),
                    ('、', '〃'),
                    ('〽', '〽'),
                    ('・', '・'),
                    ('꓾', '꓿'),
                    ('꘍', '꘏'),
                    ('꙳', '꙳'),
                    ('꙾', '꙾'),
                    ('꛲', '꛷'),
                    ('꡴', '꡷'),
                    ('꣎', '꣏'),
                    ('꣸', '꣺'),
                    ('꣼', '꣼'),
                    ('꤮', '꤯'),
                    ('꥟', '꥟'),
                    ('꧁', '꧍'),
                    ('꧞', '꧟'),
                    ('꩜', '꩟'),
                    ('꫞', '꫟'),
                    ('꫰', '꫱'),
                    ('꯫', '꯫'),
                    ('︐', '︖'),
                    ('︙', '︙'),
                    ('︰', '︰'),
                    ('﹅', '﹆'),
                    ('﹉', '﹌'),
                    ('﹐', '﹒'),
                    ('﹔', '﹗'),
                    ('﹟', '﹡'),
                    ('﹨', '﹨'),
                    ('﹪', '﹫'),
                    ('！', '＃'),
                    ('％', '＇'),
                    ('＊', '＊'),
                    ('，', '，'),
                    ('．', '／'),
                    ('：', '；'),
                    ('？', '＠'),
                    ('＼', '＼'),
                    ('｡', '｡'),
                    ('､', '･'),
                    ('𐄀', '𐄂'),
                    ('𐎟', '𐎟'),
                    ('𐏐', '𐏐'),
                    ('𐕯', '𐕯'),
                    ('𐡗', '𐡗'),
                    ('𐤟', '𐤟'),
                    ('𐤿', '𐤿'),
                    ('𐩐', '𐩘'),
                    ('𐩿', '𐩿'),
                    ('𐫰', '𐫶'),
                    ('𐬹', '𐬿'),
                    ('𐮙', '𐮜'),
                    ('𐽕', '𐽙'),
                    ('𐾆', '𐾉'),
                    ('𑁇', '𑁍'),
                    ('𑂻', '𑂼'),
                    ('𑂾', '𑃁'),
                    ('𑅀', '𑅃'),
                    ('𑅴', '𑅵'),
                    ('𑇅', '𑇈'),
                    ('𑇍', '𑇍'),
                    ('𑇛', '𑇛'),
                    ('𑇝', '𑇟'),
                    ('𑈸', '𑈽'),
                    ('𑊩', '𑊩'),
                    ('𑏔', '𑏕'),
                    ('𑏗', '𑏘'),
                    ('𑑋', '𑑏'),
                    ('𑑚', '𑑛'),
                    ('𑑝', '𑑝'),
                    ('𑓆', '𑓆'),
                    ('𑗁', '𑗗'),
                    ('𑙁', '𑙃'),
                    ('𑙠', '𑙬'),
                    ('𑚹', '𑚹'),
                    ('𑜼', '𑜾'),
                    ('𑠻', '𑠻'),
                    ('𑥄', '𑥆'),
                    ('𑧢', '𑧢'),
                    ('𑨿', '𑩆'),
                    ('𑪚', '𑪜'),
                    ('𑪞', '𑪢'),
                    ('𑬀', '𑬉'),
                    ('𑯡', '𑯡'),
                    ('𑱁', '𑱅'),
                    ('𑱰', '𑱱'),
                    ('𑻷', '𑻸'),
                    ('𑽃', '𑽏'),
                    ('𑿿', '𑿿'),
                    ('𒑰', '𒑴'),
                    ('𒿱', '𒿲'),
                    ('𖩮', '𖩯'),
                    ('𖫵', '𖫵'),
                    ('𖬷', '𖬻'),
                    ('𖭄', '𖭄'),
                    ('𖵭', '𖵯'),
                    ('𖺗', '𖺚'),
                    ('𖿢', '𖿢'),
                    ('𛲟', '𛲟'),
                    ('𝪇', '𝪋'),
                    ('𞗿', '𞗿'),
                    ('𞥞', '𞥟'),
                ];

                pub const OTHER_SYMBOL: &'static [(char, char)] = &
                [
                    ('¦', '¦'),
                    ('©', '©'),
                    ('®', '®'),
                    ('°', '°'),
                    ('҂', '҂'),
                    ('֍', '֎'),
                    ('؎', '؏'),
                    ('۞', '۞'),
                    ('۩', '۩'),
                    ('۽', '۾'),
                    ('߶', '߶'),
                    ('৺', '৺'),
                    ('୰', '୰'),
                    ('௳', '௸'),
                    ('௺', '௺'),
                    ('౿', '౿'),
                    ('൏', '൏'),
                    ('൹', '൹'),
                    ('༁', '༃'),
                    ('༓', '༓'),
                    ('༕', '༗'),
                    ('༚', '༟'),
                    ('༴', '༴'),
                    ('༶', '༶'),
                    ('༸', '༸'),
                    ('྾', '࿅'),
                    ('࿇', '࿌'),
                    ('࿎', '࿏'),
                    ('࿕', '࿘'),
                    ('႞', '႟'),
                    ('᎐', '᎙'),
                    ('᙭', '᙭'),
                    ('᥀', '᥀'),
                    ('᧞', '᧿'),
                    ('᭡', '᭪'),
                    ('᭴', '᭼'),
                    ('℀', '℁'),
                    ('℃', '℆'),
                    ('℈', '℉'),
                    ('℔', '℔'),
                    ('№', '℗'),
                    ('℞', '℣'),
                    ('℥', '℥'),
                    ('℧', '℧'),
                    ('℩', '℩'),
                    ('℮', '℮'),
                    ('℺', '℻'),
                    ('⅊', '⅊'),
                    ('⅌', '⅍'),
                    ('⅏', '⅏'),
                    ('↊', '↋'),
                    ('↕', '↙'),
                    ('↜', '↟'),
                    ('↡', '↢'),
                    ('↤', '↥'),
                    ('↧', '↭'),
                    ('↯', '⇍'),
                    ('⇐', '⇑'),
                    ('⇓', '⇓'),
                    ('⇕', '⇳'),
                    ('⌀', '⌇'),
                    ('⌌', '⌟'),
                    ('⌢', '⌨'),
                    ('⌫', '⍻'),
                    ('⍽', '⎚'),
                    ('⎴', '⏛'),
                    ('⏢', '␩'),
                    ('⑀', '⑊'),
                    ('⒜', 'ⓩ'),
                    ('─', '▶'),
                    ('▸', '◀'),
                    ('◂', '◷'),
                    ('☀', '♮'),
                    ('♰', '❧'),
                    ('➔', '➿'),
                    ('⠀', '⣿'),
                    ('⬀', '⬯'),
                    ('⭅', '⭆'),
                    ('⭍', '⭳'),
                    ('⭶', '⮕'),
                    ('⮗', '⯿'),
                    ('⳥', '⳪'),
                    ('⹐', '⹑'),
                    ('⺀', '⺙'),
                    ('⺛', '⻳'),
                    ('⼀', '⿕'),
                    ('⿰', '⿿'),
                    ('〄', '〄'),
                    ('〒', '〓'),
                    ('〠', '〠'),
                    ('〶', '〷'),
                    ('〾', '〿'),
                    ('㆐', '㆑'),
                    ('㆖', '㆟'),
                    ('㇀', '㇥'),
                    ('㇯', '㇯'),
                    ('㈀', '㈞'),
                    ('㈪', '㉇'),
                    ('㉐', '㉐'),
                    ('㉠', '㉿'),
                    ('㊊', '㊰'),
                    ('㋀', '㏿'),
                    ('䷀', '䷿'),
                    ('꒐', '꓆'),
                    ('꠨', '꠫'),
                    ('꠶', '꠷'),
                    ('꠹', '꠹'),
                    ('꩷', '꩹'),
                    ('﵀', '﵏'),
                    ('﷏', '﷏'),
                    ('﷽', '﷿'),
                    ('￤', '￤'),
                    ('￨', '￨'),
                    ('￭', '￮'),
                    (' ', ' '),
                    ('𐄷', '𐄿'),
                    ('𐅹', '𐆉'),
                    ('𐆌', '𐆎'),
                    ('𐆐', '𐆜'),
                    ('𐆠', '𐆠'),
                    ('𐇐', '𐇼'),
                    ('𐡷', '𐡸'),
                    ('𐫈', '𐫈'),
                    ('𑜿', '𑜿'),
                    ('𑿕', '𑿜'),
                    ('𑿡', '𑿱'),
                    ('𖬼', '𖬿'),
                    ('𖭅', '𖭅'),
                    ('𛲜', '𛲜'),
                    ('𜰀', '𜳯'),
                    ('𜴀', '𜺳'),
                    ('𜽐', '𜿃'),
                    ('𝀀', '𝃵'),
                    ('𝄀', '𝄦'),
                    ('𝄩', '𝅘𝅥𝅲'),
                    ('𝅪', '𝅬'),
                    ('𝆃', '𝆄'),
                    ('𝆌', '𝆩'),
                    ('𝆮', '𝇪'),
                    ('𝈀', '𝉁'),
                    ('𝉅', '𝉅'),
                    ('𝌀', '𝍖'),
                    ('𝠀', '𝧿'),
                    ('𝨷', '𝨺'),
                    ('𝩭', '𝩴'),
                    ('𝩶', '𝪃'),
                    ('𝪅', '𝪆'),
                    ('𞅏', '𞅏'),
                    ('𞲬', '𞲬'),
                    ('𞴮', '𞴮'),
                    ('🀀', '🀫'),
                    ('🀰', '🂓'),
                    ('🂠', '🂮'),
                    ('🂱', '🂿'),
                    ('🃁', '🃏'),
                    ('🃑', '🃵'),
                    ('🄍', '🆭'),
                    ('🇦', '🈂'),
                    ('🈐', '🈻'),
                    ('🉀', '🉈'),
                    ('🉐', '🉑'),
                    ('🉠', '🉥'),
                    ('🌀', '🏺'),
                    ('🐀', '🛗'),
                    ('🛜', '🛬'),
                    ('🛰', '🛼'),
                    ('🜀', '🝶'),
                    ('🝻', '🟙'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🠀', '🠋'),
                    ('🠐', '🡇'),
                    ('🡐', '🡙'),
                    ('🡠', '🢇'),
                    ('🢐', '🢭'),
                    ('🢰', '🢻'),
                    ('🣀', '🣁'),
                    ('🤀', '🩓'),
                    ('🩠', '🩭'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                    ('🬀', '🮒'),
                    ('🮔', '🯯'),
                ];

                pub const PARAGRAPH_SEPARATOR: &'static [(char, char)] = &[('\u{2029}', '\u{2029}')];

                pub const PRIVATE_USE: &'static [(char, char)] = &
                [
                    ('\u{e000}', '\u{f8ff}'),
                    ('\u{f0000}', '\u{ffffd}'),
                    ('\u{100000}', '\u{10fffd}'),
                ];

                pub const PUNCTUATION: &'static [(char, char)] = &
                [
                    ('!', '#'),
                    ('%', '*'),
                    (',', '/'),
                    (':', ';'),
                    ('?', '@'),
                    ('[', ']'),
                    ('_', '_'),
                    ('{', '{'),
                    ('}', '}'),
                    ('¡', '¡'),
                    ('§', '§'),
                    ('«', '«'),
                    ('¶', '·'),
                    ('»', '»'),
                    ('¿', '¿'),
                    (';', ';'),
                    ('·', '·'),
                    ('՚', '՟'),
                    ('։', '֊'),
                    ('־', '־'),
                    ('׀', '׀'),
                    ('׃', '׃'),
                    ('׆', '׆'),
                    ('׳', '״'),
                    ('؉', '؊'),
                    ('،', '؍'),
                    ('؛', '؛'),
                    ('؝', '؟'),
                    ('٪', '٭'),
                    ('۔', '۔'),
                    ('܀', '܍'),
                    ('߷', '߹'),
                    ('࠰', '࠾'),
                    ('࡞', '࡞'),
                    ('।', '॥'),
                    ('॰', '॰'),
                    ('৽', '৽'),
                    ('੶', '੶'),
                    ('૰', '૰'),
                    ('౷', '౷'),
                    ('಄', '಄'),
                    ('෴', '෴'),
                    ('๏', '๏'),
                    ('๚', '๛'),
                    ('༄', '༒'),
                    ('༔', '༔'),
                    ('༺', '༽'),
                    ('྅', '྅'),
                    ('࿐', '࿔'),
                    ('࿙', '࿚'),
                    ('၊', '၏'),
                    ('჻', '჻'),
                    ('፠', '፨'),
                    ('᐀', '᐀'),
                    ('᙮', '᙮'),
                    ('᚛', '᚜'),
                    ('᛫', '᛭'),
                    ('᜵', '᜶'),
                    ('។', '៖'),
                    ('៘', '៚'),
                    ('᠀', '᠊'),
                    ('᥄', '᥅'),
                    ('᨞', '᨟'),
                    ('᪠', '᪦'),
                    ('᪨', '᪭'),
                    ('᭎', '᭏'),
                    ('᭚', '᭠'),
                    ('᭽', '᭿'),
                    ('᯼', '᯿'),
                    ('᰻', '᰿'),
                    ('᱾', '᱿'),
                    ('᳀', '᳇'),
                    ('᳓', '᳓'),
                    ('‐', '‧'),
                    ('‰', '⁃'),
                    ('⁅', '⁑'),
                    ('⁓', '⁞'),
                    ('⁽', '⁾'),
                    ('₍', '₎'),
                    ('⌈', '⌋'),
                    ('〈', '〉'),
                    ('❨', '❵'),
                    ('⟅', '⟆'),
                    ('⟦', '⟯'),
                    ('⦃', '⦘'),
                    ('⧘', '⧛'),
                    ('⧼', '⧽'),
                    ('⳹', '⳼'),
                    ('⳾', '⳿'),
                    ('⵰', '⵰'),
                    ('⸀', '⸮'),
                    ('⸰', '⹏'),
                    ('⹒', '⹝'),
                    ('、', '〃'),
                    ('〈', '】'),
                    ('〔', '〟'),
                    ('〰', '〰'),
                    ('〽', '〽'),
                    ('゠', '゠'),
                    ('・', '・'),
                    ('꓾', '꓿'),
                    ('꘍', '꘏'),
                    ('꙳', '꙳'),
                    ('꙾', '꙾'),
                    ('꛲', '꛷'),
                    ('꡴', '꡷'),
                    ('꣎', '꣏'),
                    ('꣸', '꣺'),
                    ('꣼', '꣼'),
                    ('꤮', '꤯'),
                    ('꥟', '꥟'),
                    ('꧁', '꧍'),
                    ('꧞', '꧟'),
                    ('꩜', '꩟'),
                    ('꫞', '꫟'),
                    ('꫰', '꫱'),
                    ('꯫', '꯫'),
                    ('﴾', '﴿'),
                    ('︐', '︙'),
                    ('︰', '﹒'),
                    ('﹔', '﹡'),
                    ('﹣', '﹣'),
                    ('﹨', '﹨'),
                    ('﹪', '﹫'),
                    ('！', '＃'),
                    ('％', '＊'),
                    ('，', '／'),
                    ('：', '；'),
                    ('？', '＠'),
                    ('［', '］'),
                    ('＿', '＿'),
                    ('｛', '｛'),
                    ('｝', '｝'),
                    ('｟', '･'),
                    ('𐄀', '𐄂'),
                    ('𐎟', '𐎟'),
                    ('𐏐', '𐏐'),
                    ('𐕯', '𐕯'),
                    ('𐡗', '𐡗'),
                    ('𐤟', '𐤟'),
                    ('𐤿', '𐤿'),
                    ('𐩐', '𐩘'),
                    ('𐩿', '𐩿'),
                    ('𐫰', '𐫶'),
                    ('𐬹', '𐬿'),
                    ('𐮙', '𐮜'),
                    ('𐵮', '𐵮'),
                    ('𐺭', '𐺭'),
                    ('𐽕', '𐽙'),
                    ('𐾆', '𐾉'),
                    ('𑁇', '𑁍'),
                    ('𑂻', '𑂼'),
                    ('𑂾', '𑃁'),
                    ('𑅀', '𑅃'),
                    ('𑅴', '𑅵'),
                    ('𑇅', '𑇈'),
                    ('𑇍', '𑇍'),
                    ('𑇛', '𑇛'),
                    ('𑇝', '𑇟'),
                    ('𑈸', '𑈽'),
                    ('𑊩', '𑊩'),
                    ('𑏔', '𑏕'),
                    ('𑏗', '𑏘'),
                    ('𑑋', '𑑏'),
                    ('𑑚', '𑑛'),
                    ('𑑝', '𑑝'),
                    ('𑓆', '𑓆'),
                    ('𑗁', '𑗗'),
                    ('𑙁', '𑙃'),
                    ('𑙠', '𑙬'),
                    ('𑚹', '𑚹'),
                    ('𑜼', '𑜾'),
                    ('𑠻', '𑠻'),
                    ('𑥄', '𑥆'),
                    ('𑧢', '𑧢'),
                    ('𑨿', '𑩆'),
                    ('𑪚', '𑪜'),
                    ('𑪞', '𑪢'),
                    ('𑬀', '𑬉'),
                    ('𑯡', '𑯡'),
                    ('𑱁', '𑱅'),
                    ('𑱰', '𑱱'),
                    ('𑻷', '𑻸'),
                    ('𑽃', '𑽏'),
                    ('𑿿', '𑿿'),
                    ('𒑰', '𒑴'),
                    ('𒿱', '𒿲'),
                    ('𖩮', '𖩯'),
                    ('𖫵', '𖫵'),
                    ('𖬷', '𖬻'),
                    ('𖭄', '𖭄'),
                    ('𖵭', '𖵯'),
                    ('𖺗', '𖺚'),
                    ('𖿢', '𖿢'),
                    ('𛲟', '𛲟'),
                    ('𝪇', '𝪋'),
                    ('𞗿', '𞗿'),
                    ('𞥞', '𞥟'),
                ];

                pub const SEPARATOR: &'static [(char, char)] = &
                [
                    (' ', ' '),
                    ('\u{a0}', '\u{a0}'),
                    ('\u{1680}', '\u{1680}'),
                    ('\u{2000}', '\u{200a}'),
                    ('\u{2028}', '\u{2029}'),
                    ('\u{202f}', '\u{202f}'),
                    ('\u{205f}', '\u{205f}'),
                    ('\u{3000}', '\u{3000}'),
                ];

                pub const SPACE_SEPARATOR: &'static [(char, char)] = &
                [
                    (' ', ' '),
                    ('\u{a0}', '\u{a0}'),
                    ('\u{1680}', '\u{1680}'),
                    ('\u{2000}', '\u{200a}'),
                    ('\u{202f}', '\u{202f}'),
                    ('\u{205f}', '\u{205f}'),
                    ('\u{3000}', '\u{3000}'),
                ];

                pub const SPACING_MARK: &'static [(char, char)] = &
                [
                    ('ः', 'ः'),
                    ('ऻ', 'ऻ'),
                    ('ा', 'ी'),
                    ('ॉ', 'ौ'),
                    ('ॎ', 'ॏ'),
                    ('ং', 'ঃ'),
                    ('\u{9be}', 'ী'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৌ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ਃ', 'ਃ'),
                    ('ਾ', 'ੀ'),
                    ('ઃ', 'ઃ'),
                    ('ા', 'ી'),
                    ('ૉ', 'ૉ'),
                    ('ો', 'ૌ'),
                    ('ଂ', 'ଃ'),
                    ('\u{b3e}', '\u{b3e}'),
                    ('ୀ', 'ୀ'),
                    ('େ', 'ୈ'),
                    ('ୋ', 'ୌ'),
                    ('\u{b57}', '\u{b57}'),
                    ('\u{bbe}', 'ி'),
                    ('ு', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', 'ௌ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('ఁ', 'ః'),
                    ('ు', 'ౄ'),
                    ('ಂ', 'ಃ'),
                    ('ಾ', 'ಾ'),
                    ('\u{cc0}', 'ೄ'),
                    ('\u{cc7}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccb}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೳ', 'ೳ'),
                    ('ം', 'ഃ'),
                    ('\u{d3e}', 'ീ'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൌ'),
                    ('\u{d57}', '\u{d57}'),
                    ('ං', 'ඃ'),
                    ('\u{dcf}', 'ෑ'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', 'ෳ'),
                    ('༾', '༿'),
                    ('ཿ', 'ཿ'),
                    ('ါ', 'ာ'),
                    ('ေ', 'ေ'),
                    ('း', 'း'),
                    ('ျ', 'ြ'),
                    ('ၖ', 'ၗ'),
                    ('ၢ', 'ၤ'),
                    ('ၧ', 'ၭ'),
                    ('ႃ', 'ႄ'),
                    ('ႇ', 'ႌ'),
                    ('ႏ', 'ႏ'),
                    ('ႚ', 'ႜ'),
                    ('\u{1715}', '\u{1715}'),
                    ('\u{1734}', '\u{1734}'),
                    ('ា', 'ា'),
                    ('ើ', 'ៅ'),
                    ('ះ', 'ៈ'),
                    ('ᤣ', 'ᤦ'),
                    ('ᤩ', 'ᤫ'),
                    ('ᤰ', 'ᤱ'),
                    ('ᤳ', 'ᤸ'),
                    ('ᨙ', 'ᨚ'),
                    ('ᩕ', 'ᩕ'),
                    ('ᩗ', 'ᩗ'),
                    ('ᩡ', 'ᩡ'),
                    ('ᩣ', 'ᩤ'),
                    ('ᩭ', 'ᩲ'),
                    ('ᬄ', 'ᬄ'),
                    ('\u{1b35}', '\u{1b35}'),
                    ('\u{1b3b}', '\u{1b3b}'),
                    ('\u{1b3d}', 'ᭁ'),
                    ('\u{1b43}', '\u{1b44}'),
                    ('ᮂ', 'ᮂ'),
                    ('ᮡ', 'ᮡ'),
                    ('ᮦ', 'ᮧ'),
                    ('\u{1baa}', '\u{1baa}'),
                    ('ᯧ', 'ᯧ'),
                    ('ᯪ', 'ᯬ'),
                    ('ᯮ', 'ᯮ'),
                    ('\u{1bf2}', '\u{1bf3}'),
                    ('ᰤ', 'ᰫ'),
                    ('ᰴ', 'ᰵ'),
                    ('᳡', '᳡'),
                    ('᳷', '᳷'),
                    ('\u{302e}', '\u{302f}'),
                    ('ꠣ', 'ꠤ'),
                    ('ꠧ', 'ꠧ'),
                    ('ꢀ', 'ꢁ'),
                    ('ꢴ', 'ꣃ'),
                    ('ꥒ', '\u{a953}'),
                    ('ꦃ', 'ꦃ'),
                    ('ꦴ', 'ꦵ'),
                    ('ꦺ', 'ꦻ'),
                    ('ꦾ', '\u{a9c0}'),
                    ('ꨯ', 'ꨰ'),
                    ('ꨳ', 'ꨴ'),
                    ('ꩍ', 'ꩍ'),
                    ('ꩻ', 'ꩻ'),
                    ('ꩽ', 'ꩽ'),
                    ('ꫫ', 'ꫫ'),
                    ('ꫮ', 'ꫯ'),
                    ('ꫵ', 'ꫵ'),
                    ('ꯣ', 'ꯤ'),
                    ('ꯦ', 'ꯧ'),
                    ('ꯩ', 'ꯪ'),
                    ('꯬', '꯬'),
                    ('𑀀', '𑀀'),
                    ('𑀂', '𑀂'),
                    ('𑂂', '𑂂'),
                    ('𑂰', '𑂲'),
                    ('𑂷', '𑂸'),
                    ('𑄬', '𑄬'),
                    ('𑅅', '𑅆'),
                    ('𑆂', '𑆂'),
                    ('𑆳', '𑆵'),
                    ('𑆿', '\u{111c0}'),
                    ('𑇎', '𑇎'),
                    ('𑈬', '𑈮'),
                    ('𑈲', '𑈳'),
                    ('\u{11235}', '\u{11235}'),
                    ('𑋠', '𑋢'),
                    ('𑌂', '𑌃'),
                    ('\u{1133e}', '𑌿'),
                    ('𑍁', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍢', '𑍣'),
                    ('\u{113b8}', '𑎺'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏍'),
                    ('\u{113cf}', '\u{113cf}'),
                    ('𑐵', '𑐷'),
                    ('𑑀', '𑑁'),
                    ('𑑅', '𑑅'),
                    ('\u{114b0}', '𑒲'),
                    ('𑒹', '𑒹'),
                    ('𑒻', '𑒾'),
                    ('𑓁', '𑓁'),
                    ('\u{115af}', '𑖱'),
                    ('𑖸', '𑖻'),
                    ('𑖾', '𑖾'),
                    ('𑘰', '𑘲'),
                    ('𑘻', '𑘼'),
                    ('𑘾', '𑘾'),
                    ('𑚬', '𑚬'),
                    ('𑚮', '𑚯'),
                    ('\u{116b6}', '\u{116b6}'),
                    ('𑜞', '𑜞'),
                    ('𑜠', '𑜡'),
                    ('𑜦', '𑜦'),
                    ('𑠬', '𑠮'),
                    ('𑠸', '𑠸'),
                    ('\u{11930}', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193d}', '\u{1193d}'),
                    ('𑥀', '𑥀'),
                    ('𑥂', '𑥂'),
                    ('𑧑', '𑧓'),
                    ('𑧜', '𑧟'),
                    ('𑧤', '𑧤'),
                    ('𑨹', '𑨹'),
                    ('𑩗', '𑩘'),
                    ('𑪗', '𑪗'),
                    ('𑰯', '𑰯'),
                    ('𑰾', '𑰾'),
                    ('𑲩', '𑲩'),
                    ('𑲱', '𑲱'),
                    ('𑲴', '𑲴'),
                    ('𑶊', '𑶎'),
                    ('𑶓', '𑶔'),
                    ('𑶖', '𑶖'),
                    ('𑻵', '𑻶'),
                    ('𑼃', '𑼃'),
                    ('𑼴', '𑼵'),
                    ('𑼾', '𑼿'),
                    ('\u{11f41}', '\u{11f41}'),
                    ('𖄪', '𖄬'),
                    ('𖽑', '𖾇'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1d165}', '\u{1d166}'),
                    ('\u{1d16d}', '\u{1d172}'),
                ];

                pub const SYMBOL: &'static [(char, char)] = &
                [
                    ('$', '$'),
                    ('+', '+'),
                    ('<', '>'),
                    ('^', '^'),
                    ('`', '`'),
                    ('|', '|'),
                    ('~', '~'),
                    ('¢', '¦'),
                    ('¨', '©'),
                    ('¬', '¬'),
                    ('®', '±'),
                    ('´', '´'),
                    ('¸', '¸'),
                    ('×', '×'),
                    ('÷', '÷'),
                    ('˂', '˅'),
                    ('˒', '˟'),
                    ('˥', '˫'),
                    ('˭', '˭'),
                    ('˯', '˿'),
                    ('͵', '͵'),
                    ('΄', '΅'),
                    ('϶', '϶'),
                    ('҂', '҂'),
                    ('֍', '֏'),
                    ('؆', '؈'),
                    ('؋', '؋'),
                    ('؎', '؏'),
                    ('۞', '۞'),
                    ('۩', '۩'),
                    ('۽', '۾'),
                    ('߶', '߶'),
                    ('߾', '߿'),
                    ('࢈', '࢈'),
                    ('৲', '৳'),
                    ('৺', '৻'),
                    ('૱', '૱'),
                    ('୰', '୰'),
                    ('௳', '௺'),
                    ('౿', '౿'),
                    ('൏', '൏'),
                    ('൹', '൹'),
                    ('฿', '฿'),
                    ('༁', '༃'),
                    ('༓', '༓'),
                    ('༕', '༗'),
                    ('༚', '༟'),
                    ('༴', '༴'),
                    ('༶', '༶'),
                    ('༸', '༸'),
                    ('྾', '࿅'),
                    ('࿇', '࿌'),
                    ('࿎', '࿏'),
                    ('࿕', '࿘'),
                    ('႞', '႟'),
                    ('᎐', '᎙'),
                    ('᙭', '᙭'),
                    ('៛', '៛'),
                    ('᥀', '᥀'),
                    ('᧞', '᧿'),
                    ('᭡', '᭪'),
                    ('᭴', '᭼'),
                    ('᾽', '᾽'),
                    ('᾿', '῁'),
                    ('῍', '῏'),
                    ('῝', '῟'),
                    ('῭', '`'),
                    ('´', '῾'),
                    ('⁄', '⁄'),
                    ('⁒', '⁒'),
                    ('⁺', '⁼'),
                    ('₊', '₌'),
                    ('₠', '⃀'),
                    ('℀', '℁'),
                    ('℃', '℆'),
                    ('℈', '℉'),
                    ('℔', '℔'),
                    ('№', '℘'),
                    ('℞', '℣'),
                    ('℥', '℥'),
                    ('℧', '℧'),
                    ('℩', '℩'),
                    ('℮', '℮'),
                    ('℺', '℻'),
                    ('⅀', '⅄'),
                    ('⅊', '⅍'),
                    ('⅏', '⅏'),
                    ('↊', '↋'),
                    ('←', '⌇'),
                    ('⌌', '⌨'),
                    ('⌫', '␩'),
                    ('⑀', '⑊'),
                    ('⒜', 'ⓩ'),
                    ('─', '❧'),
                    ('➔', '⟄'),
                    ('⟇', '⟥'),
                    ('⟰', '⦂'),
                    ('⦙', '⧗'),
                    ('⧜', '⧻'),
                    ('⧾', '⭳'),
                    ('⭶', '⮕'),
                    ('⮗', '⯿'),
                    ('⳥', '⳪'),
                    ('⹐', '⹑'),
                    ('⺀', '⺙'),
                    ('⺛', '⻳'),
                    ('⼀', '⿕'),
                    ('⿰', '⿿'),
                    ('〄', '〄'),
                    ('〒', '〓'),
                    ('〠', '〠'),
                    ('〶', '〷'),
                    ('〾', '〿'),
                    ('゛', '゜'),
                    ('㆐', '㆑'),
                    ('㆖', '㆟'),
                    ('㇀', '㇥'),
                    ('㇯', '㇯'),
                    ('㈀', '㈞'),
                    ('㈪', '㉇'),
                    ('㉐', '㉐'),
                    ('㉠', '㉿'),
                    ('㊊', '㊰'),
                    ('㋀', '㏿'),
                    ('䷀', '䷿'),
                    ('꒐', '꓆'),
                    ('꜀', '꜖'),
                    ('꜠', '꜡'),
                    ('꞉', '꞊'),
                    ('꠨', '꠫'),
                    ('꠶', '꠹'),
                    ('꩷', '꩹'),
                    ('꭛', '꭛'),
                    ('꭪', '꭫'),
                    ('﬩', '﬩'),
                    ('﮲', '﯂'),
                    ('﵀', '﵏'),
                    ('﷏', '﷏'),
                    ('﷼', '﷿'),
                    ('﹢', '﹢'),
                    ('﹤', '﹦'),
                    ('﹩', '﹩'),
                    ('＄', '＄'),
                    ('＋', '＋'),
                    ('＜', '＞'),
                    ('＾', '＾'),
                    ('｀', '｀'),
                    ('｜', '｜'),
                    ('～', '～'),
                    ('￠', '￦'),
                    ('￨', '￮'),
                    (' ', ' '),
                    ('𐄷', '𐄿'),
                    ('𐅹', '𐆉'),
                    ('𐆌', '𐆎'),
                    ('𐆐', '𐆜'),
                    ('𐆠', '𐆠'),
                    ('𐇐', '𐇼'),
                    ('𐡷', '𐡸'),
                    ('𐫈', '𐫈'),
                    ('𐶎', '𐶏'),
                    ('𑜿', '𑜿'),
                    ('𑿕', '𑿱'),
                    ('𖬼', '𖬿'),
                    ('𖭅', '𖭅'),
                    ('𛲜', '𛲜'),
                    ('𜰀', '𜳯'),
                    ('𜴀', '𜺳'),
                    ('𜽐', '𜿃'),
                    ('𝀀', '𝃵'),
                    ('𝄀', '𝄦'),
                    ('𝄩', '𝅘𝅥𝅲'),
                    ('𝅪', '𝅬'),
                    ('𝆃', '𝆄'),
                    ('𝆌', '𝆩'),
                    ('𝆮', '𝇪'),
                    ('𝈀', '𝉁'),
                    ('𝉅', '𝉅'),
                    ('𝌀', '𝍖'),
                    ('𝛁', '𝛁'),
                    ('𝛛', '𝛛'),
                    ('𝛻', '𝛻'),
                    ('𝜕', '𝜕'),
                    ('𝜵', '𝜵'),
                    ('𝝏', '𝝏'),
                    ('𝝯', '𝝯'),
                    ('𝞉', '𝞉'),
                    ('𝞩', '𝞩'),
                    ('𝟃', '𝟃'),
                    ('𝠀', '𝧿'),
                    ('𝨷', '𝨺'),
                    ('𝩭', '𝩴'),
                    ('𝩶', '𝪃'),
                    ('𝪅', '𝪆'),
                    ('𞅏', '𞅏'),
                    ('𞋿', '𞋿'),
                    ('𞲬', '𞲬'),
                    ('𞲰', '𞲰'),
                    ('𞴮', '𞴮'),
                    ('𞻰', '𞻱'),
                    ('🀀', '🀫'),
                    ('🀰', '🂓'),
                    ('🂠', '🂮'),
                    ('🂱', '🂿'),
                    ('🃁', '🃏'),
                    ('🃑', '🃵'),
                    ('🄍', '🆭'),
                    ('🇦', '🈂'),
                    ('🈐', '🈻'),
                    ('🉀', '🉈'),
                    ('🉐', '🉑'),
                    ('🉠', '🉥'),
                    ('🌀', '🛗'),
                    ('🛜', '🛬'),
                    ('🛰', '🛼'),
                    ('🜀', '🝶'),
                    ('🝻', '🟙'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🠀', '🠋'),
                    ('🠐', '🡇'),
                    ('🡐', '🡙'),
                    ('🡠', '🢇'),
                    ('🢐', '🢭'),
                    ('🢰', '🢻'),
                    ('🣀', '🣁'),
                    ('🤀', '🩓'),
                    ('🩠', '🩭'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                    ('🬀', '🮒'),
                    ('🮔', '🯯'),
                ];

                pub const TITLECASE_LETTER: &'static [(char, char)] = &
                [
                    ('ǅ', 'ǅ'),
                    ('ǈ', 'ǈ'),
                    ('ǋ', 'ǋ'),
                    ('ǲ', 'ǲ'),
                    ('ᾈ', 'ᾏ'),
                    ('ᾘ', 'ᾟ'),
                    ('ᾨ', 'ᾯ'),
                    ('ᾼ', 'ᾼ'),
                    ('ῌ', 'ῌ'),
                    ('ῼ', 'ῼ'),
                ];

                pub const UNASSIGNED: &'static [(char, char)] = &
                [
                    ('\u{378}', '\u{379}'),
                    ('\u{380}', '\u{383}'),
                    ('\u{38b}', '\u{38b}'),
                    ('\u{38d}', '\u{38d}'),
                    ('\u{3a2}', '\u{3a2}'),
                    ('\u{530}', '\u{530}'),
                    ('\u{557}', '\u{558}'),
                    ('\u{58b}', '\u{58c}'),
                    ('\u{590}', '\u{590}'),
                    ('\u{5c8}', '\u{5cf}'),
                    ('\u{5eb}', '\u{5ee}'),
                    ('\u{5f5}', '\u{5ff}'),
                    ('\u{70e}', '\u{70e}'),
                    ('\u{74b}', '\u{74c}'),
                    ('\u{7b2}', '\u{7bf}'),
                    ('\u{7fb}', '\u{7fc}'),
                    ('\u{82e}', '\u{82f}'),
                    ('\u{83f}', '\u{83f}'),
                    ('\u{85c}', '\u{85d}'),
                    ('\u{85f}', '\u{85f}'),
                    ('\u{86b}', '\u{86f}'),
                    ('\u{88f}', '\u{88f}'),
                    ('\u{892}', '\u{896}'),
                    ('\u{984}', '\u{984}'),
                    ('\u{98d}', '\u{98e}'),
                    ('\u{991}', '\u{992}'),
                    ('\u{9a9}', '\u{9a9}'),
                    ('\u{9b1}', '\u{9b1}'),
                    ('\u{9b3}', '\u{9b5}'),
                    ('\u{9ba}', '\u{9bb}'),
                    ('\u{9c5}', '\u{9c6}'),
                    ('\u{9c9}', '\u{9ca}'),
                    ('\u{9cf}', '\u{9d6}'),
                    ('\u{9d8}', '\u{9db}'),
                    ('\u{9de}', '\u{9de}'),
                    ('\u{9e4}', '\u{9e5}'),
                    ('\u{9ff}', '\u{a00}'),
                    ('\u{a04}', '\u{a04}'),
                    ('\u{a0b}', '\u{a0e}'),
                    ('\u{a11}', '\u{a12}'),
                    ('\u{a29}', '\u{a29}'),
                    ('\u{a31}', '\u{a31}'),
                    ('\u{a34}', '\u{a34}'),
                    ('\u{a37}', '\u{a37}'),
                    ('\u{a3a}', '\u{a3b}'),
                    ('\u{a3d}', '\u{a3d}'),
                    ('\u{a43}', '\u{a46}'),
                    ('\u{a49}', '\u{a4a}'),
                    ('\u{a4e}', '\u{a50}'),
                    ('\u{a52}', '\u{a58}'),
                    ('\u{a5d}', '\u{a5d}'),
                    ('\u{a5f}', '\u{a65}'),
                    ('\u{a77}', '\u{a80}'),
                    ('\u{a84}', '\u{a84}'),
                    ('\u{a8e}', '\u{a8e}'),
                    ('\u{a92}', '\u{a92}'),
                    ('\u{aa9}', '\u{aa9}'),
                    ('\u{ab1}', '\u{ab1}'),
                    ('\u{ab4}', '\u{ab4}'),
                    ('\u{aba}', '\u{abb}'),
                    ('\u{ac6}', '\u{ac6}'),
                    ('\u{aca}', '\u{aca}'),
                    ('\u{ace}', '\u{acf}'),
                    ('\u{ad1}', '\u{adf}'),
                    ('\u{ae4}', '\u{ae5}'),
                    ('\u{af2}', '\u{af8}'),
                    ('\u{b00}', '\u{b00}'),
                    ('\u{b04}', '\u{b04}'),
                    ('\u{b0d}', '\u{b0e}'),
                    ('\u{b11}', '\u{b12}'),
                    ('\u{b29}', '\u{b29}'),
                    ('\u{b31}', '\u{b31}'),
                    ('\u{b34}', '\u{b34}'),
                    ('\u{b3a}', '\u{b3b}'),
                    ('\u{b45}', '\u{b46}'),
                    ('\u{b49}', '\u{b4a}'),
                    ('\u{b4e}', '\u{b54}'),
                    ('\u{b58}', '\u{b5b}'),
                    ('\u{b5e}', '\u{b5e}'),
                    ('\u{b64}', '\u{b65}'),
                    ('\u{b78}', '\u{b81}'),
                    ('\u{b84}', '\u{b84}'),
                    ('\u{b8b}', '\u{b8d}'),
                    ('\u{b91}', '\u{b91}'),
                    ('\u{b96}', '\u{b98}'),
                    ('\u{b9b}', '\u{b9b}'),
                    ('\u{b9d}', '\u{b9d}'),
                    ('\u{ba0}', '\u{ba2}'),
                    ('\u{ba5}', '\u{ba7}'),
                    ('\u{bab}', '\u{bad}'),
                    ('\u{bba}', '\u{bbd}'),
                    ('\u{bc3}', '\u{bc5}'),
                    ('\u{bc9}', '\u{bc9}'),
                    ('\u{bce}', '\u{bcf}'),
                    ('\u{bd1}', '\u{bd6}'),
                    ('\u{bd8}', '\u{be5}'),
                    ('\u{bfb}', '\u{bff}'),
                    ('\u{c0d}', '\u{c0d}'),
                    ('\u{c11}', '\u{c11}'),
                    ('\u{c29}', '\u{c29}'),
                    ('\u{c3a}', '\u{c3b}'),
                    ('\u{c45}', '\u{c45}'),
                    ('\u{c49}', '\u{c49}'),
                    ('\u{c4e}', '\u{c54}'),
                    ('\u{c57}', '\u{c57}'),
                    ('\u{c5b}', '\u{c5c}'),
                    ('\u{c5e}', '\u{c5f}'),
                    ('\u{c64}', '\u{c65}'),
                    ('\u{c70}', '\u{c76}'),
                    ('\u{c8d}', '\u{c8d}'),
                    ('\u{c91}', '\u{c91}'),
                    ('\u{ca9}', '\u{ca9}'),
                    ('\u{cb4}', '\u{cb4}'),
                    ('\u{cba}', '\u{cbb}'),
                    ('\u{cc5}', '\u{cc5}'),
                    ('\u{cc9}', '\u{cc9}'),
                    ('\u{cce}', '\u{cd4}'),
                    ('\u{cd7}', '\u{cdc}'),
                    ('\u{cdf}', '\u{cdf}'),
                    ('\u{ce4}', '\u{ce5}'),
                    ('\u{cf0}', '\u{cf0}'),
                    ('\u{cf4}', '\u{cff}'),
                    ('\u{d0d}', '\u{d0d}'),
                    ('\u{d11}', '\u{d11}'),
                    ('\u{d45}', '\u{d45}'),
                    ('\u{d49}', '\u{d49}'),
                    ('\u{d50}', '\u{d53}'),
                    ('\u{d64}', '\u{d65}'),
                    ('\u{d80}', '\u{d80}'),
                    ('\u{d84}', '\u{d84}'),
                    ('\u{d97}', '\u{d99}'),
                    ('\u{db2}', '\u{db2}'),
                    ('\u{dbc}', '\u{dbc}'),
                    ('\u{dbe}', '\u{dbf}'),
                    ('\u{dc7}', '\u{dc9}'),
                    ('\u{dcb}', '\u{dce}'),
                    ('\u{dd5}', '\u{dd5}'),
                    ('\u{dd7}', '\u{dd7}'),
                    ('\u{de0}', '\u{de5}'),
                    ('\u{df0}', '\u{df1}'),
                    ('\u{df5}', '\u{e00}'),
                    ('\u{e3b}', '\u{e3e}'),
                    ('\u{e5c}', '\u{e80}'),
                    ('\u{e83}', '\u{e83}'),
                    ('\u{e85}', '\u{e85}'),
                    ('\u{e8b}', '\u{e8b}'),
                    ('\u{ea4}', '\u{ea4}'),
                    ('\u{ea6}', '\u{ea6}'),
                    ('\u{ebe}', '\u{ebf}'),
                    ('\u{ec5}', '\u{ec5}'),
                    ('\u{ec7}', '\u{ec7}'),
                    ('\u{ecf}', '\u{ecf}'),
                    ('\u{eda}', '\u{edb}'),
                    ('\u{ee0}', '\u{eff}'),
                    ('\u{f48}', '\u{f48}'),
                    ('\u{f6d}', '\u{f70}'),
                    ('\u{f98}', '\u{f98}'),
                    ('\u{fbd}', '\u{fbd}'),
                    ('\u{fcd}', '\u{fcd}'),
                    ('\u{fdb}', '\u{fff}'),
                    ('\u{10c6}', '\u{10c6}'),
                    ('\u{10c8}', '\u{10cc}'),
                    ('\u{10ce}', '\u{10cf}'),
                    ('\u{1249}', '\u{1249}'),
                    ('\u{124e}', '\u{124f}'),
                    ('\u{1257}', '\u{1257}'),
                    ('\u{1259}', '\u{1259}'),
                    ('\u{125e}', '\u{125f}'),
                    ('\u{1289}', '\u{1289}'),
                    ('\u{128e}', '\u{128f}'),
                    ('\u{12b1}', '\u{12b1}'),
                    ('\u{12b6}', '\u{12b7}'),
                    ('\u{12bf}', '\u{12bf}'),
                    ('\u{12c1}', '\u{12c1}'),
                    ('\u{12c6}', '\u{12c7}'),
                    ('\u{12d7}', '\u{12d7}'),
                    ('\u{1311}', '\u{1311}'),
                    ('\u{1316}', '\u{1317}'),
                    ('\u{135b}', '\u{135c}'),
                    ('\u{137d}', '\u{137f}'),
                    ('\u{139a}', '\u{139f}'),
                    ('\u{13f6}', '\u{13f7}'),
                    ('\u{13fe}', '\u{13ff}'),
                    ('\u{169d}', '\u{169f}'),
                    ('\u{16f9}', '\u{16ff}'),
                    ('\u{1716}', '\u{171e}'),
                    ('\u{1737}', '\u{173f}'),
                    ('\u{1754}', '\u{175f}'),
                    ('\u{176d}', '\u{176d}'),
                    ('\u{1771}', '\u{1771}'),
                    ('\u{1774}', '\u{177f}'),
                    ('\u{17de}', '\u{17df}'),
                    ('\u{17ea}', '\u{17ef}'),
                    ('\u{17fa}', '\u{17ff}'),
                    ('\u{181a}', '\u{181f}'),
                    ('\u{1879}', '\u{187f}'),
                    ('\u{18ab}', '\u{18af}'),
                    ('\u{18f6}', '\u{18ff}'),
                    ('\u{191f}', '\u{191f}'),
                    ('\u{192c}', '\u{192f}'),
                    ('\u{193c}', '\u{193f}'),
                    ('\u{1941}', '\u{1943}'),
                    ('\u{196e}', '\u{196f}'),
                    ('\u{1975}', '\u{197f}'),
                    ('\u{19ac}', '\u{19af}'),
                    ('\u{19ca}', '\u{19cf}'),
                    ('\u{19db}', '\u{19dd}'),
                    ('\u{1a1c}', '\u{1a1d}'),
                    ('\u{1a5f}', '\u{1a5f}'),
                    ('\u{1a7d}', '\u{1a7e}'),
                    ('\u{1a8a}', '\u{1a8f}'),
                    ('\u{1a9a}', '\u{1a9f}'),
                    ('\u{1aae}', '\u{1aaf}'),
                    ('\u{1acf}', '\u{1aff}'),
                    ('\u{1b4d}', '\u{1b4d}'),
                    ('\u{1bf4}', '\u{1bfb}'),
                    ('\u{1c38}', '\u{1c3a}'),
                    ('\u{1c4a}', '\u{1c4c}'),
                    ('\u{1c8b}', '\u{1c8f}'),
                    ('\u{1cbb}', '\u{1cbc}'),
                    ('\u{1cc8}', '\u{1ccf}'),
                    ('\u{1cfb}', '\u{1cff}'),
                    ('\u{1f16}', '\u{1f17}'),
                    ('\u{1f1e}', '\u{1f1f}'),
                    ('\u{1f46}', '\u{1f47}'),
                    ('\u{1f4e}', '\u{1f4f}'),
                    ('\u{1f58}', '\u{1f58}'),
                    ('\u{1f5a}', '\u{1f5a}'),
                    ('\u{1f5c}', '\u{1f5c}'),
                    ('\u{1f5e}', '\u{1f5e}'),
                    ('\u{1f7e}', '\u{1f7f}'),
                    ('\u{1fb5}', '\u{1fb5}'),
                    ('\u{1fc5}', '\u{1fc5}'),
                    ('\u{1fd4}', '\u{1fd5}'),
                    ('\u{1fdc}', '\u{1fdc}'),
                    ('\u{1ff0}', '\u{1ff1}'),
                    ('\u{1ff5}', '\u{1ff5}'),
                    ('\u{1fff}', '\u{1fff}'),
                    ('\u{2065}', '\u{2065}'),
                    ('\u{2072}', '\u{2073}'),
                    ('\u{208f}', '\u{208f}'),
                    ('\u{209d}', '\u{209f}'),
                    ('\u{20c1}', '\u{20cf}'),
                    ('\u{20f1}', '\u{20ff}'),
                    ('\u{218c}', '\u{218f}'),
                    ('\u{242a}', '\u{243f}'),
                    ('\u{244b}', '\u{245f}'),
                    ('\u{2b74}', '\u{2b75}'),
                    ('\u{2b96}', '\u{2b96}'),
                    ('\u{2cf4}', '\u{2cf8}'),
                    ('\u{2d26}', '\u{2d26}'),
                    ('\u{2d28}', '\u{2d2c}'),
                    ('\u{2d2e}', '\u{2d2f}'),
                    ('\u{2d68}', '\u{2d6e}'),
                    ('\u{2d71}', '\u{2d7e}'),
                    ('\u{2d97}', '\u{2d9f}'),
                    ('\u{2da7}', '\u{2da7}'),
                    ('\u{2daf}', '\u{2daf}'),
                    ('\u{2db7}', '\u{2db7}'),
                    ('\u{2dbf}', '\u{2dbf}'),
                    ('\u{2dc7}', '\u{2dc7}'),
                    ('\u{2dcf}', '\u{2dcf}'),
                    ('\u{2dd7}', '\u{2dd7}'),
                    ('\u{2ddf}', '\u{2ddf}'),
                    ('\u{2e5e}', '\u{2e7f}'),
                    ('\u{2e9a}', '\u{2e9a}'),
                    ('\u{2ef4}', '\u{2eff}'),
                    ('\u{2fd6}', '\u{2fef}'),
                    ('\u{3040}', '\u{3040}'),
                    ('\u{3097}', '\u{3098}'),
                    ('\u{3100}', '\u{3104}'),
                    ('\u{3130}', '\u{3130}'),
                    ('\u{318f}', '\u{318f}'),
                    ('\u{31e6}', '\u{31ee}'),
                    ('\u{321f}', '\u{321f}'),
                    ('\u{a48d}', '\u{a48f}'),
                    ('\u{a4c7}', '\u{a4cf}'),
                    ('\u{a62c}', '\u{a63f}'),
                    ('\u{a6f8}', '\u{a6ff}'),
                    ('\u{a7ce}', '\u{a7cf}'),
                    ('\u{a7d2}', '\u{a7d2}'),
                    ('\u{a7d4}', '\u{a7d4}'),
                    ('\u{a7dd}', '\u{a7f1}'),
                    ('\u{a82d}', '\u{a82f}'),
                    ('\u{a83a}', '\u{a83f}'),
                    ('\u{a878}', '\u{a87f}'),
                    ('\u{a8c6}', '\u{a8cd}'),
                    ('\u{a8da}', '\u{a8df}'),
                    ('\u{a954}', '\u{a95e}'),
                    ('\u{a97d}', '\u{a97f}'),
                    ('\u{a9ce}', '\u{a9ce}'),
                    ('\u{a9da}', '\u{a9dd}'),
                    ('\u{a9ff}', '\u{a9ff}'),
                    ('\u{aa37}', '\u{aa3f}'),
                    ('\u{aa4e}', '\u{aa4f}'),
                    ('\u{aa5a}', '\u{aa5b}'),
                    ('\u{aac3}', '\u{aada}'),
                    ('\u{aaf7}', '\u{ab00}'),
                    ('\u{ab07}', '\u{ab08}'),
                    ('\u{ab0f}', '\u{ab10}'),
                    ('\u{ab17}', '\u{ab1f}'),
                    ('\u{ab27}', '\u{ab27}'),
                    ('\u{ab2f}', '\u{ab2f}'),
                    ('\u{ab6c}', '\u{ab6f}'),
                    ('\u{abee}', '\u{abef}'),
                    ('\u{abfa}', '\u{abff}'),
                    ('\u{d7a4}', '\u{d7af}'),
                    ('\u{d7c7}', '\u{d7ca}'),
                    ('\u{d7fc}', '\u{d7ff}'),
                    ('\u{fa6e}', '\u{fa6f}'),
                    ('\u{fada}', '\u{faff}'),
                    ('\u{fb07}', '\u{fb12}'),
                    ('\u{fb18}', '\u{fb1c}'),
                    ('\u{fb37}', '\u{fb37}'),
                    ('\u{fb3d}', '\u{fb3d}'),
                    ('\u{fb3f}', '\u{fb3f}'),
                    ('\u{fb42}', '\u{fb42}'),
                    ('\u{fb45}', '\u{fb45}'),
                    ('\u{fbc3}', '\u{fbd2}'),
                    ('\u{fd90}', '\u{fd91}'),
                    ('\u{fdc8}', '\u{fdce}'),
                    ('\u{fdd0}', '\u{fdef}'),
                    ('\u{fe1a}', '\u{fe1f}'),
                    ('\u{fe53}', '\u{fe53}'),
                    ('\u{fe67}', '\u{fe67}'),
                    ('\u{fe6c}', '\u{fe6f}'),
                    ('\u{fe75}', '\u{fe75}'),
                    ('\u{fefd}', '\u{fefe}'),
                    ('\u{ff00}', '\u{ff00}'),
                    ('\u{ffbf}', '\u{ffc1}'),
                    ('\u{ffc8}', '\u{ffc9}'),
                    ('\u{ffd0}', '\u{ffd1}'),
                    ('\u{ffd8}', '\u{ffd9}'),
                    ('\u{ffdd}', '\u{ffdf}'),
                    ('\u{ffe7}', '\u{ffe7}'),
                    ('\u{ffef}', '\u{fff8}'),
                    ('\u{fffe}', '\u{ffff}'),
                    ('\u{1000c}', '\u{1000c}'),
                    ('\u{10027}', '\u{10027}'),
                    ('\u{1003b}', '\u{1003b}'),
                    ('\u{1003e}', '\u{1003e}'),
                    ('\u{1004e}', '\u{1004f}'),
                    ('\u{1005e}', '\u{1007f}'),
                    ('\u{100fb}', '\u{100ff}'),
                    ('\u{10103}', '\u{10106}'),
                    ('\u{10134}', '\u{10136}'),
                    ('\u{1018f}', '\u{1018f}'),
                    ('\u{1019d}', '\u{1019f}'),
                    ('\u{101a1}', '\u{101cf}'),
                    ('\u{101fe}', '\u{1027f}'),
                    ('\u{1029d}', '\u{1029f}'),
                    ('\u{102d1}', '\u{102df}'),
                    ('\u{102fc}', '\u{102ff}'),
                    ('\u{10324}', '\u{1032c}'),
                    ('\u{1034b}', '\u{1034f}'),
                    ('\u{1037b}', '\u{1037f}'),
                    ('\u{1039e}', '\u{1039e}'),
                    ('\u{103c4}', '\u{103c7}'),
                    ('\u{103d6}', '\u{103ff}'),
                    ('\u{1049e}', '\u{1049f}'),
                    ('\u{104aa}', '\u{104af}'),
                    ('\u{104d4}', '\u{104d7}'),
                    ('\u{104fc}', '\u{104ff}'),
                    ('\u{10528}', '\u{1052f}'),
                    ('\u{10564}', '\u{1056e}'),
                    ('\u{1057b}', '\u{1057b}'),
                    ('\u{1058b}', '\u{1058b}'),
                    ('\u{10593}', '\u{10593}'),
                    ('\u{10596}', '\u{10596}'),
                    ('\u{105a2}', '\u{105a2}'),
                    ('\u{105b2}', '\u{105b2}'),
                    ('\u{105ba}', '\u{105ba}'),
                    ('\u{105bd}', '\u{105bf}'),
                    ('\u{105f4}', '\u{105ff}'),
                    ('\u{10737}', '\u{1073f}'),
                    ('\u{10756}', '\u{1075f}'),
                    ('\u{10768}', '\u{1077f}'),
                    ('\u{10786}', '\u{10786}'),
                    ('\u{107b1}', '\u{107b1}'),
                    ('\u{107bb}', '\u{107ff}'),
                    ('\u{10806}', '\u{10807}'),
                    ('\u{10809}', '\u{10809}'),
                    ('\u{10836}', '\u{10836}'),
                    ('\u{10839}', '\u{1083b}'),
                    ('\u{1083d}', '\u{1083e}'),
                    ('\u{10856}', '\u{10856}'),
                    ('\u{1089f}', '\u{108a6}'),
                    ('\u{108b0}', '\u{108df}'),
                    ('\u{108f3}', '\u{108f3}'),
                    ('\u{108f6}', '\u{108fa}'),
                    ('\u{1091c}', '\u{1091e}'),
                    ('\u{1093a}', '\u{1093e}'),
                    ('\u{10940}', '\u{1097f}'),
                    ('\u{109b8}', '\u{109bb}'),
                    ('\u{109d0}', '\u{109d1}'),
                    ('\u{10a04}', '\u{10a04}'),
                    ('\u{10a07}', '\u{10a0b}'),
                    ('\u{10a14}', '\u{10a14}'),
                    ('\u{10a18}', '\u{10a18}'),
                    ('\u{10a36}', '\u{10a37}'),
                    ('\u{10a3b}', '\u{10a3e}'),
                    ('\u{10a49}', '\u{10a4f}'),
                    ('\u{10a59}', '\u{10a5f}'),
                    ('\u{10aa0}', '\u{10abf}'),
                    ('\u{10ae7}', '\u{10aea}'),
                    ('\u{10af7}', '\u{10aff}'),
                    ('\u{10b36}', '\u{10b38}'),
                    ('\u{10b56}', '\u{10b57}'),
                    ('\u{10b73}', '\u{10b77}'),
                    ('\u{10b92}', '\u{10b98}'),
                    ('\u{10b9d}', '\u{10ba8}'),
                    ('\u{10bb0}', '\u{10bff}'),
                    ('\u{10c49}', '\u{10c7f}'),
                    ('\u{10cb3}', '\u{10cbf}'),
                    ('\u{10cf3}', '\u{10cf9}'),
                    ('\u{10d28}', '\u{10d2f}'),
                    ('\u{10d3a}', '\u{10d3f}'),
                    ('\u{10d66}', '\u{10d68}'),
                    ('\u{10d86}', '\u{10d8d}'),
                    ('\u{10d90}', '\u{10e5f}'),
                    ('\u{10e7f}', '\u{10e7f}'),
                    ('\u{10eaa}', '\u{10eaa}'),
                    ('\u{10eae}', '\u{10eaf}'),
                    ('\u{10eb2}', '\u{10ec1}'),
                    ('\u{10ec5}', '\u{10efb}'),
                    ('\u{10f28}', '\u{10f2f}'),
                    ('\u{10f5a}', '\u{10f6f}'),
                    ('\u{10f8a}', '\u{10faf}'),
                    ('\u{10fcc}', '\u{10fdf}'),
                    ('\u{10ff7}', '\u{10fff}'),
                    ('\u{1104e}', '\u{11051}'),
                    ('\u{11076}', '\u{1107e}'),
                    ('\u{110c3}', '\u{110cc}'),
                    ('\u{110ce}', '\u{110cf}'),
                    ('\u{110e9}', '\u{110ef}'),
                    ('\u{110fa}', '\u{110ff}'),
                    ('\u{11135}', '\u{11135}'),
                    ('\u{11148}', '\u{1114f}'),
                    ('\u{11177}', '\u{1117f}'),
                    ('\u{111e0}', '\u{111e0}'),
                    ('\u{111f5}', '\u{111ff}'),
                    ('\u{11212}', '\u{11212}'),
                    ('\u{11242}', '\u{1127f}'),
                    ('\u{11287}', '\u{11287}'),
                    ('\u{11289}', '\u{11289}'),
                    ('\u{1128e}', '\u{1128e}'),
                    ('\u{1129e}', '\u{1129e}'),
                    ('\u{112aa}', '\u{112af}'),
                    ('\u{112eb}', '\u{112ef}'),
                    ('\u{112fa}', '\u{112ff}'),
                    ('\u{11304}', '\u{11304}'),
                    ('\u{1130d}', '\u{1130e}'),
                    ('\u{11311}', '\u{11312}'),
                    ('\u{11329}', '\u{11329}'),
                    ('\u{11331}', '\u{11331}'),
                    ('\u{11334}', '\u{11334}'),
                    ('\u{1133a}', '\u{1133a}'),
                    ('\u{11345}', '\u{11346}'),
                    ('\u{11349}', '\u{1134a}'),
                    ('\u{1134e}', '\u{1134f}'),
                    ('\u{11351}', '\u{11356}'),
                    ('\u{11358}', '\u{1135c}'),
                    ('\u{11364}', '\u{11365}'),
                    ('\u{1136d}', '\u{1136f}'),
                    ('\u{11375}', '\u{1137f}'),
                    ('\u{1138a}', '\u{1138a}'),
                    ('\u{1138c}', '\u{1138d}'),
                    ('\u{1138f}', '\u{1138f}'),
                    ('\u{113b6}', '\u{113b6}'),
                    ('\u{113c1}', '\u{113c1}'),
                    ('\u{113c3}', '\u{113c4}'),
                    ('\u{113c6}', '\u{113c6}'),
                    ('\u{113cb}', '\u{113cb}'),
                    ('\u{113d6}', '\u{113d6}'),
                    ('\u{113d9}', '\u{113e0}'),
                    ('\u{113e3}', '\u{113ff}'),
                    ('\u{1145c}', '\u{1145c}'),
                    ('\u{11462}', '\u{1147f}'),
                    ('\u{114c8}', '\u{114cf}'),
                    ('\u{114da}', '\u{1157f}'),
                    ('\u{115b6}', '\u{115b7}'),
                    ('\u{115de}', '\u{115ff}'),
                    ('\u{11645}', '\u{1164f}'),
                    ('\u{1165a}', '\u{1165f}'),
                    ('\u{1166d}', '\u{1167f}'),
                    ('\u{116ba}', '\u{116bf}'),
                    ('\u{116ca}', '\u{116cf}'),
                    ('\u{116e4}', '\u{116ff}'),
                    ('\u{1171b}', '\u{1171c}'),
                    ('\u{1172c}', '\u{1172f}'),
                    ('\u{11747}', '\u{117ff}'),
                    ('\u{1183c}', '\u{1189f}'),
                    ('\u{118f3}', '\u{118fe}'),
                    ('\u{11907}', '\u{11908}'),
                    ('\u{1190a}', '\u{1190b}'),
                    ('\u{11914}', '\u{11914}'),
                    ('\u{11917}', '\u{11917}'),
                    ('\u{11936}', '\u{11936}'),
                    ('\u{11939}', '\u{1193a}'),
                    ('\u{11947}', '\u{1194f}'),
                    ('\u{1195a}', '\u{1199f}'),
                    ('\u{119a8}', '\u{119a9}'),
                    ('\u{119d8}', '\u{119d9}'),
                    ('\u{119e5}', '\u{119ff}'),
                    ('\u{11a48}', '\u{11a4f}'),
                    ('\u{11aa3}', '\u{11aaf}'),
                    ('\u{11af9}', '\u{11aff}'),
                    ('\u{11b0a}', '\u{11bbf}'),
                    ('\u{11be2}', '\u{11bef}'),
                    ('\u{11bfa}', '\u{11bff}'),
                    ('\u{11c09}', '\u{11c09}'),
                    ('\u{11c37}', '\u{11c37}'),
                    ('\u{11c46}', '\u{11c4f}'),
                    ('\u{11c6d}', '\u{11c6f}'),
                    ('\u{11c90}', '\u{11c91}'),
                    ('\u{11ca8}', '\u{11ca8}'),
                    ('\u{11cb7}', '\u{11cff}'),
                    ('\u{11d07}', '\u{11d07}'),
                    ('\u{11d0a}', '\u{11d0a}'),
                    ('\u{11d37}', '\u{11d39}'),
                    ('\u{11d3b}', '\u{11d3b}'),
                    ('\u{11d3e}', '\u{11d3e}'),
                    ('\u{11d48}', '\u{11d4f}'),
                    ('\u{11d5a}', '\u{11d5f}'),
                    ('\u{11d66}', '\u{11d66}'),
                    ('\u{11d69}', '\u{11d69}'),
                    ('\u{11d8f}', '\u{11d8f}'),
                    ('\u{11d92}', '\u{11d92}'),
                    ('\u{11d99}', '\u{11d9f}'),
                    ('\u{11daa}', '\u{11edf}'),
                    ('\u{11ef9}', '\u{11eff}'),
                    ('\u{11f11}', '\u{11f11}'),
                    ('\u{11f3b}', '\u{11f3d}'),
                    ('\u{11f5b}', '\u{11faf}'),
                    ('\u{11fb1}', '\u{11fbf}'),
                    ('\u{11ff2}', '\u{11ffe}'),
                    ('\u{1239a}', '\u{123ff}'),
                    ('\u{1246f}', '\u{1246f}'),
                    ('\u{12475}', '\u{1247f}'),
                    ('\u{12544}', '\u{12f8f}'),
                    ('\u{12ff3}', '\u{12fff}'),
                    ('\u{13456}', '\u{1345f}'),
                    ('\u{143fb}', '\u{143ff}'),
                    ('\u{14647}', '\u{160ff}'),
                    ('\u{1613a}', '\u{167ff}'),
                    ('\u{16a39}', '\u{16a3f}'),
                    ('\u{16a5f}', '\u{16a5f}'),
                    ('\u{16a6a}', '\u{16a6d}'),
                    ('\u{16abf}', '\u{16abf}'),
                    ('\u{16aca}', '\u{16acf}'),
                    ('\u{16aee}', '\u{16aef}'),
                    ('\u{16af6}', '\u{16aff}'),
                    ('\u{16b46}', '\u{16b4f}'),
                    ('\u{16b5a}', '\u{16b5a}'),
                    ('\u{16b62}', '\u{16b62}'),
                    ('\u{16b78}', '\u{16b7c}'),
                    ('\u{16b90}', '\u{16d3f}'),
                    ('\u{16d7a}', '\u{16e3f}'),
                    ('\u{16e9b}', '\u{16eff}'),
                    ('\u{16f4b}', '\u{16f4e}'),
                    ('\u{16f88}', '\u{16f8e}'),
                    ('\u{16fa0}', '\u{16fdf}'),
                    ('\u{16fe5}', '\u{16fef}'),
                    ('\u{16ff2}', '\u{16fff}'),
                    ('\u{187f8}', '\u{187ff}'),
                    ('\u{18cd6}', '\u{18cfe}'),
                    ('\u{18d09}', '\u{1afef}'),
                    ('\u{1aff4}', '\u{1aff4}'),
                    ('\u{1affc}', '\u{1affc}'),
                    ('\u{1afff}', '\u{1afff}'),
                    ('\u{1b123}', '\u{1b131}'),
                    ('\u{1b133}', '\u{1b14f}'),
                    ('\u{1b153}', '\u{1b154}'),
                    ('\u{1b156}', '\u{1b163}'),
                    ('\u{1b168}', '\u{1b16f}'),
                    ('\u{1b2fc}', '\u{1bbff}'),
                    ('\u{1bc6b}', '\u{1bc6f}'),
                    ('\u{1bc7d}', '\u{1bc7f}'),
                    ('\u{1bc89}', '\u{1bc8f}'),
                    ('\u{1bc9a}', '\u{1bc9b}'),
                    ('\u{1bca4}', '\u{1cbff}'),
                    ('\u{1ccfa}', '\u{1ccff}'),
                    ('\u{1ceb4}', '\u{1ceff}'),
                    ('\u{1cf2e}', '\u{1cf2f}'),
                    ('\u{1cf47}', '\u{1cf4f}'),
                    ('\u{1cfc4}', '\u{1cfff}'),
                    ('\u{1d0f6}', '\u{1d0ff}'),
                    ('\u{1d127}', '\u{1d128}'),
                    ('\u{1d1eb}', '\u{1d1ff}'),
                    ('\u{1d246}', '\u{1d2bf}'),
                    ('\u{1d2d4}', '\u{1d2df}'),
                    ('\u{1d2f4}', '\u{1d2ff}'),
                    ('\u{1d357}', '\u{1d35f}'),
                    ('\u{1d379}', '\u{1d3ff}'),
                    ('\u{1d455}', '\u{1d455}'),
                    ('\u{1d49d}', '\u{1d49d}'),
                    ('\u{1d4a0}', '\u{1d4a1}'),
                    ('\u{1d4a3}', '\u{1d4a4}'),
                    ('\u{1d4a7}', '\u{1d4a8}'),
                    ('\u{1d4ad}', '\u{1d4ad}'),
                    ('\u{1d4ba}', '\u{1d4ba}'),
                    ('\u{1d4bc}', '\u{1d4bc}'),
                    ('\u{1d4c4}', '\u{1d4c4}'),
                    ('\u{1d506}', '\u{1d506}'),
                    ('\u{1d50b}', '\u{1d50c}'),
                    ('\u{1d515}', '\u{1d515}'),
                    ('\u{1d51d}', '\u{1d51d}'),
                    ('\u{1d53a}', '\u{1d53a}'),
                    ('\u{1d53f}', '\u{1d53f}'),
                    ('\u{1d545}', '\u{1d545}'),
                    ('\u{1d547}', '\u{1d549}'),
                    ('\u{1d551}', '\u{1d551}'),
                    ('\u{1d6a6}', '\u{1d6a7}'),
                    ('\u{1d7cc}', '\u{1d7cd}'),
                    ('\u{1da8c}', '\u{1da9a}'),
                    ('\u{1daa0}', '\u{1daa0}'),
                    ('\u{1dab0}', '\u{1deff}'),
                    ('\u{1df1f}', '\u{1df24}'),
                    ('\u{1df2b}', '\u{1dfff}'),
                    ('\u{1e007}', '\u{1e007}'),
                    ('\u{1e019}', '\u{1e01a}'),
                    ('\u{1e022}', '\u{1e022}'),
                    ('\u{1e025}', '\u{1e025}'),
                    ('\u{1e02b}', '\u{1e02f}'),
                    ('\u{1e06e}', '\u{1e08e}'),
                    ('\u{1e090}', '\u{1e0ff}'),
                    ('\u{1e12d}', '\u{1e12f}'),
                    ('\u{1e13e}', '\u{1e13f}'),
                    ('\u{1e14a}', '\u{1e14d}'),
                    ('\u{1e150}', '\u{1e28f}'),
                    ('\u{1e2af}', '\u{1e2bf}'),
                    ('\u{1e2fa}', '\u{1e2fe}'),
                    ('\u{1e300}', '\u{1e4cf}'),
                    ('\u{1e4fa}', '\u{1e5cf}'),
                    ('\u{1e5fb}', '\u{1e5fe}'),
                    ('\u{1e600}', '\u{1e7df}'),
                    ('\u{1e7e7}', '\u{1e7e7}'),
                    ('\u{1e7ec}', '\u{1e7ec}'),
                    ('\u{1e7ef}', '\u{1e7ef}'),
                    ('\u{1e7ff}', '\u{1e7ff}'),
                    ('\u{1e8c5}', '\u{1e8c6}'),
                    ('\u{1e8d7}', '\u{1e8ff}'),
                    ('\u{1e94c}', '\u{1e94f}'),
                    ('\u{1e95a}', '\u{1e95d}'),
                    ('\u{1e960}', '\u{1ec70}'),
                    ('\u{1ecb5}', '\u{1ed00}'),
                    ('\u{1ed3e}', '\u{1edff}'),
                    ('\u{1ee04}', '\u{1ee04}'),
                    ('\u{1ee20}', '\u{1ee20}'),
                    ('\u{1ee23}', '\u{1ee23}'),
                    ('\u{1ee25}', '\u{1ee26}'),
                    ('\u{1ee28}', '\u{1ee28}'),
                    ('\u{1ee33}', '\u{1ee33}'),
                    ('\u{1ee38}', '\u{1ee38}'),
                    ('\u{1ee3a}', '\u{1ee3a}'),
                    ('\u{1ee3c}', '\u{1ee41}'),
                    ('\u{1ee43}', '\u{1ee46}'),
                    ('\u{1ee48}', '\u{1ee48}'),
                    ('\u{1ee4a}', '\u{1ee4a}'),
                    ('\u{1ee4c}', '\u{1ee4c}'),
                    ('\u{1ee50}', '\u{1ee50}'),
                    ('\u{1ee53}', '\u{1ee53}'),
                    ('\u{1ee55}', '\u{1ee56}'),
                    ('\u{1ee58}', '\u{1ee58}'),
                    ('\u{1ee5a}', '\u{1ee5a}'),
                    ('\u{1ee5c}', '\u{1ee5c}'),
                    ('\u{1ee5e}', '\u{1ee5e}'),
                    ('\u{1ee60}', '\u{1ee60}'),
                    ('\u{1ee63}', '\u{1ee63}'),
                    ('\u{1ee65}', '\u{1ee66}'),
                    ('\u{1ee6b}', '\u{1ee6b}'),
                    ('\u{1ee73}', '\u{1ee73}'),
                    ('\u{1ee78}', '\u{1ee78}'),
                    ('\u{1ee7d}', '\u{1ee7d}'),
                    ('\u{1ee7f}', '\u{1ee7f}'),
                    ('\u{1ee8a}', '\u{1ee8a}'),
                    ('\u{1ee9c}', '\u{1eea0}'),
                    ('\u{1eea4}', '\u{1eea4}'),
                    ('\u{1eeaa}', '\u{1eeaa}'),
                    ('\u{1eebc}', '\u{1eeef}'),
                    ('\u{1eef2}', '\u{1efff}'),
                    ('\u{1f02c}', '\u{1f02f}'),
                    ('\u{1f094}', '\u{1f09f}'),
                    ('\u{1f0af}', '\u{1f0b0}'),
                    ('\u{1f0c0}', '\u{1f0c0}'),
                    ('\u{1f0d0}', '\u{1f0d0}'),
                    ('\u{1f0f6}', '\u{1f0ff}'),
                    ('\u{1f1ae}', '\u{1f1e5}'),
                    ('\u{1f203}', '\u{1f20f}'),
                    ('\u{1f23c}', '\u{1f23f}'),
                    ('\u{1f249}', '\u{1f24f}'),
                    ('\u{1f252}', '\u{1f25f}'),
                    ('\u{1f266}', '\u{1f2ff}'),
                    ('\u{1f6d8}', '\u{1f6db}'),
                    ('\u{1f6ed}', '\u{1f6ef}'),
                    ('\u{1f6fd}', '\u{1f6ff}'),
                    ('\u{1f777}', '\u{1f77a}'),
                    ('\u{1f7da}', '\u{1f7df}'),
                    ('\u{1f7ec}', '\u{1f7ef}'),
                    ('\u{1f7f1}', '\u{1f7ff}'),
                    ('\u{1f80c}', '\u{1f80f}'),
                    ('\u{1f848}', '\u{1f84f}'),
                    ('\u{1f85a}', '\u{1f85f}'),
                    ('\u{1f888}', '\u{1f88f}'),
                    ('\u{1f8ae}', '\u{1f8af}'),
                    ('\u{1f8bc}', '\u{1f8bf}'),
                    ('\u{1f8c2}', '\u{1f8ff}'),
                    ('\u{1fa54}', '\u{1fa5f}'),
                    ('\u{1fa6e}', '\u{1fa6f}'),
                    ('\u{1fa7d}', '\u{1fa7f}'),
                    ('\u{1fa8a}', '\u{1fa8e}'),
                    ('\u{1fac7}', '\u{1facd}'),
                    ('\u{1fadd}', '\u{1fade}'),
                    ('\u{1faea}', '\u{1faef}'),
                    ('\u{1faf9}', '\u{1faff}'),
                    ('\u{1fb93}', '\u{1fb93}'),
                    ('\u{1fbfa}', '\u{1ffff}'),
                    ('\u{2a6e0}', '\u{2a6ff}'),
                    ('\u{2b73a}', '\u{2b73f}'),
                    ('\u{2b81e}', '\u{2b81f}'),
                    ('\u{2cea2}', '\u{2ceaf}'),
                    ('\u{2ebe1}', '\u{2ebef}'),
                    ('\u{2ee5e}', '\u{2f7ff}'),
                    ('\u{2fa1e}', '\u{2ffff}'),
                    ('\u{3134b}', '\u{3134f}'),
                    ('\u{323b0}', '\u{e0000}'),
                    ('\u{e0002}', '\u{e001f}'),
                    ('\u{e0080}', '\u{e00ff}'),
                    ('\u{e01f0}', '\u{effff}'),
                    ('\u{ffffe}', '\u{fffff}'),
                    ('\u{10fffe}', '\u{10ffff}'),
                ];

                pub const UPPERCASE_LETTER: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('À', 'Ö'),
                    ('Ø', 'Þ'),
                    ('Ā', 'Ā'),
                    ('Ă', 'Ă'),
                    ('Ą', 'Ą'),
                    ('Ć', 'Ć'),
                    ('Ĉ', 'Ĉ'),
                    ('Ċ', 'Ċ'),
                    ('Č', 'Č'),
                    ('Ď', 'Ď'),
                    ('Đ', 'Đ'),
                    ('Ē', 'Ē'),
                    ('Ĕ', 'Ĕ'),
                    ('Ė', 'Ė'),
                    ('Ę', 'Ę'),
                    ('Ě', 'Ě'),
                    ('Ĝ', 'Ĝ'),
                    ('Ğ', 'Ğ'),
                    ('Ġ', 'Ġ'),
                    ('Ģ', 'Ģ'),
                    ('Ĥ', 'Ĥ'),
                    ('Ħ', 'Ħ'),
                    ('Ĩ', 'Ĩ'),
                    ('Ī', 'Ī'),
                    ('Ĭ', 'Ĭ'),
                    ('Į', 'Į'),
                    ('İ', 'İ'),
                    ('Ĳ', 'Ĳ'),
                    ('Ĵ', 'Ĵ'),
                    ('Ķ', 'Ķ'),
                    ('Ĺ', 'Ĺ'),
                    ('Ļ', 'Ļ'),
                    ('Ľ', 'Ľ'),
                    ('Ŀ', 'Ŀ'),
                    ('Ł', 'Ł'),
                    ('Ń', 'Ń'),
                    ('Ņ', 'Ņ'),
                    ('Ň', 'Ň'),
                    ('Ŋ', 'Ŋ'),
                    ('Ō', 'Ō'),
                    ('Ŏ', 'Ŏ'),
                    ('Ő', 'Ő'),
                    ('Œ', 'Œ'),
                    ('Ŕ', 'Ŕ'),
                    ('Ŗ', 'Ŗ'),
                    ('Ř', 'Ř'),
                    ('Ś', 'Ś'),
                    ('Ŝ', 'Ŝ'),
                    ('Ş', 'Ş'),
                    ('Š', 'Š'),
                    ('Ţ', 'Ţ'),
                    ('Ť', 'Ť'),
                    ('Ŧ', 'Ŧ'),
                    ('Ũ', 'Ũ'),
                    ('Ū', 'Ū'),
                    ('Ŭ', 'Ŭ'),
                    ('Ů', 'Ů'),
                    ('Ű', 'Ű'),
                    ('Ų', 'Ų'),
                    ('Ŵ', 'Ŵ'),
                    ('Ŷ', 'Ŷ'),
                    ('Ÿ', 'Ź'),
                    ('Ż', 'Ż'),
                    ('Ž', 'Ž'),
                    ('Ɓ', 'Ƃ'),
                    ('Ƅ', 'Ƅ'),
                    ('Ɔ', 'Ƈ'),
                    ('Ɖ', 'Ƌ'),
                    ('Ǝ', 'Ƒ'),
                    ('Ɠ', 'Ɣ'),
                    ('Ɩ', 'Ƙ'),
                    ('Ɯ', 'Ɲ'),
                    ('Ɵ', 'Ơ'),
                    ('Ƣ', 'Ƣ'),
                    ('Ƥ', 'Ƥ'),
                    ('Ʀ', 'Ƨ'),
                    ('Ʃ', 'Ʃ'),
                    ('Ƭ', 'Ƭ'),
                    ('Ʈ', 'Ư'),
                    ('Ʊ', 'Ƴ'),
                    ('Ƶ', 'Ƶ'),
                    ('Ʒ', 'Ƹ'),
                    ('Ƽ', 'Ƽ'),
                    ('Ǆ', 'Ǆ'),
                    ('Ǉ', 'Ǉ'),
                    ('Ǌ', 'Ǌ'),
                    ('Ǎ', 'Ǎ'),
                    ('Ǐ', 'Ǐ'),
                    ('Ǒ', 'Ǒ'),
                    ('Ǔ', 'Ǔ'),
                    ('Ǖ', 'Ǖ'),
                    ('Ǘ', 'Ǘ'),
                    ('Ǚ', 'Ǚ'),
                    ('Ǜ', 'Ǜ'),
                    ('Ǟ', 'Ǟ'),
                    ('Ǡ', 'Ǡ'),
                    ('Ǣ', 'Ǣ'),
                    ('Ǥ', 'Ǥ'),
                    ('Ǧ', 'Ǧ'),
                    ('Ǩ', 'Ǩ'),
                    ('Ǫ', 'Ǫ'),
                    ('Ǭ', 'Ǭ'),
                    ('Ǯ', 'Ǯ'),
                    ('Ǳ', 'Ǳ'),
                    ('Ǵ', 'Ǵ'),
                    ('Ƕ', 'Ǹ'),
                    ('Ǻ', 'Ǻ'),
                    ('Ǽ', 'Ǽ'),
                    ('Ǿ', 'Ǿ'),
                    ('Ȁ', 'Ȁ'),
                    ('Ȃ', 'Ȃ'),
                    ('Ȅ', 'Ȅ'),
                    ('Ȇ', 'Ȇ'),
                    ('Ȉ', 'Ȉ'),
                    ('Ȋ', 'Ȋ'),
                    ('Ȍ', 'Ȍ'),
                    ('Ȏ', 'Ȏ'),
                    ('Ȑ', 'Ȑ'),
                    ('Ȓ', 'Ȓ'),
                    ('Ȕ', 'Ȕ'),
                    ('Ȗ', 'Ȗ'),
                    ('Ș', 'Ș'),
                    ('Ț', 'Ț'),
                    ('Ȝ', 'Ȝ'),
                    ('Ȟ', 'Ȟ'),
                    ('Ƞ', 'Ƞ'),
                    ('Ȣ', 'Ȣ'),
                    ('Ȥ', 'Ȥ'),
                    ('Ȧ', 'Ȧ'),
                    ('Ȩ', 'Ȩ'),
                    ('Ȫ', 'Ȫ'),
                    ('Ȭ', 'Ȭ'),
                    ('Ȯ', 'Ȯ'),
                    ('Ȱ', 'Ȱ'),
                    ('Ȳ', 'Ȳ'),
                    ('Ⱥ', 'Ȼ'),
                    ('Ƚ', 'Ⱦ'),
                    ('Ɂ', 'Ɂ'),
                    ('Ƀ', 'Ɇ'),
                    ('Ɉ', 'Ɉ'),
                    ('Ɋ', 'Ɋ'),
                    ('Ɍ', 'Ɍ'),
                    ('Ɏ', 'Ɏ'),
                    ('Ͱ', 'Ͱ'),
                    ('Ͳ', 'Ͳ'),
                    ('Ͷ', 'Ͷ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ώ'),
                    ('Α', 'Ρ'),
                    ('Σ', 'Ϋ'),
                    ('Ϗ', 'Ϗ'),
                    ('ϒ', 'ϔ'),
                    ('Ϙ', 'Ϙ'),
                    ('Ϛ', 'Ϛ'),
                    ('Ϝ', 'Ϝ'),
                    ('Ϟ', 'Ϟ'),
                    ('Ϡ', 'Ϡ'),
                    ('Ϣ', 'Ϣ'),
                    ('Ϥ', 'Ϥ'),
                    ('Ϧ', 'Ϧ'),
                    ('Ϩ', 'Ϩ'),
                    ('Ϫ', 'Ϫ'),
                    ('Ϭ', 'Ϭ'),
                    ('Ϯ', 'Ϯ'),
                    ('ϴ', 'ϴ'),
                    ('Ϸ', 'Ϸ'),
                    ('Ϲ', 'Ϻ'),
                    ('Ͻ', 'Я'),
                    ('Ѡ', 'Ѡ'),
                    ('Ѣ', 'Ѣ'),
                    ('Ѥ', 'Ѥ'),
                    ('Ѧ', 'Ѧ'),
                    ('Ѩ', 'Ѩ'),
                    ('Ѫ', 'Ѫ'),
                    ('Ѭ', 'Ѭ'),
                    ('Ѯ', 'Ѯ'),
                    ('Ѱ', 'Ѱ'),
                    ('Ѳ', 'Ѳ'),
                    ('Ѵ', 'Ѵ'),
                    ('Ѷ', 'Ѷ'),
                    ('Ѹ', 'Ѹ'),
                    ('Ѻ', 'Ѻ'),
                    ('Ѽ', 'Ѽ'),
                    ('Ѿ', 'Ѿ'),
                    ('Ҁ', 'Ҁ'),
                    ('Ҋ', 'Ҋ'),
                    ('Ҍ', 'Ҍ'),
                    ('Ҏ', 'Ҏ'),
                    ('Ґ', 'Ґ'),
                    ('Ғ', 'Ғ'),
                    ('Ҕ', 'Ҕ'),
                    ('Җ', 'Җ'),
                    ('Ҙ', 'Ҙ'),
                    ('Қ', 'Қ'),
                    ('Ҝ', 'Ҝ'),
                    ('Ҟ', 'Ҟ'),
                    ('Ҡ', 'Ҡ'),
                    ('Ң', 'Ң'),
                    ('Ҥ', 'Ҥ'),
                    ('Ҧ', 'Ҧ'),
                    ('Ҩ', 'Ҩ'),
                    ('Ҫ', 'Ҫ'),
                    ('Ҭ', 'Ҭ'),
                    ('Ү', 'Ү'),
                    ('Ұ', 'Ұ'),
                    ('Ҳ', 'Ҳ'),
                    ('Ҵ', 'Ҵ'),
                    ('Ҷ', 'Ҷ'),
                    ('Ҹ', 'Ҹ'),
                    ('Һ', 'Һ'),
                    ('Ҽ', 'Ҽ'),
                    ('Ҿ', 'Ҿ'),
                    ('Ӏ', 'Ӂ'),
                    ('Ӄ', 'Ӄ'),
                    ('Ӆ', 'Ӆ'),
                    ('Ӈ', 'Ӈ'),
                    ('Ӊ', 'Ӊ'),
                    ('Ӌ', 'Ӌ'),
                    ('Ӎ', 'Ӎ'),
                    ('Ӑ', 'Ӑ'),
                    ('Ӓ', 'Ӓ'),
                    ('Ӕ', 'Ӕ'),
                    ('Ӗ', 'Ӗ'),
                    ('Ә', 'Ә'),
                    ('Ӛ', 'Ӛ'),
                    ('Ӝ', 'Ӝ'),
                    ('Ӟ', 'Ӟ'),
                    ('Ӡ', 'Ӡ'),
                    ('Ӣ', 'Ӣ'),
                    ('Ӥ', 'Ӥ'),
                    ('Ӧ', 'Ӧ'),
                    ('Ө', 'Ө'),
                    ('Ӫ', 'Ӫ'),
                    ('Ӭ', 'Ӭ'),
                    ('Ӯ', 'Ӯ'),
                    ('Ӱ', 'Ӱ'),
                    ('Ӳ', 'Ӳ'),
                    ('Ӵ', 'Ӵ'),
                    ('Ӷ', 'Ӷ'),
                    ('Ӹ', 'Ӹ'),
                    ('Ӻ', 'Ӻ'),
                    ('Ӽ', 'Ӽ'),
                    ('Ӿ', 'Ӿ'),
                    ('Ԁ', 'Ԁ'),
                    ('Ԃ', 'Ԃ'),
                    ('Ԅ', 'Ԅ'),
                    ('Ԇ', 'Ԇ'),
                    ('Ԉ', 'Ԉ'),
                    ('Ԋ', 'Ԋ'),
                    ('Ԍ', 'Ԍ'),
                    ('Ԏ', 'Ԏ'),
                    ('Ԑ', 'Ԑ'),
                    ('Ԓ', 'Ԓ'),
                    ('Ԕ', 'Ԕ'),
                    ('Ԗ', 'Ԗ'),
                    ('Ԙ', 'Ԙ'),
                    ('Ԛ', 'Ԛ'),
                    ('Ԝ', 'Ԝ'),
                    ('Ԟ', 'Ԟ'),
                    ('Ԡ', 'Ԡ'),
                    ('Ԣ', 'Ԣ'),
                    ('Ԥ', 'Ԥ'),
                    ('Ԧ', 'Ԧ'),
                    ('Ԩ', 'Ԩ'),
                    ('Ԫ', 'Ԫ'),
                    ('Ԭ', 'Ԭ'),
                    ('Ԯ', 'Ԯ'),
                    ('Ա', 'Ֆ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('Ᲊ', 'Ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('Ḁ', 'Ḁ'),
                    ('Ḃ', 'Ḃ'),
                    ('Ḅ', 'Ḅ'),
                    ('Ḇ', 'Ḇ'),
                    ('Ḉ', 'Ḉ'),
                    ('Ḋ', 'Ḋ'),
                    ('Ḍ', 'Ḍ'),
                    ('Ḏ', 'Ḏ'),
                    ('Ḑ', 'Ḑ'),
                    ('Ḓ', 'Ḓ'),
                    ('Ḕ', 'Ḕ'),
                    ('Ḗ', 'Ḗ'),
                    ('Ḙ', 'Ḙ'),
                    ('Ḛ', 'Ḛ'),
                    ('Ḝ', 'Ḝ'),
                    ('Ḟ', 'Ḟ'),
                    ('Ḡ', 'Ḡ'),
                    ('Ḣ', 'Ḣ'),
                    ('Ḥ', 'Ḥ'),
                    ('Ḧ', 'Ḧ'),
                    ('Ḩ', 'Ḩ'),
                    ('Ḫ', 'Ḫ'),
                    ('Ḭ', 'Ḭ'),
                    ('Ḯ', 'Ḯ'),
                    ('Ḱ', 'Ḱ'),
                    ('Ḳ', 'Ḳ'),
                    ('Ḵ', 'Ḵ'),
                    ('Ḷ', 'Ḷ'),
                    ('Ḹ', 'Ḹ'),
                    ('Ḻ', 'Ḻ'),
                    ('Ḽ', 'Ḽ'),
                    ('Ḿ', 'Ḿ'),
                    ('Ṁ', 'Ṁ'),
                    ('Ṃ', 'Ṃ'),
                    ('Ṅ', 'Ṅ'),
                    ('Ṇ', 'Ṇ'),
                    ('Ṉ', 'Ṉ'),
                    ('Ṋ', 'Ṋ'),
                    ('Ṍ', 'Ṍ'),
                    ('Ṏ', 'Ṏ'),
                    ('Ṑ', 'Ṑ'),
                    ('Ṓ', 'Ṓ'),
                    ('Ṕ', 'Ṕ'),
                    ('Ṗ', 'Ṗ'),
                    ('Ṙ', 'Ṙ'),
                    ('Ṛ', 'Ṛ'),
                    ('Ṝ', 'Ṝ'),
                    ('Ṟ', 'Ṟ'),
                    ('Ṡ', 'Ṡ'),
                    ('Ṣ', 'Ṣ'),
                    ('Ṥ', 'Ṥ'),
                    ('Ṧ', 'Ṧ'),
                    ('Ṩ', 'Ṩ'),
                    ('Ṫ', 'Ṫ'),
                    ('Ṭ', 'Ṭ'),
                    ('Ṯ', 'Ṯ'),
                    ('Ṱ', 'Ṱ'),
                    ('Ṳ', 'Ṳ'),
                    ('Ṵ', 'Ṵ'),
                    ('Ṷ', 'Ṷ'),
                    ('Ṹ', 'Ṹ'),
                    ('Ṻ', 'Ṻ'),
                    ('Ṽ', 'Ṽ'),
                    ('Ṿ', 'Ṿ'),
                    ('Ẁ', 'Ẁ'),
                    ('Ẃ', 'Ẃ'),
                    ('Ẅ', 'Ẅ'),
                    ('Ẇ', 'Ẇ'),
                    ('Ẉ', 'Ẉ'),
                    ('Ẋ', 'Ẋ'),
                    ('Ẍ', 'Ẍ'),
                    ('Ẏ', 'Ẏ'),
                    ('Ẑ', 'Ẑ'),
                    ('Ẓ', 'Ẓ'),
                    ('Ẕ', 'Ẕ'),
                    ('ẞ', 'ẞ'),
                    ('Ạ', 'Ạ'),
                    ('Ả', 'Ả'),
                    ('Ấ', 'Ấ'),
                    ('Ầ', 'Ầ'),
                    ('Ẩ', 'Ẩ'),
                    ('Ẫ', 'Ẫ'),
                    ('Ậ', 'Ậ'),
                    ('Ắ', 'Ắ'),
                    ('Ằ', 'Ằ'),
                    ('Ẳ', 'Ẳ'),
                    ('Ẵ', 'Ẵ'),
                    ('Ặ', 'Ặ'),
                    ('Ẹ', 'Ẹ'),
                    ('Ẻ', 'Ẻ'),
                    ('Ẽ', 'Ẽ'),
                    ('Ế', 'Ế'),
                    ('Ề', 'Ề'),
                    ('Ể', 'Ể'),
                    ('Ễ', 'Ễ'),
                    ('Ệ', 'Ệ'),
                    ('Ỉ', 'Ỉ'),
                    ('Ị', 'Ị'),
                    ('Ọ', 'Ọ'),
                    ('Ỏ', 'Ỏ'),
                    ('Ố', 'Ố'),
                    ('Ồ', 'Ồ'),
                    ('Ổ', 'Ổ'),
                    ('Ỗ', 'Ỗ'),
                    ('Ộ', 'Ộ'),
                    ('Ớ', 'Ớ'),
                    ('Ờ', 'Ờ'),
                    ('Ở', 'Ở'),
                    ('Ỡ', 'Ỡ'),
                    ('Ợ', 'Ợ'),
                    ('Ụ', 'Ụ'),
                    ('Ủ', 'Ủ'),
                    ('Ứ', 'Ứ'),
                    ('Ừ', 'Ừ'),
                    ('Ử', 'Ử'),
                    ('Ữ', 'Ữ'),
                    ('Ự', 'Ự'),
                    ('Ỳ', 'Ỳ'),
                    ('Ỵ', 'Ỵ'),
                    ('Ỷ', 'Ỷ'),
                    ('Ỹ', 'Ỹ'),
                    ('Ỻ', 'Ỻ'),
                    ('Ỽ', 'Ỽ'),
                    ('Ỿ', 'Ỿ'),
                    ('Ἀ', 'Ἇ'),
                    ('Ἐ', 'Ἕ'),
                    ('Ἠ', 'Ἧ'),
                    ('Ἰ', 'Ἷ'),
                    ('Ὀ', 'Ὅ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'Ὗ'),
                    ('Ὠ', 'Ὧ'),
                    ('Ᾰ', 'Ά'),
                    ('Ὲ', 'Ή'),
                    ('Ῐ', 'Ί'),
                    ('Ῠ', 'Ῥ'),
                    ('Ὸ', 'Ώ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℋ', 'ℍ'),
                    ('ℐ', 'ℒ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℰ', 'ℳ'),
                    ('ℾ', 'ℿ'),
                    ('ⅅ', 'ⅅ'),
                    ('Ↄ', 'Ↄ'),
                    ('Ⰰ', 'Ⱟ'),
                    ('Ⱡ', 'Ⱡ'),
                    ('Ɫ', 'Ɽ'),
                    ('Ⱨ', 'Ⱨ'),
                    ('Ⱪ', 'Ⱪ'),
                    ('Ⱬ', 'Ⱬ'),
                    ('Ɑ', 'Ɒ'),
                    ('Ⱳ', 'Ⱳ'),
                    ('Ⱶ', 'Ⱶ'),
                    ('Ȿ', 'Ⲁ'),
                    ('Ⲃ', 'Ⲃ'),
                    ('Ⲅ', 'Ⲅ'),
                    ('Ⲇ', 'Ⲇ'),
                    ('Ⲉ', 'Ⲉ'),
                    ('Ⲋ', 'Ⲋ'),
                    ('Ⲍ', 'Ⲍ'),
                    ('Ⲏ', 'Ⲏ'),
                    ('Ⲑ', 'Ⲑ'),
                    ('Ⲓ', 'Ⲓ'),
                    ('Ⲕ', 'Ⲕ'),
                    ('Ⲗ', 'Ⲗ'),
                    ('Ⲙ', 'Ⲙ'),
                    ('Ⲛ', 'Ⲛ'),
                    ('Ⲝ', 'Ⲝ'),
                    ('Ⲟ', 'Ⲟ'),
                    ('Ⲡ', 'Ⲡ'),
                    ('Ⲣ', 'Ⲣ'),
                    ('Ⲥ', 'Ⲥ'),
                    ('Ⲧ', 'Ⲧ'),
                    ('Ⲩ', 'Ⲩ'),
                    ('Ⲫ', 'Ⲫ'),
                    ('Ⲭ', 'Ⲭ'),
                    ('Ⲯ', 'Ⲯ'),
                    ('Ⲱ', 'Ⲱ'),
                    ('Ⲳ', 'Ⲳ'),
                    ('Ⲵ', 'Ⲵ'),
                    ('Ⲷ', 'Ⲷ'),
                    ('Ⲹ', 'Ⲹ'),
                    ('Ⲻ', 'Ⲻ'),
                    ('Ⲽ', 'Ⲽ'),
                    ('Ⲿ', 'Ⲿ'),
                    ('Ⳁ', 'Ⳁ'),
                    ('Ⳃ', 'Ⳃ'),
                    ('Ⳅ', 'Ⳅ'),
                    ('Ⳇ', 'Ⳇ'),
                    ('Ⳉ', 'Ⳉ'),
                    ('Ⳋ', 'Ⳋ'),
                    ('Ⳍ', 'Ⳍ'),
                    ('Ⳏ', 'Ⳏ'),
                    ('Ⳑ', 'Ⳑ'),
                    ('Ⳓ', 'Ⳓ'),
                    ('Ⳕ', 'Ⳕ'),
                    ('Ⳗ', 'Ⳗ'),
                    ('Ⳙ', 'Ⳙ'),
                    ('Ⳛ', 'Ⳛ'),
                    ('Ⳝ', 'Ⳝ'),
                    ('Ⳟ', 'Ⳟ'),
                    ('Ⳡ', 'Ⳡ'),
                    ('Ⳣ', 'Ⳣ'),
                    ('Ⳬ', 'Ⳬ'),
                    ('Ⳮ', 'Ⳮ'),
                    ('Ⳳ', 'Ⳳ'),
                    ('Ꙁ', 'Ꙁ'),
                    ('Ꙃ', 'Ꙃ'),
                    ('Ꙅ', 'Ꙅ'),
                    ('Ꙇ', 'Ꙇ'),
                    ('Ꙉ', 'Ꙉ'),
                    ('Ꙋ', 'Ꙋ'),
                    ('Ꙍ', 'Ꙍ'),
                    ('Ꙏ', 'Ꙏ'),
                    ('Ꙑ', 'Ꙑ'),
                    ('Ꙓ', 'Ꙓ'),
                    ('Ꙕ', 'Ꙕ'),
                    ('Ꙗ', 'Ꙗ'),
                    ('Ꙙ', 'Ꙙ'),
                    ('Ꙛ', 'Ꙛ'),
                    ('Ꙝ', 'Ꙝ'),
                    ('Ꙟ', 'Ꙟ'),
                    ('Ꙡ', 'Ꙡ'),
                    ('Ꙣ', 'Ꙣ'),
                    ('Ꙥ', 'Ꙥ'),
                    ('Ꙧ', 'Ꙧ'),
                    ('Ꙩ', 'Ꙩ'),
                    ('Ꙫ', 'Ꙫ'),
                    ('Ꙭ', 'Ꙭ'),
                    ('Ꚁ', 'Ꚁ'),
                    ('Ꚃ', 'Ꚃ'),
                    ('Ꚅ', 'Ꚅ'),
                    ('Ꚇ', 'Ꚇ'),
                    ('Ꚉ', 'Ꚉ'),
                    ('Ꚋ', 'Ꚋ'),
                    ('Ꚍ', 'Ꚍ'),
                    ('Ꚏ', 'Ꚏ'),
                    ('Ꚑ', 'Ꚑ'),
                    ('Ꚓ', 'Ꚓ'),
                    ('Ꚕ', 'Ꚕ'),
                    ('Ꚗ', 'Ꚗ'),
                    ('Ꚙ', 'Ꚙ'),
                    ('Ꚛ', 'Ꚛ'),
                    ('Ꜣ', 'Ꜣ'),
                    ('Ꜥ', 'Ꜥ'),
                    ('Ꜧ', 'Ꜧ'),
                    ('Ꜩ', 'Ꜩ'),
                    ('Ꜫ', 'Ꜫ'),
                    ('Ꜭ', 'Ꜭ'),
                    ('Ꜯ', 'Ꜯ'),
                    ('Ꜳ', 'Ꜳ'),
                    ('Ꜵ', 'Ꜵ'),
                    ('Ꜷ', 'Ꜷ'),
                    ('Ꜹ', 'Ꜹ'),
                    ('Ꜻ', 'Ꜻ'),
                    ('Ꜽ', 'Ꜽ'),
                    ('Ꜿ', 'Ꜿ'),
                    ('Ꝁ', 'Ꝁ'),
                    ('Ꝃ', 'Ꝃ'),
                    ('Ꝅ', 'Ꝅ'),
                    ('Ꝇ', 'Ꝇ'),
                    ('Ꝉ', 'Ꝉ'),
                    ('Ꝋ', 'Ꝋ'),
                    ('Ꝍ', 'Ꝍ'),
                    ('Ꝏ', 'Ꝏ'),
                    ('Ꝑ', 'Ꝑ'),
                    ('Ꝓ', 'Ꝓ'),
                    ('Ꝕ', 'Ꝕ'),
                    ('Ꝗ', 'Ꝗ'),
                    ('Ꝙ', 'Ꝙ'),
                    ('Ꝛ', 'Ꝛ'),
                    ('Ꝝ', 'Ꝝ'),
                    ('Ꝟ', 'Ꝟ'),
                    ('Ꝡ', 'Ꝡ'),
                    ('Ꝣ', 'Ꝣ'),
                    ('Ꝥ', 'Ꝥ'),
                    ('Ꝧ', 'Ꝧ'),
                    ('Ꝩ', 'Ꝩ'),
                    ('Ꝫ', 'Ꝫ'),
                    ('Ꝭ', 'Ꝭ'),
                    ('Ꝯ', 'Ꝯ'),
                    ('Ꝺ', 'Ꝺ'),
                    ('Ꝼ', 'Ꝼ'),
                    ('Ᵹ', 'Ꝿ'),
                    ('Ꞁ', 'Ꞁ'),
                    ('Ꞃ', 'Ꞃ'),
                    ('Ꞅ', 'Ꞅ'),
                    ('Ꞇ', 'Ꞇ'),
                    ('Ꞌ', 'Ꞌ'),
                    ('Ɥ', 'Ɥ'),
                    ('Ꞑ', 'Ꞑ'),
                    ('Ꞓ', 'Ꞓ'),
                    ('Ꞗ', 'Ꞗ'),
                    ('Ꞙ', 'Ꞙ'),
                    ('Ꞛ', 'Ꞛ'),
                    ('Ꞝ', 'Ꞝ'),
                    ('Ꞟ', 'Ꞟ'),
                    ('Ꞡ', 'Ꞡ'),
                    ('Ꞣ', 'Ꞣ'),
                    ('Ꞥ', 'Ꞥ'),
                    ('Ꞧ', 'Ꞧ'),
                    ('Ꞩ', 'Ꞩ'),
                    ('Ɦ', 'Ɪ'),
                    ('Ʞ', 'Ꞵ'),
                    ('Ꞷ', 'Ꞷ'),
                    ('Ꞹ', 'Ꞹ'),
                    ('Ꞻ', 'Ꞻ'),
                    ('Ꞽ', 'Ꞽ'),
                    ('Ꞿ', 'Ꞿ'),
                    ('Ꟁ', 'Ꟁ'),
                    ('Ꟃ', 'Ꟃ'),
                    ('Ꞔ', 'Ꟈ'),
                    ('Ꟊ', 'Ꟊ'),
                    ('Ɤ', 'Ꟍ'),
                    ('Ꟑ', 'Ꟑ'),
                    ('Ꟗ', 'Ꟗ'),
                    ('Ꟙ', 'Ꟙ'),
                    ('Ꟛ', 'Ꟛ'),
                    ('Ƛ', 'Ƛ'),
                    ('Ꟶ', 'Ꟶ'),
                    ('Ａ', 'Ｚ'),
                    ('𐐀', '𐐧'),
                    ('𐒰', '𐓓'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐲀', '𐲲'),
                    ('𐵐', '𐵥'),
                    ('𑢠', '𑢿'),
                    ('𖹀', '𖹟'),
                    ('𝐀', '𝐙'),
                    ('𝐴', '𝑍'),
                    ('𝑨', '𝒁'),
                    ('𝒜', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒵'),
                    ('𝓐', '𝓩'),
                    ('𝔄', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔸', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕬', '𝖅'),
                    ('𝖠', '𝖹'),
                    ('𝗔', '𝗭'),
                    ('𝘈', '𝘡'),
                    ('𝘼', '𝙕'),
                    ('𝙰', '𝚉'),
                    ('𝚨', '𝛀'),
                    ('𝛢', '𝛺'),
                    ('𝜜', '𝜴'),
                    ('𝝖', '𝝮'),
                    ('𝞐', '𝞨'),
                    ('𝟊', '𝟊'),
                    ('𞤀', '𞤡'),
                ];
            }

            pub mod grapheme_cluster_break
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &
                [
                    ("CR", CR),
                    ("Control", CONTROL),
                    ("Extend", EXTEND),
                    ("L", L),
                    ("LF", LF),
                    ("LV", LV),
                    ("LVT", LVT),
                    ("Prepend", PREPEND),
                    ("Regional_Indicator", REGIONAL_INDICATOR),
                    ("SpacingMark", SPACINGMARK),
                    ("T", T),
                    ("V", V),
                    ("ZWJ", ZWJ),
                ];

                pub const CR: &'static [(char, char)] = &[('\r', '\r')];

                pub const CONTROL: &'static [(char, char)] = &
                [
                    ('\0', '\t'),
                    ('\u{b}', '\u{c}'),
                    ('\u{e}', '\u{1f}'),
                    ('\u{7f}', '\u{9f}'),
                    ('\u{ad}', '\u{ad}'),
                    ('\u{61c}', '\u{61c}'),
                    ('\u{180e}', '\u{180e}'),
                    ('\u{200b}', '\u{200b}'),
                    ('\u{200e}', '\u{200f}'),
                    ('\u{2028}', '\u{202e}'),
                    ('\u{2060}', '\u{206f}'),
                    ('\u{feff}', '\u{feff}'),
                    ('\u{fff0}', '\u{fffb}'),
                    ('\u{13430}', '\u{1343f}'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('\u{1d173}', '\u{1d17a}'),
                    ('\u{e0000}', '\u{e001f}'),
                    ('\u{e0080}', '\u{e00ff}'),
                    ('\u{e01f0}', '\u{e0fff}'),
                ];

                pub const EXTEND: &'static [(char, char)] = &
                [
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{489}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', '\u{902}'),
                    ('\u{93a}', '\u{93a}'),
                    ('\u{93c}', '\u{93c}'),
                    ('\u{941}', '\u{948}'),
                    ('\u{94d}', '\u{94d}'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', '\u{981}'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9be}'),
                    ('\u{9c1}', '\u{9c4}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', '\u{a02}'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('\u{a41}', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', '\u{a82}'),
                    ('\u{abc}', '\u{abc}'),
                    ('\u{ac1}', '\u{ac5}'),
                    ('\u{ac7}', '\u{ac8}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', '\u{b01}'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3e}', '\u{b3f}'),
                    ('\u{b41}', '\u{b44}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', '\u{bbe}'),
                    ('\u{bc0}', '\u{bc0}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c00}'),
                    ('\u{c04}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', '\u{c40}'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', '\u{c81}'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('\u{cbf}', '\u{cc0}'),
                    ('\u{cc2}', '\u{cc2}'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('\u{d00}', '\u{d01}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d3e}', '\u{d3e}'),
                    ('\u{d41}', '\u{d44}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', '\u{d81}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dcf}'),
                    ('\u{dd2}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('\u{ddf}', '\u{ddf}'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('\u{f71}', '\u{f7e}'),
                    ('\u{f80}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('\u{102d}', '\u{1030}'),
                    ('\u{1032}', '\u{1037}'),
                    ('\u{1039}', '\u{103a}'),
                    ('\u{103d}', '\u{103e}'),
                    ('\u{1058}', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{1082}'),
                    ('\u{1085}', '\u{1086}'),
                    ('\u{108d}', '\u{108d}'),
                    ('\u{109d}', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1715}'),
                    ('\u{1732}', '\u{1734}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{17b7}', '\u{17bd}'),
                    ('\u{17c6}', '\u{17c6}'),
                    ('\u{17c9}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', '\u{1922}'),
                    ('\u{1927}', '\u{1928}'),
                    ('\u{1932}', '\u{1932}'),
                    ('\u{1939}', '\u{193b}'),
                    ('\u{1a17}', '\u{1a18}'),
                    ('\u{1a1b}', '\u{1a1b}'),
                    ('\u{1a56}', '\u{1a56}'),
                    ('\u{1a58}', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1a62}', '\u{1a62}'),
                    ('\u{1a65}', '\u{1a6c}'),
                    ('\u{1a73}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', '\u{1b03}'),
                    ('\u{1b34}', '\u{1b3d}'),
                    ('\u{1b42}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1b81}'),
                    ('\u{1ba2}', '\u{1ba5}'),
                    ('\u{1ba8}', '\u{1bad}'),
                    ('\u{1be6}', '\u{1be6}'),
                    ('\u{1be8}', '\u{1be9}'),
                    ('\u{1bed}', '\u{1bed}'),
                    ('\u{1bef}', '\u{1bf3}'),
                    ('\u{1c2c}', '\u{1c33}'),
                    ('\u{1c36}', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce0}'),
                    ('\u{1ce2}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{200c}', '\u{200c}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('\u{a825}', '\u{a826}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a951}'),
                    ('\u{a953}', '\u{a953}'),
                    ('\u{a980}', '\u{a982}'),
                    ('\u{a9b3}', '\u{a9b3}'),
                    ('\u{a9b6}', '\u{a9b9}'),
                    ('\u{a9bc}', '\u{a9bd}'),
                    ('\u{a9c0}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa2e}'),
                    ('\u{aa31}', '\u{aa32}'),
                    ('\u{aa35}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', '\u{aa4c}'),
                    ('\u{aa7c}', '\u{aa7c}'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('\u{aaec}', '\u{aaed}'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('\u{abe5}', '\u{abe5}'),
                    ('\u{abe8}', '\u{abe8}'),
                    ('\u{abed}', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('\u{11001}', '\u{11001}'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '\u{11081}'),
                    ('\u{110b3}', '\u{110b6}'),
                    ('\u{110b9}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{1112b}'),
                    ('\u{1112d}', '\u{11134}'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '\u{11181}'),
                    ('\u{111b6}', '\u{111be}'),
                    ('\u{111c0}', '\u{111c0}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('\u{111cf}', '\u{111cf}'),
                    ('\u{1122f}', '\u{11231}'),
                    ('\u{11234}', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112df}'),
                    ('\u{112e3}', '\u{112ea}'),
                    ('\u{11300}', '\u{11301}'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1133e}', '\u{1133e}'),
                    ('\u{11340}', '\u{11340}'),
                    ('\u{1134d}', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113b8}', '\u{113b8}'),
                    ('\u{113bb}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '\u{113c9}'),
                    ('\u{113ce}', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('\u{11438}', '\u{1143f}'),
                    ('\u{11442}', '\u{11444}'),
                    ('\u{11446}', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b0}', '\u{114b0}'),
                    ('\u{114b3}', '\u{114b8}'),
                    ('\u{114ba}', '\u{114ba}'),
                    ('\u{114bd}', '\u{114bd}'),
                    ('\u{114bf}', '\u{114c0}'),
                    ('\u{114c2}', '\u{114c3}'),
                    ('\u{115af}', '\u{115af}'),
                    ('\u{115b2}', '\u{115b5}'),
                    ('\u{115bc}', '\u{115bd}'),
                    ('\u{115bf}', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('\u{11633}', '\u{1163a}'),
                    ('\u{1163d}', '\u{1163d}'),
                    ('\u{1163f}', '\u{11640}'),
                    ('\u{116ab}', '\u{116ab}'),
                    ('\u{116ad}', '\u{116ad}'),
                    ('\u{116b0}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1171d}'),
                    ('\u{1171f}', '\u{1171f}'),
                    ('\u{11722}', '\u{11725}'),
                    ('\u{11727}', '\u{1172b}'),
                    ('\u{1182f}', '\u{11837}'),
                    ('\u{11839}', '\u{1183a}'),
                    ('\u{11930}', '\u{11930}'),
                    ('\u{1193b}', '\u{1193e}'),
                    ('\u{11943}', '\u{11943}'),
                    ('\u{119d4}', '\u{119d7}'),
                    ('\u{119da}', '\u{119db}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '\u{11a38}'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a56}'),
                    ('\u{11a59}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a96}'),
                    ('\u{11a98}', '\u{11a99}'),
                    ('\u{11c30}', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3d}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('\u{11caa}', '\u{11cb0}'),
                    ('\u{11cb2}', '\u{11cb3}'),
                    ('\u{11cb5}', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('\u{11d95}', '\u{11d95}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11ef3}', '\u{11ef4}'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('\u{11f36}', '\u{11f3a}'),
                    ('\u{11f40}', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{16129}'),
                    ('\u{1612d}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('🏻', '🏿'),
                    ('\u{e0020}', '\u{e007f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const L: &'static [(char, char)] = &[('ᄀ', 'ᅟ'), ('ꥠ', 'ꥼ')];

                pub const LF: &'static [(char, char)] = &[('\n', '\n')];

                pub const LV: &'static [(char, char)] = &
                [
                    ('가', '가'),
                    ('개', '개'),
                    ('갸', '갸'),
                    ('걔', '걔'),
                    ('거', '거'),
                    ('게', '게'),
                    ('겨', '겨'),
                    ('계', '계'),
                    ('고', '고'),
                    ('과', '과'),
                    ('괘', '괘'),
                    ('괴', '괴'),
                    ('교', '교'),
                    ('구', '구'),
                    ('궈', '궈'),
                    ('궤', '궤'),
                    ('귀', '귀'),
                    ('규', '규'),
                    ('그', '그'),
                    ('긔', '긔'),
                    ('기', '기'),
                    ('까', '까'),
                    ('깨', '깨'),
                    ('꺄', '꺄'),
                    ('꺠', '꺠'),
                    ('꺼', '꺼'),
                    ('께', '께'),
                    ('껴', '껴'),
                    ('꼐', '꼐'),
                    ('꼬', '꼬'),
                    ('꽈', '꽈'),
                    ('꽤', '꽤'),
                    ('꾀', '꾀'),
                    ('꾜', '꾜'),
                    ('꾸', '꾸'),
                    ('꿔', '꿔'),
                    ('꿰', '꿰'),
                    ('뀌', '뀌'),
                    ('뀨', '뀨'),
                    ('끄', '끄'),
                    ('끠', '끠'),
                    ('끼', '끼'),
                    ('나', '나'),
                    ('내', '내'),
                    ('냐', '냐'),
                    ('냬', '냬'),
                    ('너', '너'),
                    ('네', '네'),
                    ('녀', '녀'),
                    ('녜', '녜'),
                    ('노', '노'),
                    ('놔', '놔'),
                    ('놰', '놰'),
                    ('뇌', '뇌'),
                    ('뇨', '뇨'),
                    ('누', '누'),
                    ('눠', '눠'),
                    ('눼', '눼'),
                    ('뉘', '뉘'),
                    ('뉴', '뉴'),
                    ('느', '느'),
                    ('늬', '늬'),
                    ('니', '니'),
                    ('다', '다'),
                    ('대', '대'),
                    ('댜', '댜'),
                    ('댸', '댸'),
                    ('더', '더'),
                    ('데', '데'),
                    ('뎌', '뎌'),
                    ('뎨', '뎨'),
                    ('도', '도'),
                    ('돠', '돠'),
                    ('돼', '돼'),
                    ('되', '되'),
                    ('됴', '됴'),
                    ('두', '두'),
                    ('둬', '둬'),
                    ('뒈', '뒈'),
                    ('뒤', '뒤'),
                    ('듀', '듀'),
                    ('드', '드'),
                    ('듸', '듸'),
                    ('디', '디'),
                    ('따', '따'),
                    ('때', '때'),
                    ('땨', '땨'),
                    ('떄', '떄'),
                    ('떠', '떠'),
                    ('떼', '떼'),
                    ('뗘', '뗘'),
                    ('뗴', '뗴'),
                    ('또', '또'),
                    ('똬', '똬'),
                    ('뙈', '뙈'),
                    ('뙤', '뙤'),
                    ('뚀', '뚀'),
                    ('뚜', '뚜'),
                    ('뚸', '뚸'),
                    ('뛔', '뛔'),
                    ('뛰', '뛰'),
                    ('뜌', '뜌'),
                    ('뜨', '뜨'),
                    ('띄', '띄'),
                    ('띠', '띠'),
                    ('라', '라'),
                    ('래', '래'),
                    ('랴', '랴'),
                    ('럐', '럐'),
                    ('러', '러'),
                    ('레', '레'),
                    ('려', '려'),
                    ('례', '례'),
                    ('로', '로'),
                    ('롸', '롸'),
                    ('뢔', '뢔'),
                    ('뢰', '뢰'),
                    ('료', '료'),
                    ('루', '루'),
                    ('뤄', '뤄'),
                    ('뤠', '뤠'),
                    ('뤼', '뤼'),
                    ('류', '류'),
                    ('르', '르'),
                    ('릐', '릐'),
                    ('리', '리'),
                    ('마', '마'),
                    ('매', '매'),
                    ('먀', '먀'),
                    ('먜', '먜'),
                    ('머', '머'),
                    ('메', '메'),
                    ('며', '며'),
                    ('몌', '몌'),
                    ('모', '모'),
                    ('뫄', '뫄'),
                    ('뫠', '뫠'),
                    ('뫼', '뫼'),
                    ('묘', '묘'),
                    ('무', '무'),
                    ('뭐', '뭐'),
                    ('뭬', '뭬'),
                    ('뮈', '뮈'),
                    ('뮤', '뮤'),
                    ('므', '므'),
                    ('믜', '믜'),
                    ('미', '미'),
                    ('바', '바'),
                    ('배', '배'),
                    ('뱌', '뱌'),
                    ('뱨', '뱨'),
                    ('버', '버'),
                    ('베', '베'),
                    ('벼', '벼'),
                    ('볘', '볘'),
                    ('보', '보'),
                    ('봐', '봐'),
                    ('봬', '봬'),
                    ('뵈', '뵈'),
                    ('뵤', '뵤'),
                    ('부', '부'),
                    ('붜', '붜'),
                    ('붸', '붸'),
                    ('뷔', '뷔'),
                    ('뷰', '뷰'),
                    ('브', '브'),
                    ('븨', '븨'),
                    ('비', '비'),
                    ('빠', '빠'),
                    ('빼', '빼'),
                    ('뺘', '뺘'),
                    ('뺴', '뺴'),
                    ('뻐', '뻐'),
                    ('뻬', '뻬'),
                    ('뼈', '뼈'),
                    ('뼤', '뼤'),
                    ('뽀', '뽀'),
                    ('뽜', '뽜'),
                    ('뽸', '뽸'),
                    ('뾔', '뾔'),
                    ('뾰', '뾰'),
                    ('뿌', '뿌'),
                    ('뿨', '뿨'),
                    ('쀄', '쀄'),
                    ('쀠', '쀠'),
                    ('쀼', '쀼'),
                    ('쁘', '쁘'),
                    ('쁴', '쁴'),
                    ('삐', '삐'),
                    ('사', '사'),
                    ('새', '새'),
                    ('샤', '샤'),
                    ('섀', '섀'),
                    ('서', '서'),
                    ('세', '세'),
                    ('셔', '셔'),
                    ('셰', '셰'),
                    ('소', '소'),
                    ('솨', '솨'),
                    ('쇄', '쇄'),
                    ('쇠', '쇠'),
                    ('쇼', '쇼'),
                    ('수', '수'),
                    ('숴', '숴'),
                    ('쉐', '쉐'),
                    ('쉬', '쉬'),
                    ('슈', '슈'),
                    ('스', '스'),
                    ('싀', '싀'),
                    ('시', '시'),
                    ('싸', '싸'),
                    ('쌔', '쌔'),
                    ('쌰', '쌰'),
                    ('썌', '썌'),
                    ('써', '써'),
                    ('쎄', '쎄'),
                    ('쎠', '쎠'),
                    ('쎼', '쎼'),
                    ('쏘', '쏘'),
                    ('쏴', '쏴'),
                    ('쐐', '쐐'),
                    ('쐬', '쐬'),
                    ('쑈', '쑈'),
                    ('쑤', '쑤'),
                    ('쒀', '쒀'),
                    ('쒜', '쒜'),
                    ('쒸', '쒸'),
                    ('쓔', '쓔'),
                    ('쓰', '쓰'),
                    ('씌', '씌'),
                    ('씨', '씨'),
                    ('아', '아'),
                    ('애', '애'),
                    ('야', '야'),
                    ('얘', '얘'),
                    ('어', '어'),
                    ('에', '에'),
                    ('여', '여'),
                    ('예', '예'),
                    ('오', '오'),
                    ('와', '와'),
                    ('왜', '왜'),
                    ('외', '외'),
                    ('요', '요'),
                    ('우', '우'),
                    ('워', '워'),
                    ('웨', '웨'),
                    ('위', '위'),
                    ('유', '유'),
                    ('으', '으'),
                    ('의', '의'),
                    ('이', '이'),
                    ('자', '자'),
                    ('재', '재'),
                    ('쟈', '쟈'),
                    ('쟤', '쟤'),
                    ('저', '저'),
                    ('제', '제'),
                    ('져', '져'),
                    ('졔', '졔'),
                    ('조', '조'),
                    ('좌', '좌'),
                    ('좨', '좨'),
                    ('죄', '죄'),
                    ('죠', '죠'),
                    ('주', '주'),
                    ('줘', '줘'),
                    ('줴', '줴'),
                    ('쥐', '쥐'),
                    ('쥬', '쥬'),
                    ('즈', '즈'),
                    ('즤', '즤'),
                    ('지', '지'),
                    ('짜', '짜'),
                    ('째', '째'),
                    ('쨔', '쨔'),
                    ('쨰', '쨰'),
                    ('쩌', '쩌'),
                    ('쩨', '쩨'),
                    ('쪄', '쪄'),
                    ('쪠', '쪠'),
                    ('쪼', '쪼'),
                    ('쫘', '쫘'),
                    ('쫴', '쫴'),
                    ('쬐', '쬐'),
                    ('쬬', '쬬'),
                    ('쭈', '쭈'),
                    ('쭤', '쭤'),
                    ('쮀', '쮀'),
                    ('쮜', '쮜'),
                    ('쮸', '쮸'),
                    ('쯔', '쯔'),
                    ('쯰', '쯰'),
                    ('찌', '찌'),
                    ('차', '차'),
                    ('채', '채'),
                    ('챠', '챠'),
                    ('챼', '챼'),
                    ('처', '처'),
                    ('체', '체'),
                    ('쳐', '쳐'),
                    ('쳬', '쳬'),
                    ('초', '초'),
                    ('촤', '촤'),
                    ('쵀', '쵀'),
                    ('최', '최'),
                    ('쵸', '쵸'),
                    ('추', '추'),
                    ('춰', '춰'),
                    ('췌', '췌'),
                    ('취', '취'),
                    ('츄', '츄'),
                    ('츠', '츠'),
                    ('츼', '츼'),
                    ('치', '치'),
                    ('카', '카'),
                    ('캐', '캐'),
                    ('캬', '캬'),
                    ('컈', '컈'),
                    ('커', '커'),
                    ('케', '케'),
                    ('켜', '켜'),
                    ('켸', '켸'),
                    ('코', '코'),
                    ('콰', '콰'),
                    ('쾌', '쾌'),
                    ('쾨', '쾨'),
                    ('쿄', '쿄'),
                    ('쿠', '쿠'),
                    ('쿼', '쿼'),
                    ('퀘', '퀘'),
                    ('퀴', '퀴'),
                    ('큐', '큐'),
                    ('크', '크'),
                    ('킈', '킈'),
                    ('키', '키'),
                    ('타', '타'),
                    ('태', '태'),
                    ('탸', '탸'),
                    ('턔', '턔'),
                    ('터', '터'),
                    ('테', '테'),
                    ('텨', '텨'),
                    ('톄', '톄'),
                    ('토', '토'),
                    ('톼', '톼'),
                    ('퇘', '퇘'),
                    ('퇴', '퇴'),
                    ('툐', '툐'),
                    ('투', '투'),
                    ('퉈', '퉈'),
                    ('퉤', '퉤'),
                    ('튀', '튀'),
                    ('튜', '튜'),
                    ('트', '트'),
                    ('틔', '틔'),
                    ('티', '티'),
                    ('파', '파'),
                    ('패', '패'),
                    ('퍄', '퍄'),
                    ('퍠', '퍠'),
                    ('퍼', '퍼'),
                    ('페', '페'),
                    ('펴', '펴'),
                    ('폐', '폐'),
                    ('포', '포'),
                    ('퐈', '퐈'),
                    ('퐤', '퐤'),
                    ('푀', '푀'),
                    ('표', '표'),
                    ('푸', '푸'),
                    ('풔', '풔'),
                    ('풰', '풰'),
                    ('퓌', '퓌'),
                    ('퓨', '퓨'),
                    ('프', '프'),
                    ('픠', '픠'),
                    ('피', '피'),
                    ('하', '하'),
                    ('해', '해'),
                    ('햐', '햐'),
                    ('햬', '햬'),
                    ('허', '허'),
                    ('헤', '헤'),
                    ('혀', '혀'),
                    ('혜', '혜'),
                    ('호', '호'),
                    ('화', '화'),
                    ('홰', '홰'),
                    ('회', '회'),
                    ('효', '효'),
                    ('후', '후'),
                    ('훠', '훠'),
                    ('훼', '훼'),
                    ('휘', '휘'),
                    ('휴', '휴'),
                    ('흐', '흐'),
                    ('희', '희'),
                    ('히', '히'),
                ];

                pub const LVT: &'static [(char, char)] = &
                [
                    ('각', '갛'),
                    ('객', '갷'),
                    ('갹', '걓'),
                    ('걕', '걯'),
                    ('걱', '겋'),
                    ('겍', '겧'),
                    ('격', '곃'),
                    ('곅', '곟'),
                    ('곡', '곻'),
                    ('곽', '괗'),
                    ('괙', '괳'),
                    ('괵', '굏'),
                    ('굑', '굫'),
                    ('국', '궇'),
                    ('궉', '궣'),
                    ('궥', '궿'),
                    ('귁', '귛'),
                    ('귝', '귷'),
                    ('극', '긓'),
                    ('긕', '긯'),
                    ('긱', '깋'),
                    ('깍', '깧'),
                    ('깩', '꺃'),
                    ('꺅', '꺟'),
                    ('꺡', '꺻'),
                    ('꺽', '껗'),
                    ('껙', '껳'),
                    ('껵', '꼏'),
                    ('꼑', '꼫'),
                    ('꼭', '꽇'),
                    ('꽉', '꽣'),
                    ('꽥', '꽿'),
                    ('꾁', '꾛'),
                    ('꾝', '꾷'),
                    ('꾹', '꿓'),
                    ('꿕', '꿯'),
                    ('꿱', '뀋'),
                    ('뀍', '뀧'),
                    ('뀩', '끃'),
                    ('끅', '끟'),
                    ('끡', '끻'),
                    ('끽', '낗'),
                    ('낙', '낳'),
                    ('낵', '냏'),
                    ('냑', '냫'),
                    ('냭', '넇'),
                    ('넉', '넣'),
                    ('넥', '넿'),
                    ('녁', '녛'),
                    ('녝', '녷'),
                    ('녹', '놓'),
                    ('놕', '놯'),
                    ('놱', '뇋'),
                    ('뇍', '뇧'),
                    ('뇩', '눃'),
                    ('눅', '눟'),
                    ('눡', '눻'),
                    ('눽', '뉗'),
                    ('뉙', '뉳'),
                    ('뉵', '늏'),
                    ('늑', '늫'),
                    ('늭', '닇'),
                    ('닉', '닣'),
                    ('닥', '닿'),
                    ('댁', '댛'),
                    ('댝', '댷'),
                    ('댹', '덓'),
                    ('덕', '덯'),
                    ('덱', '뎋'),
                    ('뎍', '뎧'),
                    ('뎩', '돃'),
                    ('독', '돟'),
                    ('돡', '돻'),
                    ('돽', '됗'),
                    ('됙', '됳'),
                    ('됵', '둏'),
                    ('둑', '둫'),
                    ('둭', '뒇'),
                    ('뒉', '뒣'),
                    ('뒥', '뒿'),
                    ('듁', '듛'),
                    ('득', '듷'),
                    ('듹', '딓'),
                    ('딕', '딯'),
                    ('딱', '땋'),
                    ('땍', '땧'),
                    ('땩', '떃'),
                    ('떅', '떟'),
                    ('떡', '떻'),
                    ('떽', '뗗'),
                    ('뗙', '뗳'),
                    ('뗵', '똏'),
                    ('똑', '똫'),
                    ('똭', '뙇'),
                    ('뙉', '뙣'),
                    ('뙥', '뙿'),
                    ('뚁', '뚛'),
                    ('뚝', '뚷'),
                    ('뚹', '뛓'),
                    ('뛕', '뛯'),
                    ('뛱', '뜋'),
                    ('뜍', '뜧'),
                    ('뜩', '띃'),
                    ('띅', '띟'),
                    ('띡', '띻'),
                    ('락', '랗'),
                    ('랙', '랳'),
                    ('략', '럏'),
                    ('럑', '럫'),
                    ('럭', '렇'),
                    ('렉', '렣'),
                    ('력', '렿'),
                    ('롁', '롛'),
                    ('록', '롷'),
                    ('롹', '뢓'),
                    ('뢕', '뢯'),
                    ('뢱', '룋'),
                    ('룍', '룧'),
                    ('룩', '뤃'),
                    ('뤅', '뤟'),
                    ('뤡', '뤻'),
                    ('뤽', '륗'),
                    ('륙', '륳'),
                    ('륵', '릏'),
                    ('릑', '릫'),
                    ('릭', '맇'),
                    ('막', '맣'),
                    ('맥', '맿'),
                    ('먁', '먛'),
                    ('먝', '먷'),
                    ('먹', '멓'),
                    ('멕', '멯'),
                    ('멱', '몋'),
                    ('몍', '몧'),
                    ('목', '뫃'),
                    ('뫅', '뫟'),
                    ('뫡', '뫻'),
                    ('뫽', '묗'),
                    ('묙', '묳'),
                    ('묵', '뭏'),
                    ('뭑', '뭫'),
                    ('뭭', '뮇'),
                    ('뮉', '뮣'),
                    ('뮥', '뮿'),
                    ('믁', '믛'),
                    ('믝', '믷'),
                    ('믹', '밓'),
                    ('박', '밯'),
                    ('백', '뱋'),
                    ('뱍', '뱧'),
                    ('뱩', '벃'),
                    ('벅', '벟'),
                    ('벡', '벻'),
                    ('벽', '볗'),
                    ('볙', '볳'),
                    ('복', '봏'),
                    ('봑', '봫'),
                    ('봭', '뵇'),
                    ('뵉', '뵣'),
                    ('뵥', '뵿'),
                    ('북', '붛'),
                    ('붝', '붷'),
                    ('붹', '뷓'),
                    ('뷕', '뷯'),
                    ('뷱', '븋'),
                    ('븍', '븧'),
                    ('븩', '빃'),
                    ('빅', '빟'),
                    ('빡', '빻'),
                    ('빽', '뺗'),
                    ('뺙', '뺳'),
                    ('뺵', '뻏'),
                    ('뻑', '뻫'),
                    ('뻭', '뼇'),
                    ('뼉', '뼣'),
                    ('뼥', '뼿'),
                    ('뽁', '뽛'),
                    ('뽝', '뽷'),
                    ('뽹', '뾓'),
                    ('뾕', '뾯'),
                    ('뾱', '뿋'),
                    ('뿍', '뿧'),
                    ('뿩', '쀃'),
                    ('쀅', '쀟'),
                    ('쀡', '쀻'),
                    ('쀽', '쁗'),
                    ('쁙', '쁳'),
                    ('쁵', '삏'),
                    ('삑', '삫'),
                    ('삭', '샇'),
                    ('색', '샣'),
                    ('샥', '샿'),
                    ('섁', '섛'),
                    ('석', '섷'),
                    ('섹', '셓'),
                    ('셕', '셯'),
                    ('셱', '솋'),
                    ('속', '솧'),
                    ('솩', '쇃'),
                    ('쇅', '쇟'),
                    ('쇡', '쇻'),
                    ('쇽', '숗'),
                    ('숙', '숳'),
                    ('숵', '쉏'),
                    ('쉑', '쉫'),
                    ('쉭', '슇'),
                    ('슉', '슣'),
                    ('슥', '슿'),
                    ('싁', '싛'),
                    ('식', '싷'),
                    ('싹', '쌓'),
                    ('쌕', '쌯'),
                    ('쌱', '썋'),
                    ('썍', '썧'),
                    ('썩', '쎃'),
                    ('쎅', '쎟'),
                    ('쎡', '쎻'),
                    ('쎽', '쏗'),
                    ('쏙', '쏳'),
                    ('쏵', '쐏'),
                    ('쐑', '쐫'),
                    ('쐭', '쑇'),
                    ('쑉', '쑣'),
                    ('쑥', '쑿'),
                    ('쒁', '쒛'),
                    ('쒝', '쒷'),
                    ('쒹', '쓓'),
                    ('쓕', '쓯'),
                    ('쓱', '씋'),
                    ('씍', '씧'),
                    ('씩', '앃'),
                    ('악', '앟'),
                    ('액', '앻'),
                    ('약', '얗'),
                    ('얙', '얳'),
                    ('억', '엏'),
                    ('엑', '엫'),
                    ('역', '옇'),
                    ('옉', '옣'),
                    ('옥', '옿'),
                    ('왁', '왛'),
                    ('왝', '왷'),
                    ('왹', '욓'),
                    ('욕', '욯'),
                    ('욱', '웋'),
                    ('웍', '웧'),
                    ('웩', '윃'),
                    ('윅', '윟'),
                    ('육', '윻'),
                    ('윽', '읗'),
                    ('읙', '읳'),
                    ('익', '잏'),
                    ('작', '잫'),
                    ('잭', '쟇'),
                    ('쟉', '쟣'),
                    ('쟥', '쟿'),
                    ('적', '젛'),
                    ('젝', '젷'),
                    ('젹', '졓'),
                    ('졕', '졯'),
                    ('족', '좋'),
                    ('좍', '좧'),
                    ('좩', '죃'),
                    ('죅', '죟'),
                    ('죡', '죻'),
                    ('죽', '줗'),
                    ('줙', '줳'),
                    ('줵', '쥏'),
                    ('쥑', '쥫'),
                    ('쥭', '즇'),
                    ('즉', '즣'),
                    ('즥', '즿'),
                    ('직', '짛'),
                    ('짝', '짷'),
                    ('짹', '쨓'),
                    ('쨕', '쨯'),
                    ('쨱', '쩋'),
                    ('쩍', '쩧'),
                    ('쩩', '쪃'),
                    ('쪅', '쪟'),
                    ('쪡', '쪻'),
                    ('쪽', '쫗'),
                    ('쫙', '쫳'),
                    ('쫵', '쬏'),
                    ('쬑', '쬫'),
                    ('쬭', '쭇'),
                    ('쭉', '쭣'),
                    ('쭥', '쭿'),
                    ('쮁', '쮛'),
                    ('쮝', '쮷'),
                    ('쮹', '쯓'),
                    ('쯕', '쯯'),
                    ('쯱', '찋'),
                    ('찍', '찧'),
                    ('착', '챃'),
                    ('책', '챟'),
                    ('챡', '챻'),
                    ('챽', '첗'),
                    ('척', '첳'),
                    ('첵', '쳏'),
                    ('쳑', '쳫'),
                    ('쳭', '촇'),
                    ('촉', '촣'),
                    ('촥', '촿'),
                    ('쵁', '쵛'),
                    ('쵝', '쵷'),
                    ('쵹', '춓'),
                    ('축', '춯'),
                    ('춱', '췋'),
                    ('췍', '췧'),
                    ('췩', '츃'),
                    ('츅', '츟'),
                    ('측', '츻'),
                    ('츽', '칗'),
                    ('칙', '칳'),
                    ('칵', '캏'),
                    ('캑', '캫'),
                    ('캭', '컇'),
                    ('컉', '컣'),
                    ('컥', '컿'),
                    ('켁', '켛'),
                    ('켝', '켷'),
                    ('켹', '콓'),
                    ('콕', '콯'),
                    ('콱', '쾋'),
                    ('쾍', '쾧'),
                    ('쾩', '쿃'),
                    ('쿅', '쿟'),
                    ('쿡', '쿻'),
                    ('쿽', '퀗'),
                    ('퀙', '퀳'),
                    ('퀵', '큏'),
                    ('큑', '큫'),
                    ('큭', '킇'),
                    ('킉', '킣'),
                    ('킥', '킿'),
                    ('탁', '탛'),
                    ('택', '탷'),
                    ('탹', '턓'),
                    ('턕', '턯'),
                    ('턱', '텋'),
                    ('텍', '텧'),
                    ('텩', '톃'),
                    ('톅', '톟'),
                    ('톡', '톻'),
                    ('톽', '퇗'),
                    ('퇙', '퇳'),
                    ('퇵', '툏'),
                    ('툑', '툫'),
                    ('툭', '퉇'),
                    ('퉉', '퉣'),
                    ('퉥', '퉿'),
                    ('튁', '튛'),
                    ('튝', '튷'),
                    ('특', '틓'),
                    ('틕', '틯'),
                    ('틱', '팋'),
                    ('팍', '팧'),
                    ('팩', '퍃'),
                    ('퍅', '퍟'),
                    ('퍡', '퍻'),
                    ('퍽', '펗'),
                    ('펙', '펳'),
                    ('펵', '폏'),
                    ('폑', '폫'),
                    ('폭', '퐇'),
                    ('퐉', '퐣'),
                    ('퐥', '퐿'),
                    ('푁', '푛'),
                    ('푝', '푷'),
                    ('푹', '풓'),
                    ('풕', '풯'),
                    ('풱', '퓋'),
                    ('퓍', '퓧'),
                    ('퓩', '픃'),
                    ('픅', '픟'),
                    ('픡', '픻'),
                    ('픽', '핗'),
                    ('학', '핳'),
                    ('핵', '햏'),
                    ('햑', '햫'),
                    ('햭', '헇'),
                    ('헉', '헣'),
                    ('헥', '헿'),
                    ('혁', '혛'),
                    ('혝', '혷'),
                    ('혹', '홓'),
                    ('확', '홯'),
                    ('홱', '횋'),
                    ('획', '횧'),
                    ('횩', '훃'),
                    ('훅', '훟'),
                    ('훡', '훻'),
                    ('훽', '휗'),
                    ('휙', '휳'),
                    ('휵', '흏'),
                    ('흑', '흫'),
                    ('흭', '힇'),
                    ('힉', '힣'),
                ];

                pub const PREPEND: &'static [(char, char)] = &
                [
                    ('\u{600}', '\u{605}'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('\u{70f}', '\u{70f}'),
                    ('\u{890}', '\u{891}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('ൎ', 'ൎ'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110cd}', '\u{110cd}'),
                    ('𑇂', '𑇃'),
                    ('𑏑', '𑏑'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑨺', '𑨺'),
                    ('𑪄', '𑪉'),
                    ('𑵆', '𑵆'),
                    ('𑼂', '𑼂'),
                ];

                pub const REGIONAL_INDICATOR: &'static [(char, char)] = &[('🇦', '🇿')];

                pub const SPACINGMARK: &'static [(char, char)] = &
                [
                    ('ः', 'ः'),
                    ('ऻ', 'ऻ'),
                    ('ा', 'ी'),
                    ('ॉ', 'ौ'),
                    ('ॎ', 'ॏ'),
                    ('ং', 'ঃ'),
                    ('ি', 'ী'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৌ'),
                    ('ਃ', 'ਃ'),
                    ('ਾ', 'ੀ'),
                    ('ઃ', 'ઃ'),
                    ('ા', 'ી'),
                    ('ૉ', 'ૉ'),
                    ('ો', 'ૌ'),
                    ('ଂ', 'ଃ'),
                    ('ୀ', 'ୀ'),
                    ('େ', 'ୈ'),
                    ('ୋ', 'ୌ'),
                    ('ி', 'ி'),
                    ('ு', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', 'ௌ'),
                    ('ఁ', 'ః'),
                    ('ు', 'ౄ'),
                    ('ಂ', 'ಃ'),
                    ('ಾ', 'ಾ'),
                    ('ು', 'ು'),
                    ('ೃ', 'ೄ'),
                    ('ೳ', 'ೳ'),
                    ('ം', 'ഃ'),
                    ('ി', 'ീ'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൌ'),
                    ('ං', 'ඃ'),
                    ('ැ', 'ෑ'),
                    ('ෘ', 'ෞ'),
                    ('ෲ', 'ෳ'),
                    ('ำ', 'ำ'),
                    ('ຳ', 'ຳ'),
                    ('༾', '༿'),
                    ('ཿ', 'ཿ'),
                    ('ေ', 'ေ'),
                    ('ျ', 'ြ'),
                    ('ၖ', 'ၗ'),
                    ('ႄ', 'ႄ'),
                    ('ា', 'ា'),
                    ('ើ', 'ៅ'),
                    ('ះ', 'ៈ'),
                    ('ᤣ', 'ᤦ'),
                    ('ᤩ', 'ᤫ'),
                    ('ᤰ', 'ᤱ'),
                    ('ᤳ', 'ᤸ'),
                    ('ᨙ', 'ᨚ'),
                    ('ᩕ', 'ᩕ'),
                    ('ᩗ', 'ᩗ'),
                    ('ᩭ', 'ᩲ'),
                    ('ᬄ', 'ᬄ'),
                    ('ᬾ', 'ᭁ'),
                    ('ᮂ', 'ᮂ'),
                    ('ᮡ', 'ᮡ'),
                    ('ᮦ', 'ᮧ'),
                    ('ᯧ', 'ᯧ'),
                    ('ᯪ', 'ᯬ'),
                    ('ᯮ', 'ᯮ'),
                    ('ᰤ', 'ᰫ'),
                    ('ᰴ', 'ᰵ'),
                    ('᳡', '᳡'),
                    ('᳷', '᳷'),
                    ('ꠣ', 'ꠤ'),
                    ('ꠧ', 'ꠧ'),
                    ('ꢀ', 'ꢁ'),
                    ('ꢴ', 'ꣃ'),
                    ('ꥒ', 'ꥒ'),
                    ('ꦃ', 'ꦃ'),
                    ('ꦴ', 'ꦵ'),
                    ('ꦺ', 'ꦻ'),
                    ('ꦾ', 'ꦿ'),
                    ('ꨯ', 'ꨰ'),
                    ('ꨳ', 'ꨴ'),
                    ('ꩍ', 'ꩍ'),
                    ('ꫫ', 'ꫫ'),
                    ('ꫮ', 'ꫯ'),
                    ('ꫵ', 'ꫵ'),
                    ('ꯣ', 'ꯤ'),
                    ('ꯦ', 'ꯧ'),
                    ('ꯩ', 'ꯪ'),
                    ('꯬', '꯬'),
                    ('𑀀', '𑀀'),
                    ('𑀂', '𑀂'),
                    ('𑂂', '𑂂'),
                    ('𑂰', '𑂲'),
                    ('𑂷', '𑂸'),
                    ('𑄬', '𑄬'),
                    ('𑅅', '𑅆'),
                    ('𑆂', '𑆂'),
                    ('𑆳', '𑆵'),
                    ('𑆿', '𑆿'),
                    ('𑇎', '𑇎'),
                    ('𑈬', '𑈮'),
                    ('𑈲', '𑈳'),
                    ('𑋠', '𑋢'),
                    ('𑌂', '𑌃'),
                    ('𑌿', '𑌿'),
                    ('𑍁', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '𑍌'),
                    ('𑍢', '𑍣'),
                    ('𑎹', '𑎺'),
                    ('𑏊', '𑏊'),
                    ('𑏌', '𑏍'),
                    ('𑐵', '𑐷'),
                    ('𑑀', '𑑁'),
                    ('𑑅', '𑑅'),
                    ('𑒱', '𑒲'),
                    ('𑒹', '𑒹'),
                    ('𑒻', '𑒼'),
                    ('𑒾', '𑒾'),
                    ('𑓁', '𑓁'),
                    ('𑖰', '𑖱'),
                    ('𑖸', '𑖻'),
                    ('𑖾', '𑖾'),
                    ('𑘰', '𑘲'),
                    ('𑘻', '𑘼'),
                    ('𑘾', '𑘾'),
                    ('𑚬', '𑚬'),
                    ('𑚮', '𑚯'),
                    ('𑜞', '𑜞'),
                    ('𑜦', '𑜦'),
                    ('𑠬', '𑠮'),
                    ('𑠸', '𑠸'),
                    ('𑤱', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('𑥀', '𑥀'),
                    ('𑥂', '𑥂'),
                    ('𑧑', '𑧓'),
                    ('𑧜', '𑧟'),
                    ('𑧤', '𑧤'),
                    ('𑨹', '𑨹'),
                    ('𑩗', '𑩘'),
                    ('𑪗', '𑪗'),
                    ('𑰯', '𑰯'),
                    ('𑰾', '𑰾'),
                    ('𑲩', '𑲩'),
                    ('𑲱', '𑲱'),
                    ('𑲴', '𑲴'),
                    ('𑶊', '𑶎'),
                    ('𑶓', '𑶔'),
                    ('𑶖', '𑶖'),
                    ('𑻵', '𑻶'),
                    ('𑼃', '𑼃'),
                    ('𑼴', '𑼵'),
                    ('𑼾', '𑼿'),
                    ('𖄪', '𖄬'),
                    ('𖽑', '𖾇'),
                ];

                pub const T: &'static [(char, char)] = &[('ᆨ', 'ᇿ'), ('ퟋ', 'ퟻ')];

                pub const V: &'static [(char, char)] = &[('ᅠ', 'ᆧ'), ('ힰ', 'ퟆ'), ('𖵣', '𖵣'), ('𖵧', '𖵪')];

                pub const ZWJ: &'static [(char, char)] = &[('\u{200d}', '\u{200d}')];
            }

            pub mod perl_decimal
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] =
                    &[("Decimal_Number", DECIMAL_NUMBER)];

                pub const DECIMAL_NUMBER: &'static [(char, char)] = &[
                    ('0', '9'),
                    ('٠', '٩'),
                    ('۰', '۹'),
                    ('߀', '߉'),
                    ('०', '९'),
                    ('০', '৯'),
                    ('੦', '੯'),
                    ('૦', '૯'),
                    ('୦', '୯'),
                    ('௦', '௯'),
                    ('౦', '౯'),
                    ('೦', '೯'),
                    ('൦', '൯'),
                    ('෦', '෯'),
                    ('๐', '๙'),
                    ('໐', '໙'),
                    ('༠', '༩'),
                    ('၀', '၉'),
                    ('႐', '႙'),
                    ('០', '៩'),
                    ('᠐', '᠙'),
                    ('᥆', '᥏'),
                    ('᧐', '᧙'),
                    ('᪀', '᪉'),
                    ('᪐', '᪙'),
                    ('᭐', '᭙'),
                    ('᮰', '᮹'),
                    ('᱀', '᱉'),
                    ('᱐', '᱙'),
                    ('꘠', '꘩'),
                    ('꣐', '꣙'),
                    ('꤀', '꤉'),
                    ('꧐', '꧙'),
                    ('꧰', '꧹'),
                    ('꩐', '꩙'),
                    ('꯰', '꯹'),
                    ('０', '９'),
                    ('𐒠', '𐒩'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵉'),
                    ('𑁦', '𑁯'),
                    ('𑃰', '𑃹'),
                    ('𑄶', '𑄿'),
                    ('𑇐', '𑇙'),
                    ('𑋰', '𑋹'),
                    ('𑑐', '𑑙'),
                    ('𑓐', '𑓙'),
                    ('𑙐', '𑙙'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜰', '𑜹'),
                    ('𑣠', '𑣩'),
                    ('𑥐', '𑥙'),
                    ('𑯰', '𑯹'),
                    ('𑱐', '𑱙'),
                    ('𑵐', '𑵙'),
                    ('𑶠', '𑶩'),
                    ('𑽐', '𑽙'),
                    ('𖄰', '𖄹'),
                    ('𖩠', '𖩩'),
                    ('𖫀', '𖫉'),
                    ('𖭐', '𖭙'),
                    ('𖵰', '𖵹'),
                    ('𜳰', '𜳹'),
                    ('𝟎', '𝟿'),
                    ('𞅀', '𞅉'),
                    ('𞋰', '𞋹'),
                    ('𞓰', '𞓹'),
                    ('𞗱', '𞗺'),
                    ('𞥐', '𞥙'),
                    ('🯰', '🯹'),
                ];
            }

            pub mod perl_space
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] =
                    &[("White_Space", WHITE_SPACE)];

                pub const WHITE_SPACE: &'static [(char, char)] = &[
                    ('\t', '\r'),
                    (' ', ' '),
                    ('\u{85}', '\u{85}'),
                    ('\u{a0}', '\u{a0}'),
                    ('\u{1680}', '\u{1680}'),
                    ('\u{2000}', '\u{200a}'),
                    ('\u{2028}', '\u{2029}'),
                    ('\u{202f}', '\u{202f}'),
                    ('\u{205f}', '\u{205f}'),
                    ('\u{3000}', '\u{3000}'),
                ];
            }

            pub mod perl_word
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const PERL_WORD: &'static [(char, char)] = &
                [
                    ('0', '9'),
                    ('A', 'Z'),
                    ('_', '_'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('\u{300}', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('\u{483}', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('\u{610}', '\u{61a}'),
                    ('ؠ', '٩'),
                    ('ٮ', 'ۓ'),
                    ('ە', '\u{6dc}'),
                    ('\u{6df}', '\u{6e8}'),
                    ('\u{6ea}', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', '\u{74a}'),
                    ('ݍ', 'ޱ'),
                    ('߀', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('ࠀ', '\u{82d}'),
                    ('ࡀ', '\u{85b}'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('\u{897}', '\u{8e1}'),
                    ('\u{8e3}', '\u{963}'),
                    ('०', '९'),
                    ('ॱ', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৎ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('০', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', '\u{ae3}'),
                    ('૦', '૯'),
                    ('ૹ', '\u{aff}'),
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('\u{b3c}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', '\u{b63}'),
                    ('୦', '୯'),
                    ('ୱ', 'ୱ'),
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('ௐ', 'ௐ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('௦', '௯'),
                    ('\u{c00}', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('\u{c3c}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', '\u{c63}'),
                    ('౦', '౯'),
                    ('ಀ', 'ಃ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('\u{cbc}', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', '\u{ce3}'),
                    ('೦', '೯'),
                    ('ೱ', 'ೳ'),
                    ('\u{d00}', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൎ'),
                    ('ൔ', '\u{d57}'),
                    ('ൟ', '\u{d63}'),
                    ('൦', '൯'),
                    ('ൺ', 'ൿ'),
                    ('\u{d81}', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('෦', '෯'),
                    ('ෲ', 'ෳ'),
                    ('ก', '\u{e3a}'),
                    ('เ', '\u{e4e}'),
                    ('๐', '๙'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ece}'),
                    ('໐', '໙'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('\u{f18}', '\u{f19}'),
                    ('༠', '༩'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('\u{f71}', '\u{f84}'),
                    ('\u{f86}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('က', '၉'),
                    ('ၐ', '\u{109d}'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('\u{135d}', '\u{135f}'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', '\u{1715}'),
                    ('ᜟ', '\u{1734}'),
                    ('ᝀ', '\u{1753}'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('\u{1772}', '\u{1773}'),
                    ('ក', '\u{17d3}'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', '\u{17dd}'),
                    ('០', '៩'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '᠙'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('᥆', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('᧐', '᧙'),
                    ('ᨀ', '\u{1a1b}'),
                    ('ᨠ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '᪉'),
                    ('᪐', '᪙'),
                    ('ᪧ', 'ᪧ'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', 'ᭌ'),
                    ('᭐', '᭙'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1bf3}'),
                    ('ᰀ', '\u{1c37}'),
                    ('᱀', '᱉'),
                    ('ᱍ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', 'ᳺ'),
                    ('ᴀ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('\u{200c}', '\u{200d}'),
                    ('‿', '⁀'),
                    ('⁔', '⁔'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℯ', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⓐ', 'ⓩ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('\u{2d7f}', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '〇'),
                    ('〡', '\u{302f}'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('\u{3099}', '\u{309a}'),
                    ('ゝ', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘫ'),
                    ('Ꙁ', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('ꙿ', '\u{a6f1}'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠧ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢀ', '\u{a8c5}'),
                    ('꣐', '꣙'),
                    ('\u{a8e0}', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', '\u{a92d}'),
                    ('ꤰ', '\u{a953}'),
                    ('ꥠ', 'ꥼ'),
                    ('\u{a980}', '\u{a9c0}'),
                    ('ꧏ', '꧙'),
                    ('ꧠ', 'ꧾ'),
                    ('ꨀ', '\u{aa36}'),
                    ('ꩀ', 'ꩍ'),
                    ('꩐', '꩙'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫯ'),
                    ('ꫲ', '\u{aaf6}'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯪ'),
                    ('꯬', '\u{abed}'),
                    ('꯰', '꯹'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('︳', '︴'),
                    ('﹍', '﹏'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('０', '９'),
                    ('Ａ', 'Ｚ'),
                    ('＿', '＿'),
                    ('ａ', 'ｚ'),
                    ('ｦ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '\u{1037a}'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒠', '𐒩'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '\u{10ae6}'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '\u{10d27}'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵥'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '\u{10f50}'),
                    ('𐽰', '\u{10f85}'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀀', '\u{11046}'),
                    ('𑁦', '𑁵'),
                    ('\u{1107f}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('𑃐', '𑃨'),
                    ('𑃰', '𑃹'),
                    ('\u{11100}', '\u{11134}'),
                    ('𑄶', '𑄿'),
                    ('𑅄', '𑅇'),
                    ('𑅐', '\u{11173}'),
                    ('𑅶', '𑅶'),
                    ('\u{11180}', '𑇄'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇎', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '\u{11237}'),
                    ('\u{1123e}', '\u{11241}'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '\u{112ea}'),
                    ('𑋰', '𑋹'),
                    ('\u{11300}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('\u{1133b}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('𑍐', '𑍐'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏓'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑐀', '𑑊'),
                    ('𑑐', '𑑙'),
                    ('\u{1145e}', '𑑡'),
                    ('𑒀', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑓐', '𑓙'),
                    ('𑖀', '\u{115b5}'),
                    ('𑖸', '\u{115c0}'),
                    ('𑗘', '\u{115dd}'),
                    ('𑘀', '\u{11640}'),
                    ('𑙄', '𑙄'),
                    ('𑙐', '𑙙'),
                    ('𑚀', '𑚸'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜀', '𑜚'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑜰', '𑜹'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '\u{1183a}'),
                    ('𑢠', '𑣩'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{11943}'),
                    ('𑥐', '𑥙'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '\u{119d7}'),
                    ('\u{119da}', '𑧡'),
                    ('𑧣', '𑧤'),
                    ('𑨀', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('𑩐', '\u{11a99}'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑯰', '𑯹'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '\u{11c36}'),
                    ('\u{11c38}', '𑱀'),
                    ('𑱐', '𑱙'),
                    ('𑱲', '𑲏'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d47}'),
                    ('𑵐', '𑵙'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶘'),
                    ('𑶠', '𑶩'),
                    ('𑻠', '𑻶'),
                    ('\u{11f00}', '𑼐'),
                    ('𑼒', '\u{11f3a}'),
                    ('𑼾', '\u{11f42}'),
                    ('𑽐', '\u{11f5a}'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('\u{13440}', '\u{13455}'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄹'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩠', '𖩩'),
                    ('𖩰', '𖪾'),
                    ('𖫀', '𖫉'),
                    ('𖫐', '𖫭'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('𖬀', '\u{16b36}'),
                    ('𖭀', '𖭃'),
                    ('𖭐', '𖭙'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖵰', '𖵹'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('\u{16f4f}', '𖾇'),
                    ('\u{16f8f}', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('𜳰', '𜳹'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('𞄀', '𞄬'),
                    ('\u{1e130}', '𞄽'),
                    ('𞅀', '𞅉'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '\u{1e2ae}'),
                    ('𞋀', '𞋹'),
                    ('𞓐', '𞓹'),
                    ('𞗐', '𞗺'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('𞤀', '𞥋'),
                    ('𞥐', '𞥙'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                    ('🯰', '🯹'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];
            }

            pub mod property_bool
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &
                [
                    ("ASCII_Hex_Digit", ASCII_HEX_DIGIT),
                    ("Alphabetic", ALPHABETIC),
                    ("Bidi_Control", BIDI_CONTROL),
                    ("Bidi_Mirrored", BIDI_MIRRORED),
                    ("Case_Ignorable", CASE_IGNORABLE),
                    ("Cased", CASED),
                    ("Changes_When_Casefolded", CHANGES_WHEN_CASEFOLDED),
                    ("Changes_When_Casemapped", CHANGES_WHEN_CASEMAPPED),
                    ("Changes_When_Lowercased", CHANGES_WHEN_LOWERCASED),
                    ("Changes_When_Titlecased", CHANGES_WHEN_TITLECASED),
                    ("Changes_When_Uppercased", CHANGES_WHEN_UPPERCASED),
                    ("Dash", DASH),
                    ("Default_Ignorable_Code_Point", DEFAULT_IGNORABLE_CODE_POINT),
                    ("Deprecated", DEPRECATED),
                    ("Diacritic", DIACRITIC),
                    ("Emoji", EMOJI),
                    ("Emoji_Component", EMOJI_COMPONENT),
                    ("Emoji_Modifier", EMOJI_MODIFIER),
                    ("Emoji_Modifier_Base", EMOJI_MODIFIER_BASE),
                    ("Emoji_Presentation", EMOJI_PRESENTATION),
                    ("Extended_Pictographic", EXTENDED_PICTOGRAPHIC),
                    ("Extender", EXTENDER),
                    ("Grapheme_Base", GRAPHEME_BASE),
                    ("Grapheme_Extend", GRAPHEME_EXTEND),
                    ("Grapheme_Link", GRAPHEME_LINK),
                    ("Hex_Digit", HEX_DIGIT),
                    ("Hyphen", HYPHEN),
                    ("IDS_Binary_Operator", IDS_BINARY_OPERATOR),
                    ("IDS_Trinary_Operator", IDS_TRINARY_OPERATOR),
                    ("IDS_Unary_Operator", IDS_UNARY_OPERATOR),
                    ("ID_Compat_Math_Continue", ID_COMPAT_MATH_CONTINUE),
                    ("ID_Compat_Math_Start", ID_COMPAT_MATH_START),
                    ("ID_Continue", ID_CONTINUE),
                    ("ID_Start", ID_START),
                    ("Ideographic", IDEOGRAPHIC),
                    ("InCB", INCB),
                    ("Join_Control", JOIN_CONTROL),
                    ("Logical_Order_Exception", LOGICAL_ORDER_EXCEPTION),
                    ("Lowercase", LOWERCASE),
                    ("Math", MATH),
                    ("Modifier_Combining_Mark", MODIFIER_COMBINING_MARK),
                    ("Noncharacter_Code_Point", NONCHARACTER_CODE_POINT),
                    ("Other_Alphabetic", OTHER_ALPHABETIC),
                    ("Other_Default_Ignorable_Code_Point", OTHER_DEFAULT_IGNORABLE_CODE_POINT),
                    ("Other_Grapheme_Extend", OTHER_GRAPHEME_EXTEND),
                    ("Other_ID_Continue", OTHER_ID_CONTINUE),
                    ("Other_ID_Start", OTHER_ID_START),
                    ("Other_Lowercase", OTHER_LOWERCASE),
                    ("Other_Math", OTHER_MATH),
                    ("Other_Uppercase", OTHER_UPPERCASE),
                    ("Pattern_Syntax", PATTERN_SYNTAX),
                    ("Pattern_White_Space", PATTERN_WHITE_SPACE),
                    ("Prepended_Concatenation_Mark", PREPENDED_CONCATENATION_MARK),
                    ("Quotation_Mark", QUOTATION_MARK),
                    ("Radical", RADICAL),
                    ("Regional_Indicator", REGIONAL_INDICATOR),
                    ("Sentence_Terminal", SENTENCE_TERMINAL),
                    ("Soft_Dotted", SOFT_DOTTED),
                    ("Terminal_Punctuation", TERMINAL_PUNCTUATION),
                    ("Unified_Ideograph", UNIFIED_IDEOGRAPH),
                    ("Uppercase", UPPERCASE),
                    ("Variation_Selector", VARIATION_SELECTOR),
                    ("White_Space", WHITE_SPACE),
                    ("XID_Continue", XID_CONTINUE),
                    ("XID_Start", XID_START),
                ];

                pub const ASCII_HEX_DIGIT: &'static [(char, char)] = &[('0', '9'), ('A', 'F'), ('a', 'f')];

                pub const ALPHABETIC: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('\u{345}', '\u{345}'),
                    ('\u{363}', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('\u{5b0}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('\u{610}', '\u{61a}'),
                    ('ؠ', '\u{657}'),
                    ('\u{659}', '\u{65f}'),
                    ('ٮ', 'ۓ'),
                    ('ە', '\u{6dc}'),
                    ('\u{6e1}', '\u{6e8}'),
                    ('\u{6ed}', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', '\u{73f}'),
                    ('ݍ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠀ', '\u{817}'),
                    ('ࠚ', '\u{82c}'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('\u{897}', '\u{897}'),
                    ('ࢠ', 'ࣉ'),
                    ('\u{8d4}', '\u{8df}'),
                    ('\u{8e3}', '\u{8e9}'),
                    ('\u{8f0}', 'ऻ'),
                    ('ऽ', 'ौ'),
                    ('ॎ', 'ॐ'),
                    ('\u{955}', '\u{963}'),
                    ('ॱ', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৌ'),
                    ('ৎ', 'ৎ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('\u{a01}', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4c}'),
                    ('\u{a51}', '\u{a51}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('\u{a70}', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', 'ૌ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', '\u{ae3}'),
                    ('ૹ', '\u{afc}'),
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', 'ୌ'),
                    ('\u{b56}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', '\u{b63}'),
                    ('ୱ', 'ୱ'),
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', 'ௌ'),
                    ('ௐ', 'ௐ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4c}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', '\u{c63}'),
                    ('ಀ', 'ಃ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccc}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', '\u{ce3}'),
                    ('ೱ', 'ೳ'),
                    ('\u{d00}', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൌ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', '\u{d57}'),
                    ('ൟ', '\u{d63}'),
                    ('ൺ', 'ൿ'),
                    ('\u{d81}', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', 'ෳ'),
                    ('ก', '\u{e3a}'),
                    ('เ', 'ๆ'),
                    ('\u{e4d}', '\u{e4d}'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', '\u{eb9}'),
                    ('\u{ebb}', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ecd}', '\u{ecd}'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('\u{f71}', '\u{f83}'),
                    ('ྈ', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('က', '\u{1036}'),
                    ('း', 'း'),
                    ('ျ', 'ဿ'),
                    ('ၐ', 'ႏ'),
                    ('ႚ', '\u{109d}'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', '\u{1713}'),
                    ('ᜟ', '\u{1733}'),
                    ('ᝀ', '\u{1753}'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('\u{1772}', '\u{1773}'),
                    ('ក', 'ឳ'),
                    ('ា', 'ៈ'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', 'ៜ'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', 'ᤸ'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('ᨀ', '\u{1a1b}'),
                    ('ᨠ', '\u{1a5e}'),
                    ('ᩡ', '\u{1a74}'),
                    ('ᪧ', 'ᪧ'),
                    ('\u{1abf}', '\u{1ac0}'),
                    ('\u{1acc}', '\u{1ace}'),
                    ('\u{1b00}', 'ᬳ'),
                    ('\u{1b35}', '\u{1b43}'),
                    ('ᭅ', 'ᭌ'),
                    ('\u{1b80}', '\u{1ba9}'),
                    ('\u{1bac}', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᯧ', '\u{1bf1}'),
                    ('ᰀ', '\u{1c36}'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ᴀ', 'ᶿ'),
                    ('\u{1dd3}', '\u{1df4}'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℯ', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⓐ', 'ⓩ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '〇'),
                    ('〡', '〩'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('ゝ', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('Ꙁ', 'ꙮ'),
                    ('\u{a674}', '\u{a67b}'),
                    ('ꙿ', 'ꛯ'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠅ'),
                    ('ꠇ', 'ꠧ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢀ', 'ꣃ'),
                    ('\u{a8c5}', '\u{a8c5}'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', '\u{a8ff}'),
                    ('ꤊ', '\u{a92a}'),
                    ('ꤰ', 'ꥒ'),
                    ('ꥠ', 'ꥼ'),
                    ('\u{a980}', 'ꦲ'),
                    ('ꦴ', 'ꦿ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧠ', 'ꧯ'),
                    ('ꧺ', 'ꧾ'),
                    ('ꨀ', '\u{aa36}'),
                    ('ꩀ', 'ꩍ'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', '\u{aabe}'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫯ'),
                    ('ꫲ', 'ꫵ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯪ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('ｦ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '\u{1037a}'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '\u{10d27}'),
                    ('𐵊', '𐵥'),
                    ('\u{10d69}', '\u{10d69}'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '\u{10efc}'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀀', '\u{11045}'),
                    ('𑁱', '𑁵'),
                    ('\u{11080}', '𑂸'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('𑃐', '𑃨'),
                    ('\u{11100}', '\u{11132}'),
                    ('𑅄', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('\u{11180}', '𑆿'),
                    ('𑇁', '𑇄'),
                    ('𑇎', '\u{111cf}'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '\u{11234}'),
                    ('\u{11237}', '\u{11237}'),
                    ('\u{1123e}', '\u{11241}'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '\u{112e8}'),
                    ('\u{11300}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '𑍌'),
                    ('𑍐', '𑍐'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏍'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑑁'),
                    ('\u{11443}', '𑑅'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑓁'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '\u{115b5}'),
                    ('𑖸', '𑖾'),
                    ('𑗘', '\u{115dd}'),
                    ('𑘀', '𑘾'),
                    ('\u{11640}', '\u{11640}'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '\u{116b5}'),
                    ('𑚸', '𑚸'),
                    ('𑜀', '𑜚'),
                    ('\u{1171d}', '\u{1172a}'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '𑠸'),
                    ('𑢠', '𑣟'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{1193c}'),
                    ('𑤿', '𑥂'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '\u{119d7}'),
                    ('\u{119da}', '𑧟'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧤'),
                    ('𑨀', '𑨲'),
                    ('\u{11a35}', '\u{11a3e}'),
                    ('𑩐', '𑪗'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '\u{11c36}'),
                    ('\u{11c38}', '𑰾'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d41}'),
                    ('\u{11d43}', '\u{11d43}'),
                    ('𑵆', '\u{11d47}'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶖'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻶'),
                    ('\u{11f00}', '𑼐'),
                    ('𑼒', '\u{11f3a}'),
                    ('𑼾', '\u{11f40}'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '\u{1612e}'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭀', '𖭃'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('\u{16f4f}', '𖾇'),
                    ('\u{16f8f}', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('\u{1bc9e}', '\u{1bc9e}'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓫'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞤀', '𞥃'),
                    ('\u{1e947}', '\u{1e947}'),
                    ('𞥋', '𞥋'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const BIDI_CONTROL: &'static [(char, char)] = &
                [
                    ('\u{61c}', '\u{61c}'),
                    ('\u{200e}', '\u{200f}'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2066}', '\u{2069}'),
                ];

                pub const BIDI_MIRRORED: &'static [(char, char)] = &
                [
                    ('(', ')'),
                    ('<', '<'),
                    ('>', '>'),
                    ('[', '['),
                    (']', ']'),
                    ('{', '{'),
                    ('}', '}'),
                    ('«', '«'),
                    ('»', '»'),
                    ('༺', '༽'),
                    ('᚛', '᚜'),
                    ('‹', '›'),
                    ('⁅', '⁆'),
                    ('⁽', '⁾'),
                    ('₍', '₎'),
                    ('⅀', '⅀'),
                    ('∁', '∄'),
                    ('∈', '∍'),
                    ('∑', '∑'),
                    ('∕', '∖'),
                    ('√', '∝'),
                    ('∟', '∢'),
                    ('∤', '∤'),
                    ('∦', '∦'),
                    ('∫', '∳'),
                    ('∹', '∹'),
                    ('∻', '≌'),
                    ('≒', '≕'),
                    ('≟', '≠'),
                    ('≢', '≢'),
                    ('≤', '≫'),
                    ('≭', '⊌'),
                    ('⊏', '⊒'),
                    ('⊘', '⊘'),
                    ('⊢', '⊣'),
                    ('⊦', '⊸'),
                    ('⊾', '⊿'),
                    ('⋉', '⋍'),
                    ('⋐', '⋑'),
                    ('⋖', '⋭'),
                    ('⋰', '⋿'),
                    ('⌈', '⌋'),
                    ('⌠', '⌡'),
                    ('〈', '〉'),
                    ('❨', '❵'),
                    ('⟀', '⟀'),
                    ('⟃', '⟆'),
                    ('⟈', '⟉'),
                    ('⟋', '⟍'),
                    ('⟓', '⟖'),
                    ('⟜', '⟞'),
                    ('⟢', '⟯'),
                    ('⦃', '⦘'),
                    ('⦛', '⦠'),
                    ('⦢', '⦯'),
                    ('⦸', '⦸'),
                    ('⧀', '⧅'),
                    ('⧉', '⧉'),
                    ('⧎', '⧒'),
                    ('⧔', '⧕'),
                    ('⧘', '⧜'),
                    ('⧡', '⧡'),
                    ('⧣', '⧥'),
                    ('⧨', '⧩'),
                    ('⧴', '⧹'),
                    ('⧼', '⧽'),
                    ('⨊', '⨜'),
                    ('⨞', '⨡'),
                    ('⨤', '⨤'),
                    ('⨦', '⨦'),
                    ('⨩', '⨩'),
                    ('⨫', '⨮'),
                    ('⨴', '⨵'),
                    ('⨼', '⨾'),
                    ('⩗', '⩘'),
                    ('⩤', '⩥'),
                    ('⩪', '⩭'),
                    ('⩯', '⩰'),
                    ('⩳', '⩴'),
                    ('⩹', '⪣'),
                    ('⪦', '⪭'),
                    ('⪯', '⫖'),
                    ('⫝̸', '⫝̸'),
                    ('⫞', '⫞'),
                    ('⫢', '⫦'),
                    ('⫬', '⫮'),
                    ('⫳', '⫳'),
                    ('⫷', '⫻'),
                    ('⫽', '⫽'),
                    ('⯾', '⯾'),
                    ('⸂', '⸅'),
                    ('⸉', '⸊'),
                    ('⸌', '⸍'),
                    ('⸜', '⸝'),
                    ('⸠', '⸩'),
                    ('⹕', '⹜'),
                    ('〈', '】'),
                    ('〔', '〛'),
                    ('﹙', '﹞'),
                    ('﹤', '﹥'),
                    ('（', '）'),
                    ('＜', '＜'),
                    ('＞', '＞'),
                    ('［', '［'),
                    ('］', '］'),
                    ('｛', '｛'),
                    ('｝', '｝'),
                    ('｟', '｠'),
                    ('｢', '｣'),
                    ('𝛛', '𝛛'),
                    ('𝜕', '𝜕'),
                    ('𝝏', '𝝏'),
                    ('𝞉', '𝞉'),
                    ('𝟃', '𝟃'),
                ];

                pub const CASE_IGNORABLE: &'static [(char, char)] = &
                [
                    ('\'', '\''),
                    ('.', '.'),
                    (':', ':'),
                    ('^', '^'),
                    ('`', '`'),
                    ('¨', '¨'),
                    ('\u{ad}', '\u{ad}'),
                    ('¯', '¯'),
                    ('´', '´'),
                    ('·', '¸'),
                    ('ʰ', '\u{36f}'),
                    ('ʹ', '͵'),
                    ('ͺ', 'ͺ'),
                    ('΄', '΅'),
                    ('·', '·'),
                    ('\u{483}', '\u{489}'),
                    ('ՙ', 'ՙ'),
                    ('՟', '՟'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('״', '״'),
                    ('\u{600}', '\u{605}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{61c}', '\u{61c}'),
                    ('ـ', 'ـ'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dd}'),
                    ('\u{6df}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{70f}', '\u{70f}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('࢈', '࢈'),
                    ('\u{890}', '\u{891}'),
                    ('\u{897}', '\u{89f}'),
                    ('ࣉ', '\u{902}'),
                    ('\u{93a}', '\u{93a}'),
                    ('\u{93c}', '\u{93c}'),
                    ('\u{941}', '\u{948}'),
                    ('\u{94d}', '\u{94d}'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('ॱ', 'ॱ'),
                    ('\u{981}', '\u{981}'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9c1}', '\u{9c4}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', '\u{a02}'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('\u{a41}', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', '\u{a82}'),
                    ('\u{abc}', '\u{abc}'),
                    ('\u{ac1}', '\u{ac5}'),
                    ('\u{ac7}', '\u{ac8}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', '\u{b01}'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3f}', '\u{b3f}'),
                    ('\u{b41}', '\u{b44}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{b55}', '\u{b56}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bc0}', '\u{bc0}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{c00}', '\u{c00}'),
                    ('\u{c04}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', '\u{c40}'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', '\u{c81}'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('\u{cbf}', '\u{cbf}'),
                    ('\u{cc6}', '\u{cc6}'),
                    ('\u{ccc}', '\u{ccd}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('\u{d00}', '\u{d01}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d41}', '\u{d44}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', '\u{d81}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dd2}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('ๆ', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('\u{f71}', '\u{f7e}'),
                    ('\u{f80}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('\u{102d}', '\u{1030}'),
                    ('\u{1032}', '\u{1037}'),
                    ('\u{1039}', '\u{103a}'),
                    ('\u{103d}', '\u{103e}'),
                    ('\u{1058}', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{1082}'),
                    ('\u{1085}', '\u{1086}'),
                    ('\u{108d}', '\u{108d}'),
                    ('\u{109d}', '\u{109d}'),
                    ('ჼ', 'ჼ'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1714}'),
                    ('\u{1732}', '\u{1733}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{17b7}', '\u{17bd}'),
                    ('\u{17c6}', '\u{17c6}'),
                    ('\u{17c9}', '\u{17d3}'),
                    ('ៗ', 'ៗ'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180f}'),
                    ('ᡃ', 'ᡃ'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', '\u{1922}'),
                    ('\u{1927}', '\u{1928}'),
                    ('\u{1932}', '\u{1932}'),
                    ('\u{1939}', '\u{193b}'),
                    ('\u{1a17}', '\u{1a18}'),
                    ('\u{1a1b}', '\u{1a1b}'),
                    ('\u{1a56}', '\u{1a56}'),
                    ('\u{1a58}', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1a62}', '\u{1a62}'),
                    ('\u{1a65}', '\u{1a6c}'),
                    ('\u{1a73}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('ᪧ', 'ᪧ'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', '\u{1b03}'),
                    ('\u{1b34}', '\u{1b34}'),
                    ('\u{1b36}', '\u{1b3a}'),
                    ('\u{1b3c}', '\u{1b3c}'),
                    ('\u{1b42}', '\u{1b42}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1b81}'),
                    ('\u{1ba2}', '\u{1ba5}'),
                    ('\u{1ba8}', '\u{1ba9}'),
                    ('\u{1bab}', '\u{1bad}'),
                    ('\u{1be6}', '\u{1be6}'),
                    ('\u{1be8}', '\u{1be9}'),
                    ('\u{1bed}', '\u{1bed}'),
                    ('\u{1bef}', '\u{1bf1}'),
                    ('\u{1c2c}', '\u{1c33}'),
                    ('\u{1c36}', '\u{1c37}'),
                    ('ᱸ', 'ᱽ'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce0}'),
                    ('\u{1ce2}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('ᴬ', 'ᵪ'),
                    ('ᵸ', 'ᵸ'),
                    ('ᶛ', '\u{1dff}'),
                    ('᾽', '᾽'),
                    ('᾿', '῁'),
                    ('῍', '῏'),
                    ('῝', '῟'),
                    ('῭', '`'),
                    ('´', '῾'),
                    ('\u{200b}', '\u{200f}'),
                    ('‘', '’'),
                    ('․', '․'),
                    ('‧', '‧'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2060}', '\u{2064}'),
                    ('\u{2066}', '\u{206f}'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('ⱼ', 'ⱽ'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('ⵯ', 'ⵯ'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '々'),
                    ('\u{302a}', '\u{302d}'),
                    ('〱', '〵'),
                    ('〻', '〻'),
                    ('\u{3099}', 'ゞ'),
                    ('ー', 'ヾ'),
                    ('ꀕ', 'ꀕ'),
                    ('ꓸ', 'ꓽ'),
                    ('ꘌ', 'ꘌ'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('ꙿ', 'ꙿ'),
                    ('ꚜ', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('꜀', '꜡'),
                    ('ꝰ', 'ꝰ'),
                    ('ꞈ', '꞊'),
                    ('ꟲ', 'ꟴ'),
                    ('ꟸ', 'ꟹ'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('\u{a825}', '\u{a826}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a951}'),
                    ('\u{a980}', '\u{a982}'),
                    ('\u{a9b3}', '\u{a9b3}'),
                    ('\u{a9b6}', '\u{a9b9}'),
                    ('\u{a9bc}', '\u{a9bd}'),
                    ('ꧏ', 'ꧏ'),
                    ('\u{a9e5}', 'ꧦ'),
                    ('\u{aa29}', '\u{aa2e}'),
                    ('\u{aa31}', '\u{aa32}'),
                    ('\u{aa35}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', '\u{aa4c}'),
                    ('ꩰ', 'ꩰ'),
                    ('\u{aa7c}', '\u{aa7c}'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('ꫝ', 'ꫝ'),
                    ('\u{aaec}', '\u{aaed}'),
                    ('ꫳ', 'ꫴ'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('꭛', 'ꭟ'),
                    ('ꭩ', '꭫'),
                    ('\u{abe5}', '\u{abe5}'),
                    ('\u{abe8}', '\u{abe8}'),
                    ('\u{abed}', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('﮲', '﯂'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('︓', '︓'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('﹒', '﹒'),
                    ('﹕', '﹕'),
                    ('\u{feff}', '\u{feff}'),
                    ('＇', '＇'),
                    ('．', '．'),
                    ('：', '：'),
                    ('＾', '＾'),
                    ('｀', '｀'),
                    ('ｰ', 'ｰ'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('￣', '￣'),
                    ('\u{fff9}', '\u{fffb}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('𐵎', '𐵎'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('𐵯', '𐵯'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('\u{11001}', '\u{11001}'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '\u{11081}'),
                    ('\u{110b3}', '\u{110b6}'),
                    ('\u{110b9}', '\u{110ba}'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{110cd}', '\u{110cd}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{1112b}'),
                    ('\u{1112d}', '\u{11134}'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '\u{11181}'),
                    ('\u{111b6}', '\u{111be}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('\u{111cf}', '\u{111cf}'),
                    ('\u{1122f}', '\u{11231}'),
                    ('\u{11234}', '\u{11234}'),
                    ('\u{11236}', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112df}'),
                    ('\u{112e3}', '\u{112ea}'),
                    ('\u{11300}', '\u{11301}'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{11340}', '\u{11340}'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113bb}', '\u{113c0}'),
                    ('\u{113ce}', '\u{113ce}'),
                    ('\u{113d0}', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('\u{11438}', '\u{1143f}'),
                    ('\u{11442}', '\u{11444}'),
                    ('\u{11446}', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b3}', '\u{114b8}'),
                    ('\u{114ba}', '\u{114ba}'),
                    ('\u{114bf}', '\u{114c0}'),
                    ('\u{114c2}', '\u{114c3}'),
                    ('\u{115b2}', '\u{115b5}'),
                    ('\u{115bc}', '\u{115bd}'),
                    ('\u{115bf}', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('\u{11633}', '\u{1163a}'),
                    ('\u{1163d}', '\u{1163d}'),
                    ('\u{1163f}', '\u{11640}'),
                    ('\u{116ab}', '\u{116ab}'),
                    ('\u{116ad}', '\u{116ad}'),
                    ('\u{116b0}', '\u{116b5}'),
                    ('\u{116b7}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1171d}'),
                    ('\u{1171f}', '\u{1171f}'),
                    ('\u{11722}', '\u{11725}'),
                    ('\u{11727}', '\u{1172b}'),
                    ('\u{1182f}', '\u{11837}'),
                    ('\u{11839}', '\u{1183a}'),
                    ('\u{1193b}', '\u{1193c}'),
                    ('\u{1193e}', '\u{1193e}'),
                    ('\u{11943}', '\u{11943}'),
                    ('\u{119d4}', '\u{119d7}'),
                    ('\u{119da}', '\u{119db}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '\u{11a38}'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a56}'),
                    ('\u{11a59}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a96}'),
                    ('\u{11a98}', '\u{11a99}'),
                    ('\u{11c30}', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3d}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('\u{11caa}', '\u{11cb0}'),
                    ('\u{11cb2}', '\u{11cb3}'),
                    ('\u{11cb5}', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('\u{11d95}', '\u{11d95}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11ef3}', '\u{11ef4}'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('\u{11f36}', '\u{11f3a}'),
                    ('\u{11f40}', '\u{11f40}'),
                    ('\u{11f42}', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13430}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{16129}'),
                    ('\u{1612d}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('𖭀', '𖭃'),
                    ('𖵀', '𖵂'),
                    ('𖵫', '𖵬'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('\u{16f8f}', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '\u{16fe4}'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d167}', '\u{1d169}'),
                    ('\u{1d173}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '𞄽'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('𞓫', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '𞥋'),
                    ('🏻', '🏿'),
                    ('\u{e0001}', '\u{e0001}'),
                    ('\u{e0020}', '\u{e007f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const CASED: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ƺ'),
                    ('Ƽ', 'ƿ'),
                    ('Ǆ', 'ʓ'),
                    ('ʕ', 'ʸ'),
                    ('ˀ', 'ˁ'),
                    ('ˠ', 'ˤ'),
                    ('\u{345}', '\u{345}'),
                    ('Ͱ', 'ͳ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՠ', 'ֈ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ჿ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᴀ', 'ᶿ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℯ', 'ℴ'),
                    ('ℹ', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ⅿ'),
                    ('Ↄ', 'ↄ'),
                    ('Ⓐ', 'ⓩ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('Ꙁ', 'ꙭ'),
                    ('Ꚁ', 'ꚝ'),
                    ('Ꜣ', 'ꞇ'),
                    ('Ꞌ', 'ꞎ'),
                    ('Ꞑ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꟶ'),
                    ('ꟸ', 'ꟺ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('𐐀', '𐑏'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐞀', '𐞀'),
                    ('𐞃', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐵐', '𐵥'),
                    ('𐵰', '𐶅'),
                    ('𑢠', '𑣟'),
                    ('𖹀', '𖹿'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼉'),
                    ('𝼋', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞤀', '𞥃'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                ];

                pub const CHANGES_WHEN_CASEFOLDED: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('µ', 'µ'),
                    ('À', 'Ö'),
                    ('Ø', 'ß'),
                    ('Ā', 'Ā'),
                    ('Ă', 'Ă'),
                    ('Ą', 'Ą'),
                    ('Ć', 'Ć'),
                    ('Ĉ', 'Ĉ'),
                    ('Ċ', 'Ċ'),
                    ('Č', 'Č'),
                    ('Ď', 'Ď'),
                    ('Đ', 'Đ'),
                    ('Ē', 'Ē'),
                    ('Ĕ', 'Ĕ'),
                    ('Ė', 'Ė'),
                    ('Ę', 'Ę'),
                    ('Ě', 'Ě'),
                    ('Ĝ', 'Ĝ'),
                    ('Ğ', 'Ğ'),
                    ('Ġ', 'Ġ'),
                    ('Ģ', 'Ģ'),
                    ('Ĥ', 'Ĥ'),
                    ('Ħ', 'Ħ'),
                    ('Ĩ', 'Ĩ'),
                    ('Ī', 'Ī'),
                    ('Ĭ', 'Ĭ'),
                    ('Į', 'Į'),
                    ('İ', 'İ'),
                    ('Ĳ', 'Ĳ'),
                    ('Ĵ', 'Ĵ'),
                    ('Ķ', 'Ķ'),
                    ('Ĺ', 'Ĺ'),
                    ('Ļ', 'Ļ'),
                    ('Ľ', 'Ľ'),
                    ('Ŀ', 'Ŀ'),
                    ('Ł', 'Ł'),
                    ('Ń', 'Ń'),
                    ('Ņ', 'Ņ'),
                    ('Ň', 'Ň'),
                    ('ŉ', 'Ŋ'),
                    ('Ō', 'Ō'),
                    ('Ŏ', 'Ŏ'),
                    ('Ő', 'Ő'),
                    ('Œ', 'Œ'),
                    ('Ŕ', 'Ŕ'),
                    ('Ŗ', 'Ŗ'),
                    ('Ř', 'Ř'),
                    ('Ś', 'Ś'),
                    ('Ŝ', 'Ŝ'),
                    ('Ş', 'Ş'),
                    ('Š', 'Š'),
                    ('Ţ', 'Ţ'),
                    ('Ť', 'Ť'),
                    ('Ŧ', 'Ŧ'),
                    ('Ũ', 'Ũ'),
                    ('Ū', 'Ū'),
                    ('Ŭ', 'Ŭ'),
                    ('Ů', 'Ů'),
                    ('Ű', 'Ű'),
                    ('Ų', 'Ų'),
                    ('Ŵ', 'Ŵ'),
                    ('Ŷ', 'Ŷ'),
                    ('Ÿ', 'Ź'),
                    ('Ż', 'Ż'),
                    ('Ž', 'Ž'),
                    ('ſ', 'ſ'),
                    ('Ɓ', 'Ƃ'),
                    ('Ƅ', 'Ƅ'),
                    ('Ɔ', 'Ƈ'),
                    ('Ɖ', 'Ƌ'),
                    ('Ǝ', 'Ƒ'),
                    ('Ɠ', 'Ɣ'),
                    ('Ɩ', 'Ƙ'),
                    ('Ɯ', 'Ɲ'),
                    ('Ɵ', 'Ơ'),
                    ('Ƣ', 'Ƣ'),
                    ('Ƥ', 'Ƥ'),
                    ('Ʀ', 'Ƨ'),
                    ('Ʃ', 'Ʃ'),
                    ('Ƭ', 'Ƭ'),
                    ('Ʈ', 'Ư'),
                    ('Ʊ', 'Ƴ'),
                    ('Ƶ', 'Ƶ'),
                    ('Ʒ', 'Ƹ'),
                    ('Ƽ', 'Ƽ'),
                    ('Ǆ', 'ǅ'),
                    ('Ǉ', 'ǈ'),
                    ('Ǌ', 'ǋ'),
                    ('Ǎ', 'Ǎ'),
                    ('Ǐ', 'Ǐ'),
                    ('Ǒ', 'Ǒ'),
                    ('Ǔ', 'Ǔ'),
                    ('Ǖ', 'Ǖ'),
                    ('Ǘ', 'Ǘ'),
                    ('Ǚ', 'Ǚ'),
                    ('Ǜ', 'Ǜ'),
                    ('Ǟ', 'Ǟ'),
                    ('Ǡ', 'Ǡ'),
                    ('Ǣ', 'Ǣ'),
                    ('Ǥ', 'Ǥ'),
                    ('Ǧ', 'Ǧ'),
                    ('Ǩ', 'Ǩ'),
                    ('Ǫ', 'Ǫ'),
                    ('Ǭ', 'Ǭ'),
                    ('Ǯ', 'Ǯ'),
                    ('Ǳ', 'ǲ'),
                    ('Ǵ', 'Ǵ'),
                    ('Ƕ', 'Ǹ'),
                    ('Ǻ', 'Ǻ'),
                    ('Ǽ', 'Ǽ'),
                    ('Ǿ', 'Ǿ'),
                    ('Ȁ', 'Ȁ'),
                    ('Ȃ', 'Ȃ'),
                    ('Ȅ', 'Ȅ'),
                    ('Ȇ', 'Ȇ'),
                    ('Ȉ', 'Ȉ'),
                    ('Ȋ', 'Ȋ'),
                    ('Ȍ', 'Ȍ'),
                    ('Ȏ', 'Ȏ'),
                    ('Ȑ', 'Ȑ'),
                    ('Ȓ', 'Ȓ'),
                    ('Ȕ', 'Ȕ'),
                    ('Ȗ', 'Ȗ'),
                    ('Ș', 'Ș'),
                    ('Ț', 'Ț'),
                    ('Ȝ', 'Ȝ'),
                    ('Ȟ', 'Ȟ'),
                    ('Ƞ', 'Ƞ'),
                    ('Ȣ', 'Ȣ'),
                    ('Ȥ', 'Ȥ'),
                    ('Ȧ', 'Ȧ'),
                    ('Ȩ', 'Ȩ'),
                    ('Ȫ', 'Ȫ'),
                    ('Ȭ', 'Ȭ'),
                    ('Ȯ', 'Ȯ'),
                    ('Ȱ', 'Ȱ'),
                    ('Ȳ', 'Ȳ'),
                    ('Ⱥ', 'Ȼ'),
                    ('Ƚ', 'Ⱦ'),
                    ('Ɂ', 'Ɂ'),
                    ('Ƀ', 'Ɇ'),
                    ('Ɉ', 'Ɉ'),
                    ('Ɋ', 'Ɋ'),
                    ('Ɍ', 'Ɍ'),
                    ('Ɏ', 'Ɏ'),
                    ('\u{345}', '\u{345}'),
                    ('Ͱ', 'Ͱ'),
                    ('Ͳ', 'Ͳ'),
                    ('Ͷ', 'Ͷ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ώ'),
                    ('Α', 'Ρ'),
                    ('Σ', 'Ϋ'),
                    ('ς', 'ς'),
                    ('Ϗ', 'ϑ'),
                    ('ϕ', 'ϖ'),
                    ('Ϙ', 'Ϙ'),
                    ('Ϛ', 'Ϛ'),
                    ('Ϝ', 'Ϝ'),
                    ('Ϟ', 'Ϟ'),
                    ('Ϡ', 'Ϡ'),
                    ('Ϣ', 'Ϣ'),
                    ('Ϥ', 'Ϥ'),
                    ('Ϧ', 'Ϧ'),
                    ('Ϩ', 'Ϩ'),
                    ('Ϫ', 'Ϫ'),
                    ('Ϭ', 'Ϭ'),
                    ('Ϯ', 'Ϯ'),
                    ('ϰ', 'ϱ'),
                    ('ϴ', 'ϵ'),
                    ('Ϸ', 'Ϸ'),
                    ('Ϲ', 'Ϻ'),
                    ('Ͻ', 'Я'),
                    ('Ѡ', 'Ѡ'),
                    ('Ѣ', 'Ѣ'),
                    ('Ѥ', 'Ѥ'),
                    ('Ѧ', 'Ѧ'),
                    ('Ѩ', 'Ѩ'),
                    ('Ѫ', 'Ѫ'),
                    ('Ѭ', 'Ѭ'),
                    ('Ѯ', 'Ѯ'),
                    ('Ѱ', 'Ѱ'),
                    ('Ѳ', 'Ѳ'),
                    ('Ѵ', 'Ѵ'),
                    ('Ѷ', 'Ѷ'),
                    ('Ѹ', 'Ѹ'),
                    ('Ѻ', 'Ѻ'),
                    ('Ѽ', 'Ѽ'),
                    ('Ѿ', 'Ѿ'),
                    ('Ҁ', 'Ҁ'),
                    ('Ҋ', 'Ҋ'),
                    ('Ҍ', 'Ҍ'),
                    ('Ҏ', 'Ҏ'),
                    ('Ґ', 'Ґ'),
                    ('Ғ', 'Ғ'),
                    ('Ҕ', 'Ҕ'),
                    ('Җ', 'Җ'),
                    ('Ҙ', 'Ҙ'),
                    ('Қ', 'Қ'),
                    ('Ҝ', 'Ҝ'),
                    ('Ҟ', 'Ҟ'),
                    ('Ҡ', 'Ҡ'),
                    ('Ң', 'Ң'),
                    ('Ҥ', 'Ҥ'),
                    ('Ҧ', 'Ҧ'),
                    ('Ҩ', 'Ҩ'),
                    ('Ҫ', 'Ҫ'),
                    ('Ҭ', 'Ҭ'),
                    ('Ү', 'Ү'),
                    ('Ұ', 'Ұ'),
                    ('Ҳ', 'Ҳ'),
                    ('Ҵ', 'Ҵ'),
                    ('Ҷ', 'Ҷ'),
                    ('Ҹ', 'Ҹ'),
                    ('Һ', 'Һ'),
                    ('Ҽ', 'Ҽ'),
                    ('Ҿ', 'Ҿ'),
                    ('Ӏ', 'Ӂ'),
                    ('Ӄ', 'Ӄ'),
                    ('Ӆ', 'Ӆ'),
                    ('Ӈ', 'Ӈ'),
                    ('Ӊ', 'Ӊ'),
                    ('Ӌ', 'Ӌ'),
                    ('Ӎ', 'Ӎ'),
                    ('Ӑ', 'Ӑ'),
                    ('Ӓ', 'Ӓ'),
                    ('Ӕ', 'Ӕ'),
                    ('Ӗ', 'Ӗ'),
                    ('Ә', 'Ә'),
                    ('Ӛ', 'Ӛ'),
                    ('Ӝ', 'Ӝ'),
                    ('Ӟ', 'Ӟ'),
                    ('Ӡ', 'Ӡ'),
                    ('Ӣ', 'Ӣ'),
                    ('Ӥ', 'Ӥ'),
                    ('Ӧ', 'Ӧ'),
                    ('Ө', 'Ө'),
                    ('Ӫ', 'Ӫ'),
                    ('Ӭ', 'Ӭ'),
                    ('Ӯ', 'Ӯ'),
                    ('Ӱ', 'Ӱ'),
                    ('Ӳ', 'Ӳ'),
                    ('Ӵ', 'Ӵ'),
                    ('Ӷ', 'Ӷ'),
                    ('Ӹ', 'Ӹ'),
                    ('Ӻ', 'Ӻ'),
                    ('Ӽ', 'Ӽ'),
                    ('Ӿ', 'Ӿ'),
                    ('Ԁ', 'Ԁ'),
                    ('Ԃ', 'Ԃ'),
                    ('Ԅ', 'Ԅ'),
                    ('Ԇ', 'Ԇ'),
                    ('Ԉ', 'Ԉ'),
                    ('Ԋ', 'Ԋ'),
                    ('Ԍ', 'Ԍ'),
                    ('Ԏ', 'Ԏ'),
                    ('Ԑ', 'Ԑ'),
                    ('Ԓ', 'Ԓ'),
                    ('Ԕ', 'Ԕ'),
                    ('Ԗ', 'Ԗ'),
                    ('Ԙ', 'Ԙ'),
                    ('Ԛ', 'Ԛ'),
                    ('Ԝ', 'Ԝ'),
                    ('Ԟ', 'Ԟ'),
                    ('Ԡ', 'Ԡ'),
                    ('Ԣ', 'Ԣ'),
                    ('Ԥ', 'Ԥ'),
                    ('Ԧ', 'Ԧ'),
                    ('Ԩ', 'Ԩ'),
                    ('Ԫ', 'Ԫ'),
                    ('Ԭ', 'Ԭ'),
                    ('Ԯ', 'Ԯ'),
                    ('Ա', 'Ֆ'),
                    ('և', 'և'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'Ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('Ḁ', 'Ḁ'),
                    ('Ḃ', 'Ḃ'),
                    ('Ḅ', 'Ḅ'),
                    ('Ḇ', 'Ḇ'),
                    ('Ḉ', 'Ḉ'),
                    ('Ḋ', 'Ḋ'),
                    ('Ḍ', 'Ḍ'),
                    ('Ḏ', 'Ḏ'),
                    ('Ḑ', 'Ḑ'),
                    ('Ḓ', 'Ḓ'),
                    ('Ḕ', 'Ḕ'),
                    ('Ḗ', 'Ḗ'),
                    ('Ḙ', 'Ḙ'),
                    ('Ḛ', 'Ḛ'),
                    ('Ḝ', 'Ḝ'),
                    ('Ḟ', 'Ḟ'),
                    ('Ḡ', 'Ḡ'),
                    ('Ḣ', 'Ḣ'),
                    ('Ḥ', 'Ḥ'),
                    ('Ḧ', 'Ḧ'),
                    ('Ḩ', 'Ḩ'),
                    ('Ḫ', 'Ḫ'),
                    ('Ḭ', 'Ḭ'),
                    ('Ḯ', 'Ḯ'),
                    ('Ḱ', 'Ḱ'),
                    ('Ḳ', 'Ḳ'),
                    ('Ḵ', 'Ḵ'),
                    ('Ḷ', 'Ḷ'),
                    ('Ḹ', 'Ḹ'),
                    ('Ḻ', 'Ḻ'),
                    ('Ḽ', 'Ḽ'),
                    ('Ḿ', 'Ḿ'),
                    ('Ṁ', 'Ṁ'),
                    ('Ṃ', 'Ṃ'),
                    ('Ṅ', 'Ṅ'),
                    ('Ṇ', 'Ṇ'),
                    ('Ṉ', 'Ṉ'),
                    ('Ṋ', 'Ṋ'),
                    ('Ṍ', 'Ṍ'),
                    ('Ṏ', 'Ṏ'),
                    ('Ṑ', 'Ṑ'),
                    ('Ṓ', 'Ṓ'),
                    ('Ṕ', 'Ṕ'),
                    ('Ṗ', 'Ṗ'),
                    ('Ṙ', 'Ṙ'),
                    ('Ṛ', 'Ṛ'),
                    ('Ṝ', 'Ṝ'),
                    ('Ṟ', 'Ṟ'),
                    ('Ṡ', 'Ṡ'),
                    ('Ṣ', 'Ṣ'),
                    ('Ṥ', 'Ṥ'),
                    ('Ṧ', 'Ṧ'),
                    ('Ṩ', 'Ṩ'),
                    ('Ṫ', 'Ṫ'),
                    ('Ṭ', 'Ṭ'),
                    ('Ṯ', 'Ṯ'),
                    ('Ṱ', 'Ṱ'),
                    ('Ṳ', 'Ṳ'),
                    ('Ṵ', 'Ṵ'),
                    ('Ṷ', 'Ṷ'),
                    ('Ṹ', 'Ṹ'),
                    ('Ṻ', 'Ṻ'),
                    ('Ṽ', 'Ṽ'),
                    ('Ṿ', 'Ṿ'),
                    ('Ẁ', 'Ẁ'),
                    ('Ẃ', 'Ẃ'),
                    ('Ẅ', 'Ẅ'),
                    ('Ẇ', 'Ẇ'),
                    ('Ẉ', 'Ẉ'),
                    ('Ẋ', 'Ẋ'),
                    ('Ẍ', 'Ẍ'),
                    ('Ẏ', 'Ẏ'),
                    ('Ẑ', 'Ẑ'),
                    ('Ẓ', 'Ẓ'),
                    ('Ẕ', 'Ẕ'),
                    ('ẚ', 'ẛ'),
                    ('ẞ', 'ẞ'),
                    ('Ạ', 'Ạ'),
                    ('Ả', 'Ả'),
                    ('Ấ', 'Ấ'),
                    ('Ầ', 'Ầ'),
                    ('Ẩ', 'Ẩ'),
                    ('Ẫ', 'Ẫ'),
                    ('Ậ', 'Ậ'),
                    ('Ắ', 'Ắ'),
                    ('Ằ', 'Ằ'),
                    ('Ẳ', 'Ẳ'),
                    ('Ẵ', 'Ẵ'),
                    ('Ặ', 'Ặ'),
                    ('Ẹ', 'Ẹ'),
                    ('Ẻ', 'Ẻ'),
                    ('Ẽ', 'Ẽ'),
                    ('Ế', 'Ế'),
                    ('Ề', 'Ề'),
                    ('Ể', 'Ể'),
                    ('Ễ', 'Ễ'),
                    ('Ệ', 'Ệ'),
                    ('Ỉ', 'Ỉ'),
                    ('Ị', 'Ị'),
                    ('Ọ', 'Ọ'),
                    ('Ỏ', 'Ỏ'),
                    ('Ố', 'Ố'),
                    ('Ồ', 'Ồ'),
                    ('Ổ', 'Ổ'),
                    ('Ỗ', 'Ỗ'),
                    ('Ộ', 'Ộ'),
                    ('Ớ', 'Ớ'),
                    ('Ờ', 'Ờ'),
                    ('Ở', 'Ở'),
                    ('Ỡ', 'Ỡ'),
                    ('Ợ', 'Ợ'),
                    ('Ụ', 'Ụ'),
                    ('Ủ', 'Ủ'),
                    ('Ứ', 'Ứ'),
                    ('Ừ', 'Ừ'),
                    ('Ử', 'Ử'),
                    ('Ữ', 'Ữ'),
                    ('Ự', 'Ự'),
                    ('Ỳ', 'Ỳ'),
                    ('Ỵ', 'Ỵ'),
                    ('Ỷ', 'Ỷ'),
                    ('Ỹ', 'Ỹ'),
                    ('Ỻ', 'Ỻ'),
                    ('Ỽ', 'Ỽ'),
                    ('Ỿ', 'Ỿ'),
                    ('Ἀ', 'Ἇ'),
                    ('Ἐ', 'Ἕ'),
                    ('Ἠ', 'Ἧ'),
                    ('Ἰ', 'Ἷ'),
                    ('Ὀ', 'Ὅ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'Ὗ'),
                    ('Ὠ', 'Ὧ'),
                    ('ᾀ', 'ᾯ'),
                    ('ᾲ', 'ᾴ'),
                    ('ᾷ', 'ᾼ'),
                    ('ῂ', 'ῄ'),
                    ('ῇ', 'ῌ'),
                    ('Ῐ', 'Ί'),
                    ('Ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῷ', 'ῼ'),
                    ('Ω', 'Ω'),
                    ('K', 'Å'),
                    ('Ⅎ', 'Ⅎ'),
                    ('Ⅰ', 'Ⅿ'),
                    ('Ↄ', 'Ↄ'),
                    ('Ⓐ', 'Ⓩ'),
                    ('Ⰰ', 'Ⱟ'),
                    ('Ⱡ', 'Ⱡ'),
                    ('Ɫ', 'Ɽ'),
                    ('Ⱨ', 'Ⱨ'),
                    ('Ⱪ', 'Ⱪ'),
                    ('Ⱬ', 'Ⱬ'),
                    ('Ɑ', 'Ɒ'),
                    ('Ⱳ', 'Ⱳ'),
                    ('Ⱶ', 'Ⱶ'),
                    ('Ȿ', 'Ⲁ'),
                    ('Ⲃ', 'Ⲃ'),
                    ('Ⲅ', 'Ⲅ'),
                    ('Ⲇ', 'Ⲇ'),
                    ('Ⲉ', 'Ⲉ'),
                    ('Ⲋ', 'Ⲋ'),
                    ('Ⲍ', 'Ⲍ'),
                    ('Ⲏ', 'Ⲏ'),
                    ('Ⲑ', 'Ⲑ'),
                    ('Ⲓ', 'Ⲓ'),
                    ('Ⲕ', 'Ⲕ'),
                    ('Ⲗ', 'Ⲗ'),
                    ('Ⲙ', 'Ⲙ'),
                    ('Ⲛ', 'Ⲛ'),
                    ('Ⲝ', 'Ⲝ'),
                    ('Ⲟ', 'Ⲟ'),
                    ('Ⲡ', 'Ⲡ'),
                    ('Ⲣ', 'Ⲣ'),
                    ('Ⲥ', 'Ⲥ'),
                    ('Ⲧ', 'Ⲧ'),
                    ('Ⲩ', 'Ⲩ'),
                    ('Ⲫ', 'Ⲫ'),
                    ('Ⲭ', 'Ⲭ'),
                    ('Ⲯ', 'Ⲯ'),
                    ('Ⲱ', 'Ⲱ'),
                    ('Ⲳ', 'Ⲳ'),
                    ('Ⲵ', 'Ⲵ'),
                    ('Ⲷ', 'Ⲷ'),
                    ('Ⲹ', 'Ⲹ'),
                    ('Ⲻ', 'Ⲻ'),
                    ('Ⲽ', 'Ⲽ'),
                    ('Ⲿ', 'Ⲿ'),
                    ('Ⳁ', 'Ⳁ'),
                    ('Ⳃ', 'Ⳃ'),
                    ('Ⳅ', 'Ⳅ'),
                    ('Ⳇ', 'Ⳇ'),
                    ('Ⳉ', 'Ⳉ'),
                    ('Ⳋ', 'Ⳋ'),
                    ('Ⳍ', 'Ⳍ'),
                    ('Ⳏ', 'Ⳏ'),
                    ('Ⳑ', 'Ⳑ'),
                    ('Ⳓ', 'Ⳓ'),
                    ('Ⳕ', 'Ⳕ'),
                    ('Ⳗ', 'Ⳗ'),
                    ('Ⳙ', 'Ⳙ'),
                    ('Ⳛ', 'Ⳛ'),
                    ('Ⳝ', 'Ⳝ'),
                    ('Ⳟ', 'Ⳟ'),
                    ('Ⳡ', 'Ⳡ'),
                    ('Ⳣ', 'Ⳣ'),
                    ('Ⳬ', 'Ⳬ'),
                    ('Ⳮ', 'Ⳮ'),
                    ('Ⳳ', 'Ⳳ'),
                    ('Ꙁ', 'Ꙁ'),
                    ('Ꙃ', 'Ꙃ'),
                    ('Ꙅ', 'Ꙅ'),
                    ('Ꙇ', 'Ꙇ'),
                    ('Ꙉ', 'Ꙉ'),
                    ('Ꙋ', 'Ꙋ'),
                    ('Ꙍ', 'Ꙍ'),
                    ('Ꙏ', 'Ꙏ'),
                    ('Ꙑ', 'Ꙑ'),
                    ('Ꙓ', 'Ꙓ'),
                    ('Ꙕ', 'Ꙕ'),
                    ('Ꙗ', 'Ꙗ'),
                    ('Ꙙ', 'Ꙙ'),
                    ('Ꙛ', 'Ꙛ'),
                    ('Ꙝ', 'Ꙝ'),
                    ('Ꙟ', 'Ꙟ'),
                    ('Ꙡ', 'Ꙡ'),
                    ('Ꙣ', 'Ꙣ'),
                    ('Ꙥ', 'Ꙥ'),
                    ('Ꙧ', 'Ꙧ'),
                    ('Ꙩ', 'Ꙩ'),
                    ('Ꙫ', 'Ꙫ'),
                    ('Ꙭ', 'Ꙭ'),
                    ('Ꚁ', 'Ꚁ'),
                    ('Ꚃ', 'Ꚃ'),
                    ('Ꚅ', 'Ꚅ'),
                    ('Ꚇ', 'Ꚇ'),
                    ('Ꚉ', 'Ꚉ'),
                    ('Ꚋ', 'Ꚋ'),
                    ('Ꚍ', 'Ꚍ'),
                    ('Ꚏ', 'Ꚏ'),
                    ('Ꚑ', 'Ꚑ'),
                    ('Ꚓ', 'Ꚓ'),
                    ('Ꚕ', 'Ꚕ'),
                    ('Ꚗ', 'Ꚗ'),
                    ('Ꚙ', 'Ꚙ'),
                    ('Ꚛ', 'Ꚛ'),
                    ('Ꜣ', 'Ꜣ'),
                    ('Ꜥ', 'Ꜥ'),
                    ('Ꜧ', 'Ꜧ'),
                    ('Ꜩ', 'Ꜩ'),
                    ('Ꜫ', 'Ꜫ'),
                    ('Ꜭ', 'Ꜭ'),
                    ('Ꜯ', 'Ꜯ'),
                    ('Ꜳ', 'Ꜳ'),
                    ('Ꜵ', 'Ꜵ'),
                    ('Ꜷ', 'Ꜷ'),
                    ('Ꜹ', 'Ꜹ'),
                    ('Ꜻ', 'Ꜻ'),
                    ('Ꜽ', 'Ꜽ'),
                    ('Ꜿ', 'Ꜿ'),
                    ('Ꝁ', 'Ꝁ'),
                    ('Ꝃ', 'Ꝃ'),
                    ('Ꝅ', 'Ꝅ'),
                    ('Ꝇ', 'Ꝇ'),
                    ('Ꝉ', 'Ꝉ'),
                    ('Ꝋ', 'Ꝋ'),
                    ('Ꝍ', 'Ꝍ'),
                    ('Ꝏ', 'Ꝏ'),
                    ('Ꝑ', 'Ꝑ'),
                    ('Ꝓ', 'Ꝓ'),
                    ('Ꝕ', 'Ꝕ'),
                    ('Ꝗ', 'Ꝗ'),
                    ('Ꝙ', 'Ꝙ'),
                    ('Ꝛ', 'Ꝛ'),
                    ('Ꝝ', 'Ꝝ'),
                    ('Ꝟ', 'Ꝟ'),
                    ('Ꝡ', 'Ꝡ'),
                    ('Ꝣ', 'Ꝣ'),
                    ('Ꝥ', 'Ꝥ'),
                    ('Ꝧ', 'Ꝧ'),
                    ('Ꝩ', 'Ꝩ'),
                    ('Ꝫ', 'Ꝫ'),
                    ('Ꝭ', 'Ꝭ'),
                    ('Ꝯ', 'Ꝯ'),
                    ('Ꝺ', 'Ꝺ'),
                    ('Ꝼ', 'Ꝼ'),
                    ('Ᵹ', 'Ꝿ'),
                    ('Ꞁ', 'Ꞁ'),
                    ('Ꞃ', 'Ꞃ'),
                    ('Ꞅ', 'Ꞅ'),
                    ('Ꞇ', 'Ꞇ'),
                    ('Ꞌ', 'Ꞌ'),
                    ('Ɥ', 'Ɥ'),
                    ('Ꞑ', 'Ꞑ'),
                    ('Ꞓ', 'Ꞓ'),
                    ('Ꞗ', 'Ꞗ'),
                    ('Ꞙ', 'Ꞙ'),
                    ('Ꞛ', 'Ꞛ'),
                    ('Ꞝ', 'Ꞝ'),
                    ('Ꞟ', 'Ꞟ'),
                    ('Ꞡ', 'Ꞡ'),
                    ('Ꞣ', 'Ꞣ'),
                    ('Ꞥ', 'Ꞥ'),
                    ('Ꞧ', 'Ꞧ'),
                    ('Ꞩ', 'Ꞩ'),
                    ('Ɦ', 'Ɪ'),
                    ('Ʞ', 'Ꞵ'),
                    ('Ꞷ', 'Ꞷ'),
                    ('Ꞹ', 'Ꞹ'),
                    ('Ꞻ', 'Ꞻ'),
                    ('Ꞽ', 'Ꞽ'),
                    ('Ꞿ', 'Ꞿ'),
                    ('Ꟁ', 'Ꟁ'),
                    ('Ꟃ', 'Ꟃ'),
                    ('Ꞔ', 'Ꟈ'),
                    ('Ꟊ', 'Ꟊ'),
                    ('Ɤ', 'Ꟍ'),
                    ('Ꟑ', 'Ꟑ'),
                    ('Ꟗ', 'Ꟗ'),
                    ('Ꟙ', 'Ꟙ'),
                    ('Ꟛ', 'Ꟛ'),
                    ('Ƛ', 'Ƛ'),
                    ('Ꟶ', 'Ꟶ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('Ａ', 'Ｚ'),
                    ('𐐀', '𐐧'),
                    ('𐒰', '𐓓'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐲀', '𐲲'),
                    ('𐵐', '𐵥'),
                    ('𑢠', '𑢿'),
                    ('𖹀', '𖹟'),
                    ('𞤀', '𞤡'),
                ];

                pub const CHANGES_WHEN_CASEMAPPED: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('µ', 'µ'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ķ'),
                    ('Ĺ', 'ƌ'),
                    ('Ǝ', 'Ʃ'),
                    ('Ƭ', 'ƹ'),
                    ('Ƽ', 'ƽ'),
                    ('ƿ', 'ƿ'),
                    ('Ǆ', 'Ƞ'),
                    ('Ȣ', 'ȳ'),
                    ('Ⱥ', 'ɔ'),
                    ('ɖ', 'ɗ'),
                    ('ə', 'ə'),
                    ('ɛ', 'ɜ'),
                    ('ɠ', 'ɡ'),
                    ('ɣ', 'ɦ'),
                    ('ɨ', 'ɬ'),
                    ('ɯ', 'ɯ'),
                    ('ɱ', 'ɲ'),
                    ('ɵ', 'ɵ'),
                    ('ɽ', 'ɽ'),
                    ('ʀ', 'ʀ'),
                    ('ʂ', 'ʃ'),
                    ('ʇ', 'ʌ'),
                    ('ʒ', 'ʒ'),
                    ('ʝ', 'ʞ'),
                    ('\u{345}', '\u{345}'),
                    ('Ͱ', 'ͳ'),
                    ('Ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϑ'),
                    ('ϕ', 'ϵ'),
                    ('Ϸ', 'ϻ'),
                    ('Ͻ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ա', 'և'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჽ', 'ჿ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᵹ', 'ᵹ'),
                    ('ᵽ', 'ᵽ'),
                    ('ᶎ', 'ᶎ'),
                    ('Ḁ', 'ẛ'),
                    ('ẞ', 'ẞ'),
                    ('Ạ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('Ω', 'Ω'),
                    ('K', 'Å'),
                    ('Ⅎ', 'Ⅎ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ⅿ'),
                    ('Ↄ', 'ↄ'),
                    ('Ⓐ', 'ⓩ'),
                    ('Ⰰ', 'Ɒ'),
                    ('Ⱳ', 'ⱳ'),
                    ('Ⱶ', 'ⱶ'),
                    ('Ȿ', 'ⳣ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('Ꙁ', 'ꙭ'),
                    ('Ꚁ', 'ꚛ'),
                    ('Ꜣ', 'ꜯ'),
                    ('Ꜳ', 'ꝯ'),
                    ('Ꝺ', 'ꞇ'),
                    ('Ꞌ', 'Ɥ'),
                    ('Ꞑ', 'ꞔ'),
                    ('Ꞗ', 'Ɪ'),
                    ('Ʞ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('Ꟗ', 'Ƛ'),
                    ('Ꟶ', 'ꟶ'),
                    ('ꭓ', 'ꭓ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('𐐀', '𐑏'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐵐', '𐵥'),
                    ('𐵰', '𐶅'),
                    ('𑢠', '𑣟'),
                    ('𖹀', '𖹿'),
                    ('𞤀', '𞥃'),
                ];

                pub const CHANGES_WHEN_LOWERCASED: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('À', 'Ö'),
                    ('Ø', 'Þ'),
                    ('Ā', 'Ā'),
                    ('Ă', 'Ă'),
                    ('Ą', 'Ą'),
                    ('Ć', 'Ć'),
                    ('Ĉ', 'Ĉ'),
                    ('Ċ', 'Ċ'),
                    ('Č', 'Č'),
                    ('Ď', 'Ď'),
                    ('Đ', 'Đ'),
                    ('Ē', 'Ē'),
                    ('Ĕ', 'Ĕ'),
                    ('Ė', 'Ė'),
                    ('Ę', 'Ę'),
                    ('Ě', 'Ě'),
                    ('Ĝ', 'Ĝ'),
                    ('Ğ', 'Ğ'),
                    ('Ġ', 'Ġ'),
                    ('Ģ', 'Ģ'),
                    ('Ĥ', 'Ĥ'),
                    ('Ħ', 'Ħ'),
                    ('Ĩ', 'Ĩ'),
                    ('Ī', 'Ī'),
                    ('Ĭ', 'Ĭ'),
                    ('Į', 'Į'),
                    ('İ', 'İ'),
                    ('Ĳ', 'Ĳ'),
                    ('Ĵ', 'Ĵ'),
                    ('Ķ', 'Ķ'),
                    ('Ĺ', 'Ĺ'),
                    ('Ļ', 'Ļ'),
                    ('Ľ', 'Ľ'),
                    ('Ŀ', 'Ŀ'),
                    ('Ł', 'Ł'),
                    ('Ń', 'Ń'),
                    ('Ņ', 'Ņ'),
                    ('Ň', 'Ň'),
                    ('Ŋ', 'Ŋ'),
                    ('Ō', 'Ō'),
                    ('Ŏ', 'Ŏ'),
                    ('Ő', 'Ő'),
                    ('Œ', 'Œ'),
                    ('Ŕ', 'Ŕ'),
                    ('Ŗ', 'Ŗ'),
                    ('Ř', 'Ř'),
                    ('Ś', 'Ś'),
                    ('Ŝ', 'Ŝ'),
                    ('Ş', 'Ş'),
                    ('Š', 'Š'),
                    ('Ţ', 'Ţ'),
                    ('Ť', 'Ť'),
                    ('Ŧ', 'Ŧ'),
                    ('Ũ', 'Ũ'),
                    ('Ū', 'Ū'),
                    ('Ŭ', 'Ŭ'),
                    ('Ů', 'Ů'),
                    ('Ű', 'Ű'),
                    ('Ų', 'Ų'),
                    ('Ŵ', 'Ŵ'),
                    ('Ŷ', 'Ŷ'),
                    ('Ÿ', 'Ź'),
                    ('Ż', 'Ż'),
                    ('Ž', 'Ž'),
                    ('Ɓ', 'Ƃ'),
                    ('Ƅ', 'Ƅ'),
                    ('Ɔ', 'Ƈ'),
                    ('Ɖ', 'Ƌ'),
                    ('Ǝ', 'Ƒ'),
                    ('Ɠ', 'Ɣ'),
                    ('Ɩ', 'Ƙ'),
                    ('Ɯ', 'Ɲ'),
                    ('Ɵ', 'Ơ'),
                    ('Ƣ', 'Ƣ'),
                    ('Ƥ', 'Ƥ'),
                    ('Ʀ', 'Ƨ'),
                    ('Ʃ', 'Ʃ'),
                    ('Ƭ', 'Ƭ'),
                    ('Ʈ', 'Ư'),
                    ('Ʊ', 'Ƴ'),
                    ('Ƶ', 'Ƶ'),
                    ('Ʒ', 'Ƹ'),
                    ('Ƽ', 'Ƽ'),
                    ('Ǆ', 'ǅ'),
                    ('Ǉ', 'ǈ'),
                    ('Ǌ', 'ǋ'),
                    ('Ǎ', 'Ǎ'),
                    ('Ǐ', 'Ǐ'),
                    ('Ǒ', 'Ǒ'),
                    ('Ǔ', 'Ǔ'),
                    ('Ǖ', 'Ǖ'),
                    ('Ǘ', 'Ǘ'),
                    ('Ǚ', 'Ǚ'),
                    ('Ǜ', 'Ǜ'),
                    ('Ǟ', 'Ǟ'),
                    ('Ǡ', 'Ǡ'),
                    ('Ǣ', 'Ǣ'),
                    ('Ǥ', 'Ǥ'),
                    ('Ǧ', 'Ǧ'),
                    ('Ǩ', 'Ǩ'),
                    ('Ǫ', 'Ǫ'),
                    ('Ǭ', 'Ǭ'),
                    ('Ǯ', 'Ǯ'),
                    ('Ǳ', 'ǲ'),
                    ('Ǵ', 'Ǵ'),
                    ('Ƕ', 'Ǹ'),
                    ('Ǻ', 'Ǻ'),
                    ('Ǽ', 'Ǽ'),
                    ('Ǿ', 'Ǿ'),
                    ('Ȁ', 'Ȁ'),
                    ('Ȃ', 'Ȃ'),
                    ('Ȅ', 'Ȅ'),
                    ('Ȇ', 'Ȇ'),
                    ('Ȉ', 'Ȉ'),
                    ('Ȋ', 'Ȋ'),
                    ('Ȍ', 'Ȍ'),
                    ('Ȏ', 'Ȏ'),
                    ('Ȑ', 'Ȑ'),
                    ('Ȓ', 'Ȓ'),
                    ('Ȕ', 'Ȕ'),
                    ('Ȗ', 'Ȗ'),
                    ('Ș', 'Ș'),
                    ('Ț', 'Ț'),
                    ('Ȝ', 'Ȝ'),
                    ('Ȟ', 'Ȟ'),
                    ('Ƞ', 'Ƞ'),
                    ('Ȣ', 'Ȣ'),
                    ('Ȥ', 'Ȥ'),
                    ('Ȧ', 'Ȧ'),
                    ('Ȩ', 'Ȩ'),
                    ('Ȫ', 'Ȫ'),
                    ('Ȭ', 'Ȭ'),
                    ('Ȯ', 'Ȯ'),
                    ('Ȱ', 'Ȱ'),
                    ('Ȳ', 'Ȳ'),
                    ('Ⱥ', 'Ȼ'),
                    ('Ƚ', 'Ⱦ'),
                    ('Ɂ', 'Ɂ'),
                    ('Ƀ', 'Ɇ'),
                    ('Ɉ', 'Ɉ'),
                    ('Ɋ', 'Ɋ'),
                    ('Ɍ', 'Ɍ'),
                    ('Ɏ', 'Ɏ'),
                    ('Ͱ', 'Ͱ'),
                    ('Ͳ', 'Ͳ'),
                    ('Ͷ', 'Ͷ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ώ'),
                    ('Α', 'Ρ'),
                    ('Σ', 'Ϋ'),
                    ('Ϗ', 'Ϗ'),
                    ('Ϙ', 'Ϙ'),
                    ('Ϛ', 'Ϛ'),
                    ('Ϝ', 'Ϝ'),
                    ('Ϟ', 'Ϟ'),
                    ('Ϡ', 'Ϡ'),
                    ('Ϣ', 'Ϣ'),
                    ('Ϥ', 'Ϥ'),
                    ('Ϧ', 'Ϧ'),
                    ('Ϩ', 'Ϩ'),
                    ('Ϫ', 'Ϫ'),
                    ('Ϭ', 'Ϭ'),
                    ('Ϯ', 'Ϯ'),
                    ('ϴ', 'ϴ'),
                    ('Ϸ', 'Ϸ'),
                    ('Ϲ', 'Ϻ'),
                    ('Ͻ', 'Я'),
                    ('Ѡ', 'Ѡ'),
                    ('Ѣ', 'Ѣ'),
                    ('Ѥ', 'Ѥ'),
                    ('Ѧ', 'Ѧ'),
                    ('Ѩ', 'Ѩ'),
                    ('Ѫ', 'Ѫ'),
                    ('Ѭ', 'Ѭ'),
                    ('Ѯ', 'Ѯ'),
                    ('Ѱ', 'Ѱ'),
                    ('Ѳ', 'Ѳ'),
                    ('Ѵ', 'Ѵ'),
                    ('Ѷ', 'Ѷ'),
                    ('Ѹ', 'Ѹ'),
                    ('Ѻ', 'Ѻ'),
                    ('Ѽ', 'Ѽ'),
                    ('Ѿ', 'Ѿ'),
                    ('Ҁ', 'Ҁ'),
                    ('Ҋ', 'Ҋ'),
                    ('Ҍ', 'Ҍ'),
                    ('Ҏ', 'Ҏ'),
                    ('Ґ', 'Ґ'),
                    ('Ғ', 'Ғ'),
                    ('Ҕ', 'Ҕ'),
                    ('Җ', 'Җ'),
                    ('Ҙ', 'Ҙ'),
                    ('Қ', 'Қ'),
                    ('Ҝ', 'Ҝ'),
                    ('Ҟ', 'Ҟ'),
                    ('Ҡ', 'Ҡ'),
                    ('Ң', 'Ң'),
                    ('Ҥ', 'Ҥ'),
                    ('Ҧ', 'Ҧ'),
                    ('Ҩ', 'Ҩ'),
                    ('Ҫ', 'Ҫ'),
                    ('Ҭ', 'Ҭ'),
                    ('Ү', 'Ү'),
                    ('Ұ', 'Ұ'),
                    ('Ҳ', 'Ҳ'),
                    ('Ҵ', 'Ҵ'),
                    ('Ҷ', 'Ҷ'),
                    ('Ҹ', 'Ҹ'),
                    ('Һ', 'Һ'),
                    ('Ҽ', 'Ҽ'),
                    ('Ҿ', 'Ҿ'),
                    ('Ӏ', 'Ӂ'),
                    ('Ӄ', 'Ӄ'),
                    ('Ӆ', 'Ӆ'),
                    ('Ӈ', 'Ӈ'),
                    ('Ӊ', 'Ӊ'),
                    ('Ӌ', 'Ӌ'),
                    ('Ӎ', 'Ӎ'),
                    ('Ӑ', 'Ӑ'),
                    ('Ӓ', 'Ӓ'),
                    ('Ӕ', 'Ӕ'),
                    ('Ӗ', 'Ӗ'),
                    ('Ә', 'Ә'),
                    ('Ӛ', 'Ӛ'),
                    ('Ӝ', 'Ӝ'),
                    ('Ӟ', 'Ӟ'),
                    ('Ӡ', 'Ӡ'),
                    ('Ӣ', 'Ӣ'),
                    ('Ӥ', 'Ӥ'),
                    ('Ӧ', 'Ӧ'),
                    ('Ө', 'Ө'),
                    ('Ӫ', 'Ӫ'),
                    ('Ӭ', 'Ӭ'),
                    ('Ӯ', 'Ӯ'),
                    ('Ӱ', 'Ӱ'),
                    ('Ӳ', 'Ӳ'),
                    ('Ӵ', 'Ӵ'),
                    ('Ӷ', 'Ӷ'),
                    ('Ӹ', 'Ӹ'),
                    ('Ӻ', 'Ӻ'),
                    ('Ӽ', 'Ӽ'),
                    ('Ӿ', 'Ӿ'),
                    ('Ԁ', 'Ԁ'),
                    ('Ԃ', 'Ԃ'),
                    ('Ԅ', 'Ԅ'),
                    ('Ԇ', 'Ԇ'),
                    ('Ԉ', 'Ԉ'),
                    ('Ԋ', 'Ԋ'),
                    ('Ԍ', 'Ԍ'),
                    ('Ԏ', 'Ԏ'),
                    ('Ԑ', 'Ԑ'),
                    ('Ԓ', 'Ԓ'),
                    ('Ԕ', 'Ԕ'),
                    ('Ԗ', 'Ԗ'),
                    ('Ԙ', 'Ԙ'),
                    ('Ԛ', 'Ԛ'),
                    ('Ԝ', 'Ԝ'),
                    ('Ԟ', 'Ԟ'),
                    ('Ԡ', 'Ԡ'),
                    ('Ԣ', 'Ԣ'),
                    ('Ԥ', 'Ԥ'),
                    ('Ԧ', 'Ԧ'),
                    ('Ԩ', 'Ԩ'),
                    ('Ԫ', 'Ԫ'),
                    ('Ԭ', 'Ԭ'),
                    ('Ԯ', 'Ԯ'),
                    ('Ա', 'Ֆ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('Ᲊ', 'Ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('Ḁ', 'Ḁ'),
                    ('Ḃ', 'Ḃ'),
                    ('Ḅ', 'Ḅ'),
                    ('Ḇ', 'Ḇ'),
                    ('Ḉ', 'Ḉ'),
                    ('Ḋ', 'Ḋ'),
                    ('Ḍ', 'Ḍ'),
                    ('Ḏ', 'Ḏ'),
                    ('Ḑ', 'Ḑ'),
                    ('Ḓ', 'Ḓ'),
                    ('Ḕ', 'Ḕ'),
                    ('Ḗ', 'Ḗ'),
                    ('Ḙ', 'Ḙ'),
                    ('Ḛ', 'Ḛ'),
                    ('Ḝ', 'Ḝ'),
                    ('Ḟ', 'Ḟ'),
                    ('Ḡ', 'Ḡ'),
                    ('Ḣ', 'Ḣ'),
                    ('Ḥ', 'Ḥ'),
                    ('Ḧ', 'Ḧ'),
                    ('Ḩ', 'Ḩ'),
                    ('Ḫ', 'Ḫ'),
                    ('Ḭ', 'Ḭ'),
                    ('Ḯ', 'Ḯ'),
                    ('Ḱ', 'Ḱ'),
                    ('Ḳ', 'Ḳ'),
                    ('Ḵ', 'Ḵ'),
                    ('Ḷ', 'Ḷ'),
                    ('Ḹ', 'Ḹ'),
                    ('Ḻ', 'Ḻ'),
                    ('Ḽ', 'Ḽ'),
                    ('Ḿ', 'Ḿ'),
                    ('Ṁ', 'Ṁ'),
                    ('Ṃ', 'Ṃ'),
                    ('Ṅ', 'Ṅ'),
                    ('Ṇ', 'Ṇ'),
                    ('Ṉ', 'Ṉ'),
                    ('Ṋ', 'Ṋ'),
                    ('Ṍ', 'Ṍ'),
                    ('Ṏ', 'Ṏ'),
                    ('Ṑ', 'Ṑ'),
                    ('Ṓ', 'Ṓ'),
                    ('Ṕ', 'Ṕ'),
                    ('Ṗ', 'Ṗ'),
                    ('Ṙ', 'Ṙ'),
                    ('Ṛ', 'Ṛ'),
                    ('Ṝ', 'Ṝ'),
                    ('Ṟ', 'Ṟ'),
                    ('Ṡ', 'Ṡ'),
                    ('Ṣ', 'Ṣ'),
                    ('Ṥ', 'Ṥ'),
                    ('Ṧ', 'Ṧ'),
                    ('Ṩ', 'Ṩ'),
                    ('Ṫ', 'Ṫ'),
                    ('Ṭ', 'Ṭ'),
                    ('Ṯ', 'Ṯ'),
                    ('Ṱ', 'Ṱ'),
                    ('Ṳ', 'Ṳ'),
                    ('Ṵ', 'Ṵ'),
                    ('Ṷ', 'Ṷ'),
                    ('Ṹ', 'Ṹ'),
                    ('Ṻ', 'Ṻ'),
                    ('Ṽ', 'Ṽ'),
                    ('Ṿ', 'Ṿ'),
                    ('Ẁ', 'Ẁ'),
                    ('Ẃ', 'Ẃ'),
                    ('Ẅ', 'Ẅ'),
                    ('Ẇ', 'Ẇ'),
                    ('Ẉ', 'Ẉ'),
                    ('Ẋ', 'Ẋ'),
                    ('Ẍ', 'Ẍ'),
                    ('Ẏ', 'Ẏ'),
                    ('Ẑ', 'Ẑ'),
                    ('Ẓ', 'Ẓ'),
                    ('Ẕ', 'Ẕ'),
                    ('ẞ', 'ẞ'),
                    ('Ạ', 'Ạ'),
                    ('Ả', 'Ả'),
                    ('Ấ', 'Ấ'),
                    ('Ầ', 'Ầ'),
                    ('Ẩ', 'Ẩ'),
                    ('Ẫ', 'Ẫ'),
                    ('Ậ', 'Ậ'),
                    ('Ắ', 'Ắ'),
                    ('Ằ', 'Ằ'),
                    ('Ẳ', 'Ẳ'),
                    ('Ẵ', 'Ẵ'),
                    ('Ặ', 'Ặ'),
                    ('Ẹ', 'Ẹ'),
                    ('Ẻ', 'Ẻ'),
                    ('Ẽ', 'Ẽ'),
                    ('Ế', 'Ế'),
                    ('Ề', 'Ề'),
                    ('Ể', 'Ể'),
                    ('Ễ', 'Ễ'),
                    ('Ệ', 'Ệ'),
                    ('Ỉ', 'Ỉ'),
                    ('Ị', 'Ị'),
                    ('Ọ', 'Ọ'),
                    ('Ỏ', 'Ỏ'),
                    ('Ố', 'Ố'),
                    ('Ồ', 'Ồ'),
                    ('Ổ', 'Ổ'),
                    ('Ỗ', 'Ỗ'),
                    ('Ộ', 'Ộ'),
                    ('Ớ', 'Ớ'),
                    ('Ờ', 'Ờ'),
                    ('Ở', 'Ở'),
                    ('Ỡ', 'Ỡ'),
                    ('Ợ', 'Ợ'),
                    ('Ụ', 'Ụ'),
                    ('Ủ', 'Ủ'),
                    ('Ứ', 'Ứ'),
                    ('Ừ', 'Ừ'),
                    ('Ử', 'Ử'),
                    ('Ữ', 'Ữ'),
                    ('Ự', 'Ự'),
                    ('Ỳ', 'Ỳ'),
                    ('Ỵ', 'Ỵ'),
                    ('Ỷ', 'Ỷ'),
                    ('Ỹ', 'Ỹ'),
                    ('Ỻ', 'Ỻ'),
                    ('Ỽ', 'Ỽ'),
                    ('Ỿ', 'Ỿ'),
                    ('Ἀ', 'Ἇ'),
                    ('Ἐ', 'Ἕ'),
                    ('Ἠ', 'Ἧ'),
                    ('Ἰ', 'Ἷ'),
                    ('Ὀ', 'Ὅ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'Ὗ'),
                    ('Ὠ', 'Ὧ'),
                    ('ᾈ', 'ᾏ'),
                    ('ᾘ', 'ᾟ'),
                    ('ᾨ', 'ᾯ'),
                    ('Ᾰ', 'ᾼ'),
                    ('Ὲ', 'ῌ'),
                    ('Ῐ', 'Ί'),
                    ('Ῠ', 'Ῥ'),
                    ('Ὸ', 'ῼ'),
                    ('Ω', 'Ω'),
                    ('K', 'Å'),
                    ('Ⅎ', 'Ⅎ'),
                    ('Ⅰ', 'Ⅿ'),
                    ('Ↄ', 'Ↄ'),
                    ('Ⓐ', 'Ⓩ'),
                    ('Ⰰ', 'Ⱟ'),
                    ('Ⱡ', 'Ⱡ'),
                    ('Ɫ', 'Ɽ'),
                    ('Ⱨ', 'Ⱨ'),
                    ('Ⱪ', 'Ⱪ'),
                    ('Ⱬ', 'Ⱬ'),
                    ('Ɑ', 'Ɒ'),
                    ('Ⱳ', 'Ⱳ'),
                    ('Ⱶ', 'Ⱶ'),
                    ('Ȿ', 'Ⲁ'),
                    ('Ⲃ', 'Ⲃ'),
                    ('Ⲅ', 'Ⲅ'),
                    ('Ⲇ', 'Ⲇ'),
                    ('Ⲉ', 'Ⲉ'),
                    ('Ⲋ', 'Ⲋ'),
                    ('Ⲍ', 'Ⲍ'),
                    ('Ⲏ', 'Ⲏ'),
                    ('Ⲑ', 'Ⲑ'),
                    ('Ⲓ', 'Ⲓ'),
                    ('Ⲕ', 'Ⲕ'),
                    ('Ⲗ', 'Ⲗ'),
                    ('Ⲙ', 'Ⲙ'),
                    ('Ⲛ', 'Ⲛ'),
                    ('Ⲝ', 'Ⲝ'),
                    ('Ⲟ', 'Ⲟ'),
                    ('Ⲡ', 'Ⲡ'),
                    ('Ⲣ', 'Ⲣ'),
                    ('Ⲥ', 'Ⲥ'),
                    ('Ⲧ', 'Ⲧ'),
                    ('Ⲩ', 'Ⲩ'),
                    ('Ⲫ', 'Ⲫ'),
                    ('Ⲭ', 'Ⲭ'),
                    ('Ⲯ', 'Ⲯ'),
                    ('Ⲱ', 'Ⲱ'),
                    ('Ⲳ', 'Ⲳ'),
                    ('Ⲵ', 'Ⲵ'),
                    ('Ⲷ', 'Ⲷ'),
                    ('Ⲹ', 'Ⲹ'),
                    ('Ⲻ', 'Ⲻ'),
                    ('Ⲽ', 'Ⲽ'),
                    ('Ⲿ', 'Ⲿ'),
                    ('Ⳁ', 'Ⳁ'),
                    ('Ⳃ', 'Ⳃ'),
                    ('Ⳅ', 'Ⳅ'),
                    ('Ⳇ', 'Ⳇ'),
                    ('Ⳉ', 'Ⳉ'),
                    ('Ⳋ', 'Ⳋ'),
                    ('Ⳍ', 'Ⳍ'),
                    ('Ⳏ', 'Ⳏ'),
                    ('Ⳑ', 'Ⳑ'),
                    ('Ⳓ', 'Ⳓ'),
                    ('Ⳕ', 'Ⳕ'),
                    ('Ⳗ', 'Ⳗ'),
                    ('Ⳙ', 'Ⳙ'),
                    ('Ⳛ', 'Ⳛ'),
                    ('Ⳝ', 'Ⳝ'),
                    ('Ⳟ', 'Ⳟ'),
                    ('Ⳡ', 'Ⳡ'),
                    ('Ⳣ', 'Ⳣ'),
                    ('Ⳬ', 'Ⳬ'),
                    ('Ⳮ', 'Ⳮ'),
                    ('Ⳳ', 'Ⳳ'),
                    ('Ꙁ', 'Ꙁ'),
                    ('Ꙃ', 'Ꙃ'),
                    ('Ꙅ', 'Ꙅ'),
                    ('Ꙇ', 'Ꙇ'),
                    ('Ꙉ', 'Ꙉ'),
                    ('Ꙋ', 'Ꙋ'),
                    ('Ꙍ', 'Ꙍ'),
                    ('Ꙏ', 'Ꙏ'),
                    ('Ꙑ', 'Ꙑ'),
                    ('Ꙓ', 'Ꙓ'),
                    ('Ꙕ', 'Ꙕ'),
                    ('Ꙗ', 'Ꙗ'),
                    ('Ꙙ', 'Ꙙ'),
                    ('Ꙛ', 'Ꙛ'),
                    ('Ꙝ', 'Ꙝ'),
                    ('Ꙟ', 'Ꙟ'),
                    ('Ꙡ', 'Ꙡ'),
                    ('Ꙣ', 'Ꙣ'),
                    ('Ꙥ', 'Ꙥ'),
                    ('Ꙧ', 'Ꙧ'),
                    ('Ꙩ', 'Ꙩ'),
                    ('Ꙫ', 'Ꙫ'),
                    ('Ꙭ', 'Ꙭ'),
                    ('Ꚁ', 'Ꚁ'),
                    ('Ꚃ', 'Ꚃ'),
                    ('Ꚅ', 'Ꚅ'),
                    ('Ꚇ', 'Ꚇ'),
                    ('Ꚉ', 'Ꚉ'),
                    ('Ꚋ', 'Ꚋ'),
                    ('Ꚍ', 'Ꚍ'),
                    ('Ꚏ', 'Ꚏ'),
                    ('Ꚑ', 'Ꚑ'),
                    ('Ꚓ', 'Ꚓ'),
                    ('Ꚕ', 'Ꚕ'),
                    ('Ꚗ', 'Ꚗ'),
                    ('Ꚙ', 'Ꚙ'),
                    ('Ꚛ', 'Ꚛ'),
                    ('Ꜣ', 'Ꜣ'),
                    ('Ꜥ', 'Ꜥ'),
                    ('Ꜧ', 'Ꜧ'),
                    ('Ꜩ', 'Ꜩ'),
                    ('Ꜫ', 'Ꜫ'),
                    ('Ꜭ', 'Ꜭ'),
                    ('Ꜯ', 'Ꜯ'),
                    ('Ꜳ', 'Ꜳ'),
                    ('Ꜵ', 'Ꜵ'),
                    ('Ꜷ', 'Ꜷ'),
                    ('Ꜹ', 'Ꜹ'),
                    ('Ꜻ', 'Ꜻ'),
                    ('Ꜽ', 'Ꜽ'),
                    ('Ꜿ', 'Ꜿ'),
                    ('Ꝁ', 'Ꝁ'),
                    ('Ꝃ', 'Ꝃ'),
                    ('Ꝅ', 'Ꝅ'),
                    ('Ꝇ', 'Ꝇ'),
                    ('Ꝉ', 'Ꝉ'),
                    ('Ꝋ', 'Ꝋ'),
                    ('Ꝍ', 'Ꝍ'),
                    ('Ꝏ', 'Ꝏ'),
                    ('Ꝑ', 'Ꝑ'),
                    ('Ꝓ', 'Ꝓ'),
                    ('Ꝕ', 'Ꝕ'),
                    ('Ꝗ', 'Ꝗ'),
                    ('Ꝙ', 'Ꝙ'),
                    ('Ꝛ', 'Ꝛ'),
                    ('Ꝝ', 'Ꝝ'),
                    ('Ꝟ', 'Ꝟ'),
                    ('Ꝡ', 'Ꝡ'),
                    ('Ꝣ', 'Ꝣ'),
                    ('Ꝥ', 'Ꝥ'),
                    ('Ꝧ', 'Ꝧ'),
                    ('Ꝩ', 'Ꝩ'),
                    ('Ꝫ', 'Ꝫ'),
                    ('Ꝭ', 'Ꝭ'),
                    ('Ꝯ', 'Ꝯ'),
                    ('Ꝺ', 'Ꝺ'),
                    ('Ꝼ', 'Ꝼ'),
                    ('Ᵹ', 'Ꝿ'),
                    ('Ꞁ', 'Ꞁ'),
                    ('Ꞃ', 'Ꞃ'),
                    ('Ꞅ', 'Ꞅ'),
                    ('Ꞇ', 'Ꞇ'),
                    ('Ꞌ', 'Ꞌ'),
                    ('Ɥ', 'Ɥ'),
                    ('Ꞑ', 'Ꞑ'),
                    ('Ꞓ', 'Ꞓ'),
                    ('Ꞗ', 'Ꞗ'),
                    ('Ꞙ', 'Ꞙ'),
                    ('Ꞛ', 'Ꞛ'),
                    ('Ꞝ', 'Ꞝ'),
                    ('Ꞟ', 'Ꞟ'),
                    ('Ꞡ', 'Ꞡ'),
                    ('Ꞣ', 'Ꞣ'),
                    ('Ꞥ', 'Ꞥ'),
                    ('Ꞧ', 'Ꞧ'),
                    ('Ꞩ', 'Ꞩ'),
                    ('Ɦ', 'Ɪ'),
                    ('Ʞ', 'Ꞵ'),
                    ('Ꞷ', 'Ꞷ'),
                    ('Ꞹ', 'Ꞹ'),
                    ('Ꞻ', 'Ꞻ'),
                    ('Ꞽ', 'Ꞽ'),
                    ('Ꞿ', 'Ꞿ'),
                    ('Ꟁ', 'Ꟁ'),
                    ('Ꟃ', 'Ꟃ'),
                    ('Ꞔ', 'Ꟈ'),
                    ('Ꟊ', 'Ꟊ'),
                    ('Ɤ', 'Ꟍ'),
                    ('Ꟑ', 'Ꟑ'),
                    ('Ꟗ', 'Ꟗ'),
                    ('Ꟙ', 'Ꟙ'),
                    ('Ꟛ', 'Ꟛ'),
                    ('Ƛ', 'Ƛ'),
                    ('Ꟶ', 'Ꟶ'),
                    ('Ａ', 'Ｚ'),
                    ('𐐀', '𐐧'),
                    ('𐒰', '𐓓'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐲀', '𐲲'),
                    ('𐵐', '𐵥'),
                    ('𑢠', '𑢿'),
                    ('𖹀', '𖹟'),
                    ('𞤀', '𞤡'),
                ];

                pub const CHANGES_WHEN_TITLECASED: &'static [(char, char)] = &
                [
                    ('a', 'z'),
                    ('µ', 'µ'),
                    ('ß', 'ö'),
                    ('ø', 'ÿ'),
                    ('ā', 'ā'),
                    ('ă', 'ă'),
                    ('ą', 'ą'),
                    ('ć', 'ć'),
                    ('ĉ', 'ĉ'),
                    ('ċ', 'ċ'),
                    ('č', 'č'),
                    ('ď', 'ď'),
                    ('đ', 'đ'),
                    ('ē', 'ē'),
                    ('ĕ', 'ĕ'),
                    ('ė', 'ė'),
                    ('ę', 'ę'),
                    ('ě', 'ě'),
                    ('ĝ', 'ĝ'),
                    ('ğ', 'ğ'),
                    ('ġ', 'ġ'),
                    ('ģ', 'ģ'),
                    ('ĥ', 'ĥ'),
                    ('ħ', 'ħ'),
                    ('ĩ', 'ĩ'),
                    ('ī', 'ī'),
                    ('ĭ', 'ĭ'),
                    ('į', 'į'),
                    ('ı', 'ı'),
                    ('ĳ', 'ĳ'),
                    ('ĵ', 'ĵ'),
                    ('ķ', 'ķ'),
                    ('ĺ', 'ĺ'),
                    ('ļ', 'ļ'),
                    ('ľ', 'ľ'),
                    ('ŀ', 'ŀ'),
                    ('ł', 'ł'),
                    ('ń', 'ń'),
                    ('ņ', 'ņ'),
                    ('ň', 'ŉ'),
                    ('ŋ', 'ŋ'),
                    ('ō', 'ō'),
                    ('ŏ', 'ŏ'),
                    ('ő', 'ő'),
                    ('œ', 'œ'),
                    ('ŕ', 'ŕ'),
                    ('ŗ', 'ŗ'),
                    ('ř', 'ř'),
                    ('ś', 'ś'),
                    ('ŝ', 'ŝ'),
                    ('ş', 'ş'),
                    ('š', 'š'),
                    ('ţ', 'ţ'),
                    ('ť', 'ť'),
                    ('ŧ', 'ŧ'),
                    ('ũ', 'ũ'),
                    ('ū', 'ū'),
                    ('ŭ', 'ŭ'),
                    ('ů', 'ů'),
                    ('ű', 'ű'),
                    ('ų', 'ų'),
                    ('ŵ', 'ŵ'),
                    ('ŷ', 'ŷ'),
                    ('ź', 'ź'),
                    ('ż', 'ż'),
                    ('ž', 'ƀ'),
                    ('ƃ', 'ƃ'),
                    ('ƅ', 'ƅ'),
                    ('ƈ', 'ƈ'),
                    ('ƌ', 'ƌ'),
                    ('ƒ', 'ƒ'),
                    ('ƕ', 'ƕ'),
                    ('ƙ', 'ƛ'),
                    ('ƞ', 'ƞ'),
                    ('ơ', 'ơ'),
                    ('ƣ', 'ƣ'),
                    ('ƥ', 'ƥ'),
                    ('ƨ', 'ƨ'),
                    ('ƭ', 'ƭ'),
                    ('ư', 'ư'),
                    ('ƴ', 'ƴ'),
                    ('ƶ', 'ƶ'),
                    ('ƹ', 'ƹ'),
                    ('ƽ', 'ƽ'),
                    ('ƿ', 'ƿ'),
                    ('Ǆ', 'Ǆ'),
                    ('ǆ', 'Ǉ'),
                    ('ǉ', 'Ǌ'),
                    ('ǌ', 'ǌ'),
                    ('ǎ', 'ǎ'),
                    ('ǐ', 'ǐ'),
                    ('ǒ', 'ǒ'),
                    ('ǔ', 'ǔ'),
                    ('ǖ', 'ǖ'),
                    ('ǘ', 'ǘ'),
                    ('ǚ', 'ǚ'),
                    ('ǜ', 'ǝ'),
                    ('ǟ', 'ǟ'),
                    ('ǡ', 'ǡ'),
                    ('ǣ', 'ǣ'),
                    ('ǥ', 'ǥ'),
                    ('ǧ', 'ǧ'),
                    ('ǩ', 'ǩ'),
                    ('ǫ', 'ǫ'),
                    ('ǭ', 'ǭ'),
                    ('ǯ', 'Ǳ'),
                    ('ǳ', 'ǳ'),
                    ('ǵ', 'ǵ'),
                    ('ǹ', 'ǹ'),
                    ('ǻ', 'ǻ'),
                    ('ǽ', 'ǽ'),
                    ('ǿ', 'ǿ'),
                    ('ȁ', 'ȁ'),
                    ('ȃ', 'ȃ'),
                    ('ȅ', 'ȅ'),
                    ('ȇ', 'ȇ'),
                    ('ȉ', 'ȉ'),
                    ('ȋ', 'ȋ'),
                    ('ȍ', 'ȍ'),
                    ('ȏ', 'ȏ'),
                    ('ȑ', 'ȑ'),
                    ('ȓ', 'ȓ'),
                    ('ȕ', 'ȕ'),
                    ('ȗ', 'ȗ'),
                    ('ș', 'ș'),
                    ('ț', 'ț'),
                    ('ȝ', 'ȝ'),
                    ('ȟ', 'ȟ'),
                    ('ȣ', 'ȣ'),
                    ('ȥ', 'ȥ'),
                    ('ȧ', 'ȧ'),
                    ('ȩ', 'ȩ'),
                    ('ȫ', 'ȫ'),
                    ('ȭ', 'ȭ'),
                    ('ȯ', 'ȯ'),
                    ('ȱ', 'ȱ'),
                    ('ȳ', 'ȳ'),
                    ('ȼ', 'ȼ'),
                    ('ȿ', 'ɀ'),
                    ('ɂ', 'ɂ'),
                    ('ɇ', 'ɇ'),
                    ('ɉ', 'ɉ'),
                    ('ɋ', 'ɋ'),
                    ('ɍ', 'ɍ'),
                    ('ɏ', 'ɔ'),
                    ('ɖ', 'ɗ'),
                    ('ə', 'ə'),
                    ('ɛ', 'ɜ'),
                    ('ɠ', 'ɡ'),
                    ('ɣ', 'ɦ'),
                    ('ɨ', 'ɬ'),
                    ('ɯ', 'ɯ'),
                    ('ɱ', 'ɲ'),
                    ('ɵ', 'ɵ'),
                    ('ɽ', 'ɽ'),
                    ('ʀ', 'ʀ'),
                    ('ʂ', 'ʃ'),
                    ('ʇ', 'ʌ'),
                    ('ʒ', 'ʒ'),
                    ('ʝ', 'ʞ'),
                    ('\u{345}', '\u{345}'),
                    ('ͱ', 'ͱ'),
                    ('ͳ', 'ͳ'),
                    ('ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('ΐ', 'ΐ'),
                    ('ά', 'ώ'),
                    ('ϐ', 'ϑ'),
                    ('ϕ', 'ϗ'),
                    ('ϙ', 'ϙ'),
                    ('ϛ', 'ϛ'),
                    ('ϝ', 'ϝ'),
                    ('ϟ', 'ϟ'),
                    ('ϡ', 'ϡ'),
                    ('ϣ', 'ϣ'),
                    ('ϥ', 'ϥ'),
                    ('ϧ', 'ϧ'),
                    ('ϩ', 'ϩ'),
                    ('ϫ', 'ϫ'),
                    ('ϭ', 'ϭ'),
                    ('ϯ', 'ϳ'),
                    ('ϵ', 'ϵ'),
                    ('ϸ', 'ϸ'),
                    ('ϻ', 'ϻ'),
                    ('а', 'џ'),
                    ('ѡ', 'ѡ'),
                    ('ѣ', 'ѣ'),
                    ('ѥ', 'ѥ'),
                    ('ѧ', 'ѧ'),
                    ('ѩ', 'ѩ'),
                    ('ѫ', 'ѫ'),
                    ('ѭ', 'ѭ'),
                    ('ѯ', 'ѯ'),
                    ('ѱ', 'ѱ'),
                    ('ѳ', 'ѳ'),
                    ('ѵ', 'ѵ'),
                    ('ѷ', 'ѷ'),
                    ('ѹ', 'ѹ'),
                    ('ѻ', 'ѻ'),
                    ('ѽ', 'ѽ'),
                    ('ѿ', 'ѿ'),
                    ('ҁ', 'ҁ'),
                    ('ҋ', 'ҋ'),
                    ('ҍ', 'ҍ'),
                    ('ҏ', 'ҏ'),
                    ('ґ', 'ґ'),
                    ('ғ', 'ғ'),
                    ('ҕ', 'ҕ'),
                    ('җ', 'җ'),
                    ('ҙ', 'ҙ'),
                    ('қ', 'қ'),
                    ('ҝ', 'ҝ'),
                    ('ҟ', 'ҟ'),
                    ('ҡ', 'ҡ'),
                    ('ң', 'ң'),
                    ('ҥ', 'ҥ'),
                    ('ҧ', 'ҧ'),
                    ('ҩ', 'ҩ'),
                    ('ҫ', 'ҫ'),
                    ('ҭ', 'ҭ'),
                    ('ү', 'ү'),
                    ('ұ', 'ұ'),
                    ('ҳ', 'ҳ'),
                    ('ҵ', 'ҵ'),
                    ('ҷ', 'ҷ'),
                    ('ҹ', 'ҹ'),
                    ('һ', 'һ'),
                    ('ҽ', 'ҽ'),
                    ('ҿ', 'ҿ'),
                    ('ӂ', 'ӂ'),
                    ('ӄ', 'ӄ'),
                    ('ӆ', 'ӆ'),
                    ('ӈ', 'ӈ'),
                    ('ӊ', 'ӊ'),
                    ('ӌ', 'ӌ'),
                    ('ӎ', 'ӏ'),
                    ('ӑ', 'ӑ'),
                    ('ӓ', 'ӓ'),
                    ('ӕ', 'ӕ'),
                    ('ӗ', 'ӗ'),
                    ('ә', 'ә'),
                    ('ӛ', 'ӛ'),
                    ('ӝ', 'ӝ'),
                    ('ӟ', 'ӟ'),
                    ('ӡ', 'ӡ'),
                    ('ӣ', 'ӣ'),
                    ('ӥ', 'ӥ'),
                    ('ӧ', 'ӧ'),
                    ('ө', 'ө'),
                    ('ӫ', 'ӫ'),
                    ('ӭ', 'ӭ'),
                    ('ӯ', 'ӯ'),
                    ('ӱ', 'ӱ'),
                    ('ӳ', 'ӳ'),
                    ('ӵ', 'ӵ'),
                    ('ӷ', 'ӷ'),
                    ('ӹ', 'ӹ'),
                    ('ӻ', 'ӻ'),
                    ('ӽ', 'ӽ'),
                    ('ӿ', 'ӿ'),
                    ('ԁ', 'ԁ'),
                    ('ԃ', 'ԃ'),
                    ('ԅ', 'ԅ'),
                    ('ԇ', 'ԇ'),
                    ('ԉ', 'ԉ'),
                    ('ԋ', 'ԋ'),
                    ('ԍ', 'ԍ'),
                    ('ԏ', 'ԏ'),
                    ('ԑ', 'ԑ'),
                    ('ԓ', 'ԓ'),
                    ('ԕ', 'ԕ'),
                    ('ԗ', 'ԗ'),
                    ('ԙ', 'ԙ'),
                    ('ԛ', 'ԛ'),
                    ('ԝ', 'ԝ'),
                    ('ԟ', 'ԟ'),
                    ('ԡ', 'ԡ'),
                    ('ԣ', 'ԣ'),
                    ('ԥ', 'ԥ'),
                    ('ԧ', 'ԧ'),
                    ('ԩ', 'ԩ'),
                    ('ԫ', 'ԫ'),
                    ('ԭ', 'ԭ'),
                    ('ԯ', 'ԯ'),
                    ('ա', 'և'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲈ'),
                    ('ᲊ', 'ᲊ'),
                    ('ᵹ', 'ᵹ'),
                    ('ᵽ', 'ᵽ'),
                    ('ᶎ', 'ᶎ'),
                    ('ḁ', 'ḁ'),
                    ('ḃ', 'ḃ'),
                    ('ḅ', 'ḅ'),
                    ('ḇ', 'ḇ'),
                    ('ḉ', 'ḉ'),
                    ('ḋ', 'ḋ'),
                    ('ḍ', 'ḍ'),
                    ('ḏ', 'ḏ'),
                    ('ḑ', 'ḑ'),
                    ('ḓ', 'ḓ'),
                    ('ḕ', 'ḕ'),
                    ('ḗ', 'ḗ'),
                    ('ḙ', 'ḙ'),
                    ('ḛ', 'ḛ'),
                    ('ḝ', 'ḝ'),
                    ('ḟ', 'ḟ'),
                    ('ḡ', 'ḡ'),
                    ('ḣ', 'ḣ'),
                    ('ḥ', 'ḥ'),
                    ('ḧ', 'ḧ'),
                    ('ḩ', 'ḩ'),
                    ('ḫ', 'ḫ'),
                    ('ḭ', 'ḭ'),
                    ('ḯ', 'ḯ'),
                    ('ḱ', 'ḱ'),
                    ('ḳ', 'ḳ'),
                    ('ḵ', 'ḵ'),
                    ('ḷ', 'ḷ'),
                    ('ḹ', 'ḹ'),
                    ('ḻ', 'ḻ'),
                    ('ḽ', 'ḽ'),
                    ('ḿ', 'ḿ'),
                    ('ṁ', 'ṁ'),
                    ('ṃ', 'ṃ'),
                    ('ṅ', 'ṅ'),
                    ('ṇ', 'ṇ'),
                    ('ṉ', 'ṉ'),
                    ('ṋ', 'ṋ'),
                    ('ṍ', 'ṍ'),
                    ('ṏ', 'ṏ'),
                    ('ṑ', 'ṑ'),
                    ('ṓ', 'ṓ'),
                    ('ṕ', 'ṕ'),
                    ('ṗ', 'ṗ'),
                    ('ṙ', 'ṙ'),
                    ('ṛ', 'ṛ'),
                    ('ṝ', 'ṝ'),
                    ('ṟ', 'ṟ'),
                    ('ṡ', 'ṡ'),
                    ('ṣ', 'ṣ'),
                    ('ṥ', 'ṥ'),
                    ('ṧ', 'ṧ'),
                    ('ṩ', 'ṩ'),
                    ('ṫ', 'ṫ'),
                    ('ṭ', 'ṭ'),
                    ('ṯ', 'ṯ'),
                    ('ṱ', 'ṱ'),
                    ('ṳ', 'ṳ'),
                    ('ṵ', 'ṵ'),
                    ('ṷ', 'ṷ'),
                    ('ṹ', 'ṹ'),
                    ('ṻ', 'ṻ'),
                    ('ṽ', 'ṽ'),
                    ('ṿ', 'ṿ'),
                    ('ẁ', 'ẁ'),
                    ('ẃ', 'ẃ'),
                    ('ẅ', 'ẅ'),
                    ('ẇ', 'ẇ'),
                    ('ẉ', 'ẉ'),
                    ('ẋ', 'ẋ'),
                    ('ẍ', 'ẍ'),
                    ('ẏ', 'ẏ'),
                    ('ẑ', 'ẑ'),
                    ('ẓ', 'ẓ'),
                    ('ẕ', 'ẛ'),
                    ('ạ', 'ạ'),
                    ('ả', 'ả'),
                    ('ấ', 'ấ'),
                    ('ầ', 'ầ'),
                    ('ẩ', 'ẩ'),
                    ('ẫ', 'ẫ'),
                    ('ậ', 'ậ'),
                    ('ắ', 'ắ'),
                    ('ằ', 'ằ'),
                    ('ẳ', 'ẳ'),
                    ('ẵ', 'ẵ'),
                    ('ặ', 'ặ'),
                    ('ẹ', 'ẹ'),
                    ('ẻ', 'ẻ'),
                    ('ẽ', 'ẽ'),
                    ('ế', 'ế'),
                    ('ề', 'ề'),
                    ('ể', 'ể'),
                    ('ễ', 'ễ'),
                    ('ệ', 'ệ'),
                    ('ỉ', 'ỉ'),
                    ('ị', 'ị'),
                    ('ọ', 'ọ'),
                    ('ỏ', 'ỏ'),
                    ('ố', 'ố'),
                    ('ồ', 'ồ'),
                    ('ổ', 'ổ'),
                    ('ỗ', 'ỗ'),
                    ('ộ', 'ộ'),
                    ('ớ', 'ớ'),
                    ('ờ', 'ờ'),
                    ('ở', 'ở'),
                    ('ỡ', 'ỡ'),
                    ('ợ', 'ợ'),
                    ('ụ', 'ụ'),
                    ('ủ', 'ủ'),
                    ('ứ', 'ứ'),
                    ('ừ', 'ừ'),
                    ('ử', 'ử'),
                    ('ữ', 'ữ'),
                    ('ự', 'ự'),
                    ('ỳ', 'ỳ'),
                    ('ỵ', 'ỵ'),
                    ('ỷ', 'ỷ'),
                    ('ỹ', 'ỹ'),
                    ('ỻ', 'ỻ'),
                    ('ỽ', 'ỽ'),
                    ('ỿ', 'ἇ'),
                    ('ἐ', 'ἕ'),
                    ('ἠ', 'ἧ'),
                    ('ἰ', 'ἷ'),
                    ('ὀ', 'ὅ'),
                    ('ὐ', 'ὗ'),
                    ('ὠ', 'ὧ'),
                    ('ὰ', 'ώ'),
                    ('ᾀ', 'ᾇ'),
                    ('ᾐ', 'ᾗ'),
                    ('ᾠ', 'ᾧ'),
                    ('ᾰ', 'ᾴ'),
                    ('ᾶ', 'ᾷ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῇ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'ῗ'),
                    ('ῠ', 'ῧ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῷ'),
                    ('ⅎ', 'ⅎ'),
                    ('ⅰ', 'ⅿ'),
                    ('ↄ', 'ↄ'),
                    ('ⓐ', 'ⓩ'),
                    ('ⰰ', 'ⱟ'),
                    ('ⱡ', 'ⱡ'),
                    ('ⱥ', 'ⱦ'),
                    ('ⱨ', 'ⱨ'),
                    ('ⱪ', 'ⱪ'),
                    ('ⱬ', 'ⱬ'),
                    ('ⱳ', 'ⱳ'),
                    ('ⱶ', 'ⱶ'),
                    ('ⲁ', 'ⲁ'),
                    ('ⲃ', 'ⲃ'),
                    ('ⲅ', 'ⲅ'),
                    ('ⲇ', 'ⲇ'),
                    ('ⲉ', 'ⲉ'),
                    ('ⲋ', 'ⲋ'),
                    ('ⲍ', 'ⲍ'),
                    ('ⲏ', 'ⲏ'),
                    ('ⲑ', 'ⲑ'),
                    ('ⲓ', 'ⲓ'),
                    ('ⲕ', 'ⲕ'),
                    ('ⲗ', 'ⲗ'),
                    ('ⲙ', 'ⲙ'),
                    ('ⲛ', 'ⲛ'),
                    ('ⲝ', 'ⲝ'),
                    ('ⲟ', 'ⲟ'),
                    ('ⲡ', 'ⲡ'),
                    ('ⲣ', 'ⲣ'),
                    ('ⲥ', 'ⲥ'),
                    ('ⲧ', 'ⲧ'),
                    ('ⲩ', 'ⲩ'),
                    ('ⲫ', 'ⲫ'),
                    ('ⲭ', 'ⲭ'),
                    ('ⲯ', 'ⲯ'),
                    ('ⲱ', 'ⲱ'),
                    ('ⲳ', 'ⲳ'),
                    ('ⲵ', 'ⲵ'),
                    ('ⲷ', 'ⲷ'),
                    ('ⲹ', 'ⲹ'),
                    ('ⲻ', 'ⲻ'),
                    ('ⲽ', 'ⲽ'),
                    ('ⲿ', 'ⲿ'),
                    ('ⳁ', 'ⳁ'),
                    ('ⳃ', 'ⳃ'),
                    ('ⳅ', 'ⳅ'),
                    ('ⳇ', 'ⳇ'),
                    ('ⳉ', 'ⳉ'),
                    ('ⳋ', 'ⳋ'),
                    ('ⳍ', 'ⳍ'),
                    ('ⳏ', 'ⳏ'),
                    ('ⳑ', 'ⳑ'),
                    ('ⳓ', 'ⳓ'),
                    ('ⳕ', 'ⳕ'),
                    ('ⳗ', 'ⳗ'),
                    ('ⳙ', 'ⳙ'),
                    ('ⳛ', 'ⳛ'),
                    ('ⳝ', 'ⳝ'),
                    ('ⳟ', 'ⳟ'),
                    ('ⳡ', 'ⳡ'),
                    ('ⳣ', 'ⳣ'),
                    ('ⳬ', 'ⳬ'),
                    ('ⳮ', 'ⳮ'),
                    ('ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ꙁ', 'ꙁ'),
                    ('ꙃ', 'ꙃ'),
                    ('ꙅ', 'ꙅ'),
                    ('ꙇ', 'ꙇ'),
                    ('ꙉ', 'ꙉ'),
                    ('ꙋ', 'ꙋ'),
                    ('ꙍ', 'ꙍ'),
                    ('ꙏ', 'ꙏ'),
                    ('ꙑ', 'ꙑ'),
                    ('ꙓ', 'ꙓ'),
                    ('ꙕ', 'ꙕ'),
                    ('ꙗ', 'ꙗ'),
                    ('ꙙ', 'ꙙ'),
                    ('ꙛ', 'ꙛ'),
                    ('ꙝ', 'ꙝ'),
                    ('ꙟ', 'ꙟ'),
                    ('ꙡ', 'ꙡ'),
                    ('ꙣ', 'ꙣ'),
                    ('ꙥ', 'ꙥ'),
                    ('ꙧ', 'ꙧ'),
                    ('ꙩ', 'ꙩ'),
                    ('ꙫ', 'ꙫ'),
                    ('ꙭ', 'ꙭ'),
                    ('ꚁ', 'ꚁ'),
                    ('ꚃ', 'ꚃ'),
                    ('ꚅ', 'ꚅ'),
                    ('ꚇ', 'ꚇ'),
                    ('ꚉ', 'ꚉ'),
                    ('ꚋ', 'ꚋ'),
                    ('ꚍ', 'ꚍ'),
                    ('ꚏ', 'ꚏ'),
                    ('ꚑ', 'ꚑ'),
                    ('ꚓ', 'ꚓ'),
                    ('ꚕ', 'ꚕ'),
                    ('ꚗ', 'ꚗ'),
                    ('ꚙ', 'ꚙ'),
                    ('ꚛ', 'ꚛ'),
                    ('ꜣ', 'ꜣ'),
                    ('ꜥ', 'ꜥ'),
                    ('ꜧ', 'ꜧ'),
                    ('ꜩ', 'ꜩ'),
                    ('ꜫ', 'ꜫ'),
                    ('ꜭ', 'ꜭ'),
                    ('ꜯ', 'ꜯ'),
                    ('ꜳ', 'ꜳ'),
                    ('ꜵ', 'ꜵ'),
                    ('ꜷ', 'ꜷ'),
                    ('ꜹ', 'ꜹ'),
                    ('ꜻ', 'ꜻ'),
                    ('ꜽ', 'ꜽ'),
                    ('ꜿ', 'ꜿ'),
                    ('ꝁ', 'ꝁ'),
                    ('ꝃ', 'ꝃ'),
                    ('ꝅ', 'ꝅ'),
                    ('ꝇ', 'ꝇ'),
                    ('ꝉ', 'ꝉ'),
                    ('ꝋ', 'ꝋ'),
                    ('ꝍ', 'ꝍ'),
                    ('ꝏ', 'ꝏ'),
                    ('ꝑ', 'ꝑ'),
                    ('ꝓ', 'ꝓ'),
                    ('ꝕ', 'ꝕ'),
                    ('ꝗ', 'ꝗ'),
                    ('ꝙ', 'ꝙ'),
                    ('ꝛ', 'ꝛ'),
                    ('ꝝ', 'ꝝ'),
                    ('ꝟ', 'ꝟ'),
                    ('ꝡ', 'ꝡ'),
                    ('ꝣ', 'ꝣ'),
                    ('ꝥ', 'ꝥ'),
                    ('ꝧ', 'ꝧ'),
                    ('ꝩ', 'ꝩ'),
                    ('ꝫ', 'ꝫ'),
                    ('ꝭ', 'ꝭ'),
                    ('ꝯ', 'ꝯ'),
                    ('ꝺ', 'ꝺ'),
                    ('ꝼ', 'ꝼ'),
                    ('ꝿ', 'ꝿ'),
                    ('ꞁ', 'ꞁ'),
                    ('ꞃ', 'ꞃ'),
                    ('ꞅ', 'ꞅ'),
                    ('ꞇ', 'ꞇ'),
                    ('ꞌ', 'ꞌ'),
                    ('ꞑ', 'ꞑ'),
                    ('ꞓ', 'ꞔ'),
                    ('ꞗ', 'ꞗ'),
                    ('ꞙ', 'ꞙ'),
                    ('ꞛ', 'ꞛ'),
                    ('ꞝ', 'ꞝ'),
                    ('ꞟ', 'ꞟ'),
                    ('ꞡ', 'ꞡ'),
                    ('ꞣ', 'ꞣ'),
                    ('ꞥ', 'ꞥ'),
                    ('ꞧ', 'ꞧ'),
                    ('ꞩ', 'ꞩ'),
                    ('ꞵ', 'ꞵ'),
                    ('ꞷ', 'ꞷ'),
                    ('ꞹ', 'ꞹ'),
                    ('ꞻ', 'ꞻ'),
                    ('ꞽ', 'ꞽ'),
                    ('ꞿ', 'ꞿ'),
                    ('ꟁ', 'ꟁ'),
                    ('ꟃ', 'ꟃ'),
                    ('ꟈ', 'ꟈ'),
                    ('ꟊ', 'ꟊ'),
                    ('ꟍ', 'ꟍ'),
                    ('ꟑ', 'ꟑ'),
                    ('ꟗ', 'ꟗ'),
                    ('ꟙ', 'ꟙ'),
                    ('ꟛ', 'ꟛ'),
                    ('ꟶ', 'ꟶ'),
                    ('ꭓ', 'ꭓ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('ａ', 'ｚ'),
                    ('𐐨', '𐑏'),
                    ('𐓘', '𐓻'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐳀', '𐳲'),
                    ('𐵰', '𐶅'),
                    ('𑣀', '𑣟'),
                    ('𖹠', '𖹿'),
                    ('𞤢', '𞥃'),
                ];

                pub const CHANGES_WHEN_UPPERCASED: &'static [(char, char)] = &
                [
                    ('a', 'z'),
                    ('µ', 'µ'),
                    ('ß', 'ö'),
                    ('ø', 'ÿ'),
                    ('ā', 'ā'),
                    ('ă', 'ă'),
                    ('ą', 'ą'),
                    ('ć', 'ć'),
                    ('ĉ', 'ĉ'),
                    ('ċ', 'ċ'),
                    ('č', 'č'),
                    ('ď', 'ď'),
                    ('đ', 'đ'),
                    ('ē', 'ē'),
                    ('ĕ', 'ĕ'),
                    ('ė', 'ė'),
                    ('ę', 'ę'),
                    ('ě', 'ě'),
                    ('ĝ', 'ĝ'),
                    ('ğ', 'ğ'),
                    ('ġ', 'ġ'),
                    ('ģ', 'ģ'),
                    ('ĥ', 'ĥ'),
                    ('ħ', 'ħ'),
                    ('ĩ', 'ĩ'),
                    ('ī', 'ī'),
                    ('ĭ', 'ĭ'),
                    ('į', 'į'),
                    ('ı', 'ı'),
                    ('ĳ', 'ĳ'),
                    ('ĵ', 'ĵ'),
                    ('ķ', 'ķ'),
                    ('ĺ', 'ĺ'),
                    ('ļ', 'ļ'),
                    ('ľ', 'ľ'),
                    ('ŀ', 'ŀ'),
                    ('ł', 'ł'),
                    ('ń', 'ń'),
                    ('ņ', 'ņ'),
                    ('ň', 'ŉ'),
                    ('ŋ', 'ŋ'),
                    ('ō', 'ō'),
                    ('ŏ', 'ŏ'),
                    ('ő', 'ő'),
                    ('œ', 'œ'),
                    ('ŕ', 'ŕ'),
                    ('ŗ', 'ŗ'),
                    ('ř', 'ř'),
                    ('ś', 'ś'),
                    ('ŝ', 'ŝ'),
                    ('ş', 'ş'),
                    ('š', 'š'),
                    ('ţ', 'ţ'),
                    ('ť', 'ť'),
                    ('ŧ', 'ŧ'),
                    ('ũ', 'ũ'),
                    ('ū', 'ū'),
                    ('ŭ', 'ŭ'),
                    ('ů', 'ů'),
                    ('ű', 'ű'),
                    ('ų', 'ų'),
                    ('ŵ', 'ŵ'),
                    ('ŷ', 'ŷ'),
                    ('ź', 'ź'),
                    ('ż', 'ż'),
                    ('ž', 'ƀ'),
                    ('ƃ', 'ƃ'),
                    ('ƅ', 'ƅ'),
                    ('ƈ', 'ƈ'),
                    ('ƌ', 'ƌ'),
                    ('ƒ', 'ƒ'),
                    ('ƕ', 'ƕ'),
                    ('ƙ', 'ƛ'),
                    ('ƞ', 'ƞ'),
                    ('ơ', 'ơ'),
                    ('ƣ', 'ƣ'),
                    ('ƥ', 'ƥ'),
                    ('ƨ', 'ƨ'),
                    ('ƭ', 'ƭ'),
                    ('ư', 'ư'),
                    ('ƴ', 'ƴ'),
                    ('ƶ', 'ƶ'),
                    ('ƹ', 'ƹ'),
                    ('ƽ', 'ƽ'),
                    ('ƿ', 'ƿ'),
                    ('ǅ', 'ǆ'),
                    ('ǈ', 'ǉ'),
                    ('ǋ', 'ǌ'),
                    ('ǎ', 'ǎ'),
                    ('ǐ', 'ǐ'),
                    ('ǒ', 'ǒ'),
                    ('ǔ', 'ǔ'),
                    ('ǖ', 'ǖ'),
                    ('ǘ', 'ǘ'),
                    ('ǚ', 'ǚ'),
                    ('ǜ', 'ǝ'),
                    ('ǟ', 'ǟ'),
                    ('ǡ', 'ǡ'),
                    ('ǣ', 'ǣ'),
                    ('ǥ', 'ǥ'),
                    ('ǧ', 'ǧ'),
                    ('ǩ', 'ǩ'),
                    ('ǫ', 'ǫ'),
                    ('ǭ', 'ǭ'),
                    ('ǯ', 'ǰ'),
                    ('ǲ', 'ǳ'),
                    ('ǵ', 'ǵ'),
                    ('ǹ', 'ǹ'),
                    ('ǻ', 'ǻ'),
                    ('ǽ', 'ǽ'),
                    ('ǿ', 'ǿ'),
                    ('ȁ', 'ȁ'),
                    ('ȃ', 'ȃ'),
                    ('ȅ', 'ȅ'),
                    ('ȇ', 'ȇ'),
                    ('ȉ', 'ȉ'),
                    ('ȋ', 'ȋ'),
                    ('ȍ', 'ȍ'),
                    ('ȏ', 'ȏ'),
                    ('ȑ', 'ȑ'),
                    ('ȓ', 'ȓ'),
                    ('ȕ', 'ȕ'),
                    ('ȗ', 'ȗ'),
                    ('ș', 'ș'),
                    ('ț', 'ț'),
                    ('ȝ', 'ȝ'),
                    ('ȟ', 'ȟ'),
                    ('ȣ', 'ȣ'),
                    ('ȥ', 'ȥ'),
                    ('ȧ', 'ȧ'),
                    ('ȩ', 'ȩ'),
                    ('ȫ', 'ȫ'),
                    ('ȭ', 'ȭ'),
                    ('ȯ', 'ȯ'),
                    ('ȱ', 'ȱ'),
                    ('ȳ', 'ȳ'),
                    ('ȼ', 'ȼ'),
                    ('ȿ', 'ɀ'),
                    ('ɂ', 'ɂ'),
                    ('ɇ', 'ɇ'),
                    ('ɉ', 'ɉ'),
                    ('ɋ', 'ɋ'),
                    ('ɍ', 'ɍ'),
                    ('ɏ', 'ɔ'),
                    ('ɖ', 'ɗ'),
                    ('ə', 'ə'),
                    ('ɛ', 'ɜ'),
                    ('ɠ', 'ɡ'),
                    ('ɣ', 'ɦ'),
                    ('ɨ', 'ɬ'),
                    ('ɯ', 'ɯ'),
                    ('ɱ', 'ɲ'),
                    ('ɵ', 'ɵ'),
                    ('ɽ', 'ɽ'),
                    ('ʀ', 'ʀ'),
                    ('ʂ', 'ʃ'),
                    ('ʇ', 'ʌ'),
                    ('ʒ', 'ʒ'),
                    ('ʝ', 'ʞ'),
                    ('\u{345}', '\u{345}'),
                    ('ͱ', 'ͱ'),
                    ('ͳ', 'ͳ'),
                    ('ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('ΐ', 'ΐ'),
                    ('ά', 'ώ'),
                    ('ϐ', 'ϑ'),
                    ('ϕ', 'ϗ'),
                    ('ϙ', 'ϙ'),
                    ('ϛ', 'ϛ'),
                    ('ϝ', 'ϝ'),
                    ('ϟ', 'ϟ'),
                    ('ϡ', 'ϡ'),
                    ('ϣ', 'ϣ'),
                    ('ϥ', 'ϥ'),
                    ('ϧ', 'ϧ'),
                    ('ϩ', 'ϩ'),
                    ('ϫ', 'ϫ'),
                    ('ϭ', 'ϭ'),
                    ('ϯ', 'ϳ'),
                    ('ϵ', 'ϵ'),
                    ('ϸ', 'ϸ'),
                    ('ϻ', 'ϻ'),
                    ('а', 'џ'),
                    ('ѡ', 'ѡ'),
                    ('ѣ', 'ѣ'),
                    ('ѥ', 'ѥ'),
                    ('ѧ', 'ѧ'),
                    ('ѩ', 'ѩ'),
                    ('ѫ', 'ѫ'),
                    ('ѭ', 'ѭ'),
                    ('ѯ', 'ѯ'),
                    ('ѱ', 'ѱ'),
                    ('ѳ', 'ѳ'),
                    ('ѵ', 'ѵ'),
                    ('ѷ', 'ѷ'),
                    ('ѹ', 'ѹ'),
                    ('ѻ', 'ѻ'),
                    ('ѽ', 'ѽ'),
                    ('ѿ', 'ѿ'),
                    ('ҁ', 'ҁ'),
                    ('ҋ', 'ҋ'),
                    ('ҍ', 'ҍ'),
                    ('ҏ', 'ҏ'),
                    ('ґ', 'ґ'),
                    ('ғ', 'ғ'),
                    ('ҕ', 'ҕ'),
                    ('җ', 'җ'),
                    ('ҙ', 'ҙ'),
                    ('қ', 'қ'),
                    ('ҝ', 'ҝ'),
                    ('ҟ', 'ҟ'),
                    ('ҡ', 'ҡ'),
                    ('ң', 'ң'),
                    ('ҥ', 'ҥ'),
                    ('ҧ', 'ҧ'),
                    ('ҩ', 'ҩ'),
                    ('ҫ', 'ҫ'),
                    ('ҭ', 'ҭ'),
                    ('ү', 'ү'),
                    ('ұ', 'ұ'),
                    ('ҳ', 'ҳ'),
                    ('ҵ', 'ҵ'),
                    ('ҷ', 'ҷ'),
                    ('ҹ', 'ҹ'),
                    ('һ', 'һ'),
                    ('ҽ', 'ҽ'),
                    ('ҿ', 'ҿ'),
                    ('ӂ', 'ӂ'),
                    ('ӄ', 'ӄ'),
                    ('ӆ', 'ӆ'),
                    ('ӈ', 'ӈ'),
                    ('ӊ', 'ӊ'),
                    ('ӌ', 'ӌ'),
                    ('ӎ', 'ӏ'),
                    ('ӑ', 'ӑ'),
                    ('ӓ', 'ӓ'),
                    ('ӕ', 'ӕ'),
                    ('ӗ', 'ӗ'),
                    ('ә', 'ә'),
                    ('ӛ', 'ӛ'),
                    ('ӝ', 'ӝ'),
                    ('ӟ', 'ӟ'),
                    ('ӡ', 'ӡ'),
                    ('ӣ', 'ӣ'),
                    ('ӥ', 'ӥ'),
                    ('ӧ', 'ӧ'),
                    ('ө', 'ө'),
                    ('ӫ', 'ӫ'),
                    ('ӭ', 'ӭ'),
                    ('ӯ', 'ӯ'),
                    ('ӱ', 'ӱ'),
                    ('ӳ', 'ӳ'),
                    ('ӵ', 'ӵ'),
                    ('ӷ', 'ӷ'),
                    ('ӹ', 'ӹ'),
                    ('ӻ', 'ӻ'),
                    ('ӽ', 'ӽ'),
                    ('ӿ', 'ӿ'),
                    ('ԁ', 'ԁ'),
                    ('ԃ', 'ԃ'),
                    ('ԅ', 'ԅ'),
                    ('ԇ', 'ԇ'),
                    ('ԉ', 'ԉ'),
                    ('ԋ', 'ԋ'),
                    ('ԍ', 'ԍ'),
                    ('ԏ', 'ԏ'),
                    ('ԑ', 'ԑ'),
                    ('ԓ', 'ԓ'),
                    ('ԕ', 'ԕ'),
                    ('ԗ', 'ԗ'),
                    ('ԙ', 'ԙ'),
                    ('ԛ', 'ԛ'),
                    ('ԝ', 'ԝ'),
                    ('ԟ', 'ԟ'),
                    ('ԡ', 'ԡ'),
                    ('ԣ', 'ԣ'),
                    ('ԥ', 'ԥ'),
                    ('ԧ', 'ԧ'),
                    ('ԩ', 'ԩ'),
                    ('ԫ', 'ԫ'),
                    ('ԭ', 'ԭ'),
                    ('ԯ', 'ԯ'),
                    ('ա', 'և'),
                    ('ა', 'ჺ'),
                    ('ჽ', 'ჿ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲈ'),
                    ('ᲊ', 'ᲊ'),
                    ('ᵹ', 'ᵹ'),
                    ('ᵽ', 'ᵽ'),
                    ('ᶎ', 'ᶎ'),
                    ('ḁ', 'ḁ'),
                    ('ḃ', 'ḃ'),
                    ('ḅ', 'ḅ'),
                    ('ḇ', 'ḇ'),
                    ('ḉ', 'ḉ'),
                    ('ḋ', 'ḋ'),
                    ('ḍ', 'ḍ'),
                    ('ḏ', 'ḏ'),
                    ('ḑ', 'ḑ'),
                    ('ḓ', 'ḓ'),
                    ('ḕ', 'ḕ'),
                    ('ḗ', 'ḗ'),
                    ('ḙ', 'ḙ'),
                    ('ḛ', 'ḛ'),
                    ('ḝ', 'ḝ'),
                    ('ḟ', 'ḟ'),
                    ('ḡ', 'ḡ'),
                    ('ḣ', 'ḣ'),
                    ('ḥ', 'ḥ'),
                    ('ḧ', 'ḧ'),
                    ('ḩ', 'ḩ'),
                    ('ḫ', 'ḫ'),
                    ('ḭ', 'ḭ'),
                    ('ḯ', 'ḯ'),
                    ('ḱ', 'ḱ'),
                    ('ḳ', 'ḳ'),
                    ('ḵ', 'ḵ'),
                    ('ḷ', 'ḷ'),
                    ('ḹ', 'ḹ'),
                    ('ḻ', 'ḻ'),
                    ('ḽ', 'ḽ'),
                    ('ḿ', 'ḿ'),
                    ('ṁ', 'ṁ'),
                    ('ṃ', 'ṃ'),
                    ('ṅ', 'ṅ'),
                    ('ṇ', 'ṇ'),
                    ('ṉ', 'ṉ'),
                    ('ṋ', 'ṋ'),
                    ('ṍ', 'ṍ'),
                    ('ṏ', 'ṏ'),
                    ('ṑ', 'ṑ'),
                    ('ṓ', 'ṓ'),
                    ('ṕ', 'ṕ'),
                    ('ṗ', 'ṗ'),
                    ('ṙ', 'ṙ'),
                    ('ṛ', 'ṛ'),
                    ('ṝ', 'ṝ'),
                    ('ṟ', 'ṟ'),
                    ('ṡ', 'ṡ'),
                    ('ṣ', 'ṣ'),
                    ('ṥ', 'ṥ'),
                    ('ṧ', 'ṧ'),
                    ('ṩ', 'ṩ'),
                    ('ṫ', 'ṫ'),
                    ('ṭ', 'ṭ'),
                    ('ṯ', 'ṯ'),
                    ('ṱ', 'ṱ'),
                    ('ṳ', 'ṳ'),
                    ('ṵ', 'ṵ'),
                    ('ṷ', 'ṷ'),
                    ('ṹ', 'ṹ'),
                    ('ṻ', 'ṻ'),
                    ('ṽ', 'ṽ'),
                    ('ṿ', 'ṿ'),
                    ('ẁ', 'ẁ'),
                    ('ẃ', 'ẃ'),
                    ('ẅ', 'ẅ'),
                    ('ẇ', 'ẇ'),
                    ('ẉ', 'ẉ'),
                    ('ẋ', 'ẋ'),
                    ('ẍ', 'ẍ'),
                    ('ẏ', 'ẏ'),
                    ('ẑ', 'ẑ'),
                    ('ẓ', 'ẓ'),
                    ('ẕ', 'ẛ'),
                    ('ạ', 'ạ'),
                    ('ả', 'ả'),
                    ('ấ', 'ấ'),
                    ('ầ', 'ầ'),
                    ('ẩ', 'ẩ'),
                    ('ẫ', 'ẫ'),
                    ('ậ', 'ậ'),
                    ('ắ', 'ắ'),
                    ('ằ', 'ằ'),
                    ('ẳ', 'ẳ'),
                    ('ẵ', 'ẵ'),
                    ('ặ', 'ặ'),
                    ('ẹ', 'ẹ'),
                    ('ẻ', 'ẻ'),
                    ('ẽ', 'ẽ'),
                    ('ế', 'ế'),
                    ('ề', 'ề'),
                    ('ể', 'ể'),
                    ('ễ', 'ễ'),
                    ('ệ', 'ệ'),
                    ('ỉ', 'ỉ'),
                    ('ị', 'ị'),
                    ('ọ', 'ọ'),
                    ('ỏ', 'ỏ'),
                    ('ố', 'ố'),
                    ('ồ', 'ồ'),
                    ('ổ', 'ổ'),
                    ('ỗ', 'ỗ'),
                    ('ộ', 'ộ'),
                    ('ớ', 'ớ'),
                    ('ờ', 'ờ'),
                    ('ở', 'ở'),
                    ('ỡ', 'ỡ'),
                    ('ợ', 'ợ'),
                    ('ụ', 'ụ'),
                    ('ủ', 'ủ'),
                    ('ứ', 'ứ'),
                    ('ừ', 'ừ'),
                    ('ử', 'ử'),
                    ('ữ', 'ữ'),
                    ('ự', 'ự'),
                    ('ỳ', 'ỳ'),
                    ('ỵ', 'ỵ'),
                    ('ỷ', 'ỷ'),
                    ('ỹ', 'ỹ'),
                    ('ỻ', 'ỻ'),
                    ('ỽ', 'ỽ'),
                    ('ỿ', 'ἇ'),
                    ('ἐ', 'ἕ'),
                    ('ἠ', 'ἧ'),
                    ('ἰ', 'ἷ'),
                    ('ὀ', 'ὅ'),
                    ('ὐ', 'ὗ'),
                    ('ὠ', 'ὧ'),
                    ('ὰ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾷ'),
                    ('ᾼ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῇ'),
                    ('ῌ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'ῗ'),
                    ('ῠ', 'ῧ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῷ'),
                    ('ῼ', 'ῼ'),
                    ('ⅎ', 'ⅎ'),
                    ('ⅰ', 'ⅿ'),
                    ('ↄ', 'ↄ'),
                    ('ⓐ', 'ⓩ'),
                    ('ⰰ', 'ⱟ'),
                    ('ⱡ', 'ⱡ'),
                    ('ⱥ', 'ⱦ'),
                    ('ⱨ', 'ⱨ'),
                    ('ⱪ', 'ⱪ'),
                    ('ⱬ', 'ⱬ'),
                    ('ⱳ', 'ⱳ'),
                    ('ⱶ', 'ⱶ'),
                    ('ⲁ', 'ⲁ'),
                    ('ⲃ', 'ⲃ'),
                    ('ⲅ', 'ⲅ'),
                    ('ⲇ', 'ⲇ'),
                    ('ⲉ', 'ⲉ'),
                    ('ⲋ', 'ⲋ'),
                    ('ⲍ', 'ⲍ'),
                    ('ⲏ', 'ⲏ'),
                    ('ⲑ', 'ⲑ'),
                    ('ⲓ', 'ⲓ'),
                    ('ⲕ', 'ⲕ'),
                    ('ⲗ', 'ⲗ'),
                    ('ⲙ', 'ⲙ'),
                    ('ⲛ', 'ⲛ'),
                    ('ⲝ', 'ⲝ'),
                    ('ⲟ', 'ⲟ'),
                    ('ⲡ', 'ⲡ'),
                    ('ⲣ', 'ⲣ'),
                    ('ⲥ', 'ⲥ'),
                    ('ⲧ', 'ⲧ'),
                    ('ⲩ', 'ⲩ'),
                    ('ⲫ', 'ⲫ'),
                    ('ⲭ', 'ⲭ'),
                    ('ⲯ', 'ⲯ'),
                    ('ⲱ', 'ⲱ'),
                    ('ⲳ', 'ⲳ'),
                    ('ⲵ', 'ⲵ'),
                    ('ⲷ', 'ⲷ'),
                    ('ⲹ', 'ⲹ'),
                    ('ⲻ', 'ⲻ'),
                    ('ⲽ', 'ⲽ'),
                    ('ⲿ', 'ⲿ'),
                    ('ⳁ', 'ⳁ'),
                    ('ⳃ', 'ⳃ'),
                    ('ⳅ', 'ⳅ'),
                    ('ⳇ', 'ⳇ'),
                    ('ⳉ', 'ⳉ'),
                    ('ⳋ', 'ⳋ'),
                    ('ⳍ', 'ⳍ'),
                    ('ⳏ', 'ⳏ'),
                    ('ⳑ', 'ⳑ'),
                    ('ⳓ', 'ⳓ'),
                    ('ⳕ', 'ⳕ'),
                    ('ⳗ', 'ⳗ'),
                    ('ⳙ', 'ⳙ'),
                    ('ⳛ', 'ⳛ'),
                    ('ⳝ', 'ⳝ'),
                    ('ⳟ', 'ⳟ'),
                    ('ⳡ', 'ⳡ'),
                    ('ⳣ', 'ⳣ'),
                    ('ⳬ', 'ⳬ'),
                    ('ⳮ', 'ⳮ'),
                    ('ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ꙁ', 'ꙁ'),
                    ('ꙃ', 'ꙃ'),
                    ('ꙅ', 'ꙅ'),
                    ('ꙇ', 'ꙇ'),
                    ('ꙉ', 'ꙉ'),
                    ('ꙋ', 'ꙋ'),
                    ('ꙍ', 'ꙍ'),
                    ('ꙏ', 'ꙏ'),
                    ('ꙑ', 'ꙑ'),
                    ('ꙓ', 'ꙓ'),
                    ('ꙕ', 'ꙕ'),
                    ('ꙗ', 'ꙗ'),
                    ('ꙙ', 'ꙙ'),
                    ('ꙛ', 'ꙛ'),
                    ('ꙝ', 'ꙝ'),
                    ('ꙟ', 'ꙟ'),
                    ('ꙡ', 'ꙡ'),
                    ('ꙣ', 'ꙣ'),
                    ('ꙥ', 'ꙥ'),
                    ('ꙧ', 'ꙧ'),
                    ('ꙩ', 'ꙩ'),
                    ('ꙫ', 'ꙫ'),
                    ('ꙭ', 'ꙭ'),
                    ('ꚁ', 'ꚁ'),
                    ('ꚃ', 'ꚃ'),
                    ('ꚅ', 'ꚅ'),
                    ('ꚇ', 'ꚇ'),
                    ('ꚉ', 'ꚉ'),
                    ('ꚋ', 'ꚋ'),
                    ('ꚍ', 'ꚍ'),
                    ('ꚏ', 'ꚏ'),
                    ('ꚑ', 'ꚑ'),
                    ('ꚓ', 'ꚓ'),
                    ('ꚕ', 'ꚕ'),
                    ('ꚗ', 'ꚗ'),
                    ('ꚙ', 'ꚙ'),
                    ('ꚛ', 'ꚛ'),
                    ('ꜣ', 'ꜣ'),
                    ('ꜥ', 'ꜥ'),
                    ('ꜧ', 'ꜧ'),
                    ('ꜩ', 'ꜩ'),
                    ('ꜫ', 'ꜫ'),
                    ('ꜭ', 'ꜭ'),
                    ('ꜯ', 'ꜯ'),
                    ('ꜳ', 'ꜳ'),
                    ('ꜵ', 'ꜵ'),
                    ('ꜷ', 'ꜷ'),
                    ('ꜹ', 'ꜹ'),
                    ('ꜻ', 'ꜻ'),
                    ('ꜽ', 'ꜽ'),
                    ('ꜿ', 'ꜿ'),
                    ('ꝁ', 'ꝁ'),
                    ('ꝃ', 'ꝃ'),
                    ('ꝅ', 'ꝅ'),
                    ('ꝇ', 'ꝇ'),
                    ('ꝉ', 'ꝉ'),
                    ('ꝋ', 'ꝋ'),
                    ('ꝍ', 'ꝍ'),
                    ('ꝏ', 'ꝏ'),
                    ('ꝑ', 'ꝑ'),
                    ('ꝓ', 'ꝓ'),
                    ('ꝕ', 'ꝕ'),
                    ('ꝗ', 'ꝗ'),
                    ('ꝙ', 'ꝙ'),
                    ('ꝛ', 'ꝛ'),
                    ('ꝝ', 'ꝝ'),
                    ('ꝟ', 'ꝟ'),
                    ('ꝡ', 'ꝡ'),
                    ('ꝣ', 'ꝣ'),
                    ('ꝥ', 'ꝥ'),
                    ('ꝧ', 'ꝧ'),
                    ('ꝩ', 'ꝩ'),
                    ('ꝫ', 'ꝫ'),
                    ('ꝭ', 'ꝭ'),
                    ('ꝯ', 'ꝯ'),
                    ('ꝺ', 'ꝺ'),
                    ('ꝼ', 'ꝼ'),
                    ('ꝿ', 'ꝿ'),
                    ('ꞁ', 'ꞁ'),
                    ('ꞃ', 'ꞃ'),
                    ('ꞅ', 'ꞅ'),
                    ('ꞇ', 'ꞇ'),
                    ('ꞌ', 'ꞌ'),
                    ('ꞑ', 'ꞑ'),
                    ('ꞓ', 'ꞔ'),
                    ('ꞗ', 'ꞗ'),
                    ('ꞙ', 'ꞙ'),
                    ('ꞛ', 'ꞛ'),
                    ('ꞝ', 'ꞝ'),
                    ('ꞟ', 'ꞟ'),
                    ('ꞡ', 'ꞡ'),
                    ('ꞣ', 'ꞣ'),
                    ('ꞥ', 'ꞥ'),
                    ('ꞧ', 'ꞧ'),
                    ('ꞩ', 'ꞩ'),
                    ('ꞵ', 'ꞵ'),
                    ('ꞷ', 'ꞷ'),
                    ('ꞹ', 'ꞹ'),
                    ('ꞻ', 'ꞻ'),
                    ('ꞽ', 'ꞽ'),
                    ('ꞿ', 'ꞿ'),
                    ('ꟁ', 'ꟁ'),
                    ('ꟃ', 'ꟃ'),
                    ('ꟈ', 'ꟈ'),
                    ('ꟊ', 'ꟊ'),
                    ('ꟍ', 'ꟍ'),
                    ('ꟑ', 'ꟑ'),
                    ('ꟗ', 'ꟗ'),
                    ('ꟙ', 'ꟙ'),
                    ('ꟛ', 'ꟛ'),
                    ('ꟶ', 'ꟶ'),
                    ('ꭓ', 'ꭓ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('ａ', 'ｚ'),
                    ('𐐨', '𐑏'),
                    ('𐓘', '𐓻'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐳀', '𐳲'),
                    ('𐵰', '𐶅'),
                    ('𑣀', '𑣟'),
                    ('𖹠', '𖹿'),
                    ('𞤢', '𞥃'),
                ];

                pub const DASH: &'static [(char, char)] = &
                [
                    ('-', '-'),
                    ('֊', '֊'),
                    ('־', '־'),
                    ('᐀', '᐀'),
                    ('᠆', '᠆'),
                    ('‐', '―'),
                    ('⁓', '⁓'),
                    ('⁻', '⁻'),
                    ('₋', '₋'),
                    ('−', '−'),
                    ('⸗', '⸗'),
                    ('⸚', '⸚'),
                    ('⸺', '⸻'),
                    ('⹀', '⹀'),
                    ('⹝', '⹝'),
                    ('〜', '〜'),
                    ('〰', '〰'),
                    ('゠', '゠'),
                    ('︱', '︲'),
                    ('﹘', '﹘'),
                    ('﹣', '﹣'),
                    ('－', '－'),
                    ('𐵮', '𐵮'),
                    ('𐺭', '𐺭'),
                ];

                pub const DEFAULT_IGNORABLE_CODE_POINT: &'static [(char, char)] = &
                [
                    ('\u{ad}', '\u{ad}'),
                    ('\u{34f}', '\u{34f}'),
                    ('\u{61c}', '\u{61c}'),
                    ('ᅟ', 'ᅠ'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{180b}', '\u{180f}'),
                    ('\u{200b}', '\u{200f}'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2060}', '\u{206f}'),
                    ('ㅤ', 'ㅤ'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{feff}', '\u{feff}'),
                    ('ﾠ', 'ﾠ'),
                    ('\u{fff0}', '\u{fff8}'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('\u{1d173}', '\u{1d17a}'),
                    ('\u{e0000}', '\u{e0fff}'),
                ];

                pub const DEPRECATED: &'static [(char, char)] = &
                [
                    ('ŉ', 'ŉ'),
                    ('ٳ', 'ٳ'),
                    ('\u{f77}', '\u{f77}'),
                    ('\u{f79}', '\u{f79}'),
                    ('ឣ', 'ឤ'),
                    ('\u{206a}', '\u{206f}'),
                    ('〈', '〉'),
                    ('\u{e0001}', '\u{e0001}'),
                ];

                pub const DIACRITIC: &'static [(char, char)] = &
                [
                    ('^', '^'),
                    ('`', '`'),
                    ('¨', '¨'),
                    ('¯', '¯'),
                    ('´', '´'),
                    ('·', '¸'),
                    ('ʰ', '\u{34e}'),
                    ('\u{350}', '\u{357}'),
                    ('\u{35d}', '\u{362}'),
                    ('ʹ', '͵'),
                    ('ͺ', 'ͺ'),
                    ('΄', '΅'),
                    ('\u{483}', '\u{487}'),
                    ('ՙ', 'ՙ'),
                    ('\u{591}', '\u{5a1}'),
                    ('\u{5a3}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c4}'),
                    ('\u{64b}', '\u{652}'),
                    ('\u{657}', '\u{658}'),
                    ('\u{6df}', '\u{6e0}'),
                    ('ۥ', 'ۦ'),
                    ('\u{6ea}', '\u{6ec}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', 'ߵ'),
                    ('\u{818}', '\u{819}'),
                    ('\u{898}', '\u{89f}'),
                    ('ࣉ', '\u{8d2}'),
                    ('\u{8e3}', '\u{8fe}'),
                    ('\u{93c}', '\u{93c}'),
                    ('\u{94d}', '\u{94d}'),
                    ('\u{951}', '\u{954}'),
                    ('ॱ', 'ॱ'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('\u{a4d}', '\u{a4d}'),
                    ('\u{abc}', '\u{abc}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{afd}', '\u{aff}'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{b55}', '\u{b55}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c4d}', '\u{c4d}'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('\u{ccd}', '\u{ccd}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{e3a}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4c}'),
                    ('\u{e4e}', '\u{e4e}'),
                    ('\u{eba}', '\u{eba}'),
                    ('\u{ec8}', '\u{ecc}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', '༿'),
                    ('\u{f82}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('\u{1037}', '\u{1037}'),
                    ('\u{1039}', '\u{103a}'),
                    ('ၣ', 'ၤ'),
                    ('ၩ', 'ၭ'),
                    ('ႇ', '\u{108d}'),
                    ('ႏ', 'ႏ'),
                    ('ႚ', 'ႛ'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1714}', '\u{1715}'),
                    ('\u{1734}', '\u{1734}'),
                    ('\u{17c9}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{1939}', '\u{193b}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1a75}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1abe}'),
                    ('\u{1ac1}', '\u{1acb}'),
                    ('\u{1b34}', '\u{1b34}'),
                    ('\u{1b44}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1baa}', '\u{1bab}'),
                    ('\u{1be6}', '\u{1be6}'),
                    ('\u{1bf2}', '\u{1bf3}'),
                    ('\u{1c36}', '\u{1c37}'),
                    ('ᱸ', 'ᱽ'),
                    ('\u{1cd0}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('᳷', '\u{1cf9}'),
                    ('ᴬ', 'ᵪ'),
                    ('\u{1dc4}', '\u{1dcf}'),
                    ('\u{1df5}', '\u{1dff}'),
                    ('᾽', '᾽'),
                    ('᾿', '῁'),
                    ('῍', '῏'),
                    ('῝', '῟'),
                    ('῭', '`'),
                    ('´', '῾'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('ⸯ', 'ⸯ'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '゜'),
                    ('ー', 'ー'),
                    ('\u{a66f}', '\u{a66f}'),
                    ('\u{a67c}', '\u{a67d}'),
                    ('ꙿ', 'ꙿ'),
                    ('ꚜ', 'ꚝ'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('꜀', '꜡'),
                    ('ꞈ', '꞊'),
                    ('ꟸ', 'ꟹ'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c4}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a92b}', '꤮'),
                    ('\u{a953}', '\u{a953}'),
                    ('\u{a9b3}', '\u{a9b3}'),
                    ('\u{a9c0}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('ꩻ', 'ꩽ'),
                    ('\u{aabf}', 'ꫂ'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('꭛', 'ꭟ'),
                    ('ꭩ', '꭫'),
                    ('꯬', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('＾', '＾'),
                    ('｀', '｀'),
                    ('ｰ', 'ｰ'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('￣', '￣'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('𐴢', '\u{10d27}'),
                    ('𐵎', '𐵎'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10efd}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('\u{11046}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{110b9}', '\u{110ba}'),
                    ('\u{11133}', '\u{11134}'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{111c0}', '\u{111c0}'),
                    ('\u{111ca}', '\u{111cc}'),
                    ('\u{11235}', '\u{11236}'),
                    ('\u{112e9}', '\u{112ea}'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1134d}', '\u{1134d}'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113ce}', '\u{113d0}'),
                    ('\u{113d2}', '𑏓'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('\u{11442}', '\u{11442}'),
                    ('\u{11446}', '\u{11446}'),
                    ('\u{114c2}', '\u{114c3}'),
                    ('\u{115bf}', '\u{115c0}'),
                    ('\u{1163f}', '\u{1163f}'),
                    ('\u{116b6}', '\u{116b7}'),
                    ('\u{1172b}', '\u{1172b}'),
                    ('\u{11839}', '\u{1183a}'),
                    ('\u{1193d}', '\u{1193e}'),
                    ('\u{11943}', '\u{11943}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a34}', '\u{11a34}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a99}', '\u{11a99}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11d42}', '\u{11d42}'),
                    ('\u{11d44}', '\u{11d45}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11f41}', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1612f}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('𖵫', '𖵬'),
                    ('\u{16f8f}', '𖾟'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d167}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e946}'),
                    ('\u{1e948}', '\u{1e94a}'),
                ];

                pub const EMOJI: &'static [(char, char)] = &
                [
                    ('#', '#'),
                    ('*', '*'),
                    ('0', '9'),
                    ('©', '©'),
                    ('®', '®'),
                    ('‼', '‼'),
                    ('⁉', '⁉'),
                    ('™', '™'),
                    ('ℹ', 'ℹ'),
                    ('↔', '↙'),
                    ('↩', '↪'),
                    ('⌚', '⌛'),
                    ('⌨', '⌨'),
                    ('⏏', '⏏'),
                    ('⏩', '⏳'),
                    ('⏸', '⏺'),
                    ('Ⓜ', 'Ⓜ'),
                    ('▪', '▫'),
                    ('▶', '▶'),
                    ('◀', '◀'),
                    ('◻', '◾'),
                    ('☀', '☄'),
                    ('☎', '☎'),
                    ('☑', '☑'),
                    ('☔', '☕'),
                    ('☘', '☘'),
                    ('☝', '☝'),
                    ('☠', '☠'),
                    ('☢', '☣'),
                    ('☦', '☦'),
                    ('☪', '☪'),
                    ('☮', '☯'),
                    ('☸', '☺'),
                    ('♀', '♀'),
                    ('♂', '♂'),
                    ('♈', '♓'),
                    ('♟', '♠'),
                    ('♣', '♣'),
                    ('♥', '♦'),
                    ('♨', '♨'),
                    ('♻', '♻'),
                    ('♾', '♿'),
                    ('⚒', '⚗'),
                    ('⚙', '⚙'),
                    ('⚛', '⚜'),
                    ('⚠', '⚡'),
                    ('⚧', '⚧'),
                    ('⚪', '⚫'),
                    ('⚰', '⚱'),
                    ('⚽', '⚾'),
                    ('⛄', '⛅'),
                    ('⛈', '⛈'),
                    ('⛎', '⛏'),
                    ('⛑', '⛑'),
                    ('⛓', '⛔'),
                    ('⛩', '⛪'),
                    ('⛰', '⛵'),
                    ('⛷', '⛺'),
                    ('⛽', '⛽'),
                    ('✂', '✂'),
                    ('✅', '✅'),
                    ('✈', '✍'),
                    ('✏', '✏'),
                    ('✒', '✒'),
                    ('✔', '✔'),
                    ('✖', '✖'),
                    ('✝', '✝'),
                    ('✡', '✡'),
                    ('✨', '✨'),
                    ('✳', '✴'),
                    ('❄', '❄'),
                    ('❇', '❇'),
                    ('❌', '❌'),
                    ('❎', '❎'),
                    ('❓', '❕'),
                    ('❗', '❗'),
                    ('❣', '❤'),
                    ('➕', '➗'),
                    ('➡', '➡'),
                    ('➰', '➰'),
                    ('➿', '➿'),
                    ('⤴', '⤵'),
                    ('⬅', '⬇'),
                    ('⬛', '⬜'),
                    ('⭐', '⭐'),
                    ('⭕', '⭕'),
                    ('〰', '〰'),
                    ('〽', '〽'),
                    ('㊗', '㊗'),
                    ('㊙', '㊙'),
                    ('🀄', '🀄'),
                    ('🃏', '🃏'),
                    ('🅰', '🅱'),
                    ('🅾', '🅿'),
                    ('🆎', '🆎'),
                    ('🆑', '🆚'),
                    ('🇦', '🇿'),
                    ('🈁', '🈂'),
                    ('🈚', '🈚'),
                    ('🈯', '🈯'),
                    ('🈲', '🈺'),
                    ('🉐', '🉑'),
                    ('🌀', '🌡'),
                    ('🌤', '🎓'),
                    ('🎖', '🎗'),
                    ('🎙', '🎛'),
                    ('🎞', '🏰'),
                    ('🏳', '🏵'),
                    ('🏷', '📽'),
                    ('📿', '🔽'),
                    ('🕉', '🕎'),
                    ('🕐', '🕧'),
                    ('🕯', '🕰'),
                    ('🕳', '🕺'),
                    ('🖇', '🖇'),
                    ('🖊', '🖍'),
                    ('🖐', '🖐'),
                    ('🖕', '🖖'),
                    ('🖤', '🖥'),
                    ('🖨', '🖨'),
                    ('🖱', '🖲'),
                    ('🖼', '🖼'),
                    ('🗂', '🗄'),
                    ('🗑', '🗓'),
                    ('🗜', '🗞'),
                    ('🗡', '🗡'),
                    ('🗣', '🗣'),
                    ('🗨', '🗨'),
                    ('🗯', '🗯'),
                    ('🗳', '🗳'),
                    ('🗺', '🙏'),
                    ('🚀', '🛅'),
                    ('🛋', '🛒'),
                    ('🛕', '🛗'),
                    ('🛜', '🛥'),
                    ('🛩', '🛩'),
                    ('🛫', '🛬'),
                    ('🛰', '🛰'),
                    ('🛳', '🛼'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🤌', '🤺'),
                    ('🤼', '🥅'),
                    ('🥇', '🧿'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                ];

                pub const EMOJI_COMPONENT: &'static [(char, char)] = &
                [
                    ('#', '#'),
                    ('*', '*'),
                    ('0', '9'),
                    ('\u{200d}', '\u{200d}'),
                    ('\u{20e3}', '\u{20e3}'),
                    ('\u{fe0f}', '\u{fe0f}'),
                    ('🇦', '🇿'),
                    ('🏻', '🏿'),
                    ('🦰', '🦳'),
                    ('\u{e0020}', '\u{e007f}'),
                ];

                pub const EMOJI_MODIFIER: &'static [(char, char)] = &[('🏻', '🏿')];

                pub const EMOJI_MODIFIER_BASE: &'static [(char, char)] = &
                [
                    ('☝', '☝'),
                    ('⛹', '⛹'),
                    ('✊', '✍'),
                    ('🎅', '🎅'),
                    ('🏂', '🏄'),
                    ('🏇', '🏇'),
                    ('🏊', '🏌'),
                    ('👂', '👃'),
                    ('👆', '👐'),
                    ('👦', '👸'),
                    ('👼', '👼'),
                    ('💁', '💃'),
                    ('💅', '💇'),
                    ('💏', '💏'),
                    ('💑', '💑'),
                    ('💪', '💪'),
                    ('🕴', '🕵'),
                    ('🕺', '🕺'),
                    ('🖐', '🖐'),
                    ('🖕', '🖖'),
                    ('🙅', '🙇'),
                    ('🙋', '🙏'),
                    ('🚣', '🚣'),
                    ('🚴', '🚶'),
                    ('🛀', '🛀'),
                    ('🛌', '🛌'),
                    ('🤌', '🤌'),
                    ('🤏', '🤏'),
                    ('🤘', '🤟'),
                    ('🤦', '🤦'),
                    ('🤰', '🤹'),
                    ('🤼', '🤾'),
                    ('🥷', '🥷'),
                    ('🦵', '🦶'),
                    ('🦸', '🦹'),
                    ('🦻', '🦻'),
                    ('🧍', '🧏'),
                    ('🧑', '🧝'),
                    ('🫃', '🫅'),
                    ('🫰', '🫸'),
                ];

                pub const EMOJI_PRESENTATION: &'static [(char, char)] = &
                [
                    ('⌚', '⌛'),
                    ('⏩', '⏬'),
                    ('⏰', '⏰'),
                    ('⏳', '⏳'),
                    ('◽', '◾'),
                    ('☔', '☕'),
                    ('♈', '♓'),
                    ('♿', '♿'),
                    ('⚓', '⚓'),
                    ('⚡', '⚡'),
                    ('⚪', '⚫'),
                    ('⚽', '⚾'),
                    ('⛄', '⛅'),
                    ('⛎', '⛎'),
                    ('⛔', '⛔'),
                    ('⛪', '⛪'),
                    ('⛲', '⛳'),
                    ('⛵', '⛵'),
                    ('⛺', '⛺'),
                    ('⛽', '⛽'),
                    ('✅', '✅'),
                    ('✊', '✋'),
                    ('✨', '✨'),
                    ('❌', '❌'),
                    ('❎', '❎'),
                    ('❓', '❕'),
                    ('❗', '❗'),
                    ('➕', '➗'),
                    ('➰', '➰'),
                    ('➿', '➿'),
                    ('⬛', '⬜'),
                    ('⭐', '⭐'),
                    ('⭕', '⭕'),
                    ('🀄', '🀄'),
                    ('🃏', '🃏'),
                    ('🆎', '🆎'),
                    ('🆑', '🆚'),
                    ('🇦', '🇿'),
                    ('🈁', '🈁'),
                    ('🈚', '🈚'),
                    ('🈯', '🈯'),
                    ('🈲', '🈶'),
                    ('🈸', '🈺'),
                    ('🉐', '🉑'),
                    ('🌀', '🌠'),
                    ('🌭', '🌵'),
                    ('🌷', '🍼'),
                    ('🍾', '🎓'),
                    ('🎠', '🏊'),
                    ('🏏', '🏓'),
                    ('🏠', '🏰'),
                    ('🏴', '🏴'),
                    ('🏸', '🐾'),
                    ('👀', '👀'),
                    ('👂', '📼'),
                    ('📿', '🔽'),
                    ('🕋', '🕎'),
                    ('🕐', '🕧'),
                    ('🕺', '🕺'),
                    ('🖕', '🖖'),
                    ('🖤', '🖤'),
                    ('🗻', '🙏'),
                    ('🚀', '🛅'),
                    ('🛌', '🛌'),
                    ('🛐', '🛒'),
                    ('🛕', '🛗'),
                    ('🛜', '🛟'),
                    ('🛫', '🛬'),
                    ('🛴', '🛼'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🤌', '🤺'),
                    ('🤼', '🥅'),
                    ('🥇', '🧿'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                ];

                pub const EXTENDED_PICTOGRAPHIC: &'static [(char, char)] = &
                [
                    ('©', '©'),
                    ('®', '®'),
                    ('‼', '‼'),
                    ('⁉', '⁉'),
                    ('™', '™'),
                    ('ℹ', 'ℹ'),
                    ('↔', '↙'),
                    ('↩', '↪'),
                    ('⌚', '⌛'),
                    ('⌨', '⌨'),
                    ('⎈', '⎈'),
                    ('⏏', '⏏'),
                    ('⏩', '⏳'),
                    ('⏸', '⏺'),
                    ('Ⓜ', 'Ⓜ'),
                    ('▪', '▫'),
                    ('▶', '▶'),
                    ('◀', '◀'),
                    ('◻', '◾'),
                    ('☀', '★'),
                    ('☇', '☒'),
                    ('☔', '⚅'),
                    ('⚐', '✅'),
                    ('✈', '✒'),
                    ('✔', '✔'),
                    ('✖', '✖'),
                    ('✝', '✝'),
                    ('✡', '✡'),
                    ('✨', '✨'),
                    ('✳', '✴'),
                    ('❄', '❄'),
                    ('❇', '❇'),
                    ('❌', '❌'),
                    ('❎', '❎'),
                    ('❓', '❕'),
                    ('❗', '❗'),
                    ('❣', '❧'),
                    ('➕', '➗'),
                    ('➡', '➡'),
                    ('➰', '➰'),
                    ('➿', '➿'),
                    ('⤴', '⤵'),
                    ('⬅', '⬇'),
                    ('⬛', '⬜'),
                    ('⭐', '⭐'),
                    ('⭕', '⭕'),
                    ('〰', '〰'),
                    ('〽', '〽'),
                    ('㊗', '㊗'),
                    ('㊙', '㊙'),
                    ('🀀', '\u{1f0ff}'),
                    ('🄍', '🄏'),
                    ('🄯', '🄯'),
                    ('🅬', '🅱'),
                    ('🅾', '🅿'),
                    ('🆎', '🆎'),
                    ('🆑', '🆚'),
                    ('🆭', '\u{1f1e5}'),
                    ('🈁', '\u{1f20f}'),
                    ('🈚', '🈚'),
                    ('🈯', '🈯'),
                    ('🈲', '🈺'),
                    ('\u{1f23c}', '\u{1f23f}'),
                    ('\u{1f249}', '🏺'),
                    ('🐀', '🔽'),
                    ('🕆', '🙏'),
                    ('🚀', '\u{1f6ff}'),
                    ('🝴', '🝿'),
                    ('🟕', '\u{1f7ff}'),
                    ('\u{1f80c}', '\u{1f80f}'),
                    ('\u{1f848}', '\u{1f84f}'),
                    ('\u{1f85a}', '\u{1f85f}'),
                    ('\u{1f888}', '\u{1f88f}'),
                    ('\u{1f8ae}', '\u{1f8ff}'),
                    ('🤌', '🤺'),
                    ('🤼', '🥅'),
                    ('🥇', '\u{1faff}'),
                    ('\u{1fc00}', '\u{1fffd}'),
                ];

                pub const EXTENDER: &'static [(char, char)] = &
                [
                    ('·', '·'),
                    ('ː', 'ˑ'),
                    ('ـ', 'ـ'),
                    ('ߺ', 'ߺ'),
                    ('\u{a71}', '\u{a71}'),
                    ('\u{afb}', '\u{afb}'),
                    ('\u{b55}', '\u{b55}'),
                    ('ๆ', 'ๆ'),
                    ('ໆ', 'ໆ'),
                    ('᠊', '᠊'),
                    ('ᡃ', 'ᡃ'),
                    ('ᪧ', 'ᪧ'),
                    ('\u{1c36}', '\u{1c36}'),
                    ('ᱻ', 'ᱻ'),
                    ('々', '々'),
                    ('〱', '〵'),
                    ('ゝ', 'ゞ'),
                    ('ー', 'ヾ'),
                    ('ꀕ', 'ꀕ'),
                    ('ꘌ', 'ꘌ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧦ', 'ꧦ'),
                    ('ꩰ', 'ꩰ'),
                    ('ꫝ', 'ꫝ'),
                    ('ꫳ', 'ꫴ'),
                    ('ｰ', 'ｰ'),
                    ('𐞁', '𐞂'),
                    ('𐵎', '𐵎'),
                    ('\u{10d6a}', '\u{10d6a}'),
                    ('𐵯', '𐵯'),
                    ('\u{11237}', '\u{11237}'),
                    ('𑍝', '𑍝'),
                    ('\u{113d2}', '𑏓'),
                    ('𑗆', '𑗈'),
                    ('\u{11a98}', '\u{11a98}'),
                    ('𖭂', '𖭃'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𞄼', '𞄽'),
                    ('\u{1e5ef}', '\u{1e5ef}'),
                    ('\u{1e944}', '\u{1e946}'),
                ];

                pub const GRAPHEME_BASE: &'static [(char, char)] = &
                [
                    (' ', '~'),
                    ('\u{a0}', '¬'),
                    ('®', '˿'),
                    ('Ͱ', 'ͷ'),
                    ('ͺ', 'Ϳ'),
                    ('΄', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', '҂'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', '֊'),
                    ('֍', '֏'),
                    ('־', '־'),
                    ('׀', '׀'),
                    ('׃', '׃'),
                    ('׆', '׆'),
                    ('א', 'ת'),
                    ('ׯ', '״'),
                    ('؆', '؏'),
                    ('؛', '؛'),
                    ('؝', 'ي'),
                    ('٠', 'ٯ'),
                    ('ٱ', 'ە'),
                    ('۞', '۞'),
                    ('ۥ', 'ۦ'),
                    ('۩', '۩'),
                    ('ۮ', '܍'),
                    ('ܐ', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('߀', 'ߪ'),
                    ('ߴ', 'ߺ'),
                    ('߾', 'ࠕ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('࠰', '࠾'),
                    ('ࡀ', 'ࡘ'),
                    ('࡞', '࡞'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢎ'),
                    ('ࢠ', 'ࣉ'),
                    ('ः', 'ह'),
                    ('ऻ', 'ऻ'),
                    ('ऽ', 'ी'),
                    ('ॉ', 'ौ'),
                    ('ॎ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('।', 'ঀ'),
                    ('ং', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ি', 'ী'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৌ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('০', '৽'),
                    ('ਃ', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਾ', 'ੀ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', '੯'),
                    ('ੲ', 'ੴ'),
                    ('੶', '੶'),
                    ('ઃ', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ી'),
                    ('ૉ', 'ૉ'),
                    ('ો', 'ૌ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('૦', '૱'),
                    ('ૹ', 'ૹ'),
                    ('ଂ', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ୀ', 'ୀ'),
                    ('େ', 'ୈ'),
                    ('ୋ', 'ୌ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('୦', '୷'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ி', 'ி'),
                    ('ு', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', 'ௌ'),
                    ('ௐ', 'ௐ'),
                    ('௦', '௺'),
                    ('ఁ', 'ః'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ు', 'ౄ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('౦', '౯'),
                    ('౷', 'ಀ'),
                    ('ಂ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಾ'),
                    ('ು', 'ು'),
                    ('ೃ', 'ೄ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('೦', '೯'),
                    ('ೱ', 'ೳ'),
                    ('ം', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ി', 'ീ'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൌ'),
                    ('ൎ', '൏'),
                    ('ൔ', 'ൖ'),
                    ('൘', 'ൡ'),
                    ('൦', 'ൿ'),
                    ('ං', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ැ', 'ෑ'),
                    ('ෘ', 'ෞ'),
                    ('෦', '෯'),
                    ('ෲ', '෴'),
                    ('ก', 'ะ'),
                    ('า', 'ำ'),
                    ('฿', 'ๆ'),
                    ('๏', '๛'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ະ'),
                    ('າ', 'ຳ'),
                    ('ຽ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('໐', '໙'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', '༗'),
                    ('༚', '༴'),
                    ('༶', '༶'),
                    ('༸', '༸'),
                    ('༺', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ཿ', 'ཿ'),
                    ('྅', '྅'),
                    ('ྈ', 'ྌ'),
                    ('྾', '࿅'),
                    ('࿇', '࿌'),
                    ('࿎', '࿚'),
                    ('က', 'ာ'),
                    ('ေ', 'ေ'),
                    ('း', 'း'),
                    ('ျ', 'ြ'),
                    ('ဿ', 'ၗ'),
                    ('ၚ', 'ၝ'),
                    ('ၡ', 'ၰ'),
                    ('ၵ', 'ႁ'),
                    ('ႃ', 'ႄ'),
                    ('ႇ', 'ႌ'),
                    ('ႎ', 'ႜ'),
                    ('႞', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('፠', '፼'),
                    ('ᎀ', '᎙'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('᐀', '᚜'),
                    ('ᚠ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('᜵', '᜶'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ក', 'ឳ'),
                    ('ា', 'ា'),
                    ('ើ', 'ៅ'),
                    ('ះ', 'ៈ'),
                    ('។', 'ៜ'),
                    ('០', '៩'),
                    ('៰', '៹'),
                    ('᠀', '᠊'),
                    ('᠐', '᠙'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢄ'),
                    ('ᢇ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᤣ', 'ᤦ'),
                    ('ᤩ', 'ᤫ'),
                    ('ᤰ', 'ᤱ'),
                    ('ᤳ', 'ᤸ'),
                    ('᥀', '᥀'),
                    ('᥄', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('᧐', '᧚'),
                    ('᧞', 'ᨖ'),
                    ('ᨙ', 'ᨚ'),
                    ('᨞', 'ᩕ'),
                    ('ᩗ', 'ᩗ'),
                    ('ᩡ', 'ᩡ'),
                    ('ᩣ', 'ᩤ'),
                    ('ᩭ', 'ᩲ'),
                    ('᪀', '᪉'),
                    ('᪐', '᪙'),
                    ('᪠', '᪭'),
                    ('ᬄ', 'ᬳ'),
                    ('ᬾ', 'ᭁ'),
                    ('ᭅ', 'ᭌ'),
                    ('᭎', '᭪'),
                    ('᭴', '᭿'),
                    ('ᮂ', 'ᮡ'),
                    ('ᮦ', 'ᮧ'),
                    ('ᮮ', 'ᯥ'),
                    ('ᯧ', 'ᯧ'),
                    ('ᯪ', 'ᯬ'),
                    ('ᯮ', 'ᯮ'),
                    ('᯼', 'ᰫ'),
                    ('ᰴ', 'ᰵ'),
                    ('᰻', '᱉'),
                    ('ᱍ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', '᳇'),
                    ('᳓', '᳓'),
                    ('᳡', '᳡'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', '᳷'),
                    ('ᳺ', 'ᳺ'),
                    ('ᴀ', 'ᶿ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ῄ'),
                    ('ῆ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('῝', '`'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', '῾'),
                    ('\u{2000}', '\u{200a}'),
                    ('‐', '‧'),
                    ('\u{202f}', '\u{205f}'),
                    ('⁰', 'ⁱ'),
                    ('⁴', '₎'),
                    ('ₐ', 'ₜ'),
                    ('₠', '⃀'),
                    ('℀', '↋'),
                    ('←', '␩'),
                    ('⑀', '⑊'),
                    ('①', '⭳'),
                    ('⭶', '⮕'),
                    ('⮗', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('⳹', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', '⵰'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('⸀', '⹝'),
                    ('⺀', '⺙'),
                    ('⺛', '⻳'),
                    ('⼀', '⿕'),
                    ('⿰', '〩'),
                    ('〰', '〿'),
                    ('ぁ', 'ゖ'),
                    ('゛', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('㆐', '㇥'),
                    ('㇯', '㈞'),
                    ('㈠', 'ꒌ'),
                    ('꒐', '꓆'),
                    ('ꓐ', 'ꘫ'),
                    ('Ꙁ', 'ꙮ'),
                    ('꙳', '꙳'),
                    ('꙾', 'ꚝ'),
                    ('ꚠ', 'ꛯ'),
                    ('꛲', '꛷'),
                    ('꜀', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠤ'),
                    ('ꠧ', '꠫'),
                    ('꠰', '꠹'),
                    ('ꡀ', '꡷'),
                    ('ꢀ', 'ꣃ'),
                    ('꣎', '꣙'),
                    ('ꣲ', 'ꣾ'),
                    ('꤀', 'ꤥ'),
                    ('꤮', 'ꥆ'),
                    ('ꥒ', 'ꥒ'),
                    ('꥟', 'ꥼ'),
                    ('ꦃ', 'ꦲ'),
                    ('ꦴ', 'ꦵ'),
                    ('ꦺ', 'ꦻ'),
                    ('ꦾ', 'ꦿ'),
                    ('꧁', '꧍'),
                    ('ꧏ', '꧙'),
                    ('꧞', 'ꧤ'),
                    ('ꧦ', 'ꧾ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꨯ', 'ꨰ'),
                    ('ꨳ', 'ꨴ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꩍ', 'ꩍ'),
                    ('꩐', '꩙'),
                    ('꩜', 'ꩻ'),
                    ('ꩽ', 'ꪯ'),
                    ('ꪱ', 'ꪱ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪽ'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫫ'),
                    ('ꫮ', 'ꫵ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', '꭫'),
                    ('ꭰ', 'ꯤ'),
                    ('ꯦ', 'ꯧ'),
                    ('ꯩ', '꯬'),
                    ('꯰', '꯹'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', '﯂'),
                    ('ﯓ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('﷏', '﷏'),
                    ('ﷰ', '﷿'),
                    ('︐', '︙'),
                    ('︰', '﹒'),
                    ('﹔', '﹦'),
                    ('﹨', '﹫'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('！', 'ﾝ'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('￠', '￦'),
                    ('￨', '￮'),
                    (' ', ' '),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐄀', '𐄂'),
                    ('𐄇', '𐄳'),
                    ('𐄷', '𐆎'),
                    ('𐆐', '𐆜'),
                    ('𐆠', '𐆠'),
                    ('𐇐', '𐇼'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐋡', '𐋻'),
                    ('𐌀', '𐌣'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎟', '𐏃'),
                    ('𐏈', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒠', '𐒩'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕯', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡗', '𐢞'),
                    ('𐢧', '𐢯'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐣻', '𐤛'),
                    ('𐤟', '𐤹'),
                    ('𐤿', '𐤿'),
                    ('𐦀', '𐦷'),
                    ('𐦼', '𐧏'),
                    ('𐧒', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩀', '𐩈'),
                    ('𐩐', '𐩘'),
                    ('𐩠', '𐪟'),
                    ('𐫀', '𐫤'),
                    ('𐫫', '𐫶'),
                    ('𐬀', '𐬵'),
                    ('𐬹', '𐭕'),
                    ('𐭘', '𐭲'),
                    ('𐭸', '𐮑'),
                    ('𐮙', '𐮜'),
                    ('𐮩', '𐮯'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐳺', '𐴣'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵥'),
                    ('𐵮', '𐶅'),
                    ('𐶎', '𐶏'),
                    ('𐹠', '𐹾'),
                    ('𐺀', '𐺩'),
                    ('𐺭', '𐺭'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽑', '𐽙'),
                    ('𐽰', '𐾁'),
                    ('𐾆', '𐾉'),
                    ('𐾰', '𐿋'),
                    ('𐿠', '𐿶'),
                    ('𑀀', '𑀀'),
                    ('𑀂', '𑀷'),
                    ('𑁇', '𑁍'),
                    ('𑁒', '𑁯'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂂', '𑂲'),
                    ('𑂷', '𑂸'),
                    ('𑂻', '𑂼'),
                    ('𑂾', '𑃁'),
                    ('𑃐', '𑃨'),
                    ('𑃰', '𑃹'),
                    ('𑄃', '𑄦'),
                    ('𑄬', '𑄬'),
                    ('𑄶', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅴', '𑅶'),
                    ('𑆂', '𑆵'),
                    ('𑆿', '𑆿'),
                    ('𑇁', '𑇈'),
                    ('𑇍', '𑇎'),
                    ('𑇐', '𑇟'),
                    ('𑇡', '𑇴'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈮'),
                    ('𑈲', '𑈳'),
                    ('𑈸', '𑈽'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊩'),
                    ('𑊰', '𑋞'),
                    ('𑋠', '𑋢'),
                    ('𑋰', '𑋹'),
                    ('𑌂', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑌿', '𑌿'),
                    ('𑍁', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '𑍌'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍣'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑎹', '𑎺'),
                    ('𑏊', '𑏊'),
                    ('𑏌', '𑏍'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏕'),
                    ('𑏗', '𑏘'),
                    ('𑐀', '𑐷'),
                    ('𑑀', '𑑁'),
                    ('𑑅', '𑑅'),
                    ('𑑇', '𑑛'),
                    ('𑑝', '𑑝'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑒱', '𑒲'),
                    ('𑒹', '𑒹'),
                    ('𑒻', '𑒼'),
                    ('𑒾', '𑒾'),
                    ('𑓁', '𑓁'),
                    ('𑓄', '𑓇'),
                    ('𑓐', '𑓙'),
                    ('𑖀', '𑖮'),
                    ('𑖰', '𑖱'),
                    ('𑖸', '𑖻'),
                    ('𑖾', '𑖾'),
                    ('𑗁', '𑗛'),
                    ('𑘀', '𑘲'),
                    ('𑘻', '𑘼'),
                    ('𑘾', '𑘾'),
                    ('𑙁', '𑙄'),
                    ('𑙐', '𑙙'),
                    ('𑙠', '𑙬'),
                    ('𑚀', '𑚪'),
                    ('𑚬', '𑚬'),
                    ('𑚮', '𑚯'),
                    ('𑚸', '𑚹'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜀', '𑜚'),
                    ('𑜞', '𑜞'),
                    ('𑜠', '𑜡'),
                    ('𑜦', '𑜦'),
                    ('𑜰', '𑝆'),
                    ('𑠀', '𑠮'),
                    ('𑠸', '𑠸'),
                    ('𑠻', '𑠻'),
                    ('𑢠', '𑣲'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤱', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('𑤿', '𑥂'),
                    ('𑥄', '𑥆'),
                    ('𑥐', '𑥙'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧓'),
                    ('𑧜', '𑧟'),
                    ('𑧡', '𑧤'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨹', '𑨺'),
                    ('𑨿', '𑩆'),
                    ('𑩐', '𑩐'),
                    ('𑩗', '𑩘'),
                    ('𑩜', '𑪉'),
                    ('𑪗', '𑪗'),
                    ('𑪚', '𑪢'),
                    ('𑪰', '𑫸'),
                    ('𑬀', '𑬉'),
                    ('𑯀', '𑯡'),
                    ('𑯰', '𑯹'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰯'),
                    ('𑰾', '𑰾'),
                    ('𑱀', '𑱅'),
                    ('𑱐', '𑱬'),
                    ('𑱰', '𑲏'),
                    ('𑲩', '𑲩'),
                    ('𑲱', '𑲱'),
                    ('𑲴', '𑲴'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵐', '𑵙'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('𑶓', '𑶔'),
                    ('𑶖', '𑶖'),
                    ('𑶘', '𑶘'),
                    ('𑶠', '𑶩'),
                    ('𑻠', '𑻲'),
                    ('𑻵', '𑻸'),
                    ('𑼂', '𑼐'),
                    ('𑼒', '𑼵'),
                    ('𑼾', '𑼿'),
                    ('𑽃', '𑽙'),
                    ('𑾰', '𑾰'),
                    ('𑿀', '𑿱'),
                    ('𑿿', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒑰', '𒑴'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿲'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖄪', '𖄬'),
                    ('𖄰', '𖄹'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩠', '𖩩'),
                    ('𖩮', '𖪾'),
                    ('𖫀', '𖫉'),
                    ('𖫐', '𖫭'),
                    ('𖫵', '𖫵'),
                    ('𖬀', '𖬯'),
                    ('𖬷', '𖭅'),
                    ('𖭐', '𖭙'),
                    ('𖭛', '𖭡'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵹'),
                    ('𖹀', '𖺚'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖾇'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿣'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𛲜', '𛲜'),
                    ('𛲟', '𛲟'),
                    ('𜰀', '𜳹'),
                    ('𜴀', '𜺳'),
                    ('𜽐', '𜿃'),
                    ('𝀀', '𝃵'),
                    ('𝄀', '𝄦'),
                    ('𝄩', '𝅘𝅥𝅲'),
                    ('𝅪', '𝅬'),
                    ('𝆃', '𝆄'),
                    ('𝆌', '𝆩'),
                    ('𝆮', '𝇪'),
                    ('𝈀', '𝉁'),
                    ('𝉅', '𝉅'),
                    ('𝋀', '𝋓'),
                    ('𝋠', '𝋳'),
                    ('𝌀', '𝍖'),
                    ('𝍠', '𝍸'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝟋'),
                    ('𝟎', '𝧿'),
                    ('𝨷', '𝨺'),
                    ('𝩭', '𝩴'),
                    ('𝩶', '𝪃'),
                    ('𝪅', '𝪋'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅀', '𞅉'),
                    ('𞅎', '𞅏'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞋰', '𞋹'),
                    ('𞋿', '𞋿'),
                    ('𞓐', '𞓫'),
                    ('𞓰', '𞓹'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗺'),
                    ('𞗿', '𞗿'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞣇', '𞣏'),
                    ('𞤀', '𞥃'),
                    ('𞥋', '𞥋'),
                    ('𞥐', '𞥙'),
                    ('𞥞', '𞥟'),
                    ('𞱱', '𞲴'),
                    ('𞴁', '𞴽'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𞻰', '𞻱'),
                    ('🀀', '🀫'),
                    ('🀰', '🂓'),
                    ('🂠', '🂮'),
                    ('🂱', '🂿'),
                    ('🃁', '🃏'),
                    ('🃑', '🃵'),
                    ('🄀', '🆭'),
                    ('🇦', '🈂'),
                    ('🈐', '🈻'),
                    ('🉀', '🉈'),
                    ('🉐', '🉑'),
                    ('🉠', '🉥'),
                    ('🌀', '🛗'),
                    ('🛜', '🛬'),
                    ('🛰', '🛼'),
                    ('🜀', '🝶'),
                    ('🝻', '🟙'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🠀', '🠋'),
                    ('🠐', '🡇'),
                    ('🡐', '🡙'),
                    ('🡠', '🢇'),
                    ('🢐', '🢭'),
                    ('🢰', '🢻'),
                    ('🣀', '🣁'),
                    ('🤀', '🩓'),
                    ('🩠', '🩭'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                    ('🬀', '🮒'),
                    ('🮔', '🯹'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const GRAPHEME_EXTEND: &'static [(char, char)] = &
                [
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{489}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', '\u{902}'),
                    ('\u{93a}', '\u{93a}'),
                    ('\u{93c}', '\u{93c}'),
                    ('\u{941}', '\u{948}'),
                    ('\u{94d}', '\u{94d}'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', '\u{981}'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9be}'),
                    ('\u{9c1}', '\u{9c4}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', '\u{a02}'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('\u{a41}', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', '\u{a82}'),
                    ('\u{abc}', '\u{abc}'),
                    ('\u{ac1}', '\u{ac5}'),
                    ('\u{ac7}', '\u{ac8}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', '\u{b01}'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3e}', '\u{b3f}'),
                    ('\u{b41}', '\u{b44}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', '\u{bbe}'),
                    ('\u{bc0}', '\u{bc0}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c00}'),
                    ('\u{c04}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', '\u{c40}'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', '\u{c81}'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('\u{cbf}', '\u{cc0}'),
                    ('\u{cc2}', '\u{cc2}'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('\u{d00}', '\u{d01}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d3e}', '\u{d3e}'),
                    ('\u{d41}', '\u{d44}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', '\u{d81}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dcf}'),
                    ('\u{dd2}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('\u{ddf}', '\u{ddf}'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('\u{f71}', '\u{f7e}'),
                    ('\u{f80}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('\u{102d}', '\u{1030}'),
                    ('\u{1032}', '\u{1037}'),
                    ('\u{1039}', '\u{103a}'),
                    ('\u{103d}', '\u{103e}'),
                    ('\u{1058}', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{1082}'),
                    ('\u{1085}', '\u{1086}'),
                    ('\u{108d}', '\u{108d}'),
                    ('\u{109d}', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1715}'),
                    ('\u{1732}', '\u{1734}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{17b7}', '\u{17bd}'),
                    ('\u{17c6}', '\u{17c6}'),
                    ('\u{17c9}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', '\u{1922}'),
                    ('\u{1927}', '\u{1928}'),
                    ('\u{1932}', '\u{1932}'),
                    ('\u{1939}', '\u{193b}'),
                    ('\u{1a17}', '\u{1a18}'),
                    ('\u{1a1b}', '\u{1a1b}'),
                    ('\u{1a56}', '\u{1a56}'),
                    ('\u{1a58}', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1a62}', '\u{1a62}'),
                    ('\u{1a65}', '\u{1a6c}'),
                    ('\u{1a73}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', '\u{1b03}'),
                    ('\u{1b34}', '\u{1b3d}'),
                    ('\u{1b42}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1b81}'),
                    ('\u{1ba2}', '\u{1ba5}'),
                    ('\u{1ba8}', '\u{1bad}'),
                    ('\u{1be6}', '\u{1be6}'),
                    ('\u{1be8}', '\u{1be9}'),
                    ('\u{1bed}', '\u{1bed}'),
                    ('\u{1bef}', '\u{1bf3}'),
                    ('\u{1c2c}', '\u{1c33}'),
                    ('\u{1c36}', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce0}'),
                    ('\u{1ce2}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{200c}', '\u{200c}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('\u{a825}', '\u{a826}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a951}'),
                    ('\u{a953}', '\u{a953}'),
                    ('\u{a980}', '\u{a982}'),
                    ('\u{a9b3}', '\u{a9b3}'),
                    ('\u{a9b6}', '\u{a9b9}'),
                    ('\u{a9bc}', '\u{a9bd}'),
                    ('\u{a9c0}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa2e}'),
                    ('\u{aa31}', '\u{aa32}'),
                    ('\u{aa35}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', '\u{aa4c}'),
                    ('\u{aa7c}', '\u{aa7c}'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('\u{aaec}', '\u{aaed}'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('\u{abe5}', '\u{abe5}'),
                    ('\u{abe8}', '\u{abe8}'),
                    ('\u{abed}', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('\u{11001}', '\u{11001}'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '\u{11081}'),
                    ('\u{110b3}', '\u{110b6}'),
                    ('\u{110b9}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{1112b}'),
                    ('\u{1112d}', '\u{11134}'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '\u{11181}'),
                    ('\u{111b6}', '\u{111be}'),
                    ('\u{111c0}', '\u{111c0}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('\u{111cf}', '\u{111cf}'),
                    ('\u{1122f}', '\u{11231}'),
                    ('\u{11234}', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112df}'),
                    ('\u{112e3}', '\u{112ea}'),
                    ('\u{11300}', '\u{11301}'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1133e}', '\u{1133e}'),
                    ('\u{11340}', '\u{11340}'),
                    ('\u{1134d}', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113b8}', '\u{113b8}'),
                    ('\u{113bb}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '\u{113c9}'),
                    ('\u{113ce}', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('\u{11438}', '\u{1143f}'),
                    ('\u{11442}', '\u{11444}'),
                    ('\u{11446}', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b0}', '\u{114b0}'),
                    ('\u{114b3}', '\u{114b8}'),
                    ('\u{114ba}', '\u{114ba}'),
                    ('\u{114bd}', '\u{114bd}'),
                    ('\u{114bf}', '\u{114c0}'),
                    ('\u{114c2}', '\u{114c3}'),
                    ('\u{115af}', '\u{115af}'),
                    ('\u{115b2}', '\u{115b5}'),
                    ('\u{115bc}', '\u{115bd}'),
                    ('\u{115bf}', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('\u{11633}', '\u{1163a}'),
                    ('\u{1163d}', '\u{1163d}'),
                    ('\u{1163f}', '\u{11640}'),
                    ('\u{116ab}', '\u{116ab}'),
                    ('\u{116ad}', '\u{116ad}'),
                    ('\u{116b0}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1171d}'),
                    ('\u{1171f}', '\u{1171f}'),
                    ('\u{11722}', '\u{11725}'),
                    ('\u{11727}', '\u{1172b}'),
                    ('\u{1182f}', '\u{11837}'),
                    ('\u{11839}', '\u{1183a}'),
                    ('\u{11930}', '\u{11930}'),
                    ('\u{1193b}', '\u{1193e}'),
                    ('\u{11943}', '\u{11943}'),
                    ('\u{119d4}', '\u{119d7}'),
                    ('\u{119da}', '\u{119db}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '\u{11a38}'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a56}'),
                    ('\u{11a59}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a96}'),
                    ('\u{11a98}', '\u{11a99}'),
                    ('\u{11c30}', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3d}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('\u{11caa}', '\u{11cb0}'),
                    ('\u{11cb2}', '\u{11cb3}'),
                    ('\u{11cb5}', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('\u{11d95}', '\u{11d95}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11ef3}', '\u{11ef4}'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('\u{11f36}', '\u{11f3a}'),
                    ('\u{11f40}', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{16129}'),
                    ('\u{1612d}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('\u{e0020}', '\u{e007f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const GRAPHEME_LINK: &'static [(char, char)] = &
                [
                    ('\u{94d}', '\u{94d}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{a4d}', '\u{a4d}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{c4d}', '\u{c4d}'),
                    ('\u{ccd}', '\u{ccd}'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{e3a}', '\u{e3a}'),
                    ('\u{eba}', '\u{eba}'),
                    ('\u{f84}', '\u{f84}'),
                    ('\u{1039}', '\u{103a}'),
                    ('\u{1714}', '\u{1715}'),
                    ('\u{1734}', '\u{1734}'),
                    ('\u{17d2}', '\u{17d2}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1b44}', '\u{1b44}'),
                    ('\u{1baa}', '\u{1bab}'),
                    ('\u{1bf2}', '\u{1bf3}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c4}'),
                    ('\u{a953}', '\u{a953}'),
                    ('\u{a9c0}', '\u{a9c0}'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('\u{abed}', '\u{abed}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{11046}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{1107f}', '\u{1107f}'),
                    ('\u{110b9}', '\u{110b9}'),
                    ('\u{11133}', '\u{11134}'),
                    ('\u{111c0}', '\u{111c0}'),
                    ('\u{11235}', '\u{11235}'),
                    ('\u{112ea}', '\u{112ea}'),
                    ('\u{1134d}', '\u{1134d}'),
                    ('\u{113ce}', '\u{113d0}'),
                    ('\u{11442}', '\u{11442}'),
                    ('\u{114c2}', '\u{114c2}'),
                    ('\u{115bf}', '\u{115bf}'),
                    ('\u{1163f}', '\u{1163f}'),
                    ('\u{116b6}', '\u{116b6}'),
                    ('\u{1172b}', '\u{1172b}'),
                    ('\u{11839}', '\u{11839}'),
                    ('\u{1193d}', '\u{1193e}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a34}', '\u{11a34}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a99}', '\u{11a99}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11d44}', '\u{11d45}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11f41}', '\u{11f42}'),
                    ('\u{1612f}', '\u{1612f}'),
                ];

                pub const HEX_DIGIT: &'static [(char, char)] = &
                [
                    ('0', '9'),
                    ('A', 'F'),
                    ('a', 'f'),
                    ('０', '９'),
                    ('Ａ', 'Ｆ'),
                    ('ａ', 'ｆ'),
                ];

                pub const HYPHEN: &'static [(char, char)] = &
                [
                    ('-', '-'),
                    ('\u{ad}', '\u{ad}'),
                    ('֊', '֊'),
                    ('᠆', '᠆'),
                    ('‐', '‑'),
                    ('⸗', '⸗'),
                    ('・', '・'),
                    ('﹣', '﹣'),
                    ('－', '－'),
                    ('･', '･'),
                ];

                pub const IDS_BINARY_OPERATOR: &'static [(char, char)] = &[('⿰', '⿱'), ('⿴', '⿽'), ('㇯', '㇯')];

                pub const IDS_TRINARY_OPERATOR: &'static [(char, char)] = &[('⿲', '⿳')];

                pub const IDS_UNARY_OPERATOR: &'static [(char, char)] = &[('⿾', '⿿')];

                pub const ID_COMPAT_MATH_CONTINUE: &'static [(char, char)] = &
                [
                    ('²', '³'),
                    ('¹', '¹'),
                    ('⁰', '⁰'),
                    ('⁴', '⁾'),
                    ('₀', '₎'),
                    ('∂', '∂'),
                    ('∇', '∇'),
                    ('∞', '∞'),
                    ('𝛁', '𝛁'),
                    ('𝛛', '𝛛'),
                    ('𝛻', '𝛻'),
                    ('𝜕', '𝜕'),
                    ('𝜵', '𝜵'),
                    ('𝝏', '𝝏'),
                    ('𝝯', '𝝯'),
                    ('𝞉', '𝞉'),
                    ('𝞩', '𝞩'),
                    ('𝟃', '𝟃'),
                ];

                pub const ID_COMPAT_MATH_START: &'static [(char, char)] = &
                [
                    ('∂', '∂'),
                    ('∇', '∇'),
                    ('∞', '∞'),
                    ('𝛁', '𝛁'),
                    ('𝛛', '𝛛'),
                    ('𝛻', '𝛻'),
                    ('𝜕', '𝜕'),
                    ('𝜵', '𝜵'),
                    ('𝝏', '𝝏'),
                    ('𝝯', '𝝯'),
                    ('𝞉', '𝞉'),
                    ('𝞩', '𝞩'),
                    ('𝟃', '𝟃'),
                ];

                pub const ID_CONTINUE: &'static [(char, char)] = &
                [
                    ('0', '9'),
                    ('A', 'Z'),
                    ('_', '_'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('·', '·'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('\u{300}', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('\u{483}', '\u{487}'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('\u{610}', '\u{61a}'),
                    ('ؠ', '٩'),
                    ('ٮ', 'ۓ'),
                    ('ە', '\u{6dc}'),
                    ('\u{6df}', '\u{6e8}'),
                    ('\u{6ea}', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', '\u{74a}'),
                    ('ݍ', 'ޱ'),
                    ('߀', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('ࠀ', '\u{82d}'),
                    ('ࡀ', '\u{85b}'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('\u{897}', '\u{8e1}'),
                    ('\u{8e3}', '\u{963}'),
                    ('०', '९'),
                    ('ॱ', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৎ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('০', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', '\u{ae3}'),
                    ('૦', '૯'),
                    ('ૹ', '\u{aff}'),
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('\u{b3c}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', '\u{b63}'),
                    ('୦', '୯'),
                    ('ୱ', 'ୱ'),
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('ௐ', 'ௐ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('௦', '௯'),
                    ('\u{c00}', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('\u{c3c}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', '\u{c63}'),
                    ('౦', '౯'),
                    ('ಀ', 'ಃ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('\u{cbc}', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', '\u{ce3}'),
                    ('೦', '೯'),
                    ('ೱ', 'ೳ'),
                    ('\u{d00}', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൎ'),
                    ('ൔ', '\u{d57}'),
                    ('ൟ', '\u{d63}'),
                    ('൦', '൯'),
                    ('ൺ', 'ൿ'),
                    ('\u{d81}', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('෦', '෯'),
                    ('ෲ', 'ෳ'),
                    ('ก', '\u{e3a}'),
                    ('เ', '\u{e4e}'),
                    ('๐', '๙'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ece}'),
                    ('໐', '໙'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('\u{f18}', '\u{f19}'),
                    ('༠', '༩'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('\u{f71}', '\u{f84}'),
                    ('\u{f86}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('က', '၉'),
                    ('ၐ', '\u{109d}'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('\u{135d}', '\u{135f}'),
                    ('፩', '፱'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', '\u{1715}'),
                    ('ᜟ', '\u{1734}'),
                    ('ᝀ', '\u{1753}'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('\u{1772}', '\u{1773}'),
                    ('ក', '\u{17d3}'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', '\u{17dd}'),
                    ('០', '៩'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '᠙'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('᥆', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('᧐', '᧚'),
                    ('ᨀ', '\u{1a1b}'),
                    ('ᨠ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '᪉'),
                    ('᪐', '᪙'),
                    ('ᪧ', 'ᪧ'),
                    ('\u{1ab0}', '\u{1abd}'),
                    ('\u{1abf}', '\u{1ace}'),
                    ('\u{1b00}', 'ᭌ'),
                    ('᭐', '᭙'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1bf3}'),
                    ('ᰀ', '\u{1c37}'),
                    ('᱀', '᱉'),
                    ('ᱍ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', 'ᳺ'),
                    ('ᴀ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('\u{200c}', '\u{200d}'),
                    ('‿', '⁀'),
                    ('⁔', '⁔'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('\u{20d0}', '\u{20dc}'),
                    ('\u{20e1}', '\u{20e1}'),
                    ('\u{20e5}', '\u{20f0}'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('℘', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('\u{2d7f}', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('々', '〇'),
                    ('〡', '\u{302f}'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('\u{3099}', 'ゟ'),
                    ('ァ', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘫ'),
                    ('Ꙁ', '\u{a66f}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('ꙿ', '\u{a6f1}'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠧ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢀ', '\u{a8c5}'),
                    ('꣐', '꣙'),
                    ('\u{a8e0}', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', '\u{a92d}'),
                    ('ꤰ', '\u{a953}'),
                    ('ꥠ', 'ꥼ'),
                    ('\u{a980}', '\u{a9c0}'),
                    ('ꧏ', '꧙'),
                    ('ꧠ', 'ꧾ'),
                    ('ꨀ', '\u{aa36}'),
                    ('ꩀ', 'ꩍ'),
                    ('꩐', '꩙'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫯ'),
                    ('ꫲ', '\u{aaf6}'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯪ'),
                    ('꯬', '\u{abed}'),
                    ('꯰', '꯹'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('︳', '︴'),
                    ('﹍', '﹏'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('０', '９'),
                    ('Ａ', 'Ｚ'),
                    ('＿', '＿'),
                    ('ａ', 'ｚ'),
                    ('･', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '\u{1037a}'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒠', '𐒩'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '\u{10ae6}'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '\u{10d27}'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵥'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '\u{10f50}'),
                    ('𐽰', '\u{10f85}'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀀', '\u{11046}'),
                    ('𑁦', '𑁵'),
                    ('\u{1107f}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('𑃐', '𑃨'),
                    ('𑃰', '𑃹'),
                    ('\u{11100}', '\u{11134}'),
                    ('𑄶', '𑄿'),
                    ('𑅄', '𑅇'),
                    ('𑅐', '\u{11173}'),
                    ('𑅶', '𑅶'),
                    ('\u{11180}', '𑇄'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇎', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '\u{11237}'),
                    ('\u{1123e}', '\u{11241}'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '\u{112ea}'),
                    ('𑋰', '𑋹'),
                    ('\u{11300}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('\u{1133b}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('𑍐', '𑍐'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏓'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑐀', '𑑊'),
                    ('𑑐', '𑑙'),
                    ('\u{1145e}', '𑑡'),
                    ('𑒀', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑓐', '𑓙'),
                    ('𑖀', '\u{115b5}'),
                    ('𑖸', '\u{115c0}'),
                    ('𑗘', '\u{115dd}'),
                    ('𑘀', '\u{11640}'),
                    ('𑙄', '𑙄'),
                    ('𑙐', '𑙙'),
                    ('𑚀', '𑚸'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜀', '𑜚'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑜰', '𑜹'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '\u{1183a}'),
                    ('𑢠', '𑣩'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{11943}'),
                    ('𑥐', '𑥙'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '\u{119d7}'),
                    ('\u{119da}', '𑧡'),
                    ('𑧣', '𑧤'),
                    ('𑨀', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('𑩐', '\u{11a99}'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑯰', '𑯹'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '\u{11c36}'),
                    ('\u{11c38}', '𑱀'),
                    ('𑱐', '𑱙'),
                    ('𑱲', '𑲏'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d47}'),
                    ('𑵐', '𑵙'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶘'),
                    ('𑶠', '𑶩'),
                    ('𑻠', '𑻶'),
                    ('\u{11f00}', '𑼐'),
                    ('𑼒', '\u{11f3a}'),
                    ('𑼾', '\u{11f42}'),
                    ('𑽐', '\u{11f5a}'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('\u{13440}', '\u{13455}'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄹'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩠', '𖩩'),
                    ('𖩰', '𖪾'),
                    ('𖫀', '𖫉'),
                    ('𖫐', '𖫭'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('𖬀', '\u{16b36}'),
                    ('𖭀', '𖭃'),
                    ('𖭐', '𖭙'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖵰', '𖵹'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('\u{16f4f}', '𖾇'),
                    ('\u{16f8f}', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('𜳰', '𜳹'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('𞄀', '𞄬'),
                    ('\u{1e130}', '𞄽'),
                    ('𞅀', '𞅉'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '\u{1e2ae}'),
                    ('𞋀', '𞋹'),
                    ('𞓐', '𞓹'),
                    ('𞗐', '𞗺'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('𞤀', '𞥋'),
                    ('𞥐', '𞥙'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('🯰', '🯹'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const ID_START: &'static [(char, char)] = &
                [
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('Ͱ', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('ؠ', 'ي'),
                    ('ٮ', 'ٯ'),
                    ('ٱ', 'ۓ'),
                    ('ە', 'ە'),
                    ('ۥ', 'ۦ'),
                    ('ۮ', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠀ', 'ࠕ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('ࢠ', 'ࣉ'),
                    ('ऄ', 'ह'),
                    ('ऽ', 'ऽ'),
                    ('ॐ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('ॱ', 'ঀ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('ੲ', 'ੴ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ઽ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('ૹ', 'ૹ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('ୱ', 'ୱ'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ௐ', 'ௐ'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('ಀ', 'ಀ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಽ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('ೱ', 'ೲ'),
                    ('ഄ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', 'ൖ'),
                    ('ൟ', 'ൡ'),
                    ('ൺ', 'ൿ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ก', 'ะ'),
                    ('า', 'ำ'),
                    ('เ', 'ๆ'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ະ'),
                    ('າ', 'ຳ'),
                    ('ຽ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ྈ', 'ྌ'),
                    ('က', 'ဪ'),
                    ('ဿ', 'ဿ'),
                    ('ၐ', 'ၕ'),
                    ('ၚ', 'ၝ'),
                    ('ၡ', 'ၡ'),
                    ('ၥ', 'ၦ'),
                    ('ၮ', 'ၰ'),
                    ('ၵ', 'ႁ'),
                    ('ႎ', 'ႎ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ក', 'ឳ'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', 'ៜ'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('ᨀ', 'ᨖ'),
                    ('ᨠ', 'ᩔ'),
                    ('ᪧ', 'ᪧ'),
                    ('ᬅ', 'ᬳ'),
                    ('ᭅ', 'ᭌ'),
                    ('ᮃ', 'ᮠ'),
                    ('ᮮ', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᰀ', 'ᰣ'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ᴀ', 'ᶿ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('℘', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('々', '〇'),
                    ('〡', '〩'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('゛', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('Ꙁ', 'ꙮ'),
                    ('ꙿ', 'ꚝ'),
                    ('ꚠ', 'ꛯ'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠢ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢂ', 'ꢳ'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', 'ꣾ'),
                    ('ꤊ', 'ꤥ'),
                    ('ꤰ', 'ꥆ'),
                    ('ꥠ', 'ꥼ'),
                    ('ꦄ', 'ꦲ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧠ', 'ꧤ'),
                    ('ꧦ', 'ꧯ'),
                    ('ꧺ', 'ꧾ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꩺ'),
                    ('ꩾ', 'ꪯ'),
                    ('ꪱ', 'ꪱ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪽ'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫪ'),
                    ('ꫲ', 'ꫴ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯢ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('ｦ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '𐴣'),
                    ('𐵊', '𐵥'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀃', '𑀷'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂃', '𑂯'),
                    ('𑃐', '𑃨'),
                    ('𑄃', '𑄦'),
                    ('𑅄', '𑅄'),
                    ('𑅇', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('𑆃', '𑆲'),
                    ('𑇁', '𑇄'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈫'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '𑋞'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍡'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑐴'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '𑖮'),
                    ('𑗘', '𑗛'),
                    ('𑘀', '𑘯'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '𑚪'),
                    ('𑚸', '𑚸'),
                    ('𑜀', '𑜚'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '𑠫'),
                    ('𑢠', '𑣟'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧐'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧣'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨺', '𑨺'),
                    ('𑩐', '𑩐'),
                    ('𑩜', '𑪉'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰮'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶉'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻲'),
                    ('𑼂', '𑼂'),
                    ('𑼄', '𑼐'),
                    ('𑼒', '𑼳'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭀', '𖭃'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖽐'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓫'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞤀', '𞥃'),
                    ('𞥋', '𞥋'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const IDEOGRAPHIC: &'static [(char, char)] = &[
                    ('〆', '〇'),
                    ('〡', '〩'),
                    ('〸', '〺'),
                    ('㐀', '䶿'),
                    ('一', '鿿'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𛅰', '𛋻'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const INCB: &'static [(char, char)] = &[
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{489}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', '\u{902}'),
                    ('क', '\u{93a}'),
                    ('\u{93c}', '\u{93c}'),
                    ('\u{941}', '\u{948}'),
                    ('\u{94d}', '\u{94d}'),
                    ('\u{951}', 'य़'),
                    ('\u{962}', '\u{963}'),
                    ('ॸ', 'ॿ'),
                    ('\u{981}', '\u{981}'),
                    ('ক', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9be}'),
                    ('\u{9c1}', '\u{9c4}'),
                    ('\u{9cd}', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'য়'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('ৰ', 'ৱ'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', '\u{a02}'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('\u{a41}', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', '\u{a82}'),
                    ('ક', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{abc}'),
                    ('\u{ac1}', '\u{ac5}'),
                    ('\u{ac7}', '\u{ac8}'),
                    ('\u{acd}', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('ૹ', '\u{aff}'),
                    ('\u{b01}', '\u{b01}'),
                    ('କ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3e}', '\u{b3f}'),
                    ('\u{b41}', '\u{b44}'),
                    ('\u{b4d}', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୟ'),
                    ('\u{b62}', '\u{b63}'),
                    ('ୱ', 'ୱ'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', '\u{bbe}'),
                    ('\u{bc0}', '\u{bc0}'),
                    ('\u{bcd}', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c00}'),
                    ('\u{c04}', '\u{c04}'),
                    ('క', 'న'),
                    ('ప', 'హ'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', '\u{c40}'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', '\u{c81}'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('\u{cbf}', '\u{cc0}'),
                    ('\u{cc2}', '\u{cc2}'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('\u{d00}', '\u{d01}'),
                    ('ക', '\u{d3c}'),
                    ('\u{d3e}', '\u{d3e}'),
                    ('\u{d41}', '\u{d44}'),
                    ('\u{d4d}', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', '\u{d81}'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dcf}'),
                    ('\u{dd2}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('\u{ddf}', '\u{ddf}'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('\u{f71}', '\u{f7e}'),
                    ('\u{f80}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('\u{102d}', '\u{1030}'),
                    ('\u{1032}', '\u{1037}'),
                    ('\u{1039}', '\u{103a}'),
                    ('\u{103d}', '\u{103e}'),
                    ('\u{1058}', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{1082}'),
                    ('\u{1085}', '\u{1086}'),
                    ('\u{108d}', '\u{108d}'),
                    ('\u{109d}', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1715}'),
                    ('\u{1732}', '\u{1734}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{17b7}', '\u{17bd}'),
                    ('\u{17c6}', '\u{17c6}'),
                    ('\u{17c9}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', '\u{1922}'),
                    ('\u{1927}', '\u{1928}'),
                    ('\u{1932}', '\u{1932}'),
                    ('\u{1939}', '\u{193b}'),
                    ('\u{1a17}', '\u{1a18}'),
                    ('\u{1a1b}', '\u{1a1b}'),
                    ('\u{1a56}', '\u{1a56}'),
                    ('\u{1a58}', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a60}'),
                    ('\u{1a62}', '\u{1a62}'),
                    ('\u{1a65}', '\u{1a6c}'),
                    ('\u{1a73}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', '\u{1b03}'),
                    ('\u{1b34}', '\u{1b3d}'),
                    ('\u{1b42}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1b81}'),
                    ('\u{1ba2}', '\u{1ba5}'),
                    ('\u{1ba8}', '\u{1bad}'),
                    ('\u{1be6}', '\u{1be6}'),
                    ('\u{1be8}', '\u{1be9}'),
                    ('\u{1bed}', '\u{1bed}'),
                    ('\u{1bef}', '\u{1bf3}'),
                    ('\u{1c2c}', '\u{1c33}'),
                    ('\u{1c36}', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce0}'),
                    ('\u{1ce2}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{200d}', '\u{200d}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('\u{a825}', '\u{a826}'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('\u{a8c4}', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a951}'),
                    ('\u{a953}', '\u{a953}'),
                    ('\u{a980}', '\u{a982}'),
                    ('\u{a9b3}', '\u{a9b3}'),
                    ('\u{a9b6}', '\u{a9b9}'),
                    ('\u{a9bc}', '\u{a9bd}'),
                    ('\u{a9c0}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa2e}'),
                    ('\u{aa31}', '\u{aa32}'),
                    ('\u{aa35}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', '\u{aa4c}'),
                    ('\u{aa7c}', '\u{aa7c}'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('\u{aaec}', '\u{aaed}'),
                    ('\u{aaf6}', '\u{aaf6}'),
                    ('\u{abe5}', '\u{abe5}'),
                    ('\u{abe8}', '\u{abe8}'),
                    ('\u{abed}', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('\u{11001}', '\u{11001}'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '\u{11081}'),
                    ('\u{110b3}', '\u{110b6}'),
                    ('\u{110b9}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{1112b}'),
                    ('\u{1112d}', '\u{11134}'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '\u{11181}'),
                    ('\u{111b6}', '\u{111be}'),
                    ('\u{111c0}', '\u{111c0}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('\u{111cf}', '\u{111cf}'),
                    ('\u{1122f}', '\u{11231}'),
                    ('\u{11234}', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112df}'),
                    ('\u{112e3}', '\u{112ea}'),
                    ('\u{11300}', '\u{11301}'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1133e}', '\u{1133e}'),
                    ('\u{11340}', '\u{11340}'),
                    ('\u{1134d}', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113b8}', '\u{113b8}'),
                    ('\u{113bb}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '\u{113c9}'),
                    ('\u{113ce}', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('\u{11438}', '\u{1143f}'),
                    ('\u{11442}', '\u{11444}'),
                    ('\u{11446}', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b0}', '\u{114b0}'),
                    ('\u{114b3}', '\u{114b8}'),
                    ('\u{114ba}', '\u{114ba}'),
                    ('\u{114bd}', '\u{114bd}'),
                    ('\u{114bf}', '\u{114c0}'),
                    ('\u{114c2}', '\u{114c3}'),
                    ('\u{115af}', '\u{115af}'),
                    ('\u{115b2}', '\u{115b5}'),
                    ('\u{115bc}', '\u{115bd}'),
                    ('\u{115bf}', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('\u{11633}', '\u{1163a}'),
                    ('\u{1163d}', '\u{1163d}'),
                    ('\u{1163f}', '\u{11640}'),
                    ('\u{116ab}', '\u{116ab}'),
                    ('\u{116ad}', '\u{116ad}'),
                    ('\u{116b0}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1171d}'),
                    ('\u{1171f}', '\u{1171f}'),
                    ('\u{11722}', '\u{11725}'),
                    ('\u{11727}', '\u{1172b}'),
                    ('\u{1182f}', '\u{11837}'),
                    ('\u{11839}', '\u{1183a}'),
                    ('\u{11930}', '\u{11930}'),
                    ('\u{1193b}', '\u{1193e}'),
                    ('\u{11943}', '\u{11943}'),
                    ('\u{119d4}', '\u{119d7}'),
                    ('\u{119da}', '\u{119db}'),
                    ('\u{119e0}', '\u{119e0}'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '\u{11a38}'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a56}'),
                    ('\u{11a59}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a96}'),
                    ('\u{11a98}', '\u{11a99}'),
                    ('\u{11c30}', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3d}'),
                    ('\u{11c3f}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('\u{11caa}', '\u{11cb0}'),
                    ('\u{11cb2}', '\u{11cb3}'),
                    ('\u{11cb5}', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('\u{11d95}', '\u{11d95}'),
                    ('\u{11d97}', '\u{11d97}'),
                    ('\u{11ef3}', '\u{11ef4}'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('\u{11f36}', '\u{11f3a}'),
                    ('\u{11f40}', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{16129}'),
                    ('\u{1612d}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('🏻', '🏿'),
                    ('\u{e0020}', '\u{e007f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const JOIN_CONTROL: &'static [(char, char)] = &[('\u{200c}', '\u{200d}')];

                pub const LOGICAL_ORDER_EXCEPTION: &'static [(char, char)] = &[
                    ('เ', 'ไ'),
                    ('ເ', 'ໄ'),
                    ('ᦵ', 'ᦷ'),
                    ('ᦺ', 'ᦺ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪹ'),
                    ('ꪻ', 'ꪼ'),
                ];

                pub const LOWERCASE: &'static [(char, char)] = &[
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('ß', 'ö'),
                    ('ø', 'ÿ'),
                    ('ā', 'ā'),
                    ('ă', 'ă'),
                    ('ą', 'ą'),
                    ('ć', 'ć'),
                    ('ĉ', 'ĉ'),
                    ('ċ', 'ċ'),
                    ('č', 'č'),
                    ('ď', 'ď'),
                    ('đ', 'đ'),
                    ('ē', 'ē'),
                    ('ĕ', 'ĕ'),
                    ('ė', 'ė'),
                    ('ę', 'ę'),
                    ('ě', 'ě'),
                    ('ĝ', 'ĝ'),
                    ('ğ', 'ğ'),
                    ('ġ', 'ġ'),
                    ('ģ', 'ģ'),
                    ('ĥ', 'ĥ'),
                    ('ħ', 'ħ'),
                    ('ĩ', 'ĩ'),
                    ('ī', 'ī'),
                    ('ĭ', 'ĭ'),
                    ('į', 'į'),
                    ('ı', 'ı'),
                    ('ĳ', 'ĳ'),
                    ('ĵ', 'ĵ'),
                    ('ķ', 'ĸ'),
                    ('ĺ', 'ĺ'),
                    ('ļ', 'ļ'),
                    ('ľ', 'ľ'),
                    ('ŀ', 'ŀ'),
                    ('ł', 'ł'),
                    ('ń', 'ń'),
                    ('ņ', 'ņ'),
                    ('ň', 'ŉ'),
                    ('ŋ', 'ŋ'),
                    ('ō', 'ō'),
                    ('ŏ', 'ŏ'),
                    ('ő', 'ő'),
                    ('œ', 'œ'),
                    ('ŕ', 'ŕ'),
                    ('ŗ', 'ŗ'),
                    ('ř', 'ř'),
                    ('ś', 'ś'),
                    ('ŝ', 'ŝ'),
                    ('ş', 'ş'),
                    ('š', 'š'),
                    ('ţ', 'ţ'),
                    ('ť', 'ť'),
                    ('ŧ', 'ŧ'),
                    ('ũ', 'ũ'),
                    ('ū', 'ū'),
                    ('ŭ', 'ŭ'),
                    ('ů', 'ů'),
                    ('ű', 'ű'),
                    ('ų', 'ų'),
                    ('ŵ', 'ŵ'),
                    ('ŷ', 'ŷ'),
                    ('ź', 'ź'),
                    ('ż', 'ż'),
                    ('ž', 'ƀ'),
                    ('ƃ', 'ƃ'),
                    ('ƅ', 'ƅ'),
                    ('ƈ', 'ƈ'),
                    ('ƌ', 'ƍ'),
                    ('ƒ', 'ƒ'),
                    ('ƕ', 'ƕ'),
                    ('ƙ', 'ƛ'),
                    ('ƞ', 'ƞ'),
                    ('ơ', 'ơ'),
                    ('ƣ', 'ƣ'),
                    ('ƥ', 'ƥ'),
                    ('ƨ', 'ƨ'),
                    ('ƪ', 'ƫ'),
                    ('ƭ', 'ƭ'),
                    ('ư', 'ư'),
                    ('ƴ', 'ƴ'),
                    ('ƶ', 'ƶ'),
                    ('ƹ', 'ƺ'),
                    ('ƽ', 'ƿ'),
                    ('ǆ', 'ǆ'),
                    ('ǉ', 'ǉ'),
                    ('ǌ', 'ǌ'),
                    ('ǎ', 'ǎ'),
                    ('ǐ', 'ǐ'),
                    ('ǒ', 'ǒ'),
                    ('ǔ', 'ǔ'),
                    ('ǖ', 'ǖ'),
                    ('ǘ', 'ǘ'),
                    ('ǚ', 'ǚ'),
                    ('ǜ', 'ǝ'),
                    ('ǟ', 'ǟ'),
                    ('ǡ', 'ǡ'),
                    ('ǣ', 'ǣ'),
                    ('ǥ', 'ǥ'),
                    ('ǧ', 'ǧ'),
                    ('ǩ', 'ǩ'),
                    ('ǫ', 'ǫ'),
                    ('ǭ', 'ǭ'),
                    ('ǯ', 'ǰ'),
                    ('ǳ', 'ǳ'),
                    ('ǵ', 'ǵ'),
                    ('ǹ', 'ǹ'),
                    ('ǻ', 'ǻ'),
                    ('ǽ', 'ǽ'),
                    ('ǿ', 'ǿ'),
                    ('ȁ', 'ȁ'),
                    ('ȃ', 'ȃ'),
                    ('ȅ', 'ȅ'),
                    ('ȇ', 'ȇ'),
                    ('ȉ', 'ȉ'),
                    ('ȋ', 'ȋ'),
                    ('ȍ', 'ȍ'),
                    ('ȏ', 'ȏ'),
                    ('ȑ', 'ȑ'),
                    ('ȓ', 'ȓ'),
                    ('ȕ', 'ȕ'),
                    ('ȗ', 'ȗ'),
                    ('ș', 'ș'),
                    ('ț', 'ț'),
                    ('ȝ', 'ȝ'),
                    ('ȟ', 'ȟ'),
                    ('ȡ', 'ȡ'),
                    ('ȣ', 'ȣ'),
                    ('ȥ', 'ȥ'),
                    ('ȧ', 'ȧ'),
                    ('ȩ', 'ȩ'),
                    ('ȫ', 'ȫ'),
                    ('ȭ', 'ȭ'),
                    ('ȯ', 'ȯ'),
                    ('ȱ', 'ȱ'),
                    ('ȳ', 'ȹ'),
                    ('ȼ', 'ȼ'),
                    ('ȿ', 'ɀ'),
                    ('ɂ', 'ɂ'),
                    ('ɇ', 'ɇ'),
                    ('ɉ', 'ɉ'),
                    ('ɋ', 'ɋ'),
                    ('ɍ', 'ɍ'),
                    ('ɏ', 'ʓ'),
                    ('ʕ', 'ʸ'),
                    ('ˀ', 'ˁ'),
                    ('ˠ', 'ˤ'),
                    ('\u{345}', '\u{345}'),
                    ('ͱ', 'ͱ'),
                    ('ͳ', 'ͳ'),
                    ('ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('ΐ', 'ΐ'),
                    ('ά', 'ώ'),
                    ('ϐ', 'ϑ'),
                    ('ϕ', 'ϗ'),
                    ('ϙ', 'ϙ'),
                    ('ϛ', 'ϛ'),
                    ('ϝ', 'ϝ'),
                    ('ϟ', 'ϟ'),
                    ('ϡ', 'ϡ'),
                    ('ϣ', 'ϣ'),
                    ('ϥ', 'ϥ'),
                    ('ϧ', 'ϧ'),
                    ('ϩ', 'ϩ'),
                    ('ϫ', 'ϫ'),
                    ('ϭ', 'ϭ'),
                    ('ϯ', 'ϳ'),
                    ('ϵ', 'ϵ'),
                    ('ϸ', 'ϸ'),
                    ('ϻ', 'ϼ'),
                    ('а', 'џ'),
                    ('ѡ', 'ѡ'),
                    ('ѣ', 'ѣ'),
                    ('ѥ', 'ѥ'),
                    ('ѧ', 'ѧ'),
                    ('ѩ', 'ѩ'),
                    ('ѫ', 'ѫ'),
                    ('ѭ', 'ѭ'),
                    ('ѯ', 'ѯ'),
                    ('ѱ', 'ѱ'),
                    ('ѳ', 'ѳ'),
                    ('ѵ', 'ѵ'),
                    ('ѷ', 'ѷ'),
                    ('ѹ', 'ѹ'),
                    ('ѻ', 'ѻ'),
                    ('ѽ', 'ѽ'),
                    ('ѿ', 'ѿ'),
                    ('ҁ', 'ҁ'),
                    ('ҋ', 'ҋ'),
                    ('ҍ', 'ҍ'),
                    ('ҏ', 'ҏ'),
                    ('ґ', 'ґ'),
                    ('ғ', 'ғ'),
                    ('ҕ', 'ҕ'),
                    ('җ', 'җ'),
                    ('ҙ', 'ҙ'),
                    ('қ', 'қ'),
                    ('ҝ', 'ҝ'),
                    ('ҟ', 'ҟ'),
                    ('ҡ', 'ҡ'),
                    ('ң', 'ң'),
                    ('ҥ', 'ҥ'),
                    ('ҧ', 'ҧ'),
                    ('ҩ', 'ҩ'),
                    ('ҫ', 'ҫ'),
                    ('ҭ', 'ҭ'),
                    ('ү', 'ү'),
                    ('ұ', 'ұ'),
                    ('ҳ', 'ҳ'),
                    ('ҵ', 'ҵ'),
                    ('ҷ', 'ҷ'),
                    ('ҹ', 'ҹ'),
                    ('һ', 'һ'),
                    ('ҽ', 'ҽ'),
                    ('ҿ', 'ҿ'),
                    ('ӂ', 'ӂ'),
                    ('ӄ', 'ӄ'),
                    ('ӆ', 'ӆ'),
                    ('ӈ', 'ӈ'),
                    ('ӊ', 'ӊ'),
                    ('ӌ', 'ӌ'),
                    ('ӎ', 'ӏ'),
                    ('ӑ', 'ӑ'),
                    ('ӓ', 'ӓ'),
                    ('ӕ', 'ӕ'),
                    ('ӗ', 'ӗ'),
                    ('ә', 'ә'),
                    ('ӛ', 'ӛ'),
                    ('ӝ', 'ӝ'),
                    ('ӟ', 'ӟ'),
                    ('ӡ', 'ӡ'),
                    ('ӣ', 'ӣ'),
                    ('ӥ', 'ӥ'),
                    ('ӧ', 'ӧ'),
                    ('ө', 'ө'),
                    ('ӫ', 'ӫ'),
                    ('ӭ', 'ӭ'),
                    ('ӯ', 'ӯ'),
                    ('ӱ', 'ӱ'),
                    ('ӳ', 'ӳ'),
                    ('ӵ', 'ӵ'),
                    ('ӷ', 'ӷ'),
                    ('ӹ', 'ӹ'),
                    ('ӻ', 'ӻ'),
                    ('ӽ', 'ӽ'),
                    ('ӿ', 'ӿ'),
                    ('ԁ', 'ԁ'),
                    ('ԃ', 'ԃ'),
                    ('ԅ', 'ԅ'),
                    ('ԇ', 'ԇ'),
                    ('ԉ', 'ԉ'),
                    ('ԋ', 'ԋ'),
                    ('ԍ', 'ԍ'),
                    ('ԏ', 'ԏ'),
                    ('ԑ', 'ԑ'),
                    ('ԓ', 'ԓ'),
                    ('ԕ', 'ԕ'),
                    ('ԗ', 'ԗ'),
                    ('ԙ', 'ԙ'),
                    ('ԛ', 'ԛ'),
                    ('ԝ', 'ԝ'),
                    ('ԟ', 'ԟ'),
                    ('ԡ', 'ԡ'),
                    ('ԣ', 'ԣ'),
                    ('ԥ', 'ԥ'),
                    ('ԧ', 'ԧ'),
                    ('ԩ', 'ԩ'),
                    ('ԫ', 'ԫ'),
                    ('ԭ', 'ԭ'),
                    ('ԯ', 'ԯ'),
                    ('ՠ', 'ֈ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ჿ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲈ'),
                    ('ᲊ', 'ᲊ'),
                    ('ᴀ', 'ᶿ'),
                    ('ḁ', 'ḁ'),
                    ('ḃ', 'ḃ'),
                    ('ḅ', 'ḅ'),
                    ('ḇ', 'ḇ'),
                    ('ḉ', 'ḉ'),
                    ('ḋ', 'ḋ'),
                    ('ḍ', 'ḍ'),
                    ('ḏ', 'ḏ'),
                    ('ḑ', 'ḑ'),
                    ('ḓ', 'ḓ'),
                    ('ḕ', 'ḕ'),
                    ('ḗ', 'ḗ'),
                    ('ḙ', 'ḙ'),
                    ('ḛ', 'ḛ'),
                    ('ḝ', 'ḝ'),
                    ('ḟ', 'ḟ'),
                    ('ḡ', 'ḡ'),
                    ('ḣ', 'ḣ'),
                    ('ḥ', 'ḥ'),
                    ('ḧ', 'ḧ'),
                    ('ḩ', 'ḩ'),
                    ('ḫ', 'ḫ'),
                    ('ḭ', 'ḭ'),
                    ('ḯ', 'ḯ'),
                    ('ḱ', 'ḱ'),
                    ('ḳ', 'ḳ'),
                    ('ḵ', 'ḵ'),
                    ('ḷ', 'ḷ'),
                    ('ḹ', 'ḹ'),
                    ('ḻ', 'ḻ'),
                    ('ḽ', 'ḽ'),
                    ('ḿ', 'ḿ'),
                    ('ṁ', 'ṁ'),
                    ('ṃ', 'ṃ'),
                    ('ṅ', 'ṅ'),
                    ('ṇ', 'ṇ'),
                    ('ṉ', 'ṉ'),
                    ('ṋ', 'ṋ'),
                    ('ṍ', 'ṍ'),
                    ('ṏ', 'ṏ'),
                    ('ṑ', 'ṑ'),
                    ('ṓ', 'ṓ'),
                    ('ṕ', 'ṕ'),
                    ('ṗ', 'ṗ'),
                    ('ṙ', 'ṙ'),
                    ('ṛ', 'ṛ'),
                    ('ṝ', 'ṝ'),
                    ('ṟ', 'ṟ'),
                    ('ṡ', 'ṡ'),
                    ('ṣ', 'ṣ'),
                    ('ṥ', 'ṥ'),
                    ('ṧ', 'ṧ'),
                    ('ṩ', 'ṩ'),
                    ('ṫ', 'ṫ'),
                    ('ṭ', 'ṭ'),
                    ('ṯ', 'ṯ'),
                    ('ṱ', 'ṱ'),
                    ('ṳ', 'ṳ'),
                    ('ṵ', 'ṵ'),
                    ('ṷ', 'ṷ'),
                    ('ṹ', 'ṹ'),
                    ('ṻ', 'ṻ'),
                    ('ṽ', 'ṽ'),
                    ('ṿ', 'ṿ'),
                    ('ẁ', 'ẁ'),
                    ('ẃ', 'ẃ'),
                    ('ẅ', 'ẅ'),
                    ('ẇ', 'ẇ'),
                    ('ẉ', 'ẉ'),
                    ('ẋ', 'ẋ'),
                    ('ẍ', 'ẍ'),
                    ('ẏ', 'ẏ'),
                    ('ẑ', 'ẑ'),
                    ('ẓ', 'ẓ'),
                    ('ẕ', 'ẝ'),
                    ('ẟ', 'ẟ'),
                    ('ạ', 'ạ'),
                    ('ả', 'ả'),
                    ('ấ', 'ấ'),
                    ('ầ', 'ầ'),
                    ('ẩ', 'ẩ'),
                    ('ẫ', 'ẫ'),
                    ('ậ', 'ậ'),
                    ('ắ', 'ắ'),
                    ('ằ', 'ằ'),
                    ('ẳ', 'ẳ'),
                    ('ẵ', 'ẵ'),
                    ('ặ', 'ặ'),
                    ('ẹ', 'ẹ'),
                    ('ẻ', 'ẻ'),
                    ('ẽ', 'ẽ'),
                    ('ế', 'ế'),
                    ('ề', 'ề'),
                    ('ể', 'ể'),
                    ('ễ', 'ễ'),
                    ('ệ', 'ệ'),
                    ('ỉ', 'ỉ'),
                    ('ị', 'ị'),
                    ('ọ', 'ọ'),
                    ('ỏ', 'ỏ'),
                    ('ố', 'ố'),
                    ('ồ', 'ồ'),
                    ('ổ', 'ổ'),
                    ('ỗ', 'ỗ'),
                    ('ộ', 'ộ'),
                    ('ớ', 'ớ'),
                    ('ờ', 'ờ'),
                    ('ở', 'ở'),
                    ('ỡ', 'ỡ'),
                    ('ợ', 'ợ'),
                    ('ụ', 'ụ'),
                    ('ủ', 'ủ'),
                    ('ứ', 'ứ'),
                    ('ừ', 'ừ'),
                    ('ử', 'ử'),
                    ('ữ', 'ữ'),
                    ('ự', 'ự'),
                    ('ỳ', 'ỳ'),
                    ('ỵ', 'ỵ'),
                    ('ỷ', 'ỷ'),
                    ('ỹ', 'ỹ'),
                    ('ỻ', 'ỻ'),
                    ('ỽ', 'ỽ'),
                    ('ỿ', 'ἇ'),
                    ('ἐ', 'ἕ'),
                    ('ἠ', 'ἧ'),
                    ('ἰ', 'ἷ'),
                    ('ὀ', 'ὅ'),
                    ('ὐ', 'ὗ'),
                    ('ὠ', 'ὧ'),
                    ('ὰ', 'ώ'),
                    ('ᾀ', 'ᾇ'),
                    ('ᾐ', 'ᾗ'),
                    ('ᾠ', 'ᾧ'),
                    ('ᾰ', 'ᾴ'),
                    ('ᾶ', 'ᾷ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῇ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'ῗ'),
                    ('ῠ', 'ῧ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῷ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℊ', 'ℊ'),
                    ('ℎ', 'ℏ'),
                    ('ℓ', 'ℓ'),
                    ('ℯ', 'ℯ'),
                    ('ℴ', 'ℴ'),
                    ('ℹ', 'ℹ'),
                    ('ℼ', 'ℽ'),
                    ('ⅆ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('ⅰ', 'ⅿ'),
                    ('ↄ', 'ↄ'),
                    ('ⓐ', 'ⓩ'),
                    ('ⰰ', 'ⱟ'),
                    ('ⱡ', 'ⱡ'),
                    ('ⱥ', 'ⱦ'),
                    ('ⱨ', 'ⱨ'),
                    ('ⱪ', 'ⱪ'),
                    ('ⱬ', 'ⱬ'),
                    ('ⱱ', 'ⱱ'),
                    ('ⱳ', 'ⱴ'),
                    ('ⱶ', 'ⱽ'),
                    ('ⲁ', 'ⲁ'),
                    ('ⲃ', 'ⲃ'),
                    ('ⲅ', 'ⲅ'),
                    ('ⲇ', 'ⲇ'),
                    ('ⲉ', 'ⲉ'),
                    ('ⲋ', 'ⲋ'),
                    ('ⲍ', 'ⲍ'),
                    ('ⲏ', 'ⲏ'),
                    ('ⲑ', 'ⲑ'),
                    ('ⲓ', 'ⲓ'),
                    ('ⲕ', 'ⲕ'),
                    ('ⲗ', 'ⲗ'),
                    ('ⲙ', 'ⲙ'),
                    ('ⲛ', 'ⲛ'),
                    ('ⲝ', 'ⲝ'),
                    ('ⲟ', 'ⲟ'),
                    ('ⲡ', 'ⲡ'),
                    ('ⲣ', 'ⲣ'),
                    ('ⲥ', 'ⲥ'),
                    ('ⲧ', 'ⲧ'),
                    ('ⲩ', 'ⲩ'),
                    ('ⲫ', 'ⲫ'),
                    ('ⲭ', 'ⲭ'),
                    ('ⲯ', 'ⲯ'),
                    ('ⲱ', 'ⲱ'),
                    ('ⲳ', 'ⲳ'),
                    ('ⲵ', 'ⲵ'),
                    ('ⲷ', 'ⲷ'),
                    ('ⲹ', 'ⲹ'),
                    ('ⲻ', 'ⲻ'),
                    ('ⲽ', 'ⲽ'),
                    ('ⲿ', 'ⲿ'),
                    ('ⳁ', 'ⳁ'),
                    ('ⳃ', 'ⳃ'),
                    ('ⳅ', 'ⳅ'),
                    ('ⳇ', 'ⳇ'),
                    ('ⳉ', 'ⳉ'),
                    ('ⳋ', 'ⳋ'),
                    ('ⳍ', 'ⳍ'),
                    ('ⳏ', 'ⳏ'),
                    ('ⳑ', 'ⳑ'),
                    ('ⳓ', 'ⳓ'),
                    ('ⳕ', 'ⳕ'),
                    ('ⳗ', 'ⳗ'),
                    ('ⳙ', 'ⳙ'),
                    ('ⳛ', 'ⳛ'),
                    ('ⳝ', 'ⳝ'),
                    ('ⳟ', 'ⳟ'),
                    ('ⳡ', 'ⳡ'),
                    ('ⳣ', 'ⳤ'),
                    ('ⳬ', 'ⳬ'),
                    ('ⳮ', 'ⳮ'),
                    ('ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ꙁ', 'ꙁ'),
                    ('ꙃ', 'ꙃ'),
                    ('ꙅ', 'ꙅ'),
                    ('ꙇ', 'ꙇ'),
                    ('ꙉ', 'ꙉ'),
                    ('ꙋ', 'ꙋ'),
                    ('ꙍ', 'ꙍ'),
                    ('ꙏ', 'ꙏ'),
                    ('ꙑ', 'ꙑ'),
                    ('ꙓ', 'ꙓ'),
                    ('ꙕ', 'ꙕ'),
                    ('ꙗ', 'ꙗ'),
                    ('ꙙ', 'ꙙ'),
                    ('ꙛ', 'ꙛ'),
                    ('ꙝ', 'ꙝ'),
                    ('ꙟ', 'ꙟ'),
                    ('ꙡ', 'ꙡ'),
                    ('ꙣ', 'ꙣ'),
                    ('ꙥ', 'ꙥ'),
                    ('ꙧ', 'ꙧ'),
                    ('ꙩ', 'ꙩ'),
                    ('ꙫ', 'ꙫ'),
                    ('ꙭ', 'ꙭ'),
                    ('ꚁ', 'ꚁ'),
                    ('ꚃ', 'ꚃ'),
                    ('ꚅ', 'ꚅ'),
                    ('ꚇ', 'ꚇ'),
                    ('ꚉ', 'ꚉ'),
                    ('ꚋ', 'ꚋ'),
                    ('ꚍ', 'ꚍ'),
                    ('ꚏ', 'ꚏ'),
                    ('ꚑ', 'ꚑ'),
                    ('ꚓ', 'ꚓ'),
                    ('ꚕ', 'ꚕ'),
                    ('ꚗ', 'ꚗ'),
                    ('ꚙ', 'ꚙ'),
                    ('ꚛ', 'ꚝ'),
                    ('ꜣ', 'ꜣ'),
                    ('ꜥ', 'ꜥ'),
                    ('ꜧ', 'ꜧ'),
                    ('ꜩ', 'ꜩ'),
                    ('ꜫ', 'ꜫ'),
                    ('ꜭ', 'ꜭ'),
                    ('ꜯ', 'ꜱ'),
                    ('ꜳ', 'ꜳ'),
                    ('ꜵ', 'ꜵ'),
                    ('ꜷ', 'ꜷ'),
                    ('ꜹ', 'ꜹ'),
                    ('ꜻ', 'ꜻ'),
                    ('ꜽ', 'ꜽ'),
                    ('ꜿ', 'ꜿ'),
                    ('ꝁ', 'ꝁ'),
                    ('ꝃ', 'ꝃ'),
                    ('ꝅ', 'ꝅ'),
                    ('ꝇ', 'ꝇ'),
                    ('ꝉ', 'ꝉ'),
                    ('ꝋ', 'ꝋ'),
                    ('ꝍ', 'ꝍ'),
                    ('ꝏ', 'ꝏ'),
                    ('ꝑ', 'ꝑ'),
                    ('ꝓ', 'ꝓ'),
                    ('ꝕ', 'ꝕ'),
                    ('ꝗ', 'ꝗ'),
                    ('ꝙ', 'ꝙ'),
                    ('ꝛ', 'ꝛ'),
                    ('ꝝ', 'ꝝ'),
                    ('ꝟ', 'ꝟ'),
                    ('ꝡ', 'ꝡ'),
                    ('ꝣ', 'ꝣ'),
                    ('ꝥ', 'ꝥ'),
                    ('ꝧ', 'ꝧ'),
                    ('ꝩ', 'ꝩ'),
                    ('ꝫ', 'ꝫ'),
                    ('ꝭ', 'ꝭ'),
                    ('ꝯ', 'ꝸ'),
                    ('ꝺ', 'ꝺ'),
                    ('ꝼ', 'ꝼ'),
                    ('ꝿ', 'ꝿ'),
                    ('ꞁ', 'ꞁ'),
                    ('ꞃ', 'ꞃ'),
                    ('ꞅ', 'ꞅ'),
                    ('ꞇ', 'ꞇ'),
                    ('ꞌ', 'ꞌ'),
                    ('ꞎ', 'ꞎ'),
                    ('ꞑ', 'ꞑ'),
                    ('ꞓ', 'ꞕ'),
                    ('ꞗ', 'ꞗ'),
                    ('ꞙ', 'ꞙ'),
                    ('ꞛ', 'ꞛ'),
                    ('ꞝ', 'ꞝ'),
                    ('ꞟ', 'ꞟ'),
                    ('ꞡ', 'ꞡ'),
                    ('ꞣ', 'ꞣ'),
                    ('ꞥ', 'ꞥ'),
                    ('ꞧ', 'ꞧ'),
                    ('ꞩ', 'ꞩ'),
                    ('ꞯ', 'ꞯ'),
                    ('ꞵ', 'ꞵ'),
                    ('ꞷ', 'ꞷ'),
                    ('ꞹ', 'ꞹ'),
                    ('ꞻ', 'ꞻ'),
                    ('ꞽ', 'ꞽ'),
                    ('ꞿ', 'ꞿ'),
                    ('ꟁ', 'ꟁ'),
                    ('ꟃ', 'ꟃ'),
                    ('ꟈ', 'ꟈ'),
                    ('ꟊ', 'ꟊ'),
                    ('ꟍ', 'ꟍ'),
                    ('ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'ꟕ'),
                    ('ꟗ', 'ꟗ'),
                    ('ꟙ', 'ꟙ'),
                    ('ꟛ', 'ꟛ'),
                    ('ꟲ', 'ꟴ'),
                    ('ꟶ', 'ꟶ'),
                    ('ꟸ', 'ꟺ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('ａ', 'ｚ'),
                    ('𐐨', '𐑏'),
                    ('𐓘', '𐓻'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐞀', '𐞀'),
                    ('𐞃', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐳀', '𐳲'),
                    ('𐵰', '𐶅'),
                    ('𑣀', '𑣟'),
                    ('𖹠', '𖹿'),
                    ('𝐚', '𝐳'),
                    ('𝑎', '𝑔'),
                    ('𝑖', '𝑧'),
                    ('𝒂', '𝒛'),
                    ('𝒶', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝓏'),
                    ('𝓪', '𝔃'),
                    ('𝔞', '𝔷'),
                    ('𝕒', '𝕫'),
                    ('𝖆', '𝖟'),
                    ('𝖺', '𝗓'),
                    ('𝗮', '𝘇'),
                    ('𝘢', '𝘻'),
                    ('𝙖', '𝙯'),
                    ('𝚊', '𝚥'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛡'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜛'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝕'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞏'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟉'),
                    ('𝟋', '𝟋'),
                    ('𝼀', '𝼉'),
                    ('𝼋', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞤢', '𞥃'),
                ];

                pub const MATH: &'static [(char, char)] = &[
                    ('+', '+'),
                    ('<', '>'),
                    ('^', '^'),
                    ('|', '|'),
                    ('~', '~'),
                    ('¬', '¬'),
                    ('±', '±'),
                    ('×', '×'),
                    ('÷', '÷'),
                    ('ϐ', 'ϒ'),
                    ('ϕ', 'ϕ'),
                    ('ϰ', 'ϱ'),
                    ('ϴ', '϶'),
                    ('؆', '؈'),
                    ('‖', '‖'),
                    ('′', '‴'),
                    ('⁀', '⁀'),
                    ('⁄', '⁄'),
                    ('⁒', '⁒'),
                    ('\u{2061}', '\u{2064}'),
                    ('⁺', '⁾'),
                    ('₊', '₎'),
                    ('\u{20d0}', '\u{20dc}'),
                    ('\u{20e1}', '\u{20e1}'),
                    ('\u{20e5}', '\u{20e6}'),
                    ('\u{20eb}', '\u{20ef}'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('℘', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('ℨ', '℩'),
                    ('ℬ', 'ℭ'),
                    ('ℯ', 'ℱ'),
                    ('ℳ', 'ℸ'),
                    ('ℼ', 'ⅉ'),
                    ('⅋', '⅋'),
                    ('←', '↧'),
                    ('↩', '↮'),
                    ('↰', '↱'),
                    ('↶', '↷'),
                    ('↼', '⇛'),
                    ('⇝', '⇝'),
                    ('⇤', '⇥'),
                    ('⇴', '⋿'),
                    ('⌈', '⌋'),
                    ('⌠', '⌡'),
                    ('⍼', '⍼'),
                    ('⎛', '⎵'),
                    ('⎷', '⎷'),
                    ('⏐', '⏐'),
                    ('⏜', '⏢'),
                    ('■', '□'),
                    ('▮', '▷'),
                    ('▼', '◁'),
                    ('◆', '◇'),
                    ('◊', '○'),
                    ('●', '◓'),
                    ('◢', '◢'),
                    ('◤', '◤'),
                    ('◧', '◬'),
                    ('◸', '◿'),
                    ('★', '☆'),
                    ('♀', '♀'),
                    ('♂', '♂'),
                    ('♠', '♣'),
                    ('♭', '♯'),
                    ('⟀', '⟿'),
                    ('⤀', '⫿'),
                    ('⬰', '⭄'),
                    ('⭇', '⭌'),
                    ('﬩', '﬩'),
                    ('﹡', '﹦'),
                    ('﹨', '﹨'),
                    ('＋', '＋'),
                    ('＜', '＞'),
                    ('＼', '＼'),
                    ('＾', '＾'),
                    ('｜', '｜'),
                    ('～', '～'),
                    ('￢', '￢'),
                    ('￩', '￬'),
                    ('𐶎', '𐶏'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𞻰', '𞻱'),
                ];

                pub const MODIFIER_COMBINING_MARK: &'static [(char, char)] = &[
                    ('\u{654}', '\u{655}'),
                    ('\u{658}', '\u{658}'),
                    ('\u{6dc}', '\u{6dc}'),
                    ('\u{6e3}', '\u{6e3}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{8ca}', '\u{8cb}'),
                    ('\u{8cd}', '\u{8cf}'),
                    ('\u{8d3}', '\u{8d3}'),
                    ('\u{8f3}', '\u{8f3}'),
                ];

                pub const NONCHARACTER_CODE_POINT: &'static [(char, char)] = &[
                    ('\u{fdd0}', '\u{fdef}'),
                    ('\u{fffe}', '\u{ffff}'),
                    ('\u{1fffe}', '\u{1ffff}'),
                    ('\u{2fffe}', '\u{2ffff}'),
                    ('\u{3fffe}', '\u{3ffff}'),
                    ('\u{4fffe}', '\u{4ffff}'),
                    ('\u{5fffe}', '\u{5ffff}'),
                    ('\u{6fffe}', '\u{6ffff}'),
                    ('\u{7fffe}', '\u{7ffff}'),
                    ('\u{8fffe}', '\u{8ffff}'),
                    ('\u{9fffe}', '\u{9ffff}'),
                    ('\u{afffe}', '\u{affff}'),
                    ('\u{bfffe}', '\u{bffff}'),
                    ('\u{cfffe}', '\u{cffff}'),
                    ('\u{dfffe}', '\u{dffff}'),
                    ('\u{efffe}', '\u{effff}'),
                    ('\u{ffffe}', '\u{fffff}'),
                    ('\u{10fffe}', '\u{10ffff}'),
                ];

                pub const OTHER_ALPHABETIC: &'static [(char, char)] = &[
                    ('\u{345}', '\u{345}'),
                    ('\u{363}', '\u{36f}'),
                    ('\u{5b0}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{657}'),
                    ('\u{659}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6e1}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ed}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{73f}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{816}', '\u{817}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82c}'),
                    ('\u{897}', '\u{897}'),
                    ('\u{8d4}', '\u{8df}'),
                    ('\u{8e3}', '\u{8e9}'),
                    ('\u{8f0}', 'ः'),
                    ('\u{93a}', 'ऻ'),
                    ('ा', 'ौ'),
                    ('ॎ', 'ॏ'),
                    ('\u{955}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', 'ঃ'),
                    ('\u{9be}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৌ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{a01}', 'ਃ'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4c}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('ા', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', 'ૌ'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{afc}'),
                    ('\u{b01}', 'ଃ'),
                    ('\u{b3e}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', 'ୌ'),
                    ('\u{b56}', '\u{b57}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', 'ௌ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c04}'),
                    ('\u{c3e}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4c}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', 'ಃ'),
                    ('ಾ', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccc}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('ೳ', 'ೳ'),
                    ('\u{d00}', 'ഃ'),
                    ('\u{d3e}', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൌ'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', 'ඃ'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', 'ෳ'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e4d}', '\u{e4d}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{eb9}'),
                    ('\u{ebb}', '\u{ebc}'),
                    ('\u{ecd}', '\u{ecd}'),
                    ('\u{f71}', '\u{f83}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('ါ', '\u{1036}'),
                    ('း', 'း'),
                    ('ျ', '\u{103e}'),
                    ('ၖ', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('ၢ', 'ၤ'),
                    ('ၧ', 'ၭ'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{108d}'),
                    ('ႏ', 'ႏ'),
                    ('ႚ', '\u{109d}'),
                    ('\u{1712}', '\u{1713}'),
                    ('\u{1732}', '\u{1733}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('ា', 'ៈ'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', 'ᤸ'),
                    ('\u{1a17}', '\u{1a1b}'),
                    ('ᩕ', '\u{1a5e}'),
                    ('ᩡ', '\u{1a74}'),
                    ('\u{1abf}', '\u{1ac0}'),
                    ('\u{1acc}', '\u{1ace}'),
                    ('\u{1b00}', 'ᬄ'),
                    ('\u{1b35}', '\u{1b43}'),
                    ('\u{1b80}', 'ᮂ'),
                    ('ᮡ', '\u{1ba9}'),
                    ('\u{1bac}', '\u{1bad}'),
                    ('ᯧ', '\u{1bf1}'),
                    ('ᰤ', '\u{1c36}'),
                    ('\u{1dd3}', '\u{1df4}'),
                    ('Ⓐ', 'ⓩ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{a674}', '\u{a67b}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('ꠣ', 'ꠧ'),
                    ('ꢀ', 'ꢁ'),
                    ('ꢴ', 'ꣃ'),
                    ('\u{a8c5}', '\u{a8c5}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92a}'),
                    ('\u{a947}', 'ꥒ'),
                    ('\u{a980}', 'ꦃ'),
                    ('ꦴ', 'ꦿ'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', 'ꩍ'),
                    ('ꩻ', 'ꩽ'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabe}'),
                    ('ꫫ', 'ꫯ'),
                    ('ꫵ', 'ꫵ'),
                    ('ꯣ', 'ꯪ'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d69}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10efc}'),
                    ('𑀀', '𑀂'),
                    ('\u{11038}', '\u{11045}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{11080}', '𑂂'),
                    ('𑂰', '𑂸'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{11132}'),
                    ('𑅅', '𑅆'),
                    ('\u{11180}', '𑆂'),
                    ('𑆳', '𑆿'),
                    ('𑇎', '\u{111cf}'),
                    ('𑈬', '\u{11234}'),
                    ('\u{11237}', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112e8}'),
                    ('\u{11300}', '𑌃'),
                    ('\u{1133e}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '𑍌'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍢', '𑍣'),
                    ('\u{113b8}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏍'),
                    ('𑐵', '𑑁'),
                    ('\u{11443}', '𑑅'),
                    ('\u{114b0}', '𑓁'),
                    ('\u{115af}', '\u{115b5}'),
                    ('𑖸', '𑖾'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('𑘰', '𑘾'),
                    ('\u{11640}', '\u{11640}'),
                    ('\u{116ab}', '\u{116b5}'),
                    ('\u{1171d}', '\u{1172a}'),
                    ('𑠬', '𑠸'),
                    ('\u{11930}', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{1193c}'),
                    ('𑥀', '𑥀'),
                    ('𑥂', '𑥂'),
                    ('𑧑', '\u{119d7}'),
                    ('\u{119da}', '𑧟'),
                    ('𑧤', '𑧤'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a35}', '𑨹'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a51}', '\u{11a5b}'),
                    ('\u{11a8a}', '𑪗'),
                    ('𑰯', '\u{11c36}'),
                    ('\u{11c38}', '𑰾'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d41}'),
                    ('\u{11d43}', '\u{11d43}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('𑶊', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶖'),
                    ('\u{11ef3}', '𑻶'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('𑼃', '𑼃'),
                    ('𑼴', '\u{11f3a}'),
                    ('𑼾', '\u{11f40}'),
                    ('\u{1611e}', '\u{1612e}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('𖽑', '𖾇'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9e}', '\u{1bc9e}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e947}', '\u{1e947}'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                ];

                pub const OTHER_DEFAULT_IGNORABLE_CODE_POINT: &'static [(char, char)] = &[
                    ('\u{34f}', '\u{34f}'),
                    ('ᅟ', 'ᅠ'),
                    ('\u{17b4}', '\u{17b5}'),
                    ('\u{2065}', '\u{2065}'),
                    ('ㅤ', 'ㅤ'),
                    ('ﾠ', 'ﾠ'),
                    ('\u{fff0}', '\u{fff8}'),
                    ('\u{e0000}', '\u{e0000}'),
                    ('\u{e0002}', '\u{e001f}'),
                    ('\u{e0080}', '\u{e00ff}'),
                    ('\u{e01f0}', '\u{e0fff}'),
                ];

                pub const OTHER_GRAPHEME_EXTEND: &'static [(char, char)] = &[
                    ('\u{9be}', '\u{9be}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{b3e}', '\u{b3e}'),
                    ('\u{b57}', '\u{b57}'),
                    ('\u{bbe}', '\u{bbe}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{cc0}', '\u{cc0}'),
                    ('\u{cc2}', '\u{cc2}'),
                    ('\u{cc7}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccb}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{d3e}', '\u{d3e}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{dcf}', '\u{dcf}'),
                    ('\u{ddf}', '\u{ddf}'),
                    ('\u{1715}', '\u{1715}'),
                    ('\u{1734}', '\u{1734}'),
                    ('\u{1b35}', '\u{1b35}'),
                    ('\u{1b3b}', '\u{1b3b}'),
                    ('\u{1b3d}', '\u{1b3d}'),
                    ('\u{1b43}', '\u{1b44}'),
                    ('\u{1baa}', '\u{1baa}'),
                    ('\u{1bf2}', '\u{1bf3}'),
                    ('\u{200c}', '\u{200c}'),
                    ('\u{302e}', '\u{302f}'),
                    ('\u{a953}', '\u{a953}'),
                    ('\u{a9c0}', '\u{a9c0}'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('\u{111c0}', '\u{111c0}'),
                    ('\u{11235}', '\u{11235}'),
                    ('\u{1133e}', '\u{1133e}'),
                    ('\u{1134d}', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('\u{113b8}', '\u{113b8}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '\u{113c9}'),
                    ('\u{113cf}', '\u{113cf}'),
                    ('\u{114b0}', '\u{114b0}'),
                    ('\u{114bd}', '\u{114bd}'),
                    ('\u{115af}', '\u{115af}'),
                    ('\u{116b6}', '\u{116b6}'),
                    ('\u{11930}', '\u{11930}'),
                    ('\u{1193d}', '\u{1193d}'),
                    ('\u{11f41}', '\u{11f41}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1d165}', '\u{1d166}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{e0020}', '\u{e007f}'),
                ];

                pub const OTHER_ID_CONTINUE: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('·', '·'),
                    ('፩', '፱'),
                    ('᧚', '᧚'),
                    ('\u{200c}', '\u{200d}'),
                    ('・', '・'),
                    ('･', '･'),
                ];

                pub const OTHER_ID_START: &'static [(char, char)] =
                    &[('\u{1885}', '\u{1886}'), ('℘', '℘'), ('℮', '℮'), ('゛', '゜')];

                pub const OTHER_LOWERCASE: &'static [(char, char)] = &[
                    ('ª', 'ª'),
                    ('º', 'º'),
                    ('ʰ', 'ʸ'),
                    ('ˀ', 'ˁ'),
                    ('ˠ', 'ˤ'),
                    ('\u{345}', '\u{345}'),
                    ('ͺ', 'ͺ'),
                    ('ჼ', 'ჼ'),
                    ('ᴬ', 'ᵪ'),
                    ('ᵸ', 'ᵸ'),
                    ('ᶛ', 'ᶿ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ⅰ', 'ⅿ'),
                    ('ⓐ', 'ⓩ'),
                    ('ⱼ', 'ⱽ'),
                    ('ꚜ', 'ꚝ'),
                    ('ꝰ', 'ꝰ'),
                    ('ꟲ', 'ꟴ'),
                    ('ꟸ', 'ꟹ'),
                    ('ꭜ', 'ꭟ'),
                    ('ꭩ', 'ꭩ'),
                    ('𐞀', '𐞀'),
                    ('𐞃', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𞀰', '𞁭'),
                ];

                pub const OTHER_MATH: &'static [(char, char)] = &[
                    ('^', '^'),
                    ('ϐ', 'ϒ'),
                    ('ϕ', 'ϕ'),
                    ('ϰ', 'ϱ'),
                    ('ϴ', 'ϵ'),
                    ('‖', '‖'),
                    ('′', '‴'),
                    ('⁀', '⁀'),
                    ('\u{2061}', '\u{2064}'),
                    ('⁽', '⁾'),
                    ('₍', '₎'),
                    ('\u{20d0}', '\u{20dc}'),
                    ('\u{20e1}', '\u{20e1}'),
                    ('\u{20e5}', '\u{20e6}'),
                    ('\u{20eb}', '\u{20ef}'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('ℨ', '℩'),
                    ('ℬ', 'ℭ'),
                    ('ℯ', 'ℱ'),
                    ('ℳ', 'ℸ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('↕', '↙'),
                    ('↜', '↟'),
                    ('↡', '↢'),
                    ('↤', '↥'),
                    ('↧', '↧'),
                    ('↩', '↭'),
                    ('↰', '↱'),
                    ('↶', '↷'),
                    ('↼', '⇍'),
                    ('⇐', '⇑'),
                    ('⇓', '⇓'),
                    ('⇕', '⇛'),
                    ('⇝', '⇝'),
                    ('⇤', '⇥'),
                    ('⌈', '⌋'),
                    ('⎴', '⎵'),
                    ('⎷', '⎷'),
                    ('⏐', '⏐'),
                    ('⏢', '⏢'),
                    ('■', '□'),
                    ('▮', '▶'),
                    ('▼', '◀'),
                    ('◆', '◇'),
                    ('◊', '○'),
                    ('●', '◓'),
                    ('◢', '◢'),
                    ('◤', '◤'),
                    ('◧', '◬'),
                    ('★', '☆'),
                    ('♀', '♀'),
                    ('♂', '♂'),
                    ('♠', '♣'),
                    ('♭', '♮'),
                    ('⟅', '⟆'),
                    ('⟦', '⟯'),
                    ('⦃', '⦘'),
                    ('⧘', '⧛'),
                    ('⧼', '⧽'),
                    ('﹡', '﹡'),
                    ('﹣', '﹣'),
                    ('﹨', '﹨'),
                    ('＼', '＼'),
                    ('＾', '＾'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                ];

                pub const OTHER_UPPERCASE: &'static [(char, char)] =
                    &[('Ⅰ', 'Ⅿ'), ('Ⓐ', 'Ⓩ'), ('🄰', '🅉'), ('🅐', '🅩'), ('🅰', '🆉')];

                pub const PATTERN_SYNTAX: &'static [(char, char)] = &[
                    ('!', '/'),
                    (':', '@'),
                    ('[', '^'),
                    ('`', '`'),
                    ('{', '~'),
                    ('¡', '§'),
                    ('©', '©'),
                    ('«', '¬'),
                    ('®', '®'),
                    ('°', '±'),
                    ('¶', '¶'),
                    ('»', '»'),
                    ('¿', '¿'),
                    ('×', '×'),
                    ('÷', '÷'),
                    ('‐', '‧'),
                    ('‰', '‾'),
                    ('⁁', '⁓'),
                    ('⁕', '⁞'),
                    ('←', '\u{245f}'),
                    ('─', '❵'),
                    ('➔', '⯿'),
                    ('⸀', '\u{2e7f}'),
                    ('、', '〃'),
                    ('〈', '〠'),
                    ('〰', '〰'),
                    ('﴾', '﴿'),
                    ('﹅', '﹆'),
                ];

                pub const PATTERN_WHITE_SPACE: &'static [(char, char)] = &[
                    ('\t', '\r'),
                    (' ', ' '),
                    ('\u{85}', '\u{85}'),
                    ('\u{200e}', '\u{200f}'),
                    ('\u{2028}', '\u{2029}'),
                ];

                pub const PREPENDED_CONCATENATION_MARK: &'static [(char, char)] = &[
                    ('\u{600}', '\u{605}'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('\u{70f}', '\u{70f}'),
                    ('\u{890}', '\u{891}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110cd}', '\u{110cd}'),
                ];

                pub const QUOTATION_MARK: &'static [(char, char)] = &[
                    ('"', '"'),
                    ('\'', '\''),
                    ('«', '«'),
                    ('»', '»'),
                    ('‘', '‟'),
                    ('‹', '›'),
                    ('⹂', '⹂'),
                    ('「', '』'),
                    ('〝', '〟'),
                    ('﹁', '﹄'),
                    ('＂', '＂'),
                    ('＇', '＇'),
                    ('｢', '｣'),
                ];

                pub const RADICAL: &'static [(char, char)] =
                    &[('⺀', '⺙'), ('⺛', '⻳'), ('⼀', '⿕')];

                pub const REGIONAL_INDICATOR: &'static [(char, char)] = &[('🇦', '🇿')];

                pub const SENTENCE_TERMINAL: &'static [(char, char)] = &[
                    ('!', '!'),
                    ('.', '.'),
                    ('?', '?'),
                    ('։', '։'),
                    ('؝', '؟'),
                    ('۔', '۔'),
                    ('܀', '܂'),
                    ('߹', '߹'),
                    ('࠷', '࠷'),
                    ('࠹', '࠹'),
                    ('࠽', '࠾'),
                    ('।', '॥'),
                    ('၊', '။'),
                    ('።', '።'),
                    ('፧', '፨'),
                    ('᙮', '᙮'),
                    ('᜵', '᜶'),
                    ('។', '៕'),
                    ('᠃', '᠃'),
                    ('᠉', '᠉'),
                    ('᥄', '᥅'),
                    ('᪨', '᪫'),
                    ('᭎', '᭏'),
                    ('᭚', '᭛'),
                    ('᭞', '᭟'),
                    ('᭽', '᭿'),
                    ('᰻', '᰼'),
                    ('᱾', '᱿'),
                    ('․', '․'),
                    ('‼', '‽'),
                    ('⁇', '⁉'),
                    ('⳹', '⳻'),
                    ('⸮', '⸮'),
                    ('⸼', '⸼'),
                    ('⹓', '⹔'),
                    ('。', '。'),
                    ('꓿', '꓿'),
                    ('꘎', '꘏'),
                    ('꛳', '꛳'),
                    ('꛷', '꛷'),
                    ('꡶', '꡷'),
                    ('꣎', '꣏'),
                    ('꤯', '꤯'),
                    ('꧈', '꧉'),
                    ('꩝', '꩟'),
                    ('꫰', '꫱'),
                    ('꯫', '꯫'),
                    ('︒', '︒'),
                    ('︕', '︖'),
                    ('﹒', '﹒'),
                    ('﹖', '﹗'),
                    ('！', '！'),
                    ('．', '．'),
                    ('？', '？'),
                    ('｡', '｡'),
                    ('𐩖', '𐩗'),
                    ('𐽕', '𐽙'),
                    ('𐾆', '𐾉'),
                    ('𑁇', '𑁈'),
                    ('𑂾', '𑃁'),
                    ('𑅁', '𑅃'),
                    ('𑇅', '𑇆'),
                    ('𑇍', '𑇍'),
                    ('𑇞', '𑇟'),
                    ('𑈸', '𑈹'),
                    ('𑈻', '𑈼'),
                    ('𑊩', '𑊩'),
                    ('𑏔', '𑏕'),
                    ('𑑋', '𑑌'),
                    ('𑗂', '𑗃'),
                    ('𑗉', '𑗗'),
                    ('𑙁', '𑙂'),
                    ('𑜼', '𑜾'),
                    ('𑥄', '𑥄'),
                    ('𑥆', '𑥆'),
                    ('𑩂', '𑩃'),
                    ('𑪛', '𑪜'),
                    ('𑱁', '𑱂'),
                    ('𑻷', '𑻸'),
                    ('𑽃', '𑽄'),
                    ('𖩮', '𖩯'),
                    ('𖫵', '𖫵'),
                    ('𖬷', '𖬸'),
                    ('𖭄', '𖭄'),
                    ('𖵮', '𖵯'),
                    ('𖺘', '𖺘'),
                    ('𛲟', '𛲟'),
                    ('𝪈', '𝪈'),
                ];

                pub const SOFT_DOTTED: &'static [(char, char)] = &[
                    ('i', 'j'),
                    ('į', 'į'),
                    ('ɉ', 'ɉ'),
                    ('ɨ', 'ɨ'),
                    ('ʝ', 'ʝ'),
                    ('ʲ', 'ʲ'),
                    ('ϳ', 'ϳ'),
                    ('і', 'і'),
                    ('ј', 'ј'),
                    ('ᵢ', 'ᵢ'),
                    ('ᶖ', 'ᶖ'),
                    ('ᶤ', 'ᶤ'),
                    ('ᶨ', 'ᶨ'),
                    ('ḭ', 'ḭ'),
                    ('ị', 'ị'),
                    ('ⁱ', 'ⁱ'),
                    ('ⅈ', 'ⅉ'),
                    ('ⱼ', 'ⱼ'),
                    ('𝐢', '𝐣'),
                    ('𝑖', '𝑗'),
                    ('𝒊', '𝒋'),
                    ('𝒾', '𝒿'),
                    ('𝓲', '𝓳'),
                    ('𝔦', '𝔧'),
                    ('𝕚', '𝕛'),
                    ('𝖎', '𝖏'),
                    ('𝗂', '𝗃'),
                    ('𝗶', '𝗷'),
                    ('𝘪', '𝘫'),
                    ('𝙞', '𝙟'),
                    ('𝚒', '𝚓'),
                    ('𝼚', '𝼚'),
                    ('𞁌', '𞁍'),
                    ('𞁨', '𞁨'),
                ];

                pub const TERMINAL_PUNCTUATION: &'static [(char, char)] = &[
                    ('!', '!'),
                    (',', ','),
                    ('.', '.'),
                    (':', ';'),
                    ('?', '?'),
                    (';', ';'),
                    ('·', '·'),
                    ('։', '։'),
                    ('׃', '׃'),
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؝', '؟'),
                    ('۔', '۔'),
                    ('܀', '܊'),
                    ('܌', '܌'),
                    ('߸', '߹'),
                    ('࠰', '࠵'),
                    ('࠷', '࠾'),
                    ('࡞', '࡞'),
                    ('।', '॥'),
                    ('๚', '๛'),
                    ('༈', '༈'),
                    ('།', '༒'),
                    ('၊', '။'),
                    ('፡', '፨'),
                    ('᙮', '᙮'),
                    ('᛫', '᛭'),
                    ('᜵', '᜶'),
                    ('។', '៖'),
                    ('៚', '៚'),
                    ('᠂', '᠅'),
                    ('᠈', '᠉'),
                    ('᥄', '᥅'),
                    ('᪨', '᪫'),
                    ('᭎', '᭏'),
                    ('᭚', '᭛'),
                    ('᭝', '᭟'),
                    ('᭽', '᭿'),
                    ('᰻', '᰿'),
                    ('᱾', '᱿'),
                    ('․', '․'),
                    ('‼', '‽'),
                    ('⁇', '⁉'),
                    ('⳹', '⳻'),
                    ('⸮', '⸮'),
                    ('⸼', '⸼'),
                    ('⹁', '⹁'),
                    ('⹌', '⹌'),
                    ('⹎', '⹏'),
                    ('⹓', '⹔'),
                    ('、', '。'),
                    ('꓾', '꓿'),
                    ('꘍', '꘏'),
                    ('꛳', '꛷'),
                    ('꡶', '꡷'),
                    ('꣎', '꣏'),
                    ('꤯', '꤯'),
                    ('꧇', '꧉'),
                    ('꩝', '꩟'),
                    ('꫟', '꫟'),
                    ('꫰', '꫱'),
                    ('꯫', '꯫'),
                    ('︒', '︒'),
                    ('︕', '︖'),
                    ('﹐', '﹒'),
                    ('﹔', '﹗'),
                    ('！', '！'),
                    ('，', '，'),
                    ('．', '．'),
                    ('：', '；'),
                    ('？', '？'),
                    ('｡', '｡'),
                    ('､', '､'),
                    ('𐎟', '𐎟'),
                    ('𐏐', '𐏐'),
                    ('𐡗', '𐡗'),
                    ('𐤟', '𐤟'),
                    ('𐩖', '𐩗'),
                    ('𐫰', '𐫵'),
                    ('𐬺', '𐬿'),
                    ('𐮙', '𐮜'),
                    ('𐽕', '𐽙'),
                    ('𐾆', '𐾉'),
                    ('𑁇', '𑁍'),
                    ('𑂾', '𑃁'),
                    ('𑅁', '𑅃'),
                    ('𑇅', '𑇆'),
                    ('𑇍', '𑇍'),
                    ('𑇞', '𑇟'),
                    ('𑈸', '𑈼'),
                    ('𑊩', '𑊩'),
                    ('𑏔', '𑏕'),
                    ('𑑋', '𑑍'),
                    ('𑑚', '𑑛'),
                    ('𑗂', '𑗅'),
                    ('𑗉', '𑗗'),
                    ('𑙁', '𑙂'),
                    ('𑜼', '𑜾'),
                    ('𑥄', '𑥄'),
                    ('𑥆', '𑥆'),
                    ('𑩂', '𑩃'),
                    ('𑪛', '𑪜'),
                    ('𑪡', '𑪢'),
                    ('𑱁', '𑱃'),
                    ('𑱱', '𑱱'),
                    ('𑻷', '𑻸'),
                    ('𑽃', '𑽄'),
                    ('𒑰', '𒑴'),
                    ('𖩮', '𖩯'),
                    ('𖫵', '𖫵'),
                    ('𖬷', '𖬹'),
                    ('𖭄', '𖭄'),
                    ('𖵮', '𖵯'),
                    ('𖺗', '𖺘'),
                    ('𛲟', '𛲟'),
                    ('𝪇', '𝪊'),
                ];

                pub const UNIFIED_IDEOGRAPH: &'static [(char, char)] = &[
                    ('㐀', '䶿'),
                    ('一', '鿿'),
                    ('﨎', '﨏'),
                    ('﨑', '﨑'),
                    ('﨓', '﨔'),
                    ('﨟', '﨟'),
                    ('﨡', '﨡'),
                    ('﨣', '﨤'),
                    ('﨧', '﨩'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const UPPERCASE: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('À', 'Ö'),
                    ('Ø', 'Þ'),
                    ('Ā', 'Ā'),
                    ('Ă', 'Ă'),
                    ('Ą', 'Ą'),
                    ('Ć', 'Ć'),
                    ('Ĉ', 'Ĉ'),
                    ('Ċ', 'Ċ'),
                    ('Č', 'Č'),
                    ('Ď', 'Ď'),
                    ('Đ', 'Đ'),
                    ('Ē', 'Ē'),
                    ('Ĕ', 'Ĕ'),
                    ('Ė', 'Ė'),
                    ('Ę', 'Ę'),
                    ('Ě', 'Ě'),
                    ('Ĝ', 'Ĝ'),
                    ('Ğ', 'Ğ'),
                    ('Ġ', 'Ġ'),
                    ('Ģ', 'Ģ'),
                    ('Ĥ', 'Ĥ'),
                    ('Ħ', 'Ħ'),
                    ('Ĩ', 'Ĩ'),
                    ('Ī', 'Ī'),
                    ('Ĭ', 'Ĭ'),
                    ('Į', 'Į'),
                    ('İ', 'İ'),
                    ('Ĳ', 'Ĳ'),
                    ('Ĵ', 'Ĵ'),
                    ('Ķ', 'Ķ'),
                    ('Ĺ', 'Ĺ'),
                    ('Ļ', 'Ļ'),
                    ('Ľ', 'Ľ'),
                    ('Ŀ', 'Ŀ'),
                    ('Ł', 'Ł'),
                    ('Ń', 'Ń'),
                    ('Ņ', 'Ņ'),
                    ('Ň', 'Ň'),
                    ('Ŋ', 'Ŋ'),
                    ('Ō', 'Ō'),
                    ('Ŏ', 'Ŏ'),
                    ('Ő', 'Ő'),
                    ('Œ', 'Œ'),
                    ('Ŕ', 'Ŕ'),
                    ('Ŗ', 'Ŗ'),
                    ('Ř', 'Ř'),
                    ('Ś', 'Ś'),
                    ('Ŝ', 'Ŝ'),
                    ('Ş', 'Ş'),
                    ('Š', 'Š'),
                    ('Ţ', 'Ţ'),
                    ('Ť', 'Ť'),
                    ('Ŧ', 'Ŧ'),
                    ('Ũ', 'Ũ'),
                    ('Ū', 'Ū'),
                    ('Ŭ', 'Ŭ'),
                    ('Ů', 'Ů'),
                    ('Ű', 'Ű'),
                    ('Ų', 'Ų'),
                    ('Ŵ', 'Ŵ'),
                    ('Ŷ', 'Ŷ'),
                    ('Ÿ', 'Ź'),
                    ('Ż', 'Ż'),
                    ('Ž', 'Ž'),
                    ('Ɓ', 'Ƃ'),
                    ('Ƅ', 'Ƅ'),
                    ('Ɔ', 'Ƈ'),
                    ('Ɖ', 'Ƌ'),
                    ('Ǝ', 'Ƒ'),
                    ('Ɠ', 'Ɣ'),
                    ('Ɩ', 'Ƙ'),
                    ('Ɯ', 'Ɲ'),
                    ('Ɵ', 'Ơ'),
                    ('Ƣ', 'Ƣ'),
                    ('Ƥ', 'Ƥ'),
                    ('Ʀ', 'Ƨ'),
                    ('Ʃ', 'Ʃ'),
                    ('Ƭ', 'Ƭ'),
                    ('Ʈ', 'Ư'),
                    ('Ʊ', 'Ƴ'),
                    ('Ƶ', 'Ƶ'),
                    ('Ʒ', 'Ƹ'),
                    ('Ƽ', 'Ƽ'),
                    ('Ǆ', 'Ǆ'),
                    ('Ǉ', 'Ǉ'),
                    ('Ǌ', 'Ǌ'),
                    ('Ǎ', 'Ǎ'),
                    ('Ǐ', 'Ǐ'),
                    ('Ǒ', 'Ǒ'),
                    ('Ǔ', 'Ǔ'),
                    ('Ǖ', 'Ǖ'),
                    ('Ǘ', 'Ǘ'),
                    ('Ǚ', 'Ǚ'),
                    ('Ǜ', 'Ǜ'),
                    ('Ǟ', 'Ǟ'),
                    ('Ǡ', 'Ǡ'),
                    ('Ǣ', 'Ǣ'),
                    ('Ǥ', 'Ǥ'),
                    ('Ǧ', 'Ǧ'),
                    ('Ǩ', 'Ǩ'),
                    ('Ǫ', 'Ǫ'),
                    ('Ǭ', 'Ǭ'),
                    ('Ǯ', 'Ǯ'),
                    ('Ǳ', 'Ǳ'),
                    ('Ǵ', 'Ǵ'),
                    ('Ƕ', 'Ǹ'),
                    ('Ǻ', 'Ǻ'),
                    ('Ǽ', 'Ǽ'),
                    ('Ǿ', 'Ǿ'),
                    ('Ȁ', 'Ȁ'),
                    ('Ȃ', 'Ȃ'),
                    ('Ȅ', 'Ȅ'),
                    ('Ȇ', 'Ȇ'),
                    ('Ȉ', 'Ȉ'),
                    ('Ȋ', 'Ȋ'),
                    ('Ȍ', 'Ȍ'),
                    ('Ȏ', 'Ȏ'),
                    ('Ȑ', 'Ȑ'),
                    ('Ȓ', 'Ȓ'),
                    ('Ȕ', 'Ȕ'),
                    ('Ȗ', 'Ȗ'),
                    ('Ș', 'Ș'),
                    ('Ț', 'Ț'),
                    ('Ȝ', 'Ȝ'),
                    ('Ȟ', 'Ȟ'),
                    ('Ƞ', 'Ƞ'),
                    ('Ȣ', 'Ȣ'),
                    ('Ȥ', 'Ȥ'),
                    ('Ȧ', 'Ȧ'),
                    ('Ȩ', 'Ȩ'),
                    ('Ȫ', 'Ȫ'),
                    ('Ȭ', 'Ȭ'),
                    ('Ȯ', 'Ȯ'),
                    ('Ȱ', 'Ȱ'),
                    ('Ȳ', 'Ȳ'),
                    ('Ⱥ', 'Ȼ'),
                    ('Ƚ', 'Ⱦ'),
                    ('Ɂ', 'Ɂ'),
                    ('Ƀ', 'Ɇ'),
                    ('Ɉ', 'Ɉ'),
                    ('Ɋ', 'Ɋ'),
                    ('Ɍ', 'Ɍ'),
                    ('Ɏ', 'Ɏ'),
                    ('Ͱ', 'Ͱ'),
                    ('Ͳ', 'Ͳ'),
                    ('Ͷ', 'Ͷ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ώ'),
                    ('Α', 'Ρ'),
                    ('Σ', 'Ϋ'),
                    ('Ϗ', 'Ϗ'),
                    ('ϒ', 'ϔ'),
                    ('Ϙ', 'Ϙ'),
                    ('Ϛ', 'Ϛ'),
                    ('Ϝ', 'Ϝ'),
                    ('Ϟ', 'Ϟ'),
                    ('Ϡ', 'Ϡ'),
                    ('Ϣ', 'Ϣ'),
                    ('Ϥ', 'Ϥ'),
                    ('Ϧ', 'Ϧ'),
                    ('Ϩ', 'Ϩ'),
                    ('Ϫ', 'Ϫ'),
                    ('Ϭ', 'Ϭ'),
                    ('Ϯ', 'Ϯ'),
                    ('ϴ', 'ϴ'),
                    ('Ϸ', 'Ϸ'),
                    ('Ϲ', 'Ϻ'),
                    ('Ͻ', 'Я'),
                    ('Ѡ', 'Ѡ'),
                    ('Ѣ', 'Ѣ'),
                    ('Ѥ', 'Ѥ'),
                    ('Ѧ', 'Ѧ'),
                    ('Ѩ', 'Ѩ'),
                    ('Ѫ', 'Ѫ'),
                    ('Ѭ', 'Ѭ'),
                    ('Ѯ', 'Ѯ'),
                    ('Ѱ', 'Ѱ'),
                    ('Ѳ', 'Ѳ'),
                    ('Ѵ', 'Ѵ'),
                    ('Ѷ', 'Ѷ'),
                    ('Ѹ', 'Ѹ'),
                    ('Ѻ', 'Ѻ'),
                    ('Ѽ', 'Ѽ'),
                    ('Ѿ', 'Ѿ'),
                    ('Ҁ', 'Ҁ'),
                    ('Ҋ', 'Ҋ'),
                    ('Ҍ', 'Ҍ'),
                    ('Ҏ', 'Ҏ'),
                    ('Ґ', 'Ґ'),
                    ('Ғ', 'Ғ'),
                    ('Ҕ', 'Ҕ'),
                    ('Җ', 'Җ'),
                    ('Ҙ', 'Ҙ'),
                    ('Қ', 'Қ'),
                    ('Ҝ', 'Ҝ'),
                    ('Ҟ', 'Ҟ'),
                    ('Ҡ', 'Ҡ'),
                    ('Ң', 'Ң'),
                    ('Ҥ', 'Ҥ'),
                    ('Ҧ', 'Ҧ'),
                    ('Ҩ', 'Ҩ'),
                    ('Ҫ', 'Ҫ'),
                    ('Ҭ', 'Ҭ'),
                    ('Ү', 'Ү'),
                    ('Ұ', 'Ұ'),
                    ('Ҳ', 'Ҳ'),
                    ('Ҵ', 'Ҵ'),
                    ('Ҷ', 'Ҷ'),
                    ('Ҹ', 'Ҹ'),
                    ('Һ', 'Һ'),
                    ('Ҽ', 'Ҽ'),
                    ('Ҿ', 'Ҿ'),
                    ('Ӏ', 'Ӂ'),
                    ('Ӄ', 'Ӄ'),
                    ('Ӆ', 'Ӆ'),
                    ('Ӈ', 'Ӈ'),
                    ('Ӊ', 'Ӊ'),
                    ('Ӌ', 'Ӌ'),
                    ('Ӎ', 'Ӎ'),
                    ('Ӑ', 'Ӑ'),
                    ('Ӓ', 'Ӓ'),
                    ('Ӕ', 'Ӕ'),
                    ('Ӗ', 'Ӗ'),
                    ('Ә', 'Ә'),
                    ('Ӛ', 'Ӛ'),
                    ('Ӝ', 'Ӝ'),
                    ('Ӟ', 'Ӟ'),
                    ('Ӡ', 'Ӡ'),
                    ('Ӣ', 'Ӣ'),
                    ('Ӥ', 'Ӥ'),
                    ('Ӧ', 'Ӧ'),
                    ('Ө', 'Ө'),
                    ('Ӫ', 'Ӫ'),
                    ('Ӭ', 'Ӭ'),
                    ('Ӯ', 'Ӯ'),
                    ('Ӱ', 'Ӱ'),
                    ('Ӳ', 'Ӳ'),
                    ('Ӵ', 'Ӵ'),
                    ('Ӷ', 'Ӷ'),
                    ('Ӹ', 'Ӹ'),
                    ('Ӻ', 'Ӻ'),
                    ('Ӽ', 'Ӽ'),
                    ('Ӿ', 'Ӿ'),
                    ('Ԁ', 'Ԁ'),
                    ('Ԃ', 'Ԃ'),
                    ('Ԅ', 'Ԅ'),
                    ('Ԇ', 'Ԇ'),
                    ('Ԉ', 'Ԉ'),
                    ('Ԋ', 'Ԋ'),
                    ('Ԍ', 'Ԍ'),
                    ('Ԏ', 'Ԏ'),
                    ('Ԑ', 'Ԑ'),
                    ('Ԓ', 'Ԓ'),
                    ('Ԕ', 'Ԕ'),
                    ('Ԗ', 'Ԗ'),
                    ('Ԙ', 'Ԙ'),
                    ('Ԛ', 'Ԛ'),
                    ('Ԝ', 'Ԝ'),
                    ('Ԟ', 'Ԟ'),
                    ('Ԡ', 'Ԡ'),
                    ('Ԣ', 'Ԣ'),
                    ('Ԥ', 'Ԥ'),
                    ('Ԧ', 'Ԧ'),
                    ('Ԩ', 'Ԩ'),
                    ('Ԫ', 'Ԫ'),
                    ('Ԭ', 'Ԭ'),
                    ('Ԯ', 'Ԯ'),
                    ('Ա', 'Ֆ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('Ᲊ', 'Ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('Ḁ', 'Ḁ'),
                    ('Ḃ', 'Ḃ'),
                    ('Ḅ', 'Ḅ'),
                    ('Ḇ', 'Ḇ'),
                    ('Ḉ', 'Ḉ'),
                    ('Ḋ', 'Ḋ'),
                    ('Ḍ', 'Ḍ'),
                    ('Ḏ', 'Ḏ'),
                    ('Ḑ', 'Ḑ'),
                    ('Ḓ', 'Ḓ'),
                    ('Ḕ', 'Ḕ'),
                    ('Ḗ', 'Ḗ'),
                    ('Ḙ', 'Ḙ'),
                    ('Ḛ', 'Ḛ'),
                    ('Ḝ', 'Ḝ'),
                    ('Ḟ', 'Ḟ'),
                    ('Ḡ', 'Ḡ'),
                    ('Ḣ', 'Ḣ'),
                    ('Ḥ', 'Ḥ'),
                    ('Ḧ', 'Ḧ'),
                    ('Ḩ', 'Ḩ'),
                    ('Ḫ', 'Ḫ'),
                    ('Ḭ', 'Ḭ'),
                    ('Ḯ', 'Ḯ'),
                    ('Ḱ', 'Ḱ'),
                    ('Ḳ', 'Ḳ'),
                    ('Ḵ', 'Ḵ'),
                    ('Ḷ', 'Ḷ'),
                    ('Ḹ', 'Ḹ'),
                    ('Ḻ', 'Ḻ'),
                    ('Ḽ', 'Ḽ'),
                    ('Ḿ', 'Ḿ'),
                    ('Ṁ', 'Ṁ'),
                    ('Ṃ', 'Ṃ'),
                    ('Ṅ', 'Ṅ'),
                    ('Ṇ', 'Ṇ'),
                    ('Ṉ', 'Ṉ'),
                    ('Ṋ', 'Ṋ'),
                    ('Ṍ', 'Ṍ'),
                    ('Ṏ', 'Ṏ'),
                    ('Ṑ', 'Ṑ'),
                    ('Ṓ', 'Ṓ'),
                    ('Ṕ', 'Ṕ'),
                    ('Ṗ', 'Ṗ'),
                    ('Ṙ', 'Ṙ'),
                    ('Ṛ', 'Ṛ'),
                    ('Ṝ', 'Ṝ'),
                    ('Ṟ', 'Ṟ'),
                    ('Ṡ', 'Ṡ'),
                    ('Ṣ', 'Ṣ'),
                    ('Ṥ', 'Ṥ'),
                    ('Ṧ', 'Ṧ'),
                    ('Ṩ', 'Ṩ'),
                    ('Ṫ', 'Ṫ'),
                    ('Ṭ', 'Ṭ'),
                    ('Ṯ', 'Ṯ'),
                    ('Ṱ', 'Ṱ'),
                    ('Ṳ', 'Ṳ'),
                    ('Ṵ', 'Ṵ'),
                    ('Ṷ', 'Ṷ'),
                    ('Ṹ', 'Ṹ'),
                    ('Ṻ', 'Ṻ'),
                    ('Ṽ', 'Ṽ'),
                    ('Ṿ', 'Ṿ'),
                    ('Ẁ', 'Ẁ'),
                    ('Ẃ', 'Ẃ'),
                    ('Ẅ', 'Ẅ'),
                    ('Ẇ', 'Ẇ'),
                    ('Ẉ', 'Ẉ'),
                    ('Ẋ', 'Ẋ'),
                    ('Ẍ', 'Ẍ'),
                    ('Ẏ', 'Ẏ'),
                    ('Ẑ', 'Ẑ'),
                    ('Ẓ', 'Ẓ'),
                    ('Ẕ', 'Ẕ'),
                    ('ẞ', 'ẞ'),
                    ('Ạ', 'Ạ'),
                    ('Ả', 'Ả'),
                    ('Ấ', 'Ấ'),
                    ('Ầ', 'Ầ'),
                    ('Ẩ', 'Ẩ'),
                    ('Ẫ', 'Ẫ'),
                    ('Ậ', 'Ậ'),
                    ('Ắ', 'Ắ'),
                    ('Ằ', 'Ằ'),
                    ('Ẳ', 'Ẳ'),
                    ('Ẵ', 'Ẵ'),
                    ('Ặ', 'Ặ'),
                    ('Ẹ', 'Ẹ'),
                    ('Ẻ', 'Ẻ'),
                    ('Ẽ', 'Ẽ'),
                    ('Ế', 'Ế'),
                    ('Ề', 'Ề'),
                    ('Ể', 'Ể'),
                    ('Ễ', 'Ễ'),
                    ('Ệ', 'Ệ'),
                    ('Ỉ', 'Ỉ'),
                    ('Ị', 'Ị'),
                    ('Ọ', 'Ọ'),
                    ('Ỏ', 'Ỏ'),
                    ('Ố', 'Ố'),
                    ('Ồ', 'Ồ'),
                    ('Ổ', 'Ổ'),
                    ('Ỗ', 'Ỗ'),
                    ('Ộ', 'Ộ'),
                    ('Ớ', 'Ớ'),
                    ('Ờ', 'Ờ'),
                    ('Ở', 'Ở'),
                    ('Ỡ', 'Ỡ'),
                    ('Ợ', 'Ợ'),
                    ('Ụ', 'Ụ'),
                    ('Ủ', 'Ủ'),
                    ('Ứ', 'Ứ'),
                    ('Ừ', 'Ừ'),
                    ('Ử', 'Ử'),
                    ('Ữ', 'Ữ'),
                    ('Ự', 'Ự'),
                    ('Ỳ', 'Ỳ'),
                    ('Ỵ', 'Ỵ'),
                    ('Ỷ', 'Ỷ'),
                    ('Ỹ', 'Ỹ'),
                    ('Ỻ', 'Ỻ'),
                    ('Ỽ', 'Ỽ'),
                    ('Ỿ', 'Ỿ'),
                    ('Ἀ', 'Ἇ'),
                    ('Ἐ', 'Ἕ'),
                    ('Ἠ', 'Ἧ'),
                    ('Ἰ', 'Ἷ'),
                    ('Ὀ', 'Ὅ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'Ὗ'),
                    ('Ὠ', 'Ὧ'),
                    ('Ᾰ', 'Ά'),
                    ('Ὲ', 'Ή'),
                    ('Ῐ', 'Ί'),
                    ('Ῠ', 'Ῥ'),
                    ('Ὸ', 'Ώ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℋ', 'ℍ'),
                    ('ℐ', 'ℒ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℰ', 'ℳ'),
                    ('ℾ', 'ℿ'),
                    ('ⅅ', 'ⅅ'),
                    ('Ⅰ', 'Ⅿ'),
                    ('Ↄ', 'Ↄ'),
                    ('Ⓐ', 'Ⓩ'),
                    ('Ⰰ', 'Ⱟ'),
                    ('Ⱡ', 'Ⱡ'),
                    ('Ɫ', 'Ɽ'),
                    ('Ⱨ', 'Ⱨ'),
                    ('Ⱪ', 'Ⱪ'),
                    ('Ⱬ', 'Ⱬ'),
                    ('Ɑ', 'Ɒ'),
                    ('Ⱳ', 'Ⱳ'),
                    ('Ⱶ', 'Ⱶ'),
                    ('Ȿ', 'Ⲁ'),
                    ('Ⲃ', 'Ⲃ'),
                    ('Ⲅ', 'Ⲅ'),
                    ('Ⲇ', 'Ⲇ'),
                    ('Ⲉ', 'Ⲉ'),
                    ('Ⲋ', 'Ⲋ'),
                    ('Ⲍ', 'Ⲍ'),
                    ('Ⲏ', 'Ⲏ'),
                    ('Ⲑ', 'Ⲑ'),
                    ('Ⲓ', 'Ⲓ'),
                    ('Ⲕ', 'Ⲕ'),
                    ('Ⲗ', 'Ⲗ'),
                    ('Ⲙ', 'Ⲙ'),
                    ('Ⲛ', 'Ⲛ'),
                    ('Ⲝ', 'Ⲝ'),
                    ('Ⲟ', 'Ⲟ'),
                    ('Ⲡ', 'Ⲡ'),
                    ('Ⲣ', 'Ⲣ'),
                    ('Ⲥ', 'Ⲥ'),
                    ('Ⲧ', 'Ⲧ'),
                    ('Ⲩ', 'Ⲩ'),
                    ('Ⲫ', 'Ⲫ'),
                    ('Ⲭ', 'Ⲭ'),
                    ('Ⲯ', 'Ⲯ'),
                    ('Ⲱ', 'Ⲱ'),
                    ('Ⲳ', 'Ⲳ'),
                    ('Ⲵ', 'Ⲵ'),
                    ('Ⲷ', 'Ⲷ'),
                    ('Ⲹ', 'Ⲹ'),
                    ('Ⲻ', 'Ⲻ'),
                    ('Ⲽ', 'Ⲽ'),
                    ('Ⲿ', 'Ⲿ'),
                    ('Ⳁ', 'Ⳁ'),
                    ('Ⳃ', 'Ⳃ'),
                    ('Ⳅ', 'Ⳅ'),
                    ('Ⳇ', 'Ⳇ'),
                    ('Ⳉ', 'Ⳉ'),
                    ('Ⳋ', 'Ⳋ'),
                    ('Ⳍ', 'Ⳍ'),
                    ('Ⳏ', 'Ⳏ'),
                    ('Ⳑ', 'Ⳑ'),
                    ('Ⳓ', 'Ⳓ'),
                    ('Ⳕ', 'Ⳕ'),
                    ('Ⳗ', 'Ⳗ'),
                    ('Ⳙ', 'Ⳙ'),
                    ('Ⳛ', 'Ⳛ'),
                    ('Ⳝ', 'Ⳝ'),
                    ('Ⳟ', 'Ⳟ'),
                    ('Ⳡ', 'Ⳡ'),
                    ('Ⳣ', 'Ⳣ'),
                    ('Ⳬ', 'Ⳬ'),
                    ('Ⳮ', 'Ⳮ'),
                    ('Ⳳ', 'Ⳳ'),
                    ('Ꙁ', 'Ꙁ'),
                    ('Ꙃ', 'Ꙃ'),
                    ('Ꙅ', 'Ꙅ'),
                    ('Ꙇ', 'Ꙇ'),
                    ('Ꙉ', 'Ꙉ'),
                    ('Ꙋ', 'Ꙋ'),
                    ('Ꙍ', 'Ꙍ'),
                    ('Ꙏ', 'Ꙏ'),
                    ('Ꙑ', 'Ꙑ'),
                    ('Ꙓ', 'Ꙓ'),
                    ('Ꙕ', 'Ꙕ'),
                    ('Ꙗ', 'Ꙗ'),
                    ('Ꙙ', 'Ꙙ'),
                    ('Ꙛ', 'Ꙛ'),
                    ('Ꙝ', 'Ꙝ'),
                    ('Ꙟ', 'Ꙟ'),
                    ('Ꙡ', 'Ꙡ'),
                    ('Ꙣ', 'Ꙣ'),
                    ('Ꙥ', 'Ꙥ'),
                    ('Ꙧ', 'Ꙧ'),
                    ('Ꙩ', 'Ꙩ'),
                    ('Ꙫ', 'Ꙫ'),
                    ('Ꙭ', 'Ꙭ'),
                    ('Ꚁ', 'Ꚁ'),
                    ('Ꚃ', 'Ꚃ'),
                    ('Ꚅ', 'Ꚅ'),
                    ('Ꚇ', 'Ꚇ'),
                    ('Ꚉ', 'Ꚉ'),
                    ('Ꚋ', 'Ꚋ'),
                    ('Ꚍ', 'Ꚍ'),
                    ('Ꚏ', 'Ꚏ'),
                    ('Ꚑ', 'Ꚑ'),
                    ('Ꚓ', 'Ꚓ'),
                    ('Ꚕ', 'Ꚕ'),
                    ('Ꚗ', 'Ꚗ'),
                    ('Ꚙ', 'Ꚙ'),
                    ('Ꚛ', 'Ꚛ'),
                    ('Ꜣ', 'Ꜣ'),
                    ('Ꜥ', 'Ꜥ'),
                    ('Ꜧ', 'Ꜧ'),
                    ('Ꜩ', 'Ꜩ'),
                    ('Ꜫ', 'Ꜫ'),
                    ('Ꜭ', 'Ꜭ'),
                    ('Ꜯ', 'Ꜯ'),
                    ('Ꜳ', 'Ꜳ'),
                    ('Ꜵ', 'Ꜵ'),
                    ('Ꜷ', 'Ꜷ'),
                    ('Ꜹ', 'Ꜹ'),
                    ('Ꜻ', 'Ꜻ'),
                    ('Ꜽ', 'Ꜽ'),
                    ('Ꜿ', 'Ꜿ'),
                    ('Ꝁ', 'Ꝁ'),
                    ('Ꝃ', 'Ꝃ'),
                    ('Ꝅ', 'Ꝅ'),
                    ('Ꝇ', 'Ꝇ'),
                    ('Ꝉ', 'Ꝉ'),
                    ('Ꝋ', 'Ꝋ'),
                    ('Ꝍ', 'Ꝍ'),
                    ('Ꝏ', 'Ꝏ'),
                    ('Ꝑ', 'Ꝑ'),
                    ('Ꝓ', 'Ꝓ'),
                    ('Ꝕ', 'Ꝕ'),
                    ('Ꝗ', 'Ꝗ'),
                    ('Ꝙ', 'Ꝙ'),
                    ('Ꝛ', 'Ꝛ'),
                    ('Ꝝ', 'Ꝝ'),
                    ('Ꝟ', 'Ꝟ'),
                    ('Ꝡ', 'Ꝡ'),
                    ('Ꝣ', 'Ꝣ'),
                    ('Ꝥ', 'Ꝥ'),
                    ('Ꝧ', 'Ꝧ'),
                    ('Ꝩ', 'Ꝩ'),
                    ('Ꝫ', 'Ꝫ'),
                    ('Ꝭ', 'Ꝭ'),
                    ('Ꝯ', 'Ꝯ'),
                    ('Ꝺ', 'Ꝺ'),
                    ('Ꝼ', 'Ꝼ'),
                    ('Ᵹ', 'Ꝿ'),
                    ('Ꞁ', 'Ꞁ'),
                    ('Ꞃ', 'Ꞃ'),
                    ('Ꞅ', 'Ꞅ'),
                    ('Ꞇ', 'Ꞇ'),
                    ('Ꞌ', 'Ꞌ'),
                    ('Ɥ', 'Ɥ'),
                    ('Ꞑ', 'Ꞑ'),
                    ('Ꞓ', 'Ꞓ'),
                    ('Ꞗ', 'Ꞗ'),
                    ('Ꞙ', 'Ꞙ'),
                    ('Ꞛ', 'Ꞛ'),
                    ('Ꞝ', 'Ꞝ'),
                    ('Ꞟ', 'Ꞟ'),
                    ('Ꞡ', 'Ꞡ'),
                    ('Ꞣ', 'Ꞣ'),
                    ('Ꞥ', 'Ꞥ'),
                    ('Ꞧ', 'Ꞧ'),
                    ('Ꞩ', 'Ꞩ'),
                    ('Ɦ', 'Ɪ'),
                    ('Ʞ', 'Ꞵ'),
                    ('Ꞷ', 'Ꞷ'),
                    ('Ꞹ', 'Ꞹ'),
                    ('Ꞻ', 'Ꞻ'),
                    ('Ꞽ', 'Ꞽ'),
                    ('Ꞿ', 'Ꞿ'),
                    ('Ꟁ', 'Ꟁ'),
                    ('Ꟃ', 'Ꟃ'),
                    ('Ꞔ', 'Ꟈ'),
                    ('Ꟊ', 'Ꟊ'),
                    ('Ɤ', 'Ꟍ'),
                    ('Ꟑ', 'Ꟑ'),
                    ('Ꟗ', 'Ꟗ'),
                    ('Ꟙ', 'Ꟙ'),
                    ('Ꟛ', 'Ꟛ'),
                    ('Ƛ', 'Ƛ'),
                    ('Ꟶ', 'Ꟶ'),
                    ('Ａ', 'Ｚ'),
                    ('𐐀', '𐐧'),
                    ('𐒰', '𐓓'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐲀', '𐲲'),
                    ('𐵐', '𐵥'),
                    ('𑢠', '𑢿'),
                    ('𖹀', '𖹟'),
                    ('𝐀', '𝐙'),
                    ('𝐴', '𝑍'),
                    ('𝑨', '𝒁'),
                    ('𝒜', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒵'),
                    ('𝓐', '𝓩'),
                    ('𝔄', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔸', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕬', '𝖅'),
                    ('𝖠', '𝖹'),
                    ('𝗔', '𝗭'),
                    ('𝘈', '𝘡'),
                    ('𝘼', '𝙕'),
                    ('𝙰', '𝚉'),
                    ('𝚨', '𝛀'),
                    ('𝛢', '𝛺'),
                    ('𝜜', '𝜴'),
                    ('𝝖', '𝝮'),
                    ('𝞐', '𝞨'),
                    ('𝟊', '𝟊'),
                    ('𞤀', '𞤡'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                ];

                pub const VARIATION_SELECTOR: &'static [(char, char)] = &[
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const WHITE_SPACE: &'static [(char, char)] = &[
                    ('\t', '\r'),
                    (' ', ' '),
                    ('\u{85}', '\u{85}'),
                    ('\u{a0}', '\u{a0}'),
                    ('\u{1680}', '\u{1680}'),
                    ('\u{2000}', '\u{200a}'),
                    ('\u{2028}', '\u{2029}'),
                    ('\u{202f}', '\u{202f}'),
                    ('\u{205f}', '\u{205f}'),
                    ('\u{3000}', '\u{3000}'),
                ];

                pub const XID_CONTINUE: &'static [(char, char)] = &[
                    ('0', '9'),
                    ('A', 'Z'),
                    ('_', '_'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('·', '·'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('\u{300}', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('\u{483}', '\u{487}'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('\u{610}', '\u{61a}'),
                    ('ؠ', '٩'),
                    ('ٮ', 'ۓ'),
                    ('ە', '\u{6dc}'),
                    ('\u{6df}', '\u{6e8}'),
                    ('\u{6ea}', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', '\u{74a}'),
                    ('ݍ', 'ޱ'),
                    ('߀', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('ࠀ', '\u{82d}'),
                    ('ࡀ', '\u{85b}'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('\u{897}', '\u{8e1}'),
                    ('\u{8e3}', '\u{963}'),
                    ('०', '९'),
                    ('ॱ', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৎ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('০', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', '\u{ae3}'),
                    ('૦', '૯'),
                    ('ૹ', '\u{aff}'),
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('\u{b3c}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', '\u{b63}'),
                    ('୦', '୯'),
                    ('ୱ', 'ୱ'),
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('ௐ', 'ௐ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('௦', '௯'),
                    ('\u{c00}', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('\u{c3c}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', '\u{c63}'),
                    ('౦', '౯'),
                    ('ಀ', 'ಃ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('\u{cbc}', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', '\u{ce3}'),
                    ('೦', '೯'),
                    ('ೱ', 'ೳ'),
                    ('\u{d00}', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', 'ൎ'),
                    ('ൔ', '\u{d57}'),
                    ('ൟ', '\u{d63}'),
                    ('൦', '൯'),
                    ('ൺ', 'ൿ'),
                    ('\u{d81}', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('෦', '෯'),
                    ('ෲ', 'ෳ'),
                    ('ก', '\u{e3a}'),
                    ('เ', '\u{e4e}'),
                    ('๐', '๙'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ece}'),
                    ('໐', '໙'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('\u{f18}', '\u{f19}'),
                    ('༠', '༩'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('\u{f71}', '\u{f84}'),
                    ('\u{f86}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('က', '၉'),
                    ('ၐ', '\u{109d}'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('\u{135d}', '\u{135f}'),
                    ('፩', '፱'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', '\u{1715}'),
                    ('ᜟ', '\u{1734}'),
                    ('ᝀ', '\u{1753}'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('\u{1772}', '\u{1773}'),
                    ('ក', '\u{17d3}'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', '\u{17dd}'),
                    ('០', '៩'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '᠙'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('᥆', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('᧐', '᧚'),
                    ('ᨀ', '\u{1a1b}'),
                    ('ᨠ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '᪉'),
                    ('᪐', '᪙'),
                    ('ᪧ', 'ᪧ'),
                    ('\u{1ab0}', '\u{1abd}'),
                    ('\u{1abf}', '\u{1ace}'),
                    ('\u{1b00}', 'ᭌ'),
                    ('᭐', '᭙'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', '\u{1bf3}'),
                    ('ᰀ', '\u{1c37}'),
                    ('᱀', '᱉'),
                    ('ᱍ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', 'ᳺ'),
                    ('ᴀ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('\u{200c}', '\u{200d}'),
                    ('‿', '⁀'),
                    ('⁔', '⁔'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('\u{20d0}', '\u{20dc}'),
                    ('\u{20e1}', '\u{20e1}'),
                    ('\u{20e5}', '\u{20f0}'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('℘', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('\u{2d7f}', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('々', '〇'),
                    ('〡', '\u{302f}'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('\u{3099}', '\u{309a}'),
                    ('ゝ', 'ゟ'),
                    ('ァ', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘫ'),
                    ('Ꙁ', '\u{a66f}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('ꙿ', '\u{a6f1}'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠧ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢀ', '\u{a8c5}'),
                    ('꣐', '꣙'),
                    ('\u{a8e0}', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', '\u{a92d}'),
                    ('ꤰ', '\u{a953}'),
                    ('ꥠ', 'ꥼ'),
                    ('\u{a980}', '\u{a9c0}'),
                    ('ꧏ', '꧙'),
                    ('ꧠ', 'ꧾ'),
                    ('ꨀ', '\u{aa36}'),
                    ('ꩀ', 'ꩍ'),
                    ('꩐', '꩙'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫯ'),
                    ('ꫲ', '\u{aaf6}'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯪ'),
                    ('꯬', '\u{abed}'),
                    ('꯰', '꯹'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﱝ'),
                    ('ﱤ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷹ'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('︳', '︴'),
                    ('﹍', '﹏'),
                    ('ﹱ', 'ﹱ'),
                    ('ﹳ', 'ﹳ'),
                    ('ﹷ', 'ﹷ'),
                    ('ﹹ', 'ﹹ'),
                    ('ﹻ', 'ﹻ'),
                    ('ﹽ', 'ﹽ'),
                    ('ﹿ', 'ﻼ'),
                    ('０', '９'),
                    ('Ａ', 'Ｚ'),
                    ('＿', '＿'),
                    ('ａ', 'ｚ'),
                    ('･', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '\u{1037a}'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒠', '𐒩'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '\u{10ae6}'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '\u{10d27}'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵥'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '\u{10f50}'),
                    ('𐽰', '\u{10f85}'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀀', '\u{11046}'),
                    ('𑁦', '𑁵'),
                    ('\u{1107f}', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('𑃐', '𑃨'),
                    ('𑃰', '𑃹'),
                    ('\u{11100}', '\u{11134}'),
                    ('𑄶', '𑄿'),
                    ('𑅄', '𑅇'),
                    ('𑅐', '\u{11173}'),
                    ('𑅶', '𑅶'),
                    ('\u{11180}', '𑇄'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇎', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '\u{11237}'),
                    ('\u{1123e}', '\u{11241}'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '\u{112ea}'),
                    ('𑋰', '𑋹'),
                    ('\u{11300}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('\u{1133b}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('𑍐', '𑍐'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏓'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑐀', '𑑊'),
                    ('𑑐', '𑑙'),
                    ('\u{1145e}', '𑑡'),
                    ('𑒀', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑓐', '𑓙'),
                    ('𑖀', '\u{115b5}'),
                    ('𑖸', '\u{115c0}'),
                    ('𑗘', '\u{115dd}'),
                    ('𑘀', '\u{11640}'),
                    ('𑙄', '𑙄'),
                    ('𑙐', '𑙙'),
                    ('𑚀', '𑚸'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜀', '𑜚'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑜰', '𑜹'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '\u{1183a}'),
                    ('𑢠', '𑣩'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{11943}'),
                    ('𑥐', '𑥙'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '\u{119d7}'),
                    ('\u{119da}', '𑧡'),
                    ('𑧣', '𑧤'),
                    ('𑨀', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('𑩐', '\u{11a99}'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑯰', '𑯹'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '\u{11c36}'),
                    ('\u{11c38}', '𑱀'),
                    ('𑱐', '𑱙'),
                    ('𑱲', '𑲏'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d47}'),
                    ('𑵐', '𑵙'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶘'),
                    ('𑶠', '𑶩'),
                    ('𑻠', '𑻶'),
                    ('\u{11f00}', '𑼐'),
                    ('𑼒', '\u{11f3a}'),
                    ('𑼾', '\u{11f42}'),
                    ('𑽐', '\u{11f5a}'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('\u{13440}', '\u{13455}'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄹'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩠', '𖩩'),
                    ('𖩰', '𖪾'),
                    ('𖫀', '𖫉'),
                    ('𖫐', '𖫭'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('𖬀', '\u{16b36}'),
                    ('𖭀', '𖭃'),
                    ('𖭐', '𖭙'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖵰', '𖵹'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('\u{16f4f}', '𖾇'),
                    ('\u{16f8f}', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('𜳰', '𜳹'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('𞄀', '𞄬'),
                    ('\u{1e130}', '𞄽'),
                    ('𞅀', '𞅉'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '\u{1e2ae}'),
                    ('𞋀', '𞋹'),
                    ('𞓐', '𞓹'),
                    ('𞗐', '𞗺'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('𞤀', '𞥋'),
                    ('𞥐', '𞥙'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('🯰', '🯹'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const XID_START: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ˁ'),
                    ('ˆ', 'ˑ'),
                    ('ˠ', 'ˤ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('Ͱ', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͻ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', 'ՙ'),
                    ('ՠ', 'ֈ'),
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('ؠ', 'ي'),
                    ('ٮ', 'ٯ'),
                    ('ٱ', 'ۓ'),
                    ('ە', 'ە'),
                    ('ۥ', 'ۦ'),
                    ('ۮ', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠀ', 'ࠕ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('ࢠ', 'ࣉ'),
                    ('ऄ', 'ह'),
                    ('ऽ', 'ऽ'),
                    ('ॐ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('ॱ', 'ঀ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('ੲ', 'ੴ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ઽ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('ૹ', 'ૹ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('ୱ', 'ୱ'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ௐ', 'ௐ'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('ಀ', 'ಀ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಽ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('ೱ', 'ೲ'),
                    ('ഄ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', 'ൖ'),
                    ('ൟ', 'ൡ'),
                    ('ൺ', 'ൿ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ก', 'ะ'),
                    ('า', 'า'),
                    ('เ', 'ๆ'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ະ'),
                    ('າ', 'າ'),
                    ('ຽ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ྈ', 'ྌ'),
                    ('က', 'ဪ'),
                    ('ဿ', 'ဿ'),
                    ('ၐ', 'ၕ'),
                    ('ၚ', 'ၝ'),
                    ('ၡ', 'ၡ'),
                    ('ၥ', 'ၦ'),
                    ('ၮ', 'ၰ'),
                    ('ၵ', 'ႁ'),
                    ('ႎ', 'ႎ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ក', 'ឳ'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', 'ៜ'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('ᨀ', 'ᨖ'),
                    ('ᨠ', 'ᩔ'),
                    ('ᪧ', 'ᪧ'),
                    ('ᬅ', 'ᬳ'),
                    ('ᭅ', 'ᭌ'),
                    ('ᮃ', 'ᮠ'),
                    ('ᮮ', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᰀ', 'ᰣ'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ᴀ', 'ᶿ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('℘', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('々', '〇'),
                    ('〡', '〩'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('ゝ', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('Ꙁ', 'ꙮ'),
                    ('ꙿ', 'ꚝ'),
                    ('ꚠ', 'ꛯ'),
                    ('ꜗ', 'ꜟ'),
                    ('Ꜣ', 'ꞈ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠢ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢂ', 'ꢳ'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', 'ꣾ'),
                    ('ꤊ', 'ꤥ'),
                    ('ꤰ', 'ꥆ'),
                    ('ꥠ', 'ꥼ'),
                    ('ꦄ', 'ꦲ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧠ', 'ꧤ'),
                    ('ꧦ', 'ꧯ'),
                    ('ꧺ', 'ꧾ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꩺ'),
                    ('ꩾ', 'ꪯ'),
                    ('ꪱ', 'ꪱ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪽ'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫪ'),
                    ('ꫲ', 'ꫴ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꯢ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﱝ'),
                    ('ﱤ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷹ'),
                    ('ﹱ', 'ﹱ'),
                    ('ﹳ', 'ﹳ'),
                    ('ﹷ', 'ﹷ'),
                    ('ﹹ', 'ﹹ'),
                    ('ﹻ', 'ﹻ'),
                    ('ﹽ', 'ﹽ'),
                    ('ﹿ', 'ﻼ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('ｦ', 'ﾝ'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '𐴣'),
                    ('𐵊', '𐵥'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀃', '𑀷'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂃', '𑂯'),
                    ('𑃐', '𑃨'),
                    ('𑄃', '𑄦'),
                    ('𑅄', '𑅄'),
                    ('𑅇', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('𑆃', '𑆲'),
                    ('𑇁', '𑇄'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈫'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '𑋞'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍡'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑐴'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '𑖮'),
                    ('𑗘', '𑗛'),
                    ('𑘀', '𑘯'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '𑚪'),
                    ('𑚸', '𑚸'),
                    ('𑜀', '𑜚'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '𑠫'),
                    ('𑢠', '𑣟'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧐'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧣'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨺', '𑨺'),
                    ('𑩐', '𑩐'),
                    ('𑩜', '𑪉'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰮'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶉'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻲'),
                    ('𑼂', '𑼂'),
                    ('𑼄', '𑼐'),
                    ('𑼒', '𑼳'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭀', '𖭃'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖽐'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓫'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞤀', '𞥃'),
                    ('𞥋', '𞥋'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];
            }

            pub mod property_names
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const PROPERTY_NAMES: &'static [(&'static str, &'static str)] = &[
                    ("age", "Age"),
                    ("ahex", "ASCII_Hex_Digit"),
                    ("alpha", "Alphabetic"),
                    ("alphabetic", "Alphabetic"),
                    ("asciihexdigit", "ASCII_Hex_Digit"),
                    ("bc", "Bidi_Class"),
                    ("bidic", "Bidi_Control"),
                    ("bidiclass", "Bidi_Class"),
                    ("bidicontrol", "Bidi_Control"),
                    ("bidim", "Bidi_Mirrored"),
                    ("bidimirrored", "Bidi_Mirrored"),
                    ("bidimirroringglyph", "Bidi_Mirroring_Glyph"),
                    ("bidipairedbracket", "Bidi_Paired_Bracket"),
                    ("bidipairedbrackettype", "Bidi_Paired_Bracket_Type"),
                    ("blk", "Block"),
                    ("block", "Block"),
                    ("bmg", "Bidi_Mirroring_Glyph"),
                    ("bpb", "Bidi_Paired_Bracket"),
                    ("bpt", "Bidi_Paired_Bracket_Type"),
                    ("canonicalcombiningclass", "Canonical_Combining_Class"),
                    ("cased", "Cased"),
                    ("casefolding", "Case_Folding"),
                    ("caseignorable", "Case_Ignorable"),
                    ("ccc", "Canonical_Combining_Class"),
                    ("ce", "Composition_Exclusion"),
                    ("cf", "Case_Folding"),
                    ("changeswhencasefolded", "Changes_When_Casefolded"),
                    ("changeswhencasemapped", "Changes_When_Casemapped"),
                    ("changeswhenlowercased", "Changes_When_Lowercased"),
                    ("changeswhennfkccasefolded", "Changes_When_NFKC_Casefolded"),
                    ("changeswhentitlecased", "Changes_When_Titlecased"),
                    ("changeswhenuppercased", "Changes_When_Uppercased"),
                    ("ci", "Case_Ignorable"),
                    ("cjkaccountingnumeric", "kAccountingNumeric"),
                    ("cjkcompatibilityvariant", "kCompatibilityVariant"),
                    ("cjkiicore", "kIICore"),
                    ("cjkirggsource", "kIRG_GSource"),
                    ("cjkirghsource", "kIRG_HSource"),
                    ("cjkirgjsource", "kIRG_JSource"),
                    ("cjkirgkpsource", "kIRG_KPSource"),
                    ("cjkirgksource", "kIRG_KSource"),
                    ("cjkirgmsource", "kIRG_MSource"),
                    ("cjkirgssource", "kIRG_SSource"),
                    ("cjkirgtsource", "kIRG_TSource"),
                    ("cjkirguksource", "kIRG_UKSource"),
                    ("cjkirgusource", "kIRG_USource"),
                    ("cjkirgvsource", "kIRG_VSource"),
                    ("cjkothernumeric", "kOtherNumeric"),
                    ("cjkprimarynumeric", "kPrimaryNumeric"),
                    ("cjkrsunicode", "kRSUnicode"),
                    ("compex", "Full_Composition_Exclusion"),
                    ("compositionexclusion", "Composition_Exclusion"),
                    ("cwcf", "Changes_When_Casefolded"),
                    ("cwcm", "Changes_When_Casemapped"),
                    ("cwkcf", "Changes_When_NFKC_Casefolded"),
                    ("cwl", "Changes_When_Lowercased"),
                    ("cwt", "Changes_When_Titlecased"),
                    ("cwu", "Changes_When_Uppercased"),
                    ("dash", "Dash"),
                    ("decompositionmapping", "Decomposition_Mapping"),
                    ("decompositiontype", "Decomposition_Type"),
                    ("defaultignorablecodepoint", "Default_Ignorable_Code_Point"),
                    ("dep", "Deprecated"),
                    ("deprecated", "Deprecated"),
                    ("di", "Default_Ignorable_Code_Point"),
                    ("dia", "Diacritic"),
                    ("diacritic", "Diacritic"),
                    ("dm", "Decomposition_Mapping"),
                    ("dt", "Decomposition_Type"),
                    ("ea", "East_Asian_Width"),
                    ("eastasianwidth", "East_Asian_Width"),
                    ("ebase", "Emoji_Modifier_Base"),
                    ("ecomp", "Emoji_Component"),
                    ("emod", "Emoji_Modifier"),
                    ("emoji", "Emoji"),
                    ("emojicomponent", "Emoji_Component"),
                    ("emojimodifier", "Emoji_Modifier"),
                    ("emojimodifierbase", "Emoji_Modifier_Base"),
                    ("emojipresentation", "Emoji_Presentation"),
                    ("epres", "Emoji_Presentation"),
                    ("equideo", "Equivalent_Unified_Ideograph"),
                    ("equivalentunifiedideograph", "Equivalent_Unified_Ideograph"),
                    ("expandsonnfc", "Expands_On_NFC"),
                    ("expandsonnfd", "Expands_On_NFD"),
                    ("expandsonnfkc", "Expands_On_NFKC"),
                    ("expandsonnfkd", "Expands_On_NFKD"),
                    ("ext", "Extender"),
                    ("extendedpictographic", "Extended_Pictographic"),
                    ("extender", "Extender"),
                    ("extpict", "Extended_Pictographic"),
                    ("fcnfkc", "FC_NFKC_Closure"),
                    ("fcnfkcclosure", "FC_NFKC_Closure"),
                    ("fullcompositionexclusion", "Full_Composition_Exclusion"),
                    ("gc", "General_Category"),
                    ("gcb", "Grapheme_Cluster_Break"),
                    ("generalcategory", "General_Category"),
                    ("graphemebase", "Grapheme_Base"),
                    ("graphemeclusterbreak", "Grapheme_Cluster_Break"),
                    ("graphemeextend", "Grapheme_Extend"),
                    ("graphemelink", "Grapheme_Link"),
                    ("grbase", "Grapheme_Base"),
                    ("grext", "Grapheme_Extend"),
                    ("grlink", "Grapheme_Link"),
                    ("hangulsyllabletype", "Hangul_Syllable_Type"),
                    ("hex", "Hex_Digit"),
                    ("hexdigit", "Hex_Digit"),
                    ("hst", "Hangul_Syllable_Type"),
                    ("hyphen", "Hyphen"),
                    ("idc", "ID_Continue"),
                    ("idcompatmathcontinue", "ID_Compat_Math_Continue"),
                    ("idcompatmathstart", "ID_Compat_Math_Start"),
                    ("idcontinue", "ID_Continue"),
                    ("ideo", "Ideographic"),
                    ("ideographic", "Ideographic"),
                    ("ids", "ID_Start"),
                    ("idsb", "IDS_Binary_Operator"),
                    ("idsbinaryoperator", "IDS_Binary_Operator"),
                    ("idst", "IDS_Trinary_Operator"),
                    ("idstart", "ID_Start"),
                    ("idstrinaryoperator", "IDS_Trinary_Operator"),
                    ("idsu", "IDS_Unary_Operator"),
                    ("idsunaryoperator", "IDS_Unary_Operator"),
                    ("incb", "Indic_Conjunct_Break"),
                    ("indicconjunctbreak", "Indic_Conjunct_Break"),
                    ("indicpositionalcategory", "Indic_Positional_Category"),
                    ("indicsyllabiccategory", "Indic_Syllabic_Category"),
                    ("inpc", "Indic_Positional_Category"),
                    ("insc", "Indic_Syllabic_Category"),
                    ("isc", "ISO_Comment"),
                    ("jamoshortname", "Jamo_Short_Name"),
                    ("jg", "Joining_Group"),
                    ("joinc", "Join_Control"),
                    ("joincontrol", "Join_Control"),
                    ("joininggroup", "Joining_Group"),
                    ("joiningtype", "Joining_Type"),
                    ("jsn", "Jamo_Short_Name"),
                    ("jt", "Joining_Type"),
                    ("kaccountingnumeric", "kAccountingNumeric"),
                    ("kcompatibilityvariant", "kCompatibilityVariant"),
                    ("kehcat", "kEH_Cat"),
                    ("kehdesc", "kEH_Desc"),
                    ("kehhg", "kEH_HG"),
                    ("kehifao", "kEH_IFAO"),
                    ("kehjsesh", "kEH_JSesh"),
                    ("kehnomirror", "kEH_NoMirror"),
                    ("kehnorotate", "kEH_NoRotate"),
                    ("kiicore", "kIICore"),
                    ("kirggsource", "kIRG_GSource"),
                    ("kirghsource", "kIRG_HSource"),
                    ("kirgjsource", "kIRG_JSource"),
                    ("kirgkpsource", "kIRG_KPSource"),
                    ("kirgksource", "kIRG_KSource"),
                    ("kirgmsource", "kIRG_MSource"),
                    ("kirgssource", "kIRG_SSource"),
                    ("kirgtsource", "kIRG_TSource"),
                    ("kirguksource", "kIRG_UKSource"),
                    ("kirgusource", "kIRG_USource"),
                    ("kirgvsource", "kIRG_VSource"),
                    ("kothernumeric", "kOtherNumeric"),
                    ("kprimarynumeric", "kPrimaryNumeric"),
                    ("krsunicode", "kRSUnicode"),
                    ("lb", "Line_Break"),
                    ("lc", "Lowercase_Mapping"),
                    ("linebreak", "Line_Break"),
                    ("loe", "Logical_Order_Exception"),
                    ("logicalorderexception", "Logical_Order_Exception"),
                    ("lower", "Lowercase"),
                    ("lowercase", "Lowercase"),
                    ("lowercasemapping", "Lowercase_Mapping"),
                    ("math", "Math"),
                    ("mcm", "Modifier_Combining_Mark"),
                    ("modifiercombiningmark", "Modifier_Combining_Mark"),
                    ("na", "Name"),
                    ("na1", "Unicode_1_Name"),
                    ("name", "Name"),
                    ("namealias", "Name_Alias"),
                    ("nchar", "Noncharacter_Code_Point"),
                    ("nfcqc", "NFC_Quick_Check"),
                    ("nfcquickcheck", "NFC_Quick_Check"),
                    ("nfdqc", "NFD_Quick_Check"),
                    ("nfdquickcheck", "NFD_Quick_Check"),
                    ("nfkccasefold", "NFKC_Casefold"),
                    ("nfkccf", "NFKC_Casefold"),
                    ("nfkcqc", "NFKC_Quick_Check"),
                    ("nfkcquickcheck", "NFKC_Quick_Check"),
                    ("nfkcscf", "NFKC_Simple_Casefold"),
                    ("nfkcsimplecasefold", "NFKC_Simple_Casefold"),
                    ("nfkdqc", "NFKD_Quick_Check"),
                    ("nfkdquickcheck", "NFKD_Quick_Check"),
                    ("noncharactercodepoint", "Noncharacter_Code_Point"),
                    ("nt", "Numeric_Type"),
                    ("numerictype", "Numeric_Type"),
                    ("numericvalue", "Numeric_Value"),
                    ("nv", "Numeric_Value"),
                    ("oalpha", "Other_Alphabetic"),
                    ("ocomment", "ISO_Comment"),
                    ("odi", "Other_Default_Ignorable_Code_Point"),
                    ("ogrext", "Other_Grapheme_Extend"),
                    ("oidc", "Other_ID_Continue"),
                    ("oids", "Other_ID_Start"),
                    ("olower", "Other_Lowercase"),
                    ("omath", "Other_Math"),
                    ("otheralphabetic", "Other_Alphabetic"),
                    ("otherdefaultignorablecodepoint", "Other_Default_Ignorable_Code_Point"),
                    ("othergraphemeextend", "Other_Grapheme_Extend"),
                    ("otheridcontinue", "Other_ID_Continue"),
                    ("otheridstart", "Other_ID_Start"),
                    ("otherlowercase", "Other_Lowercase"),
                    ("othermath", "Other_Math"),
                    ("otheruppercase", "Other_Uppercase"),
                    ("oupper", "Other_Uppercase"),
                    ("patsyn", "Pattern_Syntax"),
                    ("patternsyntax", "Pattern_Syntax"),
                    ("patternwhitespace", "Pattern_White_Space"),
                    ("patws", "Pattern_White_Space"),
                    ("pcm", "Prepended_Concatenation_Mark"),
                    ("prependedconcatenationmark", "Prepended_Concatenation_Mark"),
                    ("qmark", "Quotation_Mark"),
                    ("quotationmark", "Quotation_Mark"),
                    ("radical", "Radical"),
                    ("regionalindicator", "Regional_Indicator"),
                    ("ri", "Regional_Indicator"),
                    ("sb", "Sentence_Break"),
                    ("sc", "Script"),
                    ("scf", "Simple_Case_Folding"),
                    ("script", "Script"),
                    ("scriptextensions", "Script_Extensions"),
                    ("scx", "Script_Extensions"),
                    ("sd", "Soft_Dotted"),
                    ("sentencebreak", "Sentence_Break"),
                    ("sentenceterminal", "Sentence_Terminal"),
                    ("sfc", "Simple_Case_Folding"),
                    ("simplecasefolding", "Simple_Case_Folding"),
                    ("simplelowercasemapping", "Simple_Lowercase_Mapping"),
                    ("simpletitlecasemapping", "Simple_Titlecase_Mapping"),
                    ("simpleuppercasemapping", "Simple_Uppercase_Mapping"),
                    ("slc", "Simple_Lowercase_Mapping"),
                    ("softdotted", "Soft_Dotted"),
                    ("space", "White_Space"),
                    ("stc", "Simple_Titlecase_Mapping"),
                    ("sterm", "Sentence_Terminal"),
                    ("suc", "Simple_Uppercase_Mapping"),
                    ("tc", "Titlecase_Mapping"),
                    ("term", "Terminal_Punctuation"),
                    ("terminalpunctuation", "Terminal_Punctuation"),
                    ("titlecasemapping", "Titlecase_Mapping"),
                    ("uc", "Uppercase_Mapping"),
                    ("uideo", "Unified_Ideograph"),
                    ("unicode1name", "Unicode_1_Name"),
                    ("unicoderadicalstroke", "kRSUnicode"),
                    ("unifiedideograph", "Unified_Ideograph"),
                    ("upper", "Uppercase"),
                    ("uppercase", "Uppercase"),
                    ("uppercasemapping", "Uppercase_Mapping"),
                    ("urs", "kRSUnicode"),
                    ("variationselector", "Variation_Selector"),
                    ("verticalorientation", "Vertical_Orientation"),
                    ("vo", "Vertical_Orientation"),
                    ("vs", "Variation_Selector"),
                    ("wb", "Word_Break"),
                    ("whitespace", "White_Space"),
                    ("wordbreak", "Word_Break"),
                    ("wspace", "White_Space"),
                    ("xidc", "XID_Continue"),
                    ("xidcontinue", "XID_Continue"),
                    ("xids", "XID_Start"),
                    ("xidstart", "XID_Start"),
                    ("xonfc", "Expands_On_NFC"),
                    ("xonfd", "Expands_On_NFD"),
                    ("xonfkc", "Expands_On_NFKC"),
                    ("xonfkd", "Expands_On_NFKD"),
                ];
            }

            pub mod property_values
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const PROPERTY_VALUES: &'static [(
                    &'static str,
                    &'static [(&'static str, &'static str)],
                )] = &[
                    (
                        "Age",
                        &[
                            ("1.1", "V1_1"),
                            ("10.0", "V10_0"),
                            ("11.0", "V11_0"),
                            ("12.0", "V12_0"),
                            ("12.1", "V12_1"),
                            ("13.0", "V13_0"),
                            ("14.0", "V14_0"),
                            ("15.0", "V15_0"),
                            ("15.1", "V15_1"),
                            ("16.0", "V16_0"),
                            ("2.0", "V2_0"),
                            ("2.1", "V2_1"),
                            ("3.0", "V3_0"),
                            ("3.1", "V3_1"),
                            ("3.2", "V3_2"),
                            ("4.0", "V4_0"),
                            ("4.1", "V4_1"),
                            ("5.0", "V5_0"),
                            ("5.1", "V5_1"),
                            ("5.2", "V5_2"),
                            ("6.0", "V6_0"),
                            ("6.1", "V6_1"),
                            ("6.2", "V6_2"),
                            ("6.3", "V6_3"),
                            ("7.0", "V7_0"),
                            ("8.0", "V8_0"),
                            ("9.0", "V9_0"),
                            ("na", "Unassigned"),
                            ("unassigned", "Unassigned"),
                            ("v100", "V10_0"),
                            ("v11", "V1_1"),
                            ("v110", "V11_0"),
                            ("v120", "V12_0"),
                            ("v121", "V12_1"),
                            ("v130", "V13_0"),
                            ("v140", "V14_0"),
                            ("v150", "V15_0"),
                            ("v151", "V15_1"),
                            ("v160", "V16_0"),
                            ("v20", "V2_0"),
                            ("v21", "V2_1"),
                            ("v30", "V3_0"),
                            ("v31", "V3_1"),
                            ("v32", "V3_2"),
                            ("v40", "V4_0"),
                            ("v41", "V4_1"),
                            ("v50", "V5_0"),
                            ("v51", "V5_1"),
                            ("v52", "V5_2"),
                            ("v60", "V6_0"),
                            ("v61", "V6_1"),
                            ("v62", "V6_2"),
                            ("v63", "V6_3"),
                            ("v70", "V7_0"),
                            ("v80", "V8_0"),
                            ("v90", "V9_0"),
                        ],
                    ),
                    (
                        "General_Category",
                        &[
                            ("c", "Other"),
                            ("casedletter", "Cased_Letter"),
                            ("cc", "Control"),
                            ("cf", "Format"),
                            ("closepunctuation", "Close_Punctuation"),
                            ("cn", "Unassigned"),
                            ("cntrl", "Control"),
                            ("co", "Private_Use"),
                            ("combiningmark", "Mark"),
                            ("connectorpunctuation", "Connector_Punctuation"),
                            ("control", "Control"),
                            ("cs", "Surrogate"),
                            ("currencysymbol", "Currency_Symbol"),
                            ("dashpunctuation", "Dash_Punctuation"),
                            ("decimalnumber", "Decimal_Number"),
                            ("digit", "Decimal_Number"),
                            ("enclosingmark", "Enclosing_Mark"),
                            ("finalpunctuation", "Final_Punctuation"),
                            ("format", "Format"),
                            ("initialpunctuation", "Initial_Punctuation"),
                            ("l", "Letter"),
                            ("lc", "Cased_Letter"),
                            ("letter", "Letter"),
                            ("letternumber", "Letter_Number"),
                            ("lineseparator", "Line_Separator"),
                            ("ll", "Lowercase_Letter"),
                            ("lm", "Modifier_Letter"),
                            ("lo", "Other_Letter"),
                            ("lowercaseletter", "Lowercase_Letter"),
                            ("lt", "Titlecase_Letter"),
                            ("lu", "Uppercase_Letter"),
                            ("m", "Mark"),
                            ("mark", "Mark"),
                            ("mathsymbol", "Math_Symbol"),
                            ("mc", "Spacing_Mark"),
                            ("me", "Enclosing_Mark"),
                            ("mn", "Nonspacing_Mark"),
                            ("modifierletter", "Modifier_Letter"),
                            ("modifiersymbol", "Modifier_Symbol"),
                            ("n", "Number"),
                            ("nd", "Decimal_Number"),
                            ("nl", "Letter_Number"),
                            ("no", "Other_Number"),
                            ("nonspacingmark", "Nonspacing_Mark"),
                            ("number", "Number"),
                            ("openpunctuation", "Open_Punctuation"),
                            ("other", "Other"),
                            ("otherletter", "Other_Letter"),
                            ("othernumber", "Other_Number"),
                            ("otherpunctuation", "Other_Punctuation"),
                            ("othersymbol", "Other_Symbol"),
                            ("p", "Punctuation"),
                            ("paragraphseparator", "Paragraph_Separator"),
                            ("pc", "Connector_Punctuation"),
                            ("pd", "Dash_Punctuation"),
                            ("pe", "Close_Punctuation"),
                            ("pf", "Final_Punctuation"),
                            ("pi", "Initial_Punctuation"),
                            ("po", "Other_Punctuation"),
                            ("privateuse", "Private_Use"),
                            ("ps", "Open_Punctuation"),
                            ("punct", "Punctuation"),
                            ("punctuation", "Punctuation"),
                            ("s", "Symbol"),
                            ("sc", "Currency_Symbol"),
                            ("separator", "Separator"),
                            ("sk", "Modifier_Symbol"),
                            ("sm", "Math_Symbol"),
                            ("so", "Other_Symbol"),
                            ("spaceseparator", "Space_Separator"),
                            ("spacingmark", "Spacing_Mark"),
                            ("surrogate", "Surrogate"),
                            ("symbol", "Symbol"),
                            ("titlecaseletter", "Titlecase_Letter"),
                            ("unassigned", "Unassigned"),
                            ("uppercaseletter", "Uppercase_Letter"),
                            ("z", "Separator"),
                            ("zl", "Line_Separator"),
                            ("zp", "Paragraph_Separator"),
                            ("zs", "Space_Separator"),
                        ],
                    ),
                    (
                        "Grapheme_Cluster_Break",
                        &[
                            ("cn", "Control"),
                            ("control", "Control"),
                            ("cr", "CR"),
                            ("eb", "E_Base"),
                            ("ebase", "E_Base"),
                            ("ebasegaz", "E_Base_GAZ"),
                            ("ebg", "E_Base_GAZ"),
                            ("em", "E_Modifier"),
                            ("emodifier", "E_Modifier"),
                            ("ex", "Extend"),
                            ("extend", "Extend"),
                            ("gaz", "Glue_After_Zwj"),
                            ("glueafterzwj", "Glue_After_Zwj"),
                            ("l", "L"),
                            ("lf", "LF"),
                            ("lv", "LV"),
                            ("lvt", "LVT"),
                            ("other", "Other"),
                            ("pp", "Prepend"),
                            ("prepend", "Prepend"),
                            ("regionalindicator", "Regional_Indicator"),
                            ("ri", "Regional_Indicator"),
                            ("sm", "SpacingMark"),
                            ("spacingmark", "SpacingMark"),
                            ("t", "T"),
                            ("v", "V"),
                            ("xx", "Other"),
                            ("zwj", "ZWJ"),
                        ],
                    ),
                    (
                        "Script",
                        &[
                            ("adlam", "Adlam"),
                            ("adlm", "Adlam"),
                            ("aghb", "Caucasian_Albanian"),
                            ("ahom", "Ahom"),
                            ("anatolianhieroglyphs", "Anatolian_Hieroglyphs"),
                            ("arab", "Arabic"),
                            ("arabic", "Arabic"),
                            ("armenian", "Armenian"),
                            ("armi", "Imperial_Aramaic"),
                            ("armn", "Armenian"),
                            ("avestan", "Avestan"),
                            ("avst", "Avestan"),
                            ("bali", "Balinese"),
                            ("balinese", "Balinese"),
                            ("bamu", "Bamum"),
                            ("bamum", "Bamum"),
                            ("bass", "Bassa_Vah"),
                            ("bassavah", "Bassa_Vah"),
                            ("batak", "Batak"),
                            ("batk", "Batak"),
                            ("beng", "Bengali"),
                            ("bengali", "Bengali"),
                            ("bhaiksuki", "Bhaiksuki"),
                            ("bhks", "Bhaiksuki"),
                            ("bopo", "Bopomofo"),
                            ("bopomofo", "Bopomofo"),
                            ("brah", "Brahmi"),
                            ("brahmi", "Brahmi"),
                            ("brai", "Braille"),
                            ("braille", "Braille"),
                            ("bugi", "Buginese"),
                            ("buginese", "Buginese"),
                            ("buhd", "Buhid"),
                            ("buhid", "Buhid"),
                            ("cakm", "Chakma"),
                            ("canadianaboriginal", "Canadian_Aboriginal"),
                            ("cans", "Canadian_Aboriginal"),
                            ("cari", "Carian"),
                            ("carian", "Carian"),
                            ("caucasianalbanian", "Caucasian_Albanian"),
                            ("chakma", "Chakma"),
                            ("cham", "Cham"),
                            ("cher", "Cherokee"),
                            ("cherokee", "Cherokee"),
                            ("chorasmian", "Chorasmian"),
                            ("chrs", "Chorasmian"),
                            ("common", "Common"),
                            ("copt", "Coptic"),
                            ("coptic", "Coptic"),
                            ("cpmn", "Cypro_Minoan"),
                            ("cprt", "Cypriot"),
                            ("cuneiform", "Cuneiform"),
                            ("cypriot", "Cypriot"),
                            ("cyprominoan", "Cypro_Minoan"),
                            ("cyrillic", "Cyrillic"),
                            ("cyrl", "Cyrillic"),
                            ("deseret", "Deseret"),
                            ("deva", "Devanagari"),
                            ("devanagari", "Devanagari"),
                            ("diak", "Dives_Akuru"),
                            ("divesakuru", "Dives_Akuru"),
                            ("dogr", "Dogra"),
                            ("dogra", "Dogra"),
                            ("dsrt", "Deseret"),
                            ("dupl", "Duployan"),
                            ("duployan", "Duployan"),
                            ("egyp", "Egyptian_Hieroglyphs"),
                            ("egyptianhieroglyphs", "Egyptian_Hieroglyphs"),
                            ("elba", "Elbasan"),
                            ("elbasan", "Elbasan"),
                            ("elym", "Elymaic"),
                            ("elymaic", "Elymaic"),
                            ("ethi", "Ethiopic"),
                            ("ethiopic", "Ethiopic"),
                            ("gara", "Garay"),
                            ("garay", "Garay"),
                            ("geor", "Georgian"),
                            ("georgian", "Georgian"),
                            ("glag", "Glagolitic"),
                            ("glagolitic", "Glagolitic"),
                            ("gong", "Gunjala_Gondi"),
                            ("gonm", "Masaram_Gondi"),
                            ("goth", "Gothic"),
                            ("gothic", "Gothic"),
                            ("gran", "Grantha"),
                            ("grantha", "Grantha"),
                            ("greek", "Greek"),
                            ("grek", "Greek"),
                            ("gujarati", "Gujarati"),
                            ("gujr", "Gujarati"),
                            ("gukh", "Gurung_Khema"),
                            ("gunjalagondi", "Gunjala_Gondi"),
                            ("gurmukhi", "Gurmukhi"),
                            ("guru", "Gurmukhi"),
                            ("gurungkhema", "Gurung_Khema"),
                            ("han", "Han"),
                            ("hang", "Hangul"),
                            ("hangul", "Hangul"),
                            ("hani", "Han"),
                            ("hanifirohingya", "Hanifi_Rohingya"),
                            ("hano", "Hanunoo"),
                            ("hanunoo", "Hanunoo"),
                            ("hatr", "Hatran"),
                            ("hatran", "Hatran"),
                            ("hebr", "Hebrew"),
                            ("hebrew", "Hebrew"),
                            ("hira", "Hiragana"),
                            ("hiragana", "Hiragana"),
                            ("hluw", "Anatolian_Hieroglyphs"),
                            ("hmng", "Pahawh_Hmong"),
                            ("hmnp", "Nyiakeng_Puachue_Hmong"),
                            ("hrkt", "Katakana_Or_Hiragana"),
                            ("hung", "Old_Hungarian"),
                            ("imperialaramaic", "Imperial_Aramaic"),
                            ("inherited", "Inherited"),
                            ("inscriptionalpahlavi", "Inscriptional_Pahlavi"),
                            ("inscriptionalparthian", "Inscriptional_Parthian"),
                            ("ital", "Old_Italic"),
                            ("java", "Javanese"),
                            ("javanese", "Javanese"),
                            ("kaithi", "Kaithi"),
                            ("kali", "Kayah_Li"),
                            ("kana", "Katakana"),
                            ("kannada", "Kannada"),
                            ("katakana", "Katakana"),
                            ("katakanaorhiragana", "Katakana_Or_Hiragana"),
                            ("kawi", "Kawi"),
                            ("kayahli", "Kayah_Li"),
                            ("khar", "Kharoshthi"),
                            ("kharoshthi", "Kharoshthi"),
                            ("khitansmallscript", "Khitan_Small_Script"),
                            ("khmer", "Khmer"),
                            ("khmr", "Khmer"),
                            ("khoj", "Khojki"),
                            ("khojki", "Khojki"),
                            ("khudawadi", "Khudawadi"),
                            ("kiratrai", "Kirat_Rai"),
                            ("kits", "Khitan_Small_Script"),
                            ("knda", "Kannada"),
                            ("krai", "Kirat_Rai"),
                            ("kthi", "Kaithi"),
                            ("lana", "Tai_Tham"),
                            ("lao", "Lao"),
                            ("laoo", "Lao"),
                            ("latin", "Latin"),
                            ("latn", "Latin"),
                            ("lepc", "Lepcha"),
                            ("lepcha", "Lepcha"),
                            ("limb", "Limbu"),
                            ("limbu", "Limbu"),
                            ("lina", "Linear_A"),
                            ("linb", "Linear_B"),
                            ("lineara", "Linear_A"),
                            ("linearb", "Linear_B"),
                            ("lisu", "Lisu"),
                            ("lyci", "Lycian"),
                            ("lycian", "Lycian"),
                            ("lydi", "Lydian"),
                            ("lydian", "Lydian"),
                            ("mahajani", "Mahajani"),
                            ("mahj", "Mahajani"),
                            ("maka", "Makasar"),
                            ("makasar", "Makasar"),
                            ("malayalam", "Malayalam"),
                            ("mand", "Mandaic"),
                            ("mandaic", "Mandaic"),
                            ("mani", "Manichaean"),
                            ("manichaean", "Manichaean"),
                            ("marc", "Marchen"),
                            ("marchen", "Marchen"),
                            ("masaramgondi", "Masaram_Gondi"),
                            ("medefaidrin", "Medefaidrin"),
                            ("medf", "Medefaidrin"),
                            ("meeteimayek", "Meetei_Mayek"),
                            ("mend", "Mende_Kikakui"),
                            ("mendekikakui", "Mende_Kikakui"),
                            ("merc", "Meroitic_Cursive"),
                            ("mero", "Meroitic_Hieroglyphs"),
                            ("meroiticcursive", "Meroitic_Cursive"),
                            ("meroitichieroglyphs", "Meroitic_Hieroglyphs"),
                            ("miao", "Miao"),
                            ("mlym", "Malayalam"),
                            ("modi", "Modi"),
                            ("mong", "Mongolian"),
                            ("mongolian", "Mongolian"),
                            ("mro", "Mro"),
                            ("mroo", "Mro"),
                            ("mtei", "Meetei_Mayek"),
                            ("mult", "Multani"),
                            ("multani", "Multani"),
                            ("myanmar", "Myanmar"),
                            ("mymr", "Myanmar"),
                            ("nabataean", "Nabataean"),
                            ("nagm", "Nag_Mundari"),
                            ("nagmundari", "Nag_Mundari"),
                            ("nand", "Nandinagari"),
                            ("nandinagari", "Nandinagari"),
                            ("narb", "Old_North_Arabian"),
                            ("nbat", "Nabataean"),
                            ("newa", "Newa"),
                            ("newtailue", "New_Tai_Lue"),
                            ("nko", "Nko"),
                            ("nkoo", "Nko"),
                            ("nshu", "Nushu"),
                            ("nushu", "Nushu"),
                            ("nyiakengpuachuehmong", "Nyiakeng_Puachue_Hmong"),
                            ("ogam", "Ogham"),
                            ("ogham", "Ogham"),
                            ("olchiki", "Ol_Chiki"),
                            ("olck", "Ol_Chiki"),
                            ("oldhungarian", "Old_Hungarian"),
                            ("olditalic", "Old_Italic"),
                            ("oldnortharabian", "Old_North_Arabian"),
                            ("oldpermic", "Old_Permic"),
                            ("oldpersian", "Old_Persian"),
                            ("oldsogdian", "Old_Sogdian"),
                            ("oldsoutharabian", "Old_South_Arabian"),
                            ("oldturkic", "Old_Turkic"),
                            ("olduyghur", "Old_Uyghur"),
                            ("olonal", "Ol_Onal"),
                            ("onao", "Ol_Onal"),
                            ("oriya", "Oriya"),
                            ("orkh", "Old_Turkic"),
                            ("orya", "Oriya"),
                            ("osage", "Osage"),
                            ("osge", "Osage"),
                            ("osma", "Osmanya"),
                            ("osmanya", "Osmanya"),
                            ("ougr", "Old_Uyghur"),
                            ("pahawhhmong", "Pahawh_Hmong"),
                            ("palm", "Palmyrene"),
                            ("palmyrene", "Palmyrene"),
                            ("pauc", "Pau_Cin_Hau"),
                            ("paucinhau", "Pau_Cin_Hau"),
                            ("perm", "Old_Permic"),
                            ("phag", "Phags_Pa"),
                            ("phagspa", "Phags_Pa"),
                            ("phli", "Inscriptional_Pahlavi"),
                            ("phlp", "Psalter_Pahlavi"),
                            ("phnx", "Phoenician"),
                            ("phoenician", "Phoenician"),
                            ("plrd", "Miao"),
                            ("prti", "Inscriptional_Parthian"),
                            ("psalterpahlavi", "Psalter_Pahlavi"),
                            ("qaac", "Coptic"),
                            ("qaai", "Inherited"),
                            ("rejang", "Rejang"),
                            ("rjng", "Rejang"),
                            ("rohg", "Hanifi_Rohingya"),
                            ("runic", "Runic"),
                            ("runr", "Runic"),
                            ("samaritan", "Samaritan"),
                            ("samr", "Samaritan"),
                            ("sarb", "Old_South_Arabian"),
                            ("saur", "Saurashtra"),
                            ("saurashtra", "Saurashtra"),
                            ("sgnw", "SignWriting"),
                            ("sharada", "Sharada"),
                            ("shavian", "Shavian"),
                            ("shaw", "Shavian"),
                            ("shrd", "Sharada"),
                            ("sidd", "Siddham"),
                            ("siddham", "Siddham"),
                            ("signwriting", "SignWriting"),
                            ("sind", "Khudawadi"),
                            ("sinh", "Sinhala"),
                            ("sinhala", "Sinhala"),
                            ("sogd", "Sogdian"),
                            ("sogdian", "Sogdian"),
                            ("sogo", "Old_Sogdian"),
                            ("sora", "Sora_Sompeng"),
                            ("sorasompeng", "Sora_Sompeng"),
                            ("soyo", "Soyombo"),
                            ("soyombo", "Soyombo"),
                            ("sund", "Sundanese"),
                            ("sundanese", "Sundanese"),
                            ("sunu", "Sunuwar"),
                            ("sunuwar", "Sunuwar"),
                            ("sylo", "Syloti_Nagri"),
                            ("sylotinagri", "Syloti_Nagri"),
                            ("syrc", "Syriac"),
                            ("syriac", "Syriac"),
                            ("tagalog", "Tagalog"),
                            ("tagb", "Tagbanwa"),
                            ("tagbanwa", "Tagbanwa"),
                            ("taile", "Tai_Le"),
                            ("taitham", "Tai_Tham"),
                            ("taiviet", "Tai_Viet"),
                            ("takr", "Takri"),
                            ("takri", "Takri"),
                            ("tale", "Tai_Le"),
                            ("talu", "New_Tai_Lue"),
                            ("tamil", "Tamil"),
                            ("taml", "Tamil"),
                            ("tang", "Tangut"),
                            ("tangsa", "Tangsa"),
                            ("tangut", "Tangut"),
                            ("tavt", "Tai_Viet"),
                            ("telu", "Telugu"),
                            ("telugu", "Telugu"),
                            ("tfng", "Tifinagh"),
                            ("tglg", "Tagalog"),
                            ("thaa", "Thaana"),
                            ("thaana", "Thaana"),
                            ("thai", "Thai"),
                            ("tibetan", "Tibetan"),
                            ("tibt", "Tibetan"),
                            ("tifinagh", "Tifinagh"),
                            ("tirh", "Tirhuta"),
                            ("tirhuta", "Tirhuta"),
                            ("tnsa", "Tangsa"),
                            ("todhri", "Todhri"),
                            ("todr", "Todhri"),
                            ("toto", "Toto"),
                            ("tulutigalari", "Tulu_Tigalari"),
                            ("tutg", "Tulu_Tigalari"),
                            ("ugar", "Ugaritic"),
                            ("ugaritic", "Ugaritic"),
                            ("unknown", "Unknown"),
                            ("vai", "Vai"),
                            ("vaii", "Vai"),
                            ("vith", "Vithkuqi"),
                            ("vithkuqi", "Vithkuqi"),
                            ("wancho", "Wancho"),
                            ("wara", "Warang_Citi"),
                            ("warangciti", "Warang_Citi"),
                            ("wcho", "Wancho"),
                            ("xpeo", "Old_Persian"),
                            ("xsux", "Cuneiform"),
                            ("yezi", "Yezidi"),
                            ("yezidi", "Yezidi"),
                            ("yi", "Yi"),
                            ("yiii", "Yi"),
                            ("zanabazarsquare", "Zanabazar_Square"),
                            ("zanb", "Zanabazar_Square"),
                            ("zinh", "Inherited"),
                            ("zyyy", "Common"),
                            ("zzzz", "Unknown"),
                        ],
                    ),
                    (
                        "Script_Extensions",
                        &[
                            ("adlam", "Adlam"),
                            ("adlm", "Adlam"),
                            ("aghb", "Caucasian_Albanian"),
                            ("ahom", "Ahom"),
                            ("anatolianhieroglyphs", "Anatolian_Hieroglyphs"),
                            ("arab", "Arabic"),
                            ("arabic", "Arabic"),
                            ("armenian", "Armenian"),
                            ("armi", "Imperial_Aramaic"),
                            ("armn", "Armenian"),
                            ("avestan", "Avestan"),
                            ("avst", "Avestan"),
                            ("bali", "Balinese"),
                            ("balinese", "Balinese"),
                            ("bamu", "Bamum"),
                            ("bamum", "Bamum"),
                            ("bass", "Bassa_Vah"),
                            ("bassavah", "Bassa_Vah"),
                            ("batak", "Batak"),
                            ("batk", "Batak"),
                            ("beng", "Bengali"),
                            ("bengali", "Bengali"),
                            ("bhaiksuki", "Bhaiksuki"),
                            ("bhks", "Bhaiksuki"),
                            ("bopo", "Bopomofo"),
                            ("bopomofo", "Bopomofo"),
                            ("brah", "Brahmi"),
                            ("brahmi", "Brahmi"),
                            ("brai", "Braille"),
                            ("braille", "Braille"),
                            ("bugi", "Buginese"),
                            ("buginese", "Buginese"),
                            ("buhd", "Buhid"),
                            ("buhid", "Buhid"),
                            ("cakm", "Chakma"),
                            ("canadianaboriginal", "Canadian_Aboriginal"),
                            ("cans", "Canadian_Aboriginal"),
                            ("cari", "Carian"),
                            ("carian", "Carian"),
                            ("caucasianalbanian", "Caucasian_Albanian"),
                            ("chakma", "Chakma"),
                            ("cham", "Cham"),
                            ("cher", "Cherokee"),
                            ("cherokee", "Cherokee"),
                            ("chorasmian", "Chorasmian"),
                            ("chrs", "Chorasmian"),
                            ("common", "Common"),
                            ("copt", "Coptic"),
                            ("coptic", "Coptic"),
                            ("cpmn", "Cypro_Minoan"),
                            ("cprt", "Cypriot"),
                            ("cuneiform", "Cuneiform"),
                            ("cypriot", "Cypriot"),
                            ("cyprominoan", "Cypro_Minoan"),
                            ("cyrillic", "Cyrillic"),
                            ("cyrl", "Cyrillic"),
                            ("deseret", "Deseret"),
                            ("deva", "Devanagari"),
                            ("devanagari", "Devanagari"),
                            ("diak", "Dives_Akuru"),
                            ("divesakuru", "Dives_Akuru"),
                            ("dogr", "Dogra"),
                            ("dogra", "Dogra"),
                            ("dsrt", "Deseret"),
                            ("dupl", "Duployan"),
                            ("duployan", "Duployan"),
                            ("egyp", "Egyptian_Hieroglyphs"),
                            ("egyptianhieroglyphs", "Egyptian_Hieroglyphs"),
                            ("elba", "Elbasan"),
                            ("elbasan", "Elbasan"),
                            ("elym", "Elymaic"),
                            ("elymaic", "Elymaic"),
                            ("ethi", "Ethiopic"),
                            ("ethiopic", "Ethiopic"),
                            ("gara", "Garay"),
                            ("garay", "Garay"),
                            ("geor", "Georgian"),
                            ("georgian", "Georgian"),
                            ("glag", "Glagolitic"),
                            ("glagolitic", "Glagolitic"),
                            ("gong", "Gunjala_Gondi"),
                            ("gonm", "Masaram_Gondi"),
                            ("goth", "Gothic"),
                            ("gothic", "Gothic"),
                            ("gran", "Grantha"),
                            ("grantha", "Grantha"),
                            ("greek", "Greek"),
                            ("grek", "Greek"),
                            ("gujarati", "Gujarati"),
                            ("gujr", "Gujarati"),
                            ("gukh", "Gurung_Khema"),
                            ("gunjalagondi", "Gunjala_Gondi"),
                            ("gurmukhi", "Gurmukhi"),
                            ("guru", "Gurmukhi"),
                            ("gurungkhema", "Gurung_Khema"),
                            ("han", "Han"),
                            ("hang", "Hangul"),
                            ("hangul", "Hangul"),
                            ("hani", "Han"),
                            ("hanifirohingya", "Hanifi_Rohingya"),
                            ("hano", "Hanunoo"),
                            ("hanunoo", "Hanunoo"),
                            ("hatr", "Hatran"),
                            ("hatran", "Hatran"),
                            ("hebr", "Hebrew"),
                            ("hebrew", "Hebrew"),
                            ("hira", "Hiragana"),
                            ("hiragana", "Hiragana"),
                            ("hluw", "Anatolian_Hieroglyphs"),
                            ("hmng", "Pahawh_Hmong"),
                            ("hmnp", "Nyiakeng_Puachue_Hmong"),
                            ("hrkt", "Katakana_Or_Hiragana"),
                            ("hung", "Old_Hungarian"),
                            ("imperialaramaic", "Imperial_Aramaic"),
                            ("inherited", "Inherited"),
                            ("inscriptionalpahlavi", "Inscriptional_Pahlavi"),
                            ("inscriptionalparthian", "Inscriptional_Parthian"),
                            ("ital", "Old_Italic"),
                            ("java", "Javanese"),
                            ("javanese", "Javanese"),
                            ("kaithi", "Kaithi"),
                            ("kali", "Kayah_Li"),
                            ("kana", "Katakana"),
                            ("kannada", "Kannada"),
                            ("katakana", "Katakana"),
                            ("katakanaorhiragana", "Katakana_Or_Hiragana"),
                            ("kawi", "Kawi"),
                            ("kayahli", "Kayah_Li"),
                            ("khar", "Kharoshthi"),
                            ("kharoshthi", "Kharoshthi"),
                            ("khitansmallscript", "Khitan_Small_Script"),
                            ("khmer", "Khmer"),
                            ("khmr", "Khmer"),
                            ("khoj", "Khojki"),
                            ("khojki", "Khojki"),
                            ("khudawadi", "Khudawadi"),
                            ("kiratrai", "Kirat_Rai"),
                            ("kits", "Khitan_Small_Script"),
                            ("knda", "Kannada"),
                            ("krai", "Kirat_Rai"),
                            ("kthi", "Kaithi"),
                            ("lana", "Tai_Tham"),
                            ("lao", "Lao"),
                            ("laoo", "Lao"),
                            ("latin", "Latin"),
                            ("latn", "Latin"),
                            ("lepc", "Lepcha"),
                            ("lepcha", "Lepcha"),
                            ("limb", "Limbu"),
                            ("limbu", "Limbu"),
                            ("lina", "Linear_A"),
                            ("linb", "Linear_B"),
                            ("lineara", "Linear_A"),
                            ("linearb", "Linear_B"),
                            ("lisu", "Lisu"),
                            ("lyci", "Lycian"),
                            ("lycian", "Lycian"),
                            ("lydi", "Lydian"),
                            ("lydian", "Lydian"),
                            ("mahajani", "Mahajani"),
                            ("mahj", "Mahajani"),
                            ("maka", "Makasar"),
                            ("makasar", "Makasar"),
                            ("malayalam", "Malayalam"),
                            ("mand", "Mandaic"),
                            ("mandaic", "Mandaic"),
                            ("mani", "Manichaean"),
                            ("manichaean", "Manichaean"),
                            ("marc", "Marchen"),
                            ("marchen", "Marchen"),
                            ("masaramgondi", "Masaram_Gondi"),
                            ("medefaidrin", "Medefaidrin"),
                            ("medf", "Medefaidrin"),
                            ("meeteimayek", "Meetei_Mayek"),
                            ("mend", "Mende_Kikakui"),
                            ("mendekikakui", "Mende_Kikakui"),
                            ("merc", "Meroitic_Cursive"),
                            ("mero", "Meroitic_Hieroglyphs"),
                            ("meroiticcursive", "Meroitic_Cursive"),
                            ("meroitichieroglyphs", "Meroitic_Hieroglyphs"),
                            ("miao", "Miao"),
                            ("mlym", "Malayalam"),
                            ("modi", "Modi"),
                            ("mong", "Mongolian"),
                            ("mongolian", "Mongolian"),
                            ("mro", "Mro"),
                            ("mroo", "Mro"),
                            ("mtei", "Meetei_Mayek"),
                            ("mult", "Multani"),
                            ("multani", "Multani"),
                            ("myanmar", "Myanmar"),
                            ("mymr", "Myanmar"),
                            ("nabataean", "Nabataean"),
                            ("nagm", "Nag_Mundari"),
                            ("nagmundari", "Nag_Mundari"),
                            ("nand", "Nandinagari"),
                            ("nandinagari", "Nandinagari"),
                            ("narb", "Old_North_Arabian"),
                            ("nbat", "Nabataean"),
                            ("newa", "Newa"),
                            ("newtailue", "New_Tai_Lue"),
                            ("nko", "Nko"),
                            ("nkoo", "Nko"),
                            ("nshu", "Nushu"),
                            ("nushu", "Nushu"),
                            ("nyiakengpuachuehmong", "Nyiakeng_Puachue_Hmong"),
                            ("ogam", "Ogham"),
                            ("ogham", "Ogham"),
                            ("olchiki", "Ol_Chiki"),
                            ("olck", "Ol_Chiki"),
                            ("oldhungarian", "Old_Hungarian"),
                            ("olditalic", "Old_Italic"),
                            ("oldnortharabian", "Old_North_Arabian"),
                            ("oldpermic", "Old_Permic"),
                            ("oldpersian", "Old_Persian"),
                            ("oldsogdian", "Old_Sogdian"),
                            ("oldsoutharabian", "Old_South_Arabian"),
                            ("oldturkic", "Old_Turkic"),
                            ("olduyghur", "Old_Uyghur"),
                            ("olonal", "Ol_Onal"),
                            ("onao", "Ol_Onal"),
                            ("oriya", "Oriya"),
                            ("orkh", "Old_Turkic"),
                            ("orya", "Oriya"),
                            ("osage", "Osage"),
                            ("osge", "Osage"),
                            ("osma", "Osmanya"),
                            ("osmanya", "Osmanya"),
                            ("ougr", "Old_Uyghur"),
                            ("pahawhhmong", "Pahawh_Hmong"),
                            ("palm", "Palmyrene"),
                            ("palmyrene", "Palmyrene"),
                            ("pauc", "Pau_Cin_Hau"),
                            ("paucinhau", "Pau_Cin_Hau"),
                            ("perm", "Old_Permic"),
                            ("phag", "Phags_Pa"),
                            ("phagspa", "Phags_Pa"),
                            ("phli", "Inscriptional_Pahlavi"),
                            ("phlp", "Psalter_Pahlavi"),
                            ("phnx", "Phoenician"),
                            ("phoenician", "Phoenician"),
                            ("plrd", "Miao"),
                            ("prti", "Inscriptional_Parthian"),
                            ("psalterpahlavi", "Psalter_Pahlavi"),
                            ("qaac", "Coptic"),
                            ("qaai", "Inherited"),
                            ("rejang", "Rejang"),
                            ("rjng", "Rejang"),
                            ("rohg", "Hanifi_Rohingya"),
                            ("runic", "Runic"),
                            ("runr", "Runic"),
                            ("samaritan", "Samaritan"),
                            ("samr", "Samaritan"),
                            ("sarb", "Old_South_Arabian"),
                            ("saur", "Saurashtra"),
                            ("saurashtra", "Saurashtra"),
                            ("sgnw", "SignWriting"),
                            ("sharada", "Sharada"),
                            ("shavian", "Shavian"),
                            ("shaw", "Shavian"),
                            ("shrd", "Sharada"),
                            ("sidd", "Siddham"),
                            ("siddham", "Siddham"),
                            ("signwriting", "SignWriting"),
                            ("sind", "Khudawadi"),
                            ("sinh", "Sinhala"),
                            ("sinhala", "Sinhala"),
                            ("sogd", "Sogdian"),
                            ("sogdian", "Sogdian"),
                            ("sogo", "Old_Sogdian"),
                            ("sora", "Sora_Sompeng"),
                            ("sorasompeng", "Sora_Sompeng"),
                            ("soyo", "Soyombo"),
                            ("soyombo", "Soyombo"),
                            ("sund", "Sundanese"),
                            ("sundanese", "Sundanese"),
                            ("sunu", "Sunuwar"),
                            ("sunuwar", "Sunuwar"),
                            ("sylo", "Syloti_Nagri"),
                            ("sylotinagri", "Syloti_Nagri"),
                            ("syrc", "Syriac"),
                            ("syriac", "Syriac"),
                            ("tagalog", "Tagalog"),
                            ("tagb", "Tagbanwa"),
                            ("tagbanwa", "Tagbanwa"),
                            ("taile", "Tai_Le"),
                            ("taitham", "Tai_Tham"),
                            ("taiviet", "Tai_Viet"),
                            ("takr", "Takri"),
                            ("takri", "Takri"),
                            ("tale", "Tai_Le"),
                            ("talu", "New_Tai_Lue"),
                            ("tamil", "Tamil"),
                            ("taml", "Tamil"),
                            ("tang", "Tangut"),
                            ("tangsa", "Tangsa"),
                            ("tangut", "Tangut"),
                            ("tavt", "Tai_Viet"),
                            ("telu", "Telugu"),
                            ("telugu", "Telugu"),
                            ("tfng", "Tifinagh"),
                            ("tglg", "Tagalog"),
                            ("thaa", "Thaana"),
                            ("thaana", "Thaana"),
                            ("thai", "Thai"),
                            ("tibetan", "Tibetan"),
                            ("tibt", "Tibetan"),
                            ("tifinagh", "Tifinagh"),
                            ("tirh", "Tirhuta"),
                            ("tirhuta", "Tirhuta"),
                            ("tnsa", "Tangsa"),
                            ("todhri", "Todhri"),
                            ("todr", "Todhri"),
                            ("toto", "Toto"),
                            ("tulutigalari", "Tulu_Tigalari"),
                            ("tutg", "Tulu_Tigalari"),
                            ("ugar", "Ugaritic"),
                            ("ugaritic", "Ugaritic"),
                            ("unknown", "Unknown"),
                            ("vai", "Vai"),
                            ("vaii", "Vai"),
                            ("vith", "Vithkuqi"),
                            ("vithkuqi", "Vithkuqi"),
                            ("wancho", "Wancho"),
                            ("wara", "Warang_Citi"),
                            ("warangciti", "Warang_Citi"),
                            ("wcho", "Wancho"),
                            ("xpeo", "Old_Persian"),
                            ("xsux", "Cuneiform"),
                            ("yezi", "Yezidi"),
                            ("yezidi", "Yezidi"),
                            ("yi", "Yi"),
                            ("yiii", "Yi"),
                            ("zanabazarsquare", "Zanabazar_Square"),
                            ("zanb", "Zanabazar_Square"),
                            ("zinh", "Inherited"),
                            ("zyyy", "Common"),
                            ("zzzz", "Unknown"),
                        ],
                    ),
                    (
                        "Sentence_Break",
                        &[
                            ("at", "ATerm"),
                            ("aterm", "ATerm"),
                            ("cl", "Close"),
                            ("close", "Close"),
                            ("cr", "CR"),
                            ("ex", "Extend"),
                            ("extend", "Extend"),
                            ("fo", "Format"),
                            ("format", "Format"),
                            ("le", "OLetter"),
                            ("lf", "LF"),
                            ("lo", "Lower"),
                            ("lower", "Lower"),
                            ("nu", "Numeric"),
                            ("numeric", "Numeric"),
                            ("oletter", "OLetter"),
                            ("other", "Other"),
                            ("sc", "SContinue"),
                            ("scontinue", "SContinue"),
                            ("se", "Sep"),
                            ("sep", "Sep"),
                            ("sp", "Sp"),
                            ("st", "STerm"),
                            ("sterm", "STerm"),
                            ("up", "Upper"),
                            ("upper", "Upper"),
                            ("xx", "Other"),
                        ],
                    ),
                    (
                        "Word_Break",
                        &[
                            ("aletter", "ALetter"),
                            ("cr", "CR"),
                            ("doublequote", "Double_Quote"),
                            ("dq", "Double_Quote"),
                            ("eb", "E_Base"),
                            ("ebase", "E_Base"),
                            ("ebasegaz", "E_Base_GAZ"),
                            ("ebg", "E_Base_GAZ"),
                            ("em", "E_Modifier"),
                            ("emodifier", "E_Modifier"),
                            ("ex", "ExtendNumLet"),
                            ("extend", "Extend"),
                            ("extendnumlet", "ExtendNumLet"),
                            ("fo", "Format"),
                            ("format", "Format"),
                            ("gaz", "Glue_After_Zwj"),
                            ("glueafterzwj", "Glue_After_Zwj"),
                            ("hebrewletter", "Hebrew_Letter"),
                            ("hl", "Hebrew_Letter"),
                            ("ka", "Katakana"),
                            ("katakana", "Katakana"),
                            ("le", "ALetter"),
                            ("lf", "LF"),
                            ("mb", "MidNumLet"),
                            ("midletter", "MidLetter"),
                            ("midnum", "MidNum"),
                            ("midnumlet", "MidNumLet"),
                            ("ml", "MidLetter"),
                            ("mn", "MidNum"),
                            ("newline", "Newline"),
                            ("nl", "Newline"),
                            ("nu", "Numeric"),
                            ("numeric", "Numeric"),
                            ("other", "Other"),
                            ("regionalindicator", "Regional_Indicator"),
                            ("ri", "Regional_Indicator"),
                            ("singlequote", "Single_Quote"),
                            ("sq", "Single_Quote"),
                            ("wsegspace", "WSegSpace"),
                            ("xx", "Other"),
                            ("zwj", "ZWJ"),
                        ],
                    ),
                ];
            }

            pub mod script
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &[
                    ("Adlam", ADLAM),
                    ("Ahom", AHOM),
                    ("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS),
                    ("Arabic", ARABIC),
                    ("Armenian", ARMENIAN),
                    ("Avestan", AVESTAN),
                    ("Balinese", BALINESE),
                    ("Bamum", BAMUM),
                    ("Bassa_Vah", BASSA_VAH),
                    ("Batak", BATAK),
                    ("Bengali", BENGALI),
                    ("Bhaiksuki", BHAIKSUKI),
                    ("Bopomofo", BOPOMOFO),
                    ("Brahmi", BRAHMI),
                    ("Braille", BRAILLE),
                    ("Buginese", BUGINESE),
                    ("Buhid", BUHID),
                    ("Canadian_Aboriginal", CANADIAN_ABORIGINAL),
                    ("Carian", CARIAN),
                    ("Caucasian_Albanian", CAUCASIAN_ALBANIAN),
                    ("Chakma", CHAKMA),
                    ("Cham", CHAM),
                    ("Cherokee", CHEROKEE),
                    ("Chorasmian", CHORASMIAN),
                    ("Common", COMMON),
                    ("Coptic", COPTIC),
                    ("Cuneiform", CUNEIFORM),
                    ("Cypriot", CYPRIOT),
                    ("Cypro_Minoan", CYPRO_MINOAN),
                    ("Cyrillic", CYRILLIC),
                    ("Deseret", DESERET),
                    ("Devanagari", DEVANAGARI),
                    ("Dives_Akuru", DIVES_AKURU),
                    ("Dogra", DOGRA),
                    ("Duployan", DUPLOYAN),
                    ("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS),
                    ("Elbasan", ELBASAN),
                    ("Elymaic", ELYMAIC),
                    ("Ethiopic", ETHIOPIC),
                    ("Garay", GARAY),
                    ("Georgian", GEORGIAN),
                    ("Glagolitic", GLAGOLITIC),
                    ("Gothic", GOTHIC),
                    ("Grantha", GRANTHA),
                    ("Greek", GREEK),
                    ("Gujarati", GUJARATI),
                    ("Gunjala_Gondi", GUNJALA_GONDI),
                    ("Gurmukhi", GURMUKHI),
                    ("Gurung_Khema", GURUNG_KHEMA),
                    ("Han", HAN),
                    ("Hangul", HANGUL),
                    ("Hanifi_Rohingya", HANIFI_ROHINGYA),
                    ("Hanunoo", HANUNOO),
                    ("Hatran", HATRAN),
                    ("Hebrew", HEBREW),
                    ("Hiragana", HIRAGANA),
                    ("Imperial_Aramaic", IMPERIAL_ARAMAIC),
                    ("Inherited", INHERITED),
                    ("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),
                    ("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN),
                    ("Javanese", JAVANESE),
                    ("Kaithi", KAITHI),
                    ("Kannada", KANNADA),
                    ("Katakana", KATAKANA),
                    ("Kawi", KAWI),
                    ("Kayah_Li", KAYAH_LI),
                    ("Kharoshthi", KHAROSHTHI),
                    ("Khitan_Small_Script", KHITAN_SMALL_SCRIPT),
                    ("Khmer", KHMER),
                    ("Khojki", KHOJKI),
                    ("Khudawadi", KHUDAWADI),
                    ("Kirat_Rai", KIRAT_RAI),
                    ("Lao", LAO),
                    ("Latin", LATIN),
                    ("Lepcha", LEPCHA),
                    ("Limbu", LIMBU),
                    ("Linear_A", LINEAR_A),
                    ("Linear_B", LINEAR_B),
                    ("Lisu", LISU),
                    ("Lycian", LYCIAN),
                    ("Lydian", LYDIAN),
                    ("Mahajani", MAHAJANI),
                    ("Makasar", MAKASAR),
                    ("Malayalam", MALAYALAM),
                    ("Mandaic", MANDAIC),
                    ("Manichaean", MANICHAEAN),
                    ("Marchen", MARCHEN),
                    ("Masaram_Gondi", MASARAM_GONDI),
                    ("Medefaidrin", MEDEFAIDRIN),
                    ("Meetei_Mayek", MEETEI_MAYEK),
                    ("Mende_Kikakui", MENDE_KIKAKUI),
                    ("Meroitic_Cursive", MEROITIC_CURSIVE),
                    ("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS),
                    ("Miao", MIAO),
                    ("Modi", MODI),
                    ("Mongolian", MONGOLIAN),
                    ("Mro", MRO),
                    ("Multani", MULTANI),
                    ("Myanmar", MYANMAR),
                    ("Nabataean", NABATAEAN),
                    ("Nag_Mundari", NAG_MUNDARI),
                    ("Nandinagari", NANDINAGARI),
                    ("New_Tai_Lue", NEW_TAI_LUE),
                    ("Newa", NEWA),
                    ("Nko", NKO),
                    ("Nushu", NUSHU),
                    ("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),
                    ("Ogham", OGHAM),
                    ("Ol_Chiki", OL_CHIKI),
                    ("Ol_Onal", OL_ONAL),
                    ("Old_Hungarian", OLD_HUNGARIAN),
                    ("Old_Italic", OLD_ITALIC),
                    ("Old_North_Arabian", OLD_NORTH_ARABIAN),
                    ("Old_Permic", OLD_PERMIC),
                    ("Old_Persian", OLD_PERSIAN),
                    ("Old_Sogdian", OLD_SOGDIAN),
                    ("Old_South_Arabian", OLD_SOUTH_ARABIAN),
                    ("Old_Turkic", OLD_TURKIC),
                    ("Old_Uyghur", OLD_UYGHUR),
                    ("Oriya", ORIYA),
                    ("Osage", OSAGE),
                    ("Osmanya", OSMANYA),
                    ("Pahawh_Hmong", PAHAWH_HMONG),
                    ("Palmyrene", PALMYRENE),
                    ("Pau_Cin_Hau", PAU_CIN_HAU),
                    ("Phags_Pa", PHAGS_PA),
                    ("Phoenician", PHOENICIAN),
                    ("Psalter_Pahlavi", PSALTER_PAHLAVI),
                    ("Rejang", REJANG),
                    ("Runic", RUNIC),
                    ("Samaritan", SAMARITAN),
                    ("Saurashtra", SAURASHTRA),
                    ("Sharada", SHARADA),
                    ("Shavian", SHAVIAN),
                    ("Siddham", SIDDHAM),
                    ("SignWriting", SIGNWRITING),
                    ("Sinhala", SINHALA),
                    ("Sogdian", SOGDIAN),
                    ("Sora_Sompeng", SORA_SOMPENG),
                    ("Soyombo", SOYOMBO),
                    ("Sundanese", SUNDANESE),
                    ("Sunuwar", SUNUWAR),
                    ("Syloti_Nagri", SYLOTI_NAGRI),
                    ("Syriac", SYRIAC),
                    ("Tagalog", TAGALOG),
                    ("Tagbanwa", TAGBANWA),
                    ("Tai_Le", TAI_LE),
                    ("Tai_Tham", TAI_THAM),
                    ("Tai_Viet", TAI_VIET),
                    ("Takri", TAKRI),
                    ("Tamil", TAMIL),
                    ("Tangsa", TANGSA),
                    ("Tangut", TANGUT),
                    ("Telugu", TELUGU),
                    ("Thaana", THAANA),
                    ("Thai", THAI),
                    ("Tibetan", TIBETAN),
                    ("Tifinagh", TIFINAGH),
                    ("Tirhuta", TIRHUTA),
                    ("Todhri", TODHRI),
                    ("Toto", TOTO),
                    ("Tulu_Tigalari", TULU_TIGALARI),
                    ("Ugaritic", UGARITIC),
                    ("Vai", VAI),
                    ("Vithkuqi", VITHKUQI),
                    ("Wancho", WANCHO),
                    ("Warang_Citi", WARANG_CITI),
                    ("Yezidi", YEZIDI),
                    ("Yi", YI),
                    ("Zanabazar_Square", ZANABAZAR_SQUARE),
                ];

                pub const ADLAM: &'static [(char, char)] =
                    &[('𞤀', '𞥋'), ('𞥐', '𞥙'), ('𞥞', '𞥟')];

                pub const AHOM: &'static [(char, char)] =
                    &[('𑜀', '𑜚'), ('\u{1171d}', '\u{1172b}'), ('𑜰', '𑝆')];

                pub const ANATOLIAN_HIEROGLYPHS: &'static [(char, char)] = &[('𔐀', '𔙆')];

                pub const ARABIC: &'static [(char, char)] = &[
                    ('\u{600}', '\u{604}'),
                    ('؆', '؋'),
                    ('؍', '\u{61a}'),
                    ('\u{61c}', '؞'),
                    ('ؠ', 'ؿ'),
                    ('ف', 'ي'),
                    ('\u{656}', 'ٯ'),
                    ('ٱ', '\u{6dc}'),
                    ('۞', 'ۿ'),
                    ('ݐ', 'ݿ'),
                    ('ࡰ', 'ࢎ'),
                    ('\u{890}', '\u{891}'),
                    ('\u{897}', '\u{8e1}'),
                    ('\u{8e3}', '\u{8ff}'),
                    ('ﭐ', '﯂'),
                    ('ﯓ', 'ﴽ'),
                    ('﵀', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('﷏', '﷏'),
                    ('ﷰ', '﷿'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('𐹠', '𐹾'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𞻰', '𞻱'),
                ];

                pub const ARMENIAN: &'static [(char, char)] =
                    &[('Ա', 'Ֆ'), ('ՙ', '֊'), ('֍', '֏'), ('ﬓ', 'ﬗ')];

                pub const AVESTAN: &'static [(char, char)] = &[('𐬀', '𐬵'), ('𐬹', '𐬿')];

                pub const BALINESE: &'static [(char, char)] = &[('\u{1b00}', 'ᭌ'), ('᭎', '᭿')];

                pub const BAMUM: &'static [(char, char)] = &[('ꚠ', '꛷'), ('𖠀', '𖨸')];

                pub const BASSA_VAH: &'static [(char, char)] =
                    &[('𖫐', '𖫭'), ('\u{16af0}', '𖫵')];

                pub const BATAK: &'static [(char, char)] = &[('ᯀ', '\u{1bf3}'), ('᯼', '᯿')];

                pub const BENGALI: &'static [(char, char)] = &[
                    ('ঀ', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৎ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('০', '\u{9fe}'),
                ];

                pub const BHAIKSUKI: &'static [(char, char)] =
                    &[('𑰀', '𑰈'), ('𑰊', '\u{11c36}'), ('\u{11c38}', '𑱅'), ('𑱐', '𑱬')];

                pub const BOPOMOFO: &'static [(char, char)] =
                    &[('˪', '˫'), ('ㄅ', 'ㄯ'), ('ㆠ', 'ㆿ')];

                pub const BRAHMI: &'static [(char, char)] =
                    &[('𑀀', '𑁍'), ('𑁒', '𑁵'), ('\u{1107f}', '\u{1107f}')];

                pub const BRAILLE: &'static [(char, char)] = &[('⠀', '⣿')];

                pub const BUGINESE: &'static [(char, char)] = &[('ᨀ', '\u{1a1b}'), ('᨞', '᨟')];

                pub const BUHID: &'static [(char, char)] = &[('ᝀ', '\u{1753}')];

                pub const CANADIAN_ABORIGINAL: &'static [(char, char)] =
                    &[('᐀', 'ᙿ'), ('ᢰ', 'ᣵ'), ('𑪰', '𑪿')];

                pub const CARIAN: &'static [(char, char)] = &[('𐊠', '𐋐')];

                pub const CAUCASIAN_ALBANIAN: &'static [(char, char)] =
                    &[('𐔰', '𐕣'), ('𐕯', '𐕯')];

                pub const CHAKMA: &'static [(char, char)] =
                    &[('\u{11100}', '\u{11134}'), ('𑄶', '𑅇')];

                pub const CHAM: &'static [(char, char)] =
                    &[('ꨀ', '\u{aa36}'), ('ꩀ', 'ꩍ'), ('꩐', '꩙'), ('꩜', '꩟')];

                pub const CHEROKEE: &'static [(char, char)] =
                    &[('Ꭰ', 'Ᏽ'), ('ᏸ', 'ᏽ'), ('ꭰ', 'ꮿ')];

                pub const CHORASMIAN: &'static [(char, char)] = &[('𐾰', '𐿋')];

                pub const COMMON: &'static [(char, char)] = &[
                    ('\0', '@'),
                    ('[', '`'),
                    ('{', '©'),
                    ('«', '¹'),
                    ('»', '¿'),
                    ('×', '×'),
                    ('÷', '÷'),
                    ('ʹ', '˟'),
                    ('˥', '˩'),
                    ('ˬ', '˿'),
                    ('ʹ', 'ʹ'),
                    (';', ';'),
                    ('΅', '΅'),
                    ('·', '·'),
                    ('\u{605}', '\u{605}'),
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؟', '؟'),
                    ('ـ', 'ـ'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('।', '॥'),
                    ('฿', '฿'),
                    ('࿕', '࿘'),
                    ('჻', '჻'),
                    ('᛫', '᛭'),
                    ('᜵', '᜶'),
                    ('᠂', '᠃'),
                    ('᠅', '᠅'),
                    ('᳓', '᳓'),
                    ('᳡', '᳡'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', '᳷'),
                    ('ᳺ', 'ᳺ'),
                    ('\u{2000}', '\u{200b}'),
                    ('\u{200e}', '\u{2064}'),
                    ('\u{2066}', '⁰'),
                    ('⁴', '⁾'),
                    ('₀', '₎'),
                    ('₠', '⃀'),
                    ('℀', '℥'),
                    ('℧', '℩'),
                    ('ℬ', 'ℱ'),
                    ('ℳ', '⅍'),
                    ('⅏', '⅟'),
                    ('↉', '↋'),
                    ('←', '␩'),
                    ('⑀', '⑊'),
                    ('①', '⟿'),
                    ('⤀', '⭳'),
                    ('⭶', '⮕'),
                    ('⮗', '⯿'),
                    ('⸀', '⹝'),
                    ('⿰', '〄'),
                    ('〆', '〆'),
                    ('〈', '〠'),
                    ('〰', '〷'),
                    ('〼', '〿'),
                    ('゛', '゜'),
                    ('゠', '゠'),
                    ('・', 'ー'),
                    ('㆐', '㆟'),
                    ('㇀', '㇥'),
                    ('㇯', '㇯'),
                    ('㈠', '㉟'),
                    ('㉿', '㋏'),
                    ('㋿', '㋿'),
                    ('㍘', '㏿'),
                    ('䷀', '䷿'),
                    ('꜀', '꜡'),
                    ('ꞈ', '꞊'),
                    ('꠰', '꠹'),
                    ('꤮', '꤮'),
                    ('ꧏ', 'ꧏ'),
                    ('꭛', '꭛'),
                    ('꭪', '꭫'),
                    ('﴾', '﴿'),
                    ('︐', '︙'),
                    ('︰', '﹒'),
                    ('﹔', '﹦'),
                    ('﹨', '﹫'),
                    ('\u{feff}', '\u{feff}'),
                    ('！', '＠'),
                    ('［', '｀'),
                    ('｛', '･'),
                    ('ｰ', 'ｰ'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('￠', '￦'),
                    ('￨', '￮'),
                    ('\u{fff9}', ' '),
                    ('𐄀', '𐄂'),
                    ('𐄇', '𐄳'),
                    ('𐄷', '𐄿'),
                    ('𐆐', '𐆜'),
                    ('𐇐', '𐇼'),
                    ('𐋡', '𐋻'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('𜰀', '𜳹'),
                    ('𜴀', '𜺳'),
                    ('𜽐', '𜿃'),
                    ('𝀀', '𝃵'),
                    ('𝄀', '𝄦'),
                    ('𝄩', '\u{1d166}'),
                    ('𝅪', '\u{1d17a}'),
                    ('𝆃', '𝆄'),
                    ('𝆌', '𝆩'),
                    ('𝆮', '𝇪'),
                    ('𝋀', '𝋓'),
                    ('𝋠', '𝋳'),
                    ('𝌀', '𝍖'),
                    ('𝍠', '𝍸'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('𞱱', '𞲴'),
                    ('𞴁', '𞴽'),
                    ('🀀', '🀫'),
                    ('🀰', '🂓'),
                    ('🂠', '🂮'),
                    ('🂱', '🂿'),
                    ('🃁', '🃏'),
                    ('🃑', '🃵'),
                    ('🄀', '🆭'),
                    ('🇦', '🇿'),
                    ('🈁', '🈂'),
                    ('🈐', '🈻'),
                    ('🉀', '🉈'),
                    ('🉐', '🉑'),
                    ('🉠', '🉥'),
                    ('🌀', '🛗'),
                    ('🛜', '🛬'),
                    ('🛰', '🛼'),
                    ('🜀', '🝶'),
                    ('🝻', '🟙'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🠀', '🠋'),
                    ('🠐', '🡇'),
                    ('🡐', '🡙'),
                    ('🡠', '🢇'),
                    ('🢐', '🢭'),
                    ('🢰', '🢻'),
                    ('🣀', '🣁'),
                    ('🤀', '🩓'),
                    ('🩠', '🩭'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                    ('🬀', '🮒'),
                    ('🮔', '🯹'),
                    ('\u{e0001}', '\u{e0001}'),
                    ('\u{e0020}', '\u{e007f}'),
                ];

                pub const COPTIC: &'static [(char, char)] =
                    &[('Ϣ', 'ϯ'), ('Ⲁ', 'ⳳ'), ('⳹', '⳿')];

                pub const CUNEIFORM: &'static [(char, char)] =
                    &[('𒀀', '𒎙'), ('𒐀', '𒑮'), ('𒑰', '𒑴'), ('𒒀', '𒕃')];

                pub const CYPRIOT: &'static [(char, char)] =
                    &[('𐠀', '𐠅'), ('𐠈', '𐠈'), ('𐠊', '𐠵'), ('𐠷', '𐠸'), ('𐠼', '𐠼'), ('𐠿', '𐠿')];

                pub const CYPRO_MINOAN: &'static [(char, char)] = &[('𒾐', '𒿲')];

                pub const CYRILLIC: &'static [(char, char)] = &[
                    ('Ѐ', '\u{484}'),
                    ('\u{487}', 'ԯ'),
                    ('ᲀ', 'ᲊ'),
                    ('ᴫ', 'ᴫ'),
                    ('ᵸ', 'ᵸ'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('Ꙁ', '\u{a69f}'),
                    ('\u{fe2e}', '\u{fe2f}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                ];

                pub const DESERET: &'static [(char, char)] = &[('𐐀', '𐑏')];

                pub const DEVANAGARI: &'static [(char, char)] = &[
                    ('\u{900}', 'ॐ'),
                    ('\u{955}', '\u{963}'),
                    ('०', 'ॿ'),
                    ('\u{a8e0}', '\u{a8ff}'),
                    ('𑬀', '𑬉'),
                ];

                pub const DIVES_AKURU: &'static [(char, char)] = &[
                    ('𑤀', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '𑥆'),
                    ('𑥐', '𑥙'),
                ];

                pub const DOGRA: &'static [(char, char)] = &[('𑠀', '𑠻')];

                pub const DUPLOYAN: &'static [(char, char)] =
                    &[('𛰀', '𛱪'), ('𛱰', '𛱼'), ('𛲀', '𛲈'), ('𛲐', '𛲙'), ('𛲜', '𛲟')];

                pub const EGYPTIAN_HIEROGLYPHS: &'static [(char, char)] =
                    &[('𓀀', '\u{13455}'), ('𓑠', '𔏺')];

                pub const ELBASAN: &'static [(char, char)] = &[('𐔀', '𐔧')];

                pub const ELYMAIC: &'static [(char, char)] = &[('𐿠', '𐿶')];

                pub const ETHIOPIC: &'static [(char, char)] = &[
                    ('ሀ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('\u{135d}', '፼'),
                    ('ᎀ', '᎙'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                ];

                pub const GARAY: &'static [(char, char)] =
                    &[('𐵀', '𐵥'), ('\u{10d69}', '𐶅'), ('𐶎', '𐶏')];

                pub const GEORGIAN: &'static [(char, char)] = &[
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ჿ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                ];

                pub const GLAGOLITIC: &'static [(char, char)] = &[
                    ('Ⰰ', 'ⱟ'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                ];

                pub const GOTHIC: &'static [(char, char)] = &[('𐌰', '𐍊')];

                pub const GRANTHA: &'static [(char, char)] = &[
                    ('\u{11300}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('\u{1133c}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('𑍐', '𑍐'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                ];

                pub const GREEK: &'static [(char, char)] = &[
                    ('Ͱ', 'ͳ'),
                    ('͵', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('΄', '΄'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϡ'),
                    ('ϰ', 'Ͽ'),
                    ('ᴦ', 'ᴪ'),
                    ('ᵝ', 'ᵡ'),
                    ('ᵦ', 'ᵪ'),
                    ('ᶿ', 'ᶿ'),
                    ('ἀ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ῄ'),
                    ('ῆ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('῝', '`'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', '῾'),
                    ('Ω', 'Ω'),
                    ('ꭥ', 'ꭥ'),
                    ('𐅀', '𐆎'),
                    ('𐆠', '𐆠'),
                    ('𝈀', '𝉅'),
                ];

                pub const GUJARATI: &'static [(char, char)] = &[
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', '\u{ae3}'),
                    ('૦', '૱'),
                    ('ૹ', '\u{aff}'),
                ];

                pub const GUNJALA_GONDI: &'static [(char, char)] = &[
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶘'),
                    ('𑶠', '𑶩'),
                ];

                pub const GURMUKHI: &'static [(char, char)] = &[
                    ('\u{a01}', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', '੶'),
                ];

                pub const GURUNG_KHEMA: &'static [(char, char)] = &[('𖄀', '𖄹')];

                pub const HAN: &'static [(char, char)] = &[
                    ('⺀', '⺙'),
                    ('⺛', '⻳'),
                    ('⼀', '⿕'),
                    ('々', '々'),
                    ('〇', '〇'),
                    ('〡', '〩'),
                    ('〸', '〻'),
                    ('㐀', '䶿'),
                    ('一', '鿿'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('𖿢', '𖿣'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const HANGUL: &'static [(char, char)] = &[
                    ('ᄀ', 'ᇿ'),
                    ('\u{302e}', '\u{302f}'),
                    ('ㄱ', 'ㆎ'),
                    ('㈀', '㈞'),
                    ('㉠', '㉾'),
                    ('ꥠ', 'ꥼ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                ];

                pub const HANIFI_ROHINGYA: &'static [(char, char)] =
                    &[('𐴀', '\u{10d27}'), ('𐴰', '𐴹')];

                pub const HANUNOO: &'static [(char, char)] = &[('ᜠ', '\u{1734}')];

                pub const HATRAN: &'static [(char, char)] =
                    &[('𐣠', '𐣲'), ('𐣴', '𐣵'), ('𐣻', '𐣿')];

                pub const HEBREW: &'static [(char, char)] = &[
                    ('\u{591}', '\u{5c7}'),
                    ('א', 'ת'),
                    ('ׯ', '״'),
                    ('יִ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﭏ'),
                ];

                pub const HIRAGANA: &'static [(char, char)] = &[
                    ('ぁ', 'ゖ'),
                    ('ゝ', 'ゟ'),
                    ('𛀁', '𛄟'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('🈀', '🈀'),
                ];

                pub const IMPERIAL_ARAMAIC: &'static [(char, char)] =
                    &[('𐡀', '𐡕'), ('𐡗', '𐡟')];

                pub const INHERITED: &'static [(char, char)] = &[
                    ('\u{300}', '\u{36f}'),
                    ('\u{485}', '\u{486}'),
                    ('\u{64b}', '\u{655}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{951}', '\u{954}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce0}'),
                    ('\u{1ce2}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{200c}', '\u{200d}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{302a}', '\u{302d}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2d}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{1133b}', '\u{1133b}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d167}', '\u{1d169}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const INSCRIPTIONAL_PAHLAVI: &'static [(char, char)] =
                    &[('𐭠', '𐭲'), ('𐭸', '𐭿')];

                pub const INSCRIPTIONAL_PARTHIAN: &'static [(char, char)] =
                    &[('𐭀', '𐭕'), ('𐭘', '𐭟')];

                pub const JAVANESE: &'static [(char, char)] =
                    &[('\u{a980}', '꧍'), ('꧐', '꧙'), ('꧞', '꧟')];

                pub const KAITHI: &'static [(char, char)] =
                    &[('\u{11080}', '\u{110c2}'), ('\u{110cd}', '\u{110cd}')];

                pub const KANNADA: &'static [(char, char)] = &[
                    ('ಀ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('\u{cbc}', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', '\u{ce3}'),
                    ('೦', '೯'),
                    ('ೱ', 'ೳ'),
                ];

                pub const KATAKANA: &'static [(char, char)] = &[
                    ('ァ', 'ヺ'),
                    ('ヽ', 'ヿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㋐', '㋾'),
                    ('㌀', '㍗'),
                    ('ｦ', 'ｯ'),
                    ('ｱ', 'ﾝ'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛀀'),
                    ('𛄠', '𛄢'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                ];

                pub const KAWI: &'static [(char, char)] =
                    &[('\u{11f00}', '𑼐'), ('𑼒', '\u{11f3a}'), ('𑼾', '\u{11f5a}')];

                pub const KAYAH_LI: &'static [(char, char)] = &[('꤀', '\u{a92d}'), ('꤯', '꤯')];

                pub const KHAROSHTHI: &'static [(char, char)] = &[
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '𐩈'),
                    ('𐩐', '𐩘'),
                ];

                pub const KHITAN_SMALL_SCRIPT: &'static [(char, char)] =
                    &[('\u{16fe4}', '\u{16fe4}'), ('𘬀', '𘳕'), ('𘳿', '𘳿')];

                pub const KHMER: &'static [(char, char)] =
                    &[('ក', '\u{17dd}'), ('០', '៩'), ('៰', '៹'), ('᧠', '᧿')];

                pub const KHOJKI: &'static [(char, char)] = &[('𑈀', '𑈑'), ('𑈓', '\u{11241}')];

                pub const KHUDAWADI: &'static [(char, char)] =
                    &[('𑊰', '\u{112ea}'), ('𑋰', '𑋹')];

                pub const KIRAT_RAI: &'static [(char, char)] = &[('𖵀', '𖵹')];

                pub const LAO: &'static [(char, char)] = &[
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ece}'),
                    ('໐', '໙'),
                    ('ໜ', 'ໟ'),
                ];

                pub const LATIN: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ʸ'),
                    ('ˠ', 'ˤ'),
                    ('ᴀ', 'ᴥ'),
                    ('ᴬ', 'ᵜ'),
                    ('ᵢ', 'ᵥ'),
                    ('ᵫ', 'ᵷ'),
                    ('ᵹ', 'ᶾ'),
                    ('Ḁ', 'ỿ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('K', 'Å'),
                    ('Ⅎ', 'Ⅎ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⱡ', 'Ɀ'),
                    ('Ꜣ', 'ꞇ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꟿ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭤ'),
                    ('ꭦ', 'ꭩ'),
                    ('ﬀ', 'ﬆ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                ];

                pub const LEPCHA: &'static [(char, char)] =
                    &[('ᰀ', '\u{1c37}'), ('᰻', '᱉'), ('ᱍ', 'ᱏ')];

                pub const LIMBU: &'static [(char, char)] = &[
                    ('ᤀ', 'ᤞ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('᥀', '᥀'),
                    ('᥄', '᥏'),
                ];

                pub const LINEAR_A: &'static [(char, char)] =
                    &[('𐘀', '𐜶'), ('𐝀', '𐝕'), ('𐝠', '𐝧')];

                pub const LINEAR_B: &'static [(char, char)] = &[
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                ];

                pub const LISU: &'static [(char, char)] = &[('ꓐ', '꓿'), ('𑾰', '𑾰')];

                pub const LYCIAN: &'static [(char, char)] = &[('𐊀', '𐊜')];

                pub const LYDIAN: &'static [(char, char)] = &[('𐤠', '𐤹'), ('𐤿', '𐤿')];

                pub const MAHAJANI: &'static [(char, char)] = &[('𑅐', '𑅶')];

                pub const MAKASAR: &'static [(char, char)] = &[('𑻠', '𑻸')];

                pub const MALAYALAM: &'static [(char, char)] = &[
                    ('\u{d00}', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', '൏'),
                    ('ൔ', '\u{d63}'),
                    ('൦', 'ൿ'),
                ];

                pub const MANDAIC: &'static [(char, char)] = &[('ࡀ', '\u{85b}'), ('࡞', '࡞')];

                pub const MANICHAEAN: &'static [(char, char)] =
                    &[('𐫀', '\u{10ae6}'), ('𐫫', '𐫶')];

                pub const MARCHEN: &'static [(char, char)] =
                    &[('𑱰', '𑲏'), ('\u{11c92}', '\u{11ca7}'), ('𑲩', '\u{11cb6}')];

                pub const MASARAM_GONDI: &'static [(char, char)] = &[
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d47}'),
                    ('𑵐', '𑵙'),
                ];

                pub const MEDEFAIDRIN: &'static [(char, char)] = &[('𖹀', '𖺚')];

                pub const MEETEI_MAYEK: &'static [(char, char)] =
                    &[('ꫠ', '\u{aaf6}'), ('ꯀ', '\u{abed}'), ('꯰', '꯹')];

                pub const MENDE_KIKAKUI: &'static [(char, char)] =
                    &[('𞠀', '𞣄'), ('𞣇', '\u{1e8d6}')];

                pub const MEROITIC_CURSIVE: &'static [(char, char)] =
                    &[('𐦠', '𐦷'), ('𐦼', '𐧏'), ('𐧒', '𐧿')];

                pub const MEROITIC_HIEROGLYPHS: &'static [(char, char)] = &[('𐦀', '𐦟')];

                pub const MIAO: &'static [(char, char)] =
                    &[('𖼀', '𖽊'), ('\u{16f4f}', '𖾇'), ('\u{16f8f}', '𖾟')];

                pub const MODI: &'static [(char, char)] = &[('𑘀', '𑙄'), ('𑙐', '𑙙')];

                pub const MONGOLIAN: &'static [(char, char)] =
                    &[('᠀', '᠁'), ('᠄', '᠄'), ('᠆', '᠙'), ('ᠠ', 'ᡸ'), ('ᢀ', 'ᢪ'), ('𑙠', '𑙬')];

                pub const MRO: &'static [(char, char)] = &[('𖩀', '𖩞'), ('𖩠', '𖩩'), ('𖩮', '𖩯')];

                pub const MULTANI: &'static [(char, char)] =
                    &[('𑊀', '𑊆'), ('𑊈', '𑊈'), ('𑊊', '𑊍'), ('𑊏', '𑊝'), ('𑊟', '𑊩')];

                pub const MYANMAR: &'static [(char, char)] =
                    &[('က', '႟'), ('ꧠ', 'ꧾ'), ('ꩠ', 'ꩿ'), ('𑛐', '𑛣')];

                pub const NABATAEAN: &'static [(char, char)] = &[('𐢀', '𐢞'), ('𐢧', '𐢯')];

                pub const NAG_MUNDARI: &'static [(char, char)] = &[('𞓐', '𞓹')];

                pub const NANDINAGARI: &'static [(char, char)] =
                    &[('𑦠', '𑦧'), ('𑦪', '\u{119d7}'), ('\u{119da}', '𑧤')];

                pub const NEW_TAI_LUE: &'static [(char, char)] =
                    &[('ᦀ', 'ᦫ'), ('ᦰ', 'ᧉ'), ('᧐', '᧚'), ('᧞', '᧟')];

                pub const NEWA: &'static [(char, char)] = &[('𑐀', '𑑛'), ('𑑝', '𑑡')];

                pub const NKO: &'static [(char, char)] = &[('߀', 'ߺ'), ('\u{7fd}', '߿')];

                pub const NUSHU: &'static [(char, char)] = &[('𖿡', '𖿡'), ('𛅰', '𛋻')];

                pub const NYIAKENG_PUACHUE_HMONG: &'static [(char, char)] =
                    &[('𞄀', '𞄬'), ('\u{1e130}', '𞄽'), ('𞅀', '𞅉'), ('𞅎', '𞅏')];

                pub const OGHAM: &'static [(char, char)] = &[('\u{1680}', '᚜')];

                pub const OL_CHIKI: &'static [(char, char)] = &[('᱐', '᱿')];

                pub const OL_ONAL: &'static [(char, char)] = &[('𞗐', '𞗺'), ('𞗿', '𞗿')];

                pub const OLD_HUNGARIAN: &'static [(char, char)] =
                    &[('𐲀', '𐲲'), ('𐳀', '𐳲'), ('𐳺', '𐳿')];

                pub const OLD_ITALIC: &'static [(char, char)] = &[('𐌀', '𐌣'), ('𐌭', '𐌯')];

                pub const OLD_NORTH_ARABIAN: &'static [(char, char)] = &[('𐪀', '𐪟')];

                pub const OLD_PERMIC: &'static [(char, char)] = &[('𐍐', '\u{1037a}')];

                pub const OLD_PERSIAN: &'static [(char, char)] = &[('𐎠', '𐏃'), ('𐏈', '𐏕')];

                pub const OLD_SOGDIAN: &'static [(char, char)] = &[('𐼀', '𐼧')];

                pub const OLD_SOUTH_ARABIAN: &'static [(char, char)] = &[('𐩠', '𐩿')];

                pub const OLD_TURKIC: &'static [(char, char)] = &[('𐰀', '𐱈')];

                pub const OLD_UYGHUR: &'static [(char, char)] = &[('𐽰', '𐾉')];

                pub const ORIYA: &'static [(char, char)] = &[
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('\u{b3c}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', '\u{b63}'),
                    ('୦', '୷'),
                ];

                pub const OSAGE: &'static [(char, char)] = &[('𐒰', '𐓓'), ('𐓘', '𐓻')];

                pub const OSMANYA: &'static [(char, char)] = &[('𐒀', '𐒝'), ('𐒠', '𐒩')];

                pub const PAHAWH_HMONG: &'static [(char, char)] =
                    &[('𖬀', '𖭅'), ('𖭐', '𖭙'), ('𖭛', '𖭡'), ('𖭣', '𖭷'), ('𖭽', '𖮏')];

                pub const PALMYRENE: &'static [(char, char)] = &[('𐡠', '𐡿')];

                pub const PAU_CIN_HAU: &'static [(char, char)] = &[('𑫀', '𑫸')];

                pub const PHAGS_PA: &'static [(char, char)] = &[('ꡀ', '꡷')];

                pub const PHOENICIAN: &'static [(char, char)] = &[('𐤀', '𐤛'), ('𐤟', '𐤟')];

                pub const PSALTER_PAHLAVI: &'static [(char, char)] =
                    &[('𐮀', '𐮑'), ('𐮙', '𐮜'), ('𐮩', '𐮯')];

                pub const REJANG: &'static [(char, char)] = &[('ꤰ', '\u{a953}'), ('꥟', '꥟')];

                pub const RUNIC: &'static [(char, char)] = &[('ᚠ', 'ᛪ'), ('ᛮ', 'ᛸ')];

                pub const SAMARITAN: &'static [(char, char)] = &[('ࠀ', '\u{82d}'), ('࠰', '࠾')];

                pub const SAURASHTRA: &'static [(char, char)] =
                    &[('ꢀ', '\u{a8c5}'), ('꣎', '꣙')];

                pub const SHARADA: &'static [(char, char)] = &[('\u{11180}', '𑇟')];

                pub const SHAVIAN: &'static [(char, char)] = &[('𐑐', '𐑿')];

                pub const SIDDHAM: &'static [(char, char)] =
                    &[('𑖀', '\u{115b5}'), ('𑖸', '\u{115dd}')];

                pub const SIGNWRITING: &'static [(char, char)] =
                    &[('𝠀', '𝪋'), ('\u{1da9b}', '\u{1da9f}'), ('\u{1daa1}', '\u{1daaf}')];

                pub const SINHALA: &'static [(char, char)] = &[
                    ('\u{d81}', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('෦', '෯'),
                    ('ෲ', '෴'),
                    ('𑇡', '𑇴'),
                ];

                pub const SOGDIAN: &'static [(char, char)] = &[('𐼰', '𐽙')];

                pub const SORA_SOMPENG: &'static [(char, char)] = &[('𑃐', '𑃨'), ('𑃰', '𑃹')];

                pub const SOYOMBO: &'static [(char, char)] = &[('𑩐', '𑪢')];

                pub const SUNDANESE: &'static [(char, char)] =
                    &[('\u{1b80}', 'ᮿ'), ('᳀', '᳇')];

                pub const SUNUWAR: &'static [(char, char)] = &[('𑯀', '𑯡'), ('𑯰', '𑯹')];

                pub const SYLOTI_NAGRI: &'static [(char, char)] = &[('ꠀ', '\u{a82c}')];

                pub const SYRIAC: &'static [(char, char)] =
                    &[('܀', '܍'), ('\u{70f}', '\u{74a}'), ('ݍ', 'ݏ'), ('ࡠ', 'ࡪ')];

                pub const TAGALOG: &'static [(char, char)] = &[('ᜀ', '\u{1715}'), ('ᜟ', 'ᜟ')];

                pub const TAGBANWA: &'static [(char, char)] =
                    &[('ᝠ', 'ᝬ'), ('ᝮ', 'ᝰ'), ('\u{1772}', '\u{1773}')];

                pub const TAI_LE: &'static [(char, char)] = &[('ᥐ', 'ᥭ'), ('ᥰ', 'ᥴ')];

                pub const TAI_THAM: &'static [(char, char)] = &[
                    ('ᨠ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '᪉'),
                    ('᪐', '᪙'),
                    ('᪠', '᪭'),
                ];

                pub const TAI_VIET: &'static [(char, char)] = &[('ꪀ', 'ꫂ'), ('ꫛ', '꫟')];

                pub const TAKRI: &'static [(char, char)] = &[('𑚀', '𑚹'), ('𑛀', '𑛉')];

                pub const TAMIL: &'static [(char, char)] = &[
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('ௐ', 'ௐ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('௦', '௺'),
                    ('𑿀', '𑿱'),
                    ('𑿿', '𑿿'),
                ];

                pub const TANGSA: &'static [(char, char)] = &[('𖩰', '𖪾'), ('𖫀', '𖫉')];

                pub const TANGUT: &'static [(char, char)] =
                    &[('𖿠', '𖿠'), ('𗀀', '𘟷'), ('𘠀', '𘫿'), ('𘴀', '𘴈')];

                pub const TELUGU: &'static [(char, char)] = &[
                    ('\u{c00}', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('\u{c3c}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', '\u{c63}'),
                    ('౦', '౯'),
                    ('౷', '౿'),
                ];

                pub const THAANA: &'static [(char, char)] = &[('ހ', 'ޱ')];

                pub const THAI: &'static [(char, char)] = &[('ก', '\u{e3a}'), ('เ', '๛')];

                pub const TIBETAN: &'static [(char, char)] = &[
                    ('ༀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('\u{f71}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('྾', '࿌'),
                    ('࿎', '࿔'),
                    ('࿙', '࿚'),
                ];

                pub const TIFINAGH: &'static [(char, char)] =
                    &[('ⴰ', 'ⵧ'), ('ⵯ', '⵰'), ('\u{2d7f}', '\u{2d7f}')];

                pub const TIRHUTA: &'static [(char, char)] = &[('𑒀', '𑓇'), ('𑓐', '𑓙')];

                pub const TODHRI: &'static [(char, char)] = &[('𐗀', '𐗳')];

                pub const TOTO: &'static [(char, char)] = &[('𞊐', '\u{1e2ae}')];

                pub const TULU_TIGALARI: &'static [(char, char)] = &[
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏕'),
                    ('𑏗', '𑏘'),
                    ('\u{113e1}', '\u{113e2}'),
                ];

                pub const UGARITIC: &'static [(char, char)] = &[('𐎀', '𐎝'), ('𐎟', '𐎟')];

                pub const VAI: &'static [(char, char)] = &[('ꔀ', 'ꘫ')];

                pub const VITHKUQI: &'static [(char, char)] = &[
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                ];

                pub const WANCHO: &'static [(char, char)] = &[('𞋀', '𞋹'), ('𞋿', '𞋿')];

                pub const WARANG_CITI: &'static [(char, char)] = &[('𑢠', '𑣲'), ('𑣿', '𑣿')];

                pub const YEZIDI: &'static [(char, char)] =
                    &[('𐺀', '𐺩'), ('\u{10eab}', '𐺭'), ('𐺰', '𐺱')];

                pub const YI: &'static [(char, char)] = &[('ꀀ', 'ꒌ'), ('꒐', '꓆')];

                pub const ZANABAZAR_SQUARE: &'static [(char, char)] = &[('𑨀', '\u{11a47}')];
            }

            pub mod script_extension
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &[
                    ("Adlam", ADLAM),
                    ("Ahom", AHOM),
                    ("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS),
                    ("Arabic", ARABIC),
                    ("Armenian", ARMENIAN),
                    ("Avestan", AVESTAN),
                    ("Balinese", BALINESE),
                    ("Bamum", BAMUM),
                    ("Bassa_Vah", BASSA_VAH),
                    ("Batak", BATAK),
                    ("Bengali", BENGALI),
                    ("Bhaiksuki", BHAIKSUKI),
                    ("Bopomofo", BOPOMOFO),
                    ("Brahmi", BRAHMI),
                    ("Braille", BRAILLE),
                    ("Buginese", BUGINESE),
                    ("Buhid", BUHID),
                    ("Canadian_Aboriginal", CANADIAN_ABORIGINAL),
                    ("Carian", CARIAN),
                    ("Caucasian_Albanian", CAUCASIAN_ALBANIAN),
                    ("Chakma", CHAKMA),
                    ("Cham", CHAM),
                    ("Cherokee", CHEROKEE),
                    ("Chorasmian", CHORASMIAN),
                    ("Common", COMMON),
                    ("Coptic", COPTIC),
                    ("Cuneiform", CUNEIFORM),
                    ("Cypriot", CYPRIOT),
                    ("Cypro_Minoan", CYPRO_MINOAN),
                    ("Cyrillic", CYRILLIC),
                    ("Deseret", DESERET),
                    ("Devanagari", DEVANAGARI),
                    ("Dives_Akuru", DIVES_AKURU),
                    ("Dogra", DOGRA),
                    ("Duployan", DUPLOYAN),
                    ("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS),
                    ("Elbasan", ELBASAN),
                    ("Elymaic", ELYMAIC),
                    ("Ethiopic", ETHIOPIC),
                    ("Garay", GARAY),
                    ("Georgian", GEORGIAN),
                    ("Glagolitic", GLAGOLITIC),
                    ("Gothic", GOTHIC),
                    ("Grantha", GRANTHA),
                    ("Greek", GREEK),
                    ("Gujarati", GUJARATI),
                    ("Gunjala_Gondi", GUNJALA_GONDI),
                    ("Gurmukhi", GURMUKHI),
                    ("Gurung_Khema", GURUNG_KHEMA),
                    ("Han", HAN),
                    ("Hangul", HANGUL),
                    ("Hanifi_Rohingya", HANIFI_ROHINGYA),
                    ("Hanunoo", HANUNOO),
                    ("Hatran", HATRAN),
                    ("Hebrew", HEBREW),
                    ("Hiragana", HIRAGANA),
                    ("Imperial_Aramaic", IMPERIAL_ARAMAIC),
                    ("Inherited", INHERITED),
                    ("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),
                    ("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN),
                    ("Javanese", JAVANESE),
                    ("Kaithi", KAITHI),
                    ("Kannada", KANNADA),
                    ("Katakana", KATAKANA),
                    ("Kawi", KAWI),
                    ("Kayah_Li", KAYAH_LI),
                    ("Kharoshthi", KHAROSHTHI),
                    ("Khitan_Small_Script", KHITAN_SMALL_SCRIPT),
                    ("Khmer", KHMER),
                    ("Khojki", KHOJKI),
                    ("Khudawadi", KHUDAWADI),
                    ("Kirat_Rai", KIRAT_RAI),
                    ("Lao", LAO),
                    ("Latin", LATIN),
                    ("Lepcha", LEPCHA),
                    ("Limbu", LIMBU),
                    ("Linear_A", LINEAR_A),
                    ("Linear_B", LINEAR_B),
                    ("Lisu", LISU),
                    ("Lycian", LYCIAN),
                    ("Lydian", LYDIAN),
                    ("Mahajani", MAHAJANI),
                    ("Makasar", MAKASAR),
                    ("Malayalam", MALAYALAM),
                    ("Mandaic", MANDAIC),
                    ("Manichaean", MANICHAEAN),
                    ("Marchen", MARCHEN),
                    ("Masaram_Gondi", MASARAM_GONDI),
                    ("Medefaidrin", MEDEFAIDRIN),
                    ("Meetei_Mayek", MEETEI_MAYEK),
                    ("Mende_Kikakui", MENDE_KIKAKUI),
                    ("Meroitic_Cursive", MEROITIC_CURSIVE),
                    ("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS),
                    ("Miao", MIAO),
                    ("Modi", MODI),
                    ("Mongolian", MONGOLIAN),
                    ("Mro", MRO),
                    ("Multani", MULTANI),
                    ("Myanmar", MYANMAR),
                    ("Nabataean", NABATAEAN),
                    ("Nag_Mundari", NAG_MUNDARI),
                    ("Nandinagari", NANDINAGARI),
                    ("New_Tai_Lue", NEW_TAI_LUE),
                    ("Newa", NEWA),
                    ("Nko", NKO),
                    ("Nushu", NUSHU),
                    ("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),
                    ("Ogham", OGHAM),
                    ("Ol_Chiki", OL_CHIKI),
                    ("Ol_Onal", OL_ONAL),
                    ("Old_Hungarian", OLD_HUNGARIAN),
                    ("Old_Italic", OLD_ITALIC),
                    ("Old_North_Arabian", OLD_NORTH_ARABIAN),
                    ("Old_Permic", OLD_PERMIC),
                    ("Old_Persian", OLD_PERSIAN),
                    ("Old_Sogdian", OLD_SOGDIAN),
                    ("Old_South_Arabian", OLD_SOUTH_ARABIAN),
                    ("Old_Turkic", OLD_TURKIC),
                    ("Old_Uyghur", OLD_UYGHUR),
                    ("Oriya", ORIYA),
                    ("Osage", OSAGE),
                    ("Osmanya", OSMANYA),
                    ("Pahawh_Hmong", PAHAWH_HMONG),
                    ("Palmyrene", PALMYRENE),
                    ("Pau_Cin_Hau", PAU_CIN_HAU),
                    ("Phags_Pa", PHAGS_PA),
                    ("Phoenician", PHOENICIAN),
                    ("Psalter_Pahlavi", PSALTER_PAHLAVI),
                    ("Rejang", REJANG),
                    ("Runic", RUNIC),
                    ("Samaritan", SAMARITAN),
                    ("Saurashtra", SAURASHTRA),
                    ("Sharada", SHARADA),
                    ("Shavian", SHAVIAN),
                    ("Siddham", SIDDHAM),
                    ("SignWriting", SIGNWRITING),
                    ("Sinhala", SINHALA),
                    ("Sogdian", SOGDIAN),
                    ("Sora_Sompeng", SORA_SOMPENG),
                    ("Soyombo", SOYOMBO),
                    ("Sundanese", SUNDANESE),
                    ("Sunuwar", SUNUWAR),
                    ("Syloti_Nagri", SYLOTI_NAGRI),
                    ("Syriac", SYRIAC),
                    ("Tagalog", TAGALOG),
                    ("Tagbanwa", TAGBANWA),
                    ("Tai_Le", TAI_LE),
                    ("Tai_Tham", TAI_THAM),
                    ("Tai_Viet", TAI_VIET),
                    ("Takri", TAKRI),
                    ("Tamil", TAMIL),
                    ("Tangsa", TANGSA),
                    ("Tangut", TANGUT),
                    ("Telugu", TELUGU),
                    ("Thaana", THAANA),
                    ("Thai", THAI),
                    ("Tibetan", TIBETAN),
                    ("Tifinagh", TIFINAGH),
                    ("Tirhuta", TIRHUTA),
                    ("Todhri", TODHRI),
                    ("Toto", TOTO),
                    ("Tulu_Tigalari", TULU_TIGALARI),
                    ("Ugaritic", UGARITIC),
                    ("Vai", VAI),
                    ("Vithkuqi", VITHKUQI),
                    ("Wancho", WANCHO),
                    ("Warang_Citi", WARANG_CITI),
                    ("Yezidi", YEZIDI),
                    ("Yi", YI),
                    ("Zanabazar_Square", ZANABAZAR_SQUARE),
                ];

                pub const ADLAM: &'static [(char, char)] = &[
                    ('؟', '؟'),
                    ('ـ', 'ـ'),
                    ('⁏', '⁏'),
                    ('⹁', '⹁'),
                    ('𞤀', '𞥋'),
                    ('𞥐', '𞥙'),
                    ('𞥞', '𞥟'),
                ];

                pub const AHOM: &'static [(char, char)] =
                    &[('𑜀', '𑜚'), ('\u{1171d}', '\u{1172b}'), ('𑜰', '𑝆')];

                pub const ANATOLIAN_HIEROGLYPHS: &'static [(char, char)] = &[('𔐀', '𔙆')];

                pub const ARABIC: &'static [(char, char)] = &
                [
                    ('\u{600}', '\u{604}'),
                    ('؆', '\u{6dc}'),
                    ('۞', 'ۿ'),
                    ('ݐ', 'ݿ'),
                    ('ࡰ', 'ࢎ'),
                    ('\u{890}', '\u{891}'),
                    ('\u{897}', '\u{8e1}'),
                    ('\u{8e3}', '\u{8ff}'),
                    ('⁏', '⁏'),
                    ('⹁', '⹁'),
                    ('ﭐ', '﯂'),
                    ('ﯓ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('﷏', '﷏'),
                    ('ﷰ', '﷿'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('\u{102e0}', '𐋻'),
                    ('𐹠', '𐹾'),
                    ('𐻂', '𐻄'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𞻰', '𞻱'),
                ];

                pub const ARMENIAN: &'static [(char, char)] =
                    &[('\u{308}', '\u{308}'), ('Ա', 'Ֆ'), ('ՙ', '֊'), ('֍', '֏'), ('ﬓ', 'ﬗ')];

                pub const AVESTAN: &'static [(char, char)] =
                    &[('·', '·'), ('⸰', '⸱'), ('𐬀', '𐬵'), ('𐬹', '𐬿')];

                pub const BALINESE: &'static [(char, char)] = &[('\u{1b00}', 'ᭌ'), ('᭎', '᭿')];

                pub const BAMUM: &'static [(char, char)] = &[('ꚠ', '꛷'), ('𖠀', '𖨸')];

                pub const BASSA_VAH: &'static [(char, char)] =
                    &[('𖫐', '𖫭'), ('\u{16af0}', '𖫵')];

                pub const BATAK: &'static [(char, char)] = &[('ᯀ', '\u{1bf3}'), ('᯼', '᯿')];

                pub const BENGALI: &'static [(char, char)] = &[
                    ('ʼ', 'ʼ'),
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('ঀ', 'ঃ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('\u{9bc}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', 'ৎ'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('ড়', 'ঢ়'),
                    ('য়', '\u{9e3}'),
                    ('০', '\u{9fe}'),
                    ('\u{1cd0}', '\u{1cd0}'),
                    ('\u{1cd2}', '\u{1cd2}'),
                    ('\u{1cd5}', '\u{1cd6}'),
                    ('\u{1cd8}', '\u{1cd8}'),
                    ('᳡', '᳡'),
                    ('ᳪ', 'ᳪ'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('ᳲ', 'ᳲ'),
                    ('ᳵ', '᳷'),
                    ('\u{a8f1}', '\u{a8f1}'),
                ];

                pub const BHAIKSUKI: &'static [(char, char)] =
                    &[('𑰀', '𑰈'), ('𑰊', '\u{11c36}'), ('\u{11c38}', '𑱅'), ('𑱐', '𑱬')];

                pub const BOPOMOFO: &'static [(char, char)] = &[
                    ('ˇ', 'ˇ'),
                    ('ˉ', 'ˋ'),
                    ('˙', '˙'),
                    ('˪', '˫'),
                    ('、', '〃'),
                    ('〈', '】'),
                    ('〓', '〟'),
                    ('\u{302a}', '\u{302d}'),
                    ('〰', '〰'),
                    ('〷', '〷'),
                    ('・', '・'),
                    ('ㄅ', 'ㄯ'),
                    ('ㆠ', 'ㆿ'),
                    ('﹅', '﹆'),
                    ('｡', '･'),
                ];

                pub const BRAHMI: &'static [(char, char)] =
                    &[('𑀀', '𑁍'), ('𑁒', '𑁵'), ('\u{1107f}', '\u{1107f}')];

                pub const BRAILLE: &'static [(char, char)] = &[('⠀', '⣿')];

                pub const BUGINESE: &'static [(char, char)] =
                    &[('ᨀ', '\u{1a1b}'), ('᨞', '᨟'), ('ꧏ', 'ꧏ')];

                pub const BUHID: &'static [(char, char)] = &[('᜵', '᜶'), ('ᝀ', '\u{1753}')];

                pub const CANADIAN_ABORIGINAL: &'static [(char, char)] =
                    &[('᐀', 'ᙿ'), ('ᢰ', 'ᣵ'), ('𑪰', '𑪿')];

                pub const CARIAN: &'static [(char, char)] =
                    &[('·', '·'), ('⁚', '⁚'), ('⁝', '⁝'), ('⸱', '⸱'), ('𐊠', '𐋐')];

                pub const CAUCASIAN_ALBANIAN: &'static [(char, char)] = &[
                    ('\u{304}', '\u{304}'),
                    ('\u{331}', '\u{331}'),
                    ('\u{35e}', '\u{35e}'),
                    ('𐔰', '𐕣'),
                    ('𐕯', '𐕯'),
                ];

                pub const CHAKMA: &'static [(char, char)] =
                    &[('০', '৯'), ('၀', '၉'), ('\u{11100}', '\u{11134}'), ('𑄶', '𑅇')];

                pub const CHAM: &'static [(char, char)] =
                    &[('ꨀ', '\u{aa36}'), ('ꩀ', 'ꩍ'), ('꩐', '꩙'), ('꩜', '꩟')];

                pub const CHEROKEE: &'static [(char, char)] = &[
                    ('\u{300}', '\u{302}'),
                    ('\u{304}', '\u{304}'),
                    ('\u{30b}', '\u{30c}'),
                    ('\u{323}', '\u{324}'),
                    ('\u{330}', '\u{331}'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ꭰ', 'ꮿ'),
                ];

                pub const CHORASMIAN: &'static [(char, char)] = &[('𐾰', '𐿋')];

                pub const COMMON: &'static [(char, char)] = &[
                    ('\0', '@'),
                    ('[', '`'),
                    ('{', '©'),
                    ('«', '¶'),
                    ('¸', '¹'),
                    ('»', '¿'),
                    ('×', '×'),
                    ('÷', '÷'),
                    ('ʹ', 'ʻ'),
                    ('ʽ', 'ˆ'),
                    ('ˈ', 'ˈ'),
                    ('ˌ', 'ˌ'),
                    ('ˎ', '˖'),
                    ('˘', '˘'),
                    ('˚', '˟'),
                    ('˥', '˩'),
                    ('ˬ', '˿'),
                    (';', ';'),
                    ('΅', '΅'),
                    ('·', '·'),
                    ('\u{605}', '\u{605}'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('฿', '฿'),
                    ('࿕', '࿘'),
                    ('\u{2000}', '\u{200b}'),
                    ('\u{200e}', '\u{202e}'),
                    ('‰', '⁎'),
                    ('⁐', '⁙'),
                    ('⁛', '⁜'),
                    ('⁞', '\u{2064}'),
                    ('\u{2066}', '⁰'),
                    ('⁴', '⁾'),
                    ('₀', '₎'),
                    ('₠', '⃀'),
                    ('℀', '℥'),
                    ('℧', '℩'),
                    ('ℬ', 'ℱ'),
                    ('ℳ', '⅍'),
                    ('⅏', '⅟'),
                    ('↉', '↋'),
                    ('←', '␩'),
                    ('⑀', '⑊'),
                    ('①', '⟿'),
                    ('⤀', '⭳'),
                    ('⭶', '⮕'),
                    ('⮗', '⯿'),
                    ('⸀', '⸖'),
                    ('⸘', 'ⸯ'),
                    ('⸲', '⸻'),
                    ('⸽', '⹀'),
                    ('⹂', '⹂'),
                    ('⹄', '⹝'),
                    ('\u{3000}', '\u{3000}'),
                    ('〄', '〄'),
                    ('〒', '〒'),
                    ('〠', '〠'),
                    ('〶', '〶'),
                    ('㉈', '㉟'),
                    ('㉿', '㉿'),
                    ('㊱', '㊿'),
                    ('㋌', '㋏'),
                    ('㍱', '㍺'),
                    ('㎀', '㏟'),
                    ('㏿', '㏿'),
                    ('䷀', '䷿'),
                    ('꜈', '꜡'),
                    ('ꞈ', '꞊'),
                    ('꭛', '꭛'),
                    ('꭪', '꭫'),
                    ('︐', '︙'),
                    ('︰', '﹄'),
                    ('﹇', '﹒'),
                    ('﹔', '﹦'),
                    ('﹨', '﹫'),
                    ('\u{feff}', '\u{feff}'),
                    ('！', '＠'),
                    ('［', '｀'),
                    ('｛', '｠'),
                    ('￠', '￦'),
                    ('￨', '￮'),
                    ('\u{fff9}', ' '),
                    ('𐆐', '𐆜'),
                    ('𐇐', '𐇼'),
                    ('𜰀', '𜳹'),
                    ('𜴀', '𜺳'),
                    ('𜽐', '𜿃'),
                    ('𝀀', '𝃵'),
                    ('𝄀', '𝄦'),
                    ('𝄩', '\u{1d166}'),
                    ('𝅪', '\u{1d17a}'),
                    ('𝆃', '𝆄'),
                    ('𝆌', '𝆩'),
                    ('𝆮', '𝇪'),
                    ('𝋀', '𝋓'),
                    ('𝋠', '𝋳'),
                    ('𝌀', '𝍖'),
                    ('𝍲', '𝍸'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝟋'),
                    ('𝟎', '𝟿'),
                    ('𞱱', '𞲴'),
                    ('𞴁', '𞴽'),
                    ('🀀', '🀫'),
                    ('🀰', '🂓'),
                    ('🂠', '🂮'),
                    ('🂱', '🂿'),
                    ('🃁', '🃏'),
                    ('🃑', '🃵'),
                    ('🄀', '🆭'),
                    ('🇦', '🇿'),
                    ('🈁', '🈂'),
                    ('🈐', '🈻'),
                    ('🉀', '🉈'),
                    ('🉠', '🉥'),
                    ('🌀', '🛗'),
                    ('🛜', '🛬'),
                    ('🛰', '🛼'),
                    ('🜀', '🝶'),
                    ('🝻', '🟙'),
                    ('🟠', '🟫'),
                    ('🟰', '🟰'),
                    ('🠀', '🠋'),
                    ('🠐', '🡇'),
                    ('🡐', '🡙'),
                    ('🡠', '🢇'),
                    ('🢐', '🢭'),
                    ('🢰', '🢻'),
                    ('🣀', '🣁'),
                    ('🤀', '🩓'),
                    ('🩠', '🩭'),
                    ('🩰', '🩼'),
                    ('🪀', '🪉'),
                    ('🪏', '🫆'),
                    ('🫎', '🫜'),
                    ('🫟', '🫩'),
                    ('🫰', '🫸'),
                    ('🬀', '🮒'),
                    ('🮔', '🯹'),
                    ('\u{e0001}', '\u{e0001}'),
                    ('\u{e0020}', '\u{e007f}'),
                ];

                pub const COPTIC: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('\u{300}', '\u{300}'),
                    ('\u{304}', '\u{305}'),
                    ('\u{307}', '\u{307}'),
                    ('ʹ', '͵'),
                    ('Ϣ', 'ϯ'),
                    ('Ⲁ', 'ⳳ'),
                    ('⳹', '⳿'),
                    ('⸗', '⸗'),
                    ('\u{102e0}', '𐋻'),
                ];

                pub const CUNEIFORM: &'static [(char, char)] =
                    &[('𒀀', '𒎙'), ('𒐀', '𒑮'), ('𒑰', '𒑴'), ('𒒀', '𒕃')];

                pub const CYPRIOT: &'static [(char, char)] = &[
                    ('𐄀', '𐄂'),
                    ('𐄇', '𐄳'),
                    ('𐄷', '𐄿'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐠿'),
                ];

                pub const CYPRO_MINOAN: &'static [(char, char)] = &[('𐄀', '𐄁'), ('𒾐', '𒿲')];

                pub const CYRILLIC: &'static [(char, char)] = &[
                    ('ʼ', 'ʼ'),
                    ('\u{300}', '\u{302}'),
                    ('\u{304}', '\u{304}'),
                    ('\u{306}', '\u{306}'),
                    ('\u{308}', '\u{308}'),
                    ('\u{30b}', '\u{30b}'),
                    ('\u{311}', '\u{311}'),
                    ('Ѐ', 'ԯ'),
                    ('ᲀ', 'ᲊ'),
                    ('ᴫ', 'ᴫ'),
                    ('ᵸ', 'ᵸ'),
                    ('\u{1df8}', '\u{1df8}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('⹃', '⹃'),
                    ('Ꙁ', '\u{a69f}'),
                    ('\u{fe2e}', '\u{fe2f}'),
                    ('𞀰', '𞁭'),
                    ('\u{1e08f}', '\u{1e08f}'),
                ];

                pub const DESERET: &'static [(char, char)] = &[('𐐀', '𐑏')];

                pub const DEVANAGARI: &'static [(char, char)] = &[
                    ('ʼ', 'ʼ'),
                    ('\u{900}', '\u{952}'),
                    ('\u{955}', 'ॿ'),
                    ('\u{1cd0}', 'ᳶ'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{20f0}', '\u{20f0}'),
                    ('꠰', '꠹'),
                    ('\u{a8e0}', '\u{a8ff}'),
                    ('𑬀', '𑬉'),
                ];

                pub const DIVES_AKURU: &'static [(char, char)] = &[
                    ('𑤀', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '𑥆'),
                    ('𑥐', '𑥙'),
                ];

                pub const DOGRA: &'static [(char, char)] =
                    &[('।', '९'), ('꠰', '꠹'), ('𑠀', '𑠻')];

                pub const DUPLOYAN: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('\u{307}', '\u{308}'),
                    ('\u{30a}', '\u{30a}'),
                    ('\u{323}', '\u{324}'),
                    ('⸼', '⸼'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𛲜', '\u{1bca3}'),
                ];

                pub const EGYPTIAN_HIEROGLYPHS: &'static [(char, char)] =
                    &[('𓀀', '\u{13455}'), ('𓑠', '𔏺')];

                pub const ELBASAN: &'static [(char, char)] =
                    &[('·', '·'), ('\u{305}', '\u{305}'), ('𐔀', '𐔧')];

                pub const ELYMAIC: &'static [(char, char)] = &[('𐿠', '𐿶')];

                pub const ETHIOPIC: &'static [(char, char)] = &[
                    ('\u{30e}', '\u{30e}'),
                    ('ሀ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('\u{135d}', '፼'),
                    ('ᎀ', '᎙'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                ];

                pub const GARAY: &'static [(char, char)] = &[
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؟', '؟'),
                    ('𐵀', '𐵥'),
                    ('\u{10d69}', '𐶅'),
                    ('𐶎', '𐶏'),
                ];

                pub const GEORGIAN: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('։', '։'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჿ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('⁚', '⁚'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('⸱', '⸱'),
                ];

                pub const GLAGOLITIC: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('\u{303}', '\u{303}'),
                    ('\u{305}', '\u{305}'),
                    ('\u{484}', '\u{484}'),
                    ('\u{487}', '\u{487}'),
                    ('։', '։'),
                    ('჻', '჻'),
                    ('⁚', '⁚'),
                    ('Ⰰ', 'ⱟ'),
                    ('⹃', '⹃'),
                    ('\u{a66f}', '\u{a66f}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                ];

                pub const GOTHIC: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('\u{304}', '\u{305}'),
                    ('\u{308}', '\u{308}'),
                    ('\u{331}', '\u{331}'),
                    ('𐌰', '𐍊'),
                ];

                pub const GRANTHA: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('௦', '௳'),
                    ('\u{1cd0}', '\u{1cd0}'),
                    ('\u{1cd2}', '᳓'),
                    ('ᳲ', '\u{1cf4}'),
                    ('\u{1cf8}', '\u{1cf9}'),
                    ('\u{20f0}', '\u{20f0}'),
                    ('\u{11300}', '𑌃'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('\u{1133b}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('𑍐', '𑍐'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍝', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('𑿐', '𑿑'),
                    ('𑿓', '𑿓'),
                ];

                pub const GREEK: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('\u{300}', '\u{301}'),
                    ('\u{304}', '\u{304}'),
                    ('\u{306}', '\u{306}'),
                    ('\u{308}', '\u{308}'),
                    ('\u{313}', '\u{313}'),
                    ('\u{342}', '\u{342}'),
                    ('\u{345}', '\u{345}'),
                    ('Ͱ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('΄', '΄'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϡ'),
                    ('ϰ', 'Ͽ'),
                    ('ᴦ', 'ᴪ'),
                    ('ᵝ', 'ᵡ'),
                    ('ᵦ', 'ᵪ'),
                    ('ᶿ', '\u{1dc1}'),
                    ('ἀ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ῄ'),
                    ('ῆ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('῝', '`'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', '῾'),
                    ('⁝', '⁝'),
                    ('Ω', 'Ω'),
                    ('ꭥ', 'ꭥ'),
                    ('𐅀', '𐆎'),
                    ('𐆠', '𐆠'),
                    ('𝈀', '𝉅'),
                ];

                pub const GUJARATI: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('\u{a81}', 'ઃ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('\u{abc}', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', '\u{ae3}'),
                    ('૦', '૱'),
                    ('ૹ', '\u{aff}'),
                    ('꠰', '꠹'),
                ];

                pub const GUNJALA_GONDI: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('।', '॥'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '𑶘'),
                    ('𑶠', '𑶩'),
                ];

                pub const GURMUKHI: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('\u{a01}', 'ਃ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('੦', '੶'),
                    ('꠰', '꠹'),
                ];

                pub const GURUNG_KHEMA: &'static [(char, char)] = &[('॥', '॥'), ('𖄀', '𖄹')];

                pub const HAN: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('⺀', '⺙'),
                    ('⺛', '⻳'),
                    ('⼀', '⿕'),
                    ('⿰', '⿿'),
                    ('、', '〃'),
                    ('々', '】'),
                    ('〓', '〟'),
                    ('〡', '\u{302d}'),
                    ('〰', '〰'),
                    ('〷', '〿'),
                    ('・', '・'),
                    ('㆐', '㆟'),
                    ('㇀', '㇥'),
                    ('㇯', '㇯'),
                    ('㈠', '㉇'),
                    ('㊀', '㊰'),
                    ('㋀', '㋋'),
                    ('㋿', '㋿'),
                    ('㍘', '㍰'),
                    ('㍻', '㍿'),
                    ('㏠', '㏾'),
                    ('㐀', '䶿'),
                    ('一', '鿿'),
                    ('꜀', '꜇'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('﹅', '﹆'),
                    ('｡', '･'),
                    ('𖿢', '𖿣'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('𝍠', '𝍱'),
                    ('🉐', '🉑'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const HANGUL: &'static [(char, char)] = &[
                    ('ᄀ', 'ᇿ'),
                    ('、', '〃'),
                    ('〈', '】'),
                    ('〓', '〟'),
                    ('\u{302e}', '〰'),
                    ('〷', '〷'),
                    ('・', '・'),
                    ('ㄱ', 'ㆎ'),
                    ('㈀', '㈞'),
                    ('㉠', '㉾'),
                    ('ꥠ', 'ꥼ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('﹅', '﹆'),
                    ('｡', '･'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                ];

                pub const HANIFI_ROHINGYA: &'static [(char, char)] = &[
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؟', '؟'),
                    ('ـ', 'ـ'),
                    ('۔', '۔'),
                    ('𐴀', '\u{10d27}'),
                    ('𐴰', '𐴹'),
                ];

                pub const HANUNOO: &'static [(char, char)] = &[('ᜠ', '᜶')];

                pub const HATRAN: &'static [(char, char)] =
                    &[('𐣠', '𐣲'), ('𐣴', '𐣵'), ('𐣻', '𐣿')];

                pub const HEBREW: &'static [(char, char)] = &[
                    ('\u{307}', '\u{308}'),
                    ('\u{591}', '\u{5c7}'),
                    ('א', 'ת'),
                    ('ׯ', '״'),
                    ('יִ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﭏ'),
                ];

                pub const HIRAGANA: &'static [(char, char)] = &[
                    ('、', '〃'),
                    ('〈', '】'),
                    ('〓', '〟'),
                    ('〰', '〵'),
                    ('〷', '〷'),
                    ('〼', '〽'),
                    ('ぁ', 'ゖ'),
                    ('\u{3099}', '゠'),
                    ('・', 'ー'),
                    ('﹅', '﹆'),
                    ('｡', '･'),
                    ('ｰ', 'ｰ'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('𛀁', '𛄟'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('🈀', '🈀'),
                ];

                pub const IMPERIAL_ARAMAIC: &'static [(char, char)] =
                    &[('𐡀', '𐡕'), ('𐡗', '𐡟')];

                pub const INHERITED: &'static [(char, char)] = &[
                    ('\u{30f}', '\u{30f}'),
                    ('\u{312}', '\u{312}'),
                    ('\u{314}', '\u{31f}'),
                    ('\u{321}', '\u{322}'),
                    ('\u{326}', '\u{32c}'),
                    ('\u{32f}', '\u{32f}'),
                    ('\u{332}', '\u{341}'),
                    ('\u{343}', '\u{344}'),
                    ('\u{346}', '\u{357}'),
                    ('\u{359}', '\u{35d}'),
                    ('\u{35f}', '\u{362}'),
                    ('\u{953}', '\u{954}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1dc2}', '\u{1df7}'),
                    ('\u{1df9}', '\u{1df9}'),
                    ('\u{1dfb}', '\u{1dff}'),
                    ('\u{200c}', '\u{200d}'),
                    ('\u{20d0}', '\u{20ef}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2d}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d167}', '\u{1d169}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const INSCRIPTIONAL_PAHLAVI: &'static [(char, char)] =
                    &[('𐭠', '𐭲'), ('𐭸', '𐭿')];

                pub const INSCRIPTIONAL_PARTHIAN: &'static [(char, char)] =
                    &[('𐭀', '𐭕'), ('𐭘', '𐭟')];

                pub const JAVANESE: &'static [(char, char)] =
                    &[('\u{a980}', '꧍'), ('ꧏ', '꧙'), ('꧞', '꧟')];

                pub const KAITHI: &'static [(char, char)] = &[
                    ('०', '९'),
                    ('⸱', '⸱'),
                    ('꠰', '꠹'),
                    ('\u{11080}', '\u{110c2}'),
                    ('\u{110cd}', '\u{110cd}'),
                ];

                pub const KANNADA: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('ಀ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('\u{cbc}', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', '\u{ce3}'),
                    ('೦', '೯'),
                    ('ೱ', 'ೳ'),
                    ('\u{1cd0}', '\u{1cd0}'),
                    ('\u{1cd2}', '᳓'),
                    ('\u{1cda}', '\u{1cda}'),
                    ('ᳲ', 'ᳲ'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('꠰', '꠵'),
                ];

                pub const KATAKANA: &'static [(char, char)] = &[
                    ('\u{305}', '\u{305}'),
                    ('\u{323}', '\u{323}'),
                    ('、', '〃'),
                    ('〈', '】'),
                    ('〓', '〟'),
                    ('〰', '〵'),
                    ('〷', '〷'),
                    ('〼', '〽'),
                    ('\u{3099}', '゜'),
                    ('゠', 'ヿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㋐', '㋾'),
                    ('㌀', '㍗'),
                    ('﹅', '﹆'),
                    ('｡', '\u{ff9f}'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛀀'),
                    ('𛄠', '𛄢'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                ];

                pub const KAWI: &'static [(char, char)] =
                    &[('\u{11f00}', '𑼐'), ('𑼒', '\u{11f3a}'), ('𑼾', '\u{11f5a}')];

                pub const KAYAH_LI: &'static [(char, char)] = &[('꤀', '꤯')];

                pub const KHAROSHTHI: &'static [(char, char)] = &[
                    ('𐨀', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '𐩈'),
                    ('𐩐', '𐩘'),
                ];

                pub const KHITAN_SMALL_SCRIPT: &'static [(char, char)] =
                    &[('\u{16fe4}', '\u{16fe4}'), ('𘬀', '𘳕'), ('𘳿', '𘳿')];

                pub const KHMER: &'static [(char, char)] =
                    &[('ក', '\u{17dd}'), ('០', '៩'), ('៰', '៹'), ('᧠', '᧿')];

                pub const KHOJKI: &'static [(char, char)] =
                    &[('૦', '૯'), ('꠰', '꠹'), ('𑈀', '𑈑'), ('𑈓', '\u{11241}')];

                pub const KHUDAWADI: &'static [(char, char)] =
                    &[('।', '॥'), ('꠰', '꠹'), ('𑊰', '\u{112ea}'), ('𑋰', '𑋹')];

                pub const KIRAT_RAI: &'static [(char, char)] = &[('𖵀', '𖵹')];

                pub const LAO: &'static [(char, char)] = &[
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('\u{ec8}', '\u{ece}'),
                    ('໐', '໙'),
                    ('ໜ', 'ໟ'),
                ];

                pub const LATIN: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('·', '·'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', 'ʸ'),
                    ('ʼ', 'ʼ'),
                    ('ˇ', 'ˇ'),
                    ('ˉ', 'ˋ'),
                    ('ˍ', 'ˍ'),
                    ('˗', '˗'),
                    ('˙', '˙'),
                    ('ˠ', 'ˤ'),
                    ('\u{300}', '\u{30e}'),
                    ('\u{310}', '\u{311}'),
                    ('\u{313}', '\u{313}'),
                    ('\u{320}', '\u{320}'),
                    ('\u{323}', '\u{325}'),
                    ('\u{32d}', '\u{32e}'),
                    ('\u{330}', '\u{331}'),
                    ('\u{358}', '\u{358}'),
                    ('\u{35e}', '\u{35e}'),
                    ('\u{363}', '\u{36f}'),
                    ('\u{485}', '\u{486}'),
                    ('\u{951}', '\u{952}'),
                    ('჻', '჻'),
                    ('ᴀ', 'ᴥ'),
                    ('ᴬ', 'ᵜ'),
                    ('ᵢ', 'ᵥ'),
                    ('ᵫ', 'ᵷ'),
                    ('ᵹ', 'ᶾ'),
                    ('\u{1df8}', '\u{1df8}'),
                    ('Ḁ', 'ỿ'),
                    ('\u{202f}', '\u{202f}'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('\u{20f0}', '\u{20f0}'),
                    ('K', 'Å'),
                    ('Ⅎ', 'Ⅎ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⱡ', 'Ɀ'),
                    ('⸗', '⸗'),
                    ('꜀', '꜇'),
                    ('Ꜣ', 'ꞇ'),
                    ('Ꞌ', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꟿ'),
                    ('꤮', '꤮'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭤ'),
                    ('ꭦ', 'ꭩ'),
                    ('ﬀ', 'ﬆ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                ];

                pub const LEPCHA: &'static [(char, char)] =
                    &[('ᰀ', '\u{1c37}'), ('᰻', '᱉'), ('ᱍ', 'ᱏ')];

                pub const LIMBU: &'static [(char, char)] = &[
                    ('॥', '॥'),
                    ('ᤀ', 'ᤞ'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('᥀', '᥀'),
                    ('᥄', '᥏'),
                ];

                pub const LINEAR_A: &'static [(char, char)] =
                    &[('𐄇', '𐄳'), ('𐘀', '𐜶'), ('𐝀', '𐝕'), ('𐝠', '𐝧')];

                pub const LINEAR_B: &'static [(char, char)] = &[
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐄀', '𐄂'),
                    ('𐄇', '𐄳'),
                    ('𐄷', '𐄿'),
                ];

                pub const LISU: &'static [(char, char)] =
                    &[('ʼ', 'ʼ'), ('ˍ', 'ˍ'), ('《', '》'), ('ꓐ', '꓿'), ('𑾰', '𑾰')];

                pub const LYCIAN: &'static [(char, char)] = &[('⁚', '⁚'), ('𐊀', '𐊜')];

                pub const LYDIAN: &'static [(char, char)] =
                    &[('·', '·'), ('⸱', '⸱'), ('𐤠', '𐤹'), ('𐤿', '𐤿')];

                pub const MAHAJANI: &'static [(char, char)] =
                    &[('·', '·'), ('।', '९'), ('꠰', '꠹'), ('𑅐', '𑅶')];

                pub const MAKASAR: &'static [(char, char)] = &[('𑻠', '𑻸')];

                pub const MALAYALAM: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('\u{d00}', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', '൏'),
                    ('ൔ', '\u{d63}'),
                    ('൦', 'ൿ'),
                    ('\u{1cda}', '\u{1cda}'),
                    ('ᳲ', 'ᳲ'),
                    ('꠰', '꠲'),
                ];

                pub const MANDAIC: &'static [(char, char)] =
                    &[('ـ', 'ـ'), ('ࡀ', '\u{85b}'), ('࡞', '࡞')];

                pub const MANICHAEAN: &'static [(char, char)] =
                    &[('ـ', 'ـ'), ('𐫀', '\u{10ae6}'), ('𐫫', '𐫶')];

                pub const MARCHEN: &'static [(char, char)] =
                    &[('𑱰', '𑲏'), ('\u{11c92}', '\u{11ca7}'), ('𑲩', '\u{11cb6}')];

                pub const MASARAM_GONDI: &'static [(char, char)] = &[
                    ('।', '॥'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d47}'),
                    ('𑵐', '𑵙'),
                ];

                pub const MEDEFAIDRIN: &'static [(char, char)] = &[('𖹀', '𖺚')];

                pub const MEETEI_MAYEK: &'static [(char, char)] =
                    &[('ꫠ', '\u{aaf6}'), ('ꯀ', '\u{abed}'), ('꯰', '꯹')];

                pub const MENDE_KIKAKUI: &'static [(char, char)] =
                    &[('𞠀', '𞣄'), ('𞣇', '\u{1e8d6}')];

                pub const MEROITIC_CURSIVE: &'static [(char, char)] =
                    &[('𐦠', '𐦷'), ('𐦼', '𐧏'), ('𐧒', '𐧿')];

                pub const MEROITIC_HIEROGLYPHS: &'static [(char, char)] =
                    &[('⁝', '⁝'), ('𐦀', '𐦟')];

                pub const MIAO: &'static [(char, char)] =
                    &[('𖼀', '𖽊'), ('\u{16f4f}', '𖾇'), ('\u{16f8f}', '𖾟')];

                pub const MODI: &'static [(char, char)] =
                    &[('꠰', '꠹'), ('𑘀', '𑙄'), ('𑙐', '𑙙')];

                pub const MONGOLIAN: &'static [(char, char)] = &[
                    ('᠀', '᠙'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢪ'),
                    ('\u{202f}', '\u{202f}'),
                    ('、', '。'),
                    ('〈', '》'),
                    ('𑙠', '𑙬'),
                ];

                pub const MRO: &'static [(char, char)] = &[('𖩀', '𖩞'), ('𖩠', '𖩩'), ('𖩮', '𖩯')];

                pub const MULTANI: &'static [(char, char)] =
                    &[('੦', '੯'), ('𑊀', '𑊆'), ('𑊈', '𑊈'), ('𑊊', '𑊍'), ('𑊏', '𑊝'), ('𑊟', '𑊩')];

                pub const MYANMAR: &'static [(char, char)] =
                    &[('က', '႟'), ('꤮', '꤮'), ('ꧠ', 'ꧾ'), ('ꩠ', 'ꩿ'), ('𑛐', '𑛣')];

                pub const NABATAEAN: &'static [(char, char)] = &[('𐢀', '𐢞'), ('𐢧', '𐢯')];

                pub const NAG_MUNDARI: &'static [(char, char)] = &[('𞓐', '𞓹')];

                pub const NANDINAGARI: &'static [(char, char)] = &[
                    ('।', '॥'),
                    ('೦', '೯'),
                    ('ᳩ', 'ᳩ'),
                    ('ᳲ', 'ᳲ'),
                    ('ᳺ', 'ᳺ'),
                    ('꠰', '꠵'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '\u{119d7}'),
                    ('\u{119da}', '𑧤'),
                ];

                pub const NEW_TAI_LUE: &'static [(char, char)] =
                    &[('ᦀ', 'ᦫ'), ('ᦰ', 'ᧉ'), ('᧐', '᧚'), ('᧞', '᧟')];

                pub const NEWA: &'static [(char, char)] = &[('𑐀', '𑑛'), ('𑑝', '𑑡')];

                pub const NKO: &'static [(char, char)] = &[
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؟', '؟'),
                    ('߀', 'ߺ'),
                    ('\u{7fd}', '߿'),
                    ('﴾', '﴿'),
                ];

                pub const NUSHU: &'static [(char, char)] = &[('𖿡', '𖿡'), ('𛅰', '𛋻')];

                pub const NYIAKENG_PUACHUE_HMONG: &'static [(char, char)] =
                    &[('𞄀', '𞄬'), ('\u{1e130}', '𞄽'), ('𞅀', '𞅉'), ('𞅎', '𞅏')];

                pub const OGHAM: &'static [(char, char)] = &[('\u{1680}', '᚜')];

                pub const OL_CHIKI: &'static [(char, char)] = &[('᱐', '᱿')];

                pub const OL_ONAL: &'static [(char, char)] =
                    &[('।', '॥'), ('𞗐', '𞗺'), ('𞗿', '𞗿')];

                pub const OLD_HUNGARIAN: &'static [(char, char)] = &[
                    ('⁚', '⁚'),
                    ('⁝', '⁝'),
                    ('⸱', '⸱'),
                    ('⹁', '⹁'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐳺', '𐳿'),
                ];

                pub const OLD_ITALIC: &'static [(char, char)] = &[('𐌀', '𐌣'), ('𐌭', '𐌯')];

                pub const OLD_NORTH_ARABIAN: &'static [(char, char)] = &[('𐪀', '𐪟')];

                pub const OLD_PERMIC: &'static [(char, char)] = &[
                    ('·', '·'),
                    ('\u{300}', '\u{300}'),
                    ('\u{306}', '\u{308}'),
                    ('\u{313}', '\u{313}'),
                    ('\u{483}', '\u{483}'),
                    ('𐍐', '\u{1037a}'),
                ];

                pub const OLD_PERSIAN: &'static [(char, char)] = &[('𐎠', '𐏃'), ('𐏈', '𐏕')];

                pub const OLD_SOGDIAN: &'static [(char, char)] = &[('𐼀', '𐼧')];

                pub const OLD_SOUTH_ARABIAN: &'static [(char, char)] = &[('𐩠', '𐩿')];

                pub const OLD_TURKIC: &'static [(char, char)] =
                    &[('⁚', '⁚'), ('⸰', '⸰'), ('𐰀', '𐱈')];

                pub const OLD_UYGHUR: &'static [(char, char)] =
                    &[('ـ', 'ـ'), ('𐫲', '𐫲'), ('𐽰', '𐾉')];

                pub const ORIYA: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('\u{b01}', 'ଃ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('\u{b3c}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', '\u{b63}'),
                    ('୦', '୷'),
                    ('\u{1cda}', '\u{1cda}'),
                    ('ᳲ', 'ᳲ'),
                ];

                pub const OSAGE: &'static [(char, char)] = &[
                    ('\u{301}', '\u{301}'),
                    ('\u{304}', '\u{304}'),
                    ('\u{30b}', '\u{30b}'),
                    ('\u{358}', '\u{358}'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                ];

                pub const OSMANYA: &'static [(char, char)] = &[('𐒀', '𐒝'), ('𐒠', '𐒩')];

                pub const PAHAWH_HMONG: &'static [(char, char)] =
                    &[('𖬀', '𖭅'), ('𖭐', '𖭙'), ('𖭛', '𖭡'), ('𖭣', '𖭷'), ('𖭽', '𖮏')];

                pub const PALMYRENE: &'static [(char, char)] = &[('𐡠', '𐡿')];

                pub const PAU_CIN_HAU: &'static [(char, char)] = &[('𑫀', '𑫸')];

                pub const PHAGS_PA: &'static [(char, char)] = &[
                    ('᠂', '᠃'),
                    ('᠅', '᠅'),
                    ('\u{202f}', '\u{202f}'),
                    ('。', '。'),
                    ('ꡀ', '꡷'),
                ];

                pub const PHOENICIAN: &'static [(char, char)] = &[('𐤀', '𐤛'), ('𐤟', '𐤟')];

                pub const PSALTER_PAHLAVI: &'static [(char, char)] =
                    &[('ـ', 'ـ'), ('𐮀', '𐮑'), ('𐮙', '𐮜'), ('𐮩', '𐮯')];

                pub const REJANG: &'static [(char, char)] = &[('ꤰ', '\u{a953}'), ('꥟', '꥟')];

                pub const RUNIC: &'static [(char, char)] = &[('ᚠ', 'ᛸ')];

                pub const SAMARITAN: &'static [(char, char)] =
                    &[('ࠀ', '\u{82d}'), ('࠰', '࠾'), ('⸱', '⸱')];

                pub const SAURASHTRA: &'static [(char, char)] =
                    &[('ꢀ', '\u{a8c5}'), ('꣎', '꣙')];

                pub const SHARADA: &'static [(char, char)] = &[
                    ('\u{951}', '\u{951}'),
                    ('\u{1cd7}', '\u{1cd7}'),
                    ('\u{1cd9}', '\u{1cd9}'),
                    ('\u{1cdc}', '\u{1cdd}'),
                    ('\u{1ce0}', '\u{1ce0}'),
                    ('꠰', '꠵'),
                    ('꠸', '꠸'),
                    ('\u{11180}', '𑇟'),
                ];

                pub const SHAVIAN: &'static [(char, char)] = &[('·', '·'), ('𐑐', '𐑿')];

                pub const SIDDHAM: &'static [(char, char)] =
                    &[('𑖀', '\u{115b5}'), ('𑖸', '\u{115dd}')];

                pub const SIGNWRITING: &'static [(char, char)] =
                    &[('𝠀', '𝪋'), ('\u{1da9b}', '\u{1da9f}'), ('\u{1daa1}', '\u{1daaf}')];

                pub const SINHALA: &'static [(char, char)] = &[
                    ('।', '॥'),
                    ('\u{d81}', 'ඃ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('෦', '෯'),
                    ('ෲ', '෴'),
                    ('ᳲ', 'ᳲ'),
                    ('𑇡', '𑇴'),
                ];

                pub const SOGDIAN: &'static [(char, char)] = &[('ـ', 'ـ'), ('𐼰', '𐽙')];

                pub const SORA_SOMPENG: &'static [(char, char)] = &[('𑃐', '𑃨'), ('𑃰', '𑃹')];

                pub const SOYOMBO: &'static [(char, char)] = &[('𑩐', '𑪢')];

                pub const SUNDANESE: &'static [(char, char)] =
                    &[('\u{1b80}', 'ᮿ'), ('᳀', '᳇')];

                pub const SUNUWAR: &'static [(char, char)] = &[
                    ('\u{300}', '\u{301}'),
                    ('\u{303}', '\u{303}'),
                    ('\u{30d}', '\u{30d}'),
                    ('\u{310}', '\u{310}'),
                    ('\u{32d}', '\u{32d}'),
                    ('\u{331}', '\u{331}'),
                    ('𑯀', '𑯡'),
                    ('𑯰', '𑯹'),
                ];

                pub const SYLOTI_NAGRI: &'static [(char, char)] =
                    &[('।', '॥'), ('০', '৯'), ('ꠀ', '\u{a82c}')];

                pub const SYRIAC: &'static [(char, char)] = &[
                    ('\u{303}', '\u{304}'),
                    ('\u{307}', '\u{308}'),
                    ('\u{30a}', '\u{30a}'),
                    ('\u{320}', '\u{320}'),
                    ('\u{323}', '\u{325}'),
                    ('\u{32d}', '\u{32e}'),
                    ('\u{330}', '\u{330}'),
                    ('،', '،'),
                    ('؛', '\u{61c}'),
                    ('؟', '؟'),
                    ('ـ', 'ـ'),
                    ('\u{64b}', '\u{655}'),
                    ('\u{670}', '\u{670}'),
                    ('܀', '܍'),
                    ('\u{70f}', '\u{74a}'),
                    ('ݍ', 'ݏ'),
                    ('ࡠ', 'ࡪ'),
                    ('\u{1df8}', '\u{1df8}'),
                    ('\u{1dfa}', '\u{1dfa}'),
                ];

                pub const TAGALOG: &'static [(char, char)] =
                    &[('ᜀ', '\u{1715}'), ('ᜟ', 'ᜟ'), ('᜵', '᜶')];

                pub const TAGBANWA: &'static [(char, char)] =
                    &[('᜵', '᜶'), ('ᝠ', 'ᝬ'), ('ᝮ', 'ᝰ'), ('\u{1772}', '\u{1773}')];

                pub const TAI_LE: &'static [(char, char)] = &[
                    ('\u{300}', '\u{301}'),
                    ('\u{307}', '\u{308}'),
                    ('\u{30c}', '\u{30c}'),
                    ('၀', '၉'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                ];

                pub const TAI_THAM: &'static [(char, char)] = &[
                    ('ᨠ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '᪉'),
                    ('᪐', '᪙'),
                    ('᪠', '᪭'),
                ];

                pub const TAI_VIET: &'static [(char, char)] = &[('ꪀ', 'ꫂ'), ('ꫛ', '꫟')];

                pub const TAKRI: &'static [(char, char)] =
                    &[('।', '॥'), ('꠰', '꠹'), ('𑚀', '𑚹'), ('𑛀', '𑛉')];

                pub const TAMIL: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('\u{b82}', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('ௐ', 'ௐ'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('௦', '௺'),
                    ('\u{1cda}', '\u{1cda}'),
                    ('ꣳ', 'ꣳ'),
                    ('\u{11301}', '\u{11301}'),
                    ('𑌃', '𑌃'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('𑿀', '𑿱'),
                    ('𑿿', '𑿿'),
                ];

                pub const TANGSA: &'static [(char, char)] = &[('𖩰', '𖪾'), ('𖫀', '𖫉')];

                pub const TANGUT: &'static [(char, char)] = &[
                    ('⿰', '⿿'),
                    ('㇯', '㇯'),
                    ('𖿠', '𖿠'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘫿'),
                    ('𘴀', '𘴈'),
                ];

                pub const TELUGU: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('\u{c00}', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('\u{c3c}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', '\u{c63}'),
                    ('౦', '౯'),
                    ('౷', '౿'),
                    ('\u{1cda}', '\u{1cda}'),
                    ('ᳲ', 'ᳲ'),
                ];

                pub const THAANA: &'static [(char, char)] = &[
                    ('،', '،'),
                    ('؛', '\u{61c}'),
                    ('؟', '؟'),
                    ('٠', '٩'),
                    ('ހ', 'ޱ'),
                    ('ﷲ', 'ﷲ'),
                    ('﷽', '﷽'),
                ];

                pub const THAI: &'static [(char, char)] = &[
                    ('ʼ', 'ʼ'),
                    ('˗', '˗'),
                    ('\u{303}', '\u{303}'),
                    ('\u{331}', '\u{331}'),
                    ('ก', '\u{e3a}'),
                    ('เ', '๛'),
                ];

                pub const TIBETAN: &'static [(char, char)] = &[
                    ('ༀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('\u{f71}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('྾', '࿌'),
                    ('࿎', '࿔'),
                    ('࿙', '࿚'),
                    ('〈', '》'),
                ];

                pub const TIFINAGH: &'static [(char, char)] = &[
                    ('\u{302}', '\u{302}'),
                    ('\u{304}', '\u{304}'),
                    ('\u{307}', '\u{307}'),
                    ('\u{309}', '\u{309}'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', '⵰'),
                    ('\u{2d7f}', '\u{2d7f}'),
                ];

                pub const TIRHUTA: &'static [(char, char)] = &[
                    ('\u{951}', '\u{952}'),
                    ('।', '॥'),
                    ('ᳲ', 'ᳲ'),
                    ('꠰', '꠹'),
                    ('𑒀', '𑓇'),
                    ('𑓐', '𑓙'),
                ];

                pub const TODHRI: &'static [(char, char)] = &[
                    ('\u{301}', '\u{301}'),
                    ('\u{304}', '\u{304}'),
                    ('\u{307}', '\u{307}'),
                    ('\u{311}', '\u{311}'),
                    ('\u{313}', '\u{313}'),
                    ('\u{35e}', '\u{35e}'),
                    ('𐗀', '𐗳'),
                ];

                pub const TOTO: &'static [(char, char)] = &[('ʼ', 'ʼ'), ('𞊐', '\u{1e2ae}')];

                pub const TULU_TIGALARI: &'static [(char, char)] = &[
                    ('೦', '೯'),
                    ('ᳲ', 'ᳲ'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('꠰', '꠵'),
                    ('\u{a8f1}', '\u{a8f1}'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '𑏕'),
                    ('𑏗', '𑏘'),
                    ('\u{113e1}', '\u{113e2}'),
                ];

                pub const UGARITIC: &'static [(char, char)] = &[('𐎀', '𐎝'), ('𐎟', '𐎟')];

                pub const VAI: &'static [(char, char)] = &[('ꔀ', 'ꘫ')];

                pub const VITHKUQI: &'static [(char, char)] = &[
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                ];

                pub const WANCHO: &'static [(char, char)] = &[('𞋀', '𞋹'), ('𞋿', '𞋿')];

                pub const WARANG_CITI: &'static [(char, char)] = &[('𑢠', '𑣲'), ('𑣿', '𑣿')];

                pub const YEZIDI: &'static [(char, char)] = &[
                    ('،', '،'),
                    ('؛', '؛'),
                    ('؟', '؟'),
                    ('٠', '٩'),
                    ('𐺀', '𐺩'),
                    ('\u{10eab}', '𐺭'),
                    ('𐺰', '𐺱'),
                ];

                pub const YI: &'static [(char, char)] = &[
                    ('、', '。'),
                    ('〈', '】'),
                    ('〔', '〛'),
                    ('・', '・'),
                    ('ꀀ', 'ꒌ'),
                    ('꒐', '꓆'),
                    ('｡', '･'),
                ];

                pub const ZANABAZAR_SQUARE: &'static [(char, char)] = &[('𑨀', '\u{11a47}')];
            }

            pub mod sentence_break
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &[
                    ("ATerm", ATERM),
                    ("CR", CR),
                    ("Close", CLOSE),
                    ("Extend", EXTEND),
                    ("Format", FORMAT),
                    ("LF", LF),
                    ("Lower", LOWER),
                    ("Numeric", NUMERIC),
                    ("OLetter", OLETTER),
                    ("SContinue", SCONTINUE),
                    ("STerm", STERM),
                    ("Sep", SEP),
                    ("Sp", SP),
                    ("Upper", UPPER),
                ];

                pub const ATERM: &'static [(char, char)] =
                    &[('.', '.'), ('․', '․'), ('﹒', '﹒'), ('．', '．')];

                pub const CR: &'static [(char, char)] = &[('\r', '\r')];

                pub const CLOSE: &'static [(char, char)] = &[
                    ('"', '"'),
                    ('\'', ')'),
                    ('[', '['),
                    (']', ']'),
                    ('{', '{'),
                    ('}', '}'),
                    ('«', '«'),
                    ('»', '»'),
                    ('༺', '༽'),
                    ('᚛', '᚜'),
                    ('‘', '‟'),
                    ('‹', '›'),
                    ('⁅', '⁆'),
                    ('⁽', '⁾'),
                    ('₍', '₎'),
                    ('⌈', '⌋'),
                    ('〈', '〉'),
                    ('❛', '❠'),
                    ('❨', '❵'),
                    ('⟅', '⟆'),
                    ('⟦', '⟯'),
                    ('⦃', '⦘'),
                    ('⧘', '⧛'),
                    ('⧼', '⧽'),
                    ('⸀', '⸍'),
                    ('⸜', '⸝'),
                    ('⸠', '⸩'),
                    ('⹂', '⹂'),
                    ('⹕', '⹜'),
                    ('〈', '】'),
                    ('〔', '〛'),
                    ('〝', '〟'),
                    ('﴾', '﴿'),
                    ('︗', '︘'),
                    ('︵', '﹄'),
                    ('﹇', '﹈'),
                    ('﹙', '﹞'),
                    ('（', '）'),
                    ('［', '［'),
                    ('］', '］'),
                    ('｛', '｛'),
                    ('｝', '｝'),
                    ('｟', '｠'),
                    ('｢', '｣'),
                    ('🙶', '🙸'),
                ];

                pub const EXTEND: &'static [(char, char)] = &[
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{489}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', 'ः'),
                    ('\u{93a}', '\u{93c}'),
                    ('ा', 'ॏ'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', 'ঃ'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', 'ਃ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('\u{abc}', '\u{abc}'),
                    ('ા', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', 'ଃ'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3e}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', 'ಃ'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('ಾ', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('ೳ', 'ೳ'),
                    ('\u{d00}', 'ഃ'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d3e}', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', 'ඃ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', 'ෳ'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', '༿'),
                    ('\u{f71}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('ါ', '\u{103e}'),
                    ('ၖ', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('ၢ', 'ၤ'),
                    ('ၧ', 'ၭ'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{108d}'),
                    ('ႏ', 'ႏ'),
                    ('ႚ', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1715}'),
                    ('\u{1732}', '\u{1734}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('\u{1a17}', '\u{1a1b}'),
                    ('ᩕ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', 'ᬄ'),
                    ('\u{1b34}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', 'ᮂ'),
                    ('ᮡ', '\u{1bad}'),
                    ('\u{1be6}', '\u{1bf3}'),
                    ('ᰤ', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('᳷', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{200c}', '\u{200d}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('ꠣ', 'ꠧ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꢀ', 'ꢁ'),
                    ('ꢴ', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a953}'),
                    ('\u{a980}', 'ꦃ'),
                    ('\u{a9b3}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', 'ꩍ'),
                    ('ꩻ', 'ꩽ'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('ꫫ', 'ꫯ'),
                    ('ꫵ', '\u{aaf6}'),
                    ('ꯣ', 'ꯪ'),
                    ('꯬', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('𑀀', '𑀂'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '𑂂'),
                    ('𑂰', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{11134}'),
                    ('𑅅', '𑅆'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '𑆂'),
                    ('𑆳', '\u{111c0}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇎', '\u{111cf}'),
                    ('𑈬', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112ea}'),
                    ('\u{11300}', '𑌃'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1133e}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍢', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113b8}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑐵', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b0}', '\u{114c3}'),
                    ('\u{115af}', '\u{115b5}'),
                    ('𑖸', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('𑘰', '\u{11640}'),
                    ('\u{116ab}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑠬', '\u{1183a}'),
                    ('\u{11930}', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{1193e}'),
                    ('𑥀', '𑥀'),
                    ('𑥂', '\u{11943}'),
                    ('𑧑', '\u{119d7}'),
                    ('\u{119da}', '\u{119e0}'),
                    ('𑧤', '𑧤'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '𑨹'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a99}'),
                    ('𑰯', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('𑶊', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '\u{11d97}'),
                    ('\u{11ef3}', '𑻶'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('𑼃', '𑼃'),
                    ('𑼴', '\u{11f3a}'),
                    ('𑼾', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('𖽑', '𖾇'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('\u{e0020}', '\u{e007f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const FORMAT: &'static [(char, char)] = &[
                    ('\u{ad}', '\u{ad}'),
                    ('\u{61c}', '\u{61c}'),
                    ('\u{70f}', '\u{70f}'),
                    ('\u{180e}', '\u{180e}'),
                    ('\u{200b}', '\u{200b}'),
                    ('\u{200e}', '\u{200f}'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2060}', '\u{2064}'),
                    ('\u{2066}', '\u{206f}'),
                    ('\u{feff}', '\u{feff}'),
                    ('\u{fff9}', '\u{fffb}'),
                    ('\u{13430}', '\u{1343f}'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('\u{1d173}', '\u{1d17a}'),
                    ('\u{e0001}', '\u{e0001}'),
                ];

                pub const LF: &'static [(char, char)] = &[('\n', '\n')];

                pub const LOWER: &'static [(char, char)] = &[
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('ß', 'ö'),
                    ('ø', 'ÿ'),
                    ('ā', 'ā'),
                    ('ă', 'ă'),
                    ('ą', 'ą'),
                    ('ć', 'ć'),
                    ('ĉ', 'ĉ'),
                    ('ċ', 'ċ'),
                    ('č', 'č'),
                    ('ď', 'ď'),
                    ('đ', 'đ'),
                    ('ē', 'ē'),
                    ('ĕ', 'ĕ'),
                    ('ė', 'ė'),
                    ('ę', 'ę'),
                    ('ě', 'ě'),
                    ('ĝ', 'ĝ'),
                    ('ğ', 'ğ'),
                    ('ġ', 'ġ'),
                    ('ģ', 'ģ'),
                    ('ĥ', 'ĥ'),
                    ('ħ', 'ħ'),
                    ('ĩ', 'ĩ'),
                    ('ī', 'ī'),
                    ('ĭ', 'ĭ'),
                    ('į', 'į'),
                    ('ı', 'ı'),
                    ('ĳ', 'ĳ'),
                    ('ĵ', 'ĵ'),
                    ('ķ', 'ĸ'),
                    ('ĺ', 'ĺ'),
                    ('ļ', 'ļ'),
                    ('ľ', 'ľ'),
                    ('ŀ', 'ŀ'),
                    ('ł', 'ł'),
                    ('ń', 'ń'),
                    ('ņ', 'ņ'),
                    ('ň', 'ŉ'),
                    ('ŋ', 'ŋ'),
                    ('ō', 'ō'),
                    ('ŏ', 'ŏ'),
                    ('ő', 'ő'),
                    ('œ', 'œ'),
                    ('ŕ', 'ŕ'),
                    ('ŗ', 'ŗ'),
                    ('ř', 'ř'),
                    ('ś', 'ś'),
                    ('ŝ', 'ŝ'),
                    ('ş', 'ş'),
                    ('š', 'š'),
                    ('ţ', 'ţ'),
                    ('ť', 'ť'),
                    ('ŧ', 'ŧ'),
                    ('ũ', 'ũ'),
                    ('ū', 'ū'),
                    ('ŭ', 'ŭ'),
                    ('ů', 'ů'),
                    ('ű', 'ű'),
                    ('ų', 'ų'),
                    ('ŵ', 'ŵ'),
                    ('ŷ', 'ŷ'),
                    ('ź', 'ź'),
                    ('ż', 'ż'),
                    ('ž', 'ƀ'),
                    ('ƃ', 'ƃ'),
                    ('ƅ', 'ƅ'),
                    ('ƈ', 'ƈ'),
                    ('ƌ', 'ƍ'),
                    ('ƒ', 'ƒ'),
                    ('ƕ', 'ƕ'),
                    ('ƙ', 'ƛ'),
                    ('ƞ', 'ƞ'),
                    ('ơ', 'ơ'),
                    ('ƣ', 'ƣ'),
                    ('ƥ', 'ƥ'),
                    ('ƨ', 'ƨ'),
                    ('ƪ', 'ƫ'),
                    ('ƭ', 'ƭ'),
                    ('ư', 'ư'),
                    ('ƴ', 'ƴ'),
                    ('ƶ', 'ƶ'),
                    ('ƹ', 'ƺ'),
                    ('ƽ', 'ƿ'),
                    ('ǆ', 'ǆ'),
                    ('ǉ', 'ǉ'),
                    ('ǌ', 'ǌ'),
                    ('ǎ', 'ǎ'),
                    ('ǐ', 'ǐ'),
                    ('ǒ', 'ǒ'),
                    ('ǔ', 'ǔ'),
                    ('ǖ', 'ǖ'),
                    ('ǘ', 'ǘ'),
                    ('ǚ', 'ǚ'),
                    ('ǜ', 'ǝ'),
                    ('ǟ', 'ǟ'),
                    ('ǡ', 'ǡ'),
                    ('ǣ', 'ǣ'),
                    ('ǥ', 'ǥ'),
                    ('ǧ', 'ǧ'),
                    ('ǩ', 'ǩ'),
                    ('ǫ', 'ǫ'),
                    ('ǭ', 'ǭ'),
                    ('ǯ', 'ǰ'),
                    ('ǳ', 'ǳ'),
                    ('ǵ', 'ǵ'),
                    ('ǹ', 'ǹ'),
                    ('ǻ', 'ǻ'),
                    ('ǽ', 'ǽ'),
                    ('ǿ', 'ǿ'),
                    ('ȁ', 'ȁ'),
                    ('ȃ', 'ȃ'),
                    ('ȅ', 'ȅ'),
                    ('ȇ', 'ȇ'),
                    ('ȉ', 'ȉ'),
                    ('ȋ', 'ȋ'),
                    ('ȍ', 'ȍ'),
                    ('ȏ', 'ȏ'),
                    ('ȑ', 'ȑ'),
                    ('ȓ', 'ȓ'),
                    ('ȕ', 'ȕ'),
                    ('ȗ', 'ȗ'),
                    ('ș', 'ș'),
                    ('ț', 'ț'),
                    ('ȝ', 'ȝ'),
                    ('ȟ', 'ȟ'),
                    ('ȡ', 'ȡ'),
                    ('ȣ', 'ȣ'),
                    ('ȥ', 'ȥ'),
                    ('ȧ', 'ȧ'),
                    ('ȩ', 'ȩ'),
                    ('ȫ', 'ȫ'),
                    ('ȭ', 'ȭ'),
                    ('ȯ', 'ȯ'),
                    ('ȱ', 'ȱ'),
                    ('ȳ', 'ȹ'),
                    ('ȼ', 'ȼ'),
                    ('ȿ', 'ɀ'),
                    ('ɂ', 'ɂ'),
                    ('ɇ', 'ɇ'),
                    ('ɉ', 'ɉ'),
                    ('ɋ', 'ɋ'),
                    ('ɍ', 'ɍ'),
                    ('ɏ', 'ʓ'),
                    ('ʕ', 'ʸ'),
                    ('ˀ', 'ˁ'),
                    ('ˠ', 'ˤ'),
                    ('ͱ', 'ͱ'),
                    ('ͳ', 'ͳ'),
                    ('ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('ΐ', 'ΐ'),
                    ('ά', 'ώ'),
                    ('ϐ', 'ϑ'),
                    ('ϕ', 'ϗ'),
                    ('ϙ', 'ϙ'),
                    ('ϛ', 'ϛ'),
                    ('ϝ', 'ϝ'),
                    ('ϟ', 'ϟ'),
                    ('ϡ', 'ϡ'),
                    ('ϣ', 'ϣ'),
                    ('ϥ', 'ϥ'),
                    ('ϧ', 'ϧ'),
                    ('ϩ', 'ϩ'),
                    ('ϫ', 'ϫ'),
                    ('ϭ', 'ϭ'),
                    ('ϯ', 'ϳ'),
                    ('ϵ', 'ϵ'),
                    ('ϸ', 'ϸ'),
                    ('ϻ', 'ϼ'),
                    ('а', 'џ'),
                    ('ѡ', 'ѡ'),
                    ('ѣ', 'ѣ'),
                    ('ѥ', 'ѥ'),
                    ('ѧ', 'ѧ'),
                    ('ѩ', 'ѩ'),
                    ('ѫ', 'ѫ'),
                    ('ѭ', 'ѭ'),
                    ('ѯ', 'ѯ'),
                    ('ѱ', 'ѱ'),
                    ('ѳ', 'ѳ'),
                    ('ѵ', 'ѵ'),
                    ('ѷ', 'ѷ'),
                    ('ѹ', 'ѹ'),
                    ('ѻ', 'ѻ'),
                    ('ѽ', 'ѽ'),
                    ('ѿ', 'ѿ'),
                    ('ҁ', 'ҁ'),
                    ('ҋ', 'ҋ'),
                    ('ҍ', 'ҍ'),
                    ('ҏ', 'ҏ'),
                    ('ґ', 'ґ'),
                    ('ғ', 'ғ'),
                    ('ҕ', 'ҕ'),
                    ('җ', 'җ'),
                    ('ҙ', 'ҙ'),
                    ('қ', 'қ'),
                    ('ҝ', 'ҝ'),
                    ('ҟ', 'ҟ'),
                    ('ҡ', 'ҡ'),
                    ('ң', 'ң'),
                    ('ҥ', 'ҥ'),
                    ('ҧ', 'ҧ'),
                    ('ҩ', 'ҩ'),
                    ('ҫ', 'ҫ'),
                    ('ҭ', 'ҭ'),
                    ('ү', 'ү'),
                    ('ұ', 'ұ'),
                    ('ҳ', 'ҳ'),
                    ('ҵ', 'ҵ'),
                    ('ҷ', 'ҷ'),
                    ('ҹ', 'ҹ'),
                    ('һ', 'һ'),
                    ('ҽ', 'ҽ'),
                    ('ҿ', 'ҿ'),
                    ('ӂ', 'ӂ'),
                    ('ӄ', 'ӄ'),
                    ('ӆ', 'ӆ'),
                    ('ӈ', 'ӈ'),
                    ('ӊ', 'ӊ'),
                    ('ӌ', 'ӌ'),
                    ('ӎ', 'ӏ'),
                    ('ӑ', 'ӑ'),
                    ('ӓ', 'ӓ'),
                    ('ӕ', 'ӕ'),
                    ('ӗ', 'ӗ'),
                    ('ә', 'ә'),
                    ('ӛ', 'ӛ'),
                    ('ӝ', 'ӝ'),
                    ('ӟ', 'ӟ'),
                    ('ӡ', 'ӡ'),
                    ('ӣ', 'ӣ'),
                    ('ӥ', 'ӥ'),
                    ('ӧ', 'ӧ'),
                    ('ө', 'ө'),
                    ('ӫ', 'ӫ'),
                    ('ӭ', 'ӭ'),
                    ('ӯ', 'ӯ'),
                    ('ӱ', 'ӱ'),
                    ('ӳ', 'ӳ'),
                    ('ӵ', 'ӵ'),
                    ('ӷ', 'ӷ'),
                    ('ӹ', 'ӹ'),
                    ('ӻ', 'ӻ'),
                    ('ӽ', 'ӽ'),
                    ('ӿ', 'ӿ'),
                    ('ԁ', 'ԁ'),
                    ('ԃ', 'ԃ'),
                    ('ԅ', 'ԅ'),
                    ('ԇ', 'ԇ'),
                    ('ԉ', 'ԉ'),
                    ('ԋ', 'ԋ'),
                    ('ԍ', 'ԍ'),
                    ('ԏ', 'ԏ'),
                    ('ԑ', 'ԑ'),
                    ('ԓ', 'ԓ'),
                    ('ԕ', 'ԕ'),
                    ('ԗ', 'ԗ'),
                    ('ԙ', 'ԙ'),
                    ('ԛ', 'ԛ'),
                    ('ԝ', 'ԝ'),
                    ('ԟ', 'ԟ'),
                    ('ԡ', 'ԡ'),
                    ('ԣ', 'ԣ'),
                    ('ԥ', 'ԥ'),
                    ('ԧ', 'ԧ'),
                    ('ԩ', 'ԩ'),
                    ('ԫ', 'ԫ'),
                    ('ԭ', 'ԭ'),
                    ('ԯ', 'ԯ'),
                    ('ՠ', 'ֈ'),
                    ('ჼ', 'ჼ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᲀ', 'ᲈ'),
                    ('ᲊ', 'ᲊ'),
                    ('ᴀ', 'ᶿ'),
                    ('ḁ', 'ḁ'),
                    ('ḃ', 'ḃ'),
                    ('ḅ', 'ḅ'),
                    ('ḇ', 'ḇ'),
                    ('ḉ', 'ḉ'),
                    ('ḋ', 'ḋ'),
                    ('ḍ', 'ḍ'),
                    ('ḏ', 'ḏ'),
                    ('ḑ', 'ḑ'),
                    ('ḓ', 'ḓ'),
                    ('ḕ', 'ḕ'),
                    ('ḗ', 'ḗ'),
                    ('ḙ', 'ḙ'),
                    ('ḛ', 'ḛ'),
                    ('ḝ', 'ḝ'),
                    ('ḟ', 'ḟ'),
                    ('ḡ', 'ḡ'),
                    ('ḣ', 'ḣ'),
                    ('ḥ', 'ḥ'),
                    ('ḧ', 'ḧ'),
                    ('ḩ', 'ḩ'),
                    ('ḫ', 'ḫ'),
                    ('ḭ', 'ḭ'),
                    ('ḯ', 'ḯ'),
                    ('ḱ', 'ḱ'),
                    ('ḳ', 'ḳ'),
                    ('ḵ', 'ḵ'),
                    ('ḷ', 'ḷ'),
                    ('ḹ', 'ḹ'),
                    ('ḻ', 'ḻ'),
                    ('ḽ', 'ḽ'),
                    ('ḿ', 'ḿ'),
                    ('ṁ', 'ṁ'),
                    ('ṃ', 'ṃ'),
                    ('ṅ', 'ṅ'),
                    ('ṇ', 'ṇ'),
                    ('ṉ', 'ṉ'),
                    ('ṋ', 'ṋ'),
                    ('ṍ', 'ṍ'),
                    ('ṏ', 'ṏ'),
                    ('ṑ', 'ṑ'),
                    ('ṓ', 'ṓ'),
                    ('ṕ', 'ṕ'),
                    ('ṗ', 'ṗ'),
                    ('ṙ', 'ṙ'),
                    ('ṛ', 'ṛ'),
                    ('ṝ', 'ṝ'),
                    ('ṟ', 'ṟ'),
                    ('ṡ', 'ṡ'),
                    ('ṣ', 'ṣ'),
                    ('ṥ', 'ṥ'),
                    ('ṧ', 'ṧ'),
                    ('ṩ', 'ṩ'),
                    ('ṫ', 'ṫ'),
                    ('ṭ', 'ṭ'),
                    ('ṯ', 'ṯ'),
                    ('ṱ', 'ṱ'),
                    ('ṳ', 'ṳ'),
                    ('ṵ', 'ṵ'),
                    ('ṷ', 'ṷ'),
                    ('ṹ', 'ṹ'),
                    ('ṻ', 'ṻ'),
                    ('ṽ', 'ṽ'),
                    ('ṿ', 'ṿ'),
                    ('ẁ', 'ẁ'),
                    ('ẃ', 'ẃ'),
                    ('ẅ', 'ẅ'),
                    ('ẇ', 'ẇ'),
                    ('ẉ', 'ẉ'),
                    ('ẋ', 'ẋ'),
                    ('ẍ', 'ẍ'),
                    ('ẏ', 'ẏ'),
                    ('ẑ', 'ẑ'),
                    ('ẓ', 'ẓ'),
                    ('ẕ', 'ẝ'),
                    ('ẟ', 'ẟ'),
                    ('ạ', 'ạ'),
                    ('ả', 'ả'),
                    ('ấ', 'ấ'),
                    ('ầ', 'ầ'),
                    ('ẩ', 'ẩ'),
                    ('ẫ', 'ẫ'),
                    ('ậ', 'ậ'),
                    ('ắ', 'ắ'),
                    ('ằ', 'ằ'),
                    ('ẳ', 'ẳ'),
                    ('ẵ', 'ẵ'),
                    ('ặ', 'ặ'),
                    ('ẹ', 'ẹ'),
                    ('ẻ', 'ẻ'),
                    ('ẽ', 'ẽ'),
                    ('ế', 'ế'),
                    ('ề', 'ề'),
                    ('ể', 'ể'),
                    ('ễ', 'ễ'),
                    ('ệ', 'ệ'),
                    ('ỉ', 'ỉ'),
                    ('ị', 'ị'),
                    ('ọ', 'ọ'),
                    ('ỏ', 'ỏ'),
                    ('ố', 'ố'),
                    ('ồ', 'ồ'),
                    ('ổ', 'ổ'),
                    ('ỗ', 'ỗ'),
                    ('ộ', 'ộ'),
                    ('ớ', 'ớ'),
                    ('ờ', 'ờ'),
                    ('ở', 'ở'),
                    ('ỡ', 'ỡ'),
                    ('ợ', 'ợ'),
                    ('ụ', 'ụ'),
                    ('ủ', 'ủ'),
                    ('ứ', 'ứ'),
                    ('ừ', 'ừ'),
                    ('ử', 'ử'),
                    ('ữ', 'ữ'),
                    ('ự', 'ự'),
                    ('ỳ', 'ỳ'),
                    ('ỵ', 'ỵ'),
                    ('ỷ', 'ỷ'),
                    ('ỹ', 'ỹ'),
                    ('ỻ', 'ỻ'),
                    ('ỽ', 'ỽ'),
                    ('ỿ', 'ἇ'),
                    ('ἐ', 'ἕ'),
                    ('ἠ', 'ἧ'),
                    ('ἰ', 'ἷ'),
                    ('ὀ', 'ὅ'),
                    ('ὐ', 'ὗ'),
                    ('ὠ', 'ὧ'),
                    ('ὰ', 'ώ'),
                    ('ᾀ', 'ᾇ'),
                    ('ᾐ', 'ᾗ'),
                    ('ᾠ', 'ᾧ'),
                    ('ᾰ', 'ᾴ'),
                    ('ᾶ', 'ᾷ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῇ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'ῗ'),
                    ('ῠ', 'ῧ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῷ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℊ', 'ℊ'),
                    ('ℎ', 'ℏ'),
                    ('ℓ', 'ℓ'),
                    ('ℯ', 'ℯ'),
                    ('ℴ', 'ℴ'),
                    ('ℹ', 'ℹ'),
                    ('ℼ', 'ℽ'),
                    ('ⅆ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('ⅰ', 'ⅿ'),
                    ('ↄ', 'ↄ'),
                    ('ⓐ', 'ⓩ'),
                    ('ⰰ', 'ⱟ'),
                    ('ⱡ', 'ⱡ'),
                    ('ⱥ', 'ⱦ'),
                    ('ⱨ', 'ⱨ'),
                    ('ⱪ', 'ⱪ'),
                    ('ⱬ', 'ⱬ'),
                    ('ⱱ', 'ⱱ'),
                    ('ⱳ', 'ⱴ'),
                    ('ⱶ', 'ⱽ'),
                    ('ⲁ', 'ⲁ'),
                    ('ⲃ', 'ⲃ'),
                    ('ⲅ', 'ⲅ'),
                    ('ⲇ', 'ⲇ'),
                    ('ⲉ', 'ⲉ'),
                    ('ⲋ', 'ⲋ'),
                    ('ⲍ', 'ⲍ'),
                    ('ⲏ', 'ⲏ'),
                    ('ⲑ', 'ⲑ'),
                    ('ⲓ', 'ⲓ'),
                    ('ⲕ', 'ⲕ'),
                    ('ⲗ', 'ⲗ'),
                    ('ⲙ', 'ⲙ'),
                    ('ⲛ', 'ⲛ'),
                    ('ⲝ', 'ⲝ'),
                    ('ⲟ', 'ⲟ'),
                    ('ⲡ', 'ⲡ'),
                    ('ⲣ', 'ⲣ'),
                    ('ⲥ', 'ⲥ'),
                    ('ⲧ', 'ⲧ'),
                    ('ⲩ', 'ⲩ'),
                    ('ⲫ', 'ⲫ'),
                    ('ⲭ', 'ⲭ'),
                    ('ⲯ', 'ⲯ'),
                    ('ⲱ', 'ⲱ'),
                    ('ⲳ', 'ⲳ'),
                    ('ⲵ', 'ⲵ'),
                    ('ⲷ', 'ⲷ'),
                    ('ⲹ', 'ⲹ'),
                    ('ⲻ', 'ⲻ'),
                    ('ⲽ', 'ⲽ'),
                    ('ⲿ', 'ⲿ'),
                    ('ⳁ', 'ⳁ'),
                    ('ⳃ', 'ⳃ'),
                    ('ⳅ', 'ⳅ'),
                    ('ⳇ', 'ⳇ'),
                    ('ⳉ', 'ⳉ'),
                    ('ⳋ', 'ⳋ'),
                    ('ⳍ', 'ⳍ'),
                    ('ⳏ', 'ⳏ'),
                    ('ⳑ', 'ⳑ'),
                    ('ⳓ', 'ⳓ'),
                    ('ⳕ', 'ⳕ'),
                    ('ⳗ', 'ⳗ'),
                    ('ⳙ', 'ⳙ'),
                    ('ⳛ', 'ⳛ'),
                    ('ⳝ', 'ⳝ'),
                    ('ⳟ', 'ⳟ'),
                    ('ⳡ', 'ⳡ'),
                    ('ⳣ', 'ⳤ'),
                    ('ⳬ', 'ⳬ'),
                    ('ⳮ', 'ⳮ'),
                    ('ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ꙁ', 'ꙁ'),
                    ('ꙃ', 'ꙃ'),
                    ('ꙅ', 'ꙅ'),
                    ('ꙇ', 'ꙇ'),
                    ('ꙉ', 'ꙉ'),
                    ('ꙋ', 'ꙋ'),
                    ('ꙍ', 'ꙍ'),
                    ('ꙏ', 'ꙏ'),
                    ('ꙑ', 'ꙑ'),
                    ('ꙓ', 'ꙓ'),
                    ('ꙕ', 'ꙕ'),
                    ('ꙗ', 'ꙗ'),
                    ('ꙙ', 'ꙙ'),
                    ('ꙛ', 'ꙛ'),
                    ('ꙝ', 'ꙝ'),
                    ('ꙟ', 'ꙟ'),
                    ('ꙡ', 'ꙡ'),
                    ('ꙣ', 'ꙣ'),
                    ('ꙥ', 'ꙥ'),
                    ('ꙧ', 'ꙧ'),
                    ('ꙩ', 'ꙩ'),
                    ('ꙫ', 'ꙫ'),
                    ('ꙭ', 'ꙭ'),
                    ('ꚁ', 'ꚁ'),
                    ('ꚃ', 'ꚃ'),
                    ('ꚅ', 'ꚅ'),
                    ('ꚇ', 'ꚇ'),
                    ('ꚉ', 'ꚉ'),
                    ('ꚋ', 'ꚋ'),
                    ('ꚍ', 'ꚍ'),
                    ('ꚏ', 'ꚏ'),
                    ('ꚑ', 'ꚑ'),
                    ('ꚓ', 'ꚓ'),
                    ('ꚕ', 'ꚕ'),
                    ('ꚗ', 'ꚗ'),
                    ('ꚙ', 'ꚙ'),
                    ('ꚛ', 'ꚝ'),
                    ('ꜣ', 'ꜣ'),
                    ('ꜥ', 'ꜥ'),
                    ('ꜧ', 'ꜧ'),
                    ('ꜩ', 'ꜩ'),
                    ('ꜫ', 'ꜫ'),
                    ('ꜭ', 'ꜭ'),
                    ('ꜯ', 'ꜱ'),
                    ('ꜳ', 'ꜳ'),
                    ('ꜵ', 'ꜵ'),
                    ('ꜷ', 'ꜷ'),
                    ('ꜹ', 'ꜹ'),
                    ('ꜻ', 'ꜻ'),
                    ('ꜽ', 'ꜽ'),
                    ('ꜿ', 'ꜿ'),
                    ('ꝁ', 'ꝁ'),
                    ('ꝃ', 'ꝃ'),
                    ('ꝅ', 'ꝅ'),
                    ('ꝇ', 'ꝇ'),
                    ('ꝉ', 'ꝉ'),
                    ('ꝋ', 'ꝋ'),
                    ('ꝍ', 'ꝍ'),
                    ('ꝏ', 'ꝏ'),
                    ('ꝑ', 'ꝑ'),
                    ('ꝓ', 'ꝓ'),
                    ('ꝕ', 'ꝕ'),
                    ('ꝗ', 'ꝗ'),
                    ('ꝙ', 'ꝙ'),
                    ('ꝛ', 'ꝛ'),
                    ('ꝝ', 'ꝝ'),
                    ('ꝟ', 'ꝟ'),
                    ('ꝡ', 'ꝡ'),
                    ('ꝣ', 'ꝣ'),
                    ('ꝥ', 'ꝥ'),
                    ('ꝧ', 'ꝧ'),
                    ('ꝩ', 'ꝩ'),
                    ('ꝫ', 'ꝫ'),
                    ('ꝭ', 'ꝭ'),
                    ('ꝯ', 'ꝸ'),
                    ('ꝺ', 'ꝺ'),
                    ('ꝼ', 'ꝼ'),
                    ('ꝿ', 'ꝿ'),
                    ('ꞁ', 'ꞁ'),
                    ('ꞃ', 'ꞃ'),
                    ('ꞅ', 'ꞅ'),
                    ('ꞇ', 'ꞇ'),
                    ('ꞌ', 'ꞌ'),
                    ('ꞎ', 'ꞎ'),
                    ('ꞑ', 'ꞑ'),
                    ('ꞓ', 'ꞕ'),
                    ('ꞗ', 'ꞗ'),
                    ('ꞙ', 'ꞙ'),
                    ('ꞛ', 'ꞛ'),
                    ('ꞝ', 'ꞝ'),
                    ('ꞟ', 'ꞟ'),
                    ('ꞡ', 'ꞡ'),
                    ('ꞣ', 'ꞣ'),
                    ('ꞥ', 'ꞥ'),
                    ('ꞧ', 'ꞧ'),
                    ('ꞩ', 'ꞩ'),
                    ('ꞯ', 'ꞯ'),
                    ('ꞵ', 'ꞵ'),
                    ('ꞷ', 'ꞷ'),
                    ('ꞹ', 'ꞹ'),
                    ('ꞻ', 'ꞻ'),
                    ('ꞽ', 'ꞽ'),
                    ('ꞿ', 'ꞿ'),
                    ('ꟁ', 'ꟁ'),
                    ('ꟃ', 'ꟃ'),
                    ('ꟈ', 'ꟈ'),
                    ('ꟊ', 'ꟊ'),
                    ('ꟍ', 'ꟍ'),
                    ('ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'ꟕ'),
                    ('ꟗ', 'ꟗ'),
                    ('ꟙ', 'ꟙ'),
                    ('ꟛ', 'ꟛ'),
                    ('ꟲ', 'ꟴ'),
                    ('ꟶ', 'ꟶ'),
                    ('ꟸ', 'ꟺ'),
                    ('ꬰ', 'ꭚ'),
                    ('ꭜ', 'ꭩ'),
                    ('ꭰ', 'ꮿ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('ａ', 'ｚ'),
                    ('𐐨', '𐑏'),
                    ('𐓘', '𐓻'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐞀', '𐞀'),
                    ('𐞃', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐳀', '𐳲'),
                    ('𐵰', '𐶅'),
                    ('𑣀', '𑣟'),
                    ('𖹠', '𖹿'),
                    ('𝐚', '𝐳'),
                    ('𝑎', '𝑔'),
                    ('𝑖', '𝑧'),
                    ('𝒂', '𝒛'),
                    ('𝒶', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝓏'),
                    ('𝓪', '𝔃'),
                    ('𝔞', '𝔷'),
                    ('𝕒', '𝕫'),
                    ('𝖆', '𝖟'),
                    ('𝖺', '𝗓'),
                    ('𝗮', '𝘇'),
                    ('𝘢', '𝘻'),
                    ('𝙖', '𝙯'),
                    ('𝚊', '𝚥'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛡'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜛'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝕'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞏'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟉'),
                    ('𝟋', '𝟋'),
                    ('𝼀', '𝼉'),
                    ('𝼋', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞤢', '𞥃'),
                ];

                pub const NUMERIC: &'static [(char, char)] = &[
                    ('0', '9'),
                    ('\u{600}', '\u{605}'),
                    ('٠', '٩'),
                    ('٫', '٬'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('۰', '۹'),
                    ('߀', '߉'),
                    ('\u{890}', '\u{891}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('०', '९'),
                    ('০', '৯'),
                    ('੦', '੯'),
                    ('૦', '૯'),
                    ('୦', '୯'),
                    ('௦', '௯'),
                    ('౦', '౯'),
                    ('೦', '೯'),
                    ('൦', '൯'),
                    ('෦', '෯'),
                    ('๐', '๙'),
                    ('໐', '໙'),
                    ('༠', '༩'),
                    ('၀', '၉'),
                    ('႐', '႙'),
                    ('០', '៩'),
                    ('᠐', '᠙'),
                    ('᥆', '᥏'),
                    ('᧐', '᧚'),
                    ('᪀', '᪉'),
                    ('᪐', '᪙'),
                    ('᭐', '᭙'),
                    ('᮰', '᮹'),
                    ('᱀', '᱉'),
                    ('᱐', '᱙'),
                    ('꘠', '꘩'),
                    ('꣐', '꣙'),
                    ('꤀', '꤉'),
                    ('꧐', '꧙'),
                    ('꧰', '꧹'),
                    ('꩐', '꩙'),
                    ('꯰', '꯹'),
                    ('０', '９'),
                    ('𐒠', '𐒩'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵉'),
                    ('𑁦', '𑁯'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110cd}', '\u{110cd}'),
                    ('𑃰', '𑃹'),
                    ('𑄶', '𑄿'),
                    ('𑇐', '𑇙'),
                    ('𑋰', '𑋹'),
                    ('𑑐', '𑑙'),
                    ('𑓐', '𑓙'),
                    ('𑙐', '𑙙'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜰', '𑜹'),
                    ('𑣠', '𑣩'),
                    ('𑥐', '𑥙'),
                    ('𑯰', '𑯹'),
                    ('𑱐', '𑱙'),
                    ('𑵐', '𑵙'),
                    ('𑶠', '𑶩'),
                    ('𑽐', '𑽙'),
                    ('𖄰', '𖄹'),
                    ('𖩠', '𖩩'),
                    ('𖫀', '𖫉'),
                    ('𖭐', '𖭙'),
                    ('𖵰', '𖵹'),
                    ('𜳰', '𜳹'),
                    ('𝟎', '𝟿'),
                    ('𞅀', '𞅉'),
                    ('𞋰', '𞋹'),
                    ('𞓰', '𞓹'),
                    ('𞗱', '𞗺'),
                    ('𞥐', '𞥙'),
                    ('🯰', '🯹'),
                ];

                pub const OLETTER: &'static [(char, char)] = &[
                    ('ƻ', 'ƻ'),
                    ('ǀ', 'ǃ'),
                    ('ʔ', 'ʔ'),
                    ('ʹ', 'ʿ'),
                    ('ˆ', 'ˑ'),
                    ('ˬ', 'ˬ'),
                    ('ˮ', 'ˮ'),
                    ('ʹ', 'ʹ'),
                    ('ՙ', 'ՙ'),
                    ('א', 'ת'),
                    ('ׯ', '׳'),
                    ('ؠ', 'ي'),
                    ('ٮ', 'ٯ'),
                    ('ٱ', 'ۓ'),
                    ('ە', 'ە'),
                    ('ۥ', 'ۦ'),
                    ('ۮ', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('ܐ', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠀ', 'ࠕ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('ࢠ', 'ࣉ'),
                    ('ऄ', 'ह'),
                    ('ऽ', 'ऽ'),
                    ('ॐ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('ॱ', 'ঀ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('ੲ', 'ੴ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ઽ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('ૹ', 'ૹ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('ୱ', 'ୱ'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ௐ', 'ௐ'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('ಀ', 'ಀ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಽ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('ೱ', 'ೲ'),
                    ('ഄ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', 'ൖ'),
                    ('ൟ', 'ൡ'),
                    ('ൺ', 'ൿ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ก', 'ะ'),
                    ('า', 'ำ'),
                    ('เ', 'ๆ'),
                    ('ກ', 'ຂ'),
                    ('ຄ', 'ຄ'),
                    ('ຆ', 'ຊ'),
                    ('ຌ', 'ຣ'),
                    ('ລ', 'ລ'),
                    ('ວ', 'ະ'),
                    ('າ', 'ຳ'),
                    ('ຽ', 'ຽ'),
                    ('ເ', 'ໄ'),
                    ('ໆ', 'ໆ'),
                    ('ໜ', 'ໟ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ྈ', 'ྌ'),
                    ('က', 'ဪ'),
                    ('ဿ', 'ဿ'),
                    ('ၐ', 'ၕ'),
                    ('ၚ', 'ၝ'),
                    ('ၡ', 'ၡ'),
                    ('ၥ', 'ၦ'),
                    ('ၮ', 'ၰ'),
                    ('ၵ', 'ႁ'),
                    ('ႎ', 'ႎ'),
                    ('ა', 'ჺ'),
                    ('ჽ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ក', 'ឳ'),
                    ('ៗ', 'ៗ'),
                    ('ៜ', 'ៜ'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢄ'),
                    ('ᢇ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᥐ', 'ᥭ'),
                    ('ᥰ', 'ᥴ'),
                    ('ᦀ', 'ᦫ'),
                    ('ᦰ', 'ᧉ'),
                    ('ᨀ', 'ᨖ'),
                    ('ᨠ', 'ᩔ'),
                    ('ᪧ', 'ᪧ'),
                    ('ᬅ', 'ᬳ'),
                    ('ᭅ', 'ᭌ'),
                    ('ᮃ', 'ᮠ'),
                    ('ᮮ', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᰀ', 'ᰣ'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱽ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ℵ', 'ℸ'),
                    ('ↀ', 'ↂ'),
                    ('ↅ', 'ↈ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '〇'),
                    ('〡', '〩'),
                    ('〱', '〵'),
                    ('〸', '〼'),
                    ('ぁ', 'ゖ'),
                    ('ゝ', 'ゟ'),
                    ('ァ', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㐀', '䶿'),
                    ('一', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('ꙮ', 'ꙮ'),
                    ('ꙿ', 'ꙿ'),
                    ('ꚠ', 'ꛯ'),
                    ('ꜗ', 'ꜟ'),
                    ('ꞈ', 'ꞈ'),
                    ('ꞏ', 'ꞏ'),
                    ('ꟷ', 'ꟷ'),
                    ('ꟻ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠢ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢂ', 'ꢳ'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', 'ꣾ'),
                    ('ꤊ', 'ꤥ'),
                    ('ꤰ', 'ꥆ'),
                    ('ꥠ', 'ꥼ'),
                    ('ꦄ', 'ꦲ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꧠ', 'ꧤ'),
                    ('ꧦ', 'ꧯ'),
                    ('ꧺ', 'ꧾ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꩠ', 'ꩶ'),
                    ('ꩺ', 'ꩺ'),
                    ('ꩾ', 'ꪯ'),
                    ('ꪱ', 'ꪱ'),
                    ('ꪵ', 'ꪶ'),
                    ('ꪹ', 'ꪽ'),
                    ('ꫀ', 'ꫀ'),
                    ('ꫂ', 'ꫂ'),
                    ('ꫛ', 'ꫝ'),
                    ('ꫠ', 'ꫪ'),
                    ('ꫲ', 'ꫴ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꯀ', 'ꯢ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('豈', '舘'),
                    ('並', '龎'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('ｦ', 'ﾝ'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐑐', '𐒝'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞁', '𐞂'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐴀', '𐴣'),
                    ('𐵊', '𐵏'),
                    ('𐵯', '𐵯'),
                    ('𐺀', '𐺩'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀃', '𑀷'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂃', '𑂯'),
                    ('𑃐', '𑃨'),
                    ('𑄃', '𑄦'),
                    ('𑅄', '𑅄'),
                    ('𑅇', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('𑆃', '𑆲'),
                    ('𑇁', '𑇄'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈫'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '𑋞'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍡'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑐴'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '𑖮'),
                    ('𑗘', '𑗛'),
                    ('𑘀', '𑘯'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '𑚪'),
                    ('𑚸', '𑚸'),
                    ('𑜀', '𑜚'),
                    ('𑝀', '𑝆'),
                    ('𑠀', '𑠫'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧐'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧣'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨺', '𑨺'),
                    ('𑩐', '𑩐'),
                    ('𑩜', '𑪉'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰮'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶉'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻲'),
                    ('𑼂', '𑼂'),
                    ('𑼄', '𑼐'),
                    ('𑼒', '𑼳'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭀', '𖭃'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖽐'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𗀀', '𘟷'),
                    ('𘠀', '𘳕'),
                    ('𘳿', '𘴈'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛄢'),
                    ('𛄲', '𛄲'),
                    ('𛅐', '𛅒'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                    ('𛅰', '𛋻'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𝼊', '𝼊'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓫'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞥋', '𞥋'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('𠀀', '𪛟'),
                    ('𪜀', '𫜹'),
                    ('𫝀', '𫠝'),
                    ('𫠠', '𬺡'),
                    ('𬺰', '𮯠'),
                    ('𮯰', '𮹝'),
                    ('丽', '𪘀'),
                    ('𰀀', '𱍊'),
                    ('𱍐', '𲎯'),
                ];

                pub const SCONTINUE: &'static [(char, char)] = &[
                    (',', '-'),
                    (':', ';'),
                    (';', ';'),
                    ('՝', '՝'),
                    ('،', '؍'),
                    ('߸', '߸'),
                    ('᠂', '᠂'),
                    ('᠈', '᠈'),
                    ('–', '—'),
                    ('、', '、'),
                    ('︐', '︑'),
                    ('︓', '︔'),
                    ('︱', '︲'),
                    ('﹐', '﹑'),
                    ('﹔', '﹕'),
                    ('﹘', '﹘'),
                    ('﹣', '﹣'),
                    ('，', '－'),
                    ('：', '；'),
                    ('､', '､'),
                ];

                pub const STERM: &'static [(char, char)] = &[
                    ('!', '!'),
                    ('?', '?'),
                    ('։', '։'),
                    ('؝', '؟'),
                    ('۔', '۔'),
                    ('܀', '܂'),
                    ('߹', '߹'),
                    ('࠷', '࠷'),
                    ('࠹', '࠹'),
                    ('࠽', '࠾'),
                    ('।', '॥'),
                    ('၊', '။'),
                    ('።', '።'),
                    ('፧', '፨'),
                    ('᙮', '᙮'),
                    ('᜵', '᜶'),
                    ('។', '៕'),
                    ('᠃', '᠃'),
                    ('᠉', '᠉'),
                    ('᥄', '᥅'),
                    ('᪨', '᪫'),
                    ('᭎', '᭏'),
                    ('᭚', '᭛'),
                    ('᭞', '᭟'),
                    ('᭽', '᭿'),
                    ('᰻', '᰼'),
                    ('᱾', '᱿'),
                    ('‼', '‽'),
                    ('⁇', '⁉'),
                    ('⳹', '⳻'),
                    ('⸮', '⸮'),
                    ('⸼', '⸼'),
                    ('⹓', '⹔'),
                    ('。', '。'),
                    ('꓿', '꓿'),
                    ('꘎', '꘏'),
                    ('꛳', '꛳'),
                    ('꛷', '꛷'),
                    ('꡶', '꡷'),
                    ('꣎', '꣏'),
                    ('꤯', '꤯'),
                    ('꧈', '꧉'),
                    ('꩝', '꩟'),
                    ('꫰', '꫱'),
                    ('꯫', '꯫'),
                    ('︒', '︒'),
                    ('︕', '︖'),
                    ('﹖', '﹗'),
                    ('！', '！'),
                    ('？', '？'),
                    ('｡', '｡'),
                    ('𐩖', '𐩗'),
                    ('𐽕', '𐽙'),
                    ('𐾆', '𐾉'),
                    ('𑁇', '𑁈'),
                    ('𑂾', '𑃁'),
                    ('𑅁', '𑅃'),
                    ('𑇅', '𑇆'),
                    ('𑇍', '𑇍'),
                    ('𑇞', '𑇟'),
                    ('𑈸', '𑈹'),
                    ('𑈻', '𑈼'),
                    ('𑊩', '𑊩'),
                    ('𑏔', '𑏕'),
                    ('𑑋', '𑑌'),
                    ('𑗂', '𑗃'),
                    ('𑗉', '𑗗'),
                    ('𑙁', '𑙂'),
                    ('𑜼', '𑜾'),
                    ('𑥄', '𑥄'),
                    ('𑥆', '𑥆'),
                    ('𑩂', '𑩃'),
                    ('𑪛', '𑪜'),
                    ('𑱁', '𑱂'),
                    ('𑻷', '𑻸'),
                    ('𑽃', '𑽄'),
                    ('𖩮', '𖩯'),
                    ('𖫵', '𖫵'),
                    ('𖬷', '𖬸'),
                    ('𖭄', '𖭄'),
                    ('𖵮', '𖵯'),
                    ('𖺘', '𖺘'),
                    ('𛲟', '𛲟'),
                    ('𝪈', '𝪈'),
                ];

                pub const SEP: &'static [(char, char)] =
                    &[('\u{85}', '\u{85}'), ('\u{2028}', '\u{2029}')];

                pub const SP: &'static [(char, char)] = &[
                    ('\t', '\t'),
                    ('\u{b}', '\u{c}'),
                    (' ', ' '),
                    ('\u{a0}', '\u{a0}'),
                    ('\u{1680}', '\u{1680}'),
                    ('\u{2000}', '\u{200a}'),
                    ('\u{202f}', '\u{202f}'),
                    ('\u{205f}', '\u{205f}'),
                    ('\u{3000}', '\u{3000}'),
                ];

                pub const UPPER: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('À', 'Ö'),
                    ('Ø', 'Þ'),
                    ('Ā', 'Ā'),
                    ('Ă', 'Ă'),
                    ('Ą', 'Ą'),
                    ('Ć', 'Ć'),
                    ('Ĉ', 'Ĉ'),
                    ('Ċ', 'Ċ'),
                    ('Č', 'Č'),
                    ('Ď', 'Ď'),
                    ('Đ', 'Đ'),
                    ('Ē', 'Ē'),
                    ('Ĕ', 'Ĕ'),
                    ('Ė', 'Ė'),
                    ('Ę', 'Ę'),
                    ('Ě', 'Ě'),
                    ('Ĝ', 'Ĝ'),
                    ('Ğ', 'Ğ'),
                    ('Ġ', 'Ġ'),
                    ('Ģ', 'Ģ'),
                    ('Ĥ', 'Ĥ'),
                    ('Ħ', 'Ħ'),
                    ('Ĩ', 'Ĩ'),
                    ('Ī', 'Ī'),
                    ('Ĭ', 'Ĭ'),
                    ('Į', 'Į'),
                    ('İ', 'İ'),
                    ('Ĳ', 'Ĳ'),
                    ('Ĵ', 'Ĵ'),
                    ('Ķ', 'Ķ'),
                    ('Ĺ', 'Ĺ'),
                    ('Ļ', 'Ļ'),
                    ('Ľ', 'Ľ'),
                    ('Ŀ', 'Ŀ'),
                    ('Ł', 'Ł'),
                    ('Ń', 'Ń'),
                    ('Ņ', 'Ņ'),
                    ('Ň', 'Ň'),
                    ('Ŋ', 'Ŋ'),
                    ('Ō', 'Ō'),
                    ('Ŏ', 'Ŏ'),
                    ('Ő', 'Ő'),
                    ('Œ', 'Œ'),
                    ('Ŕ', 'Ŕ'),
                    ('Ŗ', 'Ŗ'),
                    ('Ř', 'Ř'),
                    ('Ś', 'Ś'),
                    ('Ŝ', 'Ŝ'),
                    ('Ş', 'Ş'),
                    ('Š', 'Š'),
                    ('Ţ', 'Ţ'),
                    ('Ť', 'Ť'),
                    ('Ŧ', 'Ŧ'),
                    ('Ũ', 'Ũ'),
                    ('Ū', 'Ū'),
                    ('Ŭ', 'Ŭ'),
                    ('Ů', 'Ů'),
                    ('Ű', 'Ű'),
                    ('Ų', 'Ų'),
                    ('Ŵ', 'Ŵ'),
                    ('Ŷ', 'Ŷ'),
                    ('Ÿ', 'Ź'),
                    ('Ż', 'Ż'),
                    ('Ž', 'Ž'),
                    ('Ɓ', 'Ƃ'),
                    ('Ƅ', 'Ƅ'),
                    ('Ɔ', 'Ƈ'),
                    ('Ɖ', 'Ƌ'),
                    ('Ǝ', 'Ƒ'),
                    ('Ɠ', 'Ɣ'),
                    ('Ɩ', 'Ƙ'),
                    ('Ɯ', 'Ɲ'),
                    ('Ɵ', 'Ơ'),
                    ('Ƣ', 'Ƣ'),
                    ('Ƥ', 'Ƥ'),
                    ('Ʀ', 'Ƨ'),
                    ('Ʃ', 'Ʃ'),
                    ('Ƭ', 'Ƭ'),
                    ('Ʈ', 'Ư'),
                    ('Ʊ', 'Ƴ'),
                    ('Ƶ', 'Ƶ'),
                    ('Ʒ', 'Ƹ'),
                    ('Ƽ', 'Ƽ'),
                    ('Ǆ', 'ǅ'),
                    ('Ǉ', 'ǈ'),
                    ('Ǌ', 'ǋ'),
                    ('Ǎ', 'Ǎ'),
                    ('Ǐ', 'Ǐ'),
                    ('Ǒ', 'Ǒ'),
                    ('Ǔ', 'Ǔ'),
                    ('Ǖ', 'Ǖ'),
                    ('Ǘ', 'Ǘ'),
                    ('Ǚ', 'Ǚ'),
                    ('Ǜ', 'Ǜ'),
                    ('Ǟ', 'Ǟ'),
                    ('Ǡ', 'Ǡ'),
                    ('Ǣ', 'Ǣ'),
                    ('Ǥ', 'Ǥ'),
                    ('Ǧ', 'Ǧ'),
                    ('Ǩ', 'Ǩ'),
                    ('Ǫ', 'Ǫ'),
                    ('Ǭ', 'Ǭ'),
                    ('Ǯ', 'Ǯ'),
                    ('Ǳ', 'ǲ'),
                    ('Ǵ', 'Ǵ'),
                    ('Ƕ', 'Ǹ'),
                    ('Ǻ', 'Ǻ'),
                    ('Ǽ', 'Ǽ'),
                    ('Ǿ', 'Ǿ'),
                    ('Ȁ', 'Ȁ'),
                    ('Ȃ', 'Ȃ'),
                    ('Ȅ', 'Ȅ'),
                    ('Ȇ', 'Ȇ'),
                    ('Ȉ', 'Ȉ'),
                    ('Ȋ', 'Ȋ'),
                    ('Ȍ', 'Ȍ'),
                    ('Ȏ', 'Ȏ'),
                    ('Ȑ', 'Ȑ'),
                    ('Ȓ', 'Ȓ'),
                    ('Ȕ', 'Ȕ'),
                    ('Ȗ', 'Ȗ'),
                    ('Ș', 'Ș'),
                    ('Ț', 'Ț'),
                    ('Ȝ', 'Ȝ'),
                    ('Ȟ', 'Ȟ'),
                    ('Ƞ', 'Ƞ'),
                    ('Ȣ', 'Ȣ'),
                    ('Ȥ', 'Ȥ'),
                    ('Ȧ', 'Ȧ'),
                    ('Ȩ', 'Ȩ'),
                    ('Ȫ', 'Ȫ'),
                    ('Ȭ', 'Ȭ'),
                    ('Ȯ', 'Ȯ'),
                    ('Ȱ', 'Ȱ'),
                    ('Ȳ', 'Ȳ'),
                    ('Ⱥ', 'Ȼ'),
                    ('Ƚ', 'Ⱦ'),
                    ('Ɂ', 'Ɂ'),
                    ('Ƀ', 'Ɇ'),
                    ('Ɉ', 'Ɉ'),
                    ('Ɋ', 'Ɋ'),
                    ('Ɍ', 'Ɍ'),
                    ('Ɏ', 'Ɏ'),
                    ('Ͱ', 'Ͱ'),
                    ('Ͳ', 'Ͳ'),
                    ('Ͷ', 'Ͷ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ώ'),
                    ('Α', 'Ρ'),
                    ('Σ', 'Ϋ'),
                    ('Ϗ', 'Ϗ'),
                    ('ϒ', 'ϔ'),
                    ('Ϙ', 'Ϙ'),
                    ('Ϛ', 'Ϛ'),
                    ('Ϝ', 'Ϝ'),
                    ('Ϟ', 'Ϟ'),
                    ('Ϡ', 'Ϡ'),
                    ('Ϣ', 'Ϣ'),
                    ('Ϥ', 'Ϥ'),
                    ('Ϧ', 'Ϧ'),
                    ('Ϩ', 'Ϩ'),
                    ('Ϫ', 'Ϫ'),
                    ('Ϭ', 'Ϭ'),
                    ('Ϯ', 'Ϯ'),
                    ('ϴ', 'ϴ'),
                    ('Ϸ', 'Ϸ'),
                    ('Ϲ', 'Ϻ'),
                    ('Ͻ', 'Я'),
                    ('Ѡ', 'Ѡ'),
                    ('Ѣ', 'Ѣ'),
                    ('Ѥ', 'Ѥ'),
                    ('Ѧ', 'Ѧ'),
                    ('Ѩ', 'Ѩ'),
                    ('Ѫ', 'Ѫ'),
                    ('Ѭ', 'Ѭ'),
                    ('Ѯ', 'Ѯ'),
                    ('Ѱ', 'Ѱ'),
                    ('Ѳ', 'Ѳ'),
                    ('Ѵ', 'Ѵ'),
                    ('Ѷ', 'Ѷ'),
                    ('Ѹ', 'Ѹ'),
                    ('Ѻ', 'Ѻ'),
                    ('Ѽ', 'Ѽ'),
                    ('Ѿ', 'Ѿ'),
                    ('Ҁ', 'Ҁ'),
                    ('Ҋ', 'Ҋ'),
                    ('Ҍ', 'Ҍ'),
                    ('Ҏ', 'Ҏ'),
                    ('Ґ', 'Ґ'),
                    ('Ғ', 'Ғ'),
                    ('Ҕ', 'Ҕ'),
                    ('Җ', 'Җ'),
                    ('Ҙ', 'Ҙ'),
                    ('Қ', 'Қ'),
                    ('Ҝ', 'Ҝ'),
                    ('Ҟ', 'Ҟ'),
                    ('Ҡ', 'Ҡ'),
                    ('Ң', 'Ң'),
                    ('Ҥ', 'Ҥ'),
                    ('Ҧ', 'Ҧ'),
                    ('Ҩ', 'Ҩ'),
                    ('Ҫ', 'Ҫ'),
                    ('Ҭ', 'Ҭ'),
                    ('Ү', 'Ү'),
                    ('Ұ', 'Ұ'),
                    ('Ҳ', 'Ҳ'),
                    ('Ҵ', 'Ҵ'),
                    ('Ҷ', 'Ҷ'),
                    ('Ҹ', 'Ҹ'),
                    ('Һ', 'Һ'),
                    ('Ҽ', 'Ҽ'),
                    ('Ҿ', 'Ҿ'),
                    ('Ӏ', 'Ӂ'),
                    ('Ӄ', 'Ӄ'),
                    ('Ӆ', 'Ӆ'),
                    ('Ӈ', 'Ӈ'),
                    ('Ӊ', 'Ӊ'),
                    ('Ӌ', 'Ӌ'),
                    ('Ӎ', 'Ӎ'),
                    ('Ӑ', 'Ӑ'),
                    ('Ӓ', 'Ӓ'),
                    ('Ӕ', 'Ӕ'),
                    ('Ӗ', 'Ӗ'),
                    ('Ә', 'Ә'),
                    ('Ӛ', 'Ӛ'),
                    ('Ӝ', 'Ӝ'),
                    ('Ӟ', 'Ӟ'),
                    ('Ӡ', 'Ӡ'),
                    ('Ӣ', 'Ӣ'),
                    ('Ӥ', 'Ӥ'),
                    ('Ӧ', 'Ӧ'),
                    ('Ө', 'Ө'),
                    ('Ӫ', 'Ӫ'),
                    ('Ӭ', 'Ӭ'),
                    ('Ӯ', 'Ӯ'),
                    ('Ӱ', 'Ӱ'),
                    ('Ӳ', 'Ӳ'),
                    ('Ӵ', 'Ӵ'),
                    ('Ӷ', 'Ӷ'),
                    ('Ӹ', 'Ӹ'),
                    ('Ӻ', 'Ӻ'),
                    ('Ӽ', 'Ӽ'),
                    ('Ӿ', 'Ӿ'),
                    ('Ԁ', 'Ԁ'),
                    ('Ԃ', 'Ԃ'),
                    ('Ԅ', 'Ԅ'),
                    ('Ԇ', 'Ԇ'),
                    ('Ԉ', 'Ԉ'),
                    ('Ԋ', 'Ԋ'),
                    ('Ԍ', 'Ԍ'),
                    ('Ԏ', 'Ԏ'),
                    ('Ԑ', 'Ԑ'),
                    ('Ԓ', 'Ԓ'),
                    ('Ԕ', 'Ԕ'),
                    ('Ԗ', 'Ԗ'),
                    ('Ԙ', 'Ԙ'),
                    ('Ԛ', 'Ԛ'),
                    ('Ԝ', 'Ԝ'),
                    ('Ԟ', 'Ԟ'),
                    ('Ԡ', 'Ԡ'),
                    ('Ԣ', 'Ԣ'),
                    ('Ԥ', 'Ԥ'),
                    ('Ԧ', 'Ԧ'),
                    ('Ԩ', 'Ԩ'),
                    ('Ԫ', 'Ԫ'),
                    ('Ԭ', 'Ԭ'),
                    ('Ԯ', 'Ԯ'),
                    ('Ա', 'Ֆ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('Ᲊ', 'Ᲊ'),
                    ('Ḁ', 'Ḁ'),
                    ('Ḃ', 'Ḃ'),
                    ('Ḅ', 'Ḅ'),
                    ('Ḇ', 'Ḇ'),
                    ('Ḉ', 'Ḉ'),
                    ('Ḋ', 'Ḋ'),
                    ('Ḍ', 'Ḍ'),
                    ('Ḏ', 'Ḏ'),
                    ('Ḑ', 'Ḑ'),
                    ('Ḓ', 'Ḓ'),
                    ('Ḕ', 'Ḕ'),
                    ('Ḗ', 'Ḗ'),
                    ('Ḙ', 'Ḙ'),
                    ('Ḛ', 'Ḛ'),
                    ('Ḝ', 'Ḝ'),
                    ('Ḟ', 'Ḟ'),
                    ('Ḡ', 'Ḡ'),
                    ('Ḣ', 'Ḣ'),
                    ('Ḥ', 'Ḥ'),
                    ('Ḧ', 'Ḧ'),
                    ('Ḩ', 'Ḩ'),
                    ('Ḫ', 'Ḫ'),
                    ('Ḭ', 'Ḭ'),
                    ('Ḯ', 'Ḯ'),
                    ('Ḱ', 'Ḱ'),
                    ('Ḳ', 'Ḳ'),
                    ('Ḵ', 'Ḵ'),
                    ('Ḷ', 'Ḷ'),
                    ('Ḹ', 'Ḹ'),
                    ('Ḻ', 'Ḻ'),
                    ('Ḽ', 'Ḽ'),
                    ('Ḿ', 'Ḿ'),
                    ('Ṁ', 'Ṁ'),
                    ('Ṃ', 'Ṃ'),
                    ('Ṅ', 'Ṅ'),
                    ('Ṇ', 'Ṇ'),
                    ('Ṉ', 'Ṉ'),
                    ('Ṋ', 'Ṋ'),
                    ('Ṍ', 'Ṍ'),
                    ('Ṏ', 'Ṏ'),
                    ('Ṑ', 'Ṑ'),
                    ('Ṓ', 'Ṓ'),
                    ('Ṕ', 'Ṕ'),
                    ('Ṗ', 'Ṗ'),
                    ('Ṙ', 'Ṙ'),
                    ('Ṛ', 'Ṛ'),
                    ('Ṝ', 'Ṝ'),
                    ('Ṟ', 'Ṟ'),
                    ('Ṡ', 'Ṡ'),
                    ('Ṣ', 'Ṣ'),
                    ('Ṥ', 'Ṥ'),
                    ('Ṧ', 'Ṧ'),
                    ('Ṩ', 'Ṩ'),
                    ('Ṫ', 'Ṫ'),
                    ('Ṭ', 'Ṭ'),
                    ('Ṯ', 'Ṯ'),
                    ('Ṱ', 'Ṱ'),
                    ('Ṳ', 'Ṳ'),
                    ('Ṵ', 'Ṵ'),
                    ('Ṷ', 'Ṷ'),
                    ('Ṹ', 'Ṹ'),
                    ('Ṻ', 'Ṻ'),
                    ('Ṽ', 'Ṽ'),
                    ('Ṿ', 'Ṿ'),
                    ('Ẁ', 'Ẁ'),
                    ('Ẃ', 'Ẃ'),
                    ('Ẅ', 'Ẅ'),
                    ('Ẇ', 'Ẇ'),
                    ('Ẉ', 'Ẉ'),
                    ('Ẋ', 'Ẋ'),
                    ('Ẍ', 'Ẍ'),
                    ('Ẏ', 'Ẏ'),
                    ('Ẑ', 'Ẑ'),
                    ('Ẓ', 'Ẓ'),
                    ('Ẕ', 'Ẕ'),
                    ('ẞ', 'ẞ'),
                    ('Ạ', 'Ạ'),
                    ('Ả', 'Ả'),
                    ('Ấ', 'Ấ'),
                    ('Ầ', 'Ầ'),
                    ('Ẩ', 'Ẩ'),
                    ('Ẫ', 'Ẫ'),
                    ('Ậ', 'Ậ'),
                    ('Ắ', 'Ắ'),
                    ('Ằ', 'Ằ'),
                    ('Ẳ', 'Ẳ'),
                    ('Ẵ', 'Ẵ'),
                    ('Ặ', 'Ặ'),
                    ('Ẹ', 'Ẹ'),
                    ('Ẻ', 'Ẻ'),
                    ('Ẽ', 'Ẽ'),
                    ('Ế', 'Ế'),
                    ('Ề', 'Ề'),
                    ('Ể', 'Ể'),
                    ('Ễ', 'Ễ'),
                    ('Ệ', 'Ệ'),
                    ('Ỉ', 'Ỉ'),
                    ('Ị', 'Ị'),
                    ('Ọ', 'Ọ'),
                    ('Ỏ', 'Ỏ'),
                    ('Ố', 'Ố'),
                    ('Ồ', 'Ồ'),
                    ('Ổ', 'Ổ'),
                    ('Ỗ', 'Ỗ'),
                    ('Ộ', 'Ộ'),
                    ('Ớ', 'Ớ'),
                    ('Ờ', 'Ờ'),
                    ('Ở', 'Ở'),
                    ('Ỡ', 'Ỡ'),
                    ('Ợ', 'Ợ'),
                    ('Ụ', 'Ụ'),
                    ('Ủ', 'Ủ'),
                    ('Ứ', 'Ứ'),
                    ('Ừ', 'Ừ'),
                    ('Ử', 'Ử'),
                    ('Ữ', 'Ữ'),
                    ('Ự', 'Ự'),
                    ('Ỳ', 'Ỳ'),
                    ('Ỵ', 'Ỵ'),
                    ('Ỷ', 'Ỷ'),
                    ('Ỹ', 'Ỹ'),
                    ('Ỻ', 'Ỻ'),
                    ('Ỽ', 'Ỽ'),
                    ('Ỿ', 'Ỿ'),
                    ('Ἀ', 'Ἇ'),
                    ('Ἐ', 'Ἕ'),
                    ('Ἠ', 'Ἧ'),
                    ('Ἰ', 'Ἷ'),
                    ('Ὀ', 'Ὅ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'Ὗ'),
                    ('Ὠ', 'Ὧ'),
                    ('ᾈ', 'ᾏ'),
                    ('ᾘ', 'ᾟ'),
                    ('ᾨ', 'ᾯ'),
                    ('Ᾰ', 'ᾼ'),
                    ('Ὲ', 'ῌ'),
                    ('Ῐ', 'Ί'),
                    ('Ῠ', 'Ῥ'),
                    ('Ὸ', 'ῼ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℋ', 'ℍ'),
                    ('ℐ', 'ℒ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℰ', 'ℳ'),
                    ('ℾ', 'ℿ'),
                    ('ⅅ', 'ⅅ'),
                    ('Ⅰ', 'Ⅿ'),
                    ('Ↄ', 'Ↄ'),
                    ('Ⓐ', 'Ⓩ'),
                    ('Ⰰ', 'Ⱟ'),
                    ('Ⱡ', 'Ⱡ'),
                    ('Ɫ', 'Ɽ'),
                    ('Ⱨ', 'Ⱨ'),
                    ('Ⱪ', 'Ⱪ'),
                    ('Ⱬ', 'Ⱬ'),
                    ('Ɑ', 'Ɒ'),
                    ('Ⱳ', 'Ⱳ'),
                    ('Ⱶ', 'Ⱶ'),
                    ('Ȿ', 'Ⲁ'),
                    ('Ⲃ', 'Ⲃ'),
                    ('Ⲅ', 'Ⲅ'),
                    ('Ⲇ', 'Ⲇ'),
                    ('Ⲉ', 'Ⲉ'),
                    ('Ⲋ', 'Ⲋ'),
                    ('Ⲍ', 'Ⲍ'),
                    ('Ⲏ', 'Ⲏ'),
                    ('Ⲑ', 'Ⲑ'),
                    ('Ⲓ', 'Ⲓ'),
                    ('Ⲕ', 'Ⲕ'),
                    ('Ⲗ', 'Ⲗ'),
                    ('Ⲙ', 'Ⲙ'),
                    ('Ⲛ', 'Ⲛ'),
                    ('Ⲝ', 'Ⲝ'),
                    ('Ⲟ', 'Ⲟ'),
                    ('Ⲡ', 'Ⲡ'),
                    ('Ⲣ', 'Ⲣ'),
                    ('Ⲥ', 'Ⲥ'),
                    ('Ⲧ', 'Ⲧ'),
                    ('Ⲩ', 'Ⲩ'),
                    ('Ⲫ', 'Ⲫ'),
                    ('Ⲭ', 'Ⲭ'),
                    ('Ⲯ', 'Ⲯ'),
                    ('Ⲱ', 'Ⲱ'),
                    ('Ⲳ', 'Ⲳ'),
                    ('Ⲵ', 'Ⲵ'),
                    ('Ⲷ', 'Ⲷ'),
                    ('Ⲹ', 'Ⲹ'),
                    ('Ⲻ', 'Ⲻ'),
                    ('Ⲽ', 'Ⲽ'),
                    ('Ⲿ', 'Ⲿ'),
                    ('Ⳁ', 'Ⳁ'),
                    ('Ⳃ', 'Ⳃ'),
                    ('Ⳅ', 'Ⳅ'),
                    ('Ⳇ', 'Ⳇ'),
                    ('Ⳉ', 'Ⳉ'),
                    ('Ⳋ', 'Ⳋ'),
                    ('Ⳍ', 'Ⳍ'),
                    ('Ⳏ', 'Ⳏ'),
                    ('Ⳑ', 'Ⳑ'),
                    ('Ⳓ', 'Ⳓ'),
                    ('Ⳕ', 'Ⳕ'),
                    ('Ⳗ', 'Ⳗ'),
                    ('Ⳙ', 'Ⳙ'),
                    ('Ⳛ', 'Ⳛ'),
                    ('Ⳝ', 'Ⳝ'),
                    ('Ⳟ', 'Ⳟ'),
                    ('Ⳡ', 'Ⳡ'),
                    ('Ⳣ', 'Ⳣ'),
                    ('Ⳬ', 'Ⳬ'),
                    ('Ⳮ', 'Ⳮ'),
                    ('Ⳳ', 'Ⳳ'),
                    ('Ꙁ', 'Ꙁ'),
                    ('Ꙃ', 'Ꙃ'),
                    ('Ꙅ', 'Ꙅ'),
                    ('Ꙇ', 'Ꙇ'),
                    ('Ꙉ', 'Ꙉ'),
                    ('Ꙋ', 'Ꙋ'),
                    ('Ꙍ', 'Ꙍ'),
                    ('Ꙏ', 'Ꙏ'),
                    ('Ꙑ', 'Ꙑ'),
                    ('Ꙓ', 'Ꙓ'),
                    ('Ꙕ', 'Ꙕ'),
                    ('Ꙗ', 'Ꙗ'),
                    ('Ꙙ', 'Ꙙ'),
                    ('Ꙛ', 'Ꙛ'),
                    ('Ꙝ', 'Ꙝ'),
                    ('Ꙟ', 'Ꙟ'),
                    ('Ꙡ', 'Ꙡ'),
                    ('Ꙣ', 'Ꙣ'),
                    ('Ꙥ', 'Ꙥ'),
                    ('Ꙧ', 'Ꙧ'),
                    ('Ꙩ', 'Ꙩ'),
                    ('Ꙫ', 'Ꙫ'),
                    ('Ꙭ', 'Ꙭ'),
                    ('Ꚁ', 'Ꚁ'),
                    ('Ꚃ', 'Ꚃ'),
                    ('Ꚅ', 'Ꚅ'),
                    ('Ꚇ', 'Ꚇ'),
                    ('Ꚉ', 'Ꚉ'),
                    ('Ꚋ', 'Ꚋ'),
                    ('Ꚍ', 'Ꚍ'),
                    ('Ꚏ', 'Ꚏ'),
                    ('Ꚑ', 'Ꚑ'),
                    ('Ꚓ', 'Ꚓ'),
                    ('Ꚕ', 'Ꚕ'),
                    ('Ꚗ', 'Ꚗ'),
                    ('Ꚙ', 'Ꚙ'),
                    ('Ꚛ', 'Ꚛ'),
                    ('Ꜣ', 'Ꜣ'),
                    ('Ꜥ', 'Ꜥ'),
                    ('Ꜧ', 'Ꜧ'),
                    ('Ꜩ', 'Ꜩ'),
                    ('Ꜫ', 'Ꜫ'),
                    ('Ꜭ', 'Ꜭ'),
                    ('Ꜯ', 'Ꜯ'),
                    ('Ꜳ', 'Ꜳ'),
                    ('Ꜵ', 'Ꜵ'),
                    ('Ꜷ', 'Ꜷ'),
                    ('Ꜹ', 'Ꜹ'),
                    ('Ꜻ', 'Ꜻ'),
                    ('Ꜽ', 'Ꜽ'),
                    ('Ꜿ', 'Ꜿ'),
                    ('Ꝁ', 'Ꝁ'),
                    ('Ꝃ', 'Ꝃ'),
                    ('Ꝅ', 'Ꝅ'),
                    ('Ꝇ', 'Ꝇ'),
                    ('Ꝉ', 'Ꝉ'),
                    ('Ꝋ', 'Ꝋ'),
                    ('Ꝍ', 'Ꝍ'),
                    ('Ꝏ', 'Ꝏ'),
                    ('Ꝑ', 'Ꝑ'),
                    ('Ꝓ', 'Ꝓ'),
                    ('Ꝕ', 'Ꝕ'),
                    ('Ꝗ', 'Ꝗ'),
                    ('Ꝙ', 'Ꝙ'),
                    ('Ꝛ', 'Ꝛ'),
                    ('Ꝝ', 'Ꝝ'),
                    ('Ꝟ', 'Ꝟ'),
                    ('Ꝡ', 'Ꝡ'),
                    ('Ꝣ', 'Ꝣ'),
                    ('Ꝥ', 'Ꝥ'),
                    ('Ꝧ', 'Ꝧ'),
                    ('Ꝩ', 'Ꝩ'),
                    ('Ꝫ', 'Ꝫ'),
                    ('Ꝭ', 'Ꝭ'),
                    ('Ꝯ', 'Ꝯ'),
                    ('Ꝺ', 'Ꝺ'),
                    ('Ꝼ', 'Ꝼ'),
                    ('Ᵹ', 'Ꝿ'),
                    ('Ꞁ', 'Ꞁ'),
                    ('Ꞃ', 'Ꞃ'),
                    ('Ꞅ', 'Ꞅ'),
                    ('Ꞇ', 'Ꞇ'),
                    ('Ꞌ', 'Ꞌ'),
                    ('Ɥ', 'Ɥ'),
                    ('Ꞑ', 'Ꞑ'),
                    ('Ꞓ', 'Ꞓ'),
                    ('Ꞗ', 'Ꞗ'),
                    ('Ꞙ', 'Ꞙ'),
                    ('Ꞛ', 'Ꞛ'),
                    ('Ꞝ', 'Ꞝ'),
                    ('Ꞟ', 'Ꞟ'),
                    ('Ꞡ', 'Ꞡ'),
                    ('Ꞣ', 'Ꞣ'),
                    ('Ꞥ', 'Ꞥ'),
                    ('Ꞧ', 'Ꞧ'),
                    ('Ꞩ', 'Ꞩ'),
                    ('Ɦ', 'Ɪ'),
                    ('Ʞ', 'Ꞵ'),
                    ('Ꞷ', 'Ꞷ'),
                    ('Ꞹ', 'Ꞹ'),
                    ('Ꞻ', 'Ꞻ'),
                    ('Ꞽ', 'Ꞽ'),
                    ('Ꞿ', 'Ꞿ'),
                    ('Ꟁ', 'Ꟁ'),
                    ('Ꟃ', 'Ꟃ'),
                    ('Ꞔ', 'Ꟈ'),
                    ('Ꟊ', 'Ꟊ'),
                    ('Ɤ', 'Ꟍ'),
                    ('Ꟑ', 'Ꟑ'),
                    ('Ꟗ', 'Ꟗ'),
                    ('Ꟙ', 'Ꟙ'),
                    ('Ꟛ', 'Ꟛ'),
                    ('Ƛ', 'Ƛ'),
                    ('Ꟶ', 'Ꟶ'),
                    ('Ａ', 'Ｚ'),
                    ('𐐀', '𐐧'),
                    ('𐒰', '𐓓'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐲀', '𐲲'),
                    ('𐵐', '𐵥'),
                    ('𑢠', '𑢿'),
                    ('𖹀', '𖹟'),
                    ('𝐀', '𝐙'),
                    ('𝐴', '𝑍'),
                    ('𝑨', '𝒁'),
                    ('𝒜', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒵'),
                    ('𝓐', '𝓩'),
                    ('𝔄', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔸', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕬', '𝖅'),
                    ('𝖠', '𝖹'),
                    ('𝗔', '𝗭'),
                    ('𝘈', '𝘡'),
                    ('𝘼', '𝙕'),
                    ('𝙰', '𝚉'),
                    ('𝚨', '𝛀'),
                    ('𝛢', '𝛺'),
                    ('𝜜', '𝜴'),
                    ('𝝖', '𝝮'),
                    ('𝞐', '𝞨'),
                    ('𝟊', '𝟊'),
                    ('𞤀', '𞤡'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                ];
            }

            pub mod word_break
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = &[
                    ("ALetter", ALETTER),
                    ("CR", CR),
                    ("Double_Quote", DOUBLE_QUOTE),
                    ("Extend", EXTEND),
                    ("ExtendNumLet", EXTENDNUMLET),
                    ("Format", FORMAT),
                    ("Hebrew_Letter", HEBREW_LETTER),
                    ("Katakana", KATAKANA),
                    ("LF", LF),
                    ("MidLetter", MIDLETTER),
                    ("MidNum", MIDNUM),
                    ("MidNumLet", MIDNUMLET),
                    ("Newline", NEWLINE),
                    ("Numeric", NUMERIC),
                    ("Regional_Indicator", REGIONAL_INDICATOR),
                    ("Single_Quote", SINGLE_QUOTE),
                    ("WSegSpace", WSEGSPACE),
                    ("ZWJ", ZWJ),
                ];

                pub const ALETTER: &'static [(char, char)] = &[
                    ('A', 'Z'),
                    ('a', 'z'),
                    ('ª', 'ª'),
                    ('µ', 'µ'),
                    ('º', 'º'),
                    ('À', 'Ö'),
                    ('Ø', 'ö'),
                    ('ø', '˗'),
                    ('˞', '˿'),
                    ('Ͱ', 'ʹ'),
                    ('Ͷ', 'ͷ'),
                    ('ͺ', 'ͽ'),
                    ('Ϳ', 'Ϳ'),
                    ('Ά', 'Ά'),
                    ('Έ', 'Ί'),
                    ('Ό', 'Ό'),
                    ('Ύ', 'Ρ'),
                    ('Σ', 'ϵ'),
                    ('Ϸ', 'ҁ'),
                    ('Ҋ', 'ԯ'),
                    ('Ա', 'Ֆ'),
                    ('ՙ', '՜'),
                    ('՞', '՞'),
                    ('ՠ', 'ֈ'),
                    ('֊', '֊'),
                    ('׳', '׳'),
                    ('ؠ', 'ي'),
                    ('ٮ', 'ٯ'),
                    ('ٱ', 'ۓ'),
                    ('ە', 'ە'),
                    ('ۥ', 'ۦ'),
                    ('ۮ', 'ۯ'),
                    ('ۺ', 'ۼ'),
                    ('ۿ', 'ۿ'),
                    ('\u{70f}', 'ܐ'),
                    ('ܒ', 'ܯ'),
                    ('ݍ', 'ޥ'),
                    ('ޱ', 'ޱ'),
                    ('ߊ', 'ߪ'),
                    ('ߴ', 'ߵ'),
                    ('ߺ', 'ߺ'),
                    ('ࠀ', 'ࠕ'),
                    ('ࠚ', 'ࠚ'),
                    ('ࠤ', 'ࠤ'),
                    ('ࠨ', 'ࠨ'),
                    ('ࡀ', 'ࡘ'),
                    ('ࡠ', 'ࡪ'),
                    ('ࡰ', 'ࢇ'),
                    ('ࢉ', 'ࢎ'),
                    ('ࢠ', 'ࣉ'),
                    ('ऄ', 'ह'),
                    ('ऽ', 'ऽ'),
                    ('ॐ', 'ॐ'),
                    ('क़', 'ॡ'),
                    ('ॱ', 'ঀ'),
                    ('অ', 'ঌ'),
                    ('এ', 'ঐ'),
                    ('ও', 'ন'),
                    ('প', 'র'),
                    ('ল', 'ল'),
                    ('শ', 'হ'),
                    ('ঽ', 'ঽ'),
                    ('ৎ', 'ৎ'),
                    ('ড়', 'ঢ়'),
                    ('য়', 'ৡ'),
                    ('ৰ', 'ৱ'),
                    ('ৼ', 'ৼ'),
                    ('ਅ', 'ਊ'),
                    ('ਏ', 'ਐ'),
                    ('ਓ', 'ਨ'),
                    ('ਪ', 'ਰ'),
                    ('ਲ', 'ਲ਼'),
                    ('ਵ', 'ਸ਼'),
                    ('ਸ', 'ਹ'),
                    ('ਖ਼', 'ੜ'),
                    ('ਫ਼', 'ਫ਼'),
                    ('ੲ', 'ੴ'),
                    ('અ', 'ઍ'),
                    ('એ', 'ઑ'),
                    ('ઓ', 'ન'),
                    ('પ', 'ર'),
                    ('લ', 'ળ'),
                    ('વ', 'હ'),
                    ('ઽ', 'ઽ'),
                    ('ૐ', 'ૐ'),
                    ('ૠ', 'ૡ'),
                    ('ૹ', 'ૹ'),
                    ('ଅ', 'ଌ'),
                    ('ଏ', 'ଐ'),
                    ('ଓ', 'ନ'),
                    ('ପ', 'ର'),
                    ('ଲ', 'ଳ'),
                    ('ଵ', 'ହ'),
                    ('ଽ', 'ଽ'),
                    ('ଡ଼', 'ଢ଼'),
                    ('ୟ', 'ୡ'),
                    ('ୱ', 'ୱ'),
                    ('ஃ', 'ஃ'),
                    ('அ', 'ஊ'),
                    ('எ', 'ஐ'),
                    ('ஒ', 'க'),
                    ('ங', 'ச'),
                    ('ஜ', 'ஜ'),
                    ('ஞ', 'ட'),
                    ('ண', 'த'),
                    ('ந', 'ப'),
                    ('ம', 'ஹ'),
                    ('ௐ', 'ௐ'),
                    ('అ', 'ఌ'),
                    ('ఎ', 'ఐ'),
                    ('ఒ', 'న'),
                    ('ప', 'హ'),
                    ('ఽ', 'ఽ'),
                    ('ౘ', 'ౚ'),
                    ('ౝ', 'ౝ'),
                    ('ౠ', 'ౡ'),
                    ('ಀ', 'ಀ'),
                    ('ಅ', 'ಌ'),
                    ('ಎ', 'ಐ'),
                    ('ಒ', 'ನ'),
                    ('ಪ', 'ಳ'),
                    ('ವ', 'ಹ'),
                    ('ಽ', 'ಽ'),
                    ('ೝ', 'ೞ'),
                    ('ೠ', 'ೡ'),
                    ('ೱ', 'ೲ'),
                    ('ഄ', 'ഌ'),
                    ('എ', 'ഐ'),
                    ('ഒ', 'ഺ'),
                    ('ഽ', 'ഽ'),
                    ('ൎ', 'ൎ'),
                    ('ൔ', 'ൖ'),
                    ('ൟ', 'ൡ'),
                    ('ൺ', 'ൿ'),
                    ('අ', 'ඖ'),
                    ('ක', 'න'),
                    ('ඳ', 'ර'),
                    ('ල', 'ල'),
                    ('ව', 'ෆ'),
                    ('ༀ', 'ༀ'),
                    ('ཀ', 'ཇ'),
                    ('ཉ', 'ཬ'),
                    ('ྈ', 'ྌ'),
                    ('Ⴀ', 'Ⴥ'),
                    ('Ⴧ', 'Ⴧ'),
                    ('Ⴭ', 'Ⴭ'),
                    ('ა', 'ჺ'),
                    ('ჼ', 'ቈ'),
                    ('ቊ', 'ቍ'),
                    ('ቐ', 'ቖ'),
                    ('ቘ', 'ቘ'),
                    ('ቚ', 'ቝ'),
                    ('በ', 'ኈ'),
                    ('ኊ', 'ኍ'),
                    ('ነ', 'ኰ'),
                    ('ኲ', 'ኵ'),
                    ('ኸ', 'ኾ'),
                    ('ዀ', 'ዀ'),
                    ('ዂ', 'ዅ'),
                    ('ወ', 'ዖ'),
                    ('ዘ', 'ጐ'),
                    ('ጒ', 'ጕ'),
                    ('ጘ', 'ፚ'),
                    ('ᎀ', 'ᎏ'),
                    ('Ꭰ', 'Ᏽ'),
                    ('ᏸ', 'ᏽ'),
                    ('ᐁ', 'ᙬ'),
                    ('ᙯ', 'ᙿ'),
                    ('ᚁ', 'ᚚ'),
                    ('ᚠ', 'ᛪ'),
                    ('ᛮ', 'ᛸ'),
                    ('ᜀ', 'ᜑ'),
                    ('ᜟ', 'ᜱ'),
                    ('ᝀ', 'ᝑ'),
                    ('ᝠ', 'ᝬ'),
                    ('ᝮ', 'ᝰ'),
                    ('ᠠ', 'ᡸ'),
                    ('ᢀ', 'ᢄ'),
                    ('ᢇ', 'ᢨ'),
                    ('ᢪ', 'ᢪ'),
                    ('ᢰ', 'ᣵ'),
                    ('ᤀ', 'ᤞ'),
                    ('ᨀ', 'ᨖ'),
                    ('ᬅ', 'ᬳ'),
                    ('ᭅ', 'ᭌ'),
                    ('ᮃ', 'ᮠ'),
                    ('ᮮ', 'ᮯ'),
                    ('ᮺ', 'ᯥ'),
                    ('ᰀ', 'ᰣ'),
                    ('ᱍ', 'ᱏ'),
                    ('ᱚ', 'ᱽ'),
                    ('ᲀ', 'ᲊ'),
                    ('Ა', 'Ჺ'),
                    ('Ჽ', 'Ჿ'),
                    ('ᳩ', 'ᳬ'),
                    ('ᳮ', 'ᳳ'),
                    ('ᳵ', 'ᳶ'),
                    ('ᳺ', 'ᳺ'),
                    ('ᴀ', 'ᶿ'),
                    ('Ḁ', 'ἕ'),
                    ('Ἐ', 'Ἕ'),
                    ('ἠ', 'ὅ'),
                    ('Ὀ', 'Ὅ'),
                    ('ὐ', 'ὗ'),
                    ('Ὑ', 'Ὑ'),
                    ('Ὓ', 'Ὓ'),
                    ('Ὕ', 'Ὕ'),
                    ('Ὗ', 'ώ'),
                    ('ᾀ', 'ᾴ'),
                    ('ᾶ', 'ᾼ'),
                    ('ι', 'ι'),
                    ('ῂ', 'ῄ'),
                    ('ῆ', 'ῌ'),
                    ('ῐ', 'ΐ'),
                    ('ῖ', 'Ί'),
                    ('ῠ', 'Ῥ'),
                    ('ῲ', 'ῴ'),
                    ('ῶ', 'ῼ'),
                    ('ⁱ', 'ⁱ'),
                    ('ⁿ', 'ⁿ'),
                    ('ₐ', 'ₜ'),
                    ('ℂ', 'ℂ'),
                    ('ℇ', 'ℇ'),
                    ('ℊ', 'ℓ'),
                    ('ℕ', 'ℕ'),
                    ('ℙ', 'ℝ'),
                    ('ℤ', 'ℤ'),
                    ('Ω', 'Ω'),
                    ('ℨ', 'ℨ'),
                    ('K', 'ℭ'),
                    ('ℯ', 'ℹ'),
                    ('ℼ', 'ℿ'),
                    ('ⅅ', 'ⅉ'),
                    ('ⅎ', 'ⅎ'),
                    ('Ⅰ', 'ↈ'),
                    ('Ⓐ', 'ⓩ'),
                    ('Ⰰ', 'ⳤ'),
                    ('Ⳬ', 'ⳮ'),
                    ('Ⳳ', 'ⳳ'),
                    ('ⴀ', 'ⴥ'),
                    ('ⴧ', 'ⴧ'),
                    ('ⴭ', 'ⴭ'),
                    ('ⴰ', 'ⵧ'),
                    ('ⵯ', 'ⵯ'),
                    ('ⶀ', 'ⶖ'),
                    ('ⶠ', 'ⶦ'),
                    ('ⶨ', 'ⶮ'),
                    ('ⶰ', 'ⶶ'),
                    ('ⶸ', 'ⶾ'),
                    ('ⷀ', 'ⷆ'),
                    ('ⷈ', 'ⷎ'),
                    ('ⷐ', 'ⷖ'),
                    ('ⷘ', 'ⷞ'),
                    ('ⸯ', 'ⸯ'),
                    ('々', '々'),
                    ('〻', '〼'),
                    ('ㄅ', 'ㄯ'),
                    ('ㄱ', 'ㆎ'),
                    ('ㆠ', 'ㆿ'),
                    ('ꀀ', 'ꒌ'),
                    ('ꓐ', 'ꓽ'),
                    ('ꔀ', 'ꘌ'),
                    ('ꘐ', 'ꘟ'),
                    ('ꘪ', 'ꘫ'),
                    ('Ꙁ', 'ꙮ'),
                    ('ꙿ', 'ꚝ'),
                    ('ꚠ', 'ꛯ'),
                    ('꜈', 'ꟍ'),
                    ('Ꟑ', 'ꟑ'),
                    ('ꟓ', 'ꟓ'),
                    ('ꟕ', 'Ƛ'),
                    ('ꟲ', 'ꠁ'),
                    ('ꠃ', 'ꠅ'),
                    ('ꠇ', 'ꠊ'),
                    ('ꠌ', 'ꠢ'),
                    ('ꡀ', 'ꡳ'),
                    ('ꢂ', 'ꢳ'),
                    ('ꣲ', 'ꣷ'),
                    ('ꣻ', 'ꣻ'),
                    ('ꣽ', 'ꣾ'),
                    ('ꤊ', 'ꤥ'),
                    ('ꤰ', 'ꥆ'),
                    ('ꥠ', 'ꥼ'),
                    ('ꦄ', 'ꦲ'),
                    ('ꧏ', 'ꧏ'),
                    ('ꨀ', 'ꨨ'),
                    ('ꩀ', 'ꩂ'),
                    ('ꩄ', 'ꩋ'),
                    ('ꫠ', 'ꫪ'),
                    ('ꫲ', 'ꫴ'),
                    ('ꬁ', 'ꬆ'),
                    ('ꬉ', 'ꬎ'),
                    ('ꬑ', 'ꬖ'),
                    ('ꬠ', 'ꬦ'),
                    ('ꬨ', 'ꬮ'),
                    ('ꬰ', 'ꭩ'),
                    ('ꭰ', 'ꯢ'),
                    ('가', '힣'),
                    ('ힰ', 'ퟆ'),
                    ('ퟋ', 'ퟻ'),
                    ('ﬀ', 'ﬆ'),
                    ('ﬓ', 'ﬗ'),
                    ('ﭐ', 'ﮱ'),
                    ('ﯓ', 'ﴽ'),
                    ('ﵐ', 'ﶏ'),
                    ('ﶒ', 'ﷇ'),
                    ('ﷰ', 'ﷻ'),
                    ('ﹰ', 'ﹴ'),
                    ('ﹶ', 'ﻼ'),
                    ('Ａ', 'Ｚ'),
                    ('ａ', 'ｚ'),
                    ('ﾠ', 'ﾾ'),
                    ('ￂ', 'ￇ'),
                    ('ￊ', 'ￏ'),
                    ('ￒ', 'ￗ'),
                    ('ￚ', 'ￜ'),
                    ('𐀀', '𐀋'),
                    ('𐀍', '𐀦'),
                    ('𐀨', '𐀺'),
                    ('𐀼', '𐀽'),
                    ('𐀿', '𐁍'),
                    ('𐁐', '𐁝'),
                    ('𐂀', '𐃺'),
                    ('𐅀', '𐅴'),
                    ('𐊀', '𐊜'),
                    ('𐊠', '𐋐'),
                    ('𐌀', '𐌟'),
                    ('𐌭', '𐍊'),
                    ('𐍐', '𐍵'),
                    ('𐎀', '𐎝'),
                    ('𐎠', '𐏃'),
                    ('𐏈', '𐏏'),
                    ('𐏑', '𐏕'),
                    ('𐐀', '𐒝'),
                    ('𐒰', '𐓓'),
                    ('𐓘', '𐓻'),
                    ('𐔀', '𐔧'),
                    ('𐔰', '𐕣'),
                    ('𐕰', '𐕺'),
                    ('𐕼', '𐖊'),
                    ('𐖌', '𐖒'),
                    ('𐖔', '𐖕'),
                    ('𐖗', '𐖡'),
                    ('𐖣', '𐖱'),
                    ('𐖳', '𐖹'),
                    ('𐖻', '𐖼'),
                    ('𐗀', '𐗳'),
                    ('𐘀', '𐜶'),
                    ('𐝀', '𐝕'),
                    ('𐝠', '𐝧'),
                    ('𐞀', '𐞅'),
                    ('𐞇', '𐞰'),
                    ('𐞲', '𐞺'),
                    ('𐠀', '𐠅'),
                    ('𐠈', '𐠈'),
                    ('𐠊', '𐠵'),
                    ('𐠷', '𐠸'),
                    ('𐠼', '𐠼'),
                    ('𐠿', '𐡕'),
                    ('𐡠', '𐡶'),
                    ('𐢀', '𐢞'),
                    ('𐣠', '𐣲'),
                    ('𐣴', '𐣵'),
                    ('𐤀', '𐤕'),
                    ('𐤠', '𐤹'),
                    ('𐦀', '𐦷'),
                    ('𐦾', '𐦿'),
                    ('𐨀', '𐨀'),
                    ('𐨐', '𐨓'),
                    ('𐨕', '𐨗'),
                    ('𐨙', '𐨵'),
                    ('𐩠', '𐩼'),
                    ('𐪀', '𐪜'),
                    ('𐫀', '𐫇'),
                    ('𐫉', '𐫤'),
                    ('𐬀', '𐬵'),
                    ('𐭀', '𐭕'),
                    ('𐭠', '𐭲'),
                    ('𐮀', '𐮑'),
                    ('𐰀', '𐱈'),
                    ('𐲀', '𐲲'),
                    ('𐳀', '𐳲'),
                    ('𐴀', '𐴣'),
                    ('𐵊', '𐵥'),
                    ('𐵯', '𐶅'),
                    ('𐺀', '𐺩'),
                    ('𐺰', '𐺱'),
                    ('𐻂', '𐻄'),
                    ('𐼀', '𐼜'),
                    ('𐼧', '𐼧'),
                    ('𐼰', '𐽅'),
                    ('𐽰', '𐾁'),
                    ('𐾰', '𐿄'),
                    ('𐿠', '𐿶'),
                    ('𑀃', '𑀷'),
                    ('𑁱', '𑁲'),
                    ('𑁵', '𑁵'),
                    ('𑂃', '𑂯'),
                    ('𑃐', '𑃨'),
                    ('𑄃', '𑄦'),
                    ('𑅄', '𑅄'),
                    ('𑅇', '𑅇'),
                    ('𑅐', '𑅲'),
                    ('𑅶', '𑅶'),
                    ('𑆃', '𑆲'),
                    ('𑇁', '𑇄'),
                    ('𑇚', '𑇚'),
                    ('𑇜', '𑇜'),
                    ('𑈀', '𑈑'),
                    ('𑈓', '𑈫'),
                    ('𑈿', '𑉀'),
                    ('𑊀', '𑊆'),
                    ('𑊈', '𑊈'),
                    ('𑊊', '𑊍'),
                    ('𑊏', '𑊝'),
                    ('𑊟', '𑊨'),
                    ('𑊰', '𑋞'),
                    ('𑌅', '𑌌'),
                    ('𑌏', '𑌐'),
                    ('𑌓', '𑌨'),
                    ('𑌪', '𑌰'),
                    ('𑌲', '𑌳'),
                    ('𑌵', '𑌹'),
                    ('𑌽', '𑌽'),
                    ('𑍐', '𑍐'),
                    ('𑍝', '𑍡'),
                    ('𑎀', '𑎉'),
                    ('𑎋', '𑎋'),
                    ('𑎎', '𑎎'),
                    ('𑎐', '𑎵'),
                    ('𑎷', '𑎷'),
                    ('𑏑', '𑏑'),
                    ('𑏓', '𑏓'),
                    ('𑐀', '𑐴'),
                    ('𑑇', '𑑊'),
                    ('𑑟', '𑑡'),
                    ('𑒀', '𑒯'),
                    ('𑓄', '𑓅'),
                    ('𑓇', '𑓇'),
                    ('𑖀', '𑖮'),
                    ('𑗘', '𑗛'),
                    ('𑘀', '𑘯'),
                    ('𑙄', '𑙄'),
                    ('𑚀', '𑚪'),
                    ('𑚸', '𑚸'),
                    ('𑠀', '𑠫'),
                    ('𑢠', '𑣟'),
                    ('𑣿', '𑤆'),
                    ('𑤉', '𑤉'),
                    ('𑤌', '𑤓'),
                    ('𑤕', '𑤖'),
                    ('𑤘', '𑤯'),
                    ('𑤿', '𑤿'),
                    ('𑥁', '𑥁'),
                    ('𑦠', '𑦧'),
                    ('𑦪', '𑧐'),
                    ('𑧡', '𑧡'),
                    ('𑧣', '𑧣'),
                    ('𑨀', '𑨀'),
                    ('𑨋', '𑨲'),
                    ('𑨺', '𑨺'),
                    ('𑩐', '𑩐'),
                    ('𑩜', '𑪉'),
                    ('𑪝', '𑪝'),
                    ('𑪰', '𑫸'),
                    ('𑯀', '𑯠'),
                    ('𑰀', '𑰈'),
                    ('𑰊', '𑰮'),
                    ('𑱀', '𑱀'),
                    ('𑱲', '𑲏'),
                    ('𑴀', '𑴆'),
                    ('𑴈', '𑴉'),
                    ('𑴋', '𑴰'),
                    ('𑵆', '𑵆'),
                    ('𑵠', '𑵥'),
                    ('𑵧', '𑵨'),
                    ('𑵪', '𑶉'),
                    ('𑶘', '𑶘'),
                    ('𑻠', '𑻲'),
                    ('𑼂', '𑼂'),
                    ('𑼄', '𑼐'),
                    ('𑼒', '𑼳'),
                    ('𑾰', '𑾰'),
                    ('𒀀', '𒎙'),
                    ('𒐀', '𒑮'),
                    ('𒒀', '𒕃'),
                    ('𒾐', '𒿰'),
                    ('𓀀', '𓐯'),
                    ('𓑁', '𓑆'),
                    ('𓑠', '𔏺'),
                    ('𔐀', '𔙆'),
                    ('𖄀', '𖄝'),
                    ('𖠀', '𖨸'),
                    ('𖩀', '𖩞'),
                    ('𖩰', '𖪾'),
                    ('𖫐', '𖫭'),
                    ('𖬀', '𖬯'),
                    ('𖭀', '𖭃'),
                    ('𖭣', '𖭷'),
                    ('𖭽', '𖮏'),
                    ('𖵀', '𖵬'),
                    ('𖹀', '𖹿'),
                    ('𖼀', '𖽊'),
                    ('𖽐', '𖽐'),
                    ('𖾓', '𖾟'),
                    ('𖿠', '𖿡'),
                    ('𖿣', '𖿣'),
                    ('𛰀', '𛱪'),
                    ('𛱰', '𛱼'),
                    ('𛲀', '𛲈'),
                    ('𛲐', '𛲙'),
                    ('𝐀', '𝑔'),
                    ('𝑖', '𝒜'),
                    ('𝒞', '𝒟'),
                    ('𝒢', '𝒢'),
                    ('𝒥', '𝒦'),
                    ('𝒩', '𝒬'),
                    ('𝒮', '𝒹'),
                    ('𝒻', '𝒻'),
                    ('𝒽', '𝓃'),
                    ('𝓅', '𝔅'),
                    ('𝔇', '𝔊'),
                    ('𝔍', '𝔔'),
                    ('𝔖', '𝔜'),
                    ('𝔞', '𝔹'),
                    ('𝔻', '𝔾'),
                    ('𝕀', '𝕄'),
                    ('𝕆', '𝕆'),
                    ('𝕊', '𝕐'),
                    ('𝕒', '𝚥'),
                    ('𝚨', '𝛀'),
                    ('𝛂', '𝛚'),
                    ('𝛜', '𝛺'),
                    ('𝛼', '𝜔'),
                    ('𝜖', '𝜴'),
                    ('𝜶', '𝝎'),
                    ('𝝐', '𝝮'),
                    ('𝝰', '𝞈'),
                    ('𝞊', '𝞨'),
                    ('𝞪', '𝟂'),
                    ('𝟄', '𝟋'),
                    ('𝼀', '𝼞'),
                    ('𝼥', '𝼪'),
                    ('𞀰', '𞁭'),
                    ('𞄀', '𞄬'),
                    ('𞄷', '𞄽'),
                    ('𞅎', '𞅎'),
                    ('𞊐', '𞊭'),
                    ('𞋀', '𞋫'),
                    ('𞓐', '𞓫'),
                    ('𞗐', '𞗭'),
                    ('𞗰', '𞗰'),
                    ('𞟠', '𞟦'),
                    ('𞟨', '𞟫'),
                    ('𞟭', '𞟮'),
                    ('𞟰', '𞟾'),
                    ('𞠀', '𞣄'),
                    ('𞤀', '𞥃'),
                    ('𞥋', '𞥋'),
                    ('𞸀', '𞸃'),
                    ('𞸅', '𞸟'),
                    ('𞸡', '𞸢'),
                    ('𞸤', '𞸤'),
                    ('𞸧', '𞸧'),
                    ('𞸩', '𞸲'),
                    ('𞸴', '𞸷'),
                    ('𞸹', '𞸹'),
                    ('𞸻', '𞸻'),
                    ('𞹂', '𞹂'),
                    ('𞹇', '𞹇'),
                    ('𞹉', '𞹉'),
                    ('𞹋', '𞹋'),
                    ('𞹍', '𞹏'),
                    ('𞹑', '𞹒'),
                    ('𞹔', '𞹔'),
                    ('𞹗', '𞹗'),
                    ('𞹙', '𞹙'),
                    ('𞹛', '𞹛'),
                    ('𞹝', '𞹝'),
                    ('𞹟', '𞹟'),
                    ('𞹡', '𞹢'),
                    ('𞹤', '𞹤'),
                    ('𞹧', '𞹪'),
                    ('𞹬', '𞹲'),
                    ('𞹴', '𞹷'),
                    ('𞹹', '𞹼'),
                    ('𞹾', '𞹾'),
                    ('𞺀', '𞺉'),
                    ('𞺋', '𞺛'),
                    ('𞺡', '𞺣'),
                    ('𞺥', '𞺩'),
                    ('𞺫', '𞺻'),
                    ('🄰', '🅉'),
                    ('🅐', '🅩'),
                    ('🅰', '🆉'),
                ];

                pub const CR: &'static [(char, char)] = &[('\r', '\r')];

                pub const DOUBLE_QUOTE: &'static [(char, char)] = &[('"', '"')];

                pub const EXTEND: &'static [(char, char)] = &[
                    ('\u{300}', '\u{36f}'),
                    ('\u{483}', '\u{489}'),
                    ('\u{591}', '\u{5bd}'),
                    ('\u{5bf}', '\u{5bf}'),
                    ('\u{5c1}', '\u{5c2}'),
                    ('\u{5c4}', '\u{5c5}'),
                    ('\u{5c7}', '\u{5c7}'),
                    ('\u{610}', '\u{61a}'),
                    ('\u{64b}', '\u{65f}'),
                    ('\u{670}', '\u{670}'),
                    ('\u{6d6}', '\u{6dc}'),
                    ('\u{6df}', '\u{6e4}'),
                    ('\u{6e7}', '\u{6e8}'),
                    ('\u{6ea}', '\u{6ed}'),
                    ('\u{711}', '\u{711}'),
                    ('\u{730}', '\u{74a}'),
                    ('\u{7a6}', '\u{7b0}'),
                    ('\u{7eb}', '\u{7f3}'),
                    ('\u{7fd}', '\u{7fd}'),
                    ('\u{816}', '\u{819}'),
                    ('\u{81b}', '\u{823}'),
                    ('\u{825}', '\u{827}'),
                    ('\u{829}', '\u{82d}'),
                    ('\u{859}', '\u{85b}'),
                    ('\u{897}', '\u{89f}'),
                    ('\u{8ca}', '\u{8e1}'),
                    ('\u{8e3}', 'ः'),
                    ('\u{93a}', '\u{93c}'),
                    ('ा', 'ॏ'),
                    ('\u{951}', '\u{957}'),
                    ('\u{962}', '\u{963}'),
                    ('\u{981}', 'ঃ'),
                    ('\u{9bc}', '\u{9bc}'),
                    ('\u{9be}', '\u{9c4}'),
                    ('ে', 'ৈ'),
                    ('ো', '\u{9cd}'),
                    ('\u{9d7}', '\u{9d7}'),
                    ('\u{9e2}', '\u{9e3}'),
                    ('\u{9fe}', '\u{9fe}'),
                    ('\u{a01}', 'ਃ'),
                    ('\u{a3c}', '\u{a3c}'),
                    ('ਾ', '\u{a42}'),
                    ('\u{a47}', '\u{a48}'),
                    ('\u{a4b}', '\u{a4d}'),
                    ('\u{a51}', '\u{a51}'),
                    ('\u{a70}', '\u{a71}'),
                    ('\u{a75}', '\u{a75}'),
                    ('\u{a81}', 'ઃ'),
                    ('\u{abc}', '\u{abc}'),
                    ('ા', '\u{ac5}'),
                    ('\u{ac7}', 'ૉ'),
                    ('ો', '\u{acd}'),
                    ('\u{ae2}', '\u{ae3}'),
                    ('\u{afa}', '\u{aff}'),
                    ('\u{b01}', 'ଃ'),
                    ('\u{b3c}', '\u{b3c}'),
                    ('\u{b3e}', '\u{b44}'),
                    ('େ', 'ୈ'),
                    ('ୋ', '\u{b4d}'),
                    ('\u{b55}', '\u{b57}'),
                    ('\u{b62}', '\u{b63}'),
                    ('\u{b82}', '\u{b82}'),
                    ('\u{bbe}', 'ூ'),
                    ('ெ', 'ை'),
                    ('ொ', '\u{bcd}'),
                    ('\u{bd7}', '\u{bd7}'),
                    ('\u{c00}', '\u{c04}'),
                    ('\u{c3c}', '\u{c3c}'),
                    ('\u{c3e}', 'ౄ'),
                    ('\u{c46}', '\u{c48}'),
                    ('\u{c4a}', '\u{c4d}'),
                    ('\u{c55}', '\u{c56}'),
                    ('\u{c62}', '\u{c63}'),
                    ('\u{c81}', 'ಃ'),
                    ('\u{cbc}', '\u{cbc}'),
                    ('ಾ', 'ೄ'),
                    ('\u{cc6}', '\u{cc8}'),
                    ('\u{cca}', '\u{ccd}'),
                    ('\u{cd5}', '\u{cd6}'),
                    ('\u{ce2}', '\u{ce3}'),
                    ('ೳ', 'ೳ'),
                    ('\u{d00}', 'ഃ'),
                    ('\u{d3b}', '\u{d3c}'),
                    ('\u{d3e}', '\u{d44}'),
                    ('െ', 'ൈ'),
                    ('ൊ', '\u{d4d}'),
                    ('\u{d57}', '\u{d57}'),
                    ('\u{d62}', '\u{d63}'),
                    ('\u{d81}', 'ඃ'),
                    ('\u{dca}', '\u{dca}'),
                    ('\u{dcf}', '\u{dd4}'),
                    ('\u{dd6}', '\u{dd6}'),
                    ('ෘ', '\u{ddf}'),
                    ('ෲ', 'ෳ'),
                    ('\u{e31}', '\u{e31}'),
                    ('\u{e34}', '\u{e3a}'),
                    ('\u{e47}', '\u{e4e}'),
                    ('\u{eb1}', '\u{eb1}'),
                    ('\u{eb4}', '\u{ebc}'),
                    ('\u{ec8}', '\u{ece}'),
                    ('\u{f18}', '\u{f19}'),
                    ('\u{f35}', '\u{f35}'),
                    ('\u{f37}', '\u{f37}'),
                    ('\u{f39}', '\u{f39}'),
                    ('༾', '༿'),
                    ('\u{f71}', '\u{f84}'),
                    ('\u{f86}', '\u{f87}'),
                    ('\u{f8d}', '\u{f97}'),
                    ('\u{f99}', '\u{fbc}'),
                    ('\u{fc6}', '\u{fc6}'),
                    ('ါ', '\u{103e}'),
                    ('ၖ', '\u{1059}'),
                    ('\u{105e}', '\u{1060}'),
                    ('ၢ', 'ၤ'),
                    ('ၧ', 'ၭ'),
                    ('\u{1071}', '\u{1074}'),
                    ('\u{1082}', '\u{108d}'),
                    ('ႏ', 'ႏ'),
                    ('ႚ', '\u{109d}'),
                    ('\u{135d}', '\u{135f}'),
                    ('\u{1712}', '\u{1715}'),
                    ('\u{1732}', '\u{1734}'),
                    ('\u{1752}', '\u{1753}'),
                    ('\u{1772}', '\u{1773}'),
                    ('\u{17b4}', '\u{17d3}'),
                    ('\u{17dd}', '\u{17dd}'),
                    ('\u{180b}', '\u{180d}'),
                    ('\u{180f}', '\u{180f}'),
                    ('\u{1885}', '\u{1886}'),
                    ('\u{18a9}', '\u{18a9}'),
                    ('\u{1920}', 'ᤫ'),
                    ('ᤰ', '\u{193b}'),
                    ('\u{1a17}', '\u{1a1b}'),
                    ('ᩕ', '\u{1a5e}'),
                    ('\u{1a60}', '\u{1a7c}'),
                    ('\u{1a7f}', '\u{1a7f}'),
                    ('\u{1ab0}', '\u{1ace}'),
                    ('\u{1b00}', 'ᬄ'),
                    ('\u{1b34}', '\u{1b44}'),
                    ('\u{1b6b}', '\u{1b73}'),
                    ('\u{1b80}', 'ᮂ'),
                    ('ᮡ', '\u{1bad}'),
                    ('\u{1be6}', '\u{1bf3}'),
                    ('ᰤ', '\u{1c37}'),
                    ('\u{1cd0}', '\u{1cd2}'),
                    ('\u{1cd4}', '\u{1ce8}'),
                    ('\u{1ced}', '\u{1ced}'),
                    ('\u{1cf4}', '\u{1cf4}'),
                    ('᳷', '\u{1cf9}'),
                    ('\u{1dc0}', '\u{1dff}'),
                    ('\u{200c}', '\u{200c}'),
                    ('\u{20d0}', '\u{20f0}'),
                    ('\u{2cef}', '\u{2cf1}'),
                    ('\u{2d7f}', '\u{2d7f}'),
                    ('\u{2de0}', '\u{2dff}'),
                    ('\u{302a}', '\u{302f}'),
                    ('\u{3099}', '\u{309a}'),
                    ('\u{a66f}', '\u{a672}'),
                    ('\u{a674}', '\u{a67d}'),
                    ('\u{a69e}', '\u{a69f}'),
                    ('\u{a6f0}', '\u{a6f1}'),
                    ('\u{a802}', '\u{a802}'),
                    ('\u{a806}', '\u{a806}'),
                    ('\u{a80b}', '\u{a80b}'),
                    ('ꠣ', 'ꠧ'),
                    ('\u{a82c}', '\u{a82c}'),
                    ('ꢀ', 'ꢁ'),
                    ('ꢴ', '\u{a8c5}'),
                    ('\u{a8e0}', '\u{a8f1}'),
                    ('\u{a8ff}', '\u{a8ff}'),
                    ('\u{a926}', '\u{a92d}'),
                    ('\u{a947}', '\u{a953}'),
                    ('\u{a980}', 'ꦃ'),
                    ('\u{a9b3}', '\u{a9c0}'),
                    ('\u{a9e5}', '\u{a9e5}'),
                    ('\u{aa29}', '\u{aa36}'),
                    ('\u{aa43}', '\u{aa43}'),
                    ('\u{aa4c}', 'ꩍ'),
                    ('ꩻ', 'ꩽ'),
                    ('\u{aab0}', '\u{aab0}'),
                    ('\u{aab2}', '\u{aab4}'),
                    ('\u{aab7}', '\u{aab8}'),
                    ('\u{aabe}', '\u{aabf}'),
                    ('\u{aac1}', '\u{aac1}'),
                    ('ꫫ', 'ꫯ'),
                    ('ꫵ', '\u{aaf6}'),
                    ('ꯣ', 'ꯪ'),
                    ('꯬', '\u{abed}'),
                    ('\u{fb1e}', '\u{fb1e}'),
                    ('\u{fe00}', '\u{fe0f}'),
                    ('\u{fe20}', '\u{fe2f}'),
                    ('\u{ff9e}', '\u{ff9f}'),
                    ('\u{101fd}', '\u{101fd}'),
                    ('\u{102e0}', '\u{102e0}'),
                    ('\u{10376}', '\u{1037a}'),
                    ('\u{10a01}', '\u{10a03}'),
                    ('\u{10a05}', '\u{10a06}'),
                    ('\u{10a0c}', '\u{10a0f}'),
                    ('\u{10a38}', '\u{10a3a}'),
                    ('\u{10a3f}', '\u{10a3f}'),
                    ('\u{10ae5}', '\u{10ae6}'),
                    ('\u{10d24}', '\u{10d27}'),
                    ('\u{10d69}', '\u{10d6d}'),
                    ('\u{10eab}', '\u{10eac}'),
                    ('\u{10efc}', '\u{10eff}'),
                    ('\u{10f46}', '\u{10f50}'),
                    ('\u{10f82}', '\u{10f85}'),
                    ('𑀀', '𑀂'),
                    ('\u{11038}', '\u{11046}'),
                    ('\u{11070}', '\u{11070}'),
                    ('\u{11073}', '\u{11074}'),
                    ('\u{1107f}', '𑂂'),
                    ('𑂰', '\u{110ba}'),
                    ('\u{110c2}', '\u{110c2}'),
                    ('\u{11100}', '\u{11102}'),
                    ('\u{11127}', '\u{11134}'),
                    ('𑅅', '𑅆'),
                    ('\u{11173}', '\u{11173}'),
                    ('\u{11180}', '𑆂'),
                    ('𑆳', '\u{111c0}'),
                    ('\u{111c9}', '\u{111cc}'),
                    ('𑇎', '\u{111cf}'),
                    ('𑈬', '\u{11237}'),
                    ('\u{1123e}', '\u{1123e}'),
                    ('\u{11241}', '\u{11241}'),
                    ('\u{112df}', '\u{112ea}'),
                    ('\u{11300}', '𑌃'),
                    ('\u{1133b}', '\u{1133c}'),
                    ('\u{1133e}', '𑍄'),
                    ('𑍇', '𑍈'),
                    ('𑍋', '\u{1134d}'),
                    ('\u{11357}', '\u{11357}'),
                    ('𑍢', '𑍣'),
                    ('\u{11366}', '\u{1136c}'),
                    ('\u{11370}', '\u{11374}'),
                    ('\u{113b8}', '\u{113c0}'),
                    ('\u{113c2}', '\u{113c2}'),
                    ('\u{113c5}', '\u{113c5}'),
                    ('\u{113c7}', '𑏊'),
                    ('𑏌', '\u{113d0}'),
                    ('\u{113d2}', '\u{113d2}'),
                    ('\u{113e1}', '\u{113e2}'),
                    ('𑐵', '\u{11446}'),
                    ('\u{1145e}', '\u{1145e}'),
                    ('\u{114b0}', '\u{114c3}'),
                    ('\u{115af}', '\u{115b5}'),
                    ('𑖸', '\u{115c0}'),
                    ('\u{115dc}', '\u{115dd}'),
                    ('𑘰', '\u{11640}'),
                    ('\u{116ab}', '\u{116b7}'),
                    ('\u{1171d}', '\u{1172b}'),
                    ('𑠬', '\u{1183a}'),
                    ('\u{11930}', '𑤵'),
                    ('𑤷', '𑤸'),
                    ('\u{1193b}', '\u{1193e}'),
                    ('𑥀', '𑥀'),
                    ('𑥂', '\u{11943}'),
                    ('𑧑', '\u{119d7}'),
                    ('\u{119da}', '\u{119e0}'),
                    ('𑧤', '𑧤'),
                    ('\u{11a01}', '\u{11a0a}'),
                    ('\u{11a33}', '𑨹'),
                    ('\u{11a3b}', '\u{11a3e}'),
                    ('\u{11a47}', '\u{11a47}'),
                    ('\u{11a51}', '\u{11a5b}'),
                    ('\u{11a8a}', '\u{11a99}'),
                    ('𑰯', '\u{11c36}'),
                    ('\u{11c38}', '\u{11c3f}'),
                    ('\u{11c92}', '\u{11ca7}'),
                    ('𑲩', '\u{11cb6}'),
                    ('\u{11d31}', '\u{11d36}'),
                    ('\u{11d3a}', '\u{11d3a}'),
                    ('\u{11d3c}', '\u{11d3d}'),
                    ('\u{11d3f}', '\u{11d45}'),
                    ('\u{11d47}', '\u{11d47}'),
                    ('𑶊', '𑶎'),
                    ('\u{11d90}', '\u{11d91}'),
                    ('𑶓', '\u{11d97}'),
                    ('\u{11ef3}', '𑻶'),
                    ('\u{11f00}', '\u{11f01}'),
                    ('𑼃', '𑼃'),
                    ('𑼴', '\u{11f3a}'),
                    ('𑼾', '\u{11f42}'),
                    ('\u{11f5a}', '\u{11f5a}'),
                    ('\u{13440}', '\u{13440}'),
                    ('\u{13447}', '\u{13455}'),
                    ('\u{1611e}', '\u{1612f}'),
                    ('\u{16af0}', '\u{16af4}'),
                    ('\u{16b30}', '\u{16b36}'),
                    ('\u{16f4f}', '\u{16f4f}'),
                    ('𖽑', '𖾇'),
                    ('\u{16f8f}', '\u{16f92}'),
                    ('\u{16fe4}', '\u{16fe4}'),
                    ('\u{16ff0}', '\u{16ff1}'),
                    ('\u{1bc9d}', '\u{1bc9e}'),
                    ('\u{1cf00}', '\u{1cf2d}'),
                    ('\u{1cf30}', '\u{1cf46}'),
                    ('\u{1d165}', '\u{1d169}'),
                    ('\u{1d16d}', '\u{1d172}'),
                    ('\u{1d17b}', '\u{1d182}'),
                    ('\u{1d185}', '\u{1d18b}'),
                    ('\u{1d1aa}', '\u{1d1ad}'),
                    ('\u{1d242}', '\u{1d244}'),
                    ('\u{1da00}', '\u{1da36}'),
                    ('\u{1da3b}', '\u{1da6c}'),
                    ('\u{1da75}', '\u{1da75}'),
                    ('\u{1da84}', '\u{1da84}'),
                    ('\u{1da9b}', '\u{1da9f}'),
                    ('\u{1daa1}', '\u{1daaf}'),
                    ('\u{1e000}', '\u{1e006}'),
                    ('\u{1e008}', '\u{1e018}'),
                    ('\u{1e01b}', '\u{1e021}'),
                    ('\u{1e023}', '\u{1e024}'),
                    ('\u{1e026}', '\u{1e02a}'),
                    ('\u{1e08f}', '\u{1e08f}'),
                    ('\u{1e130}', '\u{1e136}'),
                    ('\u{1e2ae}', '\u{1e2ae}'),
                    ('\u{1e2ec}', '\u{1e2ef}'),
                    ('\u{1e4ec}', '\u{1e4ef}'),
                    ('\u{1e5ee}', '\u{1e5ef}'),
                    ('\u{1e8d0}', '\u{1e8d6}'),
                    ('\u{1e944}', '\u{1e94a}'),
                    ('🏻', '🏿'),
                    ('\u{e0020}', '\u{e007f}'),
                    ('\u{e0100}', '\u{e01ef}'),
                ];

                pub const EXTENDNUMLET: &'static [(char, char)] = &[
                    ('_', '_'),
                    ('\u{202f}', '\u{202f}'),
                    ('‿', '⁀'),
                    ('⁔', '⁔'),
                    ('︳', '︴'),
                    ('﹍', '﹏'),
                    ('＿', '＿'),
                ];

                pub const FORMAT: &'static [(char, char)] = &[
                    ('\u{ad}', '\u{ad}'),
                    ('\u{61c}', '\u{61c}'),
                    ('\u{180e}', '\u{180e}'),
                    ('\u{200e}', '\u{200f}'),
                    ('\u{202a}', '\u{202e}'),
                    ('\u{2060}', '\u{2064}'),
                    ('\u{2066}', '\u{206f}'),
                    ('\u{feff}', '\u{feff}'),
                    ('\u{fff9}', '\u{fffb}'),
                    ('\u{13430}', '\u{1343f}'),
                    ('\u{1bca0}', '\u{1bca3}'),
                    ('\u{1d173}', '\u{1d17a}'),
                    ('\u{e0001}', '\u{e0001}'),
                ];

                pub const HEBREW_LETTER: &'static [(char, char)] = &[
                    ('א', 'ת'),
                    ('ׯ', 'ײ'),
                    ('יִ', 'יִ'),
                    ('ײַ', 'ﬨ'),
                    ('שׁ', 'זּ'),
                    ('טּ', 'לּ'),
                    ('מּ', 'מּ'),
                    ('נּ', 'סּ'),
                    ('ףּ', 'פּ'),
                    ('צּ', 'ﭏ'),
                ];

                pub const KATAKANA: &'static [(char, char)] = &[
                    ('〱', '〵'),
                    ('゛', '゜'),
                    ('゠', 'ヺ'),
                    ('ー', 'ヿ'),
                    ('ㇰ', 'ㇿ'),
                    ('㋐', '㋾'),
                    ('㌀', '㍗'),
                    ('ｦ', 'ﾝ'),
                    ('𚿰', '𚿳'),
                    ('𚿵', '𚿻'),
                    ('𚿽', '𚿾'),
                    ('𛀀', '𛀀'),
                    ('𛄠', '𛄢'),
                    ('𛅕', '𛅕'),
                    ('𛅤', '𛅧'),
                ];

                pub const LF: &'static [(char, char)] = &[('\n', '\n')];

                pub const MIDLETTER: &'static [(char, char)] = &[
                    (':', ':'),
                    ('·', '·'),
                    ('·', '·'),
                    ('՟', '՟'),
                    ('״', '״'),
                    ('‧', '‧'),
                    ('︓', '︓'),
                    ('﹕', '﹕'),
                    ('：', '：'),
                ];

                pub const MIDNUM: &'static [(char, char)] = &[
                    (',', ','),
                    (';', ';'),
                    (';', ';'),
                    ('։', '։'),
                    ('،', '؍'),
                    ('٬', '٬'),
                    ('߸', '߸'),
                    ('⁄', '⁄'),
                    ('﹐', '﹐'),
                    ('﹔', '﹔'),
                    ('，', '，'),
                    ('；', '；'),
                ];

                pub const MIDNUMLET: &'static [(char, char)] = &[
                    ('.', '.'),
                    ('‘', '’'),
                    ('․', '․'),
                    ('﹒', '﹒'),
                    ('＇', '＇'),
                    ('．', '．'),
                ];

                pub const NEWLINE: &'static [(char, char)] =
                    &[('\u{b}', '\u{c}'), ('\u{85}', '\u{85}'), ('\u{2028}', '\u{2029}')];

                pub const NUMERIC: &'static [(char, char)] = &
                [
                    ('0', '9'),
                    ('\u{600}', '\u{605}'),
                    ('٠', '٩'),
                    ('٫', '٫'),
                    ('\u{6dd}', '\u{6dd}'),
                    ('۰', '۹'),
                    ('߀', '߉'),
                    ('\u{890}', '\u{891}'),
                    ('\u{8e2}', '\u{8e2}'),
                    ('०', '९'),
                    ('০', '৯'),
                    ('੦', '੯'),
                    ('૦', '૯'),
                    ('୦', '୯'),
                    ('௦', '௯'),
                    ('౦', '౯'),
                    ('೦', '೯'),
                    ('൦', '൯'),
                    ('෦', '෯'),
                    ('๐', '๙'),
                    ('໐', '໙'),
                    ('༠', '༩'),
                    ('၀', '၉'),
                    ('႐', '႙'),
                    ('០', '៩'),
                    ('᠐', '᠙'),
                    ('᥆', '᥏'),
                    ('᧐', '᧚'),
                    ('᪀', '᪉'),
                    ('᪐', '᪙'),
                    ('᭐', '᭙'),
                    ('᮰', '᮹'),
                    ('᱀', '᱉'),
                    ('᱐', '᱙'),
                    ('꘠', '꘩'),
                    ('꣐', '꣙'),
                    ('꤀', '꤉'),
                    ('꧐', '꧙'),
                    ('꧰', '꧹'),
                    ('꩐', '꩙'),
                    ('꯰', '꯹'),
                    ('０', '９'),
                    ('𐒠', '𐒩'),
                    ('𐴰', '𐴹'),
                    ('𐵀', '𐵉'),
                    ('𑁦', '𑁯'),
                    ('\u{110bd}', '\u{110bd}'),
                    ('\u{110cd}', '\u{110cd}'),
                    ('𑃰', '𑃹'),
                    ('𑄶', '𑄿'),
                    ('𑇐', '𑇙'),
                    ('𑋰', '𑋹'),
                    ('𑑐', '𑑙'),
                    ('𑓐', '𑓙'),
                    ('𑙐', '𑙙'),
                    ('𑛀', '𑛉'),
                    ('𑛐', '𑛣'),
                    ('𑜰', '𑜹'),
                    ('𑣠', '𑣩'),
                    ('𑥐', '𑥙'),
                    ('𑯰', '𑯹'),
                    ('𑱐', '𑱙'),
                    ('𑵐', '𑵙'),
                    ('𑶠', '𑶩'),
                    ('𑽐', '𑽙'),
                    ('𖄰', '𖄹'),
                    ('𖩠', '𖩩'),
                    ('𖫀', '𖫉'),
                    ('𖭐', '𖭙'),
                    ('𖵰', '𖵹'),
                    ('𜳰', '𜳹'),
                    ('𝟎', '𝟿'),
                    ('𞅀', '𞅉'),
                    ('𞋰', '𞋹'),
                    ('𞓰', '𞓹'),
                    ('𞗱', '𞗺'),
                    ('𞥐', '𞥙'),
                    ('🯰', '🯹'),
                ];

                pub const REGIONAL_INDICATOR: &'static [(char, char)] = &[('🇦', '🇿')];

                pub const SINGLE_QUOTE: &'static [(char, char)] = &[('\'', '\'')];

                pub const WSEGSPACE: &'static [(char, char)] = &
                [
                    (' ', ' '),
                    ('\u{1680}', '\u{1680}'),
                    ('\u{2000}', '\u{2006}'),
                    ('\u{2008}', '\u{200a}'),
                    ('\u{205f}', '\u{205f}'),
                    ('\u{3000}', '\u{3000}'),
                ];

                pub const ZWJ: &'static [(char, char)] = &[('\u{200d}', '\u{200d}')];
            }

        }

        pub mod utf8
        {
            /*!
            Converts ranges of Unicode scalar values to equivalent ranges of UTF-8 bytes. */
            use ::
            {
                *,
            };
            /*
            use ::{char, fmt, iter::FusedIterator, slice};
            use ::{vec, vec::Vec};
            */
            const MAX_UTF8_BYTES: usize = 4;
            /// Utf8Sequence represents a sequence of byte ranges.
            #[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]
            pub enum Utf8Sequence
            {
                /// One byte range.
                One(Utf8Range),
                /// Two successive byte ranges.
                Two([Utf8Range; 2]),
                /// Three successive byte ranges.
                Three([Utf8Range; 3]),
                /// Four successive byte ranges.
                Four([Utf8Range; 4]),
            }

            impl Utf8Sequence
            {
                /// Creates a new UTF-8 sequence from the encoded bytes of a scalar value
                fn from_encoded_range(start: &[u8], end: &[u8]) -> Self {
                    assert_eq!(start.len(), end.len());
                    match start.len() {
                        2 => Utf8Sequence::Two([
                            Utf8Range::new(start[0], end[0]),
                            Utf8Range::new(start[1], end[1]),
                        ]),
                        3 => Utf8Sequence::Three([
                            Utf8Range::new(start[0], end[0]),
                            Utf8Range::new(start[1], end[1]),
                            Utf8Range::new(start[2], end[2]),
                        ]),
                        4 => Utf8Sequence::Four([
                            Utf8Range::new(start[0], end[0]),
                            Utf8Range::new(start[1], end[1]),
                            Utf8Range::new(start[2], end[2]),
                            Utf8Range::new(start[3], end[3]),
                        ]),
                        n => unreachable!("invalid encoded length: {}", n),
                    }
                }
                /// Returns the underlying sequence of byte ranges as a slice.
                pub fn as_slice(&self) -> &[Utf8Range] {
                    use self::Utf8Sequence::*;
                    match *self {
                        One(ref r) => slice::from_ref(r),
                        Two(ref r) => &r[..],
                        Three(ref r) => &r[..],
                        Four(ref r) => &r[..],
                    }
                }
                /// Returns the number of byte ranges in this sequence.
                pub fn len(&self) -> usize {
                    self.as_slice().len()
                }
                /// Reverses the ranges in this sequence.
                pub fn reverse(&mut self) {
                    match *self {
                        Utf8Sequence::One(_) => {}
                        Utf8Sequence::Two(ref mut x) => x.reverse(),
                        Utf8Sequence::Three(ref mut x) => x.reverse(),
                        Utf8Sequence::Four(ref mut x) => x.reverse(),
                    }
                }
                /// Returns true if and only if a prefix of `bytes` matches this sequence
                pub fn matches(&self, bytes: &[u8]) -> bool {
                    if bytes.len() < self.len() {
                        return false;
                    }
                    for (&b, r) in bytes.iter().zip(self) {
                        if !r.matches(b) {
                            return false;
                        }
                    }
                    true
                }
            }

            impl<'a> IntoIterator for &'a Utf8Sequence {
                type IntoIter = slice::Iter<'a, Utf8Range>;
                type Item = &'a Utf8Range;

                fn into_iter(self) -> Self::IntoIter {
                    self.as_slice().iter()
                }
            }

            impl fmt::Debug for Utf8Sequence
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    use self::Utf8Sequence::*;
                    match *self {
                        One(ref r) => write!(f, "{:?}", r),
                        Two(ref r) => write!(f, "{:?}{:?}", r[0], r[1]),
                        Three(ref r) => write!(f, "{:?}{:?}{:?}", r[0], r[1], r[2]),
                        Four(ref r) => {
                            write!(f, "{:?}{:?}{:?}{:?}", r[0], r[1], r[2], r[3])
                        }
                    }
                }
            }
            /// A single inclusive range of UTF-8 bytes.
            #[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]
            pub struct Utf8Range
            {
                /// Start of byte range (inclusive).
                pub start: u8,
                /// End of byte range (inclusive).
                pub end: u8,
            }

            impl Utf8Range
            {
                fn new(start: u8, end: u8) -> Self {
                    Utf8Range { start, end }
                }
                /// Returns true if and only if the given byte is in this range.
                pub fn matches(&self, b: u8) -> bool
                { self.start <= b && b <= self.end
                }
            }

            impl fmt::Debug for Utf8Range
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    if self.start == self.end {
                        write!(f, "[{:X}]", self.start)
                    } else {
                        write!(f, "[{:X}-{:X}]", self.start, self.end)
                    }
                }
            }
            /// An iterator over ranges of matching UTF-8 byte sequences.
            #[derive(Debug)]
            pub struct Utf8Sequences {
                range_stack: Vec<ScalarRange>,
            }

            impl Utf8Sequences
            {
                /// Create a new iterator over UTF-8 byte ranges for the scalar value range
                pub fn new(start: char, end: char) -> Self
                {
                    let range =
                        ScalarRange { start: u32::from(start), end: u32::from(end) };
                    Utf8Sequences { range_stack: vec![range] }
                }
                /// reset resets the scalar value range.
                #[doc(hidden)]
                pub fn reset(&mut self, start: char, end: char) {
                    self.range_stack.clear();
                    self.push(u32::from(start), u32::from(end));
                }

                fn push(&mut self, start: u32, end: u32) {
                    self.range_stack.push(ScalarRange { start, end });
                }
            }

            struct ScalarRange {
                start: u32,
                end: u32,
            }

            impl fmt::Debug for ScalarRange
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(f, "ScalarRange({:X}, {:X})", self.start, self.end)
                }
            }

            impl Iterator for Utf8Sequences {
                type Item = Utf8Sequence;

                fn next(&mut self) -> Option<Self::Item> {
                    'TOP: while let Some(mut r) = self.range_stack.pop() {
                        'INNER: loop {
                            if let Some((r1, r2)) = r.split() {
                                self.push(r2.start, r2.end);
                                r.start = r1.start;
                                r.end = r1.end;
                                continue 'INNER;
                            }
                            
                            if !r.is_valid() {
                                continue 'TOP;
                            }
                            
                            for i in 1..MAX_UTF8_BYTES {
                                let max = max_scalar_value(i);
                                
                                if r.start <= max && max < r.end {
                                    self.push(max + 1, r.end);
                                    r.end = max;
                                    continue 'INNER;
                                }
                            }
                            
                            if let Some(ascii_range) = r.as_ascii() {
                                return Some(Utf8Sequence::One(ascii_range));
                            }
                            
                            for i in 1..MAX_UTF8_BYTES {
                                let m = (1 << (6 * i)) - 1;
                                
                                if (r.start & !m) != (r.end & !m) {
                                    if (r.start & m) != 0 {
                                        self.push((r.start | m) + 1, r.end);
                                        r.end = r.start | m;
                                        continue 'INNER;
                                    }
                                    if (r.end & m) != m {
                                        self.push(r.end & !m, r.end);
                                        r.end = (r.end & !m) - 1;
                                        continue 'INNER;
                                    }
                                }
                            }

                            let mut start = [0; MAX_UTF8_BYTES];
                            let mut end = [0; MAX_UTF8_BYTES];
                            let n = r.encode(&mut start, &mut end);
                            
                            return Some(Utf8Sequence::from_encoded_range
                            (
                                &start[0..n],
                                &end[0..n],
                            ));
                        }
                    }
                    
                    None
                }
            }

            impl FusedIterator for Utf8Sequences {}

            impl ScalarRange
            {
                /// split splits this range if it overlaps with a surrogate codepoint.
                fn split(&self) -> Option<(ScalarRange, ScalarRange)>
                {
                    if self.start < 0xE000 && self.end > 0xD7FF
                    {
                        Some((
                            ScalarRange { start: self.start, end: 0xD7FF },
                            ScalarRange { start: 0xE000, end: self.end },
                        ))
                    }
                    
                    else { None }
                }
                /// is_valid returns true if and only if start <= end.
                fn is_valid(&self) -> bool
                { self.start <= self.end
                }
                /// as_ascii returns this range as a Utf8Range if and only if all scalar
                fn as_ascii(&self) -> Option<Utf8Range>
                {
                    if self.is_ascii()
                    {
                        let start = u8::try_from(self.start).unwrap();
                        let end = u8::try_from(self.end).unwrap();
                        Some(Utf8Range::new(start, end))
                    }
                    
                    else { None }
                }
                /// is_ascii returns true if the range is ASCII only (i.e., takes a single
                fn is_ascii(&self) -> bool { self.is_valid() && self.end <= 0x7f }
                /// encode writes the UTF-8 encoding of the start and end of this range
                fn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize
                {
                    let cs = char::from_u32(self.start).unwrap();
                    let ce = char::from_u32(self.end).unwrap();
                    let ss = cs.encode_utf8(start);
                    let se = ce.encode_utf8(end);
                    assert_eq!(ss.len(), se.len());
                    ss.len()
                }
            }

            fn max_scalar_value(nbytes: usize) -> u32
            {
                match nbytes 
                {
                    1 => 0x007F,
                    2 => 0x07FF,
                    3 => 0xFFFF,
                    4 => 0x0010_FFFF,
                    _ => unreachable!("invalid UTF-8 byte sequence size"),
                }
            }
        }
        /// Escapes all regular expression meta characters in `text`.
        pub fn escape(text: &str) -> String
        {
            let mut quoted = String::new();
            escape_into(text, &mut quoted);
            quoted
        }
        /// Escapes all meta characters in `text` and writes the result into `buf`.
        pub fn escape_into(text: &str, buf: &mut String)
        {
            buf.reserve(text.len());

            for c in text.chars()
            {
                if is_meta_character(c) { buf.push('\\'); }

                buf.push(c);
            }
        }
    }
    /// Escapes all regular expression meta characters in `pattern`.
    pub fn escape(pattern: &str) -> ::string::String
    {
        ::regex::syntax::escape(pattern)
    }
	
	pub fn find_first_group(ptn: &str, text: &str) -> Option<String>
	{
		let re = match regex::Regex::new(ptn)
        {
			Ok(x) => x,
			Err(_) => return None,
		};
		match re.captures(text) {
			Some(caps) => {
				if let Some(x) = caps.get(1) {
					return Some(x.as_str().to_owned());
				}
			}
			None => {
				return None;
			}
		}
		None
	}

	pub fn contains(text: &str, ptn: &str) -> bool 
	{
		let re = match regex::Regex::new(ptn)
        {
			Ok(x) => x,
			Err(e) => {
				println!("Regex new error: {:?}", e);
				return false;
			}
		};
		re.is_match(text)
	}

	pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String 
	{
		let re = regex::Regex::new(ptn).unwrap();
		let result = re.replace_all(text, ptn_to);
		result.to_string()
	}
}

pub mod scripts
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use std::fs::File;
	use std::io::{ErrorKind, Read, Write};
	use std::path::Path;

	use pest::iterators::Pair;
	use regex::{Regex, RegexBuilder};

	use ::now;
	use crate::libs;
	use crate::parsers;
	use crate::shell;
	use crate::types;
	use crate::types::CommandResult;
	*/
	pub fn run_script(sh: &mut shell::Shell, args: &Vec<String>) -> i32
	{
		let src_file = &args[1];
		let full_src_file: String;
		if src_file.contains('/') {
			full_src_file = src_file.clone();
		} else {
			let full_path = libs::path::find_file_in_path(src_file, false);
			if full_path.is_empty() {
				// not in PATH and not in current work directory
				if !Path::new(src_file).exists() {
					println_stderr!("cicada: {}: no such file", src_file);
					return 1;
				}
				full_src_file = format!("./{}", src_file);
			} else {
				full_src_file = full_path.clone();
			}
		}

		if !Path::new(&full_src_file).exists() {
			println_stderr!("cicada: {}: no such file", src_file);
			return 1;
		}
		if Path::new(&full_src_file).is_dir() {
			println_stderr!("cicada: {}: is a directory", src_file);
			return 1;
		}

		let mut file;
		match File::open(&full_src_file)
        {
			Ok(x) => file = x,
			Err(e) => {
				println_stderr!(
					"cicada: {}: failed to open file - {:?}",
					&full_src_file,
					e.kind()
				);
				return 1;
			}
		}
		let mut text = String::new();
		match file.read_to_string(&mut text)
        {
			Ok(_) => {}
			Err(e) => {
				match e.kind() {
					ErrorKind::InvalidData => {
						println_stderr!("cicada: {}: not a valid script file", &full_src_file);
					}
					_ => {
						println_stderr!("cicada: {}: error: {:?}", &full_src_file, e);
					}
				}
				return 1;
			}
		}

		if text.contains("\\\n")
        {
			let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#)
				.multi_line(true)
				.build()
				.unwrap();
			text = re.replace_all(&text, " ").to_string();

			let re = RegexBuilder::new(r#"\\\n"#)
				.multi_line(true)
				.build()
				.unwrap();
			text = re.replace_all(&text, "").to_string();
		}

		let re_func_head =
			Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
		let re_func_tail = Regex::new(r"^\}$").unwrap();
		let mut text_new = String::new();
		let mut enter_func = false;
		let mut func_name = String::new();
		let mut func_body = String::new();
		for line in text.clone().lines() {
			if re_func_head.is_match(line.trim()) {
				enter_func = true;
				let cap = re_func_head.captures(line.trim()).unwrap();
				func_name = cap[1].to_string();
				func_body = String::new();
				continue;
			}
			if re_func_tail.is_match(line.trim()) {
				sh.set_func(&func_name, &func_body);
				enter_func = false;
				continue;
			}
			if enter_func {
				func_body.push_str(line);
				func_body.push('\n');
			} else {
				text_new.push_str(line);
				text_new.push('\n');
			}
		}

		let mut status = 0;
		let cr_list = run_lines(sh, &text_new, args, false);
		if let Some(last) = cr_list.last() {
			status = last.status;
		}

		// FIXME: We probably need to fix the issue in the `set` builtin,
		// which currently set `exit_on_error` at the shell session level,
		// we should instead set in a script-level.
		// Here is a work-around ugly fix.
		sh.exit_on_error = false;

		status
	}

	pub fn run_lines(
		sh: &mut shell::Shell,
		lines: &str,
		args: &Vec<String>,
		capture: bool,
	) -> Vec<CommandResult>
    {
		let mut cr_list = Vec::new();
		match parsers::locust::parse_lines(lines)
        {
			Ok(pairs_exp) => {
				for pair in pairs_exp {
					let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, false, capture);
					cr_list.append(&mut _cr_list);
				}
			}
			Err(e) => {
				println_stderr!("syntax error: {:?}", e);
				return cr_list;
			}
		}
		cr_list
	}

	fn expand_args(line: &str, args: &[String]) -> String
    {
		let linfo = parsers::line::parse_line(line);
		let mut tokens = linfo.tokens;
		expand_args_in_tokens(&mut tokens, args);
		parsers::line::tokens_to_line(&tokens)
	}

	fn expand_line_to_toknes(line: &str, args: &[String], sh: &mut shell::Shell) -> types::Tokens
    {
		let linfo = parsers::line::parse_line(line);
		let mut tokens = linfo.tokens;
		expand_args_in_tokens(&mut tokens, args);
		shell::do_expansion(sh, &mut tokens);
		tokens
	}

	fn expand_args_for_single_token(token: &str, args: &[String]) -> String
    {
		let re = Regex::new(r"^(.*?)\$\{?([0-9]+|@)\}?(.*)$").unwrap();
		if !re.is_match(token) {
			return token.to_string();
		}

		let mut result = String::new();
		let mut _token = token.to_string();
		let mut _head = String::new();
		let mut _output = String::new();
		let mut _tail = String::new();
		loop {
			if !re.is_match(&_token) {
				if !_token.is_empty() {
					result.push_str(&_token);
				}
				break;
			}
			for cap in re.captures_iter(&_token) {
				_head = cap[1].to_string();
				_tail = cap[3].to_string();
				let _key = cap[2].to_string();
				if _key == "@" {
					result.push_str(format!("{}{}", _head, args[1..].join(" ")).as_str());
				} else if let Ok(arg_idx) = _key.parse::<usize>() {
					if arg_idx < args.len() {
						result.push_str(format!("{}{}", _head, args[arg_idx]).as_str());
					} else {
						result.push_str(&_head);
					}
				} else {
					result.push_str(&_head);
				}
			}

			if _tail.is_empty() {
				break;
			}
			_token = _tail.clone();
		}
		result
	}

	fn expand_args_in_tokens(tokens: &mut types::Tokens, args: &[String])
    {
		let mut idx: usize = 0;
		let mut buff = Vec::new();

		for (sep, token) in tokens.iter() {
			if sep == "`" || sep == "'" || !is_args_in_token(token) {
				idx += 1;
				continue;
			}

			let _token = expand_args_for_single_token(token, args);
			buff.push((idx, _token));
			idx += 1;
		}

		for (i, text) in buff.iter().rev() {
			tokens[*i].1 = text.to_string();
		}
	}

	fn run_exp_test_br(
		sh: &mut shell::Shell,
		pair_br: Pair<parsers::rules::Rule>,
		args: &Vec<String>,
		in_loop: bool,
		capture: bool,
	) -> (Vec<CommandResult>, bool, bool, bool)
    {
		let mut cr_list = Vec::new();
		let pairs = pair_br.into_inner();
		let mut test_pass = false;
		for pair in pairs {
			let rule = pair.as_rule();
			if rule == parsers::rules::Rule::IF_HEAD
				|| rule == parsers::rules::Rule::IF_ELSEIF_HEAD
				|| rule == parsers::rules::Rule::WHILE_HEAD
			{
				let pairs_test: Vec<Pair<parsers::rules::Rule>> = pair.into_inner().collect();
				let pair_test = &pairs_test[0];
				let line = pair_test.as_str().trim();
				let line_new = expand_args(line, &args[1..]);
				let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
				if let Some(last) = _cr_list.last() {
					if last.status == 0 {
						test_pass = true;
					}
				}
				continue;
			}

			if rule == parsers::rules::Rule::KW_ELSE {
				test_pass = true;
				continue;
			}

			if rule == parsers::rules::Rule::EXP_BODY {
				if !test_pass {
					return (cr_list, false, false, false);
				}
				let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, in_loop, capture);
				cr_list.append(&mut _cr_list);
				// branch executed successfully
				return (cr_list, true, _cont, _brk);
			}

			unreachable!();
		}
		(cr_list, test_pass, false, false)
	}

	fn run_exp_if(
		sh: &mut shell::Shell,
		pair_if: Pair<parsers::rules::Rule>,
		args: &Vec<String>,
		in_loop: bool,
		capture: bool,
	) -> (Vec<CommandResult>, bool, bool)
    {
		let mut cr_list = Vec::new();
		let pairs = pair_if.into_inner();
		let mut met_continue = false;
		let mut met_break = false;
		for pair in pairs {
			let (mut _cr_list, passed, _cont, _brk) =
				run_exp_test_br(sh, pair, args, in_loop, capture);
			met_continue = _cont;
			met_break = _brk;
			cr_list.append(&mut _cr_list);
			// break at first successful branch
			if passed {
				break;
			}
		}
		(cr_list, met_continue, met_break)
	}

	fn get_for_result_from_init(
		sh: &mut shell::Shell,
		pair_init: Pair<parsers::rules::Rule>,
		args: &[String],
	) -> Vec<String>
    {
		let mut result: Vec<String> = Vec::new();
		let pairs = pair_init.into_inner();
		for pair in pairs {
			let rule = pair.as_rule();
			if rule == parsers::rules::Rule::TEST {
				let line = pair.as_str().trim();
				let tokens = expand_line_to_toknes(line, &args[1..], sh);
				for (sep, token) in tokens {
					if sep.is_empty() {
						for x in token.split_whitespace() {
							result.push(x.to_string());
						}
					} else {
						result.push(token.clone());
					}
				}
			}
		}
		result
	}

	fn get_for_result_list
    (
		sh: &mut shell::Shell,
		pair_head: Pair<parsers::rules::Rule>,
		args: &[String],
	) -> Vec<String>
    {
		let pairs = pair_head.into_inner();
		for pair in pairs {
			let rule = pair.as_rule();
			if rule == parsers::rules::Rule::FOR_INIT {
				return get_for_result_from_init(sh, pair, args);
			}
		}
		Vec::new()
	}
    
	fn get_for_var_name(pair_head: Pair<parsers::rules::Rule>) -> String
    {
        /*
		let pairs = pair_head.into_inner();
		for pair in pairs {
			let rule = pair.as_rule();
			if rule == parsers::rules::Rule::FOR_INIT {
				let pairs_init = pair.into_inner();
				for pair_init in pairs_init {
					let rule_init = pair_init.as_rule();
					if rule_init == parsers::rules::Rule::FOR_VAR {
						let line = pair_init.as_str().trim();
						return line.to_string();
					}
				}
			}
		}*/
		String::new()
	}
    
	fn run_exp_for
    (
		sh: &mut shell::Shell,
		pair_for: Pair<parsers::rules::Rule>,
		args: &Vec<String>,
		capture: bool,
	) -> Vec<CommandResult>
    {
		let mut cr_list = Vec::new();
        /*
		let pairs = pair_for.into_inner();
		let mut result_list: Vec<String> = Vec::new();
		let mut var_name: String = String::new();
		for pair in pairs 
        {
			let rule = pair.as_rule();
            
			if rule == parsers::rules::Rule::FOR_HEAD {
				var_name = get_for_var_name(pair.clone());
				result_list = get_for_result_list(sh, pair.clone(), args);
				continue;
			}
			if rule == parsers::rules::Rule::EXP_BODY {
				for value in &result_list {
					sh.set_env(&var_name, value);
					let (mut _cr_list, _cont, _brk) = run_exp(sh, pair.clone(), args, true, capture);
					cr_list.append(&mut _cr_list);
					if _brk {
						break;
					}
				}
			}
		}*/
		cr_list
	}
    
	fn run_exp_while
    (
		sh: &mut shell::Shell,
		pair_while: Pair<parsers::rules::Rule>,
		args: &Vec<String>,
		capture: bool,
	) -> Vec<CommandResult>
    {
		let mut cr_list = Vec::new();
        /*
		loop {
			let (mut _cr_list, passed, _cont, _brk) =
				run_exp_test_br(sh, pair_while.clone(), args, true, capture);
			cr_list.append(&mut _cr_list);
			if !passed || _brk {
				break;
			}
		}*/
		cr_list
	}
    
	fn run_exp
    (
		sh: &mut shell::Shell,
		pair_in: Pair<parsers::rules::Rule>,
		args: &Vec<String>,
		in_loop: bool,
		capture: bool,
	) -> (Vec<CommandResult>, bool, bool)
    {
		let mut cr_list = Vec::new();
        /*
		let pairs = pair_in.into_inner();
		for pair in pairs {
			let line = pair.as_str().trim();
			if line.is_empty() {
				continue;
			}

			let rule = pair.as_rule();
			if rule == parsers::rules::Rule::CMD {
				if line == "continue" {
					if in_loop {
						return (cr_list, true, false);
					} else {
						println_stderr!("cicada: continue: only meaningful in loops");
						continue;
					}
				}
				if line == "break" {
					if in_loop {
						return (cr_list, false, true);
					} else {
						println_stderr!("cicada: break: only meaningful in loops");
						continue;
					}
				}

				let line_new = expand_args(line, &args[1..]);
				let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
				cr_list.append(&mut _cr_list);
				if let Some(last) = cr_list.last() {
					let status = last.status;
					if status != 0 && sh.exit_on_error {
						return (cr_list, false, false);
					}
				}
			} else if rule == parsers::rules::Rule::EXP_IF {
				let (mut _cr_list, _cont, _brk) = run_exp_if(sh, pair, args, in_loop, capture);
				cr_list.append(&mut _cr_list);
				if _cont {
					return (cr_list, true, false);
				}
				if _brk {
					return (cr_list, false, true);
				}
			} else if rule == parsers::rules::Rule::EXP_FOR {
				let mut _cr_list = run_exp_for(sh, pair, args, capture);
				cr_list.append(&mut _cr_list);
			} else if rule == parsers::rules::Rule::EXP_WHILE {
				let mut _cr_list = run_exp_while(sh, pair, args, capture);
				cr_list.append(&mut _cr_list);
			}
		}*/
		(cr_list, false, false)
	}
}

pub mod shell
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use errno::errno;
	use std::collections::{HashMap, HashSet};
	use std::env;
	use std::io::Write;
	use std::mem;

	use regex::Regex;
	use uuid::Uuid;

	use crate::core;
	use crate::libs;
	use crate::parsers;
	use crate::tools;
	use crate::types::{self, CommandLine};
	*/
	#[derive(Debug, Clone)]
	pub struct Shell 
	{
		pub jobs: HashMap<i32, types::Job>,
		pub aliases: HashMap<String, String>,
		pub envs: HashMap<String, String>,
		pub funcs: HashMap<String, String>,
		pub cmd: String,
		pub current_dir: String,
		pub previous_dir: String,
		pub previous_cmd: String,
		pub previous_status: i32,
		pub is_login: bool,
		pub exit_on_error: bool,
		pub has_terminal: bool,
		pub session_id: String,
	}

	impl Shell {
		pub fn new() -> Shell {
			let uuid = Uuid::new_v4().as_hyphenated().to_string();
			let current_dir = tools::get_current_dir();
			// TODO: the shell proc may have terminal later
			// e.g. $ cicada foo.sh &
			// then with a $ fg
			let has_terminal = proc_has_terminal();
			let (session_id, _) = uuid.split_at(13);
			Shell {
				jobs: HashMap::new(),
				aliases: HashMap::new(),
				envs: HashMap::new(),
				funcs: HashMap::new(),
				cmd: String::new(),
				current_dir: current_dir.clone(),
				previous_dir: String::new(),
				previous_cmd: String::new(),
				previous_status: 0,
				is_login: false,
				exit_on_error: false,
				has_terminal,
				session_id: session_id.to_string(),
			}
		}

		pub fn insert_job(&mut self, gid: i32, pid: i32, cmd: &str, status: &str, bg: bool)
        {
			let mut i = 1;
			loop {
				let mut indexed_job_missing = false;
				if let Some(x) = self.jobs.get_mut(&i) {
					if x.gid == gid {
						x.pids.push(pid);
						x.cmd = format!("{} | {}", x.cmd, cmd);
						return;
					}
				} else {
					indexed_job_missing = true;
				}

				if indexed_job_missing {
					self.jobs.insert(
						i,
						types::Job {
							cmd: cmd.to_string(),
							id: i,
							gid,
							pids: vec![pid],
							pids_stopped: HashSet::new(),
							status: status.to_string(),
							is_bg: bg,
						},
					);
					return;
				}
				i += 1;
			}
		}

		pub fn get_job_by_id(&self, job_id: i32) -> Option<&types::Job> {
			self.jobs.get(&job_id)
		}

		pub fn mark_job_member_continued(&mut self, pid: i32, gid: i32) -> Option<&types::Job>
        {
			if self.jobs.is_empty() {
				return None;
			}
			let mut i = 1;
			let mut idx_found = 0;
			loop {
				if let Some(job) = self.jobs.get_mut(&i) {
					if job.gid == gid {
						job.pids_stopped.remove(&pid);
						idx_found = i;
						break;
					}
				}

				i += 1;
				if i >= 65535 {
					break;
				}
			}

			self.jobs.get(&idx_found)
		}

		pub fn mark_job_member_stopped(&mut self, pid: i32, gid: i32) -> Option<&types::Job>
        {
			if self.jobs.is_empty() {
				return None;
			}
			let mut i = 1;
			let mut idx_found = 0;
			loop {
				if let Some(job) = self.jobs.get_mut(&i) {
					if job.gid == gid {
						job.pids_stopped.insert(pid);
						idx_found = i;
						break;
					}
				}

				i += 1;
				if i >= 65535 {
					break;
				}
			}

			self.jobs.get(&idx_found)
		}

		pub fn get_job_by_gid(&self, gid: i32) -> Option<&types::Job>
        {
			if self.jobs.is_empty() {
				return None;
			}

			let mut i = 1;
			loop {
				if let Some(x) = self.jobs.get(&i) {
					if x.gid == gid {
						return Some(x);
					}
				}

				i += 1;
				if i >= 65535 {
					break;
				}
			}
			None
		}

		pub fn mark_job_as_running(&mut self, gid: i32, bg: bool) {
			if self.jobs.is_empty() {
				return;
			}

			let mut i = 1;
			loop {
				if let Some(job) = self.jobs.get_mut(&i) {
					if job.gid == gid {
						job.status = "Running".to_string();
						job.pids_stopped.clear();
						job.is_bg = bg;
						return;
					}
				}

				i += 1;
				if i >= 65535 {
					break;
				}
			}
		}

		pub fn mark_job_as_stopped(&mut self, gid: i32) {
			if self.jobs.is_empty() {
				return;
			}

			let mut i = 1;
			loop {
				if let Some(x) = self.jobs.get_mut(&i) {
					if x.gid == gid {
						x.status = "Stopped".to_string();
						x.is_bg = true;
						return;
					}
				}

				i += 1;
				if i >= 65535 {
					break;
				}
			}
		}

		pub fn remove_pid_from_job(&mut self, gid: i32, pid: i32) -> Option<types::Job>
        {
			if self.jobs.is_empty() {
				return None;
			}

			let mut empty_pids = false;
			let mut i = 1;
			loop {
				if let Some(x) = self.jobs.get_mut(&i) {
					if x.gid == gid {
						if let Ok(i_pid) = x.pids.binary_search(&pid) {
							x.pids.remove(i_pid);
						}
						empty_pids = x.pids.is_empty();
						break;
					}
				}

				i += 1;
				if i >= 65535 {
					break;
				}
			}

			if empty_pids {
				return self.jobs.remove(&i);
			}
			None
		}
		/// Update existing *ENV Variable* if such name exists in ENVs,
		/// otherwise, we define a local *Shell Variable*, which would not
		/// be exported into child processes.
		pub fn set_env(&mut self, name: &str, value: &str) {
			if env::var(name).is_ok() {
				env::set_var(name, value);
			} else {
				self.envs.insert(name.to_string(), value.to_string());
			}
		}
		/// get *Shell Variable*, or *ENV Variable*.
		pub fn get_env(&self, name: &str) -> Option<String> {
			match self.envs.get(name) {
				Some(x) => Some(x.to_string()),
				None => env::var(name).ok(),
			}
		}
		/// Remove environment variable, function from the environment of
		/// the currently running process
		pub fn remove_env(&mut self, name: &str) -> bool {
			// function names can contain the `-` char.
			let ptn_env = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_-]*$").unwrap();
			if !ptn_env.is_match(name) {
				return false;
			}

			env::remove_var(name);
			self.envs.remove(name);
			self.remove_func(name);
			true
		}

		pub fn remove_path(&mut self, path: &str) {
			if let Ok(paths) = env::var("PATH") {
				let mut paths_new: Vec<&str> = paths.split(":").collect();
				paths_new.retain(|&x| x != path);
				env::set_var("PATH", paths_new.join(":").as_str());
			}
		}

		fn remove_func(&mut self, name: &str) {
			self.funcs.remove(name);
		}

		pub fn set_func(&mut self, name: &str, value: &str) {
			self.funcs.insert(name.to_string(), value.to_string());
		}

		pub fn get_func(&self, name: &str) -> Option<String> {
			self.funcs.get(name).map(|x| x.to_string())
		}

		pub fn get_alias_list(&self) -> Vec<(String, String)>
        {
			let mut result = Vec::new();
			for (name, value) in &self.aliases {
				result.push((name.clone(), value.clone()));
			}
			result
		}

		pub fn add_alias(&mut self, name: &str, value: &str) {
			self.aliases.insert(name.to_string(), value.to_string());
		}

		pub fn is_alias(&self, name: &str) -> bool {
			self.aliases.contains_key(name)
		}

		pub fn remove_alias(&mut self, name: &str) -> bool {
			let opt = self.aliases.remove(name);
			opt.is_some()
		}

		pub fn get_alias_content(&self, name: &str) -> Option<String>
        {
			let result = match self.aliases.get(name) {
				Some(x) => x.to_string(),
				None => String::new(),
			};
			if result.is_empty() {
				None
			} else {
				Some(result)
			}
		}
	}

	pub unsafe fn give_terminal_to(gid: i32) -> bool
    {
		let mut mask: libc::sigset_t = mem::zeroed();
		let mut old_mask: libc::sigset_t = mem::zeroed();

		libc::sigemptyset(&mut mask);
		libc::sigaddset(&mut mask, libc::SIGTSTP);
		libc::sigaddset(&mut mask, libc::SIGTTIN);
		libc::sigaddset(&mut mask, libc::SIGTTOU);
		libc::sigaddset(&mut mask, libc::SIGCHLD);

		let rcode = libc::pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
		if rcode != 0 {
			log!("failed to call pthread_sigmask");
		}
		let rcode = libc::tcsetpgrp(1, gid);
		let given;
		if rcode == -1 {
			given = false;
			let e = errno();
			let code = e.0;
			log!("error in give_terminal_to() {}: {}", code, e);
		} else {
			given = true;
		}
		let rcode = libc::pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
		if rcode != 0 {
			log!("failed to call pthread_sigmask");
		}
		given
	}

	fn needs_globbing(line: &str) -> bool
    {
		let re = Regex::new(r"\*+").expect("Invalid regex ptn");
		re.is_match(line)
	}

	pub fn expand_glob(tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff = Vec::new();
		for (sep, text) in tokens.iter() {
			if !sep.is_empty() || !needs_globbing(text) {
				idx += 1;
				continue;
			}

			let mut result: Vec<String> = Vec::new();
			let item = text.as_str();

			if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"') {
				result.push(item.to_string());
			} else {
				let _basename = libs::path::basename(item);
				let show_hidden = _basename.starts_with(".*");

				match glob::glob(item) {
					Ok(paths) => {
						let mut is_empty = true;
						for entry in paths {
							match entry {
								Ok(path) => {
									let file_path = path.to_string_lossy();
									let _basename = libs::path::basename(&file_path);
									if _basename == ".." || _basename == "." {
										continue;
									}
									if _basename.starts_with('.') && !show_hidden {
										// skip hidden files, you may need to
										// type `ls .*rc` instead of `ls *rc`
										continue;
									}
									result.push(file_path.to_string());
									is_empty = false;
								}
								Err(e) => {
									log!("glob error: {:?}", e);
								}
							}
						}
						if is_empty {
							result.push(item.to_string());
						}
					}
					Err(e) => {
						println!("glob error: {:?}", e);
						result.push(item.to_string());
						return;
					}
				}
			}

			buff.push((idx, result));
			idx += 1;
		}

		for (i, result) in buff.iter().rev() {
			tokens.remove(*i);
			for (j, token) in result.iter().enumerate() {
				let sep = if token.contains(' ') { "\"" } else { "" };
				tokens.insert(*i + j, (sep.to_string(), token.clone()));
			}
		}
	}

	fn expand_one_env(sh: &Shell, token: &str) -> String {
		// do not combine these two into one: `\{?..\}?`,
		// otherwize `}` in `{print $NF}` would gone.
		let re1 = Regex::new(r"^(.*?)\$([A-Za-z0-9_]+|\$|\?)(.*)$").unwrap();
		let re2 = Regex::new(r"(.*?)\$\{([A-Za-z0-9_]+|\$|\?)\}(.*)$").unwrap();
		if !re1.is_match(token) && !re2.is_match(token) {
			return token.to_string();
		}

		let mut result = String::new();
		let match_re1 = re1.is_match(token);
		let match_re2 = re2.is_match(token);
		if !match_re1 && !match_re2 {
			return token.to_string();
		}

		let cap_results = if match_re1 {
			re1.captures_iter(token)
		} else {
			re2.captures_iter(token)
		};

		for cap in cap_results {
			let head = cap[1].to_string();
			let tail = cap[3].to_string();
			let key = cap[2].to_string();
			if key == "?" {
				result.push_str(format!("{}{}", head, sh.previous_status).as_str());
			} else if key == "$" {
				unsafe {
					let val = libc::getpid();
					result.push_str(format!("{}{}", head, val).as_str());
				}
			} else if let Ok(val) = env::var(&key) {
				result.push_str(format!("{}{}", head, val).as_str());
			} else if let Some(val) = sh.get_env(&key) {
				result.push_str(format!("{}{}", head, val).as_str());
			} else {
				result.push_str(&head);
			}
			result.push_str(&tail);
		}

		result
	}

	fn need_expand_brace(line: &str) -> bool {
		::regex::contains(line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"#)
	}

	fn brace_getitem(s: &str, depth: i32) -> (Vec<String>, String)
    {
		let mut out: Vec<String> = vec![String::new()];
		let mut ss = s.to_string();
		let mut tmp;
		while !ss.is_empty()
        {
			let c = match ss.chars().next() {
				Some(x) => x,
				None => {
					return (out, ss);
				}
			};
			if depth > 0 && (c == ',' || c == '}') {
				return (out, ss);
			}
			if c == '{' {
				let mut sss = ss.clone();
				sss.remove(0);
				let result_groups = brace_getgroup(&sss, depth + 1);
				if let Some((out_group, s_group)) = result_groups {
					let mut tmp_out = Vec::new();
					for x in out.iter() {
						for y in out_group.iter() {
							let item = format!("{}{}", x, y);
							tmp_out.push(item);
						}
					}
					out = tmp_out;
					ss = s_group.clone();
					continue;
				}
			}
			// FIXME: here we mean more than one char.
			if c == '\\' && ss.len() > 1 {
				ss.remove(0);

				let c = match ss.chars().next() {
					Some(x) => x,
					None => return (out, ss),
				};

				tmp = format!("\\{}", c);
			} else {
				tmp = c.to_string();
			}
			let mut result = Vec::new();
			for x in out.iter() {
				let item = format!("{}{}", x, tmp);
				result.push(item);
			}
			out = result;
			ss.remove(0);
		}
		(out, ss)
	}

	fn brace_getgroup(s: &str, depth: i32) -> Option<(Vec<String>, String)>
    {
		let mut out: Vec<String> = Vec::new();
		let mut comma = false;
		let mut ss = s.to_string();
		while !ss.is_empty()
        {
			let (g, sss) = brace_getitem(ss.as_str(), depth);
			ss = sss.clone();
			if ss.is_empty() {
				break;
			}
			for x in g.iter() {
				out.push(x.clone());
			}

			let c = match ss.chars().next() {
				Some(x) => x,
				None => {
					break;
				}
			};
			if c == '}' {
				let mut sss = ss.clone();
				sss.remove(0);
				if comma {
					return Some((out, sss));
				}
				let mut result = Vec::new();
				for x in out.iter() {
					let item = format!("{{{}}}", x);
					result.push(item);
				}
				return Some((result, ss));
			}
			if c == ',' {
				comma = true;
				ss.remove(0);
			}
		}

		None
	}

	fn expand_brace(tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff = Vec::new();
		for (sep, token) in tokens.iter() {
			if !sep.is_empty() || !need_expand_brace(token) {
				idx += 1;
				continue;
			}

			let mut result: Vec<String> = Vec::new();
			let items = brace_getitem(token, 0);
			for x in items.0 {
				result.push(x.clone());
			}
			buff.push((idx, result));
			idx += 1;
		}

		for (i, items) in buff.iter().rev() {
			tokens.remove(*i);
			for (j, token) in items.iter().enumerate() {
				let sep = if token.contains(' ') { "\"" } else { "" };
				tokens.insert(*i + j, (sep.to_string(), token.clone()));
			}
		}
	}

	fn expand_brace_range(tokens: &mut types::Tokens)
    {
		let re;
		if let Ok(x) = Regex::new(r#"\{(-?[0-9]+)\.\.(-?[0-9]+)(\.\.)?([0-9]+)?\}"#) {
			re = x;
		} else {
			println_stderr!("cicada: re new error");
			return;
		}

		let mut idx: usize = 0;
		let mut buff: Vec<(usize, Vec<String>)> = Vec::new();
		for (sep, token) in tokens.iter() {
			if !sep.is_empty() || !re.is_match(token) {
				idx += 1;
				continue;
			}

			// safe to unwrap here, since the `is_match` above already validated
			let caps = re.captures(token).unwrap();

			let start = match caps[1].to_string().parse::<i32>()
            {
				Ok(x) => x,
				Err(e) => {
					println_stderr!("cicada: {}", e);
					return;
				}
			};

			let end = match caps[2].to_string().parse::<i32>()
            {
				Ok(x) => x,
				Err(e) => {
					println_stderr!("cicada: {}", e);
					return;
				}
			};

			// incr is always positive
			let mut incr = if caps.get(4).is_none() {
				1
			} else {
				match caps[4].to_string().parse::<i32>() {
					Ok(x) => x,
					Err(e) => {
						println_stderr!("cicada: {}", e);
						return;
					}
				}
			};
			if incr <= 1 {
				incr = 1;
			}

			let mut result: Vec<String> = Vec::new();
			let mut n = start;
			if start > end {
				while n >= end {
					result.push(format!("{}", n));
					n -= incr;
				}
			} else {
				while n <= end {
					result.push(format!("{}", n));
					n += incr;
				}
			}

			buff.push((idx, result));
			idx += 1;
		}

		for (i, items) in buff.iter().rev() {
			tokens.remove(*i);
			for (j, token) in items.iter().enumerate() {
				let sep = if token.contains(' ') { "\"" } else { "" };
				tokens.insert(*i + j, (sep.to_string(), token.clone()));
			}
		}
	}

	fn expand_alias(sh: &Shell, tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff = Vec::new();
		let mut is_head = true;
		for (sep, text) in tokens.iter() {
			if sep.is_empty() && text == "|" {
				is_head = true;
				idx += 1;
				continue;
			}
			if is_head && text == "xargs" {
				idx += 1;
				continue;
			}

			if !is_head || !sh.is_alias(text) {
				idx += 1;
				is_head = false;
				continue;
			}

			if let Some(value) = sh.get_alias_content(text) {
				buff.push((idx, value.clone()));
			}

			idx += 1;
			is_head = false;
		}

		for (i, text) in buff.iter().rev()
        {
			let linfo = parsers::line::parse_line(text);
			let tokens_ = linfo.tokens;
			tokens.remove(*i);
			for item in tokens_.iter().rev() {
				tokens.insert(*i, item.clone());
			}
		}
	}

	fn expand_home(tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff = Vec::new();
		for (sep, text) in tokens.iter() {
			if !sep.is_empty() || !text.starts_with("~") {
				idx += 1;
				continue;
			}

			let mut s: String = text.clone();
			let ptn = r"^~(?P<tail>.*)";
			let re = Regex::new(ptn).expect("invalid re ptn");
			let home = tools::get_user_home();
			let ss = s.clone();
			let to = format!("{}$tail", home);
			let result = re.replace_all(ss.as_str(), to.as_str());
			s = result.to_string();

			buff.push((idx, s.clone()));
			idx += 1;
		}

		for (i, text) in buff.iter().rev() {
			tokens[*i].1 = text.to_string();
		}
	}

	fn env_in_token(token: &str) -> bool {
		if ::regex::contains(token, r"\$\{?[\$\?]\}?") {
			return true;
		}

		let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
		let ptn_env = format!(r"\$\{{?{}\}}?", ptn_env_name);
		if !::regex::contains(token, &ptn_env) {
			return false;
		}

		// do not expand env in a command substitution, e.g.:
		// - echo $(echo '$HOME')
		// - VERSION=$(foobar -h | grep 'version: v' | awk '{print $NF}')
		let ptn_cmd_sub1 = format!(r"^{}=`.*`$", ptn_env_name);
		let ptn_cmd_sub2 = format!(r"^{}=\$\(.*\)$", ptn_env_name);
		if ::regex::contains(token, &ptn_cmd_sub1)
			|| ::regex::contains(token, &ptn_cmd_sub2)
			|| ::regex::contains(token, r"^\$\(.+\)$")
		{
			return false;
		}

		// for cmd-line like `alias foo='echo $PWD'`
		let ptn_env = format!(r"='.*\$\{{?{}\}}?.*'$", ptn_env_name);
		!::regex::contains(token, &ptn_env)
	}

	pub fn expand_env(sh: &Shell, tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff = Vec::new();

		for (sep, token) in tokens.iter() {
			if sep == "`" || sep == "'" {
				idx += 1;
				continue;
			}

			if !env_in_token(token) {
				idx += 1;
				continue;
			}

			let mut _token = token.clone();
			while env_in_token(&_token) {
				_token = expand_one_env(sh, &_token);
			}
			buff.push((idx, _token));
			idx += 1;
		}

		for (i, text) in buff.iter().rev() {
			tokens[*i].1 = text.to_string();
		}
	}

	fn should_do_dollar_command_extension(line: &str) -> bool {
		::regex::contains(line, r"\$\([^\)]+\)")
			&& !::regex::contains(line, r"='.*\$\([^\)]+\).*'$")
	}

	fn do_command_substitution_for_dollar(sh: &mut Shell, tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff: HashMap<usize, String> = HashMap::new();

		for (sep, token) in tokens.iter() {
			if sep == "'" || sep == "\\" || !should_do_dollar_command_extension(token) {
				idx += 1;
				continue;
			}

			let mut line = token.to_string();
			loop {
				if !should_do_dollar_command_extension(&line) {
					break;
				}

				let ptn_cmd = r"\$\((.+)\)";
				let cmd = match libs::re::find_first_group(ptn_cmd, &line) {
					Some(x) => x,
					None => {
						println_stderr!("cicada: calculator: no first group");
						return;
					}
				};

				let cmd_result = match CommandLine::from_line(&cmd, sh) {
					Ok(c) => {
						log!("run subcmd dollar: {:?}", &cmd);
						let (term_given, cr) = core::run_pipeline(sh, &c, true, true, false);
						if term_given {
							unsafe {
								let gid = libc::getpgid(0);
								give_terminal_to(gid);
							}
						}

						cr
					}
					Err(e) => {
						println_stderr!("cicada: {}", e);
						continue;
					}
				};

				let output_txt = cmd_result.stdout.trim();

				let ptn = r"(?P<head>[^\$]*)\$\(.+\)(?P<tail>.*)";
				let re;
				if let Ok(x) = Regex::new(ptn) {
					re = x;
				} else {
					return;
				}

				let to = format!("${{head}}{}${{tail}}", output_txt);
				let line_ = line.clone();
				let result = re.replace(&line_, to.as_str());
				line = result.to_string();
			}

			buff.insert(idx, line.clone());
			idx += 1;
		}

		for (i, text) in buff.iter() {
			tokens[*i].1 = text.to_string();
		}
	}

	fn do_command_substitution_for_dot(sh: &mut Shell, tokens: &mut types::Tokens)
    {
		let mut idx: usize = 0;
		let mut buff: HashMap<usize, String> = HashMap::new();
		let re = Regex::new(r"^([^`]*)`([^`]+)`(.*)$").unwrap();

		for (sep, token) in tokens.iter()
        {
			let new_token: String;
			if sep == "`" {
				log!("run subcmd dot1: {:?}", token);
				let cr = match CommandLine::from_line(token, sh) {
					Ok(c) => {
						let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
						if term_given {
							unsafe {
								let gid = libc::getpgid(0);
								give_terminal_to(gid);
							}
						}

						_cr
					}
					Err(e) => {
						println_stderr!("cicada: {}", e);
						continue;
					}
				};

				new_token = cr.stdout.trim().to_string();
			} else if sep == "\"" || sep.is_empty() {
				if !re.is_match(token) {
					idx += 1;
					continue;
				}
				let mut _token = token.clone();
				let mut _item = String::new();
				let mut _head = String::new();
				let mut _output = String::new();
				let mut _tail = String::new();
				loop {
					if !re.is_match(&_token) {
						if !_token.is_empty() {
							_item = format!("{}{}", _item, _token);
						}
						break;
					}
					for cap in re.captures_iter(&_token) {
						_head = cap[1].to_string();
						_tail = cap[3].to_string();
						log!("run subcmd dot2: {:?}", &cap[2]);

						let cr = match CommandLine::from_line(&cap[2], sh) {
							Ok(c) => {
								let (term_given, _cr) = core::run_pipeline(sh, &c, true, true, false);
								if term_given {
									unsafe {
										let gid = libc::getpgid(0);
										give_terminal_to(gid);
									}
								}

								_cr
							}
							Err(e) => {
								println_stderr!("cicada: {}", e);
								continue;
							}
						};

						_output = cr.stdout.trim().to_string();
					}
					_item = format!("{}{}{}", _item, _head, _output);
					if _tail.is_empty() {
						break;
					}
					_token = _tail.clone();
				}
				new_token = _item;
			} else {
				idx += 1;
				continue;
			}

			buff.insert(idx, new_token.clone());
			idx += 1;
		}

		for (i, text) in buff.iter() {
			tokens[*i].1 = text.to_string();
		}
	}

	fn do_command_substitution(sh: &mut Shell, tokens: &mut types::Tokens) {
		do_command_substitution_for_dot(sh, tokens);
		do_command_substitution_for_dollar(sh, tokens);
	}

	pub fn do_expansion(sh: &mut Shell, tokens: &mut types::Tokens)
    {
		let line = parsers::line::tokens_to_line(tokens);
		if ::is::arithmetic(&line) {
			return;
		}

		if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with("PROMPT=") {
			return;
		}

		expand_alias(sh, tokens);
		expand_home(tokens);
		expand_env(sh, tokens);
		expand_brace(tokens);
		expand_glob(tokens);
		do_command_substitution(sh, tokens);
		expand_brace_range(tokens);
	}

	pub fn trim_multiline_prompts(line: &str) -> String 
    {
		let line_new = ::regex::replace_all(line, r"\\\n>> ", "");
		let line_new = ::regex::replace_all(&line_new, r"\| *\n>> ", "| ");
		::regex::replace_all(&line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE")
	}

	fn proc_has_terminal() -> bool 
    {
		unsafe 
        {
			let tgid = libc::tcgetpgrp(0);
			let pgid = libc::getpgid(0);
			tgid == pgid
		}
	}
}

pub mod signals
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use errno::{errno, set_errno};
	use nix::sys::signal;
	use nix::sys::wait::{waitpid, WaitPidFlag as WF, WaitStatus as WS};
	use nix::unistd::Pid;
	use std::collections::{HashMap, HashSet};
	use std::sync::Mutex;
	*/
	lazy_static! 
    {
		static ref REAP_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
		static ref STOP_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
		static ref CONT_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
		static ref KILL_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
	}

	pub fn killed_map_insert(pid: i32, sig: i32)
    {
		if let Ok(mut m) = KILL_MAP.try_lock() {
			m.insert(pid, sig);
		}
	}

	pub fn killed_map_pop(pid: i32) -> Option<i32>
    {
		if let Ok(mut m) = KILL_MAP.try_lock() {
			m.remove(&pid)
		} else {
			None
		}
	}

	pub fn insert_cont_map(pid: i32)
    {
		if let Ok(mut m) = CONT_MAP.try_lock() {
			m.insert(pid);
		}
	}

	pub fn pop_cont_map(pid: i32) -> bool
    {
		match CONT_MAP.try_lock()
        {
			Ok(mut m) => m.remove(&pid),
			Err(_) => false,
		}
	}

	pub fn insert_stopped_map(pid: i32)
    {
		if let Ok(mut m) = STOP_MAP.try_lock() {
			m.insert(pid);
		}
	}

	pub fn pop_stopped_map(pid: i32) -> bool   
    {
		match STOP_MAP.try_lock()
        {
			Ok(mut m) => m.remove(&pid),
			Err(_) => false,
		}
	}

	pub fn insert_reap_map(pid: i32, status: i32)
    {
		if let Ok(mut m) = REAP_MAP.try_lock() { m.insert(pid, status); }
	}

	pub fn pop_reap_map(pid: i32) -> Option<i32>
    {
		match REAP_MAP.try_lock()
        {
			Ok(mut m) => m.remove(&pid),
			Err(_) => None,
		}
	}

	pub fn block_signals()
    {
		let mut sigset = signal::SigSet::empty();
		sigset.add(signal::SIGCHLD);
		match signal::sigprocmask(signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None)
        {
			Ok(_) => {}
			Err(e) => {
				log!("sigprocmask block error: {:?}", e);
			}
		}
	}

	pub fn unblock_signals()
    {
		let mut sigset = signal::SigSet::empty();
		sigset.add(signal::SIGCHLD);
		match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None)
        {
			Ok(_) => {}
			Err(e) => {
				log!("sigprocmask unblock error: {:?}", e);
			}
		}
	}

	pub extern "C" fn handle_sigchld(_sig: i32)
    {
		let saved_errno = errno();
		let options = Some(WF::WUNTRACED | WF::WNOHANG | WF::WCONTINUED);
		loop {
			match waitpid(Pid::from_raw(-1), options)
            {
				Ok(WS::Exited(pid, status)) => {
					insert_reap_map(i32::from(pid), status);
				}
				Ok(WS::Stopped(pid, _sig)) => {
					insert_stopped_map(i32::from(pid));
				}
				Ok(WS::Continued(pid)) => {
					// NOTE: SIGCHLD generated by SIGCONT is not reliable
					// on Mac (both for signal handler or sync waitpid).
					insert_cont_map(i32::from(pid));
				}
				Ok(WS::Signaled(pid, sig, _core_dumped)) => {
					killed_map_insert(i32::from(pid), sig as i32);
				}
				Ok(WS::StillAlive) => {
					break;
				}
				Ok(_others) => {
					// log!("sigchld others: {:?}", _others);
				}
				Err(e) => {
					if e == nix::Error::ECHILD {
						break;
					}

					log!("chld waitpid error: {:?}", e);
					break;
				}
			}
		}

		set_errno(saved_errno);
	}

	pub fn setup_sigchld_handler()
    {
		let sigset = signal::SigSet::empty();
		let handler = signal::SigHandler::Handler(handle_sigchld);
		// automatically restart system calls interrupted by this signal handler
		let flags = signal::SaFlags::SA_RESTART;
		let sa = signal::SigAction::new(handler, flags, sigset);
		unsafe {
			match signal::sigaction(signal::SIGCHLD, &sa)
            {
				Ok(_) => {}
				Err(e) => {
					log!("sigaction error: {:?}", e);
				}
			}
		}
	}

}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
	pub use std::sync::{ * };
}

pub mod system
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
	pub mod common
	{
		/*!
		*/
		use ::
		{
			*,
		};
		/*
		use std::env;
		use std::ffi::{CStr, CString};
		use std::fs::File;
		use std::io::{Read, Write};
		use std::os::fd::RawFd;
		use std::os::unix::io::FromRawFd;
		use std::process;

		use libs::pipes::pipe;
		use nix::unistd::{execve, ForkResult};

		use crate::builtins;
		use crate::calculator;
		use crate::jobc;
		use crate::libs;
		use crate::parsers;
		use crate::scripts;
		use crate::shell::{self, Shell};
		use crate::tools;
		use crate::types::{CommandLine, CommandOptions, CommandResult};
		*/		
		fn try_run_builtin_in_subprocess
        (
			sh: &mut Shell,
			cl: &CommandLine,
			idx_cmd: usize,
			capture: bool,
		) -> Option<i32>
        {
			if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
				return Some(cr.status);
			}
			None
		}

		fn try_run_builtin
        (
			sh: &mut Shell,
			cl: &CommandLine,
			idx_cmd: usize,
			capture: bool,
		) -> Option<CommandResult>
        {
			let capture = capture && idx_cmd + 1 == cl.commands.len();

			if idx_cmd >= cl.commands.len()
            {
				println_stderr!("unexpected error in try_run_builtin");
				return None;
			}

			let cmd = &cl.commands[idx_cmd];
			let tokens = cmd.tokens.clone();
			let cname = tokens[0].1.clone();

            match true
            {
                true if cname == "alias" =>
                {
                    let cr = ::api::run_alias(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                true if cname == "bg" =>
                {
                    let cr = ::api::run_bg(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                true if cname == "cd" =>
                {
                    let cr = ::api::run_cd(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "cinfo" =>
                {
                    let cr = ::api::run_cinfo(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "exec" =>
                {
                    let cr = ::api::run_exec(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "exit" =>
                {
                    let cr = ::api::run_exit(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "export" =>
                {
                    let cr = ::api::run_export(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "fg" =>
                {
                    let cr = ::api::run_fg(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "history" =>
                {
                    let cr = ::api::run_history(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "jobs" =>
                {
                    let cr = ::api::run_jobs(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "minfd" =>
                {
                    let cr = ::api::run_minfd(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "read" =>
                {
                    let cr = ::api::run_read(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "set" =>
                {
                    let cr = ::api::run_set(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "source" =>
                {
                    let cr = ::api::run_source(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "ulimit" =>
                {
                    let cr = ::api::run_ulimit(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "unalias" =>
                {
                    let cr = ::api::run_unalias(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "unset" =>
                {
                    let cr = ::api::run_unset(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "unpath" =>
                {
                    let cr = ::api::run_unpath(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                
                true if cname == "vox" =>
                {
                    let cr = ::api::run_vox(sh, cl, cmd, capture);
                    return Some(cr);
                }
                
                _ => { return None; }
            }
		}
		/// Run a pipeline (e.g. `echo hi | wc -l`)
		/// returns: (is-terminal-given, command-result)
		pub fn run_pipeline
        (
			sh: &mut shell::Shell,
			cl: &CommandLine,
			tty: bool,
			capture: bool,
			log_cmd: bool,
		) -> (bool, CommandResult)
        {
			let mut term_given = false;
			if cl.background && capture {
				println_stderr!("cicada: cannot capture output of background cmd");
				return (term_given, CommandResult::error());
			}

			if let Some(cr) = try_run_calculator(&cl.line, capture) {
				return (term_given, cr);
			}

			// FIXME: move func-run into run single command
			if let Some(cr) = try_run_func(sh, cl, capture, log_cmd) {
				return (term_given, cr);
			}

			if log_cmd {
				log!("run: {}", cl.line);
			}

			let length = cl.commands.len();
			if length == 0 {
				println!("cicada: invalid command: cmds with empty length");
				return (false, CommandResult::error());
			}

			let mut pipes = Vec::new();
			let mut errored_pipes = false;
			for _ in 0..length - 1 {
				match pipe() {
					Ok(fds) => pipes.push(fds),
					Err(e) => {
						errored_pipes = true;
						println_stderr!("cicada: pipeline1: {}", e);
						break;
					}
				}
			}

			if errored_pipes {
				// release fds that already created when errors occurred
				for fds in pipes {
					libs::close(fds.0);
					libs::close(fds.1);
				}
				return (false, CommandResult::error());
			}

			if pipes.len() + 1 != length {
				println!("cicada: invalid command: unmatched pipes count");
				return (false, CommandResult::error());
			}

			let mut pgid: i32 = 0;
			let mut fg_pids: Vec<i32> = Vec::new();

			let isatty = if tty {
				unsafe { libc::isatty(1) == 1 }
			} else {
				false
			};
			let options = CommandOptions {
				isatty,
				capture_output: capture,
				background: cl.background,
				envs: cl.envs.clone(),
			};

			let mut fds_capture_stdout = None;
			let mut fds_capture_stderr = None;
			if capture {
				match pipe() {
					Ok(fds) => fds_capture_stdout = Some(fds),
					Err(e) => {
						println_stderr!("cicada: pipeline2: {}", e);
						return (false, CommandResult::error());
					}
				}
				match pipe() {
					Ok(fds) => fds_capture_stderr = Some(fds),
					Err(e) => {
						if let Some(fds) = fds_capture_stdout {
							libs::close(fds.0);
							libs::close(fds.1);
						}
						println_stderr!("cicada: pipeline3: {}", e);
						return (false, CommandResult::error());
					}
				}
			}

			let mut cmd_result = CommandResult::new();
			for i in 0..length {
				let child_id: i32 = run_single_program(
					sh,
					cl,
					i,
					&options,
					&mut pgid,
					&mut term_given,
					&mut cmd_result,
					&pipes,
					&fds_capture_stdout,
					&fds_capture_stderr,
				);

				if child_id > 0 && !cl.background {
					fg_pids.push(child_id);
				}
			}

			if cl.is_single_and_builtin() {
				return (false, cmd_result);
			}

			if cl.background {
				if let Some(job) = sh.get_job_by_gid(pgid) {
					println_stderr!("[{}] {}", job.id, job.gid);
				}
			}

			if !fg_pids.is_empty() {
				let _cr = jobc::wait_fg_job(sh, pgid, &fg_pids);
				// for capture commands, e.g. `echo foo` in `echo "hello $(echo foo)"
				// the cmd_result is already built in loop calling run_single_program()
				// above.
				if !capture {
					cmd_result = _cr;
				}
			}
			(term_given, cmd_result)
		}
		/// Run a single command.
		/// e.g. the `sort -k2` part of `ps ax | sort -k2 | head`
		fn run_single_program
        (
			sh: &mut shell::Shell,
			cl: &CommandLine,
			idx_cmd: usize,
			options: &CommandOptions,
			pgid: &mut i32,
			term_given: &mut bool,
			cmd_result: &mut CommandResult,
			pipes: &[(RawFd, RawFd)],
			fds_capture_stdout: &Option<(RawFd, RawFd)>,
			fds_capture_stderr: &Option<(RawFd, RawFd)>,
		) -> i32
        {
			let capture = options.capture_output;
			if cl.is_single_and_builtin() {
				if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
					*cmd_result = cr;
					return unsafe { libc::getpid() };
				}

				println_stderr!("cicada: error when run singler builtin");
				log!("error when run singler builtin: {:?}", cl);
				return 1;
			}

			let pipes_count = pipes.len();
			let mut fds_stdin = None;
			let cmd = cl.commands.get(idx_cmd).unwrap();

			if cmd.has_here_string() {
				match pipe() {
					Ok(fds) => fds_stdin = Some(fds),
					Err(e) => {
						println_stderr!("cicada: pipeline4: {}", e);
						return 1;
					}
				}
			}

			match ::process::fork()
            {
				Ok(ForkResult::Child) => {
					unsafe {
						// child processes need to handle ctrl-Z
						libc::signal(libc::SIGTSTP, libc::SIG_DFL);
						libc::signal(libc::SIGQUIT, libc::SIG_DFL);
					}

					// close pipes unrelated to current child (left side)
					if idx_cmd > 0 {
						for i in 0..idx_cmd - 1 {
							let fds = pipes[i];
							libs::close(fds.0);
							libs::close(fds.1);
						}
					}
					// close pipes unrelated to current child (right side)
					for i in idx_cmd + 1..pipes_count {
						let fds = pipes[i];
						libs::close(fds.0);
						libs::close(fds.1);
					}
					// close pipe fds for capturing stdout/stderr
					// (they're only used in last child)
					if idx_cmd < pipes_count {
						if let Some(fds) = fds_capture_stdout {
							libs::close(fds.0);
							libs::close(fds.1);
						}
						if let Some(fds) = fds_capture_stderr {
							libs::close(fds.0);
							libs::close(fds.1);
						}
					}

					if idx_cmd == 0 {
						unsafe {
							let pid = libc::getpid();
							libc::setpgid(0, pid);
						}
					} else {
						unsafe {
							libc::setpgid(0, *pgid);
						}
					}

					// (in child) replace stdin/stdout with read/write ends of pipe
					if idx_cmd > 0 {
						let fds_prev = pipes[idx_cmd - 1];
						libs::dup2(fds_prev.0, 0);
						libs::close(fds_prev.0);
						libs::close(fds_prev.1);
					}
					if idx_cmd < pipes_count {
						let fds = pipes[idx_cmd];
						libs::dup2(fds.1, 1);
						libs::close(fds.1);
						libs::close(fds.0);
					}

					if cmd.has_redirect_from() {
						if let Some(redirect_from) = &cmd.redirect_from {
							let fd = tools::get_fd_from_file(&redirect_from.clone().1);
							if fd == -1 {
								process::exit(1);
							}

							libs::dup2(fd, 0);
							libs::close(fd);
						}
					}

					if cmd.has_here_string() {
						if let Some(fds) = fds_stdin {
							libs::close(fds.1);
							libs::dup2(fds.0, 0);
							libs::close(fds.0);
						}
					}

					let mut stdout_redirected = false;
					let mut stderr_redirected = false;
					for item in &cmd.redirects_to {
						let from_ = &item.0;
						let op_ = &item.1;
						let to_ = &item.2;
						if to_ == "&1" && from_ == "2" {
							if idx_cmd < pipes_count {
								libs::dup2(1, 2);
							} else if !options.capture_output {
								let fd = libs::dup(1);
								if fd == -1 {
									println_stderr!("cicada: dup error");
									process::exit(1);
								}
								libs::dup2(fd, 2);
							} else {
								// note: capture output with redirections does not
								// make much sense
							}
						} else if to_ == "&2" && from_ == "1" {
							if idx_cmd < pipes_count || !options.capture_output {
								let fd = libs::dup(2);
								if fd == -1 {
									println_stderr!("cicada: dup error");
									process::exit(1);
								}
								libs::dup2(fd, 1);
							} else {
								// note: capture output with redirections does not
								// make much sense
							}
						} else {
							let append = op_ == ">>";
							match tools::create_raw_fd_from_file(to_, append) {
								Ok(fd) => {
									if fd == -1 {
										println_stderr!("cicada: fork: fd error");
										process::exit(1);
									}

									if from_ == "1" {
										libs::dup2(fd, 1);
										stdout_redirected = true;
									} else {
										libs::dup2(fd, 2);
										stderr_redirected = true;
									}
								}
								Err(e) => {
									println_stderr!("cicada: fork: {}", e);
									process::exit(1);
								}
							}
						}
					}

					// capture output of last process if needed.
					if idx_cmd == pipes_count && options.capture_output {
						if !stdout_redirected {
							if let Some(fds) = fds_capture_stdout {
								libs::close(fds.0);
								libs::dup2(fds.1, 1);
								libs::close(fds.1);
							}
						}
						if !stderr_redirected {
							if let Some(fds) = fds_capture_stderr {
								libs::close(fds.0);
								libs::dup2(fds.1, 2);
								libs::close(fds.1);
							}
						}
					}

					if cmd.is_builtin() {
						if let Some(status) = try_run_builtin_in_subprocess(sh, cl, idx_cmd, capture) {
							process::exit(status);
						}
					}

					// our strings do not have '\x00' bytes in them,
					// we can use CString::new().expect() safely.
					let mut c_envs: Vec<_> = env::vars()
						.map(|(k, v)| {
							CString::new(format!("{}={}", k, v).as_str()).expect("CString error")
						})
						.collect();
					for (key, value) in cl.envs.iter() {
						c_envs.push(
							CString::new(format!("{}={}", key, value).as_str()).expect("CString error"),
						);
					}

					let program = &cmd.tokens[0].1;
					let path = if program.contains('/') {
						program.clone()
					} else {
						libs::path::find_file_in_path(program, true)
					};
					if path.is_empty() {
						println_stderr!("cicada: {}: command not found", program);
						process::exit(127);
					}

					let c_program = CString::new(path.as_str()).expect("CString::new failed");
					let c_args: Vec<_> = cmd
						.tokens
						.iter()
						.map(|x| CString::new(x.1.as_str()).expect("CString error"))
						.collect();

					let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str()).collect();
					let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str()).collect();
					match execve(&c_program, &c_args, &c_envs) {
						Ok(_) => {}
						Err(e) => match e {
							nix::Error::ENOEXEC => {
								println_stderr!("cicada: {}: exec format error (ENOEXEC)", program);
							}
							nix::Error::ENOENT => {
								println_stderr!("cicada: {}: file does not exist", program);
							}
							nix::Error::EACCES => {
								println_stderr!("cicada: {}: Permission denied", program);
							}
							_ => {
								println_stderr!("cicada: {}: {:?}", program, e);
							}
						},
					}

					process::exit(1);
				}
				Ok(ForkResult::Parent { child, .. }) => {
					let pid: i32 = child.into();
					if idx_cmd == 0 {
						*pgid = pid;
						unsafe {
							// we need to wait pgid of child set to itself,
							// before give terminal to it (for macos).
							// 1. this loop causes `bash`, `htop` etc to go `T` status
							//    immediate after start on linux (ubuntu).
							// 2. but on mac, we need this loop, otherwise commands
							//    like `vim` will go to `T` status after start.
							if cfg!(target_os = "macos") {
								loop {
									let _pgid = libc::getpgid(pid);
									if _pgid == pid {
										break;
									}
								}
							}

							if sh.has_terminal && options.isatty && !cl.background {
								*term_given = shell::give_terminal_to(pid);
							}
						}
					}

					if options.isatty && !options.capture_output {
						let _cmd = parsers::line::tokens_to_line(&cmd.tokens);
						sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background);
					}

					if let Some(redirect_from) = &cmd.redirect_from {
						if redirect_from.0 == "<<<" {
							if let Some(fds) = fds_stdin {
								unsafe {
									libs::close(fds.0);

									let mut f = File::from_raw_fd(fds.1);
									match f.write_all(redirect_from.1.clone().as_bytes()) {
										Ok(_) => {}
										Err(e) => println_stderr!("cicada: write_all: {}", e),
									}
									match f.write_all(b"\n") {
										Ok(_) => {}
										Err(e) => println_stderr!("cicada: write_all: {}", e),
									}
								}
							}
						}
					}

					// (in parent) close unused pipe ends
					if idx_cmd < pipes_count {
						let fds = pipes[idx_cmd];
						libs::close(fds.1);
					}
					if idx_cmd > 0 {
						// close pipe end only after dupped in the child
						let fds = pipes[idx_cmd - 1];
						libs::close(fds.0);
					}

					if idx_cmd == pipes_count && options.capture_output {
						let mut s_out = String::new();
						let mut s_err = String::new();

						unsafe {
							if let Some(fds) = fds_capture_stdout {
								libs::close(fds.1);

								let mut f = File::from_raw_fd(fds.0);
								match f.read_to_string(&mut s_out) {
									Ok(_) => {}
									Err(e) => println_stderr!("cicada: readstr: {}", e),
								}
							}
							if let Some(fds) = fds_capture_stderr {
								libs::close(fds.1);
								let mut f_err = File::from_raw_fd(fds.0);
								match f_err.read_to_string(&mut s_err) {
									Ok(_) => {}
									Err(e) => println_stderr!("cicada: readstr: {}", e),
								}
							}
						}

						*cmd_result = CommandResult {
							gid: *pgid,
							status: 0,
							stdout: s_out.clone(),
							stderr: s_err.clone(),
						};
					}

					pid
				}

				Err(_) => {
					println_stderr!("Fork failed");
					*cmd_result = CommandResult::error();
					0
				}
			}
		}

		fn try_run_func
        (
			sh: &mut Shell,
			cl: &CommandLine,
			capture: bool,
			log_cmd: bool,
		) -> Option<CommandResult>
        {
			if cl.is_empty() {
				return None;
			}

			let command = &cl.commands[0];
			if let Some(func_body) = sh.get_func(&command.tokens[0].1) {
				let mut args = vec!["cicada".to_string()];
				for token in &command.tokens {
					args.push(token.1.to_string());
				}
				if log_cmd {
					log!("run func: {:?}", &args);
				}
				let cr_list = scripting::run_lines(sh, &func_body, &args, capture);
				let mut stdout = String::new();
				let mut stderr = String::new();
				for cr in cr_list {
					stdout.push_str(cr.stdout.trim());
					stdout.push(' ');
					stderr.push_str(cr.stderr.trim());
					stderr.push(' ');
				}
				let mut cr = CommandResult::new();
				cr.stdout = stdout;
				cr.stderr = stderr;
				return Some(cr);
			}
			None
		}

	}

	pub fn get_user_name() -> String
    {
		match env::var("USER")
        {
			Ok(x) => {
				return x;
			}
			Err(e) => {
				log!("cicada: env USER error: {}", e);
			}
		}
		let cmd_result = execute::run("whoami");
		cmd_result.stdout.trim().to_string()
	}

	pub fn get_user_home() -> String
    {
		match env::var("HOME")
        {
			Ok(x) => x,
			Err(e) => {
				println_stderr!("cicada: env HOME error: {}", e);
				String::new()
			}
		}
	}

	pub fn get_config_dir() -> String
    {
		if let Ok(x) = env::var("XDG_CONFIG_HOME") {
			format!("{}/cicada", x)
		} else {
			let home = get_user_home();
			format!("{}/.config/cicada", home)
		}
	}

	pub fn get_user_completer_dir() -> String
    {
		let dir_config = get_config_dir();
		format!("{}/completers", dir_config)
	}

	pub fn unquote(s: &str) -> String
    {
		let args = parsers::line::line_to_plain_tokens(s);
		if args.is_empty() {
			return String::new();
		}
		args[0].clone()
	}
    
	pub fn extend_bangbang(sh: &shell::Shell, line: &mut String)
    {
		if !re_contains(line, r"!!") {
			return;
		}
		if sh.previous_cmd.is_empty() {
			return;
		}

		let re = Regex::new(r"!!").unwrap();
		let mut replaced = false;
		let mut new_line = String::new();
		let linfo = parsers::line::parse_line(line);
		for (sep, token) in linfo.tokens {
			if !sep.is_empty() {
				new_line.push_str(&sep);
			}

			if re_contains(&token, r"!!") && sep != "'" {
				let line2 = token.clone();
				let result = re.replace_all(&line2, sh.previous_cmd.as_str());
				new_line.push_str(&result);
				replaced = true;
			} else {
				new_line.push_str(&token);
			}

			if !sep.is_empty() {
				new_line.push_str(&sep);
			}
			new_line.push(' ');
		}

		*line = new_line.trim_end().to_string();
		// print full line after extending
		if replaced {
			println!("{}", line);
		}
	}

	pub fn wrap_sep_string(sep: &str, s: &str) -> String
    {
		let mut _token = String::new();
		let mut met_subsep = false;
		// let set previous_subsep to any char except '`' or '"'
		let mut previous_subsep = 'N';
		for c in s.chars() {
			// handle cmds like: export DIR=`brew --prefix openssl`/include
			// or like: export foo="hello world"
			if sep.is_empty() && (c == '`' || c == '"') {
				if !met_subsep {
					met_subsep = true;
					previous_subsep = c;
				} else if c == previous_subsep {
					met_subsep = false;
					previous_subsep = 'N';
				}
			}
			if c.to_string() == sep {
				_token.push('\\');
			}
			if c == ' ' && sep.is_empty() && !met_subsep {
				_token.push('\\');
			}
			_token.push(c);
		}
		format!("{}{}{}", sep, _token, sep)
	}

	pub fn env_args_to_command_line() -> String
    {
		let mut result = String::new();
		let env_args = env::args();
		if env_args.len() <= 1 {
			return result;
		}
		for (i, arg) in env_args.enumerate() {
			if i == 0 || arg == "-c" {
				continue;
			}
			result.push_str(arg.as_str());
		}
		result
	}

	extern "C" 
    {
		fn gethostname(name: *mut libc::c_char, size: libc::size_t) -> libc::c_int;
	}

	/// via: https://gist.github.com/conradkleinespel/6c8174aee28fa22bfe26
	pub fn get_hostname() -> String
    {
		let len = 255;
		let mut buf = Vec::<u8>::with_capacity(len);

		let ptr = buf.as_mut_slice().as_mut_ptr();

		let err = unsafe { gethostname(ptr as *mut libc::c_char, len as libc::size_t) } as i32;

		match err {
			0 => {
				let real_len;
				let mut i = 0;
				loop {
					let byte = unsafe { *(((ptr as u64) + (i as u64)) as *const u8) };
					if byte == 0 {
						real_len = i;
						break;
					}

					i += 1;
				}
				unsafe { buf.set_len(real_len) }
				String::from_utf8_lossy(buf.as_slice()).into_owned()
			}
			_ => String::from("unknown"),
		}
	}

	pub fn create_raw_fd_from_file(file_name: &str, append: bool) -> Result<i32, String>
    {
		let mut oos = OpenOptions::new();
		if append {
			oos.append(true);
		} else {
			oos.write(true);
			oos.truncate(true);
		}
		match oos.create(true).open(file_name)
        {
			Ok(x) => {
				let fd = x.into_raw_fd();
				Ok(fd)
			}
			Err(e) => Err(format!("{}", e)),
		}
	}

	pub fn get_fd_from_file(file_name: &str) -> i32
    {
		let path = Path::new(file_name);
		let display = path.display();
		let file = match File::open(path) {
			Err(why) => {
				println_stderr!("cicada: {}: {}", display, why);
				return -1;
			}
			Ok(file) => file,
		};
		file.into_raw_fd()
	}

	pub fn escape_path(path: &str) -> String
    {
		let re = Regex::new(r##"(?P<c>[!\(\)<>,\?\]\[\{\} \\'"`*\^#|$&;])"##).unwrap();
		re.replace_all(path, "\\$c").to_string()
	}

	pub fn get_current_dir() -> String
    {
		let mut current_dir = PathBuf::new();
		match env::current_dir()
        {
			Ok(x) => current_dir = x,
			Err(e) => {
				println_stderr!("env current_dir() failed: {}", e);
			}
		}
		let mut str_current_dir = "";
		match current_dir.to_str() {
			Some(x) => str_current_dir = x,
			None => {
				println_stderr!("current_dir to str failed.");
			}
		}
		str_current_dir.to_string()
	}

	pub fn split_into_fields
    (
		sh: &shell::Shell,
		line: &str,
		envs: &HashMap<String, String>,
	) -> Vec<String>
    {
		let ifs_chars;
		if envs.contains_key("IFS") {
			ifs_chars = envs[&"IFS".to_string()].chars().collect();
		} else if let Some(x) = sh.get_env("IFS") {
			ifs_chars = x.chars().collect();
		} else if let Ok(x) = env::var("IFS") {
			ifs_chars = x.chars().collect();
		} else {
			ifs_chars = vec![];
		}

		if ifs_chars.is_empty() {
			line.split(&[' ', '\t', '\n'][..])
				.map(|x| x.to_string())
				.collect()
		} else {
			line.split(&ifs_chars[..]).map(|x| x.to_string()).collect()
		}
	}
}

pub mod time
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	*/
	pub mod std
	{
		pub use std::time::{ * };
	}
	
}

pub mod types
{
	/*!
	*/
	use ::
	{
		*,
	};
	/*
	use regex::Regex;
	use std::collections::{HashMap, HashSet};
	use std::fmt;

	use crate::libs;
	use crate::parsers;
	use crate::parsers::line::tokens_to_redirections;
	use crate::shell;
	use crate::tools;
	*/
	#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
	pub struct WaitStatus(i32, i32, i32);

	impl WaitStatus
    {
		pub fn from_exited(pid: i32, status: i32) -> Self {
			WaitStatus(pid, 0, status)
		}

		pub fn from_signaled(pid: i32, sig: i32) -> Self {
			WaitStatus(pid, 1, sig)
		}

		pub fn from_stopped(pid: i32, sig: i32) -> Self {
			WaitStatus(pid, 2, sig)
		}

		pub fn from_continuted(pid: i32) -> Self {
			WaitStatus(pid, 3, 0)
		}

		pub fn from_others() -> Self {
			WaitStatus(0, 9, 9)
		}

		pub fn from_error(errno: i32) -> Self {
			WaitStatus(0, 255, errno)
		}

		pub fn empty() -> Self {
			WaitStatus(0, 0, 0)
		}

		pub fn is_error(&self) -> bool {
			self.1 == 255
		}

		pub fn is_others(&self) -> bool {
			self.1 == 9
		}

		pub fn is_signaled(&self) -> bool {
			self.1 == 1
		}

		pub fn get_errno(&self) -> nix::Error {
			nix::Error::from_raw(self.2)
		}

		pub fn is_exited(&self) -> bool {
			self.0 != 0 && self.1 == 0
		}

		pub fn is_stopped(&self) -> bool {
			self.1 == 2
		}

		pub fn is_continued(&self) -> bool {
			self.1 == 3
		}

		pub fn get_pid(&self) -> i32 {
			self.0
		}

		fn _get_signaled_status(&self) -> i32 {
			self.2 + 128
		}

		pub fn get_signal(&self) -> i32 {
			self.2
		}

		pub fn get_name(&self) -> String {
			if self.is_exited() {
				"Exited".to_string()
			} else if self.is_stopped() {
				"Stopped".to_string()
			} else if self.is_continued() {
				"Continued".to_string()
			} else if self.is_signaled() {
				"Signaled".to_string()
			} else if self.is_others() {
				"Others".to_string()
			} else if self.is_error() {
				"Error".to_string()
			} else {
				format!("unknown: {}", self.2)
			}
		}

		pub fn get_status(&self) -> i32 {
			if self.is_exited() {
				self.2
			} else {
				self._get_signaled_status()
			}
		}
	}

	impl fmt::Debug for WaitStatus
    {
		fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
			let mut formatter = f.debug_struct("WaitStatus");
			formatter.field("pid", &self.0);
			let name = self.get_name();
			formatter.field("name", &name);
			formatter.field("ext", &self.2);
			formatter.finish()
		}
	}

	pub type Token = (String, String);
	pub type Tokens = Vec<Token>;
	pub type Redirection = (String, String, String);

	#[derive(Debug)]
	pub struct LineInfo
    {
		// e.g. echo 'foo
		// is not a completed line, need to turn to multiple-line mode.
		pub tokens: Tokens,
		pub is_complete: bool,
	}

	impl LineInfo
    {
		pub fn new(tokens: Tokens) -> Self {
			LineInfo {
				tokens,
				is_complete: true,
			}
		}
	}
	///
	/// command line: `ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
	/// Command {
	///     tokens: [("", "ls"), ("", "-G"), ("\'", "foo bar")],
	///     redirects_to: [
	///         ("2", ">", "&1"),
	///         ("1", ">", "/dev/null"),
	///     ],
	///     redirect_from: Some(("<", "one-file")),
	/// }
	///
	#[derive(Debug)]
	pub struct Command
    {
		pub tokens: Tokens,
		pub redirects_to: Vec<Redirection>,
		pub redirect_from: Option<Token>,
	}

	impl Command
    {
		pub fn from_tokens(tokens: Tokens) -> Result<Command, String>
        {
			let mut tokens_new = tokens.clone();
			let mut redirects_from_type = String::new();
			let mut redirects_from_value = String::new();
			let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");

			let mut len = tokens_new.len();
			while has_redirect_from {
				if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<") {
					redirects_from_type = "<".to_string();
					tokens_new.remove(idx);
					len -= 1;
					if len > idx {
						redirects_from_value = tokens_new.remove(idx).1;
						len -= 1;
					}
				}
				if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<") {
					redirects_from_type = "<<<".to_string();
					tokens_new.remove(idx);
					len -= 1;
					if len > idx {
						redirects_from_value = tokens_new.remove(idx).1;
						len -= 1;
					}
				}

				has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
			}

			let tokens_final;
			let redirects_to;
			match tokens_to_redirections(&tokens_new)
            {
				Ok((_tokens, _redirects_to)) => {
					tokens_final = _tokens;
					redirects_to = _redirects_to;
				}
				Err(e) => {
					return Err(e);
				}
			}

			let redirect_from = if redirects_from_type.is_empty() {
				None
			} else {
				Some((redirects_from_type, redirects_from_value))
			};

			Ok(Command {
				tokens: tokens_final,
				redirects_to,
				redirect_from,
			})
		}

		pub fn has_redirect_from(&self) -> bool {
			self.redirect_from.is_some() && self.redirect_from.clone().unwrap().0 == "<"
		}

		pub fn has_here_string(&self) -> bool {
			self.redirect_from.is_some() && self.redirect_from.clone().unwrap().0 == "<<<"
		}

		pub fn is_builtin(&self) -> bool {
			::is::builtin(&self.tokens[0].1)
		}
	}

	#[derive(Debug)]
	pub struct CommandLine
    {
		pub line: String,
		pub commands: Vec<Command>,
		pub envs: HashMap<String, String>,
		pub background: bool,
	}

	#[derive(Debug, Clone, Default)]
	pub struct Job
    {
		pub cmd: String,
		pub id: i32,
		pub gid: i32,
		pub pids: Vec<i32>,
		pub pids_stopped: HashSet<i32>,
		pub status: String,
		pub is_bg: bool,
	}

	impl Job
    {
		pub fn all_members_stopped(&self) -> bool {
			for pid in &self.pids {
				if !self.pids_stopped.contains(pid) {
					return false;
				}
			}
			true
		}

		pub fn all_members_running(&self) -> bool {
			self.pids_stopped.is_empty()
		}
	}

	#[derive(Clone, Debug, Default)]
	pub struct CommandResult
    {
		pub gid: i32,
		pub status: i32,
		pub stdout: String,
		pub stderr: String,
	}

	impl CommandResult
    {
		pub fn new() -> CommandResult {
			CommandResult {
				gid: 0,
				status: 0,
				stdout: String::new(),
				stderr: String::new(),
			}
		}

		pub fn from_status(gid: i32, status: i32) -> CommandResult {
			CommandResult {
				gid,
				status,
				stdout: String::new(),
				stderr: String::new(),
			}
		}

		pub fn error() -> CommandResult {
			CommandResult {
				gid: 0,
				status: 1,
				stdout: String::new(),
				stderr: String::new(),
			}
		}
	}
    
	#[derive(Clone, Debug, Default)]
	pub struct CommandOptions
    {
		pub background: bool,
		pub isatty: bool,
		pub capture_output: bool,
		pub envs: HashMap<String, String>,
	}

	fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens>
    {
		let mut cmd = Vec::new();
		let mut cmds = Vec::new();
		for token in tokens {
			let sep = &token.0;
			let value = &token.1;
			if sep.is_empty() && value == "|" {
				if cmd.is_empty() {
					return Vec::new();
				}
				cmds.push(cmd.clone());
				cmd = Vec::new();
			} else {
				cmd.push(token.clone());
			}
		}
		if cmd.is_empty() {
			return Vec::new();
		}
		cmds.push(cmd.clone());
		cmds
	}

	fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String>
    {
		let mut envs: HashMap<String, String> = HashMap::new();
		let mut n = 0;
		let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
		for (sep, text) in tokens.iter() {
			if !sep.is_empty() || !::regex::contains(text, r"^([a-zA-Z0-9_]+)=(.*)$") {
				break;
			}

			for cap in re.captures_iter(text) {
				let name = cap[1].to_string();
				let value = parsers::line::unquote(&cap[2]);
				envs.insert(name, value);
			}

			n += 1;
		}
		if n > 0 {
			tokens.drain(0..n);
		}
		envs
	}

	impl CommandLine
    {
		pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String>
        {
			let linfo = parsers::line::parse_line(line);
			let mut tokens = linfo.tokens;
			shell::do_expansion(sh, &mut tokens);
			let envs = drain_env_tokens(&mut tokens);

			let mut background = false;
			let len = tokens.len();
			if len > 1 && tokens[len - 1].1 == "&" {
				background = true;
				tokens.pop();
			}

			let mut commands = Vec::new();
			for sub_tokens in split_tokens_by_pipes(&tokens) {
				match Command::from_tokens(sub_tokens) {
					Ok(c) => {
						commands.push(c);
					}
					Err(e) => {
						return Err(e);
					}
				}
			}

			Ok(CommandLine {
				line: line.to_string(),
				commands,
				envs,
				background,
			})
		}

		pub fn is_empty(&self) -> bool {
			self.commands.is_empty()
		}

		pub fn with_pipeline(&self) -> bool {
			self.commands.len() > 1
		}

		pub fn is_single_and_builtin(&self) -> bool {
			self.commands.len() == 1 && self.commands[0].is_builtin()
		}
	}
}

pub mod vec
{
    pub use std::vec::{ * };
}

pub fn domain() -> Result<(), Box<dyn std::error::Error>>
{
    unsafe
    {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
        

		::env::initialize();

		let mut sh = shell::Shell::new();
		let args: Vec<String> = env::args().collect();

		if ::is::login(&args) {
			rcfile::load_rc_files(&mut sh);
			sh.is_login = true;
		}

		// Initialize command cache for highlighting
		highlight::init_command_cache();
		highlight::update_aliases(&sh);

		if ::is::script(&args) {
			log!("run script: {:?} ", &args);
			let status = scripting::run_script(&mut sh, &args);
			std::process::exit(status);
		}

		if ::is::command_string(&args) {
			// handles `cicada -c 'echo hi && echo yoo'`,
			// e.g. it could be triggered from Vim (`:!ls` etc).
			let line = tools::env_args_to_command_line();
			log!("run with -c args: {}", &line);
			execute::run_command_line(&mut sh, &line, false, false);
			std::process::exit(sh.previous_status);
		}

		if ::is::non_tty() {
			// cases like open a new MacVim window,
			// (i.e. CMD+N) on an existing one
			execute::run_procs_for_non_tty(&mut sh);
			return;
		}

		let mut rl;
		match Interface::new("cicada")
        {
			Ok(x) => rl = x,
			Err(e) => {
				// non-tty will raise errors here
				println!("cicada: lineread error: {}", e);
				return;
			}
		}

		rl.define_function("enter-function", Arc::new(prompt::EnterFunction));
		rl.bind_sequence("\r", Command::from_str("enter-function"));

		let highlighter = highlight::create_highlighter();
		rl.set_highlighter(highlighter);

		history::init(&mut rl);
		rl.set_completer(Arc::new(completers::CicadaCompleter {
			sh: Arc::new(sh.clone()),
		}));

		let sig_handler_enabled = ::is::signal_handler_enabled();
		if sig_handler_enabled {
			signals::setup_sigchld_handler();
			// block the signals at most of time, since Rust is not "async-signal-safe"
			// yet. see https://github.com/rust-lang/rfcs/issues/1368
			// we'll unblock them when necessary only.
			signals::block_signals();
		}

		loop {
			let prompt = prompt::get_prompt(&sh);
			match rl.set_prompt(&prompt)
            {
				Ok(_) => {}
				Err(e) => {
					println_stderr!("cicada: prompt error: {}", e);
				}
			}

			if sig_handler_enabled {
				// FIXME: in `rl.read_line()` below, there is lots of Rust code,
				// which may not be async-signal-safe. see follow links for details:
				// - https://ldpreload.com/blog/signalfd-is-useless
				// - https://man7.org/linux/man-pages/man7/signal-safety.7.html
				signals::unblock_signals();
			}
			match rl.read_line()
            {
				Ok(ReadResult::Input(line)) => {
					if sig_handler_enabled {
						signals::block_signals();
					}

					let line = shell::trim_multiline_prompts(&line);
					if line.trim() == "" {
						jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
						continue;
					}
					sh.cmd = line.clone();

					let tsb = ctime::DateTime::now().unix_timestamp();
					let mut line = line.clone();

					// since `!!` expansion is only meaningful in an interactive
					// shell we extend it here, instead of in `run_command_line()`.
					tools::extend_bangbang(&sh, &mut line);

					let mut status = 0;
					let cr_list = execute::run_command_line(&mut sh, &line, true, false);
					if let Some(last) = cr_list.last() {
						status = last.status;
					}
					let tse = ctime::DateTime::now().unix_timestamp();

					if !sh.cmd.starts_with(' ') && line != sh.previous_cmd {
						history::add(&sh, &mut rl, &line, status, tsb, tse);
						sh.previous_cmd = line.clone();
					}

					if ::is::shell_altering_command(&line) {
						// since our shell object need to be passed into
						// `lineread::Completer` with an Arc.
						// I currently do not know how to share the same sh
						// instance at hand with it.

						// update the Arc clone when alias/function/env changes
						rl.set_completer(Arc::new(completers::CicadaCompleter {
							sh: Arc::new(sh.clone()),
						}));

						// Update aliases in the highlighter when they might have changed
						highlight::update_aliases(&sh);
					}

					jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
					continue;
				}
				Ok(ReadResult::Eof) => {
					if let Ok(x) = env::var("NO_EXIT_ON_CTRL_D") {
						if x == "1" {
							println!();
						}
					} else {
						println!("exit");
						break;
					}
				}
				Ok(ReadResult::Signal(s)) => {
					println_stderr!("readline signal: {:?}", s);
				}
				Err(e) => {
					println_stderr!("readline error: {}", e);
					// There maybe other reason of this Err, but possibly it occurs
					// in cases we give term to a child, and it stops, and we
					// didn't have term back to shell in waitpid places. Here
					// it's a last resort.
					// FIXME: we only need this trick when job-control has issues
					unsafe {
						let gid = libc::getpgid(0);
						shell::give_terminal_to(gid);
					}
				}
			}
			if sig_handler_enabled {
				signals::block_signals();
			}
		}
        /*
        Return.*/
        Ok(())
    }
}

pub fn main() -> Result<(), Box<dyn std::error::Error>>
{
    domain()
}
// 90027 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
