//! Cicada is a bash-like Unix shell written in Rust.
#![feature
( 
    tool_lints,
 )]
/*
    #![allow(nonstandard_style)]
    #![allow(unsafe_op_in_unsafe_fn)]
*/
#![allow
( 
    dead_code,
    deprecated,
    non_camel_case_types,
    unknown_lints,
    unreachable_patterns,
    unused_imports,
    unused_macros,
    unused_variables
)]

#[macro_use] extern crate bitflags;
#[macro_use] extern crate lazy_static;
/*
*/
extern crate fnv;
extern crate libc;
extern crate nix;
extern crate num_integer;
extern crate num_traits;
extern crate rand;
extern crate regex as re;
extern crate smallvec;
extern crate time as timed;
extern crate unicode_normalization;
extern crate unicode_width;
/*
    extern crate clap;
    extern crate getrandom;
    extern crate libc;
    extern crate nix;
    extern crate unicode_normalization;
    extern crate unicode_width;
*/
/// Macros
#[macro_use] pub mod macros
{
    use ::
    {
        fs::{ OpenOptions },
        io::{ Write },
        *,
    };
    /*
        use std::collections::HashMap;
        use std::env;
        use std::fs::File;
        use std::fs::OpenOptions;
        use std::io::Write;
        use std::os::unix::io::IntoRawFd;
        use std::path::{Path, PathBuf};
    */
    #[macro_export] macro_rules! log
    {
        ( $fmt:expr ) =>
        ( 
            let log_file = if let Ok( x ) = ::env::var( "CICADA_LOG_FILE" ) { x.clone() } else { String::new() };

            if !log_file.is_empty()
            {
                let msg = $fmt;
                match  ::fs::OpenOptions::new().append( true ).create( true ).open( &log_file )
                {
                    Ok( mut cfile ) =>
                    {
                        let pid = $crate::get::pid();
                        let now = $crate::time::c::DateTime::now();
                        let msg = format!( "[{}][{}] {}", now, pid, msg );
                        let msg = if msg.ends_with( '\n' ) { msg } else { format!( "{}\n", msg ) };

                        match cfile.write_all( msg.as_bytes() )
                        {
                            Ok( _ ) => {}
                            Err( _ ) => println!( "tlog: write_all error" )
                        }
                    }
                    Err( _ ) => println!( "tlog: open file error" ),
                }
            }
       );

        ( $fmt:expr, $( $arg:tt )* ) =>
        ( 
            let msg = format!( $fmt, $( $arg )* );
            log!( &msg );
       );
    }

    #[macro_export] macro_rules! println_stderr
    {
        ( $fmt:expr ) =>
        ( 
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed: {:?}", e )
            }
       );

        ( $fmt:expr, $( $arg:tt )* ) =>
        ( 
            match writeln!( &mut ::io::stderr(), $fmt, $( $arg )* )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed: {:?}", e )
            }
       );
    }

    #[macro_export] macro_rules! map
    {
        {} =>
        {
            ::collections::HashMap::new()
        };
        
        { $( $key:expr => $value:expr ),+ , } =>
        {
            map!{ $( $key => $value ),+ }
        };

        { $( $key:expr => $value:expr ),* } =>
        {
            {
                let mut _map = ::collections::HashMap::new();
                $( 
                    let _ = _map.insert( $key, $value );
                )*
                _map
            }
        };
    }
    /// Given an int, creates and returns a `BigInt`.
    #[macro_export] macro_rules! int
    {
        ( $int:expr ) => 
        {{
            use ::num::big::BigInt;
            let _b: BigInt = $int.into();
            _b
        }};
    }
    /// Given two ints, creates and returns a `BigRational`.
    #[macro_export] macro_rules! frac
    {
        ( $int1:expr, $int2:expr ) =>
        {{
            ::num::rational::BigRational::new( $int1.into(), $int2.into())
        }};
    }
    /// Converts each element of a list to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! arr
    {
        [] => { $crate::database::arrays::Arr::from_vec( vec![]).unwrap() };        
        [ $( $elem:expr ),+ , ] => { try_arr![ $( $elem ),+ ].unwrap() };
        [ $( $elem:expr ),+ ] => { try_arr![ $( $elem ),+ ].unwrap() };
    }
    /// Converts each element of a list to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! try_arr
    {
        [ $( $elem:expr ),+ , ] => { try_arr![ $( $elem ),+ ] };        
        [ $( $elem:expr ),+ ] => {{ $crate::database::arrays::Arr::from_vec( vec![ $( $elem.into() ),+ ]) }};
    }
    /// Converts each element  of a list to `Value`s and returns a `Tup` containing a vector of the values.
    #[macro_export] macro_rules! tup
    {
        ( $( $elem:expr ),* , ) => { tup!( $( $elem ),* ) };

        ( $( $elem:expr ),* ) =>
        {{
            $crate::database::tuples::Tup::from_vec( vec![ $( $elem.into() ),+ ])
        }};
    }
    /// Given a list of field/value pairs, returns an `Obj` containing each pair.
    #[macro_export] macro_rules! obj
    {
        {} => { $crate::database::objects::Obj::from_map_unchecked( ::collections::HashMap::new()) };
        { $( $field:expr => $inner:expr ),+ , } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
        { $( $field:expr => $inner:expr ),+ } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
    }
    /// Given a list of field to `Value` pairs, returns an `Obj` with the fields and values.
    #[macro_export] macro_rules! try_obj
    {
        { $( $field:expr => $inner:expr ),+ , } => { try_obj!{ $( $field => $inner ),* }; };

        { $( $field:expr => $inner:expr ),+ } =>
        {
            {
                use $crate::database::objects::Obj;
                let mut _map = ::collections::HashMap::new();
                let mut _parent: Option<$crate::primitive::Value> = None;

                $( 
                    if $field == "^" { _parent = Some( $inner.into() ); }
                    else { _map.insert( $field.into(), $inner.into() ); }
                )*

                match _parent
                {
                    Some( parent ) => match parent.get_obj()
                    {
                        Ok( parent ) => Obj::from_map_with_parent( _map, parent),
                        e @ Err( _ ) => e,
                    }
                    None => Obj::from_map( _map),
                }
            }
        };
    }
    /// Writes attributes and formatted text to a `Terminal` or `Screen`.
    #[macro_export] macro_rules! term_write
    {
        ( $term:expr , $first:tt $($rest:tt)* ) =>
        {
            match $term.borrow_term_write_guard()
            {
                mut term =>
                {
                    let init = $crate::macros::Chain::init();
                    term_write!(@_INTERNAL main: term ; init ; $first $($rest)*)
                }
            }
        };
        
        ( @_INTERNAL main: $term:expr ; $result:expr ; ) => { $result };
        
        ( @_INTERNAL main: $term:expr ; $result:expr ; [ $($tt:tt)* ] $($rest:tt)* ) =>
        {
            term_write!
            (
                @_INTERNAL main: $term;
                term_write!(@_INTERNAL style: $term; $result; $($tt)*);
                $($rest)*
            )
        };
        
        ( @_INTERNAL main: $term:expr ; $result:expr ; ( $($tt:tt)* ) $($rest:tt)* ) =>
        {
            term_write!
            (
                @_INTERNAL main: $term;
                term_write!(@_INTERNAL format: $term; $result; $($tt)*);
                $($rest)*
            )
        };
        
        ( @_INTERNAL main: $term:expr ; $result:expr ; $tt:tt $($rest:tt)* ) =>
        {
            term_write!
            (
                @_INTERNAL main: $term;
                term_write!(@_INTERNAL literal: $term; $result; $tt);
                $($rest)*
            )
        };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; black ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Black)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; blue ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Blue)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; cyan ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Cyan)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; green ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Green)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; magenta ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Magenta)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; red ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Red)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; white ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::White)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; yellow ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_fg($crate::Color::Yellow)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; # black ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Black)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; # blue ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Blue)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; # cyan ) => 
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Cyan)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; # green ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Green)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; # magenta ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Magenta)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; # red ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Red)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; # white ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::White)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; # yellow ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg($crate::Color::Yellow)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; bold ) =>
        { $crate::macros::Chain::chain( $result, || $term.add_style($crate::Style::BOLD)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; italic ) =>
        { $crate::macros::Chain::chain( $result, || $term.add_style($crate::Style::ITALIC)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; reverse ) =>
        { $crate::macros::Chain::chain( $result, || $term.add_style($crate::Style::REVERSE)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; underline ) =>
        { $crate::macros::Chain::chain( $result, || $term.add_style($crate::Style::UNDERLINE)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; ! bold ) =>
        { $crate::macros::Chain::chain( $result, || $term.remove_style($crate::Style::BOLD)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; ! italic ) =>
        { $crate::macros::Chain::chain( $result, || $term.remove_style($crate::Style::ITALIC)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; ! reverse ) =>
        { $crate::macros::Chain::chain( $result, || $term.remove_style($crate::Style::REVERSE)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; ! underline ) =>
        { $crate::macros::Chain::chain( $result, || $term.remove_style($crate::Style::UNDERLINE)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; reset ) =>
        { $crate::macros::Chain::chain( $result, || $term.clear_attributes()) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; ! fg ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_fg(None)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; ! bg ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg(None)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; ! style ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_style(None)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; fg = $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_fg($e)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; bg = $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_bg($e)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; style = $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_style($e)) };
        
        ( @_INTERNAL style: $term:expr ; $result:expr ; style += $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || $term.add_style($e)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; style -= $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || $term.remove_style($e)) };

        ( @_INTERNAL style: $term:expr ; $result:expr ; theme = $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || $term.set_theme($e)) };
        
        ( @_INTERNAL format: $term:expr ; $result:expr ; : $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || write!($term, "{}", $e)) };

        ( @_INTERNAL format: $term:expr ; $result:expr ; ? $e:expr ) =>
        { $crate::macros::Chain::chain( $result, || write!($term, "{:?}", $e)) };
        
        ( @_INTERNAL format: $term:expr ; $result:expr ; $($tt:tt)* ) =>
        { $crate::macros::Chain::chain( $result, || write!($term, $($tt)*)) };
        
        ( @_INTERNAL literal: $term:expr ; $result:expr ; $lit:tt ) =>
        { $crate::macros::Chain::chain( $result, || $term.write_str(concat!($lit))) };
    }
    /// Writes attributes and formatted text to a `Terminal` or `Screen`.
    #[macro_export] macro_rules! term_writeln
    {
        ( $term:expr ) => { term_write!($term, "\n") };
        ( $term:expr , $($tt:tt)* ) => { term_write!($term, $($tt)* "\n") };
    }
    /// Expand a parametrized string.
    #[macro_export] macro_rules! expand
    {
        ($value:expr) => ( $crate::expand!($value;) );
        ($value:expr => $context:expr) => ( $crate::expand!($value => $context;) );
        ($value:expr; $($item:expr),*) => 
        ( $crate::expand!($value => &mut ::default::Default::default(); $($item),*) );
        ($value:expr => $context:expr; $($item:expr),*) =>
        ({
            let mut output = ::vec::Vec::new();
            $crate::expand!(&mut output, $value => $context; $($item),*).map(|()| output)
        });
        ($output:expr, $value:expr) => ( $crate::expand!($output, $value;) );
        ($output:expr, $value:expr => $context:expr) => ( $crate::expand!($output, $value => $context;) );
        ($output:expr, $value:expr; $($item:expr),*) => 
        ( $crate::expand!($output, $value => &mut ::default::Default::default(); $($item),*) );
        ($output:expr, $value:expr => $context:expr; $($item:expr),*) => 
        ({
            use $crate::expand::Expand;
            $value.expand($output, &[$($item.into()),*], $context)
        })
    }
    #[macro_export] macro_rules! constant_error
    {
        ($kind:expr, $message:expr $(,)?) =>
        {
            $crate::hint::must_use
            (
                $crate::io::Error::from_static_message( const { &$crate::io::SimpleMessage { kind: $kind, message: $message } } ) 
            );
        };
    }
    /// Facilitates chaining calls from either a `Terminal` or `Screen` lock.
    pub trait Chain: Sized
    {
        fn chain<F: FnOnce() -> Self>(self, f: F) -> Self;
        fn init() -> Self;
    }

    impl Chain for ()
    {
        fn chain<F: FnOnce() -> Self>(self, f: F) -> Self { f() }
        fn init() -> Self { }
    }

    impl Chain for io::Result<()>
    {
        fn chain<F: FnOnce() -> Self>(self, f: F) -> Self { self.and_then(|_| f()) }
        fn init() -> Self { Ok(()) }
    }

}
/// Memory allocation APIs.
pub mod alloc
{
    pub use std::alloc::{ * };
}
/// Utilities for dynamic typing or type reflection.
pub mod any
{
    pub use std::any::{ * };
}
/// SIMD and vendor intrinsics module.
pub mod arch
{
    pub use std::arch::x86_64::{ * };
}
/// Utilities for the array primitive type.
pub mod array
{
    pub use std::array::{ * };
}
/// Operations on ASCII strings and characters.
pub mod ascii
{
    pub use std::ascii::{ * };
}
/// Support for capturing a stack backtrace of an OS thread
pub mod backtrace
{
    pub use std::backtrace::{ * };
}
/// A module for working with borrowed data.
pub mod borrow
{
    pub use std::borrow::{ * };
}
/// The Box<T> type for heap allocation.
pub mod boxed
{
    pub use std::boxed::{ * };
}
/// Shareable mutable containers.
pub mod cell
{
    pub use std::cell::{ * };
}
/// Utilities for the char primitive type.
pub mod char
{
    pub use std::char::{ * };

    use ::
    {
        borrow::{ Cow },
        ops::{ Range, RangeFrom, RangeFull, RangeTo },
        str::{ CharIndices, from_utf8, from_utf8_unchecked },
        *,
    };
    /// The maximum number of bytes required to [encode](char::encode_utf8) a `char` to
    /// UTF-8 encoding.
    #[unstable(feature = "char_max_len", issue = "121714")]
    pub const MAX_LEN_UTF8: usize = char::MAX_LEN_UTF8;

    /// The maximum number of two-byte units required to [encode](char::encode_utf16) a `char`
    /// to UTF-16 encoding.
    #[unstable(feature = "char_max_len", issue = "121714")]
    pub const MAX_LEN_UTF16: usize = char::MAX_LEN_UTF16;
    pub const CTRL_MASK: u8 = 0x1f;
    pub const UNCTRL_BIT: u8 = 0x40;    
    /// Returns the control character corresponding to the given character.
    #[inline] pub fn ctrl(ch: char) -> char { ((ch as u8) & CTRL_MASK) as char }
    /// Returns the ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_upper(ch: char) -> char { ((ch as u8) | UNCTRL_BIT) as char }
    /// Returns the lowercase ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_lower(ch: char) -> char { unctrl_upper(ch).to_ascii_lowercase() }
    /// Iterator over string prefixes.
    pub struct Prefixes<'a>
    {
        s: &'a str,
        iter: CharIndices<'a>,
    }
    /// Returns an iterator over all non-empty prefixes of `s`, beginning with the shortest.
    #[inline] pub fn prefixes(s: &str) -> Prefixes
    {
        Prefixes
        {
            s,
            iter: s.char_indices(),
        }
    }

    impl<'a> Iterator for Prefixes<'a>
    {
        type Item = &'a str;
        fn next(&mut self) -> Option<&'a str> { self.iter.next().map(|(idx, ch)| &self.s[..idx + ch.len_utf8()]) }
    }
    /*
    pub fn repeat_char( ch: char, n: usize ) -> String */
    /// Returns a string consisting of a `char`, repeated `n` times.
    pub fn repeat( ch: char, n: usize ) -> String
    {
        let mut buf = [0; 4];
        let s = ch.encode_utf8( &mut buf );
        s.repeat( n )
    }
    /*
    pub fn forward_char( n:usize, s:&str, cur: usize ) -> usize */
    pub fn forward( n:usize, s:&str, cur: usize ) -> usize
    {
        let mut chars = s[cur..].char_indices().filter( |&( _, ch )| !is::combining_mark( ch ) );

        for _ in 0..n
        {
            match chars.next()
            {
                Some( _ ) => (),
                None => return s.len()
            }
        }

        match chars.next()
        {
            Some(( idx, _ )) => cur + idx,
            None => s.len()
        }
    }
    /*
    pub fn forward_search_char( n:usize, buf:&str, mut cur:usize, ch: char ) -> Option<usize> */
    pub fn forward_search( n:usize, buf:&str, mut cur:usize, ch: char ) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n
        {
            let off = match buf[cur..].chars().next()
            {
                Some( ch ) => ch.len_utf8(),
                None => break
            };

            match buf[cur + off..].find( ch )
            {
                Some( p ) =>
                {
                    cur += off + p;
                    pos = Some( cur );
                }

                None => break
            }
        }

        pos
    }
    /*
    pub fn backward_char( n:usize, s:&str, cur: usize ) -> usize */
    pub fn backward( n:usize, s:&str, cur: usize ) -> usize
    {
        let mut chars = s[..cur].char_indices().filter( |&( _, ch )| !is::combining_mark( ch ) );
        let mut res = cur;

        for _ in 0..n
        {
            match chars.next_back()
            {
                Some(( idx, _ )) => res = idx,
                None => return 0
            }
        }

        res
    }
    /*
    pub fn backward_search_char( n:usize, buf:&str, mut cur:usize, ch: char ) -> Option<usize> */
    pub fn backward_search( n:usize, buf:&str, mut cur:usize, ch: char ) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n
        {
            match buf[..cur].rfind( ch )
            {
                Some( p ) =>
                {
                    cur = p;
                    pos = Some( cur );
                }

                None => break
            }
        }

        pos
    }
    /// Returns the first character in the buffer, if it contains any valid characters.
    pub fn first_char( buf:&[u8] ) -> io::Result<Option<char>>
    {
        match from_utf8( buf )
        {
            Ok( s ) => Ok( s.chars().next() ),
            Err( e ) =>
            {
                if e.error_len().is_some()
                {
                    return Err( io::Error::new( io::ErrorKind::InvalidData, "invalid utf-8 input received" ) );
                }

                let valid = e.valid_up_to();
                let s = unsafe { from_utf8_unchecked( &buf[..valid] ) };
                Ok( s.chars().next() )
            }
        }
    }
    /// Returns a character sequence escaped( `\e` ) for user-facing display.
    pub fn escape_sequence( s: &str ) -> String
    {
        let mut res = String::with_capacity( s.len() );

        for ch in s.chars()
        {
            match ch
            {
                ESCAPE => res.push_str( r"\e"),
                RUBOUT => res.push_str( r"\C-?"),
                '\\' => res.push_str( r"\\"),
                '\'' => res.push_str( r"\'"),
                '"' => res.push_str( r#"\""#),
                
                ch if is::ctrl( ch ) =>
                {
                    res.push_str( r"\C-" );
                    res.push( unctrl_lower( ch ) );
                }

                ch => res.push( ch)
            }
        }

        res
    }
    /* pub fn char_width(ch: char) -> Option<usize> */
    /// Returns the width of a character in the terminal.
    #[inline] pub fn width(ch: char) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
    /* pub fn format_char(...) -> String */
    pub fn format( ch: char ) -> String
    {
        match ch
        {
            '\n' => String::from( "\\n" ),
            ch => format!( "{}", ch ),
        }
    }
    /// Encodes a raw `u32` value as UTF-8 into the provided byte buffer,
    /// and then returns the subslice of the buffer that contains the encoded character.
    #[inline] pub const fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> &mut [u8]
    {
        let len = len_utf8(code);
        if dst.len() < len {
            const_panic!(
                "encode_utf8: buffer does not have enough bytes to encode code point",
                "encode_utf8: need {len} bytes to encode U+{code:04X} but buffer has just {dst_len}",
                code: u32 = code,
                len: usize = len,
                dst_len: usize = dst.len(),
            );
        }
    }
    /// Encodes a raw `u32` value as UTF-8 into the byte buffer pointed to by `dst`.
    #[inline] pub const unsafe fn encode_utf8_raw_unchecked(code: u32, dst: *mut u8)
    {
        unsafe
        {
            let len = len_utf8(code);
            match len {
                1 => {
                    *dst = code as u8;
                }
                2 => {
                    *dst = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
                    *dst.add(1) = (code & 0x3F) as u8 | TAG_CONT;
                }
                3 => {
                    *dst = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
                    *dst.add(1) = (code >> 6 & 0x3F) as u8 | TAG_CONT;
                    *dst.add(2) = (code & 0x3F) as u8 | TAG_CONT;
                }
                4 => {
                    *dst = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;
                    *dst.add(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;
                    *dst.add(2) = (code >> 6 & 0x3F) as u8 | TAG_CONT;
                    *dst.add(3) = (code & 0x3F) as u8 | TAG_CONT;
                }
                // SAFETY: `char` always takes between 1 and 4 bytes to encode in UTF-8.
                _ => ::hint::unreachable_unchecked(),
            }
        }
    }
    /// Encodes a raw `u32` value as native endian UTF-16 into the provided `u16` buffer,
    /// and then returns the subslice of the buffer that contains the encoded character.
    #[inline] pub const fn encode_utf16_raw(mut code: u32, dst: &mut [u16]) -> &mut [u16]
    {
        unsafe
        {
            let len = len_utf16(code);
            match (len, &mut *dst)
            {
                (1, [a, ..]) => {
                    *a = code as u16;
                }
                (2, [a, b, ..]) => {
                    code -= 0x1_0000;
                    *a = (code >> 10) as u16 | 0xD800;
                    *b = (code & 0x3FF) as u16 | 0xDC00;
                }
                _ => {
                    const_panic!(
                        "encode_utf16: buffer does not have enough bytes to encode code point",
                        "encode_utf16: need {len} bytes to encode U+{code:04X} but buffer has just {dst_len}",
                        code: u32 = code,
                        len: usize = len,
                        dst_len: usize = dst.len(),
                    )
                }
            };
            slice::from_raw_parts_mut(dst.as_mut_ptr(), len)
        }
    }
}
/// The Clone trait for types that cannot be ‘implicitly copied’.
pub mod clone
{
    pub use std::clone::{ * };
}
/// Utilities for comparing and ordering values.
pub mod cmp
{
    pub use std::cmp::{ * };
}
/// Collection types.
pub mod collections
{
    pub use std::collections::{ * };
    
    use ::
    {
        iter::{ FromIterator },
        mem::{ replace },
        *,
    };
    /* Utilities for manipulating raw input sequences. */

    /// Contains a set of string sequences, mapped to a value.
    #[derive( Clone, Debug, Default )]
    pub struct SequenceMap<K, V>
    {
        sequences: Vec<( K, V )>,
    }
    /// Represents the result of a `SequenceMap::find` operation.
    #[derive( Copy, Clone, Debug, Eq, PartialEq )]
    pub enum FindResult<V>
    {
        /// No contained sequences begin with the provided input sequence.
        NotFound,
        /// One or more sequences begin with the provided input sequence,
        /// but the sequence does not represent a complete sequence.
        Incomplete,
        /// A sequence was found exactly matching the input sequence;
        /// additionally, one or more sequences begin with the input sequence.
        Undecided( V ),
        /// A sequence was found exactly matching the input sequence;
        /// no additional partially-matching sequences exist.
        Found( V ),
    }

    impl<'a, V: Clone> FindResult<&'a V>
    {
        /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents of the result value.
        pub fn cloned( self ) -> FindResult<V>
        {
            match self
            {
                FindResult::NotFound => FindResult::NotFound,
                FindResult::Incomplete => FindResult::Incomplete,
                FindResult::Undecided( v ) => FindResult::Undecided( v.clone() ),
                FindResult::Found( v ) => FindResult::Found( v.clone() ),
            }
        }
    }

    impl<K: AsRef<str>, V> SequenceMap<K, V>
    {
        /// Creates an empty `SequenceMap`.
        pub fn new() -> SequenceMap<K, V> { SequenceMap::with_capacity( 0 ) }
        /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
        pub fn with_capacity( n: usize ) -> SequenceMap<K, V>
        {
            SequenceMap
            {
                sequences: Vec::with_capacity( n ),
            }
        }
        /// Returns a slice of all contained sequences, sorted by key.
        pub fn sequences( &self ) -> &[( K, V )] { &self.sequences }
        /// Returns a mutable slice of all contained sequences, sorted by key.
        pub fn sequences_mut( &mut self ) -> &mut [( K, V )] { &mut self.sequences }
        /// Returns an `Entry` for the given key.
        pub fn entry( &mut self, key: K ) -> Entry<K, V>
        {
            match self.search( key.as_ref() )
            {
                Ok( n ) => Entry::Occupied( OccupiedEntry
                {
                    map: self,
                    index: n,
                } ),

                Err( n ) => Entry::Vacant( VacantEntry
                {
                    map: self,
                    key,
                    index: n,
                } )
            }
        }
        /// Performs a search for a partial or complete sequence match.
        pub fn find( &self, key:&str ) -> FindResult<&V>
        {
            let ( n, found ) = match self.search( key )
            {
                Ok( n ) => ( n, true ),
                Err( n ) => ( n, false )
            };

            let incomplete = self.sequences.get( n + ( found as usize ) )
            .map_or( false, |&( ref next, _ )| next.as_ref().starts_with( key ) );

            match ( found, incomplete )
            {
                ( false, false ) => FindResult::NotFound,
                ( false, true ) => FindResult::Incomplete,
                ( true, false ) => FindResult::Found( &self.sequences[n].1 ),
                ( true, true ) => FindResult::Undecided( &self.sequences[n].1 ),
            }
        }
        /// Returns the corresponding value for the given sequence.
        pub fn get( &self, key:&str ) -> Option<&V>
        {
            match self.search( key )
            {
                Ok( n ) => Some( &self.sequences[n].1 ),
                Err( _ ) => None
            }
        }
        /// Returns a mutable reference to the corresponding value for the given sequence.
        pub fn get_mut( &mut self, key:&str ) -> Option<&mut V>
        {
            match self.search( key )
            {
                Ok( n ) => Some( &mut self.sequences[n].1 ),
                Err( _ ) => None
            }
        }
        /// Inserts a key-value pair into the map.
        pub fn insert( &mut self, key: K, value: V ) -> Option<V>
        {
            match self.search( key.as_ref() )
            {
                Ok( n ) => Some( replace( &mut self.sequences[n], ( key, value ) ).1 ),
                Err( n ) =>
                {
                    self.sequences.insert( n, ( key, value ) );
                    None
                }
            }
        }
        /// Removes a key-value pair from the map.
        pub fn remove( &mut self, key:&str ) -> Option<( K, V )>
        {
            match self.search( key )
            {
                Ok( n ) => Some( self.sequences.remove( n ) ),
                Err( _ ) => None
            }
        }

        fn search( &self, key:&str ) -> Result<usize, usize>
        {
            self.sequences.binary_search_by_key( &key, |&( ref k, _ )| &k.as_ref() )
        }
    }

    impl<K: AsRef<str>, V> From<Vec<( K, V )>> for SequenceMap<K, V>
    {
        /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
        fn from( mut sequences: Vec<( K, V )> ) -> SequenceMap<K, V>
        {
            sequences.sort_by( |a, b| a.0.as_ref().cmp( b.0.as_ref() ) );
            sequences.dedup_by( |a, b| a.0.as_ref() == b.0.as_ref() );
            SequenceMap{sequences}
        }
    }

    impl<K: AsRef<str>, V> FromIterator<( K, V )> for SequenceMap<K, V>
    {
        /// Creates a `SequenceMap` from an iterator of key-value pairs.
        fn from_iter<I: IntoIterator<Item=( K, V )>>( iter: I ) -> Self
        {
            let iter = iter.into_iter();
            let mut map = SequenceMap::with_capacity( iter.size_hint().0 );

            for ( k, v ) in iter
            {
                map.insert( k, v );
            }

            map
        }
    }
    /// A view into a single entry of a `SequenceMap`, which may be either occupied or vacant.
    pub enum Entry<'a, K: 'a, V: 'a>
    {
        /// An occupied entry
        Occupied( OccupiedEntry<'a, K, V> ),
        /// A vacant entry
        Vacant( VacantEntry<'a, K, V> ),
    }

    impl<'a, K, V> Entry<'a, K, V>
    {
        /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.
        pub fn and_modify<F: FnOnce( &mut V )>( self, f: F ) -> Self
        {
            match self
            {
                Entry::Occupied( mut ent ) =>
                {
                    f( ent.get_mut() );
                    Entry::Occupied( ent )
                }

                Entry::Vacant( ent ) => Entry::Vacant( ent )
            }
        }
        /// Returns a mutable reference to the entry value, inserting the provided default if the entry is vacant.
        pub fn or_insert( self, default: V ) -> &'a mut V
        {
            match self
            {
                Entry::Occupied( ent ) => ent.into_mut(),
                Entry::Vacant( ent ) => ent.insert( default )
            }
        }
        /// Returns a mutable reference to the entry value,
        /// inserting a value using the provided closure if the entry is vacant.
        pub fn or_insert_with<F: FnOnce() -> V>( self, default: F ) -> &'a mut V
        {
            match self
            {
                Entry::Occupied( ent ) => ent.into_mut(),
                Entry::Vacant( ent ) => ent.insert( default() )
            }
        }
        /// Returns a borrowed reference to the entry key.
        pub fn key( &self ) -> &K
        {
            match *self
            {
                Entry::Occupied( ref ent ) => ent.key(),
                Entry::Vacant( ref ent ) => ent.key(),
            }
        }
    }

    impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V>
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            match *self
            {
                Entry::Occupied( ref ent ) =>
                f.debug_tuple( "Entry" )
                .field( ent )
                .finish(),

                Entry::Vacant( ref ent ) =>
                f.debug_tuple( "Entry" )
                .field( ent )
                .finish()
            }
        }
    }
    /// A view into an occupied entry in a `SequenceMap`.
    pub struct OccupiedEntry<'a, K: 'a, V: 'a>
    {
        map:&'a mut SequenceMap<K, V>,
        index:usize,
    }

    impl<'a, K, V> OccupiedEntry<'a, K, V>
    {
        /// Returns a borrowed reference to the entry key.
        pub fn key( &self ) -> &K { &self.map.sequences[self.index].0 }
        /// Returns a borrowed reference to the entry value.
        pub fn get( &self ) -> &V { &self.map.sequences[self.index].1 }
        /// Returns a mutable reference to the entry value.
        pub fn get_mut( &mut self ) -> &mut V { &mut self.map.sequences[self.index].1 }
        /// Converts the `OccupiedEntry` into a mutable reference whose lifetime is bound to the `SequenceMap`.
        pub fn into_mut( self ) -> &'a mut V { &mut self.map.sequences[self.index].1 }
        /// Replaces the entry value with the given value, returning the previous value.
        pub fn insert( &mut self, value: V ) -> V { replace( self.get_mut(), value ) }
        /// Removes the entry and returns the value.
        pub fn remove( self ) -> V { self.map.sequences.remove( self.index ).1 }
        /// Removes the entry and returns the key-value pair.
        pub fn remove_entry( self ) -> ( K, V ) { self.map.sequences.remove( self.index ) }
    }

    impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V>
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            f.debug_struct( "OccupiedEntry" )
            .field( "key", self.key() )
            .field( "value", self.get() )
            .finish()
        }
    }
    /// A view into a vacant entry in a `SequenceMap`.
    pub struct VacantEntry<'a, K: 'a, V: 'a>
    {
        map:&'a mut SequenceMap<K, V>,
        key: K,
        index:usize,
    }

    impl<'a, K, V> VacantEntry<'a, K, V>
    {
        /// Returns a borrowed reference to the entry key.
        pub fn key( &self ) -> &K { &self.key }
        /// Consumes the `VacantEntry` and returns ownership of the key.
        pub fn into_key( self ) -> K { self.key }
        /// Consumes the `VacantEntry` and inserts a value, returning a mutable
        /// reference to its place in the `SequenceMap`.
        pub fn insert( self, value: V ) -> &'a mut V
        {
            self.map.sequences.insert( self.index, ( self.key, value ) );
            &mut self.map.sequences[self.index].1
        }
    }

    impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V>
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            f.debug_tuple( "VacantEntry" )
            .field( self.key() )
            .finish()
        }
    }
}
/// Custom Commands
pub mod command
{
    //! Defines the set of line editing commands
    use ::
    {
        borrow::Cow::{ self, Borrowed, Owned },
        char::{ escape_sequence },
        *,
    };

    macro_rules! define_commands
    {
        ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) =>
        {
            /// Represents a command to modify `Reader` state
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum Command
            {
                $( #[$meta] $name , )+
                /// Custom application-defined command
                Custom( Cow<'static, str> ),
                /// Execute a given key sequence
                Macro( Cow<'static, str> ),
            }

            /// List of all command names
            pub static COMMANDS:&[&str] = &[ $( $str ),+ ];

            impl fmt::Display for Command
            {
                fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
                {
                    match *self
                    {
                        $( Command::$name => f.write_str( $str ) , )+
                        Command::Custom( ref s ) => f.write_str( s ),
                        Command::Macro( ref s ) => write!( f, "\"{}\"",
                            escape_sequence( s ) )
                    }
                }
            }

            impl Command
            {
                /// Constructs a command from a `'static str` reference.
                pub fn from_str( name:&'static str ) -> Command
                {
                    Command::opt_from_str( name ).unwrap_or_else( || Command::Custom( Borrowed( name ) ) )
                }
                /// Constructs a command from a non-`'static` string-like type.
                pub fn from_string<T>( name:T ) -> Command where
                T: AsRef<str> + Into<String>
                {
                    Command::opt_from_str( name.as_ref() )
                    .unwrap_or_else( || Command::Custom( Owned( name.into() ) ) )
                }

                fn opt_from_str( s:&str ) -> Option<Command>
                {
                    match s
                    {
                        $( $str => Some( Command::$name ), )+
                        _ => None
                    }
                }
            }
        }
    }

    define_commands!
    {
        /// Abort history search
        Abort => "abort",
        /// Accepts the current input line
        AcceptLine => "accept-line",
        /// Perform completion
        Complete => "complete",
        /// Insert all completions into the input buffer
        InsertCompletions => "insert-completions",
        /// Show possible completions
        PossibleCompletions => "possible-completions",
        /// Insert the next possible completion
        MenuComplete => "menu-complete",
        /// Insert the previous possible completion
        MenuCompleteBackward => "menu-complete-backward",
        /// Begin numeric argument input
        DigitArgument => "digit-argument",
        /// Insert character or sequence at the cursor
        SelfInsert => "self-insert",
        /// Inserts a tab character
        TabInsert => "tab-insert",
        /// Toggles insert/overwrite mode
        OverwriteMode => "overwrite-mode",
        /// Insert a comment and accept input
        InsertComment => "insert-comment",
        /// Move the cursor backward one character
        BackwardChar => "backward-char",
        /// Move the cursor forward one character
        ForwardChar => "forward-char",
        /// Search for a given character
        CharacterSearch => "character-search",
        /// Search backward for a given character
        CharacterSearchBackward => "character-search-backward",
        /// Move the cursor backward one word
        BackwardWord => "backward-word",
        /// Move the cursor forward one word
        ForwardWord => "forward-word",
        /// Kill all characters before the cursor
        BackwardKillLine => "backward-kill-line",
        /// Kill all characters after the cursor
        KillLine => "kill-line",
        /// Kill a word before the cursor
        BackwardKillWord => "backward-kill-word",
        /// Kill a word after the cursor
        KillWord => "kill-word",
        /// Kill a word before the cursor, delimited by whitespace
        UnixWordRubout => "unix-word-rubout",
        /// Clear the screen
        ClearScreen => "clear-screen",
        /// Move the cursor to the beginning of the line
        BeginningOfLine => "beginning-of-line",
        /// Move the cursor to the end of the line
        EndOfLine => "end-of-line",
        /// Delete one character before the cursor
        BackwardDeleteChar => "backward-delete-char",
        /// Delete one character after the cursor
        DeleteChar => "delete-char",
        /// Drag the character before the cursor forward
        TransposeChars => "transpose-chars",
        /// Drag the word before the cursor forward
        TransposeWords => "transpose-words",
        /// Move to the first line of history
        BeginningOfHistory => "beginning-of-history",
        /// Move to the last line of history
        EndOfHistory => "end-of-history",
        /// Select next line in history
        NextHistory => "next-history",
        /// Select previous line in history
        PreviousHistory => "previous-history",
        /// Incremental search in history
        ForwardSearchHistory => "forward-search-history",
        /// Incremental reverse search in history
        ReverseSearchHistory => "reverse-search-history",
        /// Non-incremental forward history search using input up to the cursor
        HistorySearchForward => "history-search-forward",
        /// Non-incremental backward history search using input up to the cursor
        HistorySearchBackward => "history-search-backward",
        /// Insert literal character
        QuotedInsert => "quoted-insert",
        /// Insert text into buffer from the kill ring
        Yank => "yank",
        /// Rotate the kill ring and yank the new top
        YankPop => "yank-pop",
    }
    /// Describes the category of a command
    #[derive( Copy, Clone, Debug, Eq, PartialEq )]
    pub enum Category
    {
        /// Completion command
        Complete,
        /// Kill command
        Kill,
        /// Non-incremental search command
        Search,
        /// Incremental search command
        IncrementalSearch,
        /// Yank command
        Yank,
        /// Digit argument command
        Digit,
        /// Other command
        Other,
    }

    impl Command
    {
        /// Returns the category of the command
        pub fn category( &self ) -> Category
        {
            use self::Command::*;

            match *self
            {
                DigitArgument => Category::Digit,
                Complete | InsertCompletions | PossibleCompletions |
                MenuComplete | MenuCompleteBackward => Category::Complete,
                BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                HistorySearchForward | HistorySearchBackward => Category::Search,
                Yank | YankPop => Category::Yank,
                _ => Category::Other
            }
        }
    }

    impl Default for Command
    {
        fn default() -> Self { Command::Custom( Borrowed( "" ) ) }
    }

    pub mod api
    {
        /**/
        pub mod alias
        {

        }
        /**/
        pub mod bg
        {

        }
        /**/
        pub mod cd
        {

        }
        /**/
        pub mod cinfo
        {

        }
        /**/
        pub mod exec
        {

        }
        /**/
        pub mod exit
        {

        }
        /**/
        pub mod export
        {

        }
        /**/
        pub mod fg
        {

        }
        /**/
        pub mod history
        {

        }
        /**/
        pub mod jobs
        {

        }
        /**/
        pub mod read
        {

        }
        /**/
        pub mod source
        {

        }
        /**/
        pub mod unalias
        {

        }
        /**/
        pub mod vox
        {

        }
        /**/
        pub mod ulimit
        {

        }
        /**/
        pub mod minfd
        {

        }
        /**/
        pub mod set
        {

        }
        /**/
        pub mod unpath
        {

        }
        /**/
        pub mod unset
        {

        }
        /**/
        pub mod utils
        {

        }
    }
}
/// API for connecting to a flat file database
pub mod connect
{

}
/// Traits for conversions between types.
pub mod convert
{
    pub use std::convert::{ * };
}
/// Flat file database using the OVER data format
pub mod database
{
    use ::
    {
        fs::{ File },
        io::{ Write },
        *,
    };
    /// Indent step in .over files.
    pub const INDENT_STEP: usize = 4;

    pub mod arrays
    {
        //! An [`Arr`] container which can hold an arbitrary number of elements of a single type.
        use ::
        {
            database::{ INDENT_STEP },
            error::over::{ OverError, OverResult },
            parsers::{ over::{ format::{ Format }, }, },
            primitive::{ Type, Value },
            slice::{ Iter },
            sync::{ Arc },
            *,
        };
        
        #[derive( Clone, Debug )]
        struct ArrInner
        {
            vec: Vec<Value>,
            inner_t: Type,
        }
        /// `Arr` struct.
        #[derive( Clone, Debug )]
        pub struct Arr
        {
            inner: Arc<ArrInner>,
        }

        impl Arr
        {
            /// Returns a new `Arr` from the given vector of `Value`s.
            pub fn from_vec( vec: Vec<Value> ) -> OverResult<Arr> 
            {
                let mut tcur = Type::Any;
                let mut has_any = true;

                for value in &vec 
                {
                    let tnew = value.get_type();

                    if has_any
                    {
                        match Type::most_specific( &tcur, &tnew ) 
                        {
                            Some(( t, any) ) => 
                            {
                                tcur = t;
                                has_any = any;
                            }
                            None => return Err( OverError::ArrTypeMismatch( tcur, tnew)),
                        }
                    }
                    else if tcur != tnew { return Err( OverError::ArrTypeMismatch( tcur, tnew ) ); }
                }

                Ok( Arr 
                {
                    inner: Arc::new( ArrInner { vec, inner_t: tcur }),
                })
            }
            /// Returns a new `Arr` from the given vector of `Value`s without checks.
            pub fn from_vec_unchecked( vec: Vec<Value>, inner_t: Type ) -> Arr
            {
                Arr
                {
                    inner: Arc::new( ArrInner { vec, inner_t }),
                }
            }
            /// Returns a reference to the inner vec of this `Arr`.
            pub fn vec_ref( &self ) -> &Vec<Value> { &self.inner.vec }
            /// Iterates over each `Value` in `self`, applying `Fn` `f`.
            pub fn with_each<F>( &self, mut f: F)
            where
            F: FnMut( &Value)
            {
                for value in &self.inner.vec
                {
                    f( value)
                }
            }
            /// Gets the value at `index`.
            pub fn get( &self, index: usize ) -> OverResult<Value>
            {
                if index >= self.inner.vec.len() { Err( OverError::ArrOutOfBounds( index)) } 
                else { Ok( self.inner.vec[index].clone()) }
            }
            /// Returns the type of all elements in this `Arr`.
            pub fn inner_type( &self ) -> Type { self.inner.inner_t.clone() }
            /// Returns the length of this `Arr`.
            pub fn len( &self ) -> usize { self.inner.vec.len() }
            /// Returns whether this `Arr` is empty.
            pub fn is_empty( &self ) -> bool { self.inner.vec.is_empty() }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq( &self, other: &Self ) -> bool { Arc::ptr_eq( &self.inner, &other.inner) }
            /// Returns an iterator over the Arr.
            pub fn iter( &self ) -> Iter<Value> { self.vec_ref().iter() }
        }

        impl Default for Arr
        {
            fn default() -> Self { Self::from_vec_unchecked( vec![], Type::Any) }
        }

        impl fmt::Display for Arr
        {
            fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
            { write!( f, "{}", self.format( true, INDENT_STEP)) }
        }

        impl PartialEq for Arr
        {
            fn eq( &self, other: &Self ) -> bool
            {
                if self.inner.inner_t != other.inner.inner_t { return false; }
                self.inner.vec == other.inner.vec
            }
        }
    }
    pub use self::arrays::{ Arr };

    pub mod objects
    {
        //! A hashmap of keys to values, where values can be any type, including other objects.
        use ::
        {
            collections::{ hash_map::{ Iter, Keys, Values }, HashMap, },
            database::
            {
                Arr, Tup, INDENT_STEP
            },
            error::over::{ OverError, OverResult },
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ Zero },
            },
            parsers::over::
            {
                self as parse, 
                format::{ Format },
            },
            primitive::{ Type, Value },
            str::{ FromStr },
            sync::{ Arc, atomic::{ AtomicUsize, Ordering }, },
            *,
        };
        
        lazy_static!
        {
            static ref CUR_ID: AtomicUsize = AtomicUsize::new( 0 );
        }
        
        macro_rules! get_fn
        {
            ( $doc:expr, $name:tt, $type:ty ) =>
            {
                #[doc=$doc]
                pub fn $name( &self, field: &str ) -> OverResult<$type>
                {
                    match self.get( field)
                    {
                        Some( value ) =>
                        {
                            match value.$name()
                            {
                                Ok( result ) => Ok( result),
                                e @ Err( _ ) => e,
                            }
                        }
                        
                        None => Err( OverError::FieldNotFound( field.into())),
                    }
                }
            }
        }

        #[derive( Clone, Debug )]
        struct ObjInner
        {
            map: HashMap<String, Value>,
            parent: Option<Obj>,
            id: usize,
        }
        /// `Obj` struct.
        #[derive( Clone, Debug )]
        pub struct Obj
        {
            inner: Arc<ObjInner>,
        }

        impl Obj
        {
            /// Returns a new `Obj` created from the given `HashMap`.
            pub fn from_map( obj_map: HashMap<String, Value> ) -> OverResult<Obj>
            {
                for field in obj_map.keys()
                {
                    if !Self::is_valid_field( field )
                    { return Err( OverError::InvalidFieldName( ( *field).clone() ) ); }
                }

                let id = get_id();

                Ok( Obj
                {
                    inner: Arc::new( ObjInner
                    {
                        map: obj_map,
                        parent: None,
                        id,
                    }),
                })
            }
            /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
            pub fn from_map_with_parent( obj_map: HashMap<String, Value>, parent: Obj ) -> OverResult<Obj>
            {
                for field in obj_map.keys()
                {
                    if !Self::is_valid_field( field )
                    { return Err( OverError::InvalidFieldName( field.clone() ) ); }
                }

                let id = get_id();

                Ok( Obj
                {
                    inner: Arc::new( ObjInner
                    {
                        map: obj_map,
                        parent: Some( parent),
                        id,
                    }),
                })
            }
            /// Returns a new `Obj` created from the given `HashMap`.
            pub fn from_map_unchecked( obj_map: HashMap<String, Value> ) -> Obj
            {
                let id = get_id();
                Obj
                {
                    inner: Arc::new( ObjInner
                    {
                        map: obj_map,
                        parent: None,
                        id,
                    }),
                }
            }
            /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
            pub fn from_map_with_parent_unchecked( obj_map: HashMap<String, Value>, parent: Obj ) -> Obj
            {
                let id = get_id();
                Obj
                {
                    inner: Arc::new( ObjInner
                    {
                        map: obj_map,
                        parent: Some( parent),
                        id,
                    }),
                }
            }
            /// Returns the ID of this `Obj`.
            pub fn id( &self ) -> usize { self.inner.id }
            /// Returns a reference to the inner map of this `Obj`.
            pub fn map_ref( &self ) -> &HashMap<String, Value> { &self.inner.map }
            /// Returns a new `Obj` loaded from a file.
            pub fn from_file( path: &str ) -> OverResult<Obj> { Ok( parse::load_from_file( path)? ) }
            /// Writes this `Obj` to given file in `.over` representation.
            ///
            /// # Notes
            /// Note that the fields of the `Obj` will be output in an unpredictable order.
            /// Also note that shorthand in the original file, including variables and file includes,
            /// is not preserved when parsing the file, and will not appear when writing to another file.
            pub fn write_to_file( &self, path: &str ) -> OverResult<()>
            {
                write_file_str( path, &self.write_str())?;
                Ok( ())
            }
            /// Writes this `Obj` to a `String`.
            pub fn write_str( &self ) -> String { self.format( false, 0 ) }
            /// Iterates over each `( String, Value)` pair in `self`, applying `f`.
            pub fn with_each<F>( &self, mut f: F ) where
            F: FnMut( &String, &Value)
            {
                for ( field, value ) in &self.inner.map
                {
                    f( field, value)
                }
            }
            /// Returns the number of fields for this `Obj` ( parent fields not included).
            pub fn len( &self ) -> usize { self.inner.map.len() }
            /// Returns whether this `Obj` is empty.
            pub fn is_empty( &self ) -> bool { self.inner.map.is_empty() }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq( &self, other: &Self ) -> bool { Arc::ptr_eq( &self.inner, &other.inner ) }
            /// Returns true if this `Obj` contains `field`.
            pub fn contains( &self, field: &str ) -> bool { self.inner.map.contains_key( field ) }
            /// Gets the `Value` associated with `field`.
            pub fn get( &self, field: &str ) -> Option<Value>
            {
                match self.inner.map.get( field)
                {
                    Some( value ) => Some( value.clone()),
                    None => match self.inner.parent
                    {
                        Some( ref parent ) => parent.get( field),
                        None => None,
                    },
                }
            }
            /// Gets the `Value` associated with `field` and the `Obj` where it was found.
            pub fn get_with_source( &self, field: &str ) -> Option<( Value, Obj)>
            {
                match self.inner.map.get( field)
                {
                    Some( value ) => Some(( value.clone(), self.clone())),
                    None => match self.inner.parent
                    {
                        Some( ref parent ) => parent.get_with_source( field),
                        None => None,
                    },
                }
            }
            get_fn!
            ( 
                "Returns the `bool` found at `field`.",
                get_bool,
                bool
            );
            get_fn!
            ( 
                "Returns the `BigInt` found at `field`.",
                get_int,
                BigInt
            );
            get_fn!
            ( 
                "Returns the `BigRational` found at `field`.",
                get_frac,
                BigRational
            );
            get_fn!
            ( 
                "Returns the `char` found at `field`.",
                get_char,
                char
            );
            get_fn!
            ( 
                "Returns the `String` found at `field`.",
                get_str,
                String
            );
            get_fn!
            ( 
                "Returns the `Arr` found at `field`.",
                get_arr,
                Arr
            );
            get_fn!
            ( 
                "Returns the `Tup` found at `field`.",
                get_tup,
                Tup
            );
            get_fn!
            ( 
                "Returns the `Obj` found at `field`.",
                get_obj,
                Obj
            );
            /// Returns whether this `Obj` has a parent.
            pub fn has_parent( &self ) -> bool { self.inner.parent.is_some() }
            /// Returns the parent for this `Obj`.
            pub fn get_parent( &self ) -> Option<Obj>
            {
                match self.inner.parent
                {
                    Some( ref parent ) => Some( parent.clone()),
                    None => None,
                }
            }
            /// Returns true if `field` is a valid field name for an `Obj`.
            pub fn is_valid_field( field: &str ) -> bool
            {
                let mut first = true;

                for ch in field.chars()
                {
                    if first
                    {
                        if !Self::is_valid_field_char( ch, true ) { return false; }
                        first = false;
                    }

                    else if !Self::is_valid_field_char( ch, false ) { return false; }
                }

                true
            }
            /// Returns true if the given char is valid for a field, depending on whether its the first char or not.
            pub fn is_valid_field_char( ch: char, first: bool ) -> bool
            {
                match ch
                {
                    ch if ch.is_alphabetic() => true,
                    ch if is_digit( ch ) => !first,
                    '_' => true,
                    '^' => first,
                    _ => false,
                }
            }
            /// An iterator visiting all fields ( keys ) in arbitrary order.
            pub fn keys( &self ) -> Keys<String, Value> { self.map_ref().keys() }
            /// An iterator visiting all values in arbitrary order.
            pub fn values( &self ) -> Values<String, Value> { self.map_ref().values() }
            /// An iterator visiting all field-value pairs in arbitrary order.
            pub fn iter( &self ) -> Iter<String, Value> { self.map_ref().iter() }
        }

        impl Default for Obj
        {
            fn default() -> Self { Self::from_map_unchecked( map! {} ) }
        }

        impl fmt::Display for Obj
        {
            fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
            {
                write!( f, "{}", self.format( true, INDENT_STEP))
            }
        }

        impl FromStr for Obj
        {
            type Err = OverError;
            fn from_str( s: &str ) -> Result<Self, Self::Err> { Ok( parse::load_from_str( s)? ) }
        }
        /// For two Objs to be equal, the following two checks must pass:
        /// 1. If either Obj has a parent, then both must have parents and the parents must be equal.
        /// 2. The two Objs must have all the same fields pointing to the same values.
        impl PartialEq for Obj
        {
            fn eq( &self, other: &Self ) -> bool
            {
                let inner = &self.inner;
                let other_inner = &other.inner;
                
                if inner.parent.is_some() && other_inner.parent.is_some()
                {
                    let parent = self.get_parent().unwrap();
                    let other_parent = other.get_parent().unwrap();
                    if parent != other_parent { return false; }
                }
                
                else if !( inner.parent.is_none() && other_inner.parent.is_none() ) { return false; }
                
                inner.map == other_inner.map
            }
        }

        fn get_id() -> usize { CUR_ID.fetch_add( 1, Ordering::Relaxed ) }
    }
    pub use self::objects::{ Obj };

    pub mod tuples
    {
        //! A tuple container which can hold elements of different types.
        use ::
        {
            database::{ INDENT_STEP },
            error::over::{ OverError, OverResult },
            parsers::over::format::Format,
            primitive::{ Type, Value },
            slice::{ Iter },
            sync::{ Arc },
            *,
        };

        #[derive( Clone, Debug )]
        struct TupInner
        {
            vec: Vec<Value>,
            inner_tvec: Vec<Type>,
        }
        /// `Tup` struct.
        #[derive( Clone, Debug )]
        pub struct Tup
        {
            inner: Arc<TupInner>,
        }

        impl Tup
        {
            /// Returns a new `Tup` from the given vector of `Value`s.
            pub fn from_vec( values: Vec<Value> ) -> Tup
            {
                let tvec: Vec<Type> = values.iter().map( |val| val.get_type()).collect();
                Tup
                {
                    inner: Arc::new( TupInner
                    {
                        vec: values,
                        inner_tvec: tvec,
                    }),
                }
            }
            /// Returns a reference to the inner vec of this `Tup`.
            pub fn vec_ref( &self ) -> &Vec<Value> { &self.inner.vec }
            /// Iterates over each `Value` in `self`, applying `Fn` `f`.
            pub fn with_each<F>( &self, mut f: F ) where
            F: FnMut( &Value)
            {
                for value in &self.inner.vec
                {
                    f( value)
                }
            }
            /// Gets the value at `index`.
            pub fn get( &self, index: usize ) -> OverResult<Value>
            {
                if index >= self.inner.vec.len() { Err( OverError::TupOutOfBounds( index) ) }
                else { Ok( self.inner.vec[index].clone() ) }
            }
            /// Returns the type vector of this `Tup`.
            pub fn inner_type_vec( &self ) -> Vec<Type> { self.inner.inner_tvec.clone() }
            /// Returns the length of this `Tup`.
            pub fn len( &self ) -> usize { self.inner.vec.len() }
            /// Returns whether this `Tup` is empty.
            pub fn is_empty( &self ) -> bool { self.inner.vec.is_empty() }
            /// Returns whether `self` and `other` point to the same data.
            pub fn ptr_eq( &self, other: &Self ) -> bool { Arc::ptr_eq( &self.inner, &other.inner ) }
            /// Returns an iterator over the Tup.
            pub fn iter( &self ) -> Iter<Value> { self.vec_ref().iter() }
        }

        impl Default for Tup
        {
            fn default() -> Self { Self::from_vec( vec![] ) }
        }

        impl fmt::Display for Tup
        {
            fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result { write!( f, "{}", self.format( true, INDENT_STEP) ) }
        }

        impl From<Vec<Value>> for Tup
        {
            fn from( vec: Vec<Value> ) -> Self { Self::from_vec( vec ) }
        }

        impl PartialEq for Tup
        {
            fn eq( &self, other: &Self ) -> bool
            {
                if self.inner.inner_tvec != other.inner.inner_tvec { return false; }
                self.inner.vec == other.inner.vec
            }
        }
    }
    pub use self::tuples::{ Tup };
    /*
    terminfo v0.9.0::database*/
    pub mod metadata
    {
        use ::
        {
            collections::{ HashMap },
            error::metadata::{ self as error, Error },
            fnv::{ FnvHasher },
            fs::{ self, File },
            hash::{ BuildHasherDefault },
            io::{ Read },
            path::{ Path, PathBuf },
            *,
        };
        /*
        use terminfo::capability::{Capability, Value};
        use terminfo::names;
        use terminfo::parser::compiled;
        */
        /// A capability database.
        #[derive(Eq, PartialEq, Clone, Debug)]
        pub struct Database
        {
            name: String,
            aliases: Vec<String>,
            description: String,
            inner: HashMap<String, Value, BuildHasherDefault<FnvHasher>>,
        }
        /// Builder for a new `Database`.
        #[derive(Default, Debug)]
        pub struct Builder
        {
            name: Option<String>,
            aliases: Vec<String>,
            description: Option<String>,
            inner: HashMap<String, Value, BuildHasherDefault<FnvHasher>>,
        }

        impl Builder
        {
            /// Build the database.
            pub fn build(self) -> Result<Database, ()>
            {
                Ok(Database
                {
                    name: self.name.ok_or(())?,
                    aliases: self.aliases,
                    description: self.description.unwrap_or_default(),
                    inner: self.inner,
                })
            }
            /// Set the terminal name.
            pub fn name<T: Into<String>>(&mut self, name: T) -> &mut Self
            {
                self.name = Some(name.into());
                self
            }
            /// Set the terminal aliases.
            pub fn aliases<T, I>(&mut self, iter: I) -> &mut Self
            where
            T: Into<String>,
            I: IntoIterator<Item = T>
            {
                self.aliases = iter.into_iter().map(|a| a.into()).collect();
                self
            }
            /// Set the terminal description.
            pub fn description<T: Into<String>>(&mut self, description: T) -> &mut Self
            {
                self.description = Some(description.into());
                self
            }
            /// Set a capability.
            pub fn set<'a, C: Capability<'a>>(&'a mut self, value: C) -> &mut Self 
            {
                if !self.inner.contains_key(C::name())
                {
                    if let Some(value) = C::into(value)
                    {
                        self.inner.insert(C::name().into(), value);
                    }
                }

                self
            }
            /// Set a raw capability.
            pub fn raw<S: AsRef<str>, V: Into<Value>>(&mut self, name: S, value: V) -> &mut Self
            {
                let name = name.as_ref();
                let name = names::ALIASES.get(name).copied().unwrap_or(name);

                if !self.inner.contains_key(name) { self.inner.insert(name.into(), value.into()); }

                self
            }
        }

        impl Database
        {
            /// Create a database builder for constucting a database.
            pub fn new() -> Builder
            {
                Builder::default()
            }
            /// Load a database from the current environment.
            pub fn from_env() -> error::Result<Self>
            {
                if let Ok(name) = env::var("TERM") { Self::from_name(name) }
                else { Err(Error::NotFound) }
            }
            /// Load a database for the given name.
            pub fn from_name<N: AsRef<str>>(name: N) -> error::Result<Self>
            {
                let name = name.as_ref();
                let first = name.chars().next().ok_or(Error::NotFound)?;

                // See https://manpages.debian.org/buster/ncurses-bin/terminfo.5.en.html#Fetching_Compiled_Descriptions
                let mut search = Vec::<PathBuf>::new();

                #[allow(deprecated)]
                if let Some(dir) = env::var_os("TERMINFO") {
                    search.push(dir.into());
                } else if let Some(mut home) = std::env::home_dir() {
                    home.push(".terminfo");
                    search.push(home);
                }

                if let Ok(dirs) = env::var("TERMINFO_DIRS") {
                    for dir in dirs.split(':') {
                        search.push(dir.into());
                    }
                }

                // handle non-FHS systems like Termux
                if let Ok(prefix) = env::var("PREFIX") {
                    let path = Path::new(&prefix);
                    search.push(path.join("etc/terminfo"));
                    search.push(path.join("lib/terminfo"));
                    search.push(path.join("share/terminfo"));
                }

                search.push("/etc/terminfo".into());
                search.push("/lib/terminfo".into());
                search.push("/usr/share/terminfo".into());
                search.push("/usr/local/share/terminfo".into());
                search.push("/usr/local/share/site-terminfo".into());
                search.push("/boot/system/data/terminfo".into());

                for path in search {
                    if fs::metadata(&path).is_err() {
                        continue;
                    }

                    // Check standard location.
                    {
                        let mut path = path.clone();
                        path.push(first.to_string());
                        path.push(name);

                        if fs::metadata(&path).is_ok() {
                            return Self::from_path(path);
                        }
                    }

                    // Check non-standard location.
                    {
                        let mut path = path.clone();
                        path.push(format!("{:x}", first as usize));
                        path.push(name);

                        if fs::metadata(&path).is_ok() {
                            return Self::from_path(path);
                        }
                    }
                }

                Err(Error::NotFound)
            }
            /// Load a database from the given path.
            pub fn from_path<P: AsRef<Path>>(path: P) -> error::Result<Self> 
            {
                let mut file = File::open(path)?;
                let mut buffer = Vec::new();
                file.read_to_end(&mut buffer)?;

                Self::from_buffer(buffer)
            }
            /// Load a database from a buffer.
            pub fn from_buffer<T: AsRef<[u8]>>(buffer: T) -> error::Result<Self> 
            {
                if let Ok((_, database)) = compiled::parse(buffer.as_ref()) {
                    Ok(database.into())
                } else {
                    Err(Error::Parse)
                }
            }
            /// The terminal name.
            pub fn name(&self) -> &str { &self.name }
            /// The terminal aliases.
            pub fn aliases(&self) -> &[String] { &self.aliases }
            /// The terminal description.
            pub fn description(&self) -> &str { &self.description }
            /// Get a capability.
            pub fn get<'a, C: Capability<'a>>(&'a self) -> Option<C> { C::from(self.inner.get(C::name())) }
            /// Get a capability by name.
            pub fn raw<S: AsRef<str>>(&self, name: S) -> Option<&Value>
            {
                let name = name.as_ref();
                let name = names::ALIASES.get(name).copied().unwrap_or(name);
                self.inner.get(name)
            }
        }
    }
}
/// The Default trait for types with a default value.
pub mod default
{
    pub use std::default::{ * };
}
/// Emission & Printing Utilities
pub mod emit
{

}
/// Inspection and manipulation of the process’s environment.
pub mod env
{
    pub use std::env::{ * };

    use ::
    {
        fs::{ read_dir },
        io::{ ErrorKind },
        path::{ Path },
    };
    // pub fn init_path_env( ... )
    pub fn initialize_pathing()
    {
        let mut paths: Vec<String> = vec![];
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if Path::new( x ).exists()
            { paths.push( x.to_string() ); }
        }

        if let Ok( env_path ) = var( "PATH" )
        {
            for x in env_path.split( ":" )
            {
                if !paths.contains( &x.to_string() ) { paths.push( x.to_string() ); }
            }
        }

        let paths = paths.join( ":" );
        set_var( "PATH", paths );
    }
    // pub fn env_args_to_command_line() -> String
    pub fn args_to_command_line() -> String
    {
        let mut result = String::new();
        let env_args = args();
        
        if env_args.len() <= 1 { return result; }

        for ( i, arg ) in env_args.enumerate()
        {
            if i == 0 || arg == "-c" { continue; }

            result.push_str( arg.as_str() );
        }

        result
    }

    pub fn find_file_in_path( filename:&str, exec:bool ) -> String
    {
        let env_path = match var( "PATH" )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: error with env PATH: {:?}", e );
                return String::new();
            }
        };

        let vec_path: Vec<&str> = env_path.split( ':' ).collect();
        for p in &vec_path
        {
            match read_dir( p )
            {
                Ok( list ) =>
                {
                    for entry in list.flatten()
                    {
                        if let Ok( name ) = entry.file_name().into_string()
                        {
                            if name != filename { continue; }

                            if exec
                            {
                                let _mode = match entry.metadata()
                                {
                                    Ok( x ) => x,
                                    Err( e ) =>
                                    {
                                        println_stderr!( "cicada: metadata error: {:?}", e );
                                        continue;
                                    }
                                };

                                let mode = _mode.permissions().mode();
                                
                                if mode & 0o111 == 0 { continue; }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }

                Err( e ) =>
                {
                    if e.kind() == ErrorKind::NotFound { continue; }

                    log!( "cicada: fs read_dir error: {}: {}", p, e );
                }
            }
        }

        String::new()
    }
}
/// Expansions
pub mod expand
{
    use ::
    {
        borrow::{ Cow },
        error::metadata::{ self as error },
        fs::{ read_dir },
        io::{ BufWriter, ErrorKind, Write },
        os::unix::fs::PermissionsExt,
        parsers::metadata::expansion::*,
        primitive::{ Tokens },
        regex::{ Regex },
        shell::{ env_in_token, Shell },
        *,
    };

    macro_rules! from
    {
        (number $ty:ty) => {
            impl From<$ty> for Parameter {
                fn from(value: $ty) -> Self {
                    Parameter::Number(value as i32)
                }
            }
        };

        (string ref $ty:ty) => {
            impl<'a> From<&'a $ty> for Parameter {
                fn from(value: &'a $ty) -> Self {
                    Parameter::String(value.into())
                }
            }
        };

        (string $ty:ty) => {
            impl From<$ty> for Parameter {
                fn from(value: $ty) -> Self {
                    Parameter::String(value.into())
                }
            }
        };
    }
    /*
    fn expand_alias( sh:&Shell, tokens:&mut Tokens ) */
    pub fn alias( sh:&Shell, tokens:&mut Tokens )
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        let mut is_head = true;
        for ( sep, text ) in tokens.iter()
        {
            if sep.is_empty() && text == "|" 
            {
                is_head = true;
                idx += 1;
                continue;
            }
            
            if is_head && text == "xargs" 
            {
                idx += 1;
                continue;
            }

            if !is_head || !sh.is_alias( text )
            {
                idx += 1;
                is_head = false;
                continue;
            }

            if let Some( value ) = sh.get_alias_content( text )
            {
                buff.push( ( idx, value.clone() ) );
            }

            idx += 1;
            is_head = false;
        }

        for ( i, text ) in buff.iter().rev()
        {
            let linfo = parsers::line::parse( text );
            let tokens_ = linfo.tokens;
            tokens.remove( *i );

            for item in tokens_.iter().rev()
            {
                tokens.insert( *i, item.clone() );
            }
        }
    }
    /*
    pub fn basename( path:&str ) -> Cow<'_, str> */
    pub fn basename( path:&str ) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit( '/' );
        match pieces.next()
        {
            Some( p ) => p.into(),
            None => path.into(),
        }
    }
    /*
    pub fn expand_home( text:&str ) -> String */
    pub fn house( text:&str ) -> String
    {
        let mut s: String = text.to_string();
        let v = vec!
        [
            r"( ?P<head> + )~( ?P<tail> + )",
            r"( ?P<head> + )~( ?P<tail>/ )",
            r"^( ?P<head> * )~( ?P<tail>/ )",
            r"( ?P<head> + )~( ?P<tail> *$ )",
        ];

        for item in &v
        {
            let re;
            if let Ok( x ) = Regex::new( item )
            { re = x; }
            else { return String::new(); }

            let home = tools::get_user_home();
            let ss = s.clone();
            let to = format!( "$head{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            s = result.to_string();
        }
        s
    }
    /*
    pub fn expand_glob( tokens:&mut Tokens )  */
    pub fn glob( tokens:&mut Tokens ) 
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !needs_globbing( text )
            {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();

            if !item.contains( '*' ) || item.trim().starts_with( '\'' ) || item.trim().starts_with( '"' )
            {
                result.push( item.to_string() );
            }
            
            else
            {
                let _basename = basename( item );
                let show_hidden = _basename.starts_with( ".*" );

                match glob::glob( item )
                {
                    Ok( paths ) =>
                    {
                        let mut is_empty = true;
                        
                        for entry in paths
                        {
                            match entry
                            {
                                Ok( path ) =>
                                {
                                    let file_path = path.to_string_lossy();
                                    let _basename = basename( &file_path );

                                    if _basename == ".." || _basename == "." { continue; }

                                    if _basename.starts_with( '.' ) && !show_hidden {  continue; }

                                    result.push( file_path.to_string() );
                                    is_empty = false;
                                }

                                Err( e ) => { log!( "glob error: {:?}", e ); }
                            }
                        }

                        if is_empty { result.push( item.to_string() ); }
                    }

                    Err( e ) =>
                    {
                        println!( "glob error: {:?}", e );
                        result.push( item.to_string() );
                        return;
                    }
                }
            }

            buff.push( ( idx, result ) );
            idx += 1;
        }

        for ( i, result ) in buff.iter().rev()
        {
            tokens.remove( *i );
            
            for ( j, token ) in result.iter().enumerate()
            {
                let sep = if token.contains( ' ' ) { "\"" } else { "" };
                tokens.insert( *i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }

    pub fn expand_one_env( sh:&Shell, token:&str ) -> String 
    {
        unsafe
        {
            let re1 = Regex::new( r"^( .*? )\$( [A-Za-z0-9_]+|\$|\? )( .* )$" ).unwrap();
            let re2 = Regex::new( r"( .*? )\$\{( [A-Za-z0-9_]+|\$|\? )\}( .* )$" ).unwrap();
            if !re1.is_match( token ) && !re2.is_match( token ) { return token.to_string(); }

            let mut result = String::new();
            let match_re1 = re1.is_match( token );
            let match_re2 = re2.is_match( token );
            if !match_re1 && !match_re2 { return token.to_string(); }

            let cap_results = if match_re1 { re1.captures_iter( token ) } else { re2.captures_iter( token ) };

            for cap in cap_results
            {
                let head = cap[1].to_string();
                let tail = cap[3].to_string();
                let key = cap[2].to_string();

                if key == "?" { result.push_str( format!( "{}{}", head, sh.previous_status ).as_str() ); }
                else if key == "$"
                {   
                    let val = libc::getpid();
                    result.push_str( format!( "{}{}", head, val ).as_str() );
                }
                else if let Ok( val ) = env::var( &key ) { result.push_str( format!( "{}{}", head, val ).as_str() ); }
                else if let Some( val ) = sh.get_env( &key ) { result.push_str( format!( "{}{}", head, val ).as_str() ); }
                else { result.push_str( &head ); }

                result.push_str( &tail );
            }

            result
        }
    }
    /*
    expand_brace( tokens:&mut Tokens ) */
    pub fn brace( tokens:&mut Tokens )
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for ( sep, token ) in tokens.iter()
        {
            if !sep.is_empty() || !need_expand_brace( token )
            {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let items = brace_getitem( token, 0 );
            
            for x in items.0
            {
                result.push( x.clone() );
            }
            
            buff.push( ( idx, result ) );
            idx += 1;
        }

        for ( i, items ) in buff.iter().rev()
        {
            tokens.remove( *i );
            for ( j, token ) in items.iter().enumerate()
            {
                let sep = if token.contains( ' ' ) { "\"" } else { "" };
                tokens.insert( *i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
    /*
    expand_brace_range( tokens:&mut Tokens ) */
    pub fn brace_range( tokens:&mut Tokens )
    {
        let re;

        if let Ok( x ) = Regex::new( r#"\{( -?[0-9]+ )\.\.( -?[0-9]+ )( \.\. )?( [0-9]+ )?\}"# ) { re = x; }
        else
        {
            println_stderr!( "cicada: re new error" );
            return;
        }

        let mut idx: usize = 0;
        let mut buff: Vec<( usize, Vec<String> )> = Vec::new();

        for ( sep, token ) in tokens.iter()
        {
            if !sep.is_empty() || !re.is_match( token )
            {
                idx += 1;
                continue;
            }
            
            let caps = re.captures( token ).unwrap();

            let start = match caps[1].to_string().parse::<i32>()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( "cicada: {}", e );
                    return;
                }
            };

            let end = match caps[2].to_string().parse::<i32>()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( "cicada: {}", e );
                    return;
                }
            };
            
            let mut incr = if caps.get( 4 ).is_none() { 1 }
            else
            {
                match caps[4].to_string().parse::<i32>()
                {
                    Ok( x ) => x,
                    Err( e ) =>
                    {
                        println_stderr!( "cicada: {}", e );
                        return;
                    }
                }
            };

            if incr <= 1 { incr = 1; }

            let mut result: Vec<String> = Vec::new();
            let mut n = start;

            if start > end
            {
                while n >= end
                {
                    result.push( format!( "{}", n ) );
                    n -= incr;
                }
            }

            else
            {
                while n <= end
                {
                    result.push( format!( "{}", n ) );
                    n += incr;
                }
            }

            buff.push( ( idx, result ) );
            idx += 1;
        }

        for ( i, items ) in buff.iter().rev()
        {
            tokens.remove( *i );

            for ( j, token ) in items.iter().enumerate()
            {
                let sep = if token.contains( ' ' ) { "\"" } else { "" };
                tokens.insert( *i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
    /*
    fn expand_home( tokens:&mut Tokens ) */
    pub fn home( tokens:&mut Tokens )
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !text.starts_with( "~" )
            {
                idx += 1;
                continue;
            }

            let mut s: String = text.clone();
            let ptn = r"^~( ?P<tail>.* )";
            let re = Regex::new( ptn ).expect( "invalid re ptn" );
            let home = get::user_home();
            let ss = s.clone();
            let to = format!( "{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            s = result.to_string();
            buff.push( ( idx, s.clone() ) );
            idx += 1;
        }

        for ( i, text ) in buff.iter().rev()
        {
            tokens[*i].1 = text.to_string();
        }
    }
    /*
    pub fn expand_env( sh:&Shell, tokens:&mut Tokens ) */
    pub fn env( sh:&Shell, tokens:&mut Tokens )
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for ( sep, token ) in tokens.iter()
        {
            if sep == "`" || sep == "'"
            {
                idx += 1;
                continue;
            }

            if !env_in_token( token )
            {
                idx += 1;
                continue;
            }

            let mut _token = token.clone();

            while env_in_token( &_token )
            {
                _token = expand_one_env( sh, &_token );
            }

            buff.push( ( idx, _token ) );
            idx += 1;
        }

        for ( i, text ) in buff.iter().rev()
        {
            tokens[*i].1 = text.to_string();
        }
    }
    /*
    pub fn extend_bangbang( sh:&shell::Shell, line:&mut String ) */
    pub fn bangbang( sh:&shell::Shell, line:&mut String )
    {
        if !re_contains( line, r"!!" ) { return; }
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new( r"!!" ).unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::line::parse( line );

        for ( sep, token ) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str( &sep ); }

            if re_contains( &token, r"!!" ) && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all( &line2, sh.previous_cmd.as_str() );
                new_line.push_str( &result );
                replaced = true;
            }
            else { new_line.push_str( &token ); }

            if !sep.is_empty()
            {
                new_line.push_str( &sep );
            }

            new_line.push( ' ' );
        }

        *line = new_line.trim_end().to_string();
        if replaced { println!( "{}", line ); }
    }
    
    /// Trait for items that can be expanded.
    pub trait Expand 
    {
        fn expand<W: Write>
        (
            &self,
            output: W,
            parameters: &[Parameter],
            context: &mut Context,
        ) -> error::Result<()>;
    }
    /// An expansion parameter.
    #[derive(Eq, PartialEq, Clone, Debug)]
    pub enum Parameter 
    {
        /// A number.
        Number(i32),

        /// An ASCII string.
        String(Vec<u8>),
    }

    impl Default for Parameter 
    {
        fn default() -> Self { Parameter::Number(0) }
    }

    from!(number bool);
    from!(number u8);
    from!(number i8);
    from!(number u16);
    from!(number i16);
    from!(number u32);
    from!(number i32);

    from!(string String);
    from!(string ref str);
    from!(string Vec<u8>);
    from!(string ref [u8]);
    /// The expansion context.
    #[derive(Eq, PartialEq, Default, Debug)]
    pub struct Context 
    {
        pub fixed: [Parameter; 26],
        pub dynamic: [Parameter; 26],
    }

    impl Expand for [u8] 
    {
        fn expand<W: Write>
        (
            &self,
            output: W,
            parameters: &[Parameter],
            context: &mut Context,
        ) -> error::Result<()> 
        {
            let mut output = BufWriter::new(output);
            let mut input = self;
            let mut params: [Parameter; 9] = Default::default();
            let mut stack = Vec::new();
            let mut conditional = false;
            let mut incremented = false;

            for (dest, source) in params.iter_mut().zip(parameters.iter())
            {
                *dest = source.clone();
            }

            macro_rules! next 
            {
                () => {
                    match parse(input) {
                        Ok((rest, item)) => {
                            input = rest;
                            item
                        }

                        Err(_) => return Err(error::Expand::Invalid.into()),
                    }
                };
            }

            'main: while !input.is_empty() 
            {
                match next!() 
                {
                    Item::Conditional(Conditional::If) => {
                        conditional = true;
                    }

                    Item::Conditional(Conditional::End) if conditional => {
                        conditional = false;
                    }

                    Item::Conditional(Conditional::Then) if conditional => match stack.pop() {
                        Some(Parameter::Number(0)) => {
                            let mut level = 0;

                            while !input.is_empty() {
                                match next!() {
                                    Item::Conditional(Conditional::End)
                                    | Item::Conditional(Conditional::Else)
                                        if level == 0 =>
                                    {
                                        continue 'main
                                    }

                                    Item::Conditional(Conditional::If) => level += 1,

                                    Item::Conditional(Conditional::End) => level -= 1,

                                    _ => (),
                                }
                            }

                            return Err(error::Expand::Invalid.into());
                        }

                        Some(_) => (),

                        None => return Err(error::Expand::StackUnderflow.into()),
                    },

                    Item::Conditional(Conditional::Else) if conditional => {
                        let mut level = 0;

                        while !input.is_empty() {
                            match next!() {
                                Item::Conditional(Conditional::End) if level == 0 => continue 'main,

                                Item::Conditional(Conditional::If) => level += 1,

                                Item::Conditional(Conditional::End) => level -= 1,

                                _ => (),
                            }
                        }

                        return Err(error::Expand::Invalid.into());
                    }

                    Item::Conditional(..) => return Err(error::Expand::Invalid.into()),

                    Item::String(value) => output.write_all(value)?,

                    Item::Constant(Constant::Character(ch)) => {
                        stack.push(Parameter::Number(ch as i32));
                    }

                    Item::Constant(Constant::Integer(value)) => {
                        stack.push(Parameter::Number(value));
                    }

                    Item::Variable(Variable::Length) => match stack.pop() {
                        Some(Parameter::String(ref value)) => {
                            stack.push(Parameter::Number(value.len() as i32));
                        }

                        Some(_) => {
                            return Err(error::Expand::TypeMismatch.into());
                        }

                        None => {
                            return Err(error::Expand::StackUnderflow.into());
                        }
                    },

                    Item::Variable(Variable::Push(index)) => {
                        stack.push(params[index as usize].clone());
                    }

                    Item::Variable(Variable::Set(dynamic, index)) => {
                        if let Some(value) = stack.pop() {
                            if dynamic {
                                context.dynamic[index as usize] = value.clone();
                            } else {
                                context.fixed[index as usize] = value.clone();
                            }
                        } else {
                            return Err(error::Expand::StackUnderflow.into());
                        }
                    }

                    Item::Variable(Variable::Get(dynamic, index)) => {
                        if dynamic {
                            stack.push(context.dynamic[index as usize].clone());
                        } else {
                            stack.push(context.fixed[index as usize].clone());
                        }
                    }

                    Item::Operation(Operation::Increment) if !incremented => {
                        incremented = true;

                        if let (&Parameter::Number(x), &Parameter::Number(y)) = (&params[0], &params[1])
                        {
                            params[0] = Parameter::Number(x + 1);
                            params[1] = Parameter::Number(y + 1);
                        } else {
                            return Err(error::Expand::TypeMismatch.into());
                        }
                    }

                    Item::Operation(Operation::Increment) => (),

                    Item::Operation(Operation::Binary(operation)) => match (stack.pop(), stack.pop()) {
                        (Some(Parameter::Number(y)), Some(Parameter::Number(x))) => {
                            stack.push(Parameter::Number(match operation {
                                Binary::Add => x + y,
                                Binary::Subtract => x - y,
                                Binary::Multiply => x * y,
                                Binary::Divide => {
                                    if y != 0 {
                                        x / y
                                    } else {
                                        0
                                    }
                                }
                                Binary::Remainder => {
                                    if y != 0 {
                                        x % y
                                    } else {
                                        0
                                    }
                                }

                                Binary::AND => x & y,
                                Binary::OR => x | y,
                                Binary::XOR => x ^ y,

                                Binary::And => (x != 0 && y != 0) as i32,
                                Binary::Or => (x != 0 || y != 0) as i32,

                                Binary::Equal => (x == y) as i32,
                                Binary::Greater => (x > y) as i32,
                                Binary::Lesser => (x < y) as i32,
                            }))
                        }

                        (Some(_), Some(_)) => return Err(error::Expand::TypeMismatch.into()),

                        _ => return Err(error::Expand::StackUnderflow.into()),
                    },

                    Item::Operation(Operation::Unary(operation)) => match stack.pop() {
                        Some(Parameter::Number(x)) => stack.push(Parameter::Number(match operation {
                            Unary::Not => (x != 0) as i32,
                            Unary::NOT => !x,
                        })),

                        Some(_) => return Err(error::Expand::TypeMismatch.into()),

                        _ => return Err(error::Expand::StackUnderflow.into()),
                    },

                    Item::Print(p) => {
                        /// Calculate the length of a formatted number.
                        fn length(value: i32, p: &Print) -> usize {
                            let digits = match p.format {
                                Format::Dec => (value as f32).abs().log(10.0).floor() as usize + 1,

                                Format::Oct => (value as f32).abs().log(8.0).floor() as usize + 1,

                                Format::Hex | Format::HEX => {
                                    (value as f32).abs().log(16.0).floor() as usize + 1
                                }

                                _ => unreachable!(),
                            };

                            let mut length = digits;

                            // Add the minimum number of digits.
                            if p.flags.precision > digits {
                                length += p.flags.precision - digits;
                            }

                            // Add the sign if present.
                            if p.format == Format::Dec && (value < 0 || p.flags.sign) {
                                length += 1;
                            }

                            // Add the alternate representation.
                            if p.flags.alternate {
                                match p.format {
                                    Format::Hex | Format::HEX => length += 2,

                                    Format::Oct => length += 1,

                                    _ => (),
                                }
                            }

                            length
                        }

                        macro_rules! w {
                            ($value:expr) => (
                                output.write_all($value)?
                            );

                            ($($item:tt)*) => (
                                write!(output, $($item)*)?
                            );
                        }

                        macro_rules! f {
                            (by $length:expr) => (
                                for _ in 0 .. p.flags.width - $length {
                                    output.write_all(if p.flags.space { b" " } else { b"0" })?;
                                }
                            );

                            (before by $length:expr) => (
                                if !p.flags.left && p.flags.width > $length {
                                    f!(by $length);
                                }
                            );

                            (after by $length:expr) => (
                                if p.flags.left && p.flags.width > $length {
                                    f!(by $length);
                                }
                            );

                            (before $value:expr) => (
                                f!(before by length($value, &p));
                            );

                            (after $value:expr) => (
                                f!(after by length($value, &p));
                            );
                        }

                        match (p.format, stack.pop()) {
                            (Format::Str, Some(Parameter::String(ref value))) => {
                                let mut value = &value[..];

                                if p.flags.precision > 0 && p.flags.precision < value.len() {
                                    value = &value[..p.flags.precision];
                                }

                                f!(before by value.len());
                                w!(value);
                                f!(after by value.len());
                            }

                            (Format::Chr, Some(Parameter::Number(value))) => {
                                w!("{}", value as u8 as char)
                            }

                            (Format::Uni, Some(Parameter::Number(value))) => w!(
                                "{}",
                                char::from_u32(value as u32).ok_or(error::Expand::TypeMismatch)?
                            ),

                            (Format::Dec, Some(Parameter::Number(value))) => {
                                f!(before value);

                                if p.flags.sign && value >= 0 {
                                    w!(b"+");
                                }

                                w!("{:.1$}", value, p.flags.precision);

                                f!(after value);
                            }

                            (Format::Oct, Some(Parameter::Number(value))) => {
                                f!(before value);

                                if p.flags.alternate {
                                    w!(b"0");
                                }

                                w!("{:.1$o}", value, p.flags.precision);

                                f!(after value);
                            }

                            (Format::Hex, Some(Parameter::Number(value))) => {
                                f!(before value);

                                if p.flags.alternate {
                                    w!(b"0x");
                                }

                                w!("{:.1$x}", value, p.flags.precision);

                                f!(after value);
                            }

                            (Format::HEX, Some(Parameter::Number(value))) => {
                                f!(before value);

                                if p.flags.alternate {
                                    w!(b"0X");
                                }

                                w!("{:.1$X}", value, p.flags.precision);

                                f!(after value);
                            }

                            (_, Some(_)) => return Err(error::Expand::TypeMismatch.into()),

                            (_, None) => return Err(error::Expand::StackUnderflow.into()),
                        }
                    }
                }
            }

            Ok(())
        }
    }
}
/// Interfaces for working with Errors.
pub mod error
{
    pub use std::error::{ * };

    use ::
    {
        fmt, io
    };
    /// Cross-platform interface to the `errno` variable.
    pub mod imply
    {
        pub mod unix
        {
            //! Implementation of `errno` functionality for Unix systems.
            use ::
            {
                error::{ Errno },
                libc::{self, c_int, size_t, strerror_r, strlen},                
                result::{ Result },
                *,
            };

            pub const STRERROR_NAME:&str = "strerror_r";

            extern "C"
            {
                #[cfg_attr( 
                    any( 
                        target_os = "macos",
                        target_os = "ios",
                        target_os = "tvos",
                        target_os = "watchos",
                        target_os = "visionos",
                        target_os = "freebsd"
                   ),
                    link_name = "__error"
               )]
                #[cfg_attr( 
                    any( 
                        target_os = "openbsd",
                        target_os = "netbsd",
                        target_os = "android",
                        target_os = "espidf",
                        target_os = "vxworks",
                        target_os = "cygwin",
                        target_env = "newlib"
                   ),
                    link_name = "__errno"
               )]
                #[cfg_attr( 
                    any( target_os = "solaris", target_os = "illumos" ),
                    link_name = "___errno"
               )]
                #[cfg_attr( target_os = "haiku", link_name = "_errnop" )]
                #[cfg_attr( 
                    any( 
                        target_os = "linux",
                        target_os = "hurd",
                        target_os = "redox",
                        target_os = "dragonfly",
                        target_os = "emscripten",
                   ),
                    link_name = "__errno_location"
               )]
                #[cfg_attr( target_os = "aix", link_name = "_Errno" )]
                #[cfg_attr( target_os = "nto", link_name = "__get_errno_ptr" )]
                fn errno_location() -> *mut c_int;
            }

            pub fn with_description<F, T>( err: Errno, callback: F ) -> T where
            F: FnOnce( Result<&str, Errno> ) -> T
            {
                unsafe
                {
                    let mut buf = [0u8; 1024];
                    let c_str =
                    {
                        let rc = strerror_r( err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t );

                        if rc != 0
                        {
                            let fm_err = match rc < 0
                            {
                                true => errno(),
                                false => Errno( rc ),
                            };

                            if fm_err != Errno( libc::ERANGE )
                            {
                                return callback( Err( fm_err ) );
                            }
                        }

                        let c_str_len = strlen( buf.as_ptr() as *const _ );
                        &buf[..c_str_len]
                    };
                    callback( Ok( from_utf8_lossy( c_str ) ) )
                }
            }
            
            pub fn errno() -> Errno { unsafe { Errno( *errno_location() ) } }

            pub fn set_errno( Errno( errno ): Errno )
            { unsafe { *errno_location() = errno; } }

            fn from_utf8_lossy( input:&[u8] ) -> &str
            {
                match str::from_utf8( input )
                {
                    Ok( valid ) => valid,
                    Err( error ) => unsafe { str::from_utf8_unchecked( &input[..error.valid_up_to()] ) },
                }
            }
        }

        pub mod windows
        {
            //! Implementation of `errno` functionality for Windows.
            use ::
            {
                char::{ self, REPLACEMENT_CHARACTER },
                ptr
            };

            use ::error::Errno;

            pub const STRERROR_NAME:&str = "FormatMessageW";
            pub const FORMAT_MESSAGE_FROM_SYSTEM: FORMAT_MESSAGE_OPTIONS = FORMAT_MESSAGE_OPTIONS( 4096u32 );
            pub const FORMAT_MESSAGE_IGNORE_INSERTS: FORMAT_MESSAGE_OPTIONS = FORMAT_MESSAGE_OPTIONS( 512u32 );
            
            pub type WIN32_ERROR = u32;            
            pub type PWSTR = *mut u16;

            #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, PartialEq )]
            pub struct FORMAT_MESSAGE_OPTIONS( pub u32 );
            
            #[inline] pub unsafe fn GetLastError() -> WIN32_ERROR { 0 }
            #[inline] pub unsafe fn SetLastError( dwerrcode:WIN32_ERROR ) { }
            #[inline] pub unsafe fn FormatMessageW
            ( 
                dwflags: FORMAT_MESSAGE_OPTIONS, 
                lpsource:Option<*const ::ffi::c_void>, 
                dwmessageid: u32, 
                dwlanguageid: u32, 
                lpbuffer:PWSTR, 
                nsize: u32, 
                arguments:Option<*const *const i8>
            ) -> u32
            { 0 }

            pub fn with_description<F, T>( err: Errno, callback: F ) -> T where
            F: FnOnce( Result<&str, Errno> ) -> T
            {
                unsafe
                {
                    let lang_id = 0x0800_u32;
                    let mut buf = [0u16; 2048];
                    
                    let res = FormatMessageW
                    ( 
                        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ptr::null_mut(),
                        err.0 as u32,
                        lang_id,
                        buf.as_mut_ptr(),
                        buf.len() as u32,
                        ptr::null_mut(),
                   );
                    
                    if res == 0
                    {
                        let fm_err = errno();
                        return callback( Err( fm_err ) );
                    }

                    let mut msg = [0u8; 2048];
                    let msg = from_utf16_lossy( &buf[..res as usize], &mut msg[..] );
                    callback( Ok( msg.trim_end() ) )
                }
            }
            
            pub fn errno() -> Errno { unsafe { Errno( GetLastError() as i32 ) } }

            pub fn set_errno( Errno( errno ): Errno ){ unsafe { SetLastError( errno as WIN32_ERROR ) } }

            fn from_utf16_lossy<'a>( input:&[u16], output:&'a mut [u8] ) -> &'a str
            {
                unsafe
                {
                    str::from_utf8_unchecked( &output[..output_len] );
                    let mut output_len = 0;
                    for c in char::decode_utf16( input.iter().copied().take_while( |&x| x != 0 ) )
                    .map( |x| x.unwrap_or( REPLACEMENT_CHARACTER ) )
                    {
                        let c_len = c.len_utf8();

                        if c_len > output.len() - output_len { break; }
                        
                        c.encode_utf8( &mut output[output_len..] );
                        output_len += c_len;
                    }
                }
            }
        }
    }
    #[cfg( unix )] pub use self::imply::unix as sys;
    #[cfg( windows )] pub use self::imply::windows as sys;
    /// OVER Error Handling
    pub mod over
    {
        //! Error module.
        use ::
        {
            error::
            {
                Error 
            },
            primitive::{ Type },
            *,
        };

        pub mod parse
        {
            //! Module for parse errors.
            use ::
            {
                error::{ Error, over::OverError, },
                num::
                {
                    big::{ BigInt, ParseBigIntError },
                    ParseIntError
                },
                parsers::over::{ MAX_DEPTH, ParseResult },
                primitive::{ Type, Value },
                *,
            };
            
            pub fn parse_err<T>( file: Option<String>, kind: ParseErrorKind ) -> ParseResult<T>
            { Err( ParseError { file, kind }) }
            /// Error kind.
            #[derive( Debug )]
            pub enum ParseErrorKind
            {
                BinaryOperatorError( Type, Type, char, usize, usize),
                CyclicInclude( String, usize, usize),
                DuplicateField( String, usize, usize),
                DuplicateGlobal( String, usize, usize),
                ExpectedType( Type, Type, usize, usize),
                GlobalNotFound( String, usize, usize),
                InvalidIndex( BigInt, usize, usize),
                InvalidClosingBracket( Option<char>, char, usize, usize),
                InvalidDot( Type, usize, usize),
                InvalidEscapeChar( char, usize, usize),
                InvalidFieldChar( char, usize, usize),
                InvalidFieldName( String, usize, usize),
                InvalidIncludeChar( char, usize, usize),
                InvalidIncludePath( String, usize, usize),
                InvalidIncludeToken( Type, usize, usize),
                InvalidNumeric( usize, usize),
                InvalidValue( String, usize, usize),
                InvalidValueChar( char, usize, usize),
                MaxDepth( usize, usize),
                UnaryOperatorError( Type, char, usize, usize),
                UnexpectedEnd( usize),
                VariableNotFound( String, usize, usize),
                IoError( String),
                OverError( String),
                ParseIntError( String),
            }
            /// Parse error.
            #[derive( Debug )]
            pub struct ParseError
            {
                /// The file this error occurred in.
                pub file: Option<String>,
                /// Error kind.
                pub kind: ParseErrorKind,
            }

            impl fmt::Display for ParseError 
            {
                fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result 
                {
                    use self::ParseErrorKind::*;

                    if let Some( ref file ) = ( *self).file { write!( f, "{}: ", file)?; }

                    match ( *self).kind
                    {
                        BinaryOperatorError( ref expected, ref found, ref op, ref line, ref col ) => write!
                        ( 
                            f,
                            "Could not apply operator {} on types {} and {} at line {}, column {}",
                            op, expected, found, line, col,
                        ),
                        CyclicInclude( ref file, ref line, ref col ) => write!
                        ( 
                            f,
                            "Tried to cyclically include file \"{}\" at line {}, column {}",
                            file, line, col
                        ),
                        DuplicateField( ref field, ref line, ref col ) => write!
                        ( 
                            f,
                            "Duplicate field \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        DuplicateGlobal( ref field, ref line, ref col ) => write!
                        ( 
                            f,
                            "Duplicate global \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        ExpectedType( ref expected, ref found, ref line, ref col ) => write!
                        ( 
                            f,
                            "Expected {} at line {}, column {}; found {}",
                            expected, line, col, found
                        ),
                        GlobalNotFound( ref var, ref line, ref col ) => write!
                        ( 
                            f,
                            "Global \"{}\" at line {}, column {} could not be found",
                            var, line, col
                        ),
                        InvalidClosingBracket( ref expected, ref found, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid closing bracket '{}' at line {}, column {}; expected {}",
                            found,
                            line,
                            col,
                            match *expected
                            {
                                Some( ch ) => format!( "'{}'", ch),
                                None => String::from( "none"),
                            }
                        ),
                        InvalidDot( ref t, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid use of dot notation on value of type {} at line {}, column {}; \
                            value must be an Obj, Arr, or Tup.",
                            t, line, col
                        ),
                        InvalidEscapeChar( ref ch, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid escape character '\\{}' at line {}, column {}. \
                            If you meant to write a backslash, use '\\\\'",
                            char::format( *ch ),
                            line,
                            col
                        ),
                        InvalidFieldChar( ref ch, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid character '{}' for field at line {}, column {}",
                            char::format( *ch ),
                            line,
                            col
                        ),
                        InvalidFieldName( ref field, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid field name \"{}\" at line {}, column {}",
                            field, line, col
                        ),
                        InvalidIncludeChar( ref found, ref line, ref col ) => write!( 
                            f,
                            "Invalid include token character \'{}\' at line {}, column {}",
                            found, line, col
                        ),
                        InvalidIncludePath( ref path, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid include path \"{}\" at line {}, column {}",
                            path, line, col
                        ),
                        InvalidIncludeToken( ref t, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid value of type \"{}\" at line {}, column {}; \
                            must be either a Str value or one of the tokens \
                            \"Obj\", \"Arr\", \"Tup\", or \"Str\"",
                            t, line, col
                        ),
                        InvalidIndex( ref index, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid index {} at line {}, column {}",
                            index, line, col
                        ),
                        InvalidNumeric( ref line, ref col ) =>
                        { write!( f, "Invalid numeric value at line {}, column {}", line, col) }
                        InvalidValue( ref value, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid value \"{}\" at line {}, column {}",
                            value, line, col
                        ),
                        InvalidValueChar( ref ch, ref line, ref col ) => write!
                        ( 
                            f,
                            "Invalid character '{}' for value at line {}, column {}",
                            char::format( *ch ),
                            line,
                            col
                        ),
                        MaxDepth( ref line, ref col ) => write!
                        ( 
                            f,
                            "Exceeded maximum recursion depth ( {} ) at line {}, column {}",
                            MAX_DEPTH, line, col
                        ),
                        UnaryOperatorError( ref found, ref op, ref line, ref col ) => write!
                        ( 
                            f,
                            "Could not apply operator {} on type {} at line {}, column {}",
                            op, found, line, col,
                        ),
                        UnexpectedEnd( ref line ) => write!( f, "Unexpected end at line {}", line,),
                        VariableNotFound( ref var, ref line, ref col ) => write!
                        ( 
                            f,
                            "Variable \"{}\" at line {}, column {} could not be found",
                            var, line, col
                        ),

                        IoError( ref error ) | OverError( ref error ) | ParseIntError( ref error ) =>
                        {
                            write!( f, "{}", error)
                        }
                    }
                }
            }

            impl Error for ParseError 
            {
                fn description( &self ) -> &str 
                {
                    use self::ParseErrorKind::*;

                    match ( *self).kind
                    {
                        BinaryOperatorError( _, _, _, _, _ ) | UnaryOperatorError( _, _, _, _ ) =>
                        { "Could not apply operator" }
                        CyclicInclude( _, _, _ ) => "Tried to cyclically include file",
                        DuplicateField( _, _, _ ) => "Duplicate field",
                        DuplicateGlobal( _, _, _ ) => "Duplicate global",
                        ExpectedType( _, _, _, _ ) => "Expected different type",
                        GlobalNotFound( _, _, _ ) => "Global could not be found",
                        InvalidClosingBracket( _, _, _, _ ) => "Invalid closing bracket",
                        InvalidDot( _, _, _ ) => "Invalid use of dot notation",
                        InvalidEscapeChar( _, _, _ ) => "Invalid escape character",
                        InvalidFieldChar( _, _, _ ) => "Invalid character for field",
                        InvalidFieldName( _, _, _ ) => "Invalid field name",
                        InvalidIncludeChar( _, _, _ ) => "Invalid include character",
                        InvalidIncludePath( _, _, _ ) => "Invalid include path",
                        InvalidIncludeToken( _, _, _ ) => "Invalid include token",
                        InvalidIndex( _, _, _ ) => "Invalid index",
                        InvalidNumeric( _, _ ) => "Invalid numeric value",
                        InvalidValue( _, _, _ ) => "Invalid value",
                        InvalidValueChar( _, _, _ ) => "Invalid character for value",
                        MaxDepth( _, _ ) => "Exceeded maximum depth for a container",
                        UnexpectedEnd( _ ) => "Unexpected end when reading value",
                        VariableNotFound( _, _, _ ) => "Variable could not be found",
                        IoError( ref error ) | OverError( ref error ) | ParseIntError( ref error ) => error,
                    }
                }
            }

            impl ParseError 
            {
                /// Convert an `OverError` to a `ParseError` given line and column numbers.
                pub fn from_over( e: &OverError, file: Option<String>, line: usize, col: usize ) -> Self 
                {
                    ParseError 
                    {
                        file,
                        kind: ParseErrorKind::OverError( format!( "{} at line {}, col {}", e, line, col)),
                    }
                }
            }

            impl From<io::Error> for ParseError
            {
                fn from( e: io::Error ) -> Self
                {
                    ParseError
                    {
                        file: None,
                        kind: ParseErrorKind::IoError( format!( "{}", e)),
                    }
                }
            }

            impl From<ParseIntError> for ParseError
            {
                fn from( e: ParseIntError ) -> Self
                {
                    ParseError
                    {
                        file: None,
                        kind: ParseErrorKind::ParseIntError( format!( "{}", e)),
                    }
                }
            }

            impl From<ParseBigIntError> for ParseError
            {
                fn from( e: ParseBigIntError ) -> Self
                {
                    ParseError
                    {
                        file: None,
                        kind: ParseErrorKind::ParseIntError( format!( "{}", e)),
                    }
                }
            }
        }
        pub use self::parse::{ ParseError, ParseErrorKind, parse_err };
        /// Result type for this crate.
        pub type OverResult<T> = Result<T, OverError>;
        /// The fabulous OVER error type.
        #[derive( Debug, PartialEq, Eq)]
        pub enum OverError
        {
            ArrOutOfBounds( usize),
            ArrTypeMismatch( Type, Type),
            FieldNotFound( String),
            InvalidFieldName( String),
            NoParentFound,
            ParseError( String),
            TupOutOfBounds( usize),
            TupTypeMismatch( Type, Type, usize),
            TypeMismatch( Type, Type),
            IoError( String),
        }

        impl fmt::Display for OverError
        {
            fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
            {
                use self::OverError::*;

                match *self
                {
                    ArrOutOfBounds( ref index ) => write!( f, "Arr index {} out of bounds", index),
                    ArrTypeMismatch( ref expected, ref found ) => write!
                    ( 
                        f,
                        "Arr inner types do not match: expected {}, found {}",
                        expected, found
                    ),
                    FieldNotFound( ref field ) => write!( f, "Field not found: \"{}\"", field),
                    InvalidFieldName( ref field ) => write!( f, "Invalid field name: \"{}\"", field),
                    NoParentFound => write!( f, "No parent found for this obj"),
                    TupOutOfBounds( ref index ) => write!( f, "Tup index {} out of bounds", index),
                    TupTypeMismatch( ref expected, ref found, ref index ) => write!
                    (
                        f,
                        "Tup inner types do not match at index {}: expected {}, found {}",
                        index, expected, found
                    ),
                    TypeMismatch( ref expected, ref found ) => 
                    {
                        write!( f, "Type mismatch: expected {}, found {}", expected, found)
                    }

                    ParseError( ref error ) | IoError( ref error ) => write!( f, "{}", error),
                }
            }
        }

        impl Error for OverError
        {
            fn description( &self ) -> &str
            {
                use self::OverError::*;

                match *self
                {
                    ArrOutOfBounds( _ ) => "Arr index out of bounds",
                    ArrTypeMismatch( _, _ ) => "Arr inner types do not match",
                    FieldNotFound( _ ) => "Field not found",
                    InvalidFieldName( _ ) => "Invalid field name",
                    NoParentFound => "No parent found for this obj",
                    TupOutOfBounds( _ ) => "Tup index out of bounds",
                    TupTypeMismatch( _, _, _ ) => "Tup inner types do not match",
                    TypeMismatch( _, _ ) => "Type mismatch",
                    ParseError( ref error ) | IoError( ref error ) => error,
                }
            }
        }

        impl From<io::Error> for OverError
        {
            fn from( e: io::Error ) -> Self { OverError::IoError( format!( "{}", e)) }
        }

        impl From<ParseError> for OverError
        {
            fn from( e: ParseError ) -> Self { OverError::ParseError( format!( "{}", e)) }
        }
    }
    /*
    terminfo v0.9.0::error*/
    pub mod metadata
    {
        use ::
        {
            *,
        };

        #[derive( Debug )]
        pub enum Error
        {
            /// IO error.
            Io(io::Error),
            /// Database not found.
            NotFound,
            /// Parsing error.
            Parse,
            /// Expansion error.
            Expand(Expand),
        }

        #[derive(Eq, PartialEq, Copy, Clone, Debug)]
        pub enum Expand 
        {
            /// The expansion string is invalid.
            Invalid,
            /// There was a type mismatch while expanding.
            TypeMismatch,
            /// The stack underflowed while expanding.
            StackUnderflow,
        }

        pub type Result<T> = ::result::Result<T, Error>;

        impl From<io::Error> for Error
        {
            fn from(value: io::Error) -> Self { Error::Io(value) }
        }

        impl From<Expand> for Error
        {
            fn from(value: Expand) -> Self { Error::Expand(value) }
        }

        impl fmt::Display for Error
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> ::std::result::Result<(), fmt::Error>
            {
                match *self
                {
                    Error::Io(ref err) => err.fmt(f),
                    Error::NotFound => f.write_str("Capability database not found."),
                    Error::Parse => f.write_str("Failed to parse capability database."),
                    Error::Expand(ref err) => match *err
                    {
                        Expand::Invalid => f.write_str("The expansion string is invalid."),
                        Expand::StackUnderflow => f.write_str("Not enough elements on the stack."),
                        Expand::TypeMismatch => f.write_str("Type mismatch."),
                    },
                }
            }
        }

        impl error::Error for Error {}
    }

    /// Wraps a platform-specific error code.
    #[derive( Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash )]
    pub struct Errno( pub i32 );

    impl fmt::Debug for Errno
    {
        fn fmt( &self, fmt:&mut fmt::Formatter ) -> fmt::Result
        {
            sys::with_description( *self, |desc|
            {
                fmt.debug_struct( "Errno" )
                .field( "code", &self.0 )
                .field( "description", &desc.ok() )
                .finish()
            } )
        }
    }

    impl fmt::Display for Errno
    {
        fn fmt( &self, fmt:&mut fmt::Formatter ) -> fmt::Result
        {
            sys::with_description( *self, |desc| match desc
            {
                Ok( desc ) => fmt.write_str( desc ),
                Err( fm_err ) => write!
                (
                    fmt,
                    "OS error {} ( {} returned error {} )",
                    self.0,
                    sys::STRERROR_NAME,
                    fm_err.0
               ),
            } )
        }
    }

    impl From<Errno> for i32
    {
        fn from( e: Errno ) -> Self { e.0 }
    }
    
    impl Error for Errno
    {
        #[allow( deprecated )] fn description( &self ) -> &str { "system error" }
    }
    
    impl From<Errno> for io::Error
    {
        fn from( errno: Errno ) -> Self { io::Error::from_raw_os_error( errno.0 ) }
    }
    /// Returns the platform-specific value of `errno`.
    pub fn errno() -> Errno { sys::errno() }
    /// Sets the platform-specific value of `errno`.
    pub fn set_errno( err: Errno ) { sys::set_errno( err ) }
}
/// Constants for the f32 single-precision floating point type.
pub mod f32
{
    pub use std::f32::{ * };
}
/// Constants for the f64 double-precision floating point type.
pub mod f64
{
    pub use std::f64::{ * };
}
/// Utilities related to Foreign Function Interface bindings.
pub mod ffi
{
    //! Provides the `Function` trait for implementing custom `Prompter` commands
    pub use std::ffi::{ * };
    use ::
    {
        command::{ Category },
        terminal::{ Terminal, Terminals, Prompter },
        *,
    };    
    /*
    use ::terminal::Terminals;    
    use std::io;
    use lineread::{ Terminal};
    */
    /// Implements custom functionality for a `Prompter` command
    pub trait Function<Term:Terminals>: Send + Sync
    {
        /// Executes the function.
        fn execute( &self, prompter:&mut Prompter<Term>, count: i32, ch: char ) -> io::Result<()>;
        /// Returns the command category.
        fn category( &self ) -> Category { Category::Other }
    }

    impl<F, Term: Terminals> Function<Term> for F where
    F: Send + Sync,
    F: Fn( &mut Prompter<Term>, i32, char ) -> io::Result<()>
    {
        fn execute( &self, prompter:&mut Prompter<Term>, count: i32, ch: char ) -> io::Result<()>
        {
            self( prompter, count, ch )
        }
    }

    pub struct EnterFunction;

    impl<T: Terminals> Function<T> for EnterFunction
    {
        fn execute( &self, prompter:&mut Prompter<T>, count: i32, _ch: char ) -> io::Result<()>
        {
            let buf = prompter.buffer();
            let linfo = parsers::line::parse( buf );
            
            if linfo.is_complete { prompter.accept_input() }
            else if count > 0
            {
                match prompter.insert( count as usize, '\n' )
                {
                    Ok( _ ) => {},
                    Err( e ) => { println!( "sub-prompt error: {}", e ); }
                }

                prompter.insert_str( ">> " )
            }
            else { Ok( () ) }
        }
    }
}
/// Utilities for formatting and printing Strings.
pub mod fmt
{
    pub use std::fmt::{ * };
    use ::
    {
        cmp::{ min },
    };
    /*
    pub fn format_columns<S: AsRef<str>>( strs:&[S], screen_width:usize, horizontal:bool ) -> Option<Vec<usize>> */
    /// Formats a series of strings into columns, fitting within a given screen width.
    pub fn columns<S: AsRef<str>>( strs:&[S], screen_width:usize, horizontal:bool ) -> Option<Vec<usize>>
    {
        if strs.is_empty() { return None; }

        let n_strs = strs.len();
        let ( mut min_len, mut max_len ) = min_max( strs.iter().map( |s| s.as_ref().chars().count() ) );

        if min_len == 0 { min_len = 1; }

        if max_len == 0 { max_len = 1; }

        let mut min_cols = min( n_strs, screen_width / max_len );
        let max_cols = min( n_strs, screen_width / min_len );

        if min_cols <= 1 { min_cols = 2; }

        if max_cols <= 1 { return None; }

        let mut col_sizes = if min_cols == max_cols { vec![vec![0; max_cols]] }
        else { ( min_cols..max_cols + 1 ).map( |n| vec![0; n] ).collect::<Vec<_>>() };

        for ( i, s ) in strs.iter().enumerate()
        {
            let len = s.as_ref().chars().count();

            for cols in &mut col_sizes
            {
                let n_cols = cols.len();
                let col = if horizontal
                {
                    i % n_cols
                }
                else
                {
                    let per_col = ( n_strs + ( n_cols - 1 ) ) / n_cols;
                    i / per_col
                };

                let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                if real_len > cols[col] { cols[col] = real_len; }
            }
        }

        for cols in col_sizes.into_iter().rev()
        {
            if cols.iter().fold( 0, |a, b| a + b ) <= screen_width { return Some( cols ); }
        }

        None
    }
}
/// Filesystem manipulation operations.
pub mod fs
{
    pub use std::fs::{ * };
    use ::
    {
        path::{ Path },
        *
    };

    pub fn get_rc_file() -> String
    {
        let dir_config = tools::get_config_dir();
        let rc_file = format!( "{}/cicadarc", dir_config );
        
        if Path::new( &rc_file ).exists() { return rc_file; }
        
        let home = tools::get_user_home();
        let rc_file_home = format!( "{}/{}", home, ".cicadarc" );
        
        if Path::new( &rc_file_home ).exists() { return rc_file_home; }
        
        rc_file
    }

    pub fn load_rc_files( sh:&mut shell::Shell )
    {
        let rc_file = get_rc_file();

        if !Path::new( &rc_file ).exists() { return; }

        let args = vec!["source".to_string(), rc_file];
        scripts::run( sh, &args );
    }
}
/// Asynchronous basic functionality.
pub mod future
{
    pub use std::future::{ * };
}
/// State Reading
pub mod get
{
    use ::
    {
        borrow::{ Cow },
        env::{ var },
        ops::{Range, RangeFrom, RangeFull, RangeTo},
        str::{from_utf8, from_utf8_unchecked},
        *,
    };
    /*
    pub fn getpid() -> i32 */
    pub fn pid() -> i32 { unsafe { libc::getpid() } }
    /*
    pub fn get_user_name() -> String */
    pub fn username() -> String
    {
        match var( "USER" )
        {
            Ok( x ) => { return x; }
            Err( e ) => { log!( "cicada: env USER error: {}", e ); }
        }

        let cmd_result = now::run( "whoami" );
        return cmd_result.stdout.trim().to_string();
    }
    /*
    pub fn get_user_home() -> String */
    pub fn user_home() -> String
    {
        match env::var( "HOME" )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: env HOME error: {}", e );
                String::new()
            }
        }
    }
    /*
    fn brace_getgroup( ... ) -> Option<( Vec<String>, String )> */
    pub fn braces( s:&str, depth: i32 ) -> Option<( Vec<String>, String )>
    {
        let mut out: Vec<String> = Vec::new();
        let mut comma = false;
        let mut ss = s.to_string();

        while !ss.is_empty()
        {
            let ( g, sss ) = braced( ss.as_str(), depth );
            ss = sss.clone();
            if ss.is_empty()
            { break; }

            for x in g.iter()
            {
                out.push( x.clone() );
            }

            let c = match ss.chars().next()
            {
                Some( x ) => x,
                None =>
                {
                    break;
                }
            };

            if c == '}'
            {
                let mut sss = ss.clone();
                sss.remove( 0 );
                
                if comma { return Some(( out, sss ) ); }
                
                let mut result = Vec::new();

                for x in out.iter()
                {
                    let item = format!( "{{{}}}", x );
                    result.push( item );
                }

                return Some(( result, ss ) );
            }

            if c == ','
            {
                comma = true;
                ss.remove( 0 );
            }
        }

        None
    }
    /*
    fn brace_getitem( ... ) -> ( Vec<String>, String ) */
    pub fn braced( s:&str, depth: i32 ) -> ( Vec<String>, String )
    {
        let mut out: Vec<String> = vec![String::new()];
        let mut ss = s.to_string();
        let mut tmp;
        
        while !ss.is_empty()
        {
            let c = match ss.chars().next()
            {
                Some( x ) => x,
                None => { return ( out, ss ); }
            };

            if depth > 0 && ( c == ',' || c == '}' )
            { return ( out, ss ); }

            if c == '{'
            {
                let mut sss = ss.clone();
                sss.remove( 0 );
                let result_groups = braces( &sss, depth + 1 );
                
                if let Some(( out_group, s_group ) ) = result_groups
                {
                    let mut tmp_out = Vec::new();
                    for x in out.iter()
                    {
                        for y in out_group.iter()
                        {
                            let item = format!( "{}{}", x, y );
                            tmp_out.push( item );
                        }
                    }

                    out = tmp_out;
                    ss = s_group.clone();
                    continue;
                }
            }
            
            if c == '\\' && ss.len() > 1
            {
                ss.remove( 0 );
                let c;

                match ss.chars().next()
                {
                    Some( x ) => c = x,
                    None => { return ( out, ss ) }
                }

                tmp = format!( "\\{}", c );
            }

            else { tmp = c.to_string(); }
            
            let mut result = Vec::new();
            
            for x in out.iter()
            {
                let item = format!( "{}{}", x, tmp );
                result.push( item );
            }

            out = result;
            ss.remove( 0 );
        }

        ( out, ss )
    }
    
    pub fn backward_word( n:usize, buf:&str, cur:usize, word_break:&str ) -> usize
    {
        let mut chars = buf[..cur].char_indices().rev();

        for _ in 0..n
        {
            drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none()
            { break; }
            drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none()
            { break; }
        }

        match chars.next()
        {
            Some(( ind, ch )) => ind + ch.len_utf8(),
            None => 0
        }
    }

    pub fn forward_word( n:usize, buf:&str, cur:usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n
        {
            drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            
            if chars.clone().next().is_none() { break; }

            drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some(( ind, _ )) => cur + ind,
            None => buf.len()
        }
    }

    pub fn back_n_words( n:usize, buf:&str, cur:usize, word_break:&str ) -> Range<usize>
    {
        let prev = backward_word( 1, buf, cur, word_break );
        let end = word_end( &buf, prev, word_break );

        if n > 1
        {
            let start = backward_word( n - 1, buf, prev, word_break );
            start..end
        }

        else { prev..end }
    }

    pub fn forward_n_words( n:usize, buf:&str, cur:usize, word_break:&str ) -> Range<usize>
    {
        let start = next_word( 1, buf, cur, word_break );

        if n > 1
        {
            let last = next_word( n - 1, buf, start, word_break );
            let end = word_end( buf, last, word_break );
            start..end
        }
        
        else
        {
            let end = word_end( buf, start, word_break );
            start..end
        }
    }
    /// Returns the longest common prefix of a set of strings.
    pub fn longest_common_prefix<'a, I, S>( iter: I ) -> Option<&'a str> where
    I: IntoIterator<Item=&'a S>,
    S: 'a + ?Sized + AsRef<str>
    {
        let mut iter = iter.into_iter();
        let mut pfx = iter.next()?.as_ref();

        for s in iter
        {
            let s = s.as_ref();

            let n = pfx.chars().zip( s.chars() )
            .take_while( |&( a, b )| a == b )
            .map( |( ch, _ )| ch.len_utf8() ).sum();

            if n == 0 { return None; }
            else { pfx = &pfx[..n]; }
        }

        Some( pfx )
    }

    pub fn word_start( buf:&str, cur:usize, word_break:&str ) -> usize
    {
        let fwd = match buf[cur..].chars().next()
        {
            Some( ch ) => word_break.contains( ch ),
            None => return buf.len()
        };

        if fwd
        {
            next_word( 1, buf, cur, word_break )
        }
        
        else
        {
            let mut chars = buf[..cur].char_indices().rev();
            drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );

            match chars.next()
            {
                Some(( idx, ch )) => idx + ch.len_utf8(),
                None => 0
            }
        }
    }

    pub fn word_end( buf:&str, cur:usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();
        drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );

        match chars.next()
        {
            Some(( idx, _ )) => cur + idx,
            None => buf.len()
        }
    }
    /*
    pub fn get_escape_char( ch: char ) -> Option<char> */
    /// If `ch` preceded by a backslash together form an escape character, then return this char.
    pub fn escape_char( ch: char ) -> Option<char>
    {
        match ch
        {
            '\\' => Some( '\\'),
            '"' => Some( '"'),
            '\'' => Some( '\''),
            '$' => Some( '$'),
            'n' => Some( '\n'),
            'r' => Some( '\r'),
            't' => Some( '\t'),
            _ => None,
        }
    }
}
/// Generic hashing support.
pub mod hash
{
    pub use std::hash::{ * };
}
/// Hints to compiler that affects how code should be emitted or optimized.
pub mod hint
{
    pub use std::hint::{ * };
}
/// Input History
pub mod history
{
    use ::
    {
        collections::{ HashMap },
        terminal::{ DefaultTerminal, Interface },
        io::{ Write },
        path::{ Path },
        *,
    };
    /*
    use rusqlite::Connection as Conn;
    use rusqlite::Error::SqliteFailure;

    use ::shell;
    use ::tools;
    */
    fn init_db( hfile:&str, htable:&str )
    {
        let path = Path::new( hfile );
        if !path.exists()
        {
            let _parent = match path.parent()
            {
                Some( x ) => x,
                None =>
                {
                    println_stderr!( "cicada: history init - no parent found" );
                    return;
                }
            };
            let parent = match _parent.to_str()
            {
                Some( x ) => x,
                None =>
                {
                    println_stderr!( "cicada: parent to_str is None" );
                    return;
                }
            };

            match fs::create_dir_all( parent )
            {
                Ok( _ ) => {}
                Err( e ) =>
                {
                    println_stderr!( "cicada: histdir create error: {}", e );
                    return;
                }
            }

            match fs::File::create( hfile )
            {
                Ok( _ ) => { println!( "cicada: created history file: {}", hfile ); }
                Err( e ) => { println_stderr!( "cicada: history: file create failed: {}", e ); }
            }
        }

        let conn = match Connection::open( hfile )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: history: open db error: {}", e );
                return;
            }
        };

        let sql = format!
        ("
            CREATE TABLE IF NOT EXISTS {}
            (
                inp TEXT,
                rtn INTEGER,
                tsb REAL,
                tse REAL,
                sessionid TEXT,
                out TEXT,
                info TEXT
            );", htable 
        );

        match conn.execute( &sql, [] )
        {
            Ok( _ ) => {}
            Err( e ) => println_stderr!( "cicada: history: query error: {}", e ),
        }
    }

    pub fn init( rl:&mut Interface<DefaultTerminal> )
    {
        let mut hist_size: usize = 99999;

        if let Ok( x ) = env::var( "HISTORY_SIZE" )
        {
            if let Ok( y ) = x.parse::<usize>()
            {
                hist_size = y;
            }
        }

        rl.set_history_size( hist_size );

        let history_table = get_history_table();
        let hfile = get_history_file();

        if !Path::new( &hfile ).exists()
        {
            init_db( &hfile, &history_table );
        }

        let mut delete_dups = true;
        if let Ok( x ) = env::var( "HISTORY_DELETE_DUPS" )
        {
            if x == "0" { delete_dups = false; }
        }

        if delete_dups { delete_duplicated_histories(); }

        let conn = match Connection::open( &hfile )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: history: conn error: {}", e );
                return;
            }
        };

        let sql = format!( "SELECT inp FROM {} ORDER BY tsb;", history_table );
        let mut stmt = match conn.prepare( &sql )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: prepare select error: {}", e );
                return;
            }
        };

        let rows = match stmt.query_map( [], |row| row.get( 0 ) )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: query select error: {}", e );
                return;
            }
        };

        let mut dict_helper: HashMap<String, bool> = HashMap::new();
        for x in rows.flatten()
        {
            let inp: String = x;

            if dict_helper.contains_key( &inp ) { continue; }
            
            dict_helper.insert( inp.clone(), true );
            rl.add_history( inp.trim().to_string() );
        }
    }

    pub fn get_history_file() -> String
    {
        if let Ok( hfile ) = env::var( "HISTORY_FILE" ) { hfile } 
        else if let Ok( d ) = env::var( "XDG_DATA_HOME" ) { format!( "{}/{}", d, "cicada/history.sqlite" ) }
        else
        {
            let home = get::user_home();
            format!( "{}/{}", home, ".local/share/cicada/history.sqlite" )
        }
    }

    pub fn get_history_table() -> String
    {
        if let Ok( hfile ) = env::var( "HISTORY_TABLE" ) { hfile }
        else { String::from( "cicada_history" ) }
    }

    fn delete_duplicated_histories()
    {
        let hfile = get_history_file();
        let history_table = get_history_table();
        let conn = match Connection::open( &hfile )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: history: conn error: {}", e );
                return;
            }
        };
        let sql = format!
        (
            "DELETE FROM {} WHERE rowid NOT IN ( 
            SELECT MAX( rowid ) FROM {} GROUP BY inp )",
            history_table, history_table
        );
        
        match conn.execute( &sql, [] )
        {
            Ok( _ ) => {}
            Err( e ) => match e
            {
                SqliteFailure( ee, msg ) =>
                {
                    if ee.extended_code == 5
                    {
                        log!( "failed to delete dup histories: {}", msg.unwrap_or( "db is locked?".to_owned() ) );
                        return;
                    }

                    println_stderr!
                    (
                        "cicada: history: delete dups error: {}: {:?}",
                        &ee,
                        &msg
                   );
                }
                _ => { println_stderr!( "cicada: history: delete dup error: {}", e ); }
            },
        }
    }

    pub fn add_raw( sh:&shell::Shell, line:&str, status: i32, tsb: f64, tse: f64 )
    {
        let hfile = get_history_file();
        let history_table = get_history_table();

        if !Path::new( &hfile ).exists() { init_db( &hfile, &history_table ); }

        let conn = match Connection::open( &hfile )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "cicada: history: conn error: {}", e );
                return;
            }
        };
        let sql = format!
        (
            "INSERT INTO \
            {} ( inp, rtn, tsb, tse, sessionid, info ) \
            VALUES( '{}', {}, {}, {}, '{}', 'dir:{}|' );",
            history_table,
            str::replace( line.trim(), "'", "''" ),
            status,
            tsb,
            tse,
            sh.session_id,
            sh.current_dir
        );
        match conn.execute( &sql, [] )
        {
            Ok( _ ) => {}
            Err( e ) => println_stderr!( "cicada: history: save error: {}", e ),
        }
    }

    pub fn add( sh:&shell::Shell, rl:&mut Interface<DefaultTerminal>, line:&str, status: i32, tsb: f64, tse: f64 )
    {
        add_raw( sh, line, status, tsb, tse );
        rl.add_history( line.to_string() );
    }
}
/// State Verification
pub mod is
{
    use ::
    {
        char::{ CTRL_MASK, width },
        env::{ var },
        regex::{ contains, Regex },
        *,
    };
    
    pub const NONE: u8 = 0b000000;
    pub const PRINT: u8 = 0b000001;
    pub const SPACE: u8 = 0b000010;
    pub const CONTROL: u8 = 0b000100;
    pub const PIPE: u8 = 0b001000;
    pub const COMMA: u8 = 0b010000;
    pub const EOL: u8 = 0b100000;

    pub static ASCII: [u8; 256] =
    [
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, SPACE, EOL, NONE, NONE, EOL, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        PRINT | SPACE, PRINT, PRINT, PRINT | CONTROL, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT | COMMA | CONTROL, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT | CONTROL, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT | PIPE, PRINT, PRINT, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
    ];
    /*
    is_ws( ... ) -> bool */
    #[inline(always)] pub fn ws(ch: u8) -> bool
    { unsafe { ASCII.get_unchecked(ch as usize) & SPACE == SPACE } }
    /*
    is_eol( ... ) -> bool */
    #[inline(always)] pub fn eol(ch: u8) -> bool
    { unsafe { ASCII.get_unchecked(ch as usize) & EOL == EOL } }
    /*
    is_printable( ... ) -> bool */
    /// Returns whether the character is printable.
    pub fn printable(c: char) -> bool { c == '\t' || c == '\n' || !(c == '\0' || ctrl(c)) }
    /*
    is_printable_no_pipe( ... ) -> bool */
    #[inline(always)] pub fn printable_no_pipe(ch: u8) -> bool
    { unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | PIPE) == PRINT } }
    /*
    is_printable_no_comma( ... ) -> bool */
    #[inline(always)] pub fn printable_no_comma(ch: u8) -> bool
    { unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | COMMA) == PRINT } }
    /*
    is_printable_no_control( ... ) -> bool */
    #[inline(always)] pub fn printable_no_control(ch: u8) -> bool 
    { unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | CONTROL) == PRINT } }
    /*
    is_command_string( ... ) -> bool */
    pub fn command_string( args:&[String] ) -> bool { args.len() > 1 && args[1] == "-c" }
    /*
    is_login( ... ) -> bool */
    pub fn login( args:&[String] ) -> bool
    {
        if !args.is_empty() && args[0].starts_with( "-" )
        { return true; }

        if args.len() > 1 && ( args[1] == "--login" || args[1] == "-l" )
        { return true; }

        if let Ok( term_program ) = var( "TERM_PROGRAM" )
        { if term_program == "vscode" { return true; } }

        false
    }
    /*
    is_non_tty( ... ) -> bool */
    pub fn non_tty() -> bool { unsafe { libc::isatty( 0 ) == 0 } }
    /*
    is_shell_altering_command( ... ) -> bool */
    pub fn shell_altering_command( line:&str ) -> bool
    {
        let line = line.trim();
        
        if contains( line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$" ) { return true; }
        
        line.starts_with( "alias " )
        || line.starts_with( "export " )
        || line.starts_with( "unalias " )
        || line.starts_with( "unset " )
        || line.starts_with( "source " )
    }
    /*
    is_script( ... ) -> bool */
    pub fn script( args:&[String] ) -> bool { args.len() > 1 && !args[1].starts_with( "-" ) }
    /*
    is_signal_handler_enabled( ... ) -> bool */
    pub fn signal_handler_enabled() -> bool { var( "CICADA_ENABLE_SIG_HANDLER" ).map_or( false, |x| x == "1" ) }
    /*
    is_prefix_char( ... ) -> bool */
    pub fn prefix_char( c: char ) -> bool { c == '[' || c == '{' }
    /*
    is_suffix_char( ... ) -> bool */
    pub fn suffix_char( c: char ) -> bool { c == ']' || c == '}' }
    /*
    is_prompt_item_char( ... ) -> bool */
    pub fn prompt_item_char( c: char, token:&str ) -> bool 
    {
        let s = c.to_string();

        if token.is_empty() { contains( &s, r#"^[a-zA-Z_]$"# ) } 
        else { contains( &s, r#"^[a-zA-Z0-9_]$"# ) }
    }
    /*
    needs_globbing( ... ) -> bool */
    pub fn globable( line:&str ) -> bool 
    {
        let re = Regex::new( r"\*+" ).expect( "Invalid regex ptn" );
        re.is_match( line )
    }
    /*
    should_do_dollar_command_extension( ... ) -> bool */
    fn dollar_command_extensible( line:&str ) -> bool 
    { contains( line, r"\$\( [^\ )]+\ )" ) && !contains( line, r"='.*\$\( [^\ )]+\ ).*'$" ) }
    /*
    need_expand_brace( ... ) -> bool */
    fn brace_expandable( line:&str ) -> bool { contains( line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"# ) }
    /*
    is_digit( ... ) -> bool */
    /// Returns true if `ch` is an ASCII decimal digit.
    pub fn digit( ch: char ) -> bool
    {
        match ch
        {
            '0'..='9' => true,
            _ => false,
        }
    }
    /*
    is_value_end_char( ... ) -> bool */
    /// Returns true if this character signifies the legal end of a value.
    pub fn value_end_char( ch: char ) -> bool { is_whitespace( ch ) || is_end_delimiter( ch ) || is_operator( ch ) }
    /*
    is_whitespace( ... ) -> bool */
    /// Returns true if the character is either whitespace or '#' ( start of a comment ).
    pub fn whitespace( ch: char ) -> bool { ch.is_whitespace() || ch == '#' }
    /*
    is_end_delimiter( ... ) -> bool */
    pub fn end_delimiter( ch: char ) -> bool
    {
        match ch
        {
            ')' | ']' | '}' | '>' => true,
            _ => false,
        }
    }
    /*
    is_numeric_char( ... ) -> bool */
    pub fn numeric_char( ch: char ) -> bool
    {
        match ch
        {
            _ch if is_digit( _ch ) => true,
            '.' | ',' => true,
            _ => false,
        }
    }
    /*
    is_priority_operator( ... ) -> bool */
    pub fn priority_operator( ch: char ) -> bool
    {
        match ch
        {
            '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /*
    is_operator( ... ) -> bool */
    pub fn operator( ch: char ) -> bool
    {
        match ch
        {
            '+' | '-' | '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /*
    is_reserved( ... ) -> bool */
    pub fn reserved( field: &str ) -> bool
    {
        match field
        {
            "@" | "null" | "true" | "false" | "Obj" | "Str" | "Arr" | "Tup" => true,
            _ => false,
        }
    }
    /*
    is_combining_mark( ... ) -> bool */
    /// Returns whether the given character is a combining mark.
    #[inline] pub fn combining_mark(ch: char) -> bool
    {
        use unicode_normalization::char::is_combining_mark;
        is_combining_mark(ch)
    }
    /*
    is_ctrl( ... ) -> bool */
    /// Returns whether the given character is a control character.
    #[inline] pub fn ctrl(ch: char) -> bool
    {
        let ch = ch as u32;
        ch & (CTRL_MASK as u32) == ch
    }
    /*
    is_visible( ... ) -> bool */
    pub fn visible(ch: char) -> bool
    {
        match ch
        {
            '\t' | '\r' | '\n' => true,
            _ => width( ch ).unwrap_or(0) != 0
        }
    }
    /*
    is_arithmetic( ... ) -> bool */
    pub fn arithmetic( line:&str ) -> bool
    {
        if !re_contains(line, r"[0-9]+") { return false; }
        if !re_contains(line, r"\+|\-|\*|/|\^") { return false; }
        contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
    }
    /*
    is_command( ... ) -> bool */
    fn command( word: &str ) -> bool
    {
        if is::builtin(word) { return true; }
        if let Ok(aliases) = ALIASES.lock() { if aliases.contains(word) { return true; } }
        if let Ok(commands) = AVAILABLE_COMMANDS.lock() { if commands.contains(word) { return true; } }
        false
    }
}
/// Traits, helpers, and type definitions for core I/O functionality.
pub mod io
{
    pub use std::io::{ * };

    pub mod reader
    {
        //! Provides access to terminal read operations
        use ::
        {
            borrow::{ Cow },
            collections::{ HashMap, SequenceMap, Entry, VecDeque },
            command::{ Category, Command },
            ffi::{ Function },
            mem::{ replace },
            ops::{ Deref, DerefMut },
            path::{ Path, PathBuf },
            signals::{ Signal },
            sync::{ Arc, MutexGuard },
            terminal::
            { 
                Interface,
                size::Size, 
                Terminals,
            },
            timed::{ Duration, Instant },
            *,
        };
        /*
        use ::complete::{Completer, Completion, DummyCompleter};
        use ::inputrc::{parse_file, Directive};
        use ::interface::Interface;
        use ::prompter::Prompter;
        use ::sys::path::{env_init_file, system_init_file, user_init_file};
        use ::terminal::{
            RawRead, Signal, SignalSet, Size,
            Terminal, TerminalReader,
        };
        use ::util::{first_char, match_name};
        use ::variables::{Variable, Variables, VariableIter};
        */
        /// Default set of string characters
        pub const STRING_CHARS:&str = "\"'";
        /// Default set of word break characters
        pub const WORD_BREAK_CHARS:&str = " \t\n\"\\'`@$><=;|&{( ";
        /// Indicates the start of a series of invisible characters in the prompt
        pub const START_INVISIBLE: char = '\x01';
        /// Indicates the end of a series of invisible characters in the prompt
        pub const END_INVISIBLE: char = '\x02';
        /// Maximum size of kill ring
        const MAX_KILLS: usize = 10;
        /// Represents the result of a `Terminal` read operation
        pub enum RawRead
        {
            /// `n` bytes were read from the device
            Bytes( usize ),
            /// The terminal window was resized
            Resize( Size ),
            /// A signal was received while waiting for input
            Signal( Signal ),
        }

        /// Provides access to data related to reading and processing user input.
        pub struct Reader<'a, Term: 'a + Terminals>
        {
            iface:&'a Interface<Term>,
            lock:ReadLock<'a, Term>,
        }

        pub struct Read<Term: Terminals>
        {
            /// Application name
            pub application: Cow<'static, str>,
            /// Pending input
            pub input_buffer: Vec<u8>,
            /// Pending macro sequence
            pub macro_buffer: String,
            pub bindings: SequenceMap<Cow<'static, str>, Command>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,
            /// Current input sequence
            pub sequence: String,
            /// Whether newline has been received
            pub input_accepted:bool,
            /// Whether overwrite mode is currently active
            pub overwrite_mode:bool,
            /// Characters appended while in overwrite mode
            pub overwritten_append:usize,
            /// Characters overwritten in overwrite mode
            pub overwritten_chars: String,
            /// Configured completer
            pub completer: Arc<dyn Completer<Term>>,
            /// Character appended to completions
            pub completion_append_character:Option<char>,
            /// Current set of possible completions
            pub completions:Option<Vec<Completion>>,
            /// Current "menu-complete" entry being viewed:
            pub completion_index:usize,
            /// Start of the completed word
            pub completion_start:usize,
            /// Start of the inserted prefix of a completed word
            pub completion_prefix:usize,
            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,
            pub last_cmd: Category,
            pub last_yank:Option<( usize, usize )>,
            pub kill_ring: VecDeque<String>,
            pub catch_signals:bool,
            pub ignore_signals: SignalSet,
            pub report_signals: SignalSet,
            pub last_resize:Option<Size>,
            pub last_signal:Option<Signal>,
            variables: Variables,
            pub state: InputState,
            pub max_wait_duration:Option<Duration>,
        }

        pub struct ReadLock<'a, Term: 'a + Terminals>
        {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }
        /// Returned from [`read_line`] to indicate user input
        #[derive( Debug )]
        pub enum ReadResult
        {
            /// User issued end-of-file
            Eof,
            /// User input received
            Input( String ),
            /// Reported signal was received
            Signal( Signal ),
        }

        #[derive( Copy, Clone, Debug )]
        pub enum InputState
        {
            Inactive,
            NewSequence,
            ContinueSequence
            {
                expiry:Option<Instant>,
            },
            Number,
            CharSearch
            {
                n:usize,
                backward:bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore( usize ),
            QuotedInsert( usize ),
        }

        impl<'a, Term: 'a + Terminals> Reader<'a, Term> 
        {
            pub fn new( iface:&'a Interface<Term>, lock:ReadLock<'a, Term> ) -> Reader<'a, Term>
            {
                Reader{iface, lock}
            }
            /// Interactively reads a line from the terminal device.
            pub fn read_line( &mut self ) -> io::Result<ReadResult>
            {
                loop
                {
                    if let Some( res ) = self.read_line_step( None )? { return Ok( res ); }
                }
            }
            /// Performs one step of the interactive `read_line` loop.
            pub fn read_line_step( &mut self, timeout:Option<Duration> ) -> io::Result<Option<ReadResult>>
            {
                self.initialize_read_line()?;
                let state = self.prepare_term()?;
                let res = self.read_line_step_impl( timeout );
                self.lock.term.restore( state )?;
                res
            }
            /// Cancels an in-progress `read_line` operation.
            pub fn cancel_read_line( &mut self ) -> io::Result<()> { self.end_read_line() }

            fn initialize_read_line( &mut self ) -> io::Result<()>
            {
                if !self.lock.is_active() { self.prompter().start_read_line()?; }
                Ok( () )
            }

            fn read_line_step_impl( &mut self, timeout:Option<Duration> ) -> io::Result<Option<ReadResult>>
            {
                let do_read = if self.lock.is_input_available()
                { self.lock.term.wait_for_input( Some( Duration::from_secs( 0 ) ) )? }
                
                else
                {
                    let timeout = limit_duration( timeout, self.lock.max_wait_duration );
                    self.lock.term.wait_for_input( timeout )?
                };

                if do_read { self.lock.read_input()?; }

                if let Some( size ) = self.lock.take_resize() { self.handle_resize( size )?; }

                if let Some( sig ) = self.lock.take_signal()
                {
                    if self.lock.report_signals.contains( sig ) { return Ok( Some( ReadResult::Signal( sig ) ) ); }
                    if !self.lock.ignore_signals.contains( sig ) { self.handle_signal( sig )?; }
                }

                {
                    let mut prompter = self.prompter();
                    prompter.check_expire_timeout()?;
                    let mut macro_len = prompter.read.data.macro_buffer.len();

                    while prompter.read.is_input_available()
                    {
                        if let Some( ch ) = prompter.read.read_char()?
                        {
                            if let Some( r ) = prompter.handle_input( ch )?
                            {
                                prompter.end_read_line()?;
                                return Ok( Some( r ) );
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len { break; }

                        macro_len = new_macro_len;
                    }
                }

                Ok( None )
            }

            fn end_read_line( &mut self ) -> io::Result<()>
            {
                if self.lock.is_active() { self.prompter().end_read_line()?; }
                
                Ok( () )
            }

            fn prepare_term( &mut self ) -> io::Result<Term::PrepareState>
            {
                if self.read_next_raw() { self.lock.term.prepare( true, SignalSet::new() ) }
                else
                {
                    let mut signals = self.lock.report_signals.union( self.lock.ignore_signals );

                    if self.lock.catch_signals
                    {
                        signals.insert( Signal::Interrupt );
                    }

                    let block_signals = !self.lock.catch_signals;
                    self.lock.term.prepare( block_signals, signals )
                }
            }

            fn read_next_raw( &self ) -> bool
            {
                match self.lock.state
                {
                    InputState::QuotedInsert( _ ) => true,
                    _ => false
                }
            }
            /// Sets the input buffer to the given string.
            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()>
            {
                if self.lock.is_active() { self.prompter().set_buffer( buf ) }
                
                else
                {
                    self.iface.lock_write_data().set_buffer( buf );
                    Ok( () )
                }
            }
            /// Sets the cursor position in the input buffer.
            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()>
            {
                if self.lock.is_active() { self.prompter().set_cursor( pos ) }
                else
                {
                    self.iface.lock_write_data().set_cursor( pos );
                    Ok( () )
                }
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> { self.prompter().set_prompt( prompt ) }
            /// Adds a line to history.
            pub fn add_history( &self, line: String )
            {
                if !self.lock.is_active()
                {
                    if let Ok( mut lock ) = self.iface.lock_write() { lock.add_history( line ); }
                }
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique( &self, line: String )
            {
                if !self.lock.is_active()
                {
                    if let Ok( mut lock ) = self.iface.lock_write() { lock.add_history_unique( line ); }
                }
            }
            /// Removes all history entries.
            pub fn clear_history( &self )
            {
                if !self.lock.is_active()
                {
                    if let Ok( mut lock ) = self.iface.lock_write() { lock.clear_history(); }
                }
            }
            /// Removes the history entry at the given index.
            pub fn remove_history( &self, idx: usize )
            {
                if !self.lock.is_active()
                {
                    if let Ok( mut lock ) = self.iface.lock_write() { lock.remove_history( idx ); }
                }
            }
            /// Sets the maximum number of history entries.
            pub fn set_history_size( &self, n: usize )
            {
                if !self.lock.is_active()
                {
                    if let Ok( mut lock ) = self.iface.lock_write() { lock.set_history_size( n ); }
                }
            }
            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history( &self, n: usize )
            {
                if !self.lock.is_active()
                {
                    if let Ok( mut lock ) = self.iface.lock_write() { lock.truncate_history( n ); }
                }
            }
            /// Returns the application name
            pub fn application( &self ) -> &str { &self.lock.application }
            /// Sets the application name
            pub fn set_application<T>( &mut self, application:T ) where
            T: Into<Cow<'static, str>>
            { self.lock.application = application.into(); }
            /// Returns a reference to the current completer instance.
            pub fn completer( &self ) -> &Arc<dyn Completer<Term>> { &self.lock.completer }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer( &mut self, completer: Arc<dyn Completer<Term>> ) -> Arc<dyn Completer<Term>>
            { replace( &mut self.lock.completer, completer ) }
            /// Returns the value of the named variable or `None` if no such variable exists.
            pub fn get_variable( &self, name:&str ) -> Option<Variable> { self.lock.get_variable( name ) }
            /// Sets the value of the named variable and returns the previous value.
            pub fn set_variable( &mut self, name:&str, value:&str ) -> Option<Variable>
            { self.lock.set_variable( name, value ) }
            /// Returns an iterator over stored variables.
            pub fn variables( &self ) -> VariableIter { self.lock.variables.iter() }
            /// Returns whether to "blink" matching opening parenthesis character 
            /// when a closing parenthesis character is entered.
            pub fn blink_matching_paren( &self ) -> bool { self.lock.blink_matching_paren }
            /// Sets the `blink-matching-paren` variable.
            pub fn set_blink_matching_paren( &mut self, set:bool ) { self.lock.blink_matching_paren = set; }
            /// Returns whether `lineread` will catch certain signals.
            pub fn catch_signals( &self ) -> bool { self.lock.catch_signals }
            /// Sets whether `lineread` will catch certain signals.
            pub fn set_catch_signals( &mut self, enabled:bool ) { self.lock.catch_signals = enabled; }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal( &self, signal: Signal ) -> bool { self.lock.ignore_signals.contains( signal ) }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal( &mut self, signal: Signal, set:bool )
            {
                if set
                {
                    self.lock.ignore_signals.insert( signal );
                    self.lock.report_signals.remove( signal );
                }
                else { self.lock.ignore_signals.remove( signal ); }
            }
            /// Returns whether the given `Signal` is to be reported.
            pub fn report_signal( &self, signal: Signal ) -> bool { self.lock.report_signals.contains( signal ) }
            /// Sets whether to report the given `Signal`.
            pub fn set_report_signal( &mut self, signal: Signal, set:bool )
            {
                if set
                {
                    self.lock.report_signals.insert( signal );
                    self.lock.ignore_signals.remove( signal );
                }
                else { self.lock.report_signals.remove( signal ); }
            }
            /// Returns whether Tab completion is disabled.
            pub fn disable_completion( &self ) -> bool { self.lock.disable_completion }
            /// Sets the `disable-completion` variable.
            pub fn set_disable_completion( &mut self, disable:bool ) { self.lock.disable_completion = disable; }
            /// When certain control characters are pressed, 
            /// a character sequence equivalent to this character will be echoed.
            pub fn echo_control_characters( &self ) -> bool { self.lock.echo_control_characters }
            /// Sets the `echo-control-characters` variable.
            pub fn set_echo_control_characters( &mut self, echo:bool ) { self.lock.echo_control_characters = echo; }
            /// Returns the character, if any, that is appended to a successful completion.
            pub fn completion_append_character( &self ) -> Option<char> { self.lock.completion_append_character }
            /// Sets the character, if any, that is appended to a successful completion.
            pub fn set_completion_append_character( &mut self, ch:Option<char> )
            { self.lock.completion_append_character = ch; }
            /// Returns the width of completion listing display.
            pub fn completion_display_width( &self ) -> usize { self.lock.completion_display_width }
            /// Sets the `completion-display-width` variable.
            pub fn set_completion_display_width( &mut self, n: usize ) { self.lock.completion_display_width = n; }
            /// Returns the minimum number of completion items that require user confirmation before listing.
            pub fn completion_query_items( &self ) -> usize { self.lock.completion_query_items }
            /// Sets the `completion-query-items` variable.
            pub fn set_completion_query_items( &mut self, n: usize ) { self.lock.completion_query_items = n; }
            /// Returns the timeout to wait for further user input when an ambiguous sequence has been entered. 
            pub fn keyseq_timeout( &self ) -> Option<Duration> { self.lock.keyseq_timeout }
            /// Sets the `keyseq-timeout` variable.
            pub fn set_keyseq_timeout( &mut self, timeout:Option<Duration> ) { self.lock.keyseq_timeout = timeout; }
            /// Returns whether to list possible completions one page at a time.
            pub fn page_completions( &self ) -> bool { self.lock.page_completions }
            /// Sets the `page-completions` variable.
            pub fn set_page_completions( &mut self, set:bool ) { self.lock.page_completions = set; }
            /// Returns whether to list completions horizontally, rather than down the screen.
            pub fn print_completions_horizontally( &self ) -> bool { self.lock.print_completions_horizontally }
            /// Sets the `print-completions-horizontally` variable.
            pub fn set_print_completions_horizontally( &mut self, set:bool )
            { self.lock.print_completions_horizontally = set; }
            /// Returns the set of characters that delimit strings.
            pub fn string_chars( &self ) -> &str { &self.lock.string_chars }
            /// Sets the set of characters that delimit strings.
            pub fn set_string_chars<T>( &mut self, chars:T ) where 
            T: Into<Cow<'static, str>>
            { self.lock.string_chars = chars.into(); }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars( &self ) -> &str { &self.lock.word_break }
            /// Sets the set of characters that indicate a word break.
            pub fn set_word_break_chars<T>( &mut self, chars:T ) where
            T: Into<Cow<'static, str>>
            { self.lock.word_break = chars.into(); }
            /// Returns an iterator over bound sequences
            pub fn bindings( &self ) -> BindingIter { self.lock.bindings() }
            /// Binds a sequence to a command.
            pub fn bind_sequence<T>( &mut self, seq:T, cmd: Command ) -> Option<Command> where 
            T: Into<Cow<'static, str>>
            { self.lock.bind_sequence( seq, cmd ) }
            /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
            pub fn bind_sequence_if_unbound<T>( &mut self, seq:T, cmd: Command ) -> bool where 
            T: Into<Cow<'static, str>> 
            { self.lock.bind_sequence_if_unbound( seq, cmd ) }
            /// Removes a binding for the given sequence.
            pub fn unbind_sequence( &mut self, seq:&str ) -> Option<Command> { self.lock.unbind_sequence( seq ) }
            /// Defines a named function to which sequences may be bound.
            pub fn define_function<T>( &mut self, name:T, cmd: Arc<dyn Function<Term>> ) -> 
            Option<Arc<dyn Function<Term>>> where 
            T: Into<Cow<'static, str>>
            { self.lock.define_function( name, cmd ) }
            /// Removes a function defined with the given name.
            pub fn remove_function( &mut self, name:&str ) -> Option<Arc<dyn Function<Term>>> 
            { self.lock.remove_function( name ) }

            pub fn evaluate_directives( &mut self, term:&Term, dirs: Vec<Directive> )
            { self.lock.data.evaluate_directives( term, dirs ) }

            pub fn evaluate_directive( &mut self, term:&Term, dir: Directive )
            { self.lock.data.evaluate_directive( term, dir ) }

            fn prompter<'b>( &'b mut self ) -> Prompter<'b, 'a, Term>
            {
                Prompter::new
                (
                    &mut self.lock,
                    self.iface.lock_write().expect( "Failed to acquire write lock" )
                )
            }
            
            fn handle_resize( &mut self, size:Size ) -> io::Result<()> { self.prompter().handle_resize( size ) }

            fn handle_signal( &mut self, sig: Signal ) -> io::Result<()> { self.prompter().handle_signal( sig ) }
        }

        impl<'a, Term: 'a + Terminals> ReadLock<'a, Term> 
        {
            pub fn new( term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>> ) -> 
            ReadLock<'a, Term>
            { ReadLock{term, data} }
            /// Reads the next character of input.
            pub fn read_char( &mut self ) -> io::Result<Option<char>>
            {
                if let Some( ch ) = self.macro_pop() { Ok( Some( ch ) ) }
                else if let Some( ch ) = self.decode_input()? { Ok( Some( ch ) ) }
                else { Ok( None ) }
            }

            fn read_input( &mut self ) -> io::Result<()>
            {
                match self.term.read( &mut self.data.input_buffer )?
                {
                    RawRead::Bytes( _ ) => (),
                    RawRead::Resize( new_size ) => { self.last_resize = Some( new_size ); }
                    RawRead::Signal( sig ) => { self.last_signal = Some( sig ); }
                }

                Ok( () )
            }

            fn is_input_available( &self ) -> bool
            {
                !self.data.macro_buffer.is_empty() || match self.peek_input()
                {
                    Ok( Some( _ ) ) | Err( _ ) => true,
                    Ok( None ) => false
                }
            }

            fn macro_pop( &mut self ) -> Option<char>
            {
                if self.data.macro_buffer.is_empty() { None }
                else { Some( self.data.macro_buffer.remove( 0 ) ) }
            }

            fn decode_input( &mut self ) -> io::Result<Option<char>>
            {
                let res = self.peek_input();

                if let Ok( Some( ch ) ) = res { self.data.input_buffer.drain( ..ch.len_utf8() ); }

                res
            }

            fn peek_input( &self ) -> io::Result<Option<char>>
            {
                if self.data.input_buffer.is_empty() { Ok( None ) }
                else { first_char( &self.data.input_buffer ) }
            }

            pub fn reset_data( &mut self )
            {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminals> Deref for ReadLock<'a, Term>
        {
            type Target = Read<Term>;
            fn deref( &self ) -> &Read<Term> { &self.data }
        }

        impl<'a, Term: 'a + Terminals> DerefMut for ReadLock<'a, Term>
        {
            fn deref_mut( &mut self ) -> &mut Read<Term> { &mut self.data }
        }

        impl<Term: Terminals> Deref for Read<Term>
        {
            type Target = Variables;
            fn deref( &self ) -> &Variables { &self.variables }
        }

        impl<Term: Terminals> DerefMut for Read<Term>
        {
            fn deref_mut( &mut self ) -> &mut Variables { &mut self.variables }
        }

        impl<Term: Terminals> Read<Term>
        {
            pub fn new( term:&Term, application: Cow<'static, str> ) -> Read<Term>
            {
                let mut r = Read
                {
                    application,
                    bindings: default_bindings(),
                    functions: HashMap::new(),
                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),
                    sequence: String::new(),
                    input_accepted: false,
                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),
                    completer: Arc::new( DummyCompleter ),
                    completion_append_character: Some( ' ' ),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,
                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),
                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity( MAX_KILLS ),
                    catch_signals: true,
                    ignore_signals: SignalSet::new(),
                    report_signals: SignalSet::new(),
                    last_resize: None,
                    last_signal: None,
                    variables: Variables::default(),
                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init( term );
                r
            }

            pub fn bindings( &self ) -> BindingIter { BindingIter( self.bindings.sequences().iter() ) }

            pub fn variables( &self ) -> VariableIter { self.variables.iter() }

            fn take_resize( &mut self ) -> Option<Size> { self.last_resize.take() }

            fn take_signal( &mut self ) -> Option<Signal> { self.last_signal.take() }

            pub fn queue_input( &mut self, seq:&str ) { self.macro_buffer.insert_str( 0, seq ); }

            pub fn is_active( &self ) -> bool
            {
                match self.state
                {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data( &mut self )
            {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();
                self.completions = None;
                self.last_cmd = Category::Other;
                self.last_yank = None;
                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>( &mut self, seq:T, cmd: Command ) -> Option<Command> where 
            T: Into<Cow<'static, str>>
            { self.bindings.insert( seq.into(), cmd ) }

            pub fn bind_sequence_if_unbound<T>( &mut self, seq:T, cmd: Command ) -> bool where
            T: Into<Cow<'static, str>>
            {
                match self.bindings.entry( seq.into() )
                {
                    Entry::Occupied( _ ) => false,
                    Entry::Vacant( ent ) =>
                    {
                        ent.insert( cmd );
                        true
                    }
                }
            }

            pub fn unbind_sequence( &mut self, seq:&str ) -> Option<Command>
            {
                self.bindings.remove( seq ).map( |( _, cmd )| cmd )
            }

            pub fn define_function<T>( &mut self, name:T, cmd: Arc<dyn Function<Term>> ) -> 
            Option<Arc<dyn Function<Term>>> where 
            T: Into<Cow<'static, str>>
            { self.functions.insert( name.into(), cmd ) }

            pub fn remove_function( &mut self, name:&str ) -> Option<Arc<dyn Function<Term>>>
            { self.functions.remove( name ) }

            fn read_init( &mut self, term:&Term )
            {
                if let Some( path ) = env_init_file() { self.read_init_file_if_exists( term, Some( path ) );  }
                else
                {
                    if !self.read_init_file_if_exists( term, user_init_file() ) 
                    { self.read_init_file_if_exists( term, system_init_file() ); }
                }
            }

            fn read_init_file_if_exists( &mut self, term:&Term, path:Option<PathBuf> ) -> bool
            {
                match path
                {
                    Some( ref path ) if path.exists() =>
                    {
                        self.read_init_file( term, path );
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file( &mut self, term:&Term, path:&Path )
            {
                if let Some( dirs ) = parse_file( path ) { self.evaluate_directives( term, dirs ); }
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives( &mut self, term:&Term, dirs: Vec<Directive> )
            {
                for dir in dirs
                {
                    self.evaluate_directive( term, dir );
                }
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive( &mut self, term:&Term, dir: Directive )
            {
                match dir 
                {
                    Directive::Bind( seq, cmd ) => { self.bind_sequence( seq, cmd ); }
                    
                    Directive::Conditional{name, value, then_group, else_group} =>
                    {
                        let name = name.as_ref().map( |s| &s[..] );

                        if self.eval_condition( term, name, &value ) { self.evaluate_directives( term, then_group ); }

                        else { self.evaluate_directives( term, else_group ); }
                    }

                    Directive::SetVariable( name, value ) => { self.set_variable( &name, &value ); }
                }
            }

            fn eval_condition( &self, term:&Term, name:Option<&str>, value:&str ) -> bool
            {
                match name
                {
                    None => self.application == value,
                    Some( "lib" ) => value == "lineread",
                    Some( "mode" ) => value == "emacs",
                    Some( "term" ) => self.term_matches( term, value ),
                    _ => false
                }
            }

            fn term_matches( &self, term:&Term, value:&str ) -> bool { match_name( term.name(), value ) }
        }
        /// Iterator over `Reader` bindings
        pub struct BindingIter<'a>( slice::Iter<'a, ( Cow<'static, str>, Command )> );

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a>
        {
            type Item = ( &'a str, &'a Command );

            #[inline] fn next( &mut self ) -> Option<Self::Item>
            { self.0.next().map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }

            #[inline] fn nth( &mut self, n: usize ) -> Option<Self::Item>
            { self.0.nth( n ).map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }

            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.0.size_hint() }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a>
        {
            #[inline] fn next_back( &mut self ) -> Option<Self::Item>
            { self.0.next_back().map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
        }

        fn default_bindings() -> SequenceMap<Cow<'static, str>, Command>
        {
            use ::command::Command::*;

            SequenceMap::from( vec!
            [
                ( "\r".into(), AcceptLine ),
                ( "\n".into(), AcceptLine ),
                ( "\x1b[A".into(), PreviousHistory ),
                ( "\x1b[B".into(), NextHistory ),
                ( "\x1b[C".into(), ForwardChar ),
                ( "\x1b[D".into(), BackwardChar ),
                ( "\x1b[H".into(), BeginningOfLine ),
                ( "\x1b[F".into(), EndOfLine ),
                ( "\x1bOA".into(), PreviousHistory ),
                ( "\x1bOB".into(), NextHistory ),
                ( "\x1bOC".into(), ForwardChar ),
                ( "\x1bOD".into(), BackwardChar ),
                ( "\x1bOH".into(), BeginningOfLine ),
                ( "\x1bOF".into(), EndOfLine ),
                ( "\x1b[2~".into(), OverwriteMode ),
                ( "\x1b[3~".into(), DeleteChar ),
                ( "\x01"    .into(), BeginningOfLine ),
                ( "\x02"    .into(), BackwardChar ),   
                ( "\x04"    .into(), DeleteChar ),     
                ( "\x05"    .into(), EndOfLine ),      
                ( "\x06"    .into(), ForwardChar ),    
                ( "\x07"    .into(), Abort ),          
                ( "\x08"    .into(), BackwardDeleteChar ),
                ( "\x0b"    .into(), KillLine ),       
                ( "\x0c"    .into(), ClearScreen ),    
                ( "\x0e"    .into(), NextHistory ),    
                ( "\x10"    .into(), PreviousHistory ),
                ( "\x12"    .into(), ReverseSearchHistory ),
                ( "\x14"    .into(), TransposeChars ), 
                ( "\x15"    .into(), BackwardKillLine ),
                ( "\x16"    .into(), QuotedInsert ),   
                ( "\x17"    .into(), UnixWordRubout ), 
                ( "\x19"    .into(), Yank ),           
                ( "\x1d"    .into(), CharacterSearch ),
                ( "\x7f"    .into(), BackwardDeleteChar ),
                ( "\x1b\x08".into(), BackwardKillWord ),
                ( "\x1b\x1d".into(), CharacterSearchBackward ),
                ( "\x1b\x7f".into(), BackwardKillWord )
                ( "\x1bb"   .into(), BackwardWord ),   
                ( "\x1bd"   .into(), KillWord ),       
                ( "\x1bf"   .into(), ForwardWord ),    
                ( "\x1bt"   .into(), TransposeWords ), 
                ( "\x1by"   .into(), YankPop ),        
                ( "\x1b#"   .into(), InsertComment ),  
                ( "\x1b<"   .into(), BeginningOfHistory ),
                ( "\x1b>"   .into(), EndOfHistory ),
                ( "\t"   .into(), Complete ),
                ( "\x1b?".into(), PossibleCompletions ),
                ( "\x1b*".into(), InsertCompletions ),
                ( "\x1b-".into(), DigitArgument ),
                ( "\x1b0".into(), DigitArgument ),
                ( "\x1b1".into(), DigitArgument ),
                ( "\x1b2".into(), DigitArgument ),
                ( "\x1b3".into(), DigitArgument ),
                ( "\x1b4".into(), DigitArgument ),
                ( "\x1b5".into(), DigitArgument ),
                ( "\x1b6".into(), DigitArgument ),
                ( "\x1b7".into(), DigitArgument ),
                ( "\x1b8".into(), DigitArgument ),
                ( "\x1b9".into(), DigitArgument ),
            ] )
        }

        fn limit_duration( dur:Option<Duration>, max:Option<Duration> ) -> Option<Duration>
        {
            match ( dur, max )
            {
                ( dur, None ) | ( None, dur ) => dur,
                ( Some( dur ), Some( max )) => Some( dur.min( max ) ),
            }
        }
        /// Reads a file and returns its contents in a string.
        pub fn read_file_str( fname: &str ) -> io::Result<String>
        {
            let mut file = File::open( fname )?;
            let mut contents = String::new();
            let _ = file.read_to_string( &mut contents )?;

            Ok( contents )
        }
    }

    pub mod writer
    {
        //! Provides access to terminal write operations
        use ::
        {
            borrow::{ Cow::{ self, Borrowed, Owned }, },
            collections::{ vec_deque, VecDeque },
            iter::{ repeat, Skip },
            ops::{ Deref, DerefMut, Range },
            sync::{ MutexGuard },
            system::
            {
                CursorMode,
            },
            terminal::{ Size, Terminals },
            time::{ Duration, Instant },
            *,
        };
        /*
        use std::fmt;
        use std::io;
        use std::iter::{repeat, Skip};
        use std::mem::swap;
        use std::sync::MutexGuard;

        use ::chars::{is_ctrl, unctrl, ESCAPE, RUBOUT};
        use ::reader::{START_INVISIBLE, END_INVISIBLE};
        use ::terminal::{CursorMode, Size, Terminal, TerminalWriter};
        use ::util::
        { backward_char, forward_char, backward_search_char, forward_search_char, filter_visible, is_combining_mark, is_wide, RangeArgument };
        */
        /// Duration to wait for input when "blinking"
        pub const BLINK_DURATION: Duration = Duration::from_millis( 500 );

        pub const COMPLETE_MORE:&'static str = "--More--";
        /// Default maximum history size
        pub const MAX_HISTORY: usize = !0;
        /// Tab column interval
        pub const TAB_STOP: usize = 8;
        pub const PROMPT_NUM_PREFIX: usize = 6;
        pub const PROMPT_NUM_SUFFIX: usize = 2;
        pub const PROMPT_SEARCH_PREFIX: usize = 11;
        pub const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        pub const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        pub const PROMPT_SEARCH_SUFFIX: usize = 3;
        /// Provides an interface to write line-by-line output to the terminal device.
        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminals>
        {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminals>
        {
            Mutex( WriteLock<'b, Term> ),
            MutRef( &'a mut WriteLock<'b, Term> ),
        }

        pub struct Write
        {
            /// Input buffer
            pub buffer: String,
            /// Original buffer entered before searching through history
            pub backup_buffer: String,
            /// Position of the cursor
            pub cursor:usize,
            /// Position of the cursor if currently performing a blink
            blink:Option<Blink>,
            /// Stored history entries
            pub history: VecDeque<String>,
            /// History entry currently being edited;
            /// `None` if the new buffer is being edited
            pub history_index:Option<usize>,
            /// Maximum size of history
            history_size:usize,
            /// Number of history entries added since last loading history
            history_new_entries:usize,
            /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
            pub is_prompt_drawn:bool,
            /// Portion of prompt up to and including the final newline
            pub prompt_prefix: String,
            prompt_prefix_len:usize,
            /// Portion of prompt after the final newline
            pub prompt_suffix: String,
            prompt_suffix_len:usize,
            /// Current type of prompt
            pub prompt_type: PromptType,
            /// Whether a search in progress is a reverse search
            pub reverse_search:bool,
            /// Whether a search in progress has failed to find a match
            pub search_failed:bool,
            /// Current search string
            pub search_buffer: String,
            /// Last search string
            pub last_search: String,
            /// Selected history entry prior to a history search
            pub prev_history:Option<usize>,
            /// Position of the cursor prior to a history search
            pub prev_cursor:usize,
            /// Numerical argument
            pub input_arg: Digit,
            /// Whether a numerical argument was supplied
            pub explicit_arg:bool,
            /// Terminal size as of last draw operation
            pub screen_size:Size,
        }

        pub struct WriteLock<'a, Term: 'a + Terminals>
        {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
        }

        impl<'a, Term: Terminals> WriteLock<'a, Term>
        {
            pub fn new( term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write> )
                    -> WriteLock<'a, Term> {
                WriteLock{term, data}
            }

            pub fn size( &self ) -> io::Result<Size> {
                self.term.size()
            }

            pub fn flush( &mut self ) -> io::Result<()> {
                self.term.flush()
            }

            pub fn update_size( &mut self ) -> io::Result<()> {
                let size = self.size()?;
                self.screen_size = size;
                Ok( () )
            }

            pub fn blink( &mut self, pos: usize ) -> io::Result<()> {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to( pos )?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some( Blink{
                    pos,
                    expiry,
                });

                Ok( () )
            }

            pub fn check_expire_blink( &mut self, now: Instant ) -> io::Result<bool> {
                if let Some( blink ) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok( self.blink.is_none() )
            }

            pub fn expire_blink( &mut self ) -> io::Result<()> {
                if let Some( blink ) = self.data.blink.take()
            {
                    self.move_from( blink.pos )?;
                }

                Ok( () )
            }

            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt( prompt );

                if redraw {
                    self.draw_prompt()?;
                }

                Ok( () )
            }

            /// Draws the prompt and current input, assuming the cursor is at column 0
            pub fn draw_prompt( &mut self ) -> io::Result<()> {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix( &mut self ) -> io::Result<()> {
                match self.prompt_type {
                    // Prefix is not drawn when completions are shown
                    PromptType::CompleteMore => Ok( () ),
                    _ => {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt( &pfx )
                    }
                }
            }

            pub fn draw_prompt_suffix( &mut self ) -> io::Result<()> {
                match self.prompt_type {
                    PromptType::Normal => {
                        let sfx = self.prompt_suffix.clone();
                        self.draw_raw_prompt( &sfx )?;
                    }
                    PromptType::Number => {
                        let n = self.input_arg.to_i32();
                        let s = format!( "( arg: {} ) ", n );
                        self.draw_text( 0, &s )?;
                    }
                    PromptType::Search => {
                        let pre = match ( self.reverse_search, self.search_failed )
            {
                            ( false, false ) => "( i-search )",
                            ( false, true )  => "( failed i-search )",
                            ( true,  false ) => "( reverse-i-search )",
                            ( true,  true )  => "( failed reverse-i-search )",
                        };

                        let ent = self.get_history( self.history_index ).to_owned();
                        let s = format!( "{}`{}': {}", pre, self.search_buffer, ent );

                        self.draw_text( 0, &s )?;
                        let pos = self.cursor;

                        let ( lines, cols ) = self.move_delta( ent.len(), pos, &ent );
                        return self.move_rel( lines, cols );
                    }
                    PromptType::CompleteIntro( n ) => {
                        return self.term.write( &complete_intro( n ) );
                    }
                    PromptType::CompleteMore => {
                        return self.term.write( COMPLETE_MORE );
                    }
                }

                self.draw_buffer( 0 )?;
                let len = self.buffer.len();
                self.move_from( len )
            }

            pub fn redraw_prompt( &mut self, new_prompt: PromptType ) -> io::Result<()> {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }

            /// Draws a portion of the buffer, starting from the given cursor position
            pub fn draw_buffer( &mut self, pos: usize ) -> io::Result<()> {
                let ( _, col ) = self.line_col( pos );

                let buf = self.buffer[pos..].to_owned();
                self.draw_text( col, &buf )?;
                Ok( () )
            }

            /// Draw some text with the cursor beginning at the given column.
            fn draw_text( &mut self, start_col:usize, text:&str ) -> io::Result<()> {
                self.draw_text_impl( start_col, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false )
            }

            fn draw_raw_prompt( &mut self, text:&str ) -> io::Result<()> {
                self.draw_text_impl( 0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true )
            }

            fn draw_text_impl( &mut self, start_col:usize, text:&str, disp: Display, handle_invisible:bool ) -> 
            io::Result<()>
            {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity( text.len() );
                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars()
                {
                    if handle_invisible && ch == START_INVISIBLE { hidden = true; }
                    else if handle_invisible && ch == END_INVISIBLE { hidden = false; }
                    else if hidden { out.push( ch ); }
                    else
                    {
                        for ch in display( ch, disp )
                        {
                            if ch == '\t'
                            {
                                let n = TAB_STOP - ( col % TAB_STOP );

                                if col + n > width
                                {
                                    let pre = width - col;
                                    out.extend( repeat( ' ' ).take( pre ) );
                                    out.push_str( " \r" );
                                    out.extend( repeat( ' ' ).take( n - pre ) );
                                    col = n - pre;
                                }
                                else
                                {
                                    out.extend( repeat( ' ' ).take( n ) );
                                    col += n;

                                    if col == width
                                    {
                                        out.push_str( " \r" );
                                        col = 0;
                                    }
                                }
                            }

                            else if ch == '\n'
                            {
                                if !clear
                                {
                                    self.term.write( &out )?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push( '\n' );
                                col = 0;
                            }
                            else if is::combining_mark( ch ) { out.push( ch ); }
                            else if is_wide( ch )
                            {
                                if col == width - 1
                                {
                                    out.push_str( "  \r" );
                                    out.push( ch );
                                    col = 2;
                                }
                                else
                                {
                                    out.push( ch );
                                    col += 2;
                                }
                            }

                            else
                            {
                                out.push( ch );
                                col += 1;

                                if col == width
                                {
                                    out.push_str( " \r" );
                                    col = 0;
                                }
                            }
                        }
                    }
                }

                if col == width { out.push_str( " \r" ); }

                self.term.write( &out )
            }

            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> {
                self.expire_blink()?;

                self.move_to( 0 )?;
                self.buffer.clear();
                self.buffer.push_str( buf );
                self.new_buffer()
            }

            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary( pos )
            {
                    panic!( "invalid cursor position {} in buffer {:?}",
                        pos, self.buffer );
                }

                self.move_to( pos )
            }

            pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> {
                self.term.set_cursor_mode( mode )
            }

            pub fn history_len( &self ) -> usize {
                self.history.len()
            }

            pub fn history_size( &self ) -> usize {
                self.history_size
            }

            pub fn set_history_size( &mut self, n: usize )
            {
                self.history_size = n;
                self.truncate_history( n );
            }

            pub fn write_str( &mut self, s:&str ) -> io::Result<()> {
                self.term.write( s )
            }

            pub fn start_history_search( &mut self, reverse:bool ) -> io::Result<()> {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search( reverse )
            }

            pub fn continue_history_search( &mut self, reverse:bool ) -> io::Result<()> {
                if let Some( idx ) = self.find_history_search( reverse )
            {
                    self.set_history_entry( Some( idx ) );

                    let pos = self.cursor;
                    let end = self.buffer.len();

                    self.draw_buffer( pos )?;
                    self.clear_to_screen_end()?;
                    self.move_from( end )?;
                }

                Ok( () )
            }

            fn find_history_search( &self, reverse:bool ) -> Option<usize> {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or( len );

                if reverse {
                    self.history.iter().rev().skip( len - idx )
                        .position( |ent| ent.starts_with( &self.search_buffer ) )
                        .map( |pos| idx - ( pos + 1 ) )
                } else {
                    self.history.iter().skip( idx + 1 )
                        .position( |ent| ent.starts_with( &self.search_buffer ) )
                        .map( |pos| idx + ( pos + 1 ) )
                }
            }

            pub fn start_search_history( &mut self, reverse:bool ) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt( PromptType::Search )
            }

            pub fn continue_search_history( &mut self, reverse:bool ) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from( &data.last_search );
                }

                self.search_history_step()
            }

            pub fn end_search_history( &mut self ) -> io::Result<()> {
                self.redraw_prompt( PromptType::Normal )
            }

            pub fn abort_search_history( &mut self ) -> io::Result<()> {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry( ent );
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match( &mut self, next_match:Option<( Option<usize>, usize )> )
                    -> io::Result<()> {
                self.clear_prompt()?;

                if let Some(( idx, pos ) ) = next_match {
                    self.search_failed = false;
                    self.set_history_entry( idx );
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }

                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update( &mut self ) -> io::Result<()> {
                // Search for the next match, perhaps including the current position
                let next_match = if self.reverse_search {
                    self.search_history_backward( &self.search_buffer, true )
                } else {
                    self.search_history_forward( &self.search_buffer, true )
                };

                self.show_search_match( next_match )
            }

            fn search_history_step( &mut self ) -> io::Result<()> {
                if self.search_buffer.is_empty()
            {
                    return self.redraw_prompt( PromptType::Search );
                }

                // Search for the next match
                let next_match = if self.reverse_search {
                    self.search_history_backward( &self.search_buffer, false )
                } else {
                    self.search_history_forward( &self.search_buffer, false )
                };

                self.show_search_match( next_match )
            }

            fn search_history_backward( &self, s:&str, include_cur:bool ) -> Option<( Option<usize>, usize )>
            {
                let mut idx = self.history_index;
                let mut pos = Some( self.cursor );

                if include_cur && !self.search_failed
                {
                    if let Some( p ) = pos 
                    {
                        if self.get_history( idx ).is_char_boundary( p + s.len() )
                        {
                            pos = Some( p + s.len() );
                        }
                    }
                }
                
                loop
                {
                    let line = self.get_history( idx );

                    match line[..pos.unwrap_or( line.len() )].rfind( s )
                    {
                        Some( found ) =>
                        {
                            pos = Some( found );
                            break;
                        }

                        None =>
                        {
                            match idx
                            {
                                Some( 0 ) => return None,
                                Some( n ) =>
                                {
                                    idx = Some( n - 1 );
                                    pos = None;
                                }
                                None =>
                                {
                                    if self.history.is_empty() { return None; }                                    
                                    else
                                    {
                                        idx = Some( self.history.len() - 1 );
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map( |pos| ( idx, pos ) )
            }

            fn search_history_forward( &self, s:&str, include_cur:bool ) -> Option<( Option<usize>, usize )>
            {
                let mut idx = self.history_index;
                let mut pos = Some( self.cursor );

                if !include_cur
                { if let Some( p ) = pos { pos = Some( forward_char( 1, self.get_history( idx ), p ) ); } }

                loop
                {
                    let line = self.get_history( idx );

                    match line[pos.unwrap_or( 0 )..].find( s )
                    {
                        Some( found ) =>
                        {
                            pos = pos.map( |n| n + found ).or( Some( found ) );
                            break;
                        }
                        
                        None =>
                        {
                            if let Some( n ) = idx
                            {
                                if n + 1 == self.history.len() { idx = None; }
                                else { idx = Some( n + 1 ); }
                                pos = None;
                            }

                            else { return None; }
                        }
                    }
                }

                pos.map( |pos| ( idx, pos ) )
            }

            pub fn add_history( &mut self, line: String )
            {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back( line );
                self.history_new_entries = self.history.len()
                    .min( self.history_new_entries + 1 );
            }

            pub fn add_history_unique( &mut self, line: String )
            {
                let is_duplicate = self.history.back().map_or( false, |ent| *ent == line );

                if !is_duplicate {
                    self.add_history( line );
                }
            }

            pub fn clear_history( &mut self )
            {
                self.truncate_history( 0 );
                self.history_new_entries = 0;
            }

            pub fn remove_history( &mut self, n: usize )
            {
                if n < self.history.len()
                {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new { self.history_new_entries -= 1; }

                    self.history.remove( n );
                }
            }

            pub fn truncate_history( &mut self, n: usize )
            {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain( ..len - n );
                    self.history_new_entries = self.history_new_entries.max( n );
                }
            }

            pub fn next_history( &mut self, n: usize ) -> io::Result<()>
            {
                if let Some( old ) = self.history_index
                {
                    let new = old.saturating_add( n );

                    if new >= self.history.len() { self.select_history_entry( None )?; }
                    else { self.select_history_entry( Some( new ) )?; }
                }
                Ok( () )
            }

            pub fn prev_history( &mut self, n: usize ) -> io::Result<()>
            {
                if !self.history.is_empty() && self.history_index != Some( 0 )
                {
                    let new = if let Some( old ) = self.history_index { old.saturating_sub( n ) }
                    else { self.history.len().saturating_sub( n ) };

                    self.select_history_entry( Some( new ) )?;
                }

                Ok( () )
            }

            pub fn select_history_entry( &mut self, new:Option<usize> ) -> io::Result<()> {
                if new != self.history_index {
                    self.move_to( 0 )?;
                    self.set_history_entry( new );
                    self.new_buffer()?;
                }

                Ok( () )
            }

            pub fn set_history_entry( &mut self, new:Option<usize> )
            {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some( old ) = old {
                        data.history[old].clone_from( &data.buffer );
                    } else {
                        swap( &mut data.buffer, &mut data.backup_buffer );
                    }

                    if let Some( new ) = new {
                        data.buffer.clone_from( &data.history[new] );
                    } else {
                        data.buffer.clear();
                        swap( &mut data.buffer, &mut data.backup_buffer );
                    }
                }
            }

            fn get_history( &self, n:Option<usize> ) -> &str {
                if self.history_index == n {
                    &self.buffer
                } else if let Some( n ) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char( &mut self, n: usize ) -> io::Result<()> 
            {
                let pos = char::backward( n, &self.buffer, self.cursor );
                self.move_to( pos )
            }

            pub fn forward_char( &mut self, n: usize ) -> io::Result<()> {
                let pos = forward_char( n, &self.buffer, self.cursor );
                self.move_to( pos )
            }

            pub fn backward_search_char( &mut self, n:usize, ch: char ) -> io::Result<()> {
                if let Some( pos ) = backward_search_char( n, &self.buffer, self.cursor, ch )
            {
                    self.move_to( pos )?;
                }

                Ok( () )
            }

            pub fn forward_search_char( &mut self, n:usize, ch: char ) -> io::Result<()>
            {
                if let Some( pos ) = forward_search_char( n, &self.buffer, self.cursor, ch ){ self.move_to( pos )?; }
                Ok( () )
            }
            /// Deletes a range from the buffer; the cursor is moved to the end of the given range.
            pub fn delete_range<R: RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()>
            {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.buffer.len() );
                self.move_to( start )?;
                let _ = self.buffer.drain( start..end );
                self.draw_buffer( start )?;
                self.term.clear_to_screen_end()?;
                let len = self.buffer.len();
                self.move_from( len )?;
                Ok( () )
            }

            pub fn insert_str( &mut self, s:&str ) -> io::Result<()>
            {
                let moves_combining = match self.buffer[self.cursor..].chars().next()
                {
                    Some( ch ) if is_combining_mark( ch ) => true,
                    _ => false
                };

                let cursor = self.cursor;
                self.buffer.insert_str( cursor, s );

                if moves_combining && cursor != 0
                {
                    let pos = backward_char( 1, &self.buffer, self.cursor );
                    let ( lines, cols ) = self.move_delta( cursor, pos, &self.buffer );
                    self.move_rel( lines, cols )?;
                    self.draw_buffer( pos )?;
                }
                else { self.draw_buffer( cursor )?; }

                self.cursor += s.len();
                let len = self.buffer.len();
                self.move_from( len )
            }

            pub fn transpose_range( &mut self, src: Range<usize>, dest: Range<usize> ) -> io::Result<()>
            {
                
                assert!( src.end <= dest.start || src.start >= dest.end );
                
                let final_cur = if src.start < dest.start { dest.end }
                else { dest.start + ( src.end - src.start ) };

                let ( left, right ) = if src.start < dest.start { ( src, dest ) } else { ( dest, src ) };

                self.move_to( left.start )?;

                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();

                let _ = self.buffer.drain( right.clone() );
                self.buffer.insert_str( right.start, &a );

                let _ = self.buffer.drain( left.clone() );
                self.buffer.insert_str( left.start, &b );

                let cursor = self.cursor;
                self.draw_buffer( cursor )?;
                self.term.clear_to_screen_end()?;

                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from( len )
            }

            fn prompt_suffix_length( &self ) -> usize {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number => {
                        let n = number_len( self.input_arg.to_i32() );
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search => {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size( &self.search_buffer, prefix );
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro( n ) => complete_intro( n ).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col( &self, pos: usize ) -> ( usize, usize )
            {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type
                {
                    PromptType::CompleteIntro( _ ) | PromptType::CompleteMore => 
                    {
                        let width = self.screen_size.columns;
                        ( prompt_len / width, prompt_len % width )
                    }
                    _ => self.line_col_with( pos, &self.buffer, prompt_len )
                }
            }

            fn line_col_with( &self, pos:usize, buf:&str, start_col: usize ) -> ( usize, usize )
            {
                let width = self.screen_size.columns;
                if width == 0 {
                    return ( 0, 0 );
                }

                let n = start_col + self.display_size( &buf[..pos], start_col );

                ( n / width, n % width )
            }

            pub fn clear_screen( &mut self ) -> io::Result<()>
            {
                self.term.clear_screen()?;
                self.draw_prompt()?;
                Ok( () )
            }

            pub fn clear_to_screen_end( &mut self ) -> io::Result<()> { self.term.clear_to_screen_end() }
            /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
            pub fn new_buffer( &mut self ) -> io::Result<()>
            {
                self.draw_buffer( 0 )?;
                self.cursor = self.buffer.len();
                self.term.clear_to_screen_end()?;
                Ok( () )
            }

            pub fn clear_full_prompt( &mut self ) -> io::Result<()>
            {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let ( line, _ ) = self.line_col( self.cursor );
                self.term.move_up( prefix_lines + line )?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn clear_prompt( &mut self ) -> io::Result<()>
            {
                let ( line, _ ) = self.line_col( self.cursor );
                self.term.move_up( line )?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }
            /// Move back to true cursor position from some other position
            pub fn move_from( &mut self, pos: usize ) -> io::Result<()>
            {
                let ( lines, cols ) = self.move_delta( pos, self.cursor, &self.buffer );
                self.move_rel( lines, cols )
            }

            pub fn move_to( &mut self, pos: usize ) -> io::Result<()>
            {
                if pos != self.cursor
                {
                    let ( lines, cols ) = self.move_delta( self.cursor, pos, &self.buffer );
                    self.move_rel( lines, cols )?;
                    self.cursor = pos;
                }

                Ok( () )
            }

            pub fn move_to_end( &mut self ) -> io::Result<()>
            {
                let pos = self.buffer.len();
                self.move_to( pos )
            }
            pub fn move_right( &mut self, n: usize ) -> io::Result<()> { self.term.move_right( n ) }
            /// Moves from `old` to `new` cursor position, using the given buffer as current input.
            fn move_delta( &self, old:usize, new:usize, buf:&str ) -> ( isize, isize )
            {
                let prompt_len = self.prompt_suffix_length();
                let ( old_line, old_col ) = self.line_col_with( old, buf, prompt_len );
                let ( new_line, new_col ) = self.line_col_with( new, buf, prompt_len );
                ( new_line as isize - old_line as isize, new_col as isize - old_col as isize )
            }

            fn move_rel( &mut self, lines: isize, cols: isize ) -> io::Result<()>
            {
                if lines > 0 { self.term.move_down( lines as usize )?; }
                else if lines < 0 { self.term.move_up( ( -lines ) as usize )?; }

                if cols > 0 { self.term.move_right( cols as usize )?; }
                else if cols < 0 { self.term.move_left( ( -cols ) as usize )?; }

                Ok( () )
            }

            pub fn reset_data( &mut self ) { self.data.reset_data(); }

            pub fn set_digit_from_char( &mut self, ch: char )
            {
                let digit = match ch
                {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from( ch ),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive( Copy, Clone )]
        struct Blink {
            pos:usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> Writer<'a, 'b, Term> {
            fn new( mut write: WriterImpl<'a, 'b, Term>, clear:bool ) -> io::Result<Self> {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str( "\n" )?;
                    }
                }

                Ok( Writer{write} )
            }

            pub fn with_lock( write: WriteLock<'b, Term>, clear:bool ) -> io::Result<Self> {
                Writer::new( WriterImpl::Mutex( write ), clear )
            }

            pub fn with_ref( write:&'a mut WriteLock<'b, Term>, clear:bool ) -> io::Result<Self> {
                Writer::new( WriterImpl::MutRef( write ), clear )
            }

            /// Returns an iterator over history entries.
            pub fn history( &self ) -> HistoryIter {
                self.write.history()
            }

            /// Writes some text to the terminal device.
            ///
            /// Before the `Writer` is dropped, any output written should be followed
            /// by a newline. A newline is automatically written if the `writeln!`
            /// macro is used.
            pub fn write_str( &mut self, s:&str ) -> io::Result<()> {
                self.write.write_str( s )
            }

            /// Writes formatted text to the terminal display.
            ///
            /// This method enables `Interface` to be used as the receiver to
            /// the [`writeln!`] macro.
            ///
            /// If the text contains any unprintable characters ( e.g. escape sequences ),
            /// those characters will be escaped before printing.
            ///
            /// [`read_line`]: ../interface/struct.Interface.html#method.read_line
            /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
            pub fn write_fmt( &mut self, args:fmt::Arguments ) -> io::Result<()> {
                let s = args.to_string();
                self.write_str( &s )
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> Drop for Writer<'a, 'b, Term> {
            fn drop( &mut self )
            {
                if self.write.is_prompt_drawn {
                    // There's not really anything useful to be done with this error.
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminals> Deref for WriteLock<'a, Term> {
            type Target = Write;

            fn deref( &self ) -> &Write {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminals> DerefMut for WriteLock<'a, Term> {
            fn deref_mut( &mut self ) -> &mut Write {
                &mut self.data
            }
        }

        impl Write
        {
            pub fn new( screen_size:Size ) -> Write
            {
                Write
                {
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,
                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,
                    is_prompt_drawn: false,
                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,
                    prompt_type: PromptType::Normal,
                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,
                    input_arg: Digit::None,
                    explicit_arg: false,
                    screen_size,
                }
            }

            pub fn history( &self ) -> HistoryIter { HistoryIter( self.history.iter() ) }

            pub fn new_history( &self ) -> Skip<HistoryIter>
            {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip( first_new )
            }

            pub fn new_history_entries( &self ) -> usize {
                self.history_new_entries
            }

            pub fn reset_data( &mut self )
            {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;
                self.prompt_type = PromptType::Normal;
                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history( &mut self ) { self.history_new_entries = 0; }

            pub fn set_buffer( &mut self, buf:&str )
            {
                self.buffer.clear();
                self.buffer.push_str( buf );
                self.cursor = buf.len();
            }

            pub fn set_cursor( &mut self, pos: usize )
            {
                if !self.buffer.is_char_boundary( pos ) 
                { panic!( "invalid cursor position {} in buffer {:?}", pos, self.buffer ); }

                self.cursor = pos;
            }

            pub fn set_prompt( &mut self, prompt:&str )
            {
                let ( pre, suf ) = match prompt.rfind( '\n' )
                {
                    Some( pos ) => ( &prompt[..pos + 1], &prompt[pos + 1..] ),
                    None => ( &prompt[..0], prompt )
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();
                let pre_virt = filter_visible( pre );
                self.prompt_prefix_len = self.display_size( &pre_virt, 0 );
                let suf_virt = filter_visible( suf );
                self.prompt_suffix_len = self.display_size( &suf_virt, 0 );
            }

            pub fn display_size( &self, s:&str, start_col: usize ) -> usize
            {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let disp = Display
                {
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in s.chars().flat_map( |ch| display( ch, disp ) )
                {
                    let n = match ch
                    {
                        '\n' => width - ( col % width ),
                        '\t' => TAB_STOP - ( col % TAB_STOP ),
                        ch if is::combining_mark( ch ) => 0,
                        ch if is::wide( ch ) =>
                        {
                            if col % width == width - 1 { 3 } else { 2 }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }
        /// Maximum value of digit input
        pub const NUMBER_MAX: i32 = 1_000_000;

        #[derive( Copy, Clone, Debug )]
        pub enum Digit
        {
            None,
            NegNone,
            Num( i32 ),
            NegNum( i32 ),
        }

        impl Digit {
            pub fn input( &mut self, n: i32 )
            {
                match *self {
                    Digit::None => *self = Digit::Num( n ),
                    Digit::NegNone => *self = Digit::NegNum( n ),
                    Digit::Num( ref mut m ) | Digit::NegNum( ref mut m ) => {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds( &self ) -> bool {
                match *self {
                    Digit::Num( n ) | Digit::NegNum( n ) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32( &self ) -> i32 {
                match *self {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num( n ) => n,
                    Digit::NegNum( n ) => -n,
                }
            }
        }

        impl From<char> for Digit {
            /// Convert a decimal digit character to a `Digit` value.
            ///
            /// The input must be in the range `'0' ..= '9'`.
            fn from( ch: char ) -> Digit {
                let n = ( ch as u8 ) - b'0';
                Digit::Num( n as i32 )
            }
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum PromptType {
            Normal,
            Number,
            Search,
            CompleteIntro( usize ),
            CompleteMore,
        }

        impl PromptType {
            pub fn is_normal( &self ) -> bool {
                *self == PromptType::Normal
            }
        }

        impl<'a, 'b, Term: 'b + Terminals> Deref for WriterImpl<'a, 'b, Term> {
            type Target = WriteLock<'b, Term>;

            fn deref( &self ) -> &WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex( ref m ) => m,
                    WriterImpl::MutRef( ref m ) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> DerefMut for WriterImpl<'a, 'b, Term> {
            fn deref_mut( &mut self ) -> &mut WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex( ref mut m ) => m,
                    WriterImpl::MutRef( ref mut m ) => m,
                }
            }
        }

        /// Iterator over `Interface` history entries
        pub struct HistoryIter<'a>( vec_deque::Iter<'a, String> );

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a>
        {
            type Item = &'a str;
            #[inline] fn next( &mut self ) -> Option<&'a str> { self.0.next().map( |s| &s[..] ) }
            #[inline] fn nth( &mut self, n: usize ) -> Option<&'a str> { self.0.nth( n ).map( |s| &s[..] ) }
            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.0.size_hint() }        
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a>
        {
            #[inline] fn next_back( &mut self ) -> Option<&'a str> { self.0.next_back().map( |s| &s[..] ) }
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum DisplaySequence
        {
            Char( char ),
            Escape( char ),
            End,
        }

        impl Iterator for DisplaySequence
        {
            type Item = char;
            fn next( &mut self ) -> Option<char>
            {
                use self::DisplaySequence::*;

                let ( res, next ) = match *self {
                    Char( ch ) => ( ch, End ),
                    Escape( ch ) => ( '^', Char( ch ) ),
                    End => return None
                };

                *self = next;
                Some( res )
            }
            fn size_hint( &self ) -> ( usize, Option<usize> )
            {
                use self::DisplaySequence::*;
                let n = match *self
                {
                    Char( _ ) => 1,
                    Escape( _ ) => 2,
                    End => 0,
                };
                ( n, Some( n ) )
            }
        }

        #[derive( Copy, Clone, Debug, Default )]
        pub struct Display
        {
            allow_tab:bool,
            allow_newline:bool,
            allow_escape:bool,
        }

        pub fn display( ch: char, style: Display ) -> DisplaySequence
        {
            match ch
            {
                '\t' if style.allow_tab => DisplaySequence::Char( ch ),
                '\n' if style.allow_newline => DisplaySequence::Char( ch ),
                ESCAPE if style.allow_escape => DisplaySequence::Char( ch ),
                '\0' => DisplaySequence::Escape( '@' ),
                RUBOUT => DisplaySequence::Escape( '?' ),
                ch if is::ctrl( ch ) => DisplaySequence::Escape( unctrl( ch ) ),
                ch => DisplaySequence::Char( ch )
            }
        }

        pub fn display_str<'a>( s:&'a str, style: Display ) -> Cow<'a, str>
        {
            if s.chars().all( |ch| display( ch, style ) == DisplaySequence::Char( ch ) ) { Borrowed( s ) }
            else { Owned( s.chars().flat_map( |ch| display( ch, style ) ).collect() ) }
        }

        fn complete_intro( n: usize ) -> String { format!( "Display all {} possibilities? ( y/n )", n ) }

        fn number_len( n: i32 ) -> usize
        {
            match n
            {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=         9 => 1,
                        10 ..=       99 => 2,
                    100 ..=         999 => 3,
                    1_000 ..=     9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=     999_999 => 6,
                1_000_000               => 7,
                _ => unreachable!()
            }
        }
    }
}
/// Core Intrinsics
pub mod intrinsics
{
    pub use std::intrinsics::{ * };

}
/// Composable external iteration.
pub mod iter
{
    pub use std::iter::{ * };
    
}
/// Primitive traits and types representing basic properties of types.
pub mod marker
{
    pub use std::marker::{ * };
}
/// Basic functions for dealing with memory.
pub mod mem
{
    pub use std::mem::{ * };
}
/// Networking primitives for TCP/UDP communication.
pub mod net
{
    pub use std::net::{ * }; 
}
/// Execution API
pub mod now
{
    use ::
    {
        collections::{ HashMap },
        env::{ find_file_in_path },
        ffi::{CStr, CString},
        fs::{ File },
        io::{ self, Read, Write },
        nix::
        {
          unistd::{ execve, ForkResult },
        },
        os::
        {
            unix::io::FromRawFd,
            fd::{ RawFd }
        },
        primitive::{ CommandLine, CommandOptions, CommandResult, Tokens },
        process::{ pipe },
        regex::{ Regex },
        shell::{ self, Shell },
        *,
    };
    
    pub fn run_command_line( sh:&mut Shell, line:&str, tty:bool, capture:bool ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::line::to_cmds( line )
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }
            
            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = run_procedure( sh, &cmd, tty, capture );
            status = cr.status;
            sh.previous_status = status;
            cr_list.push( cr );
            
        }

        cr_list
    }
    /// Run a single command.
    fn run_single_program
    ( 
        sh:&mut shell::Shell,
        cl:&CommandLine,
        idx_cmd:usize,
        options:&CommandOptions,
        pgid:&mut i32,
        term_given:&mut bool,
        cmd_result:&mut CommandResult,
        pipes:&[( RawFd, RawFd )],
        fds_capture_stdout:&Option<( RawFd, RawFd )>,
        fds_capture_stderr:&Option<( RawFd, RawFd )>,
   ) -> i32
    {
        unsafe
        {
            let capture = options.capture_output;

            if cl.is_single_and_builtin()
            {
                if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture )
                {
                    *cmd_result = cr;
                    return unsafe { libc::getpid() };
                }

                println_stderr!( "cicada: error when run singler builtin" );
                log!( "error when run singler builtin: {:?}", cl );
                return 1;
            }

            let pipes_count = pipes.len();
            let mut fds_stdin = None;
            let cmd = cl.commands.get( idx_cmd ).unwrap();

            if cmd.has_here_string()
            {
                match process::pipe()
                {
                    Ok( fds ) => fds_stdin = Some( fds ),
                    Err( e ) =>
                    {
                        println_stderr!( "cicada: pipeline4: {}", e );
                        return 1;
                    }
                }
            }

            match process::fork()
            {
                Ok( ForkResult::Child ) =>
                {
                    libc::signal( libc::SIGTSTP, libc::SIG_DFL );
                    libc::signal( libc::SIGQUIT, libc::SIG_DFL );
                    
                    if idx_cmd > 0
                    {
                        for i in 0..idx_cmd - 1
                        {
                            let fds = pipes[i];
                            process::close( fds.0 );
                            process::close( fds.1 );
                        }
                    }
                    
                    for i in idx_cmd + 1..pipes_count
                    {
                        let fds = pipes[i];
                        process::close( fds.0 );
                        process::close( fds.1 );
                    }
                    
                    if idx_cmd < pipes_count
                    {
                        if let Some( fds ) = fds_capture_stdout
                        {
                            process::close( fds.0 );
                            process::close( fds.1 );
                        }

                        if let Some( fds ) = fds_capture_stderr
                        {
                            process::close( fds.0 );
                            process::close( fds.1 );
                        }
                    }

                    if idx_cmd == 0
                    {
                        let pid = libc::getpid();
                        libc::setpgid( 0, pid );
                    }
                    
                    else { libc::setpgid( 0, *pgid ); }
                    
                    if idx_cmd > 0
                    {
                        let fds_prev = pipes[idx_cmd - 1];
                        libs::dup2( fds_prev.0, 0 );
                        process::close( fds_prev.0 );
                        process::close( fds_prev.1 );
                    }
                    
                    if idx_cmd < pipes_count
                    {
                        let fds = pipes[idx_cmd];
                        libs::dup2( fds.1, 1 );
                        process::close( fds.1 );
                        process::close( fds.0 );
                    }

                    if cmd.has_redirect_from()
                    {
                        if let Some( redirect_from ) = &cmd.redirect_from
                        {
                            let fd = tools::get_fd_from_file( &redirect_from.clone().1 );
                            if fd == -1 { process::exit( 1 ); }

                            libs::dup2( fd, 0 );
                            process::close( fd );
                        }
                    }

                    if cmd.has_here_string()
                    {
                        if let Some( fds ) = fds_stdin
                        {
                            process::close( fds.1 );
                            libs::dup2( fds.0, 0 );
                            process::close( fds.0 );
                        }
                    }

                    let mut stdout_redirected = false;
                    let mut stderr_redirected = false;
                    
                    for item in &cmd.redirects_to
                    {
                        let from_ = &item.0;
                        let op_ = &item.1;
                        let to_ = &item.2;
                        
                        if to_ == "&1" && from_ == "2"
                        {
                            if idx_cmd < pipes_count
                            {
                                libs::dup2( 1, 2 );
                            }
                            
                            else if !options.capture_output
                            {
                                let fd = libs::dup( 1 );
                                if fd == -1
                                {
                                    println_stderr!( "cicada: dup error" );
                                    process::exit( 1 );
                                }

                                libs::dup2( fd, 2 );
                            }
                            
                            else { }
                        }
                        
                        else if to_ == "&2" && from_ == "1"
                        {
                            if idx_cmd < pipes_count || !options.capture_output
                            {
                                let fd = libs::dup( 2 );
                                if fd == -1
                                {
                                    println_stderr!( "cicada: dup error" );
                                    process::exit( 1 );
                                }

                                libs::dup2( fd, 1 );
                            }
                            
                            else { }
                        } 
                        
                        else
                        {
                            let append = op_ == ">>";
                            match tools::create_raw_fd_from_file( to_, append )
                            {
                                Ok( fd ) =>
                                {
                                    if fd == -1
                                    {
                                        println_stderr!( "cicada: fork: fd error" );
                                        process::exit( 1 );
                                    }

                                    if from_ == "1"
                                    {
                                        libs::dup2( fd, 1 );
                                        stdout_redirected = true;
                                    }
                                    
                                    else
                                    {
                                        libs::dup2( fd, 2 );
                                        stderr_redirected = true;
                                    }
                                }

                                Err( e ) =>
                                {
                                    println_stderr!( "cicada: fork: {}", e );
                                    process::exit( 1 );
                                }
                            }
                        }
                    }
                    
                    if idx_cmd == pipes_count && options.capture_output
                    {
                        if !stdout_redirected
                        {
                            if let Some( fds ) = fds_capture_stdout
                            {
                                process::close( fds.0 );
                                libs::dup2( fds.1, 1 );
                                process::close( fds.1 );
                            }
                        }

                        if !stderr_redirected
                        {
                            if let Some( fds ) = fds_capture_stderr
                            {
                                process::close( fds.0 );
                                libs::dup2( fds.1, 2 );
                                process::close( fds.1 );
                            }
                        }
                    }

                    if cmd.is_builtin()
                    {
                        if let Some( status ) = try_run_builtin_in_subprocess( sh, cl, idx_cmd, capture )
                        { process::exit( status ); }
                    }
                    
                    let mut c_envs: Vec<_> = vars().map( |( k, v )|
                    {
                        CString::new( format!( "{}={}", k, v ).as_str() ).expect( "CString error" )
                    } ).collect();

                    for ( key, value ) in cl.envs.iter()
                    {
                        c_envs.push( CString::new( format!( "{}={}", key, value ).as_str() ).expect( "CString error" ), );
                    }

                    let program = &cmd.tokens[0].1;
                    let path = if program.contains( '/' )
            {
                        program.clone()
                    }
                    
                    else {  find_file_in_path( program, true ) };

                    if path.is_empty()
                    {
                        println_stderr!( "cicada: {}: command not found", program );
                        process::exit( 127 );
                    }

                    let c_program = CString::new( path.as_str() ).expect( "CString::new failed" );
                    let c_args: Vec<_> = cmd
                    .tokens
                    .iter()
                    .map( |x| CString::new( x.1.as_str() ).expect( "CString error" ) )
                    .collect();

                    let c_args: Vec<&CStr> = c_args.iter().map( |x| x.as_c_str() ).collect();
                    let c_envs: Vec<&CStr> = c_envs.iter().map( |x| x.as_c_str() ).collect();
                    match execve( &c_program, &c_args, &c_envs )
                    {
                        Ok( _ ) => {}
                        Err( e ) => match e
                        {
                            nix::Error::ENOEXEC => 
                            { println_stderr!( "cicada: {}: exec format error ( ENOEXEC )", program ); }
                            
                            nix::Error::ENOENT => 
                            { println_stderr!( "cicada: {}: file does not exist", program ); }
                            
                            nix::Error::EACCES => 
                            { println_stderr!( "cicada: {}: Permission denied", program ); }

                            _ => { println_stderr!( "cicada: {}: {:?}", program, e ); }
                        },
                    }

                    process::exit( 1 );
                }

                Ok( ForkResult::Parent { child, .. } ) =>
                {
                    let pid: i32 = child.into();
                    if idx_cmd == 0
                    {
                        *pgid = pid;
                        if sh.has_terminal && options.isatty && !cl.background 
                        { *term_given = shell::give_terminal_to( pid ); }
                    }

                    if options.isatty && !options.capture_output
                    {
                        let _cmd = parsers::line::tokens_to_line( &cmd.tokens );
                        sh.insert_job( *pgid, pid, &_cmd, "Running", cl.background );
                    }

                    if let Some( redirect_from ) = &cmd.redirect_from
                    {
                        if redirect_from.0 == "<<<"
                        {
                            if let Some( fds ) = fds_stdin
                            {
                                unsafe
                                {
                                    process::close( fds.0 );

                                    let mut f = File::from_raw_fd( fds.1 );
                                    
                                    match f.write_all( redirect_from.1.clone().as_bytes() )
                                    {
                                        Ok( _ ) => {}
                                        Err( e ) => println_stderr!( "cicada: write_all: {}", e ),
                                    }
                                    
                                    match f.write_all( b"\n" )
                                    {
                                        Ok( _ ) => {}
                                        Err( e ) => println_stderr!( "cicada: write_all: {}", e ),
                                    }
                                }
                            }
                        }
                    }
                    
                    if idx_cmd < pipes_count
                    {
                        let fds = pipes[idx_cmd];
                        process::close( fds.1 );
                    }
                    
                    if idx_cmd > 0
                    {
                        let fds = pipes[idx_cmd - 1];
                        process::close( fds.0 );
                    }

                    if idx_cmd == pipes_count && options.capture_output
                    {
                        let mut s_out = String::new();
                        let mut s_err = String::new();

                        if let Some( fds ) = fds_capture_stdout
                        {
                            process::close( fds.1 );

                            let mut f = File::from_raw_fd( fds.0 );
                            match f.read_to_string( &mut s_out )
                            {
                                Ok( _ ) => {}
                                Err( e ) => println_stderr!( "cicada: readstr: {}", e ),
                            }
                        }
                        
                        if let Some( fds ) = fds_capture_stderr
                        {
                            process::close( fds.1 );
                            let mut f_err = File::from_raw_fd( fds.0 );
                            match f_err.read_to_string( &mut s_err )
                            {
                                Ok( _ ) => {}
                                Err( e ) => println_stderr!( "cicada: readstr: {}", e ),
                            }
                        }

                        *cmd_result = CommandResult
                        {
                            gid: *pgid,
                            status: 0,
                            stdout: s_out.clone(),
                            stderr: s_err.clone(),
                        };
                    }

                    pid
                }

                Err( _ ) =>
                {
                    println_stderr!( "Fork failed" );
                    *cmd_result = CommandResult::error();
                    0
                }
            }
        }
    }
    /// Run a pipeline ( e.g. `echo hi | wc -l` )
    /// returns: ( is-terminal-given, command-result )
    pub fn run_pipeline( sh:&mut shell::Shell, cl:&CommandLine, tty:bool, capture:bool, log_cmd:bool ) -> 
    ( bool, CommandResult )
    {
        unsafe
        {
            let mut term_given = false;
        
            if cl.background && capture
            {
                println_stderr!( "cicada: cannot capture output of background cmd" );
                return ( term_given, CommandResult::error() );
            }

            if let Some( cr ) = try_run_calculator( &cl.line, capture )
            { return ( term_given, cr ); }
            
            if let Some( cr ) = try_run_func( sh, cl, capture, log_cmd )
            { return ( term_given, cr ); }

            if log_cmd { log!( "run: {}", cl.line ); }

            let length = cl.commands.len();
            
            if length == 0
            {
                println!( "cicada: invalid command: cmds with empty length" );
                return ( false, CommandResult::error() );
            }

            let mut pipes = Vec::new();
            let mut errored_pipes = false;
            
            for _ in 0..length - 1
            {
                match pipe()
                {
                    Ok( fds ) => pipes.push( fds ),
                    Err( e ) =>
                    {
                        errored_pipes = true;
                        println_stderr!( "cicada: pipeline1: {}", e );
                        break;
                    }
                }
            }

            if errored_pipes
            {
                for fds in pipes
                {
                    process::close( fds.0 );
                    process::close( fds.1 );
                }
                
                return ( false, CommandResult::error() );
            }

            if pipes.len() + 1 != length
            {
                println!( "cicada: invalid command: unmatched pipes count" );
                return ( false, CommandResult::error() );
            }

            let mut pgid: i32 = 0;
            let mut fg_pids: Vec<i32> = Vec::new();

            let isatty = if tty { libc::isatty( 1 ) == 1 } 
            else { false };

            let options = CommandOptions
            {
                isatty,
                capture_output: capture,
                background: cl.background,
                envs: cl.envs.clone(),
            };

            let mut fds_capture_stdout = None;
            let mut fds_capture_stderr = None;
            
            if capture
            {
                match pipe()
                {
                    Ok( fds ) => fds_capture_stdout = Some( fds ),
                    Err( e ) =>
                    {
                        println_stderr!( "cicada: pipeline2: {}", e );
                        return ( false, CommandResult::error() );
                    }
                }

                match pipe()
                {
                    Ok( fds ) => fds_capture_stderr = Some( fds ),
                    Err( e ) =>
                    {
                        if let Some( fds ) = fds_capture_stdout
                        {
                            process::close( fds.0 );
                            process::close( fds.1 );
                        }

                        println_stderr!( "cicada: pipeline3: {}", e );
                        return ( false, CommandResult::error() );
                    }
                }
            }

            let mut cmd_result = CommandResult::new();

            for i in 0..length
            {
                let child_id: i32 = run_single_program
                ( 
                    sh,
                    cl,
                    i,
                    &options,
                    &mut pgid,
                    &mut term_given,
                    &mut cmd_result,
                    &pipes,
                    &fds_capture_stdout,
                    &fds_capture_stderr,
               );

                if child_id > 0 && !cl.background { fg_pids.push( child_id ); }
            }

            if cl.is_single_and_builtin()
            { return ( false, cmd_result ); }

            if cl.background
            {
                if let Some( job ) = sh.get_job_by_gid( pgid )
            { println_stderr!( "[{}] {}", job.id, job.gid ); }
            }

            if !fg_pids.is_empty()
            {
                let _cr = jobc::wait_fg_job( sh, pgid, &fg_pids );
                
                if !capture { cmd_result = _cr; }
            }
            
            ( term_given, cmd_result )
        }
    }
    /// Entry point for non-ttys ( e.g. Cmd-N on MacVim )
    pub fn run_procedures_for_non_tty( sh:&mut Shell )
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();

        match handle.read_to_string( &mut buffer )
        {
            Ok( _ ) =>
            {
                log!( "run non tty command: {}", &buffer );
                run_command_line( sh, &buffer, false, false );
            }
            
            Err( e ) =>
            {
                println!( "cicada: stdin.read_to_string() failed: {:?}", e );
            }
        }
    }
    //  fn run_proc( ... ) -> CommandResult
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    fn run_procedure( sh:&mut Shell, line:&str, tty:bool, capture:bool ) -> CommandResult
    {
        unsafe
        {   
            let log_cmd = !sh.cmd.starts_with( ' ' );
            match CommandLine::from_line( line, sh )
            {
                Ok( cl ) =>
                {
                    if cl.is_empty()
                    {
                        if !cl.envs.is_empty()
            { set_shell_vars( sh, &cl.envs ); }

                        return CommandResult::new();
                    }

                    let ( term_given, cr ) = core::run_pipeline( sh, &cl, tty, capture, log_cmd );
                    if term_given
                    {
                        unsafe {
                            let gid = libc::getpgid( 0 );
                            shell::give_terminal_to( gid );
                        }
                    }

                    cr
                }
                
                Err( e ) =>
                {
                    println_stderr!( "cicada: {}", e );
                    CommandResult::from_status( 0, 1 )
                }
            }
        }
    }
    
    fn try_run_builtin( sh:&mut Shell, cl:&CommandLine, idx_cmd:usize, capture:bool ) -> Option<CommandResult>
    {
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len()
        {
            println_stderr!( "unexpected error in try_run_builtin" );
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();
        
        if cname == "alias" {
            let cr = ffi::alias::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "bg" {
            let cr = ffi::bg::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "cd" {
            let cr = ffi::cd::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "cinfo" {
            let cr = ffi::cinfo::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "exec" {
            let cr = ffi::exec::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "exit" {
            let cr = ffi::exit::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "export" {
            let cr = ffi::export::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "fg" {
            let cr = ffi::fg::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "history" {
            let cr = ffi::history::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "jobs" {
            let cr = ffi::jobs::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "minfd" {
            let cr = ffi::minfd::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "read" {
            let cr = ffi::read::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "set" {
            let cr = ffi::set::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "source" {
            let cr = ffi::source::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "ulimit" {
            let cr = ffi::ulimit::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "unalias" {
            let cr = ffi::unalias::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "unset" {
            let cr = ffi::unset::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "unpath" {
            let cr = ffi::unpath::run( sh, cl, cmd, capture );
            return Some( cr );
        } else if cname == "vox" {
            let cr = ffi::vox::run( sh, cl, cmd, capture );
            return Some( cr );
        }
        None
    }

    fn run_with_shell( sh:&mut Shell, line:&str ) -> CommandResult
    {
        unsafe
        {
            let ( tokens, envs ) = line_to_tokens( sh, line );

            if tokens.is_empty()
            {
                set_shell_vars( sh, &envs );
                return CommandResult::new();
            }

            match CommandLine::from_line( line, sh )
            {
                Ok( c ) =>
                {
                    let ( term_given, cr ) = run_pipeline( sh, &c, false, true, false );
                    
                    if term_given
                    {
                        let gid = libc::getpgid( 0 );
                        shell::give_terminal_to( gid );    
                    }

                    cr
                }

                Err( e ) =>
                {
                    println_stderr!( "cicada: {}", e );
                    CommandResult::from_status( 0, 1 )
                }
            }
        }

        
    }

    pub fn run( line:&str ) -> CommandResult
    {
        let mut sh = Shell::new();
        run_with_shell( &mut sh, line )
    }
}
/// Additional functionality for numerics.
pub mod num
{
    pub use std::num::{ * };
    
    pub mod big
    {
        //! A Big integer ( signed version: `BigInt`, unsigned version: `BigUint`).
        use ::
        {
            error::{ Error },
            *,
        };

        #[macro_use] mod macros
        {
            macro_rules! cfg_32
            {
                ($($any:tt)+ ) => 
                {
                    #[cfg(not(target_pointer_width = "64"))] $($any)+
                }
            }

            macro_rules! cfg_32_or_test 
            {
                ($($any:tt)+ ) => 
                {
                    #[cfg(any(not(target_pointer_width = "64"), test))] $($any)+
                }
            }

            macro_rules! cfg_64 
            {
                ($($any:tt)+ ) => 
                {
                    #[cfg(target_pointer_width = "64")] $($any)+
                }
            }

            macro_rules! cfg_digit 
            {
                ($item32:item $item64:item ) => 
                {
                    cfg_32!($item32);
                    cfg_64!($item64);
                };
            }

            macro_rules! cfg_digit_expr 
            {
                ($expr32:expr, $expr64:expr ) => 
                {
                    cfg_32!($expr32);
                    cfg_64!($expr64);
                };
            }

            macro_rules! forward_val_val_binop
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl $imp<$res> for $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_val_val_binop_commutative
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl $imp<$res> for $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            if self.capacity() >= other.capacity() {
                                $imp::$method( self, &other)
                            } else {
                                $imp::$method( other, &self)
                            }
                        }
                    }
                };
            }

            macro_rules! forward_ref_val_binop
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl<'a> $imp<$res> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_val_binop_commutative 
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl<'a> $imp<$res> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( other, self)
                        }
                    }
                };
            }

            macro_rules! forward_val_ref_binop
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl<'a> $imp<&'a $res> for $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$res ) -> $res {
                            $imp::$method( &self, other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_ref_binop
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl<'a, 'b> $imp<&'b $res> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$res ) -> $res {
                            $imp::$method( self.clone(), other)
                        }
                    }
                };
            }

            macro_rules! forward_ref_ref_binop_commutative
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl<'a, 'b> $imp<&'b $res> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$res ) -> $res {
                            if self.len() >= other.len() {
                                $imp::$method( self.clone(), other)
                            } else {
                                $imp::$method( other.clone(), self)
                            }
                        }
                    }
                };
            }

            macro_rules! forward_val_assign
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    impl $imp<$res> for $res {
                        #[inline] fn $method( &mut self, other: $res ) {
                            self.$method( &other );
                        }
                    }
                };
            }

            macro_rules! forward_val_assign_scalar
            {
                ( impl $imp:ident for $res:ty, $scalar:ty, $method:ident ) => {
                    impl $imp<$res> for $scalar {
                        #[inline] fn $method( &mut self, other: $res ) {
                            self.$method( &other );
                        }
                    }
                };
            }
            /// Used if val_val_binop is already implemented and the reversed order is required
            macro_rules! forward_scalar_val_val_binop_commutative
            {
                ( impl $imp:ident < $scalar:ty > for $res:ty, $method:ident ) =>
                {
                    impl $imp<$res> for $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( other, self)
                        }
                    }
                };
            }
            
            macro_rules! forward_scalar_val_val_binop_to_ref_val 
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    impl $imp<$scalar> for $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: $scalar ) -> $res {
                            $imp::$method( &self, other)
                        }
                    }

                    impl $imp<$res> for $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_ref_binop_to_ref_val
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    impl<'a, 'b> $imp<&'b $scalar> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$scalar ) -> $res {
                            $imp::$method( self, *other)
                        }
                    }

                    impl<'a, 'b> $imp<&'a $res> for &'b $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$res ) -> $res {
                            $imp::$method( *self, other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_val_ref_binop_to_ref_val
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    impl<'a> $imp<&'a $scalar> for $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$scalar ) -> $res {
                            $imp::$method( &self, *other)
                        }
                    }

                    impl<'a> $imp<$res> for &'a $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( *self, &other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_val_ref_binop_to_val_val
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    impl<'a> $imp<&'a $scalar> for $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$scalar ) -> $res {
                            $imp::$method( self, *other)
                        }
                    }

                    impl<'a> $imp<$res> for &'a $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: $res ) -> $res {
                            $imp::$method( *self, other)
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_val_binop_to_val_val
            {
                ( impl $imp:ident < $scalar:ty > for $res:ty, $method:ident ) => {
                    impl<'a> $imp<$scalar> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: $scalar ) -> $res {
                            $imp::$method( self.clone(), other)
                        }
                    }

                    impl<'a> $imp<&'a $res> for $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$res ) -> $res {
                            $imp::$method( self, other.clone())
                        }
                    }
                };
            }

            macro_rules! forward_scalar_ref_ref_binop_to_val_val
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    impl<'a, 'b> $imp<&'b $scalar> for &'a $res {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$scalar ) -> $res {
                            $imp::$method( self.clone(), *other)
                        }
                    }

                    impl<'a, 'b> $imp<&'a $res> for &'b $scalar {
                        type Output = $res;

                        #[inline] fn $method( self, other: &$res ) -> $res {
                            $imp::$method( *self, other.clone())
                        }
                    }
                };
            }

            macro_rules! promote_scalars
            {
                ( impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),* ) => {
                    $( 
                        forward_all_scalar_binop_to_val_val!( impl $imp<$scalar> for $res, $method );

                        impl $imp<$scalar> for $res {
                            type Output = $res;

                            #[cfg_attr( feature = "cargo-clippy", allow( renamed_and_removed_lints))]
                            #[cfg_attr( feature = "cargo-clippy", allow( cast_lossless))]
                            #[inline]
                            fn $method( self, other: $scalar ) -> $res {
                                $imp::$method( self, other as $promo)
                            }
                        }

                        impl $imp<$res> for $scalar {
                            type Output = $res;

                            #[cfg_attr( feature = "cargo-clippy", allow( renamed_and_removed_lints))]
                            #[cfg_attr( feature = "cargo-clippy", allow( cast_lossless))]
                            #[inline]
                            fn $method( self, other: $res ) -> $res {
                                $imp::$method( self as $promo, other)
                            }
                        }
                    )*
                }
            }

            macro_rules! promote_scalars_assign
            {
                ( impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),* ) => {
                    $( 
                        impl $imp<$scalar> for $res {
                            #[cfg_attr( feature = "cargo-clippy", allow( renamed_and_removed_lints))]
                            #[cfg_attr( feature = "cargo-clippy", allow( cast_lossless))]
                            #[inline]
                            fn $method( &mut self, other: $scalar ) {
                                self.$method( other as $promo );
                            }
                        }
                    )*
                }
            }

            macro_rules! promote_unsigned_scalars
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    promote_scalars!( impl $imp<u32> for $res, $method, u8, u16 );
                    promote_scalars!( impl $imp<UsizePromotion> for $res, $method, usize );
                }
            }

            macro_rules! promote_unsigned_scalars_assign
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    promote_scalars_assign!( impl $imp<u32> for $res, $method, u8, u16 );
                    promote_scalars_assign!( impl $imp<UsizePromotion> for $res, $method, usize );
                }
            }

            macro_rules! promote_signed_scalars
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    promote_scalars!( impl $imp<i32> for $res, $method, i8, i16 );
                    promote_scalars!( impl $imp<IsizePromotion> for $res, $method, isize );
                }
            }

            macro_rules! promote_signed_scalars_assign
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    promote_scalars_assign!( impl $imp<i32> for $res, $method, i8, i16 );
                    promote_scalars_assign!( impl $imp<IsizePromotion> for $res, $method, isize );
                }
            }
            
            macro_rules! forward_all_binop_to_ref_ref
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    forward_val_val_binop!( impl $imp for $res, $method );
                    forward_val_ref_binop!( impl $imp for $res, $method );
                    forward_ref_val_binop!( impl $imp for $res, $method );
                };
            }
            
            macro_rules! forward_all_binop_to_val_ref
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    forward_val_val_binop!( impl $imp for $res, $method );
                    forward_ref_val_binop!( impl $imp for $res, $method );
                    forward_ref_ref_binop!( impl $imp for $res, $method );
                };
            }
            
            macro_rules! forward_all_binop_to_val_ref_commutative
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    forward_val_val_binop_commutative!( impl $imp for $res, $method );
                    forward_ref_val_binop_commutative!( impl $imp for $res, $method );
                    forward_ref_ref_binop_commutative!( impl $imp for $res, $method );
                };
            }

            macro_rules! forward_all_scalar_binop_to_ref_val
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    forward_scalar_val_val_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
                    forward_scalar_val_ref_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
                    forward_scalar_ref_ref_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
                }
            }

            macro_rules! forward_all_scalar_binop_to_val_val
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    forward_scalar_val_ref_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
                    forward_scalar_ref_val_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
                    forward_scalar_ref_ref_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
                }
            }

            macro_rules! forward_all_scalar_binop_to_val_val_commutative
            {
                ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
                    forward_scalar_val_val_binop_commutative!( impl $imp<$scalar> for $res, $method );
                    forward_all_scalar_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
                }
            }

            macro_rules! promote_all_scalars
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    promote_unsigned_scalars!( impl $imp for $res, $method );
                    promote_signed_scalars!( impl $imp for $res, $method );
                }
            }

            macro_rules! promote_all_scalars_assign
            {
                ( impl $imp:ident for $res:ty, $method:ident ) => {
                    promote_unsigned_scalars_assign!( impl $imp for $res, $method );
                    promote_signed_scalars_assign!( impl $imp for $res, $method );
                }
            }

            macro_rules! impl_sum_iter_type
            {
                ( $res:ty ) => {
                    impl<T> Sum<T> for $res
                    where
                        $res: Add<T, Output = $res>,
                    {
                        fn sum<I>( iter: I ) -> Self
                        where
                            I: Iterator<Item = T>,
                        {
                            iter.fold( Zero::zero(), <$res>::add)
                        }
                    }
                };
            }

            macro_rules! impl_product_iter_type
            {
                ( $res:ty ) => {
                    impl<T> Product<T> for $res
                    where
                        $res: Mul<T, Output = $res>,
                    {
                        fn product<I>( iter: I ) -> Self
                        where
                            I: Iterator<Item = T>,
                        {
                            iter.fold( One::one(), <$res>::mul)
                        }
                    }
                };
            }
        }

        pub mod digit 
        {
            cfg_digit!
            (
                pub type BigDigit = u32;
                pub type BigDigit = u64;
            );
            
            cfg_digit!
            (
                pub type DoubleBigDigit = u64;
                pub type DoubleBigDigit = u128;
            );

            pub const BITS: u8 = BigDigit::BITS as u8;
            pub const HALF_BITS: u8 = BITS / 2;
            pub const HALF: BigDigit = (1 << HALF_BITS) - 1;
            pub const MAX: BigDigit = BigDigit::MAX;
            pub const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline] fn get_hi( n: DoubleBigDigit ) -> BigDigit { ( n >> BITS ) as BigDigit }
            
            #[inline] fn get_lo( n: DoubleBigDigit ) -> BigDigit { ( n & LO_MASK ) as BigDigit }
            /// Split one `DoubleBigDigit` into two `BigDigit`s.
            #[inline] pub fn from_doublebigdigit( n: DoubleBigDigit ) -> ( BigDigit, BigDigit ) 
            { ( get_hi( n), get_lo( n) ) }
            /// Join two `BigDigit`s into one `DoubleBigDigit`
            #[inline] pub fn to_doublebigdigit( hi: BigDigit, lo: BigDigit ) -> DoubleBigDigit
            { DoubleBigDigit::from( lo ) | ( DoubleBigDigit::from( hi ) << BITS ) }
        }
        
        pub mod int
        {
            use ::
            {
                ascii::{ AsciiExt },
                cmp::Ordering::{ self, Equal, Greater, Less },
                default::{ Default },
                iter::{ Product, Sum },
                num::
                {
                    big::
                    {
                        digit::{ self, BigDigit, DoubleBigDigit},
                        int::Sign::{Minus, NoSign, Plus},
                        uint::{ self, to_str_radix_reversed, BigUint, IntDigits },
                        ParseBigIntError,
                        
                    },
                    integer::{ Integer, Roots },
                    traits::
                    {
                        CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, FromPrimitive, Num, One, Pow, Signed, 
                        ToPrimitive, Zero,
                    },
                },
                ops::
                {
                    Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Div, DivAssign,
                    Mul, MulAssign, Neg, Not, Rem, RemAssign, Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign,
                },
                str::{ self, FromStr },
                *,
            };
            
            macro_rules! pow_impl
            {
                ( $T:ty ) =>
                {
                    impl<'a> Pow<$T> for &'a BigInt
                    {
                        type Output = BigInt;
                        #[inline] fn pow( self, rhs: $T ) -> BigInt
                        { BigInt::from_biguint( powsign( self.sign, &rhs), ( &self.data).pow( rhs) ) }
                    }

                    impl<'a, 'b> Pow<&'b $T> for &'a BigInt
                    {
                        type Output = BigInt;
                        #[inline] fn pow( self, rhs: &$T ) -> BigInt
                        { BigInt::from_biguint( powsign( self.sign, rhs), ( &self.data).pow( rhs) ) }
                    }
                };
            }
            
            macro_rules! bigint_add
            {
                ( $a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr ) =>
                {
                    match ( $a.sign, $b.sign)
                    {
                        ( _, NoSign ) => $a_owned,
                        ( NoSign, _ ) => $b_owned,
                        ( Plus, Plus ) | ( Minus, Minus ) => BigInt::from_biguint( $a.sign, $a_data + $b_data),
                        ( Plus, Minus ) | ( Minus, Plus ) => match $a.data.cmp( &$b.data)
                        {
                            Less => BigInt::from_biguint( $b.sign, $b_data - $a_data),
                            Greater => BigInt::from_biguint( $a.sign, $a_data - $b_data),
                            Equal => Zero::zero(),
                        },
                    }
                };
            }

            macro_rules! impl_to_bigint
            {
                ( $T:ty, $from_ty:path ) =>
                {
                    impl ToBigInt for $T
                    {
                        #[inline] fn to_bigint( &self ) -> Option<BigInt> { $from_ty( *self ) }
                    }
                };
            }

            macro_rules! impl_bigint_from_uint
            {
                ( $T:ty ) =>
                {
                    impl From<$T> for BigInt
                    {
                        #[inline] fn from( n: $T ) -> Self { BigInt::from( n as u64 ) }
                    }
                };
            }

            macro_rules! impl_bigint_from_int
            {
                ( $T:ty ) =>
                {
                    impl From<$T> for BigInt
                    {
                        #[inline] fn from( n: $T ) -> Self { BigInt::from( n as i64 ) }
                    }
                };
            }
            
            macro_rules! bigint_sub
            {
                ( $a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr ) =>
                {
                    match ( $a.sign, $b.sign)
                    {
                        ( _, NoSign ) => $a_owned,
                        ( NoSign, _ ) => -$b_owned,
                        ( Plus, Minus ) | ( Minus, Plus ) => BigInt::from_biguint( $a.sign, $a_data + $b_data),
                        ( Plus, Plus ) | ( Minus, Minus ) => match $a.data.cmp( &$b.data)
                        {
                            Less => BigInt::from_biguint( -$a.sign, $b_data - $a_data),
                            Greater => BigInt::from_biguint( $a.sign, $a_data - $b_data),
                            Equal => Zero::zero(),
                        },
                    }
                };
            }
            /// A Sign is a `BigInt`'s composing element.
            #[derive( PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
            pub enum Sign
            {
                Minus,
                NoSign,
                Plus,
            }

            impl Neg for Sign
            {
                type Output = Sign;
                /// Negate Sign value.
                #[inline] fn neg( self ) -> Sign
                {
                    match self
                    {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }

            impl Mul<Sign> for Sign
            {
                type Output = Sign;
                #[inline] fn mul( self, other: Sign ) -> Sign
                {
                    match ( self, other)
                    {
                        ( NoSign, _ ) | ( _, NoSign ) => NoSign,
                        ( Plus, Plus ) | ( Minus, Minus ) => Plus,
                        ( Plus, Minus ) | ( Minus, Plus ) => Minus,
                    }
                }
            }
            /// A big signed integer type.
            #[derive( Clone, Debug, Hash)]
            pub struct BigInt 
            {
                sign: Sign,
                data: BigUint,
            }
            /// Return the magnitude of a `BigInt`.
            pub fn magnitude( i: &BigInt ) -> &BigUint { &i.data }
            /// Return the owned magnitude of a `BigInt`.
            pub fn into_magnitude( i: BigInt ) -> BigUint  { i.data }

            impl PartialEq for BigInt 
            {
                #[inline] fn eq( &self, other: &BigInt ) -> bool { self.cmp( other ) == Equal }
            }

            impl Eq for BigInt {}

            impl PartialOrd for BigInt 
            {
                #[inline] fn partial_cmp( &self, other: &BigInt ) -> Option<Ordering> { Some( self.cmp( other) ) }
            }

            impl Ord for BigInt 
            {
                #[inline] fn cmp( &self, other: &BigInt ) -> Ordering
                {
                    let scmp = self.sign.cmp( &other.sign );
                    
                    if scmp != Equal { return scmp; }

                    match self.sign
                    {
                        NoSign => Equal,
                        Plus => self.data.cmp( &other.data),
                        Minus => other.data.cmp( &self.data),
                    }
                }
            }

            impl Default for BigInt 
            {
                #[inline] fn default() -> BigInt { Zero::zero() }
            }

            impl fmt::Display for BigInt 
            {
                fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
                { f.pad_integral( !self.is_negative(), "", &self.data.to_str_radix( 10 ) ) }
            }

            impl fmt::Binary for BigInt 
            {
                fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
                { f.pad_integral( !self.is_negative(), "0b", &self.data.to_str_radix( 2) ) }
            }

            impl fmt::Octal for BigInt 
            {
                fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
                { f.pad_integral( !self.is_negative(), "0o", &self.data.to_str_radix( 8) ) }
            }

            impl fmt::LowerHex for BigInt 
            {
                fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
                { f.pad_integral( !self.is_negative(), "0x", &self.data.to_str_radix( 16) ) }
            }

            impl fmt::UpperHex for BigInt 
            {
                fn fmt( &self, f: &mut fmt::Formatter ) -> fmt::Result
                {
                    let mut s = self.data.to_str_radix( 16 );
                    s.make_ascii_uppercase();
                    f.pad_integral( !self.is_negative(), "0x", &s)
                }
            }
            
            #[inline] fn negate_carry( a: BigDigit, acc: &mut DoubleBigDigit ) -> BigDigit 
            {
                *acc += DoubleBigDigit::from( !a );
                let lo = *acc as BigDigit;
                *acc >>= digit::BITS;
                lo
            }

            impl Not for BigInt 
            {
                type Output = BigInt;
                fn not( mut self ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign | Plus =>
                        {
                            self.data += 1u32;
                            self.sign = Minus;
                        }

                        Minus =>
                        {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }

                    self
                }
            }

            impl<'a> Not for &'a BigInt 
            {
                type Output = BigInt;
                fn not( self ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign | Plus => BigInt::from_biguint( Minus, &self.data + 1u32),
                        Minus => BigInt::from_biguint( Plus, &self.data - 1u32),
                    }
                }
            }
            
            fn bitand_pos_neg( a: &mut Vec<BigDigit>, b: &[BigDigit] ) 
            {
                let mut carry_b = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_b = negate_carry( bi, &mut carry_b );
                    *ai &= twos_b;
                }

                debug_assert!( b.len() > a.len() || carry_b == 0 );
            }
            
            fn bitand_neg_pos( a: &mut Vec<BigDigit>, b: &[BigDigit] ) 
            {
                let mut carry_a = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter() )
                {
                    let twos_a = negate_carry( *ai, &mut carry_a );
                    *ai = twos_a & bi;
                }

                debug_assert!( a.len() > b.len() || carry_a == 0 );
                
                if a.len() > b.len() { a.truncate( b.len() ); }
                else if b.len() > a.len()
                {
                    let extra = &b[a.len()..];
                    a.extend( extra.iter().cloned() );
                }
            }
            
            fn bitand_neg_neg( a: &mut Vec<BigDigit>, b: &[BigDigit] ) 
            {
                let mut carry_a = 1;
                let mut carry_b = 1;
                let mut carry_and = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_a = negate_carry( *ai, &mut carry_a );
                    let twos_b = negate_carry( bi, &mut carry_b );
                    *ai = negate_carry( twos_a & twos_b, &mut carry_and );
                }

                debug_assert!( a.len() > b.len() || carry_a == 0 );
                debug_assert!( b.len() > a.len() || carry_b == 0 );
                
                if a.len() > b.len()
                {
                    for ai in a[b.len()..].iter_mut()
                    {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a, &mut carry_and );
                    }

                    debug_assert!( carry_a == 0 );
                }
                
                else if b.len() > a.len()
                {
                    let extra = &b[a.len()..];
                    a.extend( extra.iter().map( |&bi|
                    {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        negate_carry( twos_b, &mut carry_and)
                    } ) );

                    debug_assert!( carry_b == 0 );
                }

                if carry_and != 0 { a.push( 1 ); }
            }

            forward_val_val_binop!( impl BitAnd for BigInt, bitand );
            forward_ref_val_binop!( impl BitAnd for BigInt, bitand );
            
            impl<'a, 'b> BitAnd<&'b BigInt> for &'a BigInt 
            {
                type Output = BigInt;
                #[inline] fn bitand( self, other: &BigInt ) -> BigInt
                {
                    match ( self.sign, other.sign)
                    {
                        ( NoSign, _ ) | ( _, NoSign ) => BigInt::from_slice( NoSign, &[]),
                        ( Plus, Plus ) => BigInt::from_biguint( Plus, &self.data & &other.data),
                        ( Plus, Minus ) => self.clone() & other,
                        ( Minus, Plus ) => other.clone() & self,
                        ( Minus, Minus ) => 
                        {
                            if self.len() >= other.len() { self.clone() & other } else { other.clone() & self }
                        }
                    }
                }
            }

            impl<'a> BitAnd<&'a BigInt> for BigInt 
            {
                type Output = BigInt;
                #[inline] fn bitand( mut self, other: &BigInt ) -> BigInt
                {
                    self &= other;
                    self
                }
            }

            forward_val_assign!( impl BitAndAssign for BigInt, bitand_assign );

            impl<'a> BitAndAssign<&'a BigInt> for BigInt 
            {
                fn bitand_assign( &mut self, other: &BigInt)
                {
                    match ( self.sign, other.sign)
                    {
                        ( NoSign, _ ) => {}
                        ( _, NoSign ) => self.assign_from_slice( NoSign, &[]),
                        ( Plus, Plus ) =>
                        {
                            self.data &= &other.data;
                            if self.data.is_zero() {
                                self.sign = NoSign;
                            }
                        }

                        ( Plus, Minus ) =>
                        {
                            bitand_pos_neg( self.digits_mut(), other.digits() );
                            self.normalize();
                        }

                        ( Minus, Plus ) =>
                        {
                            bitand_neg_pos( self.digits_mut(), other.digits() );
                            self.sign = Plus;
                            self.normalize();
                        }

                        ( Minus, Minus ) =>
                        {
                            bitand_neg_neg( self.digits_mut(), other.digits() );
                            self.normalize();
                        }
                    }
                }
            }
            
            fn bitor_pos_neg( a: &mut Vec<BigDigit>, b: &[BigDigit])
            {
                let mut carry_b = 1;
                let mut carry_or = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_b = negate_carry( bi, &mut carry_b );
                    *ai = negate_carry( *ai | twos_b, &mut carry_or );
                }
                
                debug_assert!( b.len() > a.len() || carry_b == 0 );
                
                if a.len() > b.len() { a.truncate( b.len() ); }
                else if b.len() > a.len()
                {
                    let extra = &b[a.len()..];
                    a.extend( extra.iter().map( |&bi|
                    {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        negate_carry( twos_b, &mut carry_or)
                    } ) );
                    
                    debug_assert!( carry_b == 0 );
                }
                
                debug_assert!( carry_or == 0 );
            }
            
            fn bitor_neg_pos( a: &mut Vec<BigDigit>, b: &[BigDigit] ) 
            {
                let mut carry_a = 1;
                let mut carry_or = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_a = negate_carry( *ai, &mut carry_a );
                    *ai = negate_carry( twos_a | bi, &mut carry_or );
                }

                debug_assert!( a.len() > b.len() || carry_a == 0 );
                
                if a.len() > b.len()
                {
                    for ai in a[b.len()..].iter_mut()
                    {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a, &mut carry_or );
                    }

                    debug_assert!( carry_a == 0 );
                }
                
                debug_assert!( carry_or == 0 );
            }
            
            fn bitor_neg_neg( a: &mut Vec<BigDigit>, b: &[BigDigit] ) 
            {
                let mut carry_a = 1;
                let mut carry_b = 1;
                let mut carry_or = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_a = negate_carry( *ai, &mut carry_a );
                    let twos_b = negate_carry( bi, &mut carry_b );
                    *ai = negate_carry( twos_a | twos_b, &mut carry_or );
                }

                debug_assert!( a.len() > b.len() || carry_a == 0 );
                debug_assert!( b.len() > a.len() || carry_b == 0 );

                if a.len() > b.len() { a.truncate( b.len() ); }
                
                debug_assert!( carry_or == 0 );
            }

            forward_val_val_binop!( impl BitOr for BigInt, bitor );
            forward_ref_val_binop!( impl BitOr for BigInt, bitor );
            
            impl<'a, 'b> BitOr<&'b BigInt> for &'a BigInt 
            {
                type Output = BigInt;
                #[inline] fn bitor( self, other: &BigInt ) -> BigInt
                {
                    match ( self.sign, other.sign)
                    {
                        ( NoSign, _ ) => other.clone(),
                        ( _, NoSign ) => self.clone(),
                        ( Plus, Plus ) => BigInt::from_biguint( Plus, &self.data | &other.data),
                        ( Plus, Minus ) => other.clone() | self,
                        ( Minus, Plus ) => self.clone() | other,
                        ( Minus, Minus ) =>
                        {
                            if self.len() <= other.len() { self.clone() | other } else { other.clone() | self }
                        }
                    }
                }
            }

            impl<'a> BitOr<&'a BigInt> for BigInt 
            {
                type Output = BigInt;
                #[inline] fn bitor( mut self, other: &BigInt ) -> BigInt
                {
                    self |= other;
                    self
                }
            }

            forward_val_assign!( impl BitOrAssign for BigInt, bitor_assign );

            impl<'a> BitOrAssign<&'a BigInt> for BigInt 
            {
                fn bitor_assign( &mut self, other: &BigInt)
                {
                    match ( self.sign, other.sign)
                    {
                        ( _, NoSign ) => {}
                        ( NoSign, _ ) => self.assign_from_slice( other.sign, other.digits()),
                        ( Plus, Plus ) => self.data |= &other.data,
                        ( Plus, Minus ) =>
                        {
                            bitor_pos_neg( self.digits_mut(), other.digits() );
                            self.sign = Minus;
                            self.normalize();
                        }

                        ( Minus, Plus ) =>
                        {
                            bitor_neg_pos( self.digits_mut(), other.digits() );
                            self.normalize();
                        }

                        ( Minus, Minus ) =>
                        {
                            bitor_neg_neg( self.digits_mut(), other.digits() );
                            self.normalize();
                        }
                    }
                }
            }
            
            fn bitxor_pos_neg( a: &mut Vec<BigDigit>, b: &[BigDigit])
            {
                let mut carry_b = 1;
                let mut carry_xor = 1;

                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_b = negate_carry( bi, &mut carry_b );
                    *ai = negate_carry( *ai ^ twos_b, &mut carry_xor );
                }
                
                debug_assert!( b.len() > a.len() || carry_b == 0 );
                
                if a.len() > b.len()
                {
                    for ai in a[b.len()..].iter_mut()
                    {
                        let twos_b = !0;
                        *ai = negate_carry( *ai ^ twos_b, &mut carry_xor );
                    }
                }

                else if b.len() > a.len()
                {
                    let extra = &b[a.len()..];
                    a.extend( extra.iter().map( |&bi|
                    {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        negate_carry( twos_b, &mut carry_xor)
                    } ) );

                    debug_assert!( carry_b == 0 );
                }

                if carry_xor != 0 { a.push( 1 ); }
            }
            
            fn bitxor_neg_pos( a: &mut Vec<BigDigit>, b: &[BigDigit])
            {
                let mut carry_a = 1;
                let mut carry_xor = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_a = negate_carry( *ai, &mut carry_a );
                    *ai = negate_carry( twos_a ^ bi, &mut carry_xor );
                }

                debug_assert!( a.len() > b.len() || carry_a == 0 );
                
                if a.len() > b.len()
                {
                    for ai in a[b.len()..].iter_mut()
                    {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a, &mut carry_xor );
                    }
                    
                    debug_assert!( carry_a == 0 );
                }
                
                else if b.len() > a.len()
                {
                    let extra = &b[a.len()..];
                    a.extend( extra.iter().map( |&bi|
                    {
                        let twos_a = !0;
                        negate_carry( twos_a ^ bi, &mut carry_xor)
                    } ) );
                }

                if carry_xor != 0 { a.push( 1 ); }
            }
            
            fn bitxor_neg_neg( a: &mut Vec<BigDigit>, b: &[BigDigit])
            {
                let mut carry_a = 1;
                let mut carry_b = 1;
                
                for ( ai, &bi ) in a.iter_mut().zip( b.iter())
                {
                    let twos_a = negate_carry( *ai, &mut carry_a );
                    let twos_b = negate_carry( bi, &mut carry_b );
                    *ai = twos_a ^ twos_b;
                }
                
                debug_assert!( a.len() > b.len() || carry_a == 0 );
                debug_assert!( b.len() > a.len() || carry_b == 0 );
                
                if a.len() > b.len()
                {
                    for ai in a[b.len()..].iter_mut()
                    {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = !0;
                        *ai = twos_a ^ twos_b;
                    }
                    
                    debug_assert!( carry_a == 0 );
                }
                
                else if b.len() > a.len()
                {
                    let extra = &b[a.len()..];
                    a.extend( extra.iter().map( |&bi|
                    {
                        let twos_a = !0;
                        let twos_b = negate_carry( bi, &mut carry_b );
                        twos_a ^ twos_b
                    } ) );

                    debug_assert!( carry_b == 0 );
                }
            }

            forward_all_binop_to_val_ref_commutative!( impl BitXor for BigInt, bitxor );

            impl<'a> BitXor<&'a BigInt> for BigInt
            {
                type Output = BigInt;
                #[inline] fn bitxor( mut self, other: &BigInt ) -> BigInt
                {
                    self ^= other;
                    self
                }
            }

            forward_val_assign!( impl BitXorAssign for BigInt, bitxor_assign );

            impl<'a> BitXorAssign<&'a BigInt> for BigInt
            {
                fn bitxor_assign( &mut self, other: &BigInt)
                {
                    match ( self.sign, other.sign)
                    {
                        ( _, NoSign ) => {}
                        ( NoSign, _ ) => self.assign_from_slice( other.sign, other.digits()),
                        ( Plus, Plus ) => 
                        {
                            self.data ^= &other.data;
                            if self.data.is_zero() { self.sign = NoSign; }
                        }
                        ( Plus, Minus ) => 
                        {
                            bitxor_pos_neg( self.digits_mut(), other.digits() );
                            self.sign = Minus;
                            self.normalize();
                        }
                        ( Minus, Plus ) => 
                        {
                            bitxor_neg_pos( self.digits_mut(), other.digits() );
                            self.normalize();
                        }
                        ( Minus, Minus ) => 
                        {
                            bitxor_neg_neg( self.digits_mut(), other.digits() );
                            self.sign = Plus;
                            self.normalize();
                        }
                    }
                }
            }

            impl FromStr for BigInt
            {
                type Err = ParseBigIntError;
                #[inline] fn from_str( s: &str ) -> Result<BigInt, ParseBigIntError> { BigInt::from_str_radix( s, 10 ) }
            }

            impl Num for BigInt
            {
                type FromStrRadixErr = ParseBigIntError;
                /// Creates and initializes a BigInt.
                #[inline] fn from_str_radix( mut s: &str, radix: u32 ) -> Result<BigInt, ParseBigIntError>
                {
                    let sign = if s.starts_with( '-' )
                    {
                        let tail = &s[1..];
                        if !tail.starts_with( '+' ) { s = tail }
                        Minus
                    }
                    else { Plus };

                    let bu = BigUint::from_str_radix( s, radix)?;
                    Ok( BigInt::from_biguint( sign, bu))
                }
            }

            impl Shl<usize> for BigInt 
            {
                type Output = BigInt;

                #[inline] fn shl( mut self, rhs: usize ) -> BigInt
                {
                    self <<= rhs;
                    self
                }
            }

            impl<'a> Shl<usize> for &'a BigInt 
            {
                type Output = BigInt;
                #[inline] fn shl( self, rhs: usize ) -> BigInt { BigInt::from_biguint( self.sign, &self.data << rhs) }
            }

            impl ShlAssign<usize> for BigInt 
            {
                #[inline] fn shl_assign( &mut self, rhs: usize ) { self.data <<= rhs; }
            }
            
            fn shr_round_down( i: &BigInt, rhs: usize ) -> bool
            {
                /*
                i.is_negative() && uint::trailing_zeros( &i.data).map( |n| n < rhs).unwrap_or( false)
                */
                false
            }

            impl Shr<usize> for BigInt
            {
                type Output = BigInt;
                #[inline] fn shr( mut self, rhs: usize ) -> BigInt
                {
                    self >>= rhs;
                    self
                }
            }

            impl<'a> Shr<usize> for &'a BigInt
            {
                type Output = BigInt;
                #[inline] fn shr( self, rhs: usize ) -> BigInt
                {
                    let round_down = shr_round_down( self, rhs );
                    let data = &self.data >> rhs;
                    BigInt::from_biguint( self.sign, if round_down { data + 1u8 } else { data })
                }
            }

            impl ShrAssign<usize> for BigInt 
            {
                #[inline] fn shr_assign( &mut self, rhs: usize )
                {
                    let round_down = shr_round_down( self, rhs );
                    self.data >>= rhs;

                    if round_down { self.data += 1u8; }
                    else if self.data.is_zero() { self.sign = NoSign; }
                }
            }

            impl Zero for BigInt
            {
                #[inline] fn zero() -> BigInt { BigInt::from_biguint( NoSign, Zero::zero()) }

                #[inline] fn set_zero( &mut self )
                {
                    self.data.set_zero();
                    self.sign = NoSign;
                }

                #[inline] fn is_zero( &self ) -> bool { self.sign == NoSign }
            }

            impl One for BigInt
            {
                #[inline] fn one() -> BigInt { BigInt::from_biguint( Plus, One::one()) }

                #[inline] fn set_one( &mut self ) 
                {
                    self.data.set_one();
                    self.sign = Plus;
                }

                #[inline] fn is_one( &self ) -> bool { self.sign == Plus && self.data.is_one() }
            }

            impl Signed for BigInt 
            {
                #[inline] fn abs( &self ) -> BigInt
                {
                    match self.sign
                    {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from_biguint( Plus, self.data.clone()),
                    }
                }

                #[inline] fn abs_sub( &self, other: &BigInt ) -> BigInt
                {
                    if *self <= *other { Zero::zero() } else { self - other }
                }

                #[inline] fn signum( &self ) -> BigInt
                {
                    match self.sign
                    {
                        Plus => BigInt::from_biguint( Plus, One::one()),
                        Minus => BigInt::from_biguint( Minus, One::one()),
                        NoSign => Zero::zero(),
                    }
                }

                #[inline] fn is_positive( &self ) -> bool { self.sign == Plus }

                #[inline] fn is_negative( &self ) -> bool { self.sign == Minus }
            }
            /// Help function for pow.
            #[inline] fn powsign<T: Integer>( sign: Sign, other: &T ) -> Sign 
            {
                if other.is_zero() { Plus } 
                else if sign != Minus { sign } 
                else if other.is_odd() { sign } 
                else { -sign }
            }

            pow_impl!( u8 );
            pow_impl!( u16 );
            pow_impl!( u32 );
            pow_impl!( u64 );
            pow_impl!( usize );            
            pow_impl!( u128 );
            pow_impl!( BigUint );
            
            #[inline] fn i32_abs_as_u32( a: i32 ) -> u32
            {
                if a == i32::min_value() { a as u32 }
                else { a.abs() as u32 }
            }
            
            #[inline] fn i64_abs_as_u64( a: i64 ) -> u64
            {
                if a == i64::min_value() { a as u64 } else { a.abs() as u64 }
            }
            
            #[inline] fn i128_abs_as_u128( a: i128 ) -> u128
            {
                if a == i128::min_value() { a as u128 }
                else { a.abs() as u128 }
            }

            impl<'a, 'b> Add<&'b BigInt> for &'a BigInt
            {
                type Output = BigInt;
                #[inline] fn add( self, other: &BigInt ) -> BigInt
                {
                    bigint_add!
                    (
                        self,
                        self.clone(),
                        &self.data,
                        other,
                        other.clone(),
                        &other.data
                    )
                }
            }

            impl<'a> Add<BigInt> for &'a BigInt 
            {
                type Output = BigInt;
                #[inline] fn add( self, other: BigInt ) -> BigInt
                { bigint_add!( self, self.clone(), &self.data, other, other, other.data ) }
            }

            impl<'a> Add<&'a BigInt> for BigInt 
            {
                type Output = BigInt;
                #[inline] fn add( self, other: &BigInt ) -> BigInt
                { bigint_add!( self, self, self.data, other, other.clone(), &other.data ) }
            }

            impl Add<BigInt> for BigInt 
            {
                type Output = BigInt;
                #[inline] fn add( self, other: BigInt ) -> BigInt
                { bigint_add!( self, self, self.data, other, other, other.data ) }
            }

            impl<'a> AddAssign<&'a BigInt> for BigInt 
            {
                #[inline] fn add_assign( &mut self, other: &BigInt)
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n + other;
                }
            }

            forward_val_assign!( impl AddAssign for BigInt, add_assign );
            promote_all_scalars!( impl Add for BigInt, add );
            promote_all_scalars_assign!( impl AddAssign for BigInt, add_assign );
            forward_all_scalar_binop_to_val_val_commutative!( impl Add<u32> for BigInt, add );
            forward_all_scalar_binop_to_val_val_commutative!( impl Add<u64> for BigInt, add );
            forward_all_scalar_binop_to_val_val_commutative!( impl Add<u128> for BigInt, add );

            impl Add<u32> for BigInt 
            {
                type Output = BigInt;

                #[inline] fn add( self, other: u32 ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign => From::from( other),
                        Plus => BigInt::from_biguint( Plus, self.data + other),
                        Minus => match self.data.cmp( &From::from( other) )
                        {
                            Equal => Zero::zero(),
                            Less => BigInt::from_biguint( Plus, other - self.data),
                            Greater => BigInt::from_biguint( Minus, self.data - other),
                        },
                    }
                }
            }

            impl AddAssign<u32> for BigInt
            {
                #[inline] fn add_assign( &mut self, other: u32)
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n + other;
                }
            }

            impl Add<u64> for BigInt
            {
                type Output = BigInt;

                #[inline] fn add( self, other: u64 ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign => From::from( other),
                        Plus => BigInt::from_biguint( Plus, self.data + other),
                        Minus => match self.data.cmp( &From::from( other) ) {
                            Equal => Zero::zero(),
                            Less => BigInt::from_biguint( Plus, other - self.data),
                            Greater => BigInt::from_biguint( Minus, self.data - other),
                        },
                    }
                }
            }

            impl AddAssign<u64> for BigInt 
            {
                #[inline] fn add_assign( &mut self, other: u64)
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n + other;
                }
            }
            
            impl Add<u128> for BigInt 
            {
                type Output = BigInt;

                #[inline] fn add( self, other: u128 ) -> BigInt
                {
                    match self.sign {
                        NoSign => From::from( other),
                        Plus => BigInt::from_biguint( Plus, self.data + other),
                        Minus => match self.data.cmp( &From::from( other) ) {
                            Equal => Zero::zero(),
                            Less => BigInt::from_biguint( Plus, other - self.data),
                            Greater => BigInt::from_biguint( Minus, self.data - other),
                        },
                    }
                }
            }
            
            impl AddAssign<u128> for BigInt 
            {
                #[inline] fn add_assign( &mut self, other: u128 )
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n + other;
                }
            }

            forward_all_scalar_binop_to_val_val_commutative!( impl Add<i32> for BigInt, add );
            forward_all_scalar_binop_to_val_val_commutative!( impl Add<i64> for BigInt, add );
            forward_all_scalar_binop_to_val_val_commutative!( impl Add<i128> for BigInt, add );

            impl Add<i32> for BigInt 
            {
                type Output = BigInt;

                #[inline] fn add( self, other: i32 ) -> BigInt {
                    if other >= 0 {
                        self + other as u32
                    } else {
                        self - i32_abs_as_u32( other)
                    }
                }
            }

            impl AddAssign<i32> for BigInt 
            {
                #[inline] fn add_assign( &mut self, other: i32 )
                {
                    if other >= 0 { *self += other as u32; }
                    else { *self -= i32_abs_as_u32( other ); }
                }
            }

            impl Add<i64> for BigInt 
            {
                type Output = BigInt;
                #[inline] fn add( self, other: i64 ) -> BigInt
                {
                    if other >= 0 { self + other as u64 }
                    else { self - i64_abs_as_u64( other) }
                }
            }

            impl AddAssign<i64> for BigInt
            {
                #[inline] fn add_assign( &mut self, other: i64)
                {
                    if other >= 0 { *self += other as u64; }
                    else { *self -= i64_abs_as_u64( other ); }
                }
            }
            
            impl Add<i128> for BigInt
            {
                type Output = BigInt;
                #[inline] fn add( self, other: i128 ) -> BigInt
                {
                    if other >= 0 { self + other as u128 }
                    else { self - i128_abs_as_u128( other) }
                }
            }
            
            impl AddAssign<i128> for BigInt 
            {
                #[inline] fn add_assign( &mut self, other: i128 )
                {
                    if other >= 0 { *self += other as u128; }
                    else { *self -= i128_abs_as_u128( other ); }
                }
            }

            impl<'a, 'b> Sub<&'b BigInt> for &'a BigInt
            {
                type Output = BigInt;

                #[inline] fn sub( self, other: &BigInt ) -> BigInt
                {
                    bigint_sub!
                    (
                        self,
                        self.clone(),
                        &self.data,
                        other,
                        other.clone(),
                        &other.data
                    )
                }
            }

            impl<'a> Sub<BigInt> for &'a BigInt
            {
                type Output = BigInt;

                #[inline] fn sub( self, other: BigInt ) -> BigInt
                {
                    bigint_sub!( self, self.clone(), &self.data, other, other, other.data)
                }
            }

            impl<'a> Sub<&'a BigInt> for BigInt
            {
                type Output = BigInt;

                #[inline] fn sub( self, other: &BigInt ) -> BigInt
                { bigint_sub!( self, self, self.data, other, other.clone(), &other.data) }
            }

            impl Sub<BigInt> for BigInt
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: BigInt ) -> BigInt
                { bigint_sub!( self, self, self.data, other, other, other.data ) }
            }

            impl<'a> SubAssign<&'a BigInt> for BigInt
            {
                #[inline] fn sub_assign( &mut self, other: &BigInt)
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n - other;
                }
            }

            forward_val_assign!( impl SubAssign for BigInt, sub_assign );
            promote_all_scalars!( impl Sub for BigInt, sub );
            promote_all_scalars_assign!( impl SubAssign for BigInt, sub_assign );
            forward_all_scalar_binop_to_val_val!( impl Sub<u32> for BigInt, sub );
            forward_all_scalar_binop_to_val_val!( impl Sub<u64> for BigInt, sub );
            forward_all_scalar_binop_to_val_val!( impl Sub<u128> for BigInt, sub );

            impl Sub<u32> for BigInt
            {
                type Output = BigInt;

                #[inline] fn sub( self, other: u32 ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign => BigInt::from_biguint( Minus, From::from( other)),
                        Minus => BigInt::from_biguint( Minus, self.data + other),
                        Plus => match self.data.cmp( &From::from( other) )
                        {
                            Equal => Zero::zero(),
                            Greater => BigInt::from_biguint( Plus, self.data - other),
                            Less => BigInt::from_biguint( Minus, other - self.data),
                        },
                    }
                }
            }

            impl SubAssign<u32> for BigInt
            {
                #[inline] fn sub_assign( &mut self, other: u32 )
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n - other;
                }
            }

            impl Sub<BigInt> for u32
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: BigInt ) -> BigInt { -( other - self) }
            }

            impl Sub<BigInt> for u64
            {
                type Output = BigInt;

                #[inline] fn sub( self, other: BigInt ) -> BigInt { -( other - self) }
            }
            
            impl Sub<BigInt> for u128
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: BigInt ) -> BigInt { -( other - self) }
            }

            impl Sub<u64> for BigInt
            {
                type Output = BigInt;

                #[inline] fn sub( self, other: u64 ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign => BigInt::from_biguint( Minus, From::from( other)),
                        Minus => BigInt::from_biguint( Minus, self.data + other),
                        Plus => match self.data.cmp( &From::from( other) )
                        {
                            Equal => Zero::zero(),
                            Greater => BigInt::from_biguint( Plus, self.data - other),
                            Less => BigInt::from_biguint( Minus, other - self.data),
                        },
                    }
                }
            }
            
            impl SubAssign<u64> for BigInt
            {
                #[inline] fn sub_assign( &mut self, other: u64 )
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n - other;
                }
            }
            
            impl Sub<u128> for BigInt
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: u128 ) -> BigInt
                {
                    match self.sign
                    {
                        NoSign => BigInt::from_biguint( Minus, From::from( other)),
                        Minus => BigInt::from_biguint( Minus, self.data + other),
                        Plus => match self.data.cmp( &From::from( other) )
                        {
                            Equal => Zero::zero(),
                            Greater => BigInt::from_biguint( Plus, self.data - other),
                            Less => BigInt::from_biguint( Minus, other - self.data),
                        },
                    }
                }
            }
            
            impl SubAssign<u128> for BigInt
            {
                #[inline] fn sub_assign( &mut self, other: u128 )
                {
                    let n = mem::replace( self, BigInt::zero() );
                    *self = n - other;
                }
            }

            forward_all_scalar_binop_to_val_val!( impl Sub<i32> for BigInt, sub );
            forward_all_scalar_binop_to_val_val!( impl Sub<i64> for BigInt, sub );
            forward_all_scalar_binop_to_val_val!( impl Sub<i128> for BigInt, sub );

            impl Sub<i32> for BigInt
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: i32 ) -> BigInt
                {
                    if other >= 0 { self - other as u32 }
                    else { self + i32_abs_as_u32( other) }
                }
            }

            impl SubAssign<i32> for BigInt
            {
                #[inline] fn sub_assign( &mut self, other: i32 ) 
                {
                    if other >= 0 { *self -= other as u32; }
                    else { *self += i32_abs_as_u32( other ); }
                }
            }

            impl Sub<BigInt> for i32
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: BigInt ) -> BigInt 
                {
                    if self >= 0 { self as u32 - other }
                    
                    else { -other - i32_abs_as_u32( self ) }
                }
            }

            impl Sub<i64> for BigInt
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: i64 ) -> BigInt 
                {
                    if other >= 0 { self - other as u64 }
                    else { self + i64_abs_as_u64( other) }
                }
            }

            impl SubAssign<i64> for BigInt
            {
                #[inline] fn sub_assign( &mut self, other: i64 ) 
                {
                    if other >= 0  { *self -= other as u64; }
                    else { *self += i64_abs_as_u64( other ); }
                }
            }

            impl Sub<BigInt> for i64
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: BigInt ) -> BigInt 
                {
                    if self >= 0 { self as u64 - other }
                    else  { -other - i64_abs_as_u64( self ) }
                }
            }
            
            impl Sub<i128> for BigInt
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: i128 ) -> BigInt 
                {
                    if other >= 0  { self - other as u128 }
                    else { self + i128_abs_as_u128( other) }
                }
            }
            
            impl SubAssign<i128> for BigInt 
            {
                #[inline] fn sub_assign( &mut self, other: i128 ) 
                {
                    if other >= 0 
                    {
                        *self -= other as u128;
                    } else 
                    {
                        *self += i128_abs_as_u128( other );
                    }
                }
            }
            
            impl Sub<BigInt> for i128
            {
                type Output = BigInt;
                #[inline] fn sub( self, other: BigInt ) -> BigInt
                {
                    if self >= 0 {
                        self as u128 - other
                    } else {
                        -other - i128_abs_as_u128( self )
                    }
                }
            }

            forward_all_binop_to_ref_ref!( impl Mul for BigInt, mul );

            impl<'a, 'b> Mul<&'b BigInt> for &'a BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: &BigInt ) -> BigInt {
                    BigInt::from_biguint( self.sign * other.sign, &self.data * &other.data)
                }
            }

            impl<'a> MulAssign<&'a BigInt> for BigInt {
                #[inline] fn mul_assign( &mut self, other: &BigInt ) {
                    *self = &*self * other;
                }
            }
            forward_val_assign!( impl MulAssign for BigInt, mul_assign );

            promote_all_scalars!( impl Mul for BigInt, mul );
            promote_all_scalars_assign!( impl MulAssign for BigInt, mul_assign );
            forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u32> for BigInt, mul );
            forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u64> for BigInt, mul );
            forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u128> for BigInt, mul );

            impl Mul<u32> for BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: u32 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data * other)
                }
            }

            impl MulAssign<u32> for BigInt {
                #[inline] fn mul_assign( &mut self, other: u32 ) {
                    self.data *= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            impl Mul<u64> for BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: u64 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data * other)
                }
            }

            impl MulAssign<u64> for BigInt {
                #[inline] fn mul_assign( &mut self, other: u64 ) {
                    self.data *= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }
            
            impl Mul<u128> for BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: u128 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data * other)
                }
            }
            
            impl MulAssign<u128> for BigInt {
                #[inline] fn mul_assign( &mut self, other: u128 ) {
                    self.data *= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i32> for BigInt, mul );
            forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i64> for BigInt, mul );
            forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i128> for BigInt, mul );

            impl Mul<i32> for BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: i32 ) -> BigInt {
                    if other >= 0 {
                        self * other as u32
                    } else {
                        -( self * i32_abs_as_u32( other))
                    }
                }
            }

            impl MulAssign<i32> for BigInt {
                #[inline] fn mul_assign( &mut self, other: i32 ) {
                    if other >= 0 {
                        *self *= other as u32;
                    } else {
                        self.sign = -self.sign;
                        *self *= i32_abs_as_u32( other );
                    }
                }
            }

            impl Mul<i64> for BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: i64 ) -> BigInt {
                    if other >= 0 {
                        self * other as u64
                    } else {
                        -( self * i64_abs_as_u64( other))
                    }
                }
            }

            impl MulAssign<i64> for BigInt {
                #[inline] fn mul_assign( &mut self, other: i64 ) {
                    if other >= 0 {
                        *self *= other as u64;
                    } else {
                        self.sign = -self.sign;
                        *self *= i64_abs_as_u64( other );
                    }
                }
            }
            
            impl Mul<i128> for BigInt {
                type Output = BigInt;

                #[inline] fn mul( self, other: i128 ) -> BigInt {
                    if other >= 0 {
                        self * other as u128
                    } else {
                        -( self * i128_abs_as_u128( other))
                    }
                }
            }
            
            impl MulAssign<i128> for BigInt {
                #[inline] fn mul_assign( &mut self, other: i128 ) {
                    if other >= 0 {
                        *self *= other as u128;
                    } else {
                        self.sign = -self.sign;
                        *self *= i128_abs_as_u128( other );
                    }
                }
            }

            forward_all_binop_to_ref_ref!( impl Div for BigInt, div );

            impl<'a, 'b> Div<&'b BigInt> for &'a BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: &BigInt ) -> BigInt {
                    let ( q, _ ) = self.div_rem( other );
                    q
                }
            }

            impl<'a> DivAssign<&'a BigInt> for BigInt {
                #[inline] fn div_assign( &mut self, other: &BigInt ) {
                    *self = &*self / other;
                }
            }
            forward_val_assign!( impl DivAssign for BigInt, div_assign );

            promote_all_scalars!( impl Div for BigInt, div );
            promote_all_scalars_assign!( impl DivAssign for BigInt, div_assign );
            forward_all_scalar_binop_to_val_val!( impl Div<u32> for BigInt, div );
            forward_all_scalar_binop_to_val_val!( impl Div<u64> for BigInt, div );
            forward_all_scalar_binop_to_val_val!( impl Div<u128> for BigInt, div );

            impl Div<u32> for BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: u32 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data / other)
                }
            }

            impl DivAssign<u32> for BigInt {
                #[inline] fn div_assign( &mut self, other: u32 ) {
                    self.data /= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            impl Div<BigInt> for u32 {
                type Output = BigInt;

                #[inline] fn div( self, other: BigInt ) -> BigInt {
                    BigInt::from_biguint( other.sign, self / other.data)
                }
            }

            impl Div<u64> for BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: u64 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data / other)
                }
            }

            impl DivAssign<u64> for BigInt {
                #[inline] fn div_assign( &mut self, other: u64 ) {
                    self.data /= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            impl Div<BigInt> for u64 {
                type Output = BigInt;

                #[inline] fn div( self, other: BigInt ) -> BigInt {
                    BigInt::from_biguint( other.sign, self / other.data)
                }
            }

            
            impl Div<u128> for BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: u128 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data / other)
                }
            }
            impl DivAssign<u128> for BigInt {
                #[inline] fn div_assign( &mut self, other: u128 ) {
                    self.data /= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            
            impl Div<BigInt> for u128 {
                type Output = BigInt;

                #[inline] fn div( self, other: BigInt ) -> BigInt {
                    BigInt::from_biguint( other.sign, self / other.data)
                }
            }

            forward_all_scalar_binop_to_val_val!( impl Div<i32> for BigInt, div );
            forward_all_scalar_binop_to_val_val!( impl Div<i64> for BigInt, div );
            
            forward_all_scalar_binop_to_val_val!( impl Div<i128> for BigInt, div );

            impl Div<i32> for BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: i32 ) -> BigInt {
                    if other >= 0 {
                        self / other as u32
                    } else {
                        -( self / i32_abs_as_u32( other))
                    }
                }
            }

            impl DivAssign<i32> for BigInt {
                #[inline] fn div_assign( &mut self, other: i32 ) {
                    if other >= 0 {
                        *self /= other as u32;
                    } else {
                        self.sign = -self.sign;
                        *self /= i32_abs_as_u32( other );
                    }
                }
            }

            impl Div<BigInt> for i32 {
                type Output = BigInt;

                #[inline] fn div( self, other: BigInt ) -> BigInt {
                    if self >= 0 {
                        self as u32 / other
                    } else {
                        -( i32_abs_as_u32( self ) / other)
                    }
                }
            }

            impl Div<i64> for BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: i64 ) -> BigInt {
                    if other >= 0 {
                        self / other as u64
                    } else {
                        -( self / i64_abs_as_u64( other))
                    }
                }
            }

            impl DivAssign<i64> for BigInt {
                #[inline] fn div_assign( &mut self, other: i64 ) {
                    if other >= 0 {
                        *self /= other as u64;
                    } else {
                        self.sign = -self.sign;
                        *self /= i64_abs_as_u64( other );
                    }
                }
            }

            impl Div<BigInt> for i64 {
                type Output = BigInt;

                #[inline] fn div( self, other: BigInt ) -> BigInt {
                    if self >= 0 {
                        self as u64 / other
                    } else {
                        -( i64_abs_as_u64( self ) / other)
                    }
                }
            }

            
            impl Div<i128> for BigInt {
                type Output = BigInt;

                #[inline] fn div( self, other: i128 ) -> BigInt {
                    if other >= 0 {
                        self / other as u128
                    } else {
                        -( self / i128_abs_as_u128( other))
                    }
                }
            }

            
            impl DivAssign<i128> for BigInt {
                #[inline] fn div_assign( &mut self, other: i128 ) {
                    if other >= 0 {
                        *self /= other as u128;
                    } else {
                        self.sign = -self.sign;
                        *self /= i128_abs_as_u128( other );
                    }
                }
            }

            
            impl Div<BigInt> for i128 {
                type Output = BigInt;

                #[inline] fn div( self, other: BigInt ) -> BigInt {
                    if self >= 0 {
                        self as u128 / other
                    } else {
                        -( i128_abs_as_u128( self ) / other)
                    }
                }
            }

            forward_all_binop_to_ref_ref!( impl Rem for BigInt, rem );

            impl<'a, 'b> Rem<&'b BigInt> for &'a BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: &BigInt ) -> BigInt {
                    let ( _, r ) = self.div_rem( other );
                    r
                }
            }

            impl<'a> RemAssign<&'a BigInt> for BigInt {
                #[inline] fn rem_assign( &mut self, other: &BigInt ) {
                    *self = &*self % other;
                }
            }
            forward_val_assign!( impl RemAssign for BigInt, rem_assign );

            promote_all_scalars!( impl Rem for BigInt, rem );
            promote_all_scalars_assign!( impl RemAssign for BigInt, rem_assign );
            forward_all_scalar_binop_to_val_val!( impl Rem<u32> for BigInt, rem );
            forward_all_scalar_binop_to_val_val!( impl Rem<u64> for BigInt, rem );
            
            forward_all_scalar_binop_to_val_val!( impl Rem<u128> for BigInt, rem );

            impl Rem<u32> for BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: u32 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data % other)
                }
            }

            impl RemAssign<u32> for BigInt {
                #[inline] fn rem_assign( &mut self, other: u32 ) {
                    self.data %= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            impl Rem<BigInt> for u32 {
                type Output = BigInt;

                #[inline] fn rem( self, other: BigInt ) -> BigInt {
                    BigInt::from_biguint( Plus, self % other.data)
                }
            }

            impl Rem<u64> for BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: u64 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data % other)
                }
            }

            impl RemAssign<u64> for BigInt {
                #[inline] fn rem_assign( &mut self, other: u64 ) {
                    self.data %= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            impl Rem<BigInt> for u64 {
                type Output = BigInt;

                #[inline] fn rem( self, other: BigInt ) -> BigInt {
                    BigInt::from_biguint( Plus, self % other.data)
                }
            }

            
            impl Rem<u128> for BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: u128 ) -> BigInt {
                    BigInt::from_biguint( self.sign, self.data % other)
                }
            }

            
            impl RemAssign<u128> for BigInt {
                #[inline] fn rem_assign( &mut self, other: u128 ) {
                    self.data %= other;
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
            }

            
            impl Rem<BigInt> for u128 {
                type Output = BigInt;

                #[inline] fn rem( self, other: BigInt ) -> BigInt {
                    BigInt::from_biguint( Plus, self % other.data)
                }
            }

            forward_all_scalar_binop_to_val_val!( impl Rem<i32> for BigInt, rem );
            forward_all_scalar_binop_to_val_val!( impl Rem<i64> for BigInt, rem );
            
            forward_all_scalar_binop_to_val_val!( impl Rem<i128> for BigInt, rem );

            impl Rem<i32> for BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: i32 ) -> BigInt {
                    if other >= 0 {
                        self % other as u32
                    } else {
                        self % i32_abs_as_u32( other)
                    }
                }
            }

            impl RemAssign<i32> for BigInt {
                #[inline] fn rem_assign( &mut self, other: i32 ) {
                    if other >= 0 {
                        *self %= other as u32;
                    } else {
                        *self %= i32_abs_as_u32( other );
                    }
                }
            }

            impl Rem<BigInt> for i32 {
                type Output = BigInt;

                #[inline] fn rem( self, other: BigInt ) -> BigInt {
                    if self >= 0 {
                        self as u32 % other
                    } else {
                        -( i32_abs_as_u32( self ) % other)
                    }
                }
            }

            impl Rem<i64> for BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: i64 ) -> BigInt {
                    if other >= 0 {
                        self % other as u64
                    } else {
                        self % i64_abs_as_u64( other)
                    }
                }
            }

            impl RemAssign<i64> for BigInt {
                #[inline] fn rem_assign( &mut self, other: i64 ) {
                    if other >= 0 {
                        *self %= other as u64;
                    } else {
                        *self %= i64_abs_as_u64( other );
                    }
                }
            }

            impl Rem<BigInt> for i64 {
                type Output = BigInt;

                #[inline] fn rem( self, other: BigInt ) -> BigInt {
                    if self >= 0 {
                        self as u64 % other
                    } else {
                        -( i64_abs_as_u64( self ) % other)
                    }
                }
            }

            
            impl Rem<i128> for BigInt {
                type Output = BigInt;

                #[inline] fn rem( self, other: i128 ) -> BigInt {
                    if other >= 0 {
                        self % other as u128
                    } else {
                        self % i128_abs_as_u128( other)
                    }
                }
            }
            
            impl RemAssign<i128> for BigInt {
                #[inline] fn rem_assign( &mut self, other: i128 ) {
                    if other >= 0 {
                        *self %= other as u128;
                    } else {
                        *self %= i128_abs_as_u128( other );
                    }
                }
            }
            
            impl Rem<BigInt> for i128 {
                type Output = BigInt;

                #[inline] fn rem( self, other: BigInt ) -> BigInt {
                    if self >= 0 {
                        self as u128 % other
                    } else {
                        -( i128_abs_as_u128( self ) % other)
                    }
                }
            }

            impl Neg for BigInt {
                type Output = BigInt;

                #[inline] fn neg( mut self ) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }

            impl<'a> Neg for &'a BigInt {
                type Output = BigInt;

                #[inline] fn neg( self ) -> BigInt {
                    -self.clone()
                }
            }

            impl CheckedAdd for BigInt {
                #[inline] fn checked_add( &self, v: &BigInt ) -> Option<BigInt> {
                    Some( self.add( v))
                }
            }

            impl CheckedSub for BigInt {
                #[inline] fn checked_sub( &self, v: &BigInt ) -> Option<BigInt> {
                    Some( self.sub( v))
                }
            }

            impl CheckedMul for BigInt {
                #[inline] fn checked_mul( &self, v: &BigInt ) -> Option<BigInt> {
                    Some( self.mul( v))
                }
            }

            impl CheckedDiv for BigInt {
                #[inline] fn checked_div( &self, v: &BigInt ) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some( self.div( v))
                }
            }

            impl Integer for BigInt
            {
                #[inline] fn div_rem( &self, other: &BigInt ) -> ( BigInt, BigInt )
                {
                    let ( d_ui, r_ui ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from_biguint( self.sign, d_ui );
                    let r = BigInt::from_biguint( self.sign, r_ui );
                    if other.is_negative() {
                        ( -d, r)
                    } else {
                        ( d, r)
                    }
                }

                #[inline] fn div_floor( &self, other: &BigInt ) -> BigInt
                {
                    let ( d, _ ) = self.div_mod_floor( other );
                    d
                }

                #[inline] fn mod_floor( &self, other: &BigInt ) -> BigInt
                {
                    let ( _, m ) = self.div_mod_floor( other );
                    m
                }

                fn div_mod_floor( &self, other: &BigInt ) -> ( BigInt, BigInt )
                {
                    let ( d_ui, m_ui ) = self.data.div_rem( &other.data );
                    let d = BigInt::from_biguint( Plus, d_ui );
                    let m = BigInt::from_biguint( Plus, m_ui );
                    let one: BigInt = One::one();

                    match ( self.sign, other.sign )
                    {
                        ( _, NoSign ) => panic!(),
                        ( Plus, Plus ) | ( NoSign, Plus ) => ( d, m),
                        ( Plus, Minus ) | ( NoSign, Minus ) =>
                        {
                            if m.is_zero() { ( -d, Zero::zero()) }                            
                            else { ( -d - one, m + other) }
                        }

                        ( Minus, Plus ) =>
                        {
                            if m.is_zero() { ( -d, Zero::zero()) }
                            else { ( -d - one, other - m) }
                        }

                        ( Minus, Minus ) => ( d, -m),
                    }
                }
                /// Calculates the Greatest Common Divisor ( GCD ) of the number and `other`.
                #[inline] fn gcd( &self, other: &BigInt ) -> BigInt { BigInt::from_biguint( Plus, self.data.gcd( &other.data)) }
                /// Calculates the Lowest Common Multiple ( LCM ) of the number and `other`.
                #[inline] fn lcm( &self, other: &BigInt ) -> BigInt { BigInt::from_biguint( Plus, self.data.lcm( &other.data)) }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides( &self, other: &BigInt ) -> bool { self.is_multiple_of( other) }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of( &self, other: &BigInt ) -> bool { self.data.is_multiple_of( &other.data) }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even( &self ) -> bool { self.data.is_even() }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd( &self ) -> bool { self.data.is_odd() }
            }

            impl Roots for BigInt
            {
                fn nth_root( &self, n: u32 ) -> Self
                {
                    assert!
                    (
                        !( self.is_negative() && n.is_even()),
                        "root of degree {} is imaginary",
                        n
                    );

                    BigInt::from_biguint( self.sign, self.data.nth_root( n))
                }

                fn sqrt( &self ) -> Self
                {
                    assert!( !self.is_negative(), "square root is imaginary" );
                    BigInt::from_biguint( self.sign, self.data.sqrt())
                }

                fn cbrt( &self ) -> Self { BigInt::from_biguint( self.sign, self.data.cbrt()) }
            }

            impl ToPrimitive for BigInt
            {
                #[inline] fn to_i64( &self ) -> Option<i64>
                {
                    match self.sign
                    {
                        Plus => self.data.to_i64(),
                        NoSign => Some( 0 ),
                        Minus => self.data.to_u64().and_then( |n|
                        {
                            let m: u64 = 1 << 63;
                            if n < m { Some( -( n as i64)) }
                            else if n == m { Some( i64::MIN) }
                            else { None }
                        }),
                    }
                }

                #[inline] fn to_i128( &self ) -> Option<i128>
                {
                    match self.sign
                    {
                        Plus => self.data.to_i128(),
                        NoSign => Some( 0 ),
                        Minus => self.data.to_u128().and_then( |n|
                        {
                            let m: u128 = 1 << 127;

                            if n < m { Some( -( n as i128)) }
                            else if n == m { Some( i128::MIN) }
                            else { None }
                        }),
                    }
                }

                #[inline] fn to_u64( &self ) -> Option<u64>
                {
                    match self.sign
                    {
                        Plus => self.data.to_u64(),
                        NoSign => Some( 0 ),
                        Minus => None,
                    }
                }

                #[inline] fn to_u128( &self ) -> Option<u128>
                {
                    match self.sign
                    {
                        Plus => self.data.to_u128(),
                        NoSign => Some( 0 ),
                        Minus => None,
                    }
                }

                #[inline] fn to_f32( &self ) -> Option<f32>
                { self.data.to_f32().map( |n| if self.sign == Minus { -n } else { n }) }

                #[inline] fn to_f64( &self ) -> Option<f64>
                { self.data.to_f64().map( |n| if self.sign == Minus { -n } else { n }) }
            }

            impl FromPrimitive for BigInt
            {
                #[inline] fn from_i64( n: i64 ) -> Option<BigInt> { Some( BigInt::from( n)) }

                #[inline] fn from_i128( n: i128 ) -> Option<BigInt> { Some( BigInt::from( n)) }

                #[inline] fn from_u64( n: u64 ) -> Option<BigInt> { Some( BigInt::from( n)) }

                #[inline] fn from_u128( n: u128 ) -> Option<BigInt> { Some( BigInt::from( n)) }

                #[inline] fn from_f64( n: f64 ) -> Option<BigInt>
                {
                    if n >= 0.0 { BigUint::from_f64( n).map( |x| BigInt::from_biguint( Plus, x)) }                    
                    else { BigUint::from_f64( -n).map( |x| BigInt::from_biguint( Minus, x)) }
                }
            }

            impl From<i64> for BigInt
            {
                #[inline] fn from( n: i64 ) -> Self
                {
                    if n >= 0 { BigInt::from( n as u64) }

                    else
                    {
                        let u = u64::MAX - ( n as u64 ) + 1;
                        BigInt
                        {
                            sign: Minus,
                            data: BigUint::from( u),
                        }
                    }
                }
            }

            
            impl From<i128> for BigInt
            {
                #[inline] fn from( n: i128 ) -> Self
                {
                    if n >= 0 { BigInt::from( n as u128) }

                    else
                    {
                        let u = u128::MAX - ( n as u128 ) + 1;
                        BigInt
                        {
                            sign: Minus,
                            data: BigUint::from( u),
                        }
                    }
                }
            }

            impl_bigint_from_int!( i8 );
            impl_bigint_from_int!( i16 );
            impl_bigint_from_int!( i32 );
            impl_bigint_from_int!( isize );

            impl From<u64> for BigInt
            {
                #[inline] fn from( n: u64 ) -> Self
                {
                    if n > 0
                    {
                        BigInt
                        {
                            sign: Plus,
                            data: BigUint::from( n),
                        }
                    }
                    else { BigInt::zero() }
                }
            }

            
            impl From<u128> for BigInt
            {
                #[inline] fn from( n: u128 ) -> Self
                {
                    if n > 0
                    {
                        BigInt
                        {
                            sign: Plus,
                            data: BigUint::from( n),
                        }
                    }

                    else { BigInt::zero() }
                }
            }

            impl_bigint_from_uint!( u8 );
            impl_bigint_from_uint!( u16 );
            impl_bigint_from_uint!( u32 );
            impl_bigint_from_uint!( usize );

            impl From<BigUint> for BigInt
            {
                #[inline] fn from( n: BigUint ) -> Self
                {
                    if n.is_zero()
                    {
                        BigInt::zero()
                    }
                    else
                    {
                        BigInt
                        {
                            sign: Plus,
                            data: n,
                        }
                    }
                }
            }

            impl IntDigits for BigInt
            {
                #[inline] fn digits( &self ) -> &[BigDigit] { self.data.digits() }
                #[inline] fn digits_mut( &mut self ) -> &mut Vec<BigDigit> { self.data.digits_mut() }
                #[inline] fn normalize( &mut self )
                {
                    self.data.normalize();
                    if self.data.is_zero() { self.sign = NoSign; }
                }
                #[inline] fn capacity( &self ) -> usize { self.data.capacity() }
                #[inline] fn len( &self ) -> usize { self.data.len() }
            }
            /// A generic trait for converting a value to a `BigInt`.
            pub trait ToBigInt
            {
                /// Converts the value of `self` to a `BigInt`.
                fn to_bigint( &self ) -> Option<BigInt>;
            }

            impl ToBigInt for BigInt
            {
                #[inline] fn to_bigint( &self ) -> Option<BigInt> { Some( self.clone()) }
            }

            impl ToBigInt for BigUint
            {
                #[inline] fn to_bigint( &self ) -> Option<BigInt>
                {
                    if self.is_zero() { Some( Zero::zero()) }

                    else
                    {
                        Some
                        (
                            BigInt
                            {
                                sign: Plus,
                                data: self.clone(),
                            }
                        )
                    }
                }
            }

            impl uint::ToBigUint for BigInt
            {
                #[inline] fn to_biguint( &self ) -> Option<BigUint>
                {
                    match self.sign()
                    {
                        Plus => Some( self.data.clone()),
                        NoSign => Some( Zero::zero()),
                        Minus => None,
                    }
                }
            }

            impl_to_bigint!( isize, FromPrimitive::from_isize );
            impl_to_bigint!( i8, FromPrimitive::from_i8 );
            impl_to_bigint!( i16, FromPrimitive::from_i16 );
            impl_to_bigint!( i32, FromPrimitive::from_i32 );
            impl_to_bigint!( i64, FromPrimitive::from_i64 );
            impl_to_bigint!( i128, FromPrimitive::from_i128 );

            impl_to_bigint!( usize, FromPrimitive::from_usize );
            impl_to_bigint!( u8, FromPrimitive::from_u8 );
            impl_to_bigint!( u16, FromPrimitive::from_u16 );
            impl_to_bigint!( u32, FromPrimitive::from_u32 );
            impl_to_bigint!( u64, FromPrimitive::from_u64 );
            impl_to_bigint!( u128, FromPrimitive::from_u128 );

            impl_to_bigint!( f32, FromPrimitive::from_f32 );
            impl_to_bigint!( f64, FromPrimitive::from_f64 );

            impl BigInt
            {
                /// Creates and initializes a BigInt.
                #[inline] pub fn new( sign: Sign, digits: Vec<u32> ) -> BigInt
                { BigInt::from_biguint( sign, BigUint::new( digits) ) }
                /// Creates and initializes a `BigInt`.
                #[inline] pub fn from_biguint( mut sign: Sign, mut data: BigUint ) -> BigInt
                {
                    if sign == NoSign { data.assign_from_slice( &[] ); }

                    else if data.is_zero() { sign = NoSign; }

                    BigInt
                    {
                        sign: sign,
                        data: data,
                    }
                }
                /// Creates and initializes a `BigInt`.
                #[inline] pub fn from_slice( sign: Sign, slice: &[u32] ) -> BigInt
                { BigInt::from_biguint( sign, BigUint::from_slice( slice) ) }
                /// Reinitializes a `BigInt`.
                #[inline] pub fn assign_from_slice( &mut self, sign: Sign, slice: &[u32])
                {
                    if sign == NoSign
                    {
                        self.data.assign_from_slice( &[] );
                        self.sign = NoSign;
                    }

                    else
                    {
                        self.data.assign_from_slice( slice );
                        self.sign = match self.data.is_zero()
                        {
                            true => NoSign,
                            false => sign,
                        }
                    }
                }
                /// Creates and initializes a `BigInt`.
                #[inline] pub fn from_bytes_be( sign: Sign, bytes: &[u8] ) -> BigInt 
                { BigInt::from_biguint( sign, BigUint::from_bytes_be( bytes ) ) }
                /// Creates and initializes a `BigInt`.
                #[inline] pub fn from_bytes_le( sign: Sign, bytes: &[u8] ) -> BigInt
                { BigInt::from_biguint( sign, BigUint::from_bytes_le( bytes ) ) }
                /// Creates and inits a `BigInt` from an array of bytes in two's complement binary representation.
                #[inline] pub fn from_signed_bytes_be( digits: &[u8] ) -> BigInt
                {
                    let sign = match digits.first()
                    {
                        Some( v ) if *v > 0x7f => Sign::Minus,
                        Some( _ ) => Sign::Plus,
                        None => return BigInt::zero(),
                    };

                    if sign == Sign::Minus
                    {
                        let mut digits = Vec::from( digits );
                        twos_complement_be( &mut digits );
                        BigInt::from_biguint( sign, BigUint::from_bytes_be( &*digits))
                    }
                    else { BigInt::from_biguint( sign, BigUint::from_bytes_be( digits)) }
                }
                /// Creates and initializes a `BigInt` from an array of bytes in two's complement.
                #[inline] pub fn from_signed_bytes_le( digits: &[u8] ) -> BigInt
                {
                    let sign = match digits.last()
                    {
                        Some( v ) if *v > 0x7f => Sign::Minus,
                        Some( _ ) => Sign::Plus,
                        None => return BigInt::zero(),
                    };

                    if sign == Sign::Minus
                    {
                        let mut digits = Vec::from( digits );
                        twos_complement_le( &mut digits );
                        BigInt::from_biguint( sign, BigUint::from_bytes_le( &*digits))
                    }
                    else { BigInt::from_biguint( sign, BigUint::from_bytes_le( digits)) }
                }
                /// Creates and initializes a `BigInt`.
                #[inline] pub fn parse_bytes( buf: &[u8], radix: u32 ) -> Option<BigInt>
                {
                    str::from_utf8( buf)
                    .ok()
                    .and_then( |s| BigInt::from_str_radix( s, radix).ok())
                }
                /// Creates and initializes a `BigInt`.
                pub fn from_radix_be( sign: Sign, buf: &[u8], radix: u32 ) -> Option<BigInt>
                { BigUint::from_radix_be( buf, radix).map( |u| BigInt::from_biguint( sign, u) ) }
                /// Creates and initializes a `BigInt`.
                pub fn from_radix_le( sign: Sign, buf: &[u8], radix: u32 ) -> Option<BigInt>
                { BigUint::from_radix_le( buf, radix).map( |u| BigInt::from_biguint( sign, u) ) }
                /// Returns the sign and the byte representation of the `BigInt` in big-endian byte order.
                #[inline] pub fn to_bytes_be( &self ) -> ( Sign, Vec<u8> ) { ( self.sign, self.data.to_bytes_be() ) }
                /// Returns the sign and the byte representation of the `BigInt` in little-endian byte order.
                #[inline] pub fn to_bytes_le( &self ) -> ( Sign, Vec<u8> ) { ( self.sign, self.data.to_bytes_le() ) }
                /// Returns the sign and the `u32` digits representation
                /// of the `BigInt` ordered least significant digit first.
                #[inline] pub fn to_u32_digits( &self ) -> ( Sign, Vec<u32> ) { ( self.sign, self.data.to_u32_digits() ) }
                /// Returns the two's-complement byte representation of the `BigInt` in big-endian byte order.
                #[inline] pub fn to_signed_bytes_be( &self ) -> Vec<u8>
                {
                    let mut bytes = self.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or( 0 );
                    
                    if first_byte > 0x7f
                    && !( first_byte == 0x80
                    && bytes.iter().skip( 1).all( Zero::is_zero)
                    && self.sign == Sign::Minus)
                    { bytes.insert( 0, 0 ); }

                    if self.sign == Sign::Minus { twos_complement_be( &mut bytes ); }

                    bytes
                }
                /// Returns the two's-complement byte representation of the `BigInt` in little-endian byte order.
                #[inline] pub fn to_signed_bytes_le( &self ) -> Vec<u8>
                {
                    let mut bytes = self.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or( 0 );

                    if last_byte > 0x7f
                    && !( last_byte == 0x80
                    && bytes.iter().rev().skip( 1).all( Zero::is_zero )
                    && self.sign == Sign::Minus )
                    { bytes.push( 0 ); }

                    if self.sign == Sign::Minus { twos_complement_le( &mut bytes ); }

                    bytes
                }
                /// Returns the integer formatted as a string in the given radix.
                #[inline] pub fn to_str_radix( &self, radix: u32 ) -> String
                {
                    let mut v = to_str_radix_reversed( &self.data, radix );

                    if self.is_negative() { v.push( b'-' ); }

                    v.reverse();
                    unsafe { String::from_utf8_unchecked( v ) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be( &self, radix: u32 ) -> ( Sign, Vec<u8>)
                { ( self.sign, self.data.to_radix_be( radix) ) }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le( &self, radix: u32 ) -> ( Sign, Vec<u8>)
                { ( self.sign, self.data.to_radix_le( radix) ) }
                /// Returns the sign of the `BigInt` as a `Sign`.
                #[inline] pub fn sign( &self ) -> Sign { self.sign }
                /// Determines the fewest bits necessary to express the `BigInt`, not including the sign.
                #[inline] pub fn bits( &self ) -> usize { self.data.bits() }
                /// Converts this `BigInt` into a `BigUint`, if it's not negative.
                #[inline] pub fn to_biguint( &self ) -> Option<BigUint>
                {
                    match self.sign
                    {
                        Plus => Some( self.data.clone()),
                        NoSign => Some( Zero::zero()),
                        Minus => None,
                    }
                }

                #[inline] pub fn checked_add( &self, v: &BigInt ) -> Option<BigInt> { Some( self.add( v) ) }

                #[inline] pub fn checked_sub( &self, v: &BigInt ) -> Option<BigInt> { Some( self.sub( v) ) }

                #[inline] pub fn checked_mul( &self, v: &BigInt ) -> Option<BigInt> { Some( self.mul( v) ) }

                #[inline] pub fn checked_div( &self, v: &BigInt ) -> Option<BigInt>
                {
                    if v.is_zero() { return None; }
                    Some( self.div( v))
                }
                /// Returns `( self ^ exponent ) mod modulus`.
                pub fn modpow( &self, exponent: &Self, modulus: &Self ) -> Self
                {
                    assert!( !exponent.is_negative(), "negative exponentiation is not supported!" );
                    assert!( !modulus.is_zero(), "divide by zero!" );

                    let result = self.data.modpow( &exponent.data, &modulus.data );
                    if result.is_zero() { return BigInt::zero(); }
                    
                    let ( sign, mag ) = match ( self.is_negative() && exponent.is_odd(), modulus.is_negative() )
                    {
                        ( false, false ) => ( Plus, result),
                        ( true, false ) => ( Plus, &modulus.data - result),
                        ( false, true ) => ( Minus, &modulus.data - result),
                        ( true, true ) => ( Minus, result),
                    };                    
                    BigInt::from_biguint( sign, mag)
                }
                /// Returns the truncated principal square root of `self`.
                pub fn sqrt( &self ) -> Self { Roots::sqrt( self ) }
                /// Returns the truncated principal cube root of `self`.
                pub fn cbrt( &self ) -> Self { Roots::cbrt( self ) }
                /// Returns the truncated principal `n`th root of `self`.
                pub fn nth_root( &self, n: u32 ) -> Self { Roots::nth_root( self, n ) }
            }

            impl_sum_iter_type!( BigInt );
            impl_product_iter_type!( BigInt );
            /// Perform in-place two's complement of the given binary representation, in little-endian byte order.
            #[inline] fn twos_complement_le( digits: &mut [u8] ) { twos_complement( digits ) }
            /// Perform in-place two's complement of the given binary representation in big-endian byte order.
            #[inline] fn twos_complement_be( digits: &mut [u8] ) { twos_complement( digits.iter_mut().rev() ) }
            /// Perform inplace two complement of the given digit iterator starting from the least significant byte.
            #[inline] fn twos_complement<'a, I>( digits: I ) where
            I: IntoIterator<Item = &'a mut u8>
            {
                let mut carry = true;
                for d in digits
                {
                    *d = d.not();
                    if carry
                    {
                        *d = d.wrapping_add( 1 );
                        carry = d.is_zero();
                    }
                }
            }
        }
        pub use self::int::{ BigInt, Sign, ToBigInt };

        pub mod random
        {
            //! Randomization of big integers
            use ::
            {
                rand::
                {
                    distributions::uniform::{ SampleUniform, UniformSampler },
                    prelude::{ * },
                },
                num::
                {
                    integer::Integer,
                    big::{ BigInt, BigUint, Sign::*, digit::{ self, BigDigit } },
                    traits::Zero,
                },
                *,
            };

            macro_rules! impl_as_byte_slice
            {
                () => {};
                
                ($t:ty) =>
                {
                    impl AsByteSliceMut for [$t]
                    {
                        fn as_byte_slice_mut(&mut self) -> &mut [u8]
                        {
                            unsafe
                            {
                                if self.len() == 0 
                                { slice::from_raw_parts_mut(0x1 as *mut u8, 0) }
                                else 
                                { slice::from_raw_parts_mut(self.as_mut_ptr() as *mut u8, self.len() * mem::size_of::<$t>() ) }

                            }
                        }

                        fn to_le(&mut self)
                        {
                            for x in self
                            {
                                *x = x.to_le();
                            }
                        }
                    }

                    impl AsByteSliceMut for [Wrapping<$t>]
                    {
                        fn as_byte_slice_mut(&mut self) -> &mut [u8]
                        {
                            unsafe
                            {
                                if self.len() == 0
                                { slice::from_raw_parts_mut(0x1 as *mut u8, 0) }
                                else
                                { slice::from_raw_parts_mut(self.as_mut_ptr() as *mut u8, self.len() * mem::size_of::<$t>() ) }
                            }
                        }

                        fn to_le(&mut self)
                        {
                            for x in self
                            {
                                *x = Wrapping(x.0.to_le());
                            }
                        }
                    }
                };

                ($t:ty, $($tt:ty,)*) =>
                {
                    impl_as_byte_slice!($t);
                    impl_as_byte_slice!($($tt,)*);
                }
            }

            macro_rules! impl_as_byte_slice_arrays
            {
                ($n:expr,) => {};
                
                ($n:expr, $N:ident) =>
                {
                    impl<T> AsByteSliceMut for [T; $n] where [T]:
                    AsByteSliceMut
                    {
                        fn as_byte_slice_mut(&mut self) -> &mut [u8] { self[..].as_byte_slice_mut() }
                        fn to_le(&mut self) { self[..].to_le() }
                    }
                };

                ($n:expr, $N:ident, $($NN:ident,)*) =>
                {
                    impl_as_byte_slice_arrays!($n, $N);
                    impl_as_byte_slice_arrays!($n - 1, $($NN,)*);
                };

                (!div $n:expr,) => {};
                
                (!div $n:expr, $N:ident, $($NN:ident,)*) =>
                {
                    impl_as_byte_slice_arrays!($n, $N);
                    impl_as_byte_slice_arrays!(!div $n / 2, $($NN,)*);
                };
            }
            /// Trait for casting types to byte slices
            pub trait AsByteSliceMut
            {
                /// Return a mutable reference to self as a byte slice
                fn as_byte_slice_mut(&mut self) -> &mut [u8];
                /// Call `to_le` on each element (i.e. byte-swap on Big Endian platforms).
                fn to_le(&mut self);
            }

            impl AsByteSliceMut for [u8] 
            {
                fn as_byte_slice_mut(&mut self) -> &mut [u8] { self }

                fn to_le(&mut self) {}
            }

            impl_as_byte_slice!(u16, u32, u64, usize,);
            impl_as_byte_slice!(u128);
            impl_as_byte_slice!(i8, i16, i32, i64, isize,);
            impl_as_byte_slice!(i128);
            impl_as_byte_slice_arrays!(32, N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,);
            impl_as_byte_slice_arrays!(!div 4096, N,N,N,N,N,N,N,);
            /// A trait for sampling random big integers.
            pub trait RandBigInt 
            {
                /// Generate a random `BigUint` of the given bit size.
                fn gen_biguint( &mut self, bit_size: usize ) -> BigUint;
                /// Generate a random BigInt of the given bit size.
                fn gen_bigint( &mut self, bit_size: usize ) -> BigInt;
                /// Generate a random `BigUint` less than the given bound.
                fn gen_biguint_below( &mut self, bound: &BigUint ) -> BigUint;
                /// Generate a random `BigUint` within the given range.
                fn gen_biguint_range( &mut self, lbound: &BigUint, ubound: &BigUint ) -> BigUint;
                /// Generate a random `BigInt` within the given range.
                fn gen_bigint_range( &mut self, lbound: &BigInt, ubound: &BigInt ) -> BigInt;
            }

            impl<R: Rng + ?Sized> RandBigInt for R 
            {
                fn gen_biguint( &mut self, bit_size: usize ) -> BigUint
                {
                    use self::digit::BITS;
                    let ( digits, rem ) = bit_size.div_rem( &BITS );
                    let mut data = vec![BigDigit::default(); digits + ( rem > 0 ) as usize];
                    self.fill_bytes( data[..].as_byte_slice_mut() );
                    data.to_le();

                    if rem > 0 { data[digits] >>= BITS - rem; }

                    BigUint::new( data)
                }

                fn gen_bigint( &mut self, bit_size: usize ) -> BigInt
                {
                    loop
                    {
                        let biguint = self.gen_biguint( bit_size );
                        let sign = if biguint.is_zero()
                        {
                            if self.gen() { continue; }
                            else { NoSign }
                        }

                        else if self.gen() { Plus }
                        
                        else { Minus };

                        return BigInt::from_biguint( sign, biguint );
                    }
                }

                fn gen_biguint_below(&mut self, bound: &BigUint ) -> BigUint
                {
                    assert!(!bound.is_zero());
                    let bits = bound.bits();
                    loop
                    {
                        let n = self.gen_biguint(bits);
                        
                        if n < *bound { return n; }
                    }
                }

                fn gen_biguint_range( &mut self, lbound: &BigUint, ubound: &BigUint ) -> BigUint
                {
                    assert!( *lbound < *ubound );
                    if lbound.is_zero() { self.gen_biguint_below( ubound ) }
                    else { lbound + self.gen_biguint_below( &( ubound - lbound) ) }
                }

                fn gen_bigint_range( &mut self, lbound: &BigInt, ubound: &BigInt ) -> BigInt
                {
                    assert!( *lbound < *ubound );
                    if lbound.is_zero() { BigInt::from( self.gen_biguint_below( magnitude( &ubound)) ) }
                    else if ubound.is_zero() { lbound + BigInt::from( self.gen_biguint_below( magnitude( &lbound)) ) }
                    else
                    {
                        let delta = ubound - lbound;
                        lbound + BigInt::from( self.gen_biguint_below( magnitude( &delta)))
                    }
                }
            }
            /// The back-end implementing rand's `UniformSampler` for `BigUint`.
            #[derive( Clone, Debug )]
            pub struct UniformBigUint
            {
                base: BigUint,
                len: BigUint,
            }

            impl UniformSampler for UniformBigUint
            {
                type X = BigUint;
                #[inline] fn new( low: Self::X, high: Self::X ) -> Self
                {
                    assert!( low < high );
                    UniformBigUint
                    {
                        len: high - &low,
                        base: low,
                    }
                }
                #[inline] fn new_inclusive( low: Self::X, high: Self::X ) -> Self
                {
                    assert!( low <= high );
                    Self::new( low, high + 1u32)
                }
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng: &mut R ) -> Self::X
                { &self.base + rng.gen_biguint_below( &self.len ) }

                #[inline] fn sample_single<R: Rng + ?Sized>( low: Self::X, high: Self::X, rng: &mut R ) -> Self::X
                { rng.gen_biguint_range( &low, &high ) }
            }

            impl SampleUniform for BigUint
            {
                type Sampler = UniformBigUint;
            }
            /// The back-end implementing rand's `UniformSampler` for `BigInt`.
            #[derive( Clone, Debug )]
            pub struct UniformBigInt 
            {
                base: BigInt,
                len: BigUint,
            }

            impl UniformSampler for UniformBigInt
            {
                type X = BigInt;
                #[inline] fn new( low: Self::X, high: Self::X ) -> Self
                {
                    assert!( low < high );
                    UniformBigInt
                    {
                        len: into_magnitude( high - &low),
                        base: low,
                    }
                }
                #[inline] fn new_inclusive( low: Self::X, high: Self::X ) -> Self
                {
                    assert!( low <= high );
                    Self::new( low, high + 1u32)
                }
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng: &mut R ) -> Self::X
                { &self.base + BigInt::from( rng.gen_biguint_below( &self.len) ) }
                #[inline] fn sample_single<R: Rng + ?Sized>( low: Self::X, high: Self::X, rng: &mut R ) -> Self::X
                { rng.gen_bigint_range( &low, &high ) }
            }

            impl SampleUniform for BigInt
            {
                type Sampler = UniformBigInt;
            }
            /// A random distribution for `BigUint` and `BigInt` values of a particular bit size.
            #[derive( Clone, Copy, Debug )]
            pub struct RandomBits
            {
                bits: usize,
            }

            impl RandomBits
            {
                #[inline] pub fn new( bits: usize ) -> RandomBits { RandomBits { bits } }
            }

            impl Distribution<BigUint> for RandomBits
            {
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng: &mut R ) -> BigUint { rng.gen_biguint( self.bits ) }
            }

            impl Distribution<BigInt> for RandomBits
            {
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng: &mut R ) -> BigInt { rng.gen_bigint( self.bits ) }
            }
        }
        pub use self::random::{ RandBigInt, RandomBits, UniformBigInt, UniformBigUint };
        
        pub mod uint
        {
            use ::
            {
                cmp::{ Ordering },
                default::{ Default },
                num::
                {
                    big::
                    {
                        digit::{ self, BigDigit },
                    },
                    integer::{ Integer, Roots },
                    traits::{ self, /*ConstZero,*/ Num, One, Pow, ToPrimitive, Unsigned, Zero },
                },
                *,
            };

            pub use self::
            {
                convert::to_str_radix_reversed,
                iter::{ U32Digits, U64Digits },
            };
            
            pub mod addition
            {
                use ::
                {
                    iter::{ Sum },
                    ops::{ Add, AddAssign },
                    num::
                    {
                        big::
                        {
                            digit::{ self, BigDigit },
                            uint::{ BigUint, IntDigits },
                            UsizePromotion,
                        },
                        traits::{ CheckedAdd },
                    },
                    *,
                };

                /// Add with carry.
                #[inline] fn adc( carry: u8, a: u64, b: u64, out: &mut u64 ) -> u8 
                { unsafe { arch::_addcarry_u64( carry, a, b, out ) } }
                /// Two argument addition of raw slices, `a += b`, returning the carry.
                #[inline] pub fn __add2( a: &mut [BigDigit], b: &[BigDigit] ) -> BigDigit
                {
                    debug_assert!( a.len() >= b.len() );

                    let mut carry = 0;
                    let ( a_lo, a_hi ) = a.split_at_mut( b.len() );

                    for ( a, b ) in a_lo.iter_mut().zip( b)
                    {
                        carry = adc( carry, *a, *b, a );
                    }

                    if carry != 0
                    {
                        for a in a_hi
                        {
                            carry = adc( carry, *a, 0, a );
                            if carry == 0 { break; }
                        }
                    }

                    carry as BigDigit
                }
                /// Two argument addition of raw slices: a += b.
                pub fn add2( a: &mut [BigDigit], b: &[BigDigit])
                {
                    let carry = __add2( a, b );
                    debug_assert!( carry == 0 );
                }

                forward_all_binop_to_val_ref_commutative!( impl Add for BigUint, add );
                forward_val_assign!( impl AddAssign for BigUint, add_assign );

                impl Add<&BigUint> for BigUint
                {
                    type Output = BigUint;
                    fn add( mut self, other: &BigUint ) -> BigUint
                    {
                        self += other;
                        self
                    }
                }

                impl AddAssign<&BigUint> for BigUint
                {
                    #[inline] fn add_assign( &mut self, other: &BigUint)
                    {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len()
                        {
                            let lo_carry = __add2( &mut self.data[..], &other.data[..self_len] );
                            self.data.extend_from_slice( &other.data[self_len..] );
                            __add2( &mut self.data[self_len..], &[lo_carry])
                        }
                        else
                        {
                            __add2( &mut self.data[..], &other.data[..])
                        };
                        
                        if carry != 0 { self.data.push( carry ); }
                    }
                }

                promote_unsigned_scalars!( impl Add for BigUint, add );
                promote_unsigned_scalars_assign!( impl AddAssign for BigUint, add_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u32> for BigUint, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u64> for BigUint, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u128> for BigUint, add );

                impl Add<u32> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn add( mut self, other: u32 ) -> BigUint
                    {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u32> for BigUint
                {
                    #[inline] fn add_assign( &mut self, other: u32)
                    {
                        if other != 0
                        {
                            if self.data.is_empty() { self.data.push( 0 ); }

                            let carry = __add2( &mut self.data, &[other as BigDigit] );

                            if carry != 0 { self.data.push( carry ); }
                        }
                    }
                }

                impl Add<u64> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn add( mut self, other: u64 ) -> BigUint
                    {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u64> for BigUint
                {
                    cfg_digit!
                    ( 
                        #[inline] fn add_assign( &mut self, other: u64)
                        {
                            let ( hi, lo ) = digit::from_doublebigdigit( other );

                            if hi == 0 { *self += lo; }
                            else
                            {
                                while self.data.len() < 2
                                {
                                    self.data.push( 0 );
                                }

                                let carry = __add2( &mut self.data, &[lo, hi] );
                                
                                if carry != 0 { self.data.push( carry ); }
                            }
                        }

                        #[inline] fn add_assign( &mut self, other: u64)
                        {
                            if other != 0
                            {
                                if self.data.is_empty() { self.data.push( 0 ); }

                                let carry = __add2( &mut self.data, &[other as BigDigit] );

                                if carry != 0 { self.data.push( carry ); }
                            }
                        }
                    );
                }

                impl Add<u128> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn add( mut self, other: u128 ) -> BigUint
                    {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u128> for BigUint
                {
                    cfg_digit!
                    ( 
                        #[inline] fn add_assign( &mut self, other: u128)
                        {
                            if other <= u128::from( u64::MAX ) { *self += other as u64 }                            
                            else
                            {
                                let ( a, b, c, d ) = super::u32_from_u128( other );
                                let carry = if a > 0
                                 {
                                    while self.data.len() < 4
                                    {
                                        self.data.push( 0 );
                                    }

                                    __add2( &mut self.data, &[d, c, b, a])
                                }
                                else
                                {
                                    debug_assert!( b > 0 );
                                    while self.data.len() < 3
                                    {
                                        self.data.push( 0 );
                                    }
                                    
                                    __add2( &mut self.data, &[d, c, b])
                                };

                                if carry != 0 { self.data.push( carry ); }
                            }
                        }

                        #[inline] fn add_assign( &mut self, other: u128)
                        {
                            let ( hi, lo ) = digit::from_doublebigdigit( other );
                            if hi == 0 { *self += lo; } 
                            else
                            {
                                while self.data.len() < 2
                                {
                                    self.data.push( 0 );
                                }

                                let carry = __add2( &mut self.data, &[lo, hi] );

                                if carry != 0 { self.data.push( carry ); }
                            }
                        }
                    );
                }

                impl CheckedAdd for BigUint
                {
                    #[inline] fn checked_add( &self, v: &BigUint ) -> Option<BigUint> { Some( self.add( v) ) }
                }

                impl_sum_iter_type!( BigUint );
            }
            /**/
            pub mod arbitrary
            {
                
                use ::
                {
                    boxed::{ Box },
                    num::
                    {
                        big::
                        {
                            digit::{ BigDigit },
                            uint::{ biguint_from_vec, BigUint },
                        },
                    },
                    vec::{ Vec },
                };
                
                impl quickcheck::Arbitrary for BigUint
                {
                    fn arbitrary(g: &mut quickcheck::Gen ) -> Self { biguint_from_vec(Vec::<BigDigit>::arbitrary(g) ) }
                    fn shrink(&self ) -> Box<dyn Iterator<Item = Self>> 
                    { Box::new(self.data.shrink().map(biguint_from_vec) ) }
                }
                
                impl arbitrary::Arbitrary<'_> for BigUint
                {
                    fn arbitrary(u: &mut arbitrary::Unstructured<'_> ) -> arbitrary::Result<Self> 
                    { Ok(biguint_from_vec(Vec::<BigDigit>::arbitrary(u)?) ) }
                    fn arbitrary_take_rest(u: arbitrary::Unstructured<'_> ) -> arbitrary::Result<Self>
                    { Ok(biguint_from_vec(Vec::<BigDigit>::arbitrary_take_rest(u)?) ) }
                    fn size_hint(depth: usize ) -> (usize, Option<usize> ) { Vec::<BigDigit>::size_hint(depth ) }
                }
            }
            /**/
            pub mod bits
            {
                use ::
                {
                    num::
                    {
                        big::{ uint::{ BigUint, IntDigits }, },
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                };

                forward_val_val_binop!(impl BitAnd for BigUint, bitand);
                forward_ref_val_binop!(impl BitAnd for BigUint, bitand);
                
                impl BitAnd<&BigUint> for &BigUint
                {
                    type Output = BigUint;
                    #[inline] fn bitand(self, other: &BigUint ) -> BigUint
                    {
                        if self.data.len() <= other.data.len() { self.clone() & other } else { other.clone() & self }
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigUint, bitand_assign);

                impl BitAnd<&BigUint> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn bitand(mut self, other: &BigUint ) -> BigUint
                    {
                        self &= other;
                        self
                    }
                }

                impl BitAndAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitand_assign(&mut self, other: &BigUint)
                    {
                        for (ai, &bi ) in self.data.iter_mut().zip(other.data.iter() ) {
                            *ai &= bi;
                        }
                        self.data.truncate(other.data.len());
                        self.normalize();
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitOr for BigUint, bitor);
                forward_val_assign!(impl BitOrAssign for BigUint, bitor_assign);

                impl BitOr<&BigUint> for BigUint
                {
                    type Output = BigUint;
                    fn bitor(mut self, other: &BigUint ) -> BigUint
                    {
                        self |= other;
                        self
                    }
                }

                impl BitOrAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitor_assign(&mut self, other: &BigUint)
                    {
                        for (ai, &bi ) in self.data.iter_mut().zip(other.data.iter() ) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigUint, bitxor);
                forward_val_assign!(impl BitXorAssign for BigUint, bitxor_assign);

                impl BitXor<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn bitxor(mut self, other: &BigUint ) -> BigUint {
                        self ^= other;
                        self
                    }
                }

                impl BitXorAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitxor_assign(&mut self, other: &BigUint ) {
                        for (ai, &bi ) in self.data.iter_mut().zip(other.data.iter() ) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                        self.normalize();
                    }
                }
            }
            /**/
            pub mod convert
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    convert::{ TryFrom },
                    num::
                    {
                        big::
                        {
                            digit::{ self, BigDigit },
                            uint::
                            {
                                addition::{ add2 },
                                division::{ div_rem_digit, FAST_DIV_WIDE },
                                multiplication::mac_with_carry,
                                biguint_from_vec, BigUint, ToBigUint
                            },
                            ParseBigIntError, TryFromBigIntError,
                        },
                        integer::{ Integer, Roots },
                        traits::{ float::FloatCore, FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero },
                    },
                    str::{ FromStr },
                    vec::{ Vec },
                    *,
                };

                macro_rules! impl_biguint_from_uint {
                    ($T:ty ) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from(n: $T ) -> Self {
                                BigUint::from(n as u64)
                            }
                        }
                    };
                }

                macro_rules! impl_try_from_biguint {
                    ($T:ty, $to_ty:path ) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigUint ) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from(value: BigUint ) -> Result<$T, TryFromBigIntError<BigUint>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }
                /// Find last set bit: fls(0 ) == 0, fls(u32::MAX ) == 32
                fn fls<T: PrimInt>(v: T ) -> u8 { mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8 }

                fn ilog2<T: PrimInt>(v: T ) -> u8 { fls(v ) - 1 }

                impl FromStr for BigUint
                {
                    type Err = ParseBigIntError;
                    #[inline] fn from_str(s: &str ) -> Result<BigUint, ParseBigIntError>
                    { BigUint::from_str_radix(s, 10 ) }
                }
                
                pub fn from_bitwise_digits_le(v: &[u8], bits: u8 ) -> BigUint
                {
                    debug_assert!(!v.is_empty() && bits <= 8 && digit::BITS % bits == 0 );
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c ) < (1 << bits)));

                    let digits_per_big_digit = digit::BITS / bits;

                    let data = v
                        .chunks(digits_per_big_digit.into())
                        .map(|chunk| {
                            chunk
                                .iter()
                                .rev()
                                .fold(0, |acc, &c| (acc << bits ) | BigDigit::from(c))
                        })
                        .collect();

                    biguint_from_vec(data)
                }
                
                fn from_inexact_bitwise_digits_le(v: &[u8], bits: u8 ) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && bits <= 8 && digit::BITS % bits != 0 );
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c ) < (1 << bits)));

                    let total_bits = (v.len() as u64).saturating_mul(bits.into());
                    let big_digits = Integer::div_ceil(&total_bits, &digit::BITS.into())
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut data = Vec::with_capacity(big_digits);

                    let mut d = 0;
                    let mut dbits = 0;
                    
                    for &c in v {
                        d |= BigDigit::from(c ) << dbits;
                        dbits += bits;

                        if dbits >= digit::BITS {
                            data.push(d);
                            dbits -= digit::BITS;
                            d = BigDigit::from(c ) >> (bits - dbits);
                        }
                    }

                    if dbits > 0 {
                        debug_assert!(dbits < digit::BITS );
                        data.push(d as BigDigit);
                    }

                    biguint_from_vec(data)
                }
                
                fn from_radix_digits_be(v: &[u8], radix: u32 ) -> BigUint 
                {
                    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
                    debug_assert!(v.iter().all(|&c| u32::from(c ) < radix));
                    
                    let big_digits = 
                    {
                        let radix_log2 = f64::from(radix).log2();
                        let bits = radix_log2 * v.len() as f64;
                        (bits / digit::BITS as f64).ceil()
                    };

                    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0 ));

                    let (base, power ) = get_radix_base(radix);
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let (head, tail ) = v.split_at(i);

                    let first = head
                        .iter()
                        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                    data.push(first);

                    debug_assert!(tail.len() % power == 0 );
                    for chunk in tail.chunks(power ) {
                        if data.last() != Some(&0 ) {
                            data.push(0 );
                        }

                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry(0, *d, base, &mut carry);
                        }
                        debug_assert!(carry == 0 );

                        let n = chunk
                            .iter()
                            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                        add2(&mut data, &[n]);
                    }

                    biguint_from_vec(data)
                }

                pub fn from_radix_be(buf: &[u8], radix: u32 ) -> Option<BigUint> 
                {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8 ) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                        // Powers of two can use bitwise masks and shifting instead of multiplication
                        let bits = ilog2(radix);
                        let mut v = Vec::from(buf);
                        v.reverse();
                        if digit::BITS % bits == 0 {
                            from_bitwise_digits_le(&v, bits)
                        } else {
                            from_inexact_bitwise_digits_le(&v, bits)
                        }
                    } else {
                        from_radix_digits_be(buf, radix)
                    };

                    Some(res)
                }

                pub fn from_radix_le(buf: &[u8], radix: u32 ) -> Option<BigUint> 
                {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8 ) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                        // Powers of two can use bitwise masks and shifting instead of multiplication
                        let bits = ilog2(radix);
                        if digit::BITS % bits == 0 {
                            from_bitwise_digits_le(buf, bits)
                        } else {
                            from_inexact_bitwise_digits_le(buf, bits)
                        }
                    } else {
                        let mut v = Vec::from(buf);
                        v.reverse();
                        from_radix_digits_be(&v, radix)
                    };

                    Some(res)
                }

                impl Num for BigUint 
                {
                    type FromStrRadixErr = ParseBigIntError;
                    /// Creates and initializes a `BigUint`.
                    fn from_str_radix(s: &str, radix: u32 ) -> Result<BigUint, ParseBigIntError> {
                        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
                        let mut s = s;
                        if let Some(tail ) = s.strip_prefix('+' ) {
                            if !tail.starts_with('+' ) {
                                s = tail
                            }
                        }

                        if s.is_empty() {
                            return Err(ParseBigIntError::empty());
                        }

                        if s.starts_with('_' ) {
                            // Must lead with a real digit!
                            return Err(ParseBigIntError::invalid());
                        }

                        // First normalize all characters to plain digit values
                        let mut v = Vec::with_capacity(s.len());
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push(d);
                            } else {
                                return Err(ParseBigIntError::invalid());
                            }
                        }

                        let res = if radix.is_power_of_two() {
                            // Powers of two can use bitwise masks and shifting instead of multiplication
                            let bits = ilog2(radix);
                            v.reverse();
                            if digit::BITS % bits == 0 {
                                from_bitwise_digits_le(&v, bits)
                            } else {
                                from_inexact_bitwise_digits_le(&v, bits)
                            }
                        } else {
                            from_radix_digits_be(&v, radix)
                        };
                        Ok(res)
                    }
                }

                fn high_bits_to_u64(v: &BigUint ) -> u64 
                {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                            #[allow(clippy::useless_conversion)]
                            let v0 = u64::from(v.data[0]);
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = (bits - 1 ) % u64::from(digit::BITS ) + 1;
                                let bits_want = Ord::min(64 - ret_bits, digit_bits);

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                    // XXX Conversion is useless if already 64-bit.
                                    #[allow(clippy::useless_conversion)]
                                    let d0 = u64::from(*d ) >> (digit_bits - bits_want);
                                    ret |= d0;
                                }

                                // Implement round-to-odd: If any lower bits are 1, set LSB to 1
                                // so that rounding again to floating point value using
                                // nearest-ties-to-even is correct.
                                //
                                // See: https://en.wikipedia.org/wiki/Rounding#Rounding_to_prepare_for_shorter_precision

                                if digit_bits - bits_want != 0 {
                                    // XXX Conversion is useless if already 64-bit.
                                    #[allow(clippy::useless_conversion)]
                                    let masked = u64::from(*d ) << (64 - (digit_bits - bits_want ) as u32);
                                    ret |= (masked != 0 ) as u64;
                                }

                                ret_bits += bits_want;
                                bits -= bits_want;
                            }

                            ret
                        }
                    }
                }

                impl ToPrimitive for BigUint 
                {
                    #[inline] fn to_i64(&self ) -> Option<i64> {
                        self.to_u64().as_ref().and_then(u64::to_i64)
                    }

                    #[inline] fn to_i128(&self ) -> Option<i128> {
                        self.to_u128().as_ref().and_then(u128::to_i128)
                    }

                    #[allow(clippy::useless_conversion)]
                    #[inline] fn to_u64(&self ) -> Option<u64> {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }

                            // XXX Conversion is useless if already 64-bit.
                            ret += u64::from(*i ) << bits;
                            bits += digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline] fn to_u128(&self ) -> Option<u128> {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }

                            ret |= u128::from(*i ) << bits;
                            bits += digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline] fn to_f32(&self ) -> Option<f32> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f32::MAX_EXP as u64 {
                            Some(f32::INFINITY)
                        } else {
                            Some((mantissa as f32 ) * 2.0f32.powi(exponent as i32))
                        }
                    }

                    #[inline] fn to_f64(&self ) -> Option<f64> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f64::MAX_EXP as u64 {
                            Some(f64::INFINITY)
                        } else {
                            Some((mantissa as f64 ) * 2.0f64.powi(exponent as i32))
                        }
                    }
                }

                impl_try_from_biguint!(u8, ToPrimitive::to_u8);
                impl_try_from_biguint!(u16, ToPrimitive::to_u16);
                impl_try_from_biguint!(u32, ToPrimitive::to_u32);
                impl_try_from_biguint!(u64, ToPrimitive::to_u64);
                impl_try_from_biguint!(usize, ToPrimitive::to_usize);
                impl_try_from_biguint!(u128, ToPrimitive::to_u128);

                impl_try_from_biguint!(i8, ToPrimitive::to_i8);
                impl_try_from_biguint!(i16, ToPrimitive::to_i16);
                impl_try_from_biguint!(i32, ToPrimitive::to_i32);
                impl_try_from_biguint!(i64, ToPrimitive::to_i64);
                impl_try_from_biguint!(isize, ToPrimitive::to_isize);
                impl_try_from_biguint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigUint 
                {
                    #[inline] fn from_i64(n: i64 ) -> Option<BigUint> {
                        if n >= 0 {
                            Some(BigUint::from(n as u64))
                        } else {
                            None
                        }
                    }

                    #[inline] fn from_i128(n: i128 ) -> Option<BigUint> {
                        if n >= 0 {
                            Some(BigUint::from(n as u128))
                        } else {
                            None
                        }
                    }

                    #[inline] fn from_u64(n: u64 ) -> Option<BigUint> {
                        Some(BigUint::from(n))
                    }

                    #[inline] fn from_u128(n: u128 ) -> Option<BigUint> {
                        Some(BigUint::from(n))
                    }

                    #[inline] fn from_f64(mut n: f64 ) -> Option<BigUint> {
                        // handle NAN, INFINITY, NEG_INFINITY
                        if !n.is_finite() {
                            return None;
                        }

                        // match the rounding of casting from float to int
                        n = n.trunc();

                        // handle 0.x, -0.x
                        if n.is_zero() {
                            return Some(Self::ZERO);
                        }

                        let (mantissa, exponent, sign ) = FloatCore::integer_decode(n);

                        if sign == -1 {
                            return None;
                        }

                        let mut ret = BigUint::from(mantissa);
                        match exponent.cmp(&0 ) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= (-exponent ) as usize,
                        }
                        Some(ret)
                    }
                }

                impl From<u64> for BigUint 
                {
                    #[inline] fn from(mut n: u64 ) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n = (n >> 1 ) >> (digit::BITS - 1);
                        }

                        ret
                    }
                }

                impl From<u128> for BigUint 
                {
                    #[inline] fn from(mut n: u128 ) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n >>= digit::BITS;
                        }

                        ret
                    }
                }

                impl_biguint_from_uint!(u8);
                impl_biguint_from_uint!(u16);
                impl_biguint_from_uint!(u32);
                impl_biguint_from_uint!(usize);

                macro_rules! impl_biguint_try_from_int 
                {
                    ($T:ty, $from_ty:path ) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: $T ) -> Result<BigUint, TryFromBigIntError<()>> {
                                $from_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }
                    };
                }

                impl_biguint_try_from_int!(i8, FromPrimitive::from_i8);
                impl_biguint_try_from_int!(i16, FromPrimitive::from_i16);
                impl_biguint_try_from_int!(i32, FromPrimitive::from_i32);
                impl_biguint_try_from_int!(i64, FromPrimitive::from_i64);
                impl_biguint_try_from_int!(isize, FromPrimitive::from_isize);
                impl_biguint_try_from_int!(i128, FromPrimitive::from_i128);

                impl ToBigUint for BigUint 
                {
                    #[inline] fn to_biguint(&self ) -> Option<BigUint> {
                        Some(self.clone())
                    }
                }

                macro_rules! impl_to_biguint 
                {
                    ($T:ty, $from_ty:path ) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint(&self ) -> Option<BigUint> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_biguint!(isize, FromPrimitive::from_isize);
                impl_to_biguint!(i8, FromPrimitive::from_i8);
                impl_to_biguint!(i16, FromPrimitive::from_i16);
                impl_to_biguint!(i32, FromPrimitive::from_i32);
                impl_to_biguint!(i64, FromPrimitive::from_i64);
                impl_to_biguint!(i128, FromPrimitive::from_i128);

                impl_to_biguint!(usize, FromPrimitive::from_usize);
                impl_to_biguint!(u8, FromPrimitive::from_u8);
                impl_to_biguint!(u16, FromPrimitive::from_u16);
                impl_to_biguint!(u32, FromPrimitive::from_u32);
                impl_to_biguint!(u64, FromPrimitive::from_u64);
                impl_to_biguint!(u128, FromPrimitive::from_u128);

                impl_to_biguint!(f32, FromPrimitive::from_f32);
                impl_to_biguint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigUint 
                {
                    fn from(x: bool ) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }
                
                pub fn to_bitwise_digits_le(u: &BigUint, bits: u8 ) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && bits <= 8 && digit::BITS % bits == 0 );

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = (1 << bits ) - 1;
                    let digits_per_big_digit = digit::BITS / bits;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push((r & mask ) as u8);
                            r >>= bits;
                        }
                    }

                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push((r & mask ) as u8);
                        r >>= bits;
                    }

                    res
                }
                
                fn to_inexact_bitwise_digits_le(u: &BigUint, bits: u8 ) -> Vec<u8>
                {
                    debug_assert!(!u.is_zero() && bits <= 8 && digit::BITS % bits != 0 );

                    let mask: BigDigit = (1 << bits ) - 1;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += digit::BITS;

                        while rbits >= bits {
                            res.push((r & mask ) as u8);
                            r >>= bits;
                            
                            if rbits > digit::BITS {
                                r = *c >> (digit::BITS - (rbits - bits));
                            }

                            rbits -= bits;
                        }
                    }

                    if rbits != 0 {
                        res.push(r as u8);
                    }

                    while let Some(&0 ) = res.last() {
                        res.pop();
                    }

                    res
                }
                
                #[inline(always)] pub fn to_radix_digits_le(u: &BigUint, radix: u32 ) -> Vec<u8> 
                {
                    debug_assert!(!u.is_zero() && !radix.is_power_of_two());
                    
                    let radix_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        ((u.bits() as f64 ) / radix_log2).ceil()
                    };
                    
                    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0 ));
                    let mut digits = u.clone();
                    
                    let (base, power ) = if FAST_DIV_WIDE {
                        get_radix_base(radix)
                    } else {
                        get_half_radix_base(radix)
                    };
                    let radix = radix as BigDigit;
                    
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from(base);
                        let mut big_power = 1usize;

                        // Choose a target base length near √n.
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }

                        // This outer loop will run approximately √n times.
                        while digits > big_base {
                            // This is still the dominating factor, with n digits divided by √n digits.
                            let (q, mut big_r ) = digits.div_rem(&big_base);
                            digits = q;

                            // This inner loop now has O(√n²)=O(n ) behavior altogether.
                            for _ in 0..big_power {
                                let (q, mut r ) = div_rem_digit(big_r, base);
                                big_r = q;
                                for _ in 0..power {
                                    res.push((r % radix ) as u8);
                                    r /= radix;
                                }
                            }
                        }
                    }

                    while digits.data.len() > 1 {
                        let (q, mut r ) = div_rem_digit(digits, base);
                        for _ in 0..power {
                            res.push((r % radix ) as u8);
                            r /= radix;
                        }
                        digits = q;
                    }

                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push((r % radix ) as u8);
                        r /= radix;
                    }

                    res
                }

                pub fn to_radix_le(u: &BigUint, radix: u32 ) -> Vec<u8>
                {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                        let bits = ilog2(radix);
                        if digit::BITS % bits == 0 {
                            to_bitwise_digits_le(u, bits)
                        } else {
                            to_inexact_bitwise_digits_le(u, bits)
                        }
                    } else if radix == 10 {
                        to_radix_digits_le(u, 10 )
                    } else {
                        to_radix_digits_le(u, radix)
                    }
                }

                pub fn to_str_radix_reversed(u: &BigUint, radix: u32 ) -> Vec<u8>
                {
                    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");

                    if u.is_zero() {
                        return vec![b'0'];
                    }

                    let mut res = to_radix_le(u, radix);
                    
                    for r in &mut res {
                        debug_assert!(u32::from(*r ) < radix);
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }
                /// Returns the greatest power of the radix for the `BigDigit` bit size
                #[inline] fn get_radix_base(radix: u32 ) -> (BigDigit, usize )
                {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(digit::MAX);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }
                /// Returns the greatest power of the radix for half the `BigDigit` bit size
                #[inline] fn get_half_radix_base(radix: u32 ) -> (BigDigit, usize )
                {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(digit::HALF);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }
                /// Generate tables of the greatest power of each radix that is less that the given maximum.
                const fn generate_radix_bases(max: BigDigit ) -> [(BigDigit, usize); 257]
                {
                    let mut bases = [(0, 0 ); 257];
                    let mut radix: BigDigit = 3;
                    while radix < 256 
                    {
                        if !radix.is_power_of_two() 
                        {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some(b ) = base.checked_mul(radix )
                            {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = (base, power)
                        }
                        radix += 1;
                    }

                    bases
                }
            }
            /**/
            pub mod division
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::
                    {
                        big::
                        {
                            digit::{ self, BigDigit, DoubleBigDigit, HALF, HALF_BITS },
                            uint::{ addition::__add2, cmp_slice, BigUint },
                            UsizePromotion,
                        },
                        integer::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };
                

                pub const FAST_DIV_WIDE: bool = true;
                /// x86 and x86_64 can use a real `div` instruction.
                #[inline] fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit ) -> (BigDigit, BigDigit)
                {
                    debug_assert!(hi < divisor);
                    unsafe
                    {
                        let (div, rem);

                        cfg_digit!(
                            macro_rules! div {
                                () => {
                                    "div {0:e}"
                                };
                            }
                            macro_rules! div {
                                () => {
                                    "div {0:r}"
                                };
                            }
                        );

                        core::arch::asm!(
                            div!(),
                            in(reg ) divisor,
                            inout("dx" ) hi => rem,
                            inout("ax" ) lo => div,
                            options(pure, nomem, nostack),
                        );

                        (div, rem)
                    }
                }
                /// For small divisors, we can divide without promoting to `DoubleBigDigit` by
                /// using half-size pieces of digit, like long-division.
                #[inline] fn div_half(rem: BigDigit, digit: BigDigit, divisor: BigDigit ) -> (BigDigit, BigDigit)
                {
                    debug_assert!(rem < divisor && divisor <= HALF);
                    let (hi, rem ) = ((rem << HALF_BITS ) | (digit >> HALF_BITS )).div_rem(&divisor);
                    let (lo, rem ) = ((rem << HALF_BITS ) | (digit & HALF)).div_rem(&divisor);
                    ((hi << HALF_BITS ) | lo, rem)
                }

                #[inline] pub fn div_rem_digit(mut a: BigUint, b: BigDigit ) -> (BigUint, BigDigit)
                {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let (q, r ) = div_half(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let (q, r ) = div_wide(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    }

                    (a.normalized(), rem)
                }

                #[inline] fn rem_digit(a: &BigUint, b: BigDigit ) -> BigDigit
                {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let (_, r ) = div_half(rem, digit, b);
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let (_, r ) = div_wide(rem, digit, b);
                            rem = r;
                        }
                    }

                    rem
                }
                /// Subtract a multiple: a -= b * c.
                fn sub_mul_digit_same_len(a: &mut [BigDigit], b: &[BigDigit], c: BigDigit ) -> BigDigit
                {
                    debug_assert!(a.len() == b.len());
                    let mut offset_carry = digit::MAX;

                    for (x, y ) in a.iter_mut().zip(b ) 
                    {
                        let offset_sum = digit::to_doublebigdigit(digit::MAX, *x)
                            - digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let (new_offset_carry, new_x ) = digit::from_doublebigdigit(offset_sum);
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }
                    
                    digit::MAX - offset_carry
                }

                fn div_rem(mut u: BigUint, mut d: BigUint ) -> (BigUint, BigUint ) 
                {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u, BigUint::ZERO);
                        }
                        let (div, rem ) = div_rem_digit(u, d.data[0]);
                        // reuse d
                        d.data.clear();
                        d += rem;
                        return (div, d);
                    }

                    // Required or the q_len calculation below can underflow:
                    match u.cmp(&d ) {
                        Less => return (BigUint::ZERO, u),
                        Equal => {
                            u.set_one();
                            return (u, BigUint::ZERO);
                        }
                        Greater => {} // Do nothing
                    }
                    
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                        // no need to clone d
                        div_rem_core(u, &d.data)
                    } else {
                        let (q, r ) = div_rem_core(u << shift, &(d << shift).data);
                        (q, r >> shift)
                    }
                }

                pub fn div_rem_ref(u: &BigUint, d: &BigUint ) -> (BigUint, BigUint ) 
                {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u.clone(), BigUint::ZERO);
                        }

                        let (div, rem ) = div_rem_digit(u.clone(), d.data[0]);
                        return (div, rem.into());
                    }

                    // Required or the q_len calculation below can underflow:
                    match u.cmp(d ) {
                        Less => return (BigUint::ZERO, u.clone()),
                        Equal => return (One::one(), BigUint::ZERO),
                        Greater => {} // Do nothing
                    }

                    // This algorithm is from Knuth, TAOCP vol 2 section 4.3, algorithm D:
                    //
                    // First, normalize the arguments so the highest bit in the highest digit of the divisor is
                    // set: the main loop uses the highest digit of the divisor for generating guesses, so we
                    // want it to be the largest number we can efficiently divide by.
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                        // no need to clone d
                        div_rem_core(u.clone(), &d.data)
                    } else {
                        let (q, r ) = div_rem_core(u << shift, &(d << shift).data);
                        // renormalize the remainder
                        (q, r >> shift)
                    }
                }

                /// An implementation of the base division algorithm.
                fn div_rem_core(mut a: BigUint, b: &[BigDigit] ) -> (BigUint, BigUint ) 
                {
                    debug_assert!(a.data.len() >= b.len() && b.len() > 1);
                    debug_assert!(b.last().unwrap().leading_zeros() == 0 );
                    let mut a0 = 0;
                    
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in (0..q_len).rev() {
                        debug_assert!(a.data.len() == b.len() + j);

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];
                        
                        let (mut q0, mut r ) = if a0 < b0 {
                            let (q0, r ) = div_wide(a0, a1, b0 );
                            (q0, r as DoubleBigDigit)
                        } else {
                            debug_assert!(a0 == b0 );
                            (digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit)
                        };
                        
                        while r <= digit::MAX as DoubleBigDigit
                        && digit::to_doublebigdigit(r as BigDigit, a2)
                        < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }
                        
                        let mut borrow = sub_mul_digit_same_len(&mut a.data[j..], b, q0 );
                        if borrow > a0 {
                            q0 -= 1;
                            borrow -= __add2(&mut a.data[j..], b);
                        }
                        
                        debug_assert!(borrow == a0 );

                        q.data[j] = q0;
                        
                        a0 = a.data.pop().unwrap();
                    }

                    a.data.push(a0 );
                    a.normalize();

                    debug_assert_eq!(cmp_slice(&a.data, b), Less);

                    (q.normalized(), a)
                }

                forward_val_ref_binop!(impl Div for BigUint, div);
                forward_ref_val_binop!(impl Div for BigUint, div);
                forward_val_assign!(impl DivAssign for BigUint, div_assign);

                impl Div<BigUint> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn div(self, other: BigUint ) -> BigUint 
                    {
                        let (q, _ ) = div_rem(self, other);
                        q
                    }
                }

                impl Div<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline] fn div(self, other: &BigUint ) -> BigUint 
                    {
                        let (q, _ ) = self.div_rem(other);
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint 
                {
                    #[inline] fn div_assign(&mut self, other: &BigUint ) 
                    {
                        *self = &*self / other;
                    }
                }

                promote_unsigned_scalars!(impl Div for BigUint, div);
                promote_unsigned_scalars_assign!(impl DivAssign for BigUint, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigUint, div);

                impl Div<u32> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u32 ) -> BigUint 
                    {
                        let (q, _ ) = div_rem_digit(self, other as BigDigit);
                        q
                    }
                }
                impl DivAssign<u32> for BigUint 
                {
                    #[inline] fn div_assign(&mut self, other: u32 ) 
                    {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u32 
                {
                    type Output = BigUint;

                    #[inline] fn div(self, other: BigUint ) -> BigUint 
                    {
                        match other.data.len() {
                            0 => panic!("attempt to divide by zero"),
                            1 => From::from(self as BigDigit / other.data[0]),
                            _ => BigUint::ZERO,
                        }
                    }
                }

                impl Div<u64> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u64 ) -> BigUint 
                    {
                        let (q, _ ) = div_rem(self, From::from(other));
                        q
                    }
                }
                impl DivAssign<u64> for BigUint {
                    #[inline] fn div_assign(&mut self, other: u64 ) 
                    {
                        // a vec of size 0 does not allocate, so this is fairly cheap
                        let temp = mem::replace(self, Self::ZERO);
                        *self = temp / other;
                    }
                }

                impl Div<BigUint> for u64 
                {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn div(self, other: BigUint ) -> BigUint 
                        {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u64::from(other.data[0])),
                                2 => From::from(self / digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div(self, other: BigUint ) -> BigUint 
                        {
                            match other.data.len() 
                            {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0]),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                impl Div<u128> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn div(self, other: u128 ) -> BigUint 
                    {
                        let (q, _ ) = div_rem(self, From::from(other));
                        q
                    }
                }

                impl DivAssign<u128> for BigUint 
                {
                    #[inline] fn div_assign(&mut self, other: u128 ) 
                    {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u128 
                {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn div(self, other: BigUint ) -> BigUint 
                        {
                            use super::u32_to_u128;
                            match other.data.len() 
                            {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u128::from(other.data[0])),
                                2 => From::from(
                                    self / u128::from(digit::to_doublebigdigit(other.data[1], other.data[0])),
                                ),
                                3 => From::from(self / u32_to_u128(0, other.data[2], other.data[1], other.data[0])),
                                4 => From::from(
                                    self / u32_to_u128(other.data[3], other.data[2], other.data[1], other.data[0]),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div(self, other: BigUint ) -> BigUint 
                        {
                            match other.data.len() 
                            {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0] as u128),
                                2 => From::from(self / digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                forward_val_ref_binop!(impl Rem for BigUint, rem);
                forward_ref_val_binop!(impl Rem for BigUint, rem);
                forward_val_assign!(impl RemAssign for BigUint, rem_assign);

                impl Rem<BigUint> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: BigUint ) -> BigUint 
                    {
                        if let Some(other ) = other.to_u32() 
                        {
                            &self % other
                        } else 
                        {
                            let (_, r ) = div_rem(self, other);
                            r
                        }
                    }
                }

                impl Rem<&BigUint> for &BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: &BigUint ) -> BigUint 
                    {
                        if let Some(other ) = other.to_u32() 
                        {
                            self % other
                        } else 
                        {
                            let (_, r ) = self.div_rem(other);
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint 
                {
                    #[inline] fn rem_assign(&mut self, other: &BigUint ) 
                    {
                        *self = &*self % other;
                    }
                }

                promote_unsigned_scalars!(impl Rem for BigUint, rem);
                promote_unsigned_scalars_assign!(impl RemAssign for BigUint, rem_assign);
                forward_all_scalar_binop_to_ref_val!(impl Rem<u32> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigUint, rem);

                impl Rem<u32> for &BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u32 ) -> BigUint 
                    {
                        rem_digit(self, other as BigDigit).into()
                    }
                }
                impl RemAssign<u32> for BigUint 
                {
                    #[inline] fn rem_assign(&mut self, other: u32 ) 
                    {
                        *self = &*self % other;
                    }
                }

                impl Rem<&BigUint> for u32 
                {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: &BigUint ) -> BigUint 
                    {
                        self %= other;
                        From::from(self)
                    }
                }

                macro_rules! impl_rem_assign_scalar 
                {
                    ($scalar:ty, $to_scalar:ident ) => 
                    {
                        forward_val_assign_scalar!(impl RemAssign for BigUint, $scalar, rem_assign);
                        impl RemAssign<&BigUint> for $scalar 
                        {
                            #[inline]
                            fn rem_assign(&mut self, other: &BigUint ) 
                            {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some(0 ) => panic!("attempt to divide by zero"),
                                    Some(v ) => *self % v
                                };
                            }
                        }
                    }
                }

                // we can scalar %= BigUint for any scalar, including signed types
                impl_rem_assign_scalar!(u128, to_u128);
                impl_rem_assign_scalar!(usize, to_usize);
                impl_rem_assign_scalar!(u64, to_u64);
                impl_rem_assign_scalar!(u32, to_u32);
                impl_rem_assign_scalar!(u16, to_u16);
                impl_rem_assign_scalar!(u8, to_u8);
                impl_rem_assign_scalar!(i128, to_i128);
                impl_rem_assign_scalar!(isize, to_isize);
                impl_rem_assign_scalar!(i64, to_i64);
                impl_rem_assign_scalar!(i32, to_i32);
                impl_rem_assign_scalar!(i16, to_i16);
                impl_rem_assign_scalar!(i8, to_i8);

                impl Rem<u64> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u64 ) -> BigUint 
                    {
                        let (_, r ) = div_rem(self, From::from(other));
                        r
                    }
                }
                impl RemAssign<u64> for BigUint 
                {
                    #[inline] fn rem_assign(&mut self, other: u64 ) 
                    {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u64 
                {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: BigUint ) -> BigUint 
                    {
                        self %= other;
                        From::from(self)
                    }
                }

                impl Rem<u128> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn rem(self, other: u128 ) -> BigUint 
                    {
                        let (_, r ) = div_rem(self, From::from(other));
                        r
                    }
                }

                impl RemAssign<u128> for BigUint 
                {
                    #[inline] fn rem_assign(&mut self, other: u128 ) 
                    {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u128 
                {
                    type Output = BigUint;

                    #[inline] fn rem(mut self, other: BigUint ) -> BigUint 
                    {
                        self %= other;
                        From::from(self)
                    }
                }

                impl CheckedDiv for BigUint 
                {
                    #[inline] fn checked_div(&self, v: &BigUint ) -> Option<BigUint> 
                    {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigUint 
                {
                    #[inline] fn checked_div_euclid(&self, v: &BigUint ) -> Option<BigUint> 
                    {
                        if v.is_zero() 
                        {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline] fn checked_rem_euclid(&self, v: &BigUint ) -> Option<BigUint> 
                    {
                        if v.is_zero() 
                        {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self ) -> Option<(Self, Self)> 
                    {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigUint 
                {
                    #[inline] fn div_euclid(&self, v: &BigUint ) -> BigUint 
                    {
                        // trivially same as regular division
                        self / v
                    }

                    #[inline] fn rem_euclid(&self, v: &BigUint ) -> BigUint 
                    {
                        // trivially same as regular remainder
                        self % v
                    }

                    fn div_rem_euclid(&self, v: &Self ) -> (Self, Self ) 
                    {
                        // trivially same as regular division and remainder
                        self.div_rem(v)
                    }
                }
            }
            /**/
            pub mod iter
            {
                use ::iter::FusedIterator;

                cfg_digit!(
                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        it: core::slice::Iter<'a, u32>,
                    }

                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        data: &'a [u64],
                        next_is_lo: bool,
                        last_hi_is_zero: bool,
                    }
                );

                cfg_digit!(
                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub fn new(data: &'a [u32] ) -> Self {
                                Self { it: data.iter() }
                            }
                        }

                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next(&mut self ) -> Option<u32> {
                                self.it.next().cloned()
                            }

                            #[inline]
                            fn size_hint(&self ) -> (usize, Option<usize> ) {
                                self.it.size_hint()
                            }

                            #[inline]
                            fn nth(&mut self, n: usize ) -> Option<u32> {
                                self.it.nth(n).cloned()
                            }

                            #[inline]
                            fn last(self ) -> Option<u32> {
                                self.it.last().cloned()
                            }

                            #[inline]
                            fn count(self ) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back(&mut self ) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len(&self ) -> usize {
                                self.it.len()
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub fn new(data: &'a [u64] ) -> Self {
                                let last_hi_is_zero = data
                                    .last()
                                    .map(|&last| {
                                        let last_hi = (last >> 32 ) as u32;
                                        last_hi == 0
                                    })
                                    .unwrap_or(false);
                                U32Digits {
                                    data,
                                    next_is_lo: true,
                                    last_hi_is_zero,
                                }
                            }
                        }

                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next(&mut self ) -> Option<u32> {
                                match self.data.split_first() {
                                    Some((&first, data) ) => {
                                        let next_is_lo = self.next_is_lo;
                                        self.next_is_lo = !next_is_lo;
                                        if next_is_lo {
                                            Some(first as u32)
                                        } else {
                                            self.data = data;
                                            if data.is_empty() && self.last_hi_is_zero {
                                                self.last_hi_is_zero = false;
                                                None
                                            } else {
                                                Some((first >> 32 ) as u32)
                                            }
                                        }
                                    }
                                    None => None,
                                }
                            }

                            #[inline]
                            fn size_hint(&self ) -> (usize, Option<usize> ) {
                                let len = self.len();
                                (len, Some(len))
                            }

                            #[inline]
                            fn last(self ) -> Option<u32> {
                                self.data.last().map(|&last| {
                                    if self.last_hi_is_zero {
                                        last as u32
                                    } else {
                                        (last >> 32 ) as u32
                                    }
                                })
                            }

                            #[inline]
                            fn count(self ) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back(&mut self ) -> Option<Self::Item> {
                                match self.data.split_last() {
                                    Some((&last, data) ) => {
                                        let last_is_lo = self.last_hi_is_zero;
                                        self.last_hi_is_zero = !last_is_lo;
                                        if last_is_lo {
                                            self.data = data;
                                            if data.is_empty() && !self.next_is_lo {
                                                self.next_is_lo = true;
                                                None
                                            } else {
                                                Some(last as u32)
                                            }
                                        } else {
                                            Some((last >> 32 ) as u32)
                                        }
                                    }
                                    None => None,
                                }
                            }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len(&self ) -> usize {
                                self.data.len() * 2
                                    - usize::from(self.last_hi_is_zero)
                                    - usize::from(!self.next_is_lo)
                            }
                        }
                    };
                );

                impl FusedIterator for U32Digits<'_> {}

                cfg_digit!(
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: core::slice::Chunks<'a, u32>,
                    }

                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: core::slice::Iter<'a, u64>,
                    }
                );

                cfg_digit!(
                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub fn new(data: &'a [u32] ) -> Self {
                                U64Digits { it: data.chunks(2 ) }
                            }
                        }

                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next(&mut self ) -> Option<u64> {
                                self.it.next().map(super::u32_chunk_to_u64)
                            }

                            #[inline]
                            fn size_hint(&self ) -> (usize, Option<usize> ) {
                                let len = self.len();
                                (len, Some(len))
                            }

                            #[inline]
                            fn last(self ) -> Option<u64> {
                                self.it.last().map(super::u32_chunk_to_u64)
                            }

                            #[inline]
                            fn count(self ) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back(&mut self ) -> Option<Self::Item> {
                                self.it.next_back().map(super::u32_chunk_to_u64)
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub fn new(data: &'a [u64] ) -> Self {
                                Self { it: data.iter() }
                            }
                        }

                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next(&mut self ) -> Option<u64> {
                                self.it.next().cloned()
                            }

                            #[inline]
                            fn size_hint(&self ) -> (usize, Option<usize> ) {
                                self.it.size_hint()
                            }

                            #[inline]
                            fn nth(&mut self, n: usize ) -> Option<u64> {
                                self.it.nth(n).cloned()
                            }

                            #[inline]
                            fn last(self ) -> Option<u64> {
                                self.it.last().cloned()
                            }

                            #[inline]
                            fn count(self ) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back(&mut self ) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }
                    };
                );

                impl ExactSizeIterator for U64Digits<'_>
                {
                    #[inline] fn len(&self ) -> usize { self.it.len() }
                }

                impl FusedIterator for U64Digits<'_> {}
            }
            /**/
            pub mod monty
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            digit::{ self, BigDigit, DoubleBigDigit },
                            uint::BigUint,
                        },
                        traits::{ One },
                    },
                    ops::{ Shl },
                    vec::{ Vec },
                    *,
                };
                
                struct MontyReducer
                {
                    n0inv: BigDigit,
                }
                
                fn inv_mod_alt(b: BigDigit ) -> BigDigit {
                    assert_ne!(b & 1, 0 );

                    let mut k0 = BigDigit::wrapping_sub(2, b);
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < digit::BITS {
                        t = t.wrapping_mul(t);
                        k0 = k0.wrapping_mul(t + 1);

                        i <<= 1;
                    }
                    debug_assert_eq!(k0.wrapping_mul(b), 1);
                    k0.wrapping_neg()
                }

                impl MontyReducer {
                    fn new(n: &BigUint ) -> Self {
                        let n0inv = inv_mod_alt(n.data[0]);
                        MontyReducer { n0inv }
                    }
                }

                /// Computes z mod m = x * y * 2 ** (-n*_W ) mod m assuming k = -1/m mod 2**_W
                #[allow(clippy::many_single_char_names)]
                fn montgomery(x: &BigUint, y: &BigUint, m: &BigUint, k: BigDigit, n: usize ) -> BigUint
                {
                    assert!(
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                    );

                    let mut z = BigUint::ZERO;
                    z.data.resize(n * 2, 0 );

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw(&mut z.data[i..n + i], &x.data, y.data[i]);
                        let t = z.data[i].wrapping_mul(k);
                        let c3 = add_mul_vvw(&mut z.data[i..n + i], &m.data, t);
                        let cx = c.wrapping_add(c2);
                        let cy = cx.wrapping_add(c3);
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }

                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let (first, second ) = z.data.split_at_mut(n);
                            sub_vv(first, second, &m.data);
                        }
                        z.data = z.data[..n].to_vec();
                    }

                    z
                }

                #[inline(always)]
                fn add_mul_vvw(z: &mut [BigDigit], x: &[BigDigit], y: BigDigit ) -> BigDigit {
                    let mut c = 0;
                    for (zi, xi ) in z.iter_mut().zip(x.iter() ) {
                        let (z1, z0 ) = mul_add_www(*xi, y, *zi);
                        let (c_, zi_ ) = add_ww(z0, c, 0 );
                        *zi = zi_;
                        c = c_ + z1;
                    }

                    c
                }
                /// The resulting carry c is either 0 or 1.
                #[inline(always)]
                fn sub_vv(z: &mut [BigDigit], x: &[BigDigit], y: &[BigDigit] ) -> BigDigit {
                    let mut c = 0;
                    for (i, (xi, yi) ) in x.iter().zip(y.iter()).enumerate().take(z.len() ) {
                        let zi = xi.wrapping_sub(*yi).wrapping_sub(c);
                        z[i] = zi; 
                        c = ((yi & !xi ) | ((yi | !xi ) & zi) ) >> (digit::BITS - 1)
                    }

                    c
                }
                /// z1<<_W + z0 = x+y+c, with c == 0 or 1
                #[inline(always)]
                fn add_ww(x: BigDigit, y: BigDigit, c: BigDigit ) -> (BigDigit, BigDigit ) {
                    let yc = y.wrapping_add(c);
                    let z0 = x.wrapping_add(yc);
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    (z1, z0 )
                }
                /// z1 << _W + z0 = x * y + c
                #[inline(always)]
                fn mul_add_www(x: BigDigit, y: BigDigit, c: BigDigit ) -> (BigDigit, BigDigit ) {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ((z >> digit::BITS ) as BigDigit, z as BigDigit)
                }

                /// Calculates x ** y mod m using a fixed, 4-bit window.
                #[allow(clippy::many_single_char_names)]
                pub fn monty_modpow(x: &BigUint, y: &BigUint, m: &BigUint ) -> BigUint {
                    assert!(m.data[0] & 1 == 1);
                    let mr = MontyReducer::new(m);
                    let num_words = m.data.len();

                    let mut x = x.clone();

                    // We want the lengths of x and m to be equal.
                    // It is OK if x >= m as long as len(x ) == len(m).
                    if x.data.len() > num_words {
                        x %= m;
                        // Note: now len(x ) <= numWords, not guaranteed ==.
                    }
                    if x.data.len() < num_words {
                        x.data.resize(num_words, 0 );
                    }

                    // rr = 2**(2*_W*len(m) ) mod m
                    let mut rr = BigUint::one();
                    rr = (rr.shl(2 * num_words as u64 * u64::from(digit::BITS )) ) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize(num_words, 0 );
                    }
                    // one = 1, with equal length to that of m
                    let mut one = BigUint::one();
                    one.data.resize(num_words, 0 );

                    let n = 4;
                    // powers[i] contains x^i
                    let mut powers = Vec::with_capacity(1 << n);
                    powers.push(montgomery(&one, &rr, m, mr.n0inv, num_words));
                    powers.push(montgomery(&x, &rr, m, mr.n0inv, num_words));
                    for i in 2..1 << n {
                        let r = montgomery(&powers[i - 1], &powers[1], m, mr.n0inv, num_words);
                        powers.push(r);
                    }

                    // initialize z = 1 (Montgomery 1)
                    let mut z = powers[0].clone();
                    z.data.resize(num_words, 0 );
                    let mut zz = BigUint::ZERO;
                    zz.data.resize(num_words, 0 );

                    // same windowed exponent, but with Montgomery multiplications
                    for i in (0..y.data.len()).rev() {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                            }
                            zz = montgomery(
                                &z,
                                &powers[(yi >> (digit::BITS - n) ) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                            );
                            mem::swap(&mut z, &mut zz);
                            yi <<= n;
                            j += n;
                        }
                    }

                    // convert to regular number
                    zz = montgomery(&z, &one, m, mr.n0inv, num_words);

                    zz.normalize();
                    // One last reduction, just in case.
                    // See golang.org/issue/13907.
                    if zz >= *m {
                        // Common case is m has high bit set; in that case,
                        // since zz is the same length as m, there can be just
                        // one multiple of m to remove. Just subtract.
                        // We think that the subtract should be sufficient in general,
                        // so do that unconditionally, but double-check,
                        // in case our beliefs are wrong.
                        // The div is not expected to be reached.
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }

                    zz.normalize();
                    zz
                }
            }
            /**/
            pub mod multiplication
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit},
                            uint::
                            {
                                addition::{__add2, add2},
                                subtraction::sub2,
                                biguint_from_vec, cmp_slice, BigUint, IntDigits,
                            },
                            Sign::{self, Minus, NoSign, Plus},
                            BigInt, UsizePromotion
                        },
                        traits::{CheckedMul, FromPrimitive, One, Zero},
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };

                macro_rules! impl_mul
                {
                    ($(impl Mul<$Other:ty> for $Self:ty;)* ) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul(self, other: $Other ) -> BigUint {
                                match (&*self.data, &*other.data ) {
                                    // multiply by zero
                                    (&[], _ ) | (_, &[] ) => BigUint::ZERO,
                                    // multiply by a scalar
                                    (_, &[digit] ) => self * digit,
                                    (&[digit], _ ) => other * digit,
                                    // full multiplication
                                    (x, y ) => mul3(x, y),
                                }
                            }
                        }
                    )*}
                }

                macro_rules! impl_mul_assign
                {
                    ($(impl MulAssign<$Other:ty> for BigUint;)* ) => {$(
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other ) {
                                match (&*self.data, &*other.data ) {
                                    // multiply by zero
                                    (&[], _ ) => {},
                                    (_, &[] ) => self.set_zero(),
                                    // multiply by a scalar
                                    (_, &[digit] ) => *self *= digit,
                                    (&[digit], _ ) => *self = other * digit,
                                    // full multiplication
                                    (x, y ) => *self = mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                
                #[inline] pub fn mac_with_carry(
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc: &mut DoubleBigDigit,
                ) -> BigDigit
                {
                    *acc += DoubleBigDigit::from(a);
                    *acc += DoubleBigDigit::from(b ) * DoubleBigDigit::from(c);
                    let lo = *acc as BigDigit;
                    *acc >>= digit::BITS;
                    lo
                }

                #[inline] fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit ) -> BigDigit
                {
                    *acc += DoubleBigDigit::from(a ) * DoubleBigDigit::from(b);
                    let lo = *acc as BigDigit;
                    *acc >>= digit::BITS;
                    lo
                }

                /// Three argument multiply accumulate: acc += b * c
                fn mac_digit(acc: &mut [BigDigit], b: &[BigDigit], c: BigDigit)
                {
                    if c == 0 {
                        return;
                    }

                    let mut carry = 0;
                    let (a_lo, a_hi ) = acc.split_at_mut(b.len());

                    for (a, &b ) in a_lo.iter_mut().zip(b ) {
                        *a = mac_with_carry(*a, b, c, &mut carry);
                    }

                    let (carry_hi, carry_lo ) = digit::from_doublebigdigit(carry);

                    let final_carry = if carry_hi == 0 {
                        __add2(a_hi, &[carry_lo])
                    } else {
                        __add2(a_hi, &[carry_hi, carry_lo])
                    };
                    assert_eq!(final_carry, 0, "carry overflow during multiplication!");
                }

                fn bigint_from_slice(slice: &[BigDigit] ) -> BigInt
                {
                    BigInt::from(biguint_from_vec(slice.to_vec()))
                }

                /// Three argument multiply accumulate: acc += b * c
                fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit])
                {
                    if let Some(&0 ) = b.first() {
                        if let Some(nz ) = b.iter().position(|&d| d != 0 ) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    if let Some(&0 ) = c.first() {
                        if let Some(nz ) = c.iter().position(|&d| d != 0 ) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }

                    let acc = acc;
                    let (x, y ) = if b.len() < c.len() { (b, c ) } else { (c, b ) };

                    if x.len() <= 32 {
                        for (i, xi ) in x.iter().enumerate() {
                            mac_digit(&mut acc[i..], y, *xi);
                        }
                    } else if x.len() * 2 <= y.len() {
                        let m2 = y.len() / 2;
                        let (low2, high2 ) = y.split_at(m2);
                        mac3(acc, x, low2);
                        mac3(&mut acc[m2..], x, high2);
                    } else if x.len() <= 256 {
                        let b = x.len() / 2;
                        let (x0, x1 ) = x.split_at(b);
                        let (y0, y1 ) = y.split_at(b);
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };
                        mac3(&mut p.data, x1, y1);
                        p.normalize();
                        add2(&mut acc[b..], &p.data);
                        add2(&mut acc[b * 2..], &p.data);
                        p.data.truncate(0 );
                        p.data.resize(len, 0 );
                        mac3(&mut p.data, x0, y0 );
                        p.normalize();

                        add2(acc, &p.data);
                        add2(&mut acc[b..], &p.data);
                        let (j0_sign, j0 ) = sub_sign(x1, x0 );
                        let (j1_sign, j1 ) = sub_sign(y1, y0 );

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate(0 );
                                p.data.resize(len, 0 );

                                mac3(&mut p.data, &j0.data, &j1.data);
                                p.normalize();

                                sub2(&mut acc[b..], &p.data);
                            }
                            Minus => {
                                mac3(&mut acc[b..], &j0.data, &j1.data);
                            }
                            NoSign => (),
                        }
                    } else {
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min(x.len(), i);
                        let x1_len = Ord::min(x.len() - x0_len, i);

                        let y0_len = i;
                        let y1_len = Ord::min(y.len() - y0_len, i);
                        let x0 = bigint_from_slice(&x[..x0_len]);
                        let x1 = bigint_from_slice(&x[x0_len..x0_len + x1_len]);
                        let x2 = bigint_from_slice(&x[x0_len + x1_len..]);
                        let y0 = bigint_from_slice(&y[..y0_len]);
                        let y1 = bigint_from_slice(&y[y0_len..y0_len + y1_len]);
                        let y2 = bigint_from_slice(&y[y0_len + y1_len..]);
                        let p = &x0 + &x2;
                        let q = &y0 + &y2;
                        let p2 = &p - &x1;
                        let q2 = &q - &y1;
                        let r0 = &x0 * &y0;
                        let r4 = &x2 * &y2;
                        let r1 = (p + x1 ) * (q + y1);
                        let r2 = &p2 * &q2;
                        let r3 = ((p2 + x2 ) * 2 - x0 ) * ((q2 + y2 ) * 2 - y0 );
                        
                        let mut comp3: BigInt = (r3 - &r1 ) / 3u32;
                        let mut comp1: BigInt = (r1 - &r2 ) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = ((&comp2 - comp3 ) >> 1 ) + (&r4 << 1);
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;
                        
                        for (j, result ) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2(&mut acc[i * j..], result.digits()),
                                Minus => sub2(&mut acc[i * j..], result.digits()),
                                NoSign => {}
                            }
                        }
                    }
                }

                fn mul3(x: &[BigDigit], y: &[BigDigit] ) -> BigUint 
                {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3(&mut prod.data, x, y);
                    prod.normalized()
                }

                fn scalar_mul(a: &mut BigUint, b: BigDigit)
                {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry(*a, b, &mut carry);
                                }
                                if carry != 0 {
                                    a.data.push(carry as BigDigit);
                                }
                            }
                        }
                    }
                }

                fn sub_sign(mut a: &[BigDigit], mut b: &[BigDigit] ) -> (Sign, BigUint)
                {
                    if let Some(&0 ) = a.last() {
                        a = &a[..a.iter().rposition(|&x| x != 0 ).map_or(0, |i| i + 1)];
                    }
                    if let Some(&0 ) = b.last() {
                        b = &b[..b.iter().rposition(|&x| x != 0 ).map_or(0, |i| i + 1)];
                    }

                    match cmp_slice(a, b )
                    {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2(&mut a, b);
                            (Plus, biguint_from_vec(a))
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2(&mut b, a);
                            (Minus, biguint_from_vec(b))
                        }
                        Ordering::Equal => (NoSign, BigUint::ZERO),
                    }
                }

                impl_mul!
                {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }

                impl_mul_assign!
                {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }

                promote_unsigned_scalars!(impl Mul for BigUint, mul);
                promote_unsigned_scalars_assign!(impl MulAssign for BigUint, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigUint, mul);

                impl Mul<u32> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn mul(mut self, other: u32 ) -> BigUint
                    {
                        self *= other;
                        self
                    }
                }

                impl MulAssign<u32> for BigUint
                {
                    #[inline] fn mul_assign(&mut self, other: u32 ) { scalar_mul(self, other as BigDigit); }
                }

                impl Mul<u64> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn mul(mut self, other: u64 ) -> BigUint
                    {
                        self *= other;
                        self
                    }
                }
                
                impl MulAssign<u64> for BigUint
                {
                    cfg_digit!
                    (
                        #[inline] fn mul_assign(&mut self, other: u64 )
                        {
                            if let Some(other ) = BigDigit::from_u64(other ) { scalar_mul(self, other); }
                            
                            else
                            {
                                let (hi, lo ) = digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }

                        #[inline] fn mul_assign(&mut self, other: u64 ) { scalar_mul(self, other); }
                    );
                }

                impl Mul<u128> for BigUint
                {
                    type Output = BigUint;
                    #[inline] fn mul(mut self, other: u128 ) -> BigUint
                    {
                        self *= other;
                        self
                    }
                }

                impl MulAssign<u128> for BigUint
                {
                    cfg_digit!
                    (
                        #[inline] fn mul_assign(&mut self, other: u128 )
                        {
                            if let Some(other ) = BigDigit::from_u128(other ) { scalar_mul(self, other); }

                            else
                            {
                                *self = match super::u32_from_u128(other )
                                {
                                    (0, 0, c, d ) => mul3(&self.data, &[d, c]),
                                    (0, b, c, d ) => mul3(&self.data, &[d, c, b]),
                                    (a, b, c, d ) => mul3(&self.data, &[d, c, b, a]),
                                };
                            }
                        }

                        #[inline] fn mul_assign(&mut self, other: u128 )
                        {
                            if let Some(other ) = BigDigit::from_u128(other ) { scalar_mul(self, other); }
                            else
                            {
                                let (hi, lo ) = digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }
                    );
                }

                impl CheckedMul for BigUint
                {
                    #[inline] fn checked_mul(&self, v: &BigUint ) -> Option<BigUint> { Some(self.mul(v)) }
                }

                impl_product_iter_type!(BigUint);
            }
            /**/
            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::
                        {
                            digit::{ self, BigDigit },
                            uint::
                            {
                                monty::monty_modpow,
                                BigUint,
                            },
                        },
                        integer::Integer,
                        traits::{One, Pow, ToPrimitive, Zero},
                    },
                    *,
                };

                macro_rules! pow_impl
                {
                    ($T:ty ) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow(self, mut exp: $T ) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }

                                if exp == 1 {
                                    return base;
                                }

                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }

                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T ) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }

                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: $T ) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow(self.clone(), exp)
                            }
                        }

                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T ) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }
                    };
                }

                impl Pow<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: &BigUint ) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some(exp ) = exp.to_u64() {
                            self.pow(exp)
                        } else if let Some(exp ) = exp.to_u128() {
                            self.pow(exp)
                        } else {
                            panic!("memory overflow")
                        }
                    }
                }

                impl Pow<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: BigUint ) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                impl Pow<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: &BigUint ) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow(exp)
                        }
                    }
                }

                impl Pow<BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow(self, exp: BigUint ) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);

                pub fn modpow(x: &BigUint, exponent: &BigUint, modulus: &BigUint ) -> BigUint
                {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    if modulus.is_odd() {
                        // For an odd modulus, we can use Montgomery multiplication in base 2^32.
                        monty_modpow(x, exponent, modulus)
                    } else {
                        // Otherwise do basically the same as `num::pow`, but with a modulus.
                        plain_modpow(x, &exponent.data, modulus)
                    }
                }

                fn plain_modpow(base: &BigUint, exp_data: &[BigDigit], modulus: &BigUint ) -> BigUint
                {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let i = match exp_data.iter().position(|&r| r != 0 ) {
                        None => return BigUint::one(),
                        Some(i ) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }

                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }

                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }

                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some(&last ) = exp_iter.next_back() {
                            // consume exp_data[i]
                            for _ in b..digit::BITS {
                                unit(r.is_odd());
                                r >>= 1;
                            }

                            // consume all other digits before the last
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..digit::BITS {
                                    unit(r.is_odd());
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }

                        debug_assert_ne!(r, 0 );
                        while !r.is_zero() {
                            unit(r.is_odd());
                            r >>= 1;
                        }
                    }
                    acc
                }
            }
            /**/
            pub mod shift
            {
                use ::
                {
                    borrow::{ Cow },
                    num::
                    {
                        big::
                        {
                            digit::{ self },
                            uint::
                            {
                                biguint_from_vec, BigUint    
                            },
                        },
                        traits::{PrimInt, Zero},
                    },
                    ops::{ Shl, ShlAssign, Shr, ShrAssign },
                    vec::{ Vec },
                    *,
                };

                macro_rules! impl_shift
                {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty ) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs ) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs ) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs ) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+ ) => {$(
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs ) -> BigUint {
                                biguint_shl(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs ) -> BigUint {
                                biguint_shl(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs ) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs ) -> BigUint {
                                biguint_shr(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs ) -> BigUint {
                                biguint_shr(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs ) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                #[inline] fn biguint_shl<T: PrimInt>(n: Cow<'_, BigUint>, shift: T ) -> BigUint
                {
                    if shift < T::zero() {
                        panic!("attempt to shift left with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(digit::BITS ).unwrap();
                    let digits = (shift / bits).to_usize().expect("capacity overflow");
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shl2(n, digits, shift)
                }

                fn biguint_shl2(n: Cow<'_, BigUint>, digits: usize, shift: u8 ) -> BigUint
                {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add(n.data.len() + 1);
                            let mut data = Vec::with_capacity(len);
                            data.resize(digits, 0 );
                            data.extend(n.data.iter());
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = (*elem << shift ) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push(carry);
                        }
                    }

                    biguint_from_vec(data)
                }

                #[inline] fn biguint_shr<T: PrimInt>(n: Cow<'_, BigUint>, shift: T ) -> BigUint
                {
                    if shift < T::zero() {
                        panic!("attempt to shift right with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(digit::BITS ).unwrap();
                    let digits = (shift / bits).to_usize().unwrap_or(usize::MAX);
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shr2(n, digits, shift)
                }

                fn biguint_shr2(n: Cow<'_, BigUint>, digits: usize, shift: u8 ) -> BigUint
                {
                    if digits >= n.data.len() {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed(n ) => n.data[digits..].to_vec(),
                        Cow::Owned(mut n ) => {
                            n.data.drain(..digits);
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = (*elem >> shift ) | borrow;
                            borrow = new_borrow;
                        }
                    }

                    biguint_from_vec(data)
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
            }
            /**/
            pub mod subtraction
            {
                use ::
                {
                    cmp::{ Ordering::{Equal, Greater, Less} },
                    num::
                    {
                        big::
                        {
                            digit::{ self, BigDigit },
                            uint::{ BigUint },
                            UsizePromotion,
                        },
                        traits::CheckedSub,
                    },
                    ops::{Sub, SubAssign},
                    *,
                };
                
                cfg_64!
                (
                    #[inline] fn sbb(borrow: u8, a: u64, b: u64, out: &mut u64 ) -> u8
                    { unsafe { arch::_subborrow_u64(borrow, a, b, out ) } }
                );
                
                pub fn sub2(a: &mut [BigDigit], b: &[BigDigit])
                {
                    let mut borrow = 0;

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi ) = a.split_at_mut(len);
                    let (b_lo, b_hi ) = b.split_at(len);

                    for (a, b ) in a_lo.iter_mut().zip(b_lo ) {
                        borrow = sbb(borrow, *a, *b, a);
                    }

                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb(borrow, *a, 0, a);
                            if borrow == 0 {
                                break;
                            }
                        }
                    }

                    // note: we're _required_ to fail on underflow
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0 ),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }
                
                #[inline] fn __sub2rev(a: &[BigDigit], b: &mut [BigDigit] ) -> u8 
                {
                    debug_assert!(b.len() == a.len());

                    let mut borrow = 0;

                    for (ai, bi ) in a.iter().zip(b ) {
                        borrow = sbb(borrow, *ai, *bi, bi);
                    }

                    borrow
                }

                fn sub2rev(a: &[BigDigit], b: &mut [BigDigit] ) 
                {
                    debug_assert!(b.len() >= a.len());

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi ) = a.split_at(len);
                    let (b_lo, b_hi ) = b.split_at_mut(len);

                    let borrow = __sub2rev(a_lo, b_lo);

                    assert!(a_hi.is_empty());
                    
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0 ),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

                forward_val_val_binop!(impl Sub for BigUint, sub);
                forward_ref_ref_binop!(impl Sub for BigUint, sub);
                forward_val_assign!(impl SubAssign for BigUint, sub_assign);

                impl Sub<&BigUint> for BigUint 
                {
                    type Output = BigUint;

                    fn sub(mut self, other: &BigUint ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                
                impl SubAssign<&BigUint> for BigUint 
                {
                    fn sub_assign(&mut self, other: &BigUint ) {
                        sub2(&mut self.data[..], &other.data[..]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for &BigUint 
                {
                    type Output = BigUint;

                    fn sub(self, mut other: BigUint ) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev(&self.data[..other_len], &mut other.data);
                            other.data.extend_from_slice(&self.data[other_len..]);
                            if lo_borrow != 0 {
                                sub2(&mut other.data[other_len..], &[1])
                            }
                        } else {
                            sub2rev(&self.data[..], &mut other.data[..]);
                        }
                        other.normalized()
                    }
                }

                promote_unsigned_scalars!(impl Sub for BigUint, sub);
                promote_unsigned_scalars_assign!(impl SubAssign for BigUint, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigUint, sub);

                impl Sub<u32> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u32 ) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u32> for BigUint 
                {
                    fn sub_assign(&mut self, other: u32 ) {
                        sub2(&mut self.data[..], &[other as BigDigit]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for u32 
                {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline] fn sub(self, mut other: BigUint ) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint ) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self as BigDigit);
                            } else {
                                sub2rev(&[self as BigDigit], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u64> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u64 ) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u64> for BigUint 
                {
                    cfg_digit!(
                        #[inline] fn sub_assign(&mut self, other: u64 ) {
                            let (hi, lo ) = digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }

                        #[inline] fn sub_assign(&mut self, other: u64 ) {
                            sub2(&mut self.data[..], &[other as BigDigit]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u64 
                {
                    type Output = BigUint;

                    cfg_digit!
                    (
                        #[inline] fn sub(self, mut other: BigUint ) -> BigUint 
                        {
                            while other.data.len() < 2 { other.data.push(0 ); }

                            let (hi, lo ) = digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint ) -> BigUint 
                        {
                            if other.data.is_empty() {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u128> for BigUint 
                {
                    type Output = BigUint;

                    #[inline] fn sub(mut self, other: u128 ) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u128> for BigUint 
                {
                    cfg_digit!
                    (
                        #[inline] fn sub_assign(&mut self, other: u128 )
                        {
                            let (a, b, c, d ) = super::u32_from_u128(other);
                            sub2(&mut self.data[..], &[d, c, b, a]);
                            self.normalize();
                        }

                        #[inline] fn sub_assign(&mut self, other: u128 )
                        {
                            let (hi, lo ) = digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u128 
                {
                    type Output = BigUint;

                    cfg_digit!
                    (
                        #[inline] fn sub(self, mut other: BigUint ) -> BigUint 
                        {
                            while other.data.len() < 4 {
                                other.data.push(0 );
                            }

                            let (a, b, c, d ) = super::u32_from_u128(self);
                            sub2rev(&[d, c, b, a], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline] fn sub(self, mut other: BigUint ) -> BigUint 
                        {
                            while other.data.len() < 2 {
                                other.data.push(0 );
                            }

                            let (hi, lo ) = digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }
                    );
                }

                impl CheckedSub for BigUint 
                {
                    #[inline] fn checked_sub(&self, v: &BigUint ) -> Option<BigUint>
                    {
                        match self.cmp(v )
                        {
                            Less => None,
                            Equal => Some(Self::ZERO),
                            Greater => Some(self.sub(v)),
                        }
                    }
                }
            }
            /// A big unsigned integer type.
            pub struct BigUint
            {
                data: Vec<BigDigit>,
            }
            
            impl Clone for BigUint
            {
                #[inline] fn clone( &self ) -> Self
                {
                    BigUint
                    {
                        data: self.data.clone(),
                    }
                }

                #[inline] fn clone_from( &mut self, other: &Self ) { self.data.clone_from( &other.data ); }
            }
            
            impl hash::Hash for BigUint
            {
                #[inline] fn hash<H: hash::Hasher>( &self, state: &mut H )
                {
                    debug_assert!( self.data.last() != Some( &0 ) );
                    self.data.hash( state );
                }
            }

            impl PartialEq for BigUint
            {
                #[inline] fn eq( &self, other: &BigUint ) -> bool
                {
                    debug_assert!( self.data.last() != Some( &0 ) );
                    debug_assert!( other.data.last() != Some( &0 ) );
                    self.data == other.data
                }
            }

            impl Eq for BigUint {}

            impl PartialOrd for BigUint
            {
                #[inline] fn partial_cmp( &self, other: &BigUint ) -> Option<Ordering>
                {
                    Some( self.cmp( other))
                }
            }

            impl Ord for BigUint
            {
                #[inline] fn cmp( &self, other: &BigUint ) -> Ordering
                {
                    cmp_slice( &self.data[..], &other.data[..])
                }
            }

            #[inline] fn cmp_slice( a: &[BigDigit], b: &[BigDigit] ) -> Ordering
            {
                debug_assert!( a.last() != Some( &0 ) );
                debug_assert!( b.last() != Some( &0 ) );

                match Ord::cmp( &a.len(), &b.len() )
                {
                    Ordering::Equal => Iterator::cmp( a.iter().rev(), b.iter().rev()),
                    other => other,
                }
            }

            impl Default for BigUint
            {
                #[inline] fn default() -> BigUint { Self::ZERO }
            }

            impl fmt::Debug for BigUint 
            {
                fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result 
                {
                    fmt::Display::fmt( self, f)
                }
            }

            impl fmt::Display for BigUint 
            {
                fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result 
                {
                    f.pad_integral( true, "", &self.to_str_radix( 10 ))
                }
            }

            impl fmt::LowerHex for BigUint 
            {
                fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result 
                {
                    f.pad_integral( true, "0x", &self.to_str_radix( 16))
                }
            }

            impl fmt::UpperHex for BigUint 
            {
                fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result 
                {
                    let mut s = self.to_str_radix( 16 );
                    s.make_ascii_uppercase();
                    f.pad_integral( true, "0x", &s)
                }
            }

            impl fmt::Binary for BigUint 
            {
                fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result 
                {
                    f.pad_integral( true, "0b", &self.to_str_radix( 2))
                }
            }

            impl fmt::Octal for BigUint 
            {
                fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result 
                {
                    f.pad_integral( true, "0o", &self.to_str_radix( 8))
                }
            }

            impl Zero for BigUint 
            {
                #[inline] fn zero() -> BigUint 
                {
                    Self::ZERO
                }

                #[inline] fn set_zero( &mut self ) 
                {
                    self.data.clear();
                }

                #[inline] fn is_zero( &self ) -> bool 
                {
                    self.data.is_empty()
                }
            }

            impl One for BigUint
            {
                #[inline] fn one() -> BigUint { BigUint { data: vec![1] } }

                #[inline] fn set_one( &mut self ) { self.data.clear(); self.data.push( 1 ); }

                #[inline] fn is_one( &self ) -> bool { self.data[..] == [1] }
            }

            impl Unsigned for BigUint {}

            impl Integer for BigUint
            {
                #[inline] fn div_rem( &self, other: &BigUint ) -> ( BigUint, BigUint )
                {
                    division::div_rem_ref( self, other)
                }

                #[inline] fn div_floor( &self, other: &BigUint ) -> BigUint
                {
                    let ( d, _ ) = division::div_rem_ref( self, other );
                    d
                }

                #[inline] fn mod_floor( &self, other: &BigUint ) -> BigUint
                {
                    let ( _, m ) = division::div_rem_ref( self, other );
                    m
                }

                #[inline] fn div_mod_floor( &self, other: &BigUint ) -> ( BigUint, BigUint )
                { division::div_rem_ref( self, other) }

                #[inline] fn div_ceil( &self, other: &BigUint ) -> BigUint
                {
                    let ( d, m ) = division::div_rem_ref( self, other );
                    if m.is_zero() { d }
                    else { d + 1u32 }
                }
                /// Calculates the Greatest Common Divisor ( GCD ) of the number and `other`.
                #[inline] fn gcd( &self, other: &Self ) -> Self
                {
                    #[inline] fn twos( x: &BigUint ) -> u64 { x.trailing_zeros().unwrap_or( 0 ) }
                    
                    if self.is_zero() { return other.clone(); }

                    if other.is_zero() { return self.clone(); }

                    let mut m = self.clone();
                    let mut n = other.clone();
                    
                    let shift = cmp::min( twos( &n), twos( &m ) );
                    
                    n >>= twos( &n );

                    while !m.is_zero()
                    {
                        m >>= twos( &m );
                        if n > m { mem::swap( &mut n, &mut m) }
                        m -= &n;
                    }

                    n << shift
                }
                /// Calculates the Lowest Common Multiple ( LCM ) of the number and `other`.
                #[inline] fn lcm( &self, other: &BigUint ) -> BigUint
                {
                    if self.is_zero() && other.is_zero() { Self::ZERO }
                    else { self / self.gcd( other ) * other }
                }
                /// Calculates the Greatest Common Divisor ( GCD ) and
                /// Lowest Common Multiple ( LCM ) together.
                #[inline] fn gcd_lcm( &self, other: &Self ) -> ( Self, Self )
                {
                    let gcd = self.gcd( other );
                    let lcm = if gcd.is_zero() { Self::ZERO }
                    else { self / &gcd * other };

                    ( gcd, lcm)
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides( &self, other: &BigUint ) -> bool { self.is_multiple_of( other) }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of( &self, other: &BigUint ) -> bool
                {
                    if other.is_zero() { return self.is_zero(); }
                    ( self % other).is_zero()
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even( &self ) -> bool
                {
                    match self.data.first()
                    {
                        Some( x ) => x.is_even(),
                        None => true,
                    }
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd( &self ) -> bool { !self.is_even() }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of( &self, other: &Self ) -> Self
                {
                    let m = self.mod_floor( other );

                    if m.is_zero() { self.clone() }
                    else { self + ( other - m) }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of( &self, other: &Self ) -> Self { self - self.mod_floor( other) }
            }

            #[inline] fn fixpoint<F>( mut x: BigUint, max_bits: u64, f: F ) -> BigUint where
            F: Fn( &BigUint ) -> BigUint
            {
                let mut xn = f( &x );
                
                while x < xn
                {
                    x = if xn.bits() > max_bits { BigUint::one() << max_bits }
                    else { xn };
                    xn = f( &x );
                }
                
                while x > xn
                {
                    x = xn;
                    xn = f( &x );
                }
                x
            }

            impl Roots for BigUint
            {
                fn nth_root( &self, n: u32 ) -> Self
                {
                    assert!( n > 0, "root degree n must be at least 1" );

                    if self.is_zero() || self.is_one() { return self.clone(); }

                    match n
                    {
                        1 => return self.clone(),
                        2 => return self.sqrt(),
                        3 => return self.cbrt(),
                        _ => (),
                    }
                    
                    let bits = self.bits();
                    let n64 = u64::from( n );
                    if bits <= n64 { return BigUint::one(); }
                    
                    if let Some( x ) = self.to_u64() { return x.nth_root( n).into(); }

                    let max_bits = bits / n64 + 1;
                    
                    let guess = match self.to_f64()
                    {
                        Some( f ) if f.is_finite() =>
                        {
                            use ::num::traits::FromPrimitive;                            
                            BigUint::from_f64( ( f.ln() / f64::from( n)).exp()).unwrap()
                        }
                        _ =>
                        {
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = Integer::div_ceil( &extra_bits, &n64 );
                            let scale = root_scale * n64;
                            if scale < bits && bits - scale > n64 { ( self >> scale).nth_root( n ) << root_scale }
                            else { BigUint::one() << max_bits }
                        }
                    };
                    

                    let n_min_1 = n - 1;
                    fixpoint( guess, max_bits, move |s|
                    {
                        let q = self / s.pow( n_min_1 );
                        let t = n_min_1 * s + q;
                        t / n
                    })
                }
                
                fn sqrt( &self ) -> Self
                {
                    if self.is_zero() || self.is_one() { return self.clone(); }
                    
                    if let Some( x ) = self.to_u64() { return x.sqrt().into(); }

                    let bits = self.bits();
                    let max_bits = bits / 2 + 1;
                    
                    let guess = match self.to_f64()
                    {
                        Some( f ) if f.is_finite() =>
                        {
                            use ::num::traits::FromPrimitive;  
                            BigUint::from_f64( f.sqrt()).unwrap()
                        }
                        _ =>
                        {
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = ( extra_bits + 1 ) / 2;
                            let scale = root_scale * 2;
                            ( self >> scale).sqrt() << root_scale
                        }
                    };
                    
                    fixpoint( guess, max_bits, move |s|
                    {
                        let q = self / s;
                        let t = s + q;
                        t >> 1
                    })
                }

                fn cbrt( &self ) -> Self
                {
                    if self.is_zero() || self.is_one() { return self.clone(); }
                    
                    if let Some( x ) = self.to_u64() { return x.cbrt().into(); }

                    let bits = self.bits();
                    let max_bits = bits / 3 + 1;
                    
                    let guess = match self.to_f64()
                    {
                        Some( f ) if f.is_finite() =>
                        {
                            use ::num::traits::FromPrimitive;  
                            BigUint::from_f64( f.cbrt()).unwrap()
                        }
                        _ =>
                        {
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = ( extra_bits + 2 ) / 3;
                            let scale = root_scale * 3;
                            ( self >> scale).cbrt() << root_scale
                        }
                    };
                    
                    fixpoint( guess, max_bits, move |s|
                    {
                        let q = self / ( s * s );
                        let t = ( s << 1 ) + q;
                        t / 3u32
                    })
                }
            }
            /// A generic trait for converting a value to a [`BigUint`].
            pub trait ToBigUint
            {
                /// Converts the value of `self` to a [`BigUint`].
                fn to_biguint( &self ) -> Option<BigUint>;
            }
            /// Creates and initializes a [`BigUint`].
            #[inline] pub fn biguint_from_vec( digits: Vec<BigDigit> ) -> BigUint
            { BigUint { data: digits }.normalized() }

            impl BigUint
            {
                /// A constant `BigUint` with value 0, useful for static initialization.
                pub const ZERO: Self = BigUint { data: Vec::new() };
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn new( digits: Vec<u32> ) -> BigUint
                {
                    let mut big = Self::ZERO;

                    cfg_digit_expr!
                    ( 
                        {
                            big.data = digits;
                            big.normalize();
                        },
                        big.assign_from_slice( &digits)
                    );

                    big
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_slice( slice: &[u32] ) -> BigUint
                {
                    let mut big = Self::ZERO;
                    big.assign_from_slice( slice );
                    big
                }
                /// Assign a value to a [`BigUint`].
                #[inline] pub fn assign_from_slice( &mut self, slice: &[u32] )
                {
                    self.data.clear();

                    cfg_digit_expr!
                    (
                        self.data.extend_from_slice( slice),
                        self.data.extend( slice.chunks( 2).map( u32_chunk_to_u64))
                    );

                    self.normalize();
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_be( bytes: &[u8] ) -> BigUint
                {
                    if bytes.is_empty() { Self::ZERO }
                    else
                    {
                        let mut v = bytes.to_vec();
                        v.reverse();
                        BigUint::from_bytes_le( &v)
                    }
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_le( bytes: &[u8] ) -> BigUint
                {
                    if bytes.is_empty() { Self::ZERO }
                    else { convert::from_bitwise_digits_le( bytes, 8) }
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn parse_bytes( buf: &[u8], radix: u32 ) -> Option<BigUint>
                {
                    let s = str::from_utf8( buf).ok()?;
                    BigUint::from_str_radix( s, radix).ok()
                }
                /// Creates and initializes a [`BigUint`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                pub fn from_radix_be( buf: &[u8], radix: u32 ) -> Option<BigUint>
                { convert::from_radix_be( buf, radix) }
                /// Creates and initializes a [`BigUint`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                pub fn from_radix_le( buf: &[u8], radix: u32 ) -> Option<BigUint>
                { convert::from_radix_le( buf, radix) }
                /// Returns the byte representation of the [`BigUint`] in big-endian byte order.
                #[inline] pub fn to_bytes_be( &self ) -> Vec<u8>
                {
                    let mut v = self.to_bytes_le();
                    v.reverse();
                    v
                }
                /// Returns the byte representation of the [`BigUint`] in little-endian byte order.
                #[inline] pub fn to_bytes_le( &self ) -> Vec<u8>
                {
                    if self.is_zero() { vec![0] } else { convert::to_bitwise_digits_le( self, 8) }
                }
                /// Returns the `u32` digits representation of the [`BigUint`] ordered least significant digit
                /// first.
                #[inline] pub fn to_u32_digits( &self ) -> Vec<u32> { self.iter_u32_digits().collect() }
                /// Returns the `u64` digits representation of the [`BigUint`] ordered least significant digit
                /// first.
                #[inline] pub fn to_u64_digits( &self ) -> Vec<u64> { self.iter_u64_digits().collect() }
                /// Returns an iterator of `u32` digits representation of the [`BigUint`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u32_digits( &self ) -> U32Digits<'_> { U32Digits::new( self.data.as_slice()) }
                /// Returns an iterator of `u64` digits representation of the [`BigUint`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u64_digits( &self ) -> U64Digits<'_> { U64Digits::new( self.data.as_slice()) }
                /// Returns the integer formatted as a string in the given radix.
                #[inline] pub fn to_str_radix( &self, radix: u32 ) -> String
                {
                    let mut v = to_str_radix_reversed( self, radix );
                    v.reverse();
                    unsafe { String::from_utf8_unchecked( v ) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be( &self, radix: u32 ) -> Vec<u8>
                {
                    let mut v = convert::to_radix_le( self, radix );
                    v.reverse();
                    v
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le( &self, radix: u32 ) -> Vec<u8> { convert::to_radix_le( self, radix) }
                /// Determines the fewest bits necessary to express the [`BigUint`].
                #[inline] pub fn bits( &self ) -> u64
                {
                    if self.is_zero() { return 0; }

                    let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
                    self.data.len() as u64 * u64::from( digit::BITS ) - zeros
                }
                /// Strip off trailing zero bigdigits; comparisons need the last element in the vector to be nonzero.
                #[inline] fn normalize( &mut self )
                {
                    if let Some( &0 ) = self.data.last()
                    {
                        let len = self.data.iter().rposition( |&d| d != 0 ).map_or( 0, |i| i + 1 );
                        self.data.truncate( len );
                    }

                    if self.data.len() < self.data.capacity() / 4 { self.data.shrink_to_fit(); }
                }
                /// Returns a normalized [`BigUint`].
                #[inline] fn normalized( mut self ) -> BigUint
                {
                    self.normalize();
                    self
                }
                /// Returns `self ^ exponent`.
                pub fn pow( &self, exponent: u32 ) -> Self { Pow::pow( self, exponent) }
                /// Returns `( self ^ exponent ) % modulus`.
                pub fn modpow( &self, exponent: &Self, modulus: &Self ) -> Self
                { power::modpow( self, exponent, modulus) }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv( &self, modulus: &Self ) -> Option<Self>
                {
                    assert!( !modulus.is_zero(), "attempt to calculate with zero modulus!" );

                    if modulus.is_one() { return Some( Self::zero() ); }

                    let mut r0;
                    let mut r1 = self % modulus;
                    let mut t0;
                    let mut t1;
                    
                    if r1.is_zero() { return None; } else if r1.is_one() { return Some( r1 ); }
                    else
                    {
                        let ( q, r2 ) = modulus.div_rem( &r1 );
                        
                        if r2.is_zero() { return None; }

                        r0 = r1;
                        r1 = r2;
                        t0 = Self::one();
                        t1 = modulus - q;
                    }

                    while !r1.is_zero()
                    {
                        let ( q, r2 ) = r0.div_rem( &r1 );
                        r0 = r1;
                        r1 = r2;
                        let qt1 = q * &t1 % modulus;
                        let t2 = if t0 < qt1 { t0 + ( modulus - qt1) } else { t0 - qt1 };
                        t0 = t1;
                        t1 = t2;
                    }

                    if r0.is_one() { Some( t0 ) } else { None }
                }
                /// Returns the truncated principal square root of `self` --
                /// see [Roots::sqrt]( https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#method.sqrt)
                pub fn sqrt( &self ) -> Self { Roots::sqrt( self ) }
                /// Returns the truncated principal cube root of `self` --
                /// see [Roots::cbrt]( https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#method.cbrt).
                pub fn cbrt( &self ) -> Self { Roots::cbrt( self ) }
                /// Returns the truncated principal `n`th root of `self` --
                /// see [Roots::nth_root]( https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#tymethod.nth_root).
                pub fn nth_root( &self, n: u32 ) -> Self { Roots::nth_root( self, n) }
                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros( &self ) -> Option<u64>
                {
                    let i = self.data.iter().position( |&digit| digit != 0 )?;
                    let zeros: u64 = self.data[i].trailing_zeros().into();
                    Some( i as u64 * u64::from( digit::BITS ) + zeros)
                }
                /// Returns the number of least-significant bits that are ones.
                pub fn trailing_ones( &self ) -> u64
                {
                    if let Some( i ) = self.data.iter().position( |&digit| !digit != 0 )
                    {
                        let ones: u64 = self.data[i].trailing_ones().into();
                        i as u64 * u64::from( digit::BITS ) + ones
                    }
                    else { self.data.len() as u64 * u64::from( digit::BITS ) }
                }
                /// Returns the number of one bits.
                pub fn count_ones( &self ) -> u64 { self.data.iter().map( |&d| u64::from( d.count_ones())).sum() }
                /// Returns whether the bit in the given position is set
                pub fn bit( &self, bit: u64 ) -> bool
                {
                    let bits_per_digit = u64::from( digit::BITS );

                    if let Some( digit_index ) = ( bit / bits_per_digit).to_usize()
                    {
                        if let Some( digit ) = self.data.get( digit_index )
                        {
                            let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                            return ( digit & bit_mask ) != 0;
                        }
                    }

                    false
                }
                /// Sets or clears the bit in the given position.
                pub fn set_bit( &mut self, bit: u64, value: bool )
                {
                    let bits_per_digit = u64::from( digit::BITS );
                    let digit_index = ( bit / bits_per_digit).to_usize().unwrap_or( usize::MAX );
                    let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                    
                    if value
                    {
                        if digit_index >= self.data.len()
                        {
                            let new_len = digit_index.saturating_add( 1 );
                            self.data.resize( new_len, 0 );
                        }

                        self.data[digit_index] |= bit_mask;
                    }
                    
                    else if digit_index < self.data.len()
                    {
                        self.data[digit_index] &= !bit_mask;
                        self.normalize();
                    }
                }
                
                pub fn dec( &mut self ) { *self -= 1u32; }

                pub fn inc( &mut self ) { *self += 1u32; }
            }

            pub trait IntDigits
            {
                fn digits( &self ) -> &[BigDigit];
                fn digits_mut( &mut self ) -> &mut Vec<BigDigit>;
                fn normalize( &mut self );
                fn capacity( &self ) -> usize;
                fn len( &self ) -> usize;
            }

            impl IntDigits for BigUint
            {
                #[inline] fn digits( &self ) -> &[BigDigit] { &self.data }
                #[inline] fn digits_mut( &mut self ) -> &mut Vec<BigDigit> { &mut self.data }
                #[inline] fn normalize( &mut self ) { self.normalize(); }
                #[inline] fn capacity( &self ) -> usize { self.data.capacity() }
                #[inline] fn len( &self ) -> usize { self.data.len() }
            }
            /// Convert a `u32` chunk ( len is either 1 or 2 ) to a single `u64` digit
            #[inline] fn u32_chunk_to_u64( chunk: &[u32] ) -> u64
            {
                let mut digit = chunk[0] as u64;
                if let Some( &hi ) = chunk.get( 1 ) { digit |= ( hi as u64 ) << 32; }
                digit
            }
            /// Returns the number of least-significant bits that are zero,
            /// or `None` if the entire number is zero.
            pub fn trailing_zeros( this:&BigInt ) -> Option<u64>
            {
                let i = this.data.iter().position( |&digit| digit != 0 )?;
                let zeros: u64 = this.data[i].trailing_zeros().into();
                Some( i as u64 * u64::from( digit::BITS ) + zeros)
            }
        }
        pub use self::uint::{ BigUint, ToBigUint, U32Digits, U64Digits };
        
        type UsizePromotion = u64;
        type IsizePromotion = i64;

        #[derive( Debug, Clone, PartialEq, Eq)]
        pub struct ParseBigIntError
        {
            kind: BigIntErrorKind,
        }

        impl ParseBigIntError
        {
            fn __description( &self ) -> &str
            {
                use self::BigIntErrorKind::*;
                match self.kind
                {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }

            fn empty() -> Self
            {
                ParseBigIntError
                {
                    kind: BigIntErrorKind::Empty,
                }
            }

            fn invalid() -> Self
            {
                ParseBigIntError
                {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError
        {
            fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result { self.__description().fmt( f ) }
        }
        
        impl error::Error for ParseBigIntError
        {
            fn description( &self ) -> &str { self.__description() }
        }

        #[derive( Debug, Clone, PartialEq, Eq)]
        pub enum BigIntErrorKind
        {
            Empty,
            InvalidDigit,
        }
        /// The error type returned when a checked conversion regarding big integer fails.
        #[derive( Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TryFromBigIntError<T>
        {
            original: T,
        }

        impl<T> TryFromBigIntError<T>
        {
            fn new( original: T ) -> Self { TryFromBigIntError { original } }

            fn __description( &self ) -> &str { "out of range conversion regarding big integer attempted" }
            /// Extract the original value, if available.
            pub fn into_original( self ) -> T { self.original }
        }
        
        impl<T> error::Error for TryFromBigIntError<T> where
        T: fmt::Debug
        {
            fn description( &self ) -> &str { self.__description() }
        }

        impl<T> fmt::Display for TryFromBigIntError<T>
        {
            fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result { self.__description().fmt( f ) }
        }
    }

    pub mod fractional
    {
        use ::
        {
            num::
            {
                big::{ BigInt },
                rational::{ BigRational },
                traits::{ FromPrimitive, pow },
            },
            *,
        };
        /*
        use std::fs::File;
        use std::io::Read;
        */
        pub fn frac_from_whole_and_dec( whole:BigInt, decimal:BigInt, dec_len:usize ) -> BigRational
        {
            let denom = pow( BigInt::from_u8( 10 ).unwrap(), dec_len );
            BigRational::new( whole, 1.into() ) + BigRational::new( decimal, denom )
        }
    }

    pub mod integer
    {
        pub use num_integer::{ * };
    }
    
    pub mod rational
    {
        //! Rational numbers
        use ::
        {
            error::{ Error },
            fmt::{ self, Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex },
            hash::{ Hash, Hasher },
            num::
            {
                integer::{ Integer },
                big::{ BigInt, BigUint, Sign, ToBigInt },
                traits::
                {
                    float::{ FloatCore },
                    Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub,/* ConstOne, ConstZero, */FromPrimitive, Inv,
                    Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero,
                },
            },
            ops::{ Add, Div, Mul, Neg, Rem, ShlAssign, Sub },
            str::{ FromStr },
            *,
        };
        
        macro_rules! forward_ref_ref_binop
        {
            ( impl $imp:ident, $method:ident ) =>
            {
                impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, other:&'b Ratio<T> ) -> Ratio<T> {self.clone().$method( other.clone())}
                }

                impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, other: &'b T ) -> Ratio<T> {self.clone().$method( other.clone())}
                }
            };
        }

        macro_rules! forward_ref_val_binop
        {
            ( impl $imp:ident, $method:ident ) =>
            {
                impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T> where
                T: Clone + Integer
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, other: Ratio<T> ) -> Ratio<T> { self.clone().$method( other ) }
                }
                
                impl<'a, T> $imp<T> for &'a Ratio<T> where
                T: Clone + Integer
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, other: T ) -> Ratio<T> { self.clone().$method( other ) }
                }
            };
        }

        macro_rules! forward_val_ref_binop
        {
            ( impl $imp:ident, $method:ident ) =>
            {
                impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T> where
                T: Clone + Integer
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, other: &Ratio<T> ) -> Ratio<T> { self.$method( other.clone() ) }
                }

                impl<'a, T> $imp<&'a T> for Ratio<T> where
                T: Clone + Integer
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, other: &T ) -> Ratio<T> { self.$method( other.clone() ) }
                }
            };
        }

        macro_rules! forward_all_binop
        {
            ( impl $imp:ident, $method:ident ) =>
            {
                forward_ref_ref_binop!( impl $imp, $method );
                forward_ref_val_binop!( impl $imp, $method );
                forward_val_ref_binop!( impl $imp, $method );
            };
        }

        macro_rules! arith_impl
        {
            ( impl $imp:ident, $method:ident ) =>
            {
                forward_all_binop!( impl $imp, $method );
                
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, rhs: Ratio<T> ) -> Ratio<T>
                    {
                        if self.denom == rhs.denom { return Ratio::new( self.numer.$method( rhs.numer), rhs.denom ); }

                        let lcm = self.denom.lcm( &rhs.denom );
                        let lhs_numer = self.numer * ( lcm.clone() / self.denom );
                        let rhs_numer = rhs.numer * ( lcm.clone() / rhs.denom );
                        Ratio::new( lhs_numer.$method( rhs_numer), lcm)
                    }
                }
                
                impl<T: Clone + Integer> $imp<T> for Ratio<T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, rhs: T ) -> Ratio<T>
                    { Ratio::new( self.numer.$method( self.denom.clone() * rhs), self.denom ) }
                }
            };
        }
        
        macro_rules! checked_arith_impl
        {
            ( impl $imp:ident, $method:ident ) =>
            {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T>
                {
                    #[inline] fn $method( &self, rhs: &Ratio<T> ) -> Option<Ratio<T>>
                    {
                        let gcd = self.denom.clone().gcd( &rhs.denom );
                        let lcm = ( self.denom.clone() / gcd.clone()).checked_mul( &rhs.denom)?;
                        let lhs_numer = ( lcm.clone() / self.denom.clone()).checked_mul( &self.numer)?;
                        let rhs_numer = ( lcm.clone() / rhs.denom.clone()).checked_mul( &rhs.numer)?;
                        Some( Ratio::new( lhs_numer.$method( &rhs_numer)?, lcm))
                    }
                }
            };
        }
        
        macro_rules! impl_formatting
        {
            ( $fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr ) =>
            {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T> {
                    fn fmt( &self, f: &mut Formatter<'_> ) -> fmt::Result {
                        let pre_pad = if self.denom.is_one() {
                            format!( $fmt_str, self.numer)
                        } else {
                            if f.alternate() {
                                format!( concat!( $fmt_str, "/", $fmt_alt), self.numer, self.denom)
                            } else {
                                format!( concat!( $fmt_str, "/", $fmt_str), self.numer, self.denom)
                            }
                        };
                        if let Some( pre_pad ) = pre_pad.strip_prefix( "-" ) {
                            f.pad_integral( false, $prefix, pre_pad)
                        } else {
                            f.pad_integral( true, $prefix, &pre_pad)
                        }
                    }
                }
            };
        }

        macro_rules! from_primitive_integer
        {
            ( $typ:ty, $approx:ident ) =>
            {
                impl FromPrimitive for Ratio<$typ> {
                    fn from_i64( n: i64 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i64( n).map( Ratio::from_integer)
                    }

                    fn from_i128( n: i128 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i128( n).map( Ratio::from_integer)
                    }

                    fn from_u64( n: u64 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u64( n).map( Ratio::from_integer)
                    }

                    fn from_u128( n: u128 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u128( n).map( Ratio::from_integer)
                    }

                    fn from_f32( n: f32 ) -> Option<Self> {
                        $approx( n, 10e-20, 30 )
                    }

                    fn from_f64( n: f64 ) -> Option<Self> {
                        $approx( n, 10e-20, 30 )
                    }
                }
            };
        }

        pub mod power
        {
            use ::
            {
                num::
                {
                    integer::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Pow },
                },
                *,
            };

            macro_rules! pow_unsigned_impl
            {
                ( @ $exp:ty ) =>
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: $exp ) -> Ratio<T> {
                        Ratio::new_raw( self.numer.pow( expon), self.denom.pow( expon))
                    }
                };

                ( $exp:ty ) =>
                {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> 
                    {
                        pow_unsigned_impl!( @ $exp );
                    }

                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T> where
                    &'a T: Pow<$exp, Output = T>
                    {
                        pow_unsigned_impl!( @ $exp );
                    }

                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T>
                    {                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon: &'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon)
                        }
                    }

                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T> where
                    &'a T: Pow<$exp, Output = T>
                    {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon: &'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon)
                        }
                    }
                };
            }

            macro_rules! pow_signed_impl
            {
                ( @ &'b BigInt, BigUint ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: &'b BigInt ) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => {
                                Pow::pow( self, expon.magnitude()).into_recip()
                            }
                            Sign::Plus => Pow::pow( self, expon.magnitude()),
                        }
                    }
                };
                ( @ $exp:ty, $unsigned:ty ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: $exp ) -> Ratio<T> {
                        match expon.cmp( &0 ) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow( self, expon).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow( self, expon as $unsigned),
                        }
                    }
                };
                ( $exp:ty, $unsigned:ty ) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_signed_impl!( @ $exp, $unsigned );
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!( @ $exp, $unsigned );
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon: &'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon: &'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon)
                        }
                    }
                };
            }
            
            mod bigint
            {
                use ::
                {
                    
                    num::
                    {
                        big::{ BigInt, BigUint, Sign },
                        rational::{ * },
                        traits::{ One, Pow },
                    },
                    *,
                };

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigUint ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }

                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T> where
                &'a T: for<'b> Pow<&'b BigUint, Output = T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigUint ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }
                
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T>
                {
                    pow_unsigned_impl!( @ &'b BigUint );
                }

                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T> where
                &'a T: Pow<&'b BigUint, Output = T>
                {
                    pow_unsigned_impl!( @ &'b BigUint );
                }

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigInt ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }

                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T> where
                &'a T: for<'b> Pow<&'b BigUint, Output = T>
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigInt ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }
                
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T>
                {
                    pow_signed_impl!( @ &'b BigInt, BigUint );
                }

                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T> where
                &'a T: Pow<&'b BigUint, Output = T>
                { pow_signed_impl!( @ &'b BigInt, BigUint ); }
            }

            pow_unsigned_impl!( u8 );
            pow_unsigned_impl!( u16 );
            pow_unsigned_impl!( u32 );
            pow_unsigned_impl!( u64 );
            pow_unsigned_impl!( u128 );
            pow_unsigned_impl!( usize );
            pow_signed_impl!( i8, u8 );
            pow_signed_impl!( i16, u16 );
            pow_signed_impl!( i32, u32 );
            pow_signed_impl!( i64, u64 );
            pow_signed_impl!( i128, u128 );
            pow_signed_impl!( isize, usize );
        }

        pub mod iter_sum_product
        {
            use ::
            {
                iter::{ Product, Sum },
                num::
                {
                    integer::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Zero },
                },
                *,
            };
            
            impl<T: Integer + Clone> Sum for Ratio<T>
            {
                fn sum<I>( iter: I ) -> Self where
                I: Iterator<Item = Ratio<T>> 
                { iter.fold( Self::zero(), |sum, num| sum + num ) }
            }

            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T>
            {
                fn sum<I>( iter: I ) -> Self where
                I: Iterator<Item = &'a Ratio<T>>
                { iter.fold( Self::zero(), |sum, num| sum + num ) }
            }

            impl<T: Integer + Clone> Product for Ratio<T>
            {
                fn product<I>( iter: I ) -> Self where
                I: Iterator<Item = Ratio<T>>
                {
                    iter.fold( Self::one(), |prod, num| prod * num)
                }
            }

            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T>
            {
                fn product<I>( iter: I ) -> Self where
                I: Iterator<Item = &'a Ratio<T>>
                { iter.fold( Self::one(), |prod, num| prod * num ) }
            }
        }

        pub mod opassign
        {
            use ::
            {
                iter::{ Product, Sum },
                num::
                {
                    integer::{ Integer },
                    rational::{ Ratio },
                    traits::{ NumAssign },
                },
                ops::{ AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
                *,
            };

            macro_rules! forward_op_assign
            {
                ( impl $imp:ident, $method:ident ) =>
                {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T>
                    {
                        #[inline] fn $method( &mut self, other: &Ratio<T> ) { self.$method( other.clone() ) }
                    }

                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T>
                    {
                        #[inline] fn $method( &mut self, other: &T ) { self.$method( other.clone() ) }
                    }
                };
            }

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T>
            {
                fn add_assign( &mut self, other: Ratio<T>)
                {
                    if self.denom == other.denom { self.numer += other.numer } 
                    
                    else
                    {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }

                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T>
            {
                /// ( a/b ) / ( c/d ) = ( a/gcd_ac)*( d/gcd_bd ) / ( ( c/gcd_ac)*( b/gcd_bd))
                fn div_assign( &mut self, other: Ratio<T>)
                {
                    let gcd_ac = self.numer.gcd( &other.numer );
                    let gcd_bd = self.denom.gcd( &other.denom );
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T>
            {
                /// a/b * c/d = ( a/gcd_ad)*( c/gcd_bc ) / ( ( d/gcd_ad)*( b/gcd_bc))
                fn mul_assign( &mut self, other: Ratio<T>)
                {
                    let gcd_ad = self.numer.gcd( &other.denom );
                    let gcd_bc = self.denom.gcd( &other.numer );
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T>
            {
                fn rem_assign( &mut self, other: Ratio<T>)
                {
                    if self.denom == other.denom { self.numer %= other.numer }
                    else
                    {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }

                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T>
            {
                fn sub_assign( &mut self, other: Ratio<T>)
                {
                    if self.denom == other.denom { self.numer -= other.numer }                    
                    else
                    {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }

                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T>
            {
                /// a/b + c/1 = ( a*1 + b*c ) / ( b*1 ) = ( a + b*c ) / b
                fn add_assign( &mut self, other: T)
                {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T>
            {
                fn div_assign( &mut self, other: T)
                {
                    let gcd = self.numer.gcd( &other );
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T>
            {
                fn mul_assign( &mut self, other: T)
                {
                    let gcd = self.denom.gcd( &other );
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce();
                }
            }

            
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T>
            {
                /// a/b % c/1 = ( a*1 % b*c ) / ( b*1 ) = ( a % b*c ) / b
                fn rem_assign( &mut self, other: T)
                {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T>
            {
                /// a/b - c/1 = ( a*1 - b*c ) / ( b*1 ) = ( a - b*c ) / b
                fn sub_assign( &mut self, other: T)
                {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }

            forward_op_assign!( impl AddAssign, add_assign );
            forward_op_assign!( impl DivAssign, div_assign );
            forward_op_assign!( impl MulAssign, mul_assign );
            forward_op_assign!( impl RemAssign, rem_assign );
            forward_op_assign!( impl SubAssign, sub_assign );
        }
        /// Represents the ratio between two numbers.
        #[derive( Copy, Clone, Debug )]
        pub struct Ratio<T>
        {
            /// Numerator.
            numer: T,
            /// Denominator.
            denom: T,
        }
        /// Alias for a `Ratio` of machine-sized integers.
        pub type Rational = Ratio<isize>;
        /// Alias for a `Ratio` of 32-bit-sized integers.
        pub type Rational32 = Ratio<i32>;
        /// Alias for a `Ratio` of 64-bit-sized integers.
        pub type Rational64 = Ratio<i64>;
        /// Alias for arbitrary precision rationals.
        pub type BigRational = Ratio<BigInt>;
        /// These method are `const`.
        impl<T> Ratio<T>
        {
            /// Creates a `Ratio` without checking for `denom == 0` or reducing.
            #[inline] pub const fn new_raw( numer: T, denom: T ) -> Ratio<T> { Ratio { numer, denom } }
            /// Deconstructs a `Ratio` into its numerator and denominator.
            #[inline] pub fn into_raw( self ) -> ( T, T ) { ( self.numer, self.denom ) }
            /// Gets an immutable reference to the numerator.
            #[inline] pub const fn numer( &self ) -> &T { &self.numer }
            /// Gets an immutable reference to the denominator.
            #[inline] pub const fn denom( &self ) -> &T { &self.denom }
        }
        
        impl<T: Clone + Integer> Ratio<T>
        {
            /// Creates a new `Ratio`.
            #[inline] pub fn new( numer: T, denom: T ) -> Ratio<T>
            {
                let mut ret = Ratio::new_raw( numer, denom );
                ret.reduce();
                ret
            }
            /// Creates a `Ratio` representing the integer `t`.
            #[inline] pub fn from_integer( t: T ) -> Ratio<T> { Ratio::new_raw( t, One::one() ) }
            /// Converts to an integer, rounding towards zero.
            #[inline] pub fn to_integer( &self ) -> T { self.trunc().numer }
            /// Returns true if the rational number is an integer ( denominator is 1).
            #[inline] pub fn is_integer( &self ) -> bool { self.denom.is_one() }
            /// Puts self into lowest terms, with `denom` > 0.
            fn reduce( &mut self)
            {
                if self.denom.is_zero() {
                    panic!( "denominator == 0" );
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd( &self.denom );
                
                #[inline] fn replace_with<T: Zero>( x: &mut T, f: impl FnOnce( T ) -> T)
                {
                    let y = replace( x, T::zero() );
                    *x = f( y );
                }
                
                replace_with( &mut self.numer, |x| x / g.clone() );
                replace_with( &mut self.denom, |x| x / g );
                
                if self.denom < T::zero()
                {
                    replace_with( &mut self.numer, |x| T::zero() - x );
                    replace_with( &mut self.denom, |x| T::zero() - x );
                }
            }
            /// Returns a reduced copy of self.
            pub fn reduced( &self ) -> Ratio<T>
            {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }
            /// Returns the reciprocal.
            #[inline] pub fn recip( &self ) -> Ratio<T> { self.clone().into_recip() }

            #[inline] fn into_recip( self ) -> Ratio<T>
            {
                match self.numer.cmp( &T::zero())
                {
                    cmp::Ordering::Equal => panic!( "division by zero"),
                    cmp::Ordering::Greater => Ratio::new_raw( self.denom, self.numer),
                    cmp::Ordering::Less => Ratio::new_raw( T::zero() - self.denom, T::zero() - self.numer),
                }
            }
            /// Rounds towards minus infinity.
            #[inline] pub fn floor( &self ) -> Ratio<T>
            {
                if *self < Zero::zero()
                {
                    let one: T = One::one();
                    Ratio::from_integer( ( self.numer.clone() - self.denom.clone() + one ) / self.denom.clone() )
                }

                else { Ratio::from_integer( self.numer.clone() / self.denom.clone() ) }
            }
            /// Rounds towards plus infinity.
            #[inline] pub fn ceil( &self ) -> Ratio<T>
            {
                if *self < Zero::zero()
                {
                    Ratio::from_integer( self.numer.clone() / self.denom.clone())
                }
                else
                {
                    let one: T = One::one();
                    Ratio::from_integer( ( self.numer.clone() + self.denom.clone() - one ) / self.denom.clone() )
                }
            }
            /// Rounds to the nearest integer. Rounds half-way cases away from zero.
            #[inline] pub fn round( &self ) -> Ratio<T>
            {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();
                let mut fractional = self.fract();
                
                if fractional < zero { fractional = zero - fractional };

                let half_or_larger = if fractional.denom.is_even() { fractional.numer >= fractional.denom / two }
                else { fractional.numer >= ( fractional.denom / two ) + one };

                if half_or_larger
                {
                    let one: Ratio<T> = One::one();
                    
                    if *self >= Zero::zero() { self.trunc() + one }
                    else { self.trunc() - one }
                }

                else { self.trunc() }
            }
            /// Rounds towards zero.
            #[inline] pub fn trunc( &self ) -> Ratio<T> 
            { Ratio::from_integer( self.numer.clone()/self.denom.clone() ) }
            /// Returns the fractional part of a number, with division rounded towards zero.
            #[inline] pub fn fract( &self ) -> Ratio<T>
            { Ratio::new_raw( self.numer.clone() % self.denom.clone(), self.denom.clone() ) }
            /// Raises the `Ratio` to the power of an exponent.
            #[inline] pub fn pow( &self, expon: i32 ) -> Ratio<T> where
            for<'a> &'a T: Pow<u32, Output = T>
            { Pow::pow( self, expon ) }
        }
        
        impl Ratio<BigInt>
        {
            /// Converts a float into a rational number.
            pub fn from_float<T: FloatCore>( f: T ) -> Option<BigRational>
            {
                if !f.is_finite() { return None; }

                let ( mantissa, exponent, sign ) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                
                if exponent < 0
                {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ( ( -exponent ) as usize );
                    let numer: BigUint = FromPrimitive::from_u64( mantissa).unwrap();
                    Some( Ratio::new( BigInt::from_biguint( bigint_sign, numer), denom))
                }
                
                else
                {
                    let mut numer: BigUint = FromPrimitive::from_u64( mantissa).unwrap();
                    numer <<= exponent as usize;

                    Some( Ratio::from_integer( BigInt::from_biguint
                    ( 
                        bigint_sign,
                        numer,
                    )))
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T>
        {
            fn default() -> Self { Ratio::zero() }
        }
        
        impl<T> From<T> for Ratio<T> where
        T: Clone + Integer
        {
            fn from( x: T ) -> Ratio<T> { Ratio::from_integer( x ) }
        }
        
        impl<T> From<( T, T)> for Ratio<T> where
        T: Clone + Integer
        {
            fn from( pair: ( T, T) ) -> Ratio<T> { Ratio::new( pair.0, pair.1 ) }
        }
        
        impl<T: Clone + Integer> Ord for Ratio<T>
        {
            #[inline] fn cmp( &self, other: &Self ) -> cmp::Ordering
            {
                if self.denom == other.denom
                {
                    let ord = self.numer.cmp( &other.numer );

                    return if self.denom < T::zero() { ord.reverse() }
                    else { ord };
                }
                
                if self.numer == other.numer
                {
                    if self.numer.is_zero() { return cmp::Ordering::Equal; }

                    let ord = self.denom.cmp( &other.denom );

                    return if self.numer < T::zero() { ord } else { ord.reverse() };
                }
                
                let ( self_int, self_rem ) = self.numer.div_mod_floor( &self.denom );
                let ( other_int, other_rem ) = other.numer.div_mod_floor( &other.denom );
                
                match self_int.cmp( &other_int)
                {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal =>
                    {
                        match ( self_rem.is_zero(), other_rem.is_zero())
                        {
                            ( true, true ) => cmp::Ordering::Equal,
                            ( true, false ) => cmp::Ordering::Less,
                            ( false, true ) => cmp::Ordering::Greater,
                            ( false, false ) =>
                            {
                                let self_recip = Ratio::new_raw( self.denom.clone(), self_rem );
                                let other_recip = Ratio::new_raw( other.denom.clone(), other_rem );
                                self_recip.cmp( &other_recip).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T>
        {
            #[inline] fn partial_cmp( &self, other: &Self ) -> Option<cmp::Ordering> { Some( self.cmp( other) ) }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T>
        {
            #[inline] fn eq( &self, other: &Self ) -> bool { self.cmp( other ) == cmp::Ordering::Equal }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}
        
        impl<T: Clone + Integer + Hash> Hash for Ratio<T>
        {
            fn hash<H: Hasher>( &self, state: &mut H)
            {
                recurse( &self.numer, &self.denom, state );
                
                fn recurse<T: Integer + Hash, H: Hasher>( numer: &T, denom: &T, state: &mut H)
                {
                    if !denom.is_zero()
                    {
                        let ( int, rem ) = numer.div_mod_floor( denom );
                        int.hash( state );
                        recurse( denom, &rem, state );
                    }

                    else { denom.hash( state ); }
                }
            }
        }
        
        forward_all_binop!( impl Mul, mul );
        
        impl<T> Mul<Ratio<T>> for Ratio<T> where
        T: Clone + Integer
        {
            type Output = Ratio<T>;
            /// a/b * c/d = ( a/gcd_ad)*( c/gcd_bc ) / ( ( d/gcd_ad)*( b/gcd_bc))
            #[inline] fn mul( self, rhs: Ratio<T> ) -> Ratio<T>
            {
                let gcd_ad = self.numer.gcd( &rhs.denom );
                let gcd_bc = self.denom.gcd( &rhs.numer );
                Ratio::new
                ( 
                    self.numer / gcd_ad.clone() * ( rhs.numer / gcd_bc.clone()),
                    self.denom / gcd_bc * ( rhs.denom / gcd_ad),
                )
            }
        }
        
        impl<T> Mul<T> for Ratio<T> where
        T: Clone + Integer
        {
            type Output = Ratio<T>;
            /// a/b * c/1 = ( a*c ) / ( b*1 ) = ( a*c ) / b
            #[inline] fn mul( self, rhs: T ) -> Ratio<T>
            {
                let gcd = self.denom.gcd( &rhs );
                Ratio::new( self.numer * ( rhs / gcd.clone()), self.denom / gcd)
            }
        }

        forward_all_binop!( impl Div, div );
        
        impl<T> Div<Ratio<T>> for Ratio<T> where
        T: Clone + Integer
        {
            type Output = Ratio<T>;
            /// ( a/b ) / ( c/d ) = ( a/gcd_ac)*( d/gcd_bd ) / ( ( c/gcd_ac)*( b/gcd_bd))
            #[inline] fn div( self, rhs: Ratio<T> ) -> Ratio<T>
            {
                let gcd_ac = self.numer.gcd( &rhs.numer );
                let gcd_bd = self.denom.gcd( &rhs.denom );
                Ratio::new
                ( 
                    self.numer / gcd_ac.clone() * ( rhs.denom / gcd_bd.clone()),
                    self.denom / gcd_bd * ( rhs.numer / gcd_ac),
                )
            }
        }
        
        impl<T> Div<T> for Ratio<T> where
        T: Clone + Integer
        {
            type Output = Ratio<T>;
            /// ( a/b ) / ( c/1 ) = ( a*1 ) / ( b*c ) = a / ( b*c)
            #[inline] fn div( self, rhs: T ) -> Ratio<T>
            {
                let gcd = self.numer.gcd( &rhs );
                Ratio::new( self.numer / gcd.clone(), self.denom * ( rhs / gcd))
            }
        }

        arith_impl!( impl Add, add );
        arith_impl!( impl Sub, sub );
        arith_impl!( impl Rem, rem );
        
        impl<T> CheckedMul for Ratio<T> where
        T: Clone + Integer + CheckedMul
        {
            /// a/b * c/d = ( a*c)/( b*d)
            #[inline] fn checked_mul( &self, rhs: &Ratio<T> ) -> Option<Ratio<T>>
            {
                let gcd_ad = self.numer.gcd( &rhs.denom );
                let gcd_bc = self.denom.gcd( &rhs.numer );
                Some( Ratio::new
                ( 
                    ( self.numer.clone() / gcd_ad.clone()).checked_mul( &( rhs.numer.clone() / gcd_bc.clone()))?,
                    ( self.denom.clone() / gcd_bc).checked_mul( &( rhs.denom.clone() / gcd_ad))?,
                ))
            }
        }
        
        impl<T> CheckedDiv for Ratio<T> where
        T: Clone + Integer + CheckedMul
        {
            /// ( a/b ) / ( c/d ) = ( a*d)/( b*c)
            #[inline] fn checked_div( &self, rhs: &Ratio<T> ) -> Option<Ratio<T>>
            {
                if rhs.is_zero() { return None; }

                let ( numer, denom ) = if self.denom == rhs.denom { ( self.numer.clone(), rhs.numer.clone()) }

                else if self.numer == rhs.numer { ( rhs.denom.clone(), self.denom.clone()) }

                else
                {
                    let gcd_ac = self.numer.gcd( &rhs.numer );
                    let gcd_bd = self.denom.gcd( &rhs.denom );
                    ( 
                        ( self.numer.clone() / gcd_ac.clone()).checked_mul( &( rhs.denom.clone() / gcd_bd.clone()))?,
                        ( self.denom.clone() / gcd_bd).checked_mul( &( rhs.numer.clone() / gcd_ac))?,
                    )
                };
                
                if denom.is_zero() { None }
                else if numer.is_zero() { Some( Self::zero()) }
                else if numer == denom { Some( Self::one()) }
                
                else
                {
                    let g = numer.gcd( &denom );
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero()
                    {
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw( numer.checked_mul( &n1)?, denom.checked_mul( &n1)?)
                    }

                    else { Ratio::new_raw( numer, denom) };
                    
                    Some( raw)
                }
            }
        }
        
        checked_arith_impl!( impl CheckedAdd, checked_add );
        checked_arith_impl!( impl CheckedSub, checked_sub );

        impl<T> Neg for Ratio<T> where
        T: Clone + Integer + Neg<Output = T>
        {
            type Output = Ratio<T>;
            #[inline] fn neg( self ) -> Ratio<T> { Ratio::new_raw( -self.numer, self.denom ) }
        }

        impl<'a, T> Neg for &'a Ratio<T> where
        T: Clone + Integer + Neg<Output = T>
        {
            type Output = Ratio<T>;
            #[inline] fn neg( self ) -> Ratio<T> { -self.clone() }
        }

        impl<T> Inv for Ratio<T> where
        T: Clone + Integer
        {
            type Output = Ratio<T>;
            #[inline] fn inv( self ) -> Ratio<T> { self.recip() }
        }

        impl<'a, T> Inv for &'a Ratio<T> where
        T: Clone + Integer
        {
            type Output = Ratio<T>;
            #[inline] fn inv( self ) -> Ratio<T> { self.recip() }
        }
        
        impl<T: ConstZero + ConstOne> Ratio<T>
        {
            /// A constant `Ratio` 0/1.
            pub const ZERO: Self = Self::new_raw( T::ZERO, T::ONE );
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T>
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T>
        {
            #[inline] fn zero() -> Ratio<T> { Ratio::new_raw( Zero::zero(), One::one() ) }

            #[inline] fn is_zero( &self ) -> bool { self.numer.is_zero() }

            #[inline] fn set_zero( &mut self)
            {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T>
        {
            /// A constant `Ratio` 1/1.
            pub const ONE: Self = Self::new_raw( T::ONE, T::ONE );
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T>
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T>
        {
            #[inline] fn one() -> Ratio<T> { Ratio::new_raw( One::one(), One::one() ) }

            #[inline] fn is_one( &self ) -> bool { self.numer == self.denom }

            #[inline] fn set_one( &mut self)
            {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T>
        {
            type FromStrRadixErr = ParseRatioError;
            /// Parses `numer/denom` where the numbers are in base `radix`.
            fn from_str_radix( s: &str, radix: u32 ) -> Result<Ratio<T>, ParseRatioError>
            {
                if s.splitn( 2, '/').count() == 2
                {
                    let mut parts = s.splitn( 2, '/').map( |ss|
                    {
                        T::from_str_radix( ss, radix).map_err( |_| ParseRatioError
                        {
                            kind: RatioErrorKind::ParseError,
                        })
                    });

                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero()
                    {
                        Err( ParseRatioError
                        {
                            kind: RatioErrorKind::ZeroDenominator,
                        })
                    }

                    else { Ok( Ratio::new( numer, denom) ) }
                } 
                
                else
                {
                    Err( ParseRatioError
                    {
                        kind: RatioErrorKind::ParseError,
                    })
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T>
        {
            #[inline] fn abs( &self ) -> Ratio<T>
            {
                if self.is_negative() { -self.clone() }
                else { self.clone() }
            }

            #[inline] fn abs_sub( &self, other: &Ratio<T> ) -> Ratio<T>
            {
                if *self <= *other { Zero::zero() }
                else { self - other }
            }

            #[inline] fn signum( &self ) -> Ratio<T>
            {
                if self.is_positive() { Self::one() }
                else if self.is_zero() { Self::zero() }
                else { -Self::one() }
            }

            #[inline] fn is_positive( &self ) -> bool
            {
                ( self.numer.is_positive() && self.denom.is_positive())
                || ( self.numer.is_negative() && self.denom.is_negative())
            }

            #[inline] fn is_negative( &self ) -> bool
            {
                ( self.numer.is_negative() && self.denom.is_positive())
                || ( self.numer.is_positive() && self.denom.is_negative())
            }
        }

        impl_formatting!( Display, "", "{}", "{:#}" );
        impl_formatting!( Octal, "0o", "{:o}", "{:#o}" );
        impl_formatting!( Binary, "0b", "{:b}", "{:#b}" );
        impl_formatting!( LowerHex, "0x", "{:x}", "{:#x}" );
        impl_formatting!( UpperHex, "0x", "{:X}", "{:#X}" );
        impl_formatting!( LowerExp, "", "{:e}", "{:#e}" );
        impl_formatting!( UpperExp, "", "{:E}", "{:#E}" );

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T>
        {
            type Err = ParseRatioError;
            /// Parses `numer/denom` or just `numer`.
            fn from_str( s: &str ) -> Result<Ratio<T>, ParseRatioError>
            {
                let mut split = s.splitn( 2, '/' );

                let n = split.next().ok_or( ParseRatioError
                {
                    kind: RatioErrorKind::ParseError,
                })?;
                
                let num = FromStr::from_str( n).map_err( |_| ParseRatioError
                {
                    kind: RatioErrorKind::ParseError,
                })?;

                let d = split.next().unwrap_or( "1" );
                let den = FromStr::from_str( d).map_err( |_| ParseRatioError
                {
                    kind: RatioErrorKind::ParseError,
                })?;

                if Zero::is_zero( &den )
                {
                    Err( ParseRatioError
                    {
                        kind: RatioErrorKind::ZeroDenominator,
                    })
                }
                
                else { Ok( Ratio::new( num, den)) }
            }
        }

        impl<T> From<Ratio<T>> for ( T, T)
        {
            fn from( val: Ratio<T> ) -> Self { ( val.numer, val.denom ) }
        }
        
        #[derive( Copy, Clone, Debug, PartialEq)]
        pub struct ParseRatioError
        {
            kind: RatioErrorKind,
        }

        #[derive( Copy, Clone, Debug, PartialEq)]
        enum RatioErrorKind
        {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError
        {
            fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result { self.kind.description().fmt( f ) }
        }
        
        impl Error for ParseRatioError
        {
            #[allow( deprecated)] fn description( &self ) -> &str { self.kind.description() }
        }

        impl RatioErrorKind
        {
            fn description( &self ) -> &'static str
            {
                match *self
                {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }
        
        impl FromPrimitive for Ratio<BigInt>
        {
            fn from_i64( n: i64 ) -> Option<Self> { Some( Ratio::from_integer( n.into())) }

            fn from_i128( n: i128 ) -> Option<Self> { Some( Ratio::from_integer( n.into())) }

            fn from_u64( n: u64 ) -> Option<Self> { Some( Ratio::from_integer( n.into())) }

            fn from_u128( n: u128 ) -> Option<Self> { Some( Ratio::from_integer( n.into())) }

            fn from_f32( n: f32 ) -> Option<Self> { Ratio::from_float( n) }

            fn from_f64( n: f64 ) -> Option<Self> { Ratio::from_float( n) }
        }

        from_primitive_integer!( i8, approximate_float );
        from_primitive_integer!( i16, approximate_float );
        from_primitive_integer!( i32, approximate_float );
        from_primitive_integer!( i64, approximate_float );
        from_primitive_integer!( i128, approximate_float );
        from_primitive_integer!( isize, approximate_float );
        from_primitive_integer!( u8, approximate_float_unsigned );
        from_primitive_integer!( u16, approximate_float_unsigned );
        from_primitive_integer!( u32, approximate_float_unsigned );
        from_primitive_integer!( u64, approximate_float_unsigned );
        from_primitive_integer!( u128, approximate_float_unsigned );
        from_primitive_integer!( usize, approximate_float_unsigned );

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float<F: FloatCore + NumCast>( f: F ) -> Option<Ratio<T>>
            {
                let epsilon = <F as NumCast>::from( 10e-20 ).expect( "Can't convert 10e-20" );
                approximate_float( f, epsilon, 30 )
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>( f: F ) -> Option<Ratio<T>>
            {
                let epsilon = <F as NumCast>::from( 10e-20 ).expect( "Can't convert 10e-20" );
                approximate_float_unsigned( f, epsilon, 30 )
            }
        }

        fn approximate_float<T, F>( val: F, max_error: F, max_iterations: usize ) -> Option<Ratio<T>> where
        T: Integer + Signed + Bounded + NumCast + Clone,
        F: FloatCore + NumCast
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();
            let r = approximate_float_unsigned( abs_val, max_error, max_iterations)?;
            Some( if negative { r.neg() } else { r })
        }
        /// Continued fractions algorithm
        /// https://web.archive.org/web/20200629111319/http://mathforum.org:80/dr.math/faq/faq.fractions.html#decfrac
        fn approximate_float_unsigned<T, F>( val: F, max_error: F, max_iterations: usize ) -> Option<Ratio<T>> where
        T: Integer + Bounded + NumCast + Clone,
        F: FloatCore + NumCast
        {
            if val < F::zero() || val.is_nan() { return None; }

            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();
            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from( t_max.clone())?;            
            let epsilon = t_max_f.recip();
            
            if q > t_max_f { return None; }

            for _ in 0..max_iterations
            {
                let a = match <T as NumCast>::from( q )
                {
                    None => break,
                    Some( a ) => a,
                };

                let a_f = match <F as NumCast>::from( a.clone() )
                {
                    None => break,
                    Some( a_f ) => a_f,
                };
                
                let f = q - a_f;
                
                if !a.is_zero()
                && ( n1 > t_max.clone() / a.clone()
                || d1 > t_max.clone() / a.clone()
                || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                || a.clone() * d1.clone() > t_max.clone() - d0.clone())
                {
                    break;
                }

                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();
                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();                
                let g = Integer::gcd( &n1, &d1 );

                if !g.is_zero()
                {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }
                
                let ( n_f, d_f ) = match ( <F as NumCast>::from( n), <F as NumCast>::from( d) )
                {
                    ( Some( n_f), Some( d_f) ) => ( n_f, d_f),
                    _ => break,
                };

                if ( n_f / d_f - val).abs() < max_error { break; }
                
                if f < epsilon { break; }

                q = f.recip();
            }
            
            if d1.is_zero() { return None; }

            Some( Ratio::new( n1, d1))
        }
        
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T>
        {
            fn to_i64( &self ) -> Option<i64> { self.to_integer().to_i64() }

            fn to_i128( &self ) -> Option<i128> { self.to_integer().to_i128() }

            fn to_u64( &self ) -> Option<u64> { self.to_integer().to_u64() }

            fn to_u128( &self ) -> Option<u128> { self.to_integer().to_u128() }

            fn to_f64( &self ) -> Option<f64>
            {
                let float = match ( self.numer.to_i64(), self.denom.to_i64() )
                {
                    ( Some( numer), Some( denom) ) => ratio_to_f64
                    ( 
                        <i128 as From<_>>::from( numer),
                        <i128 as From<_>>::from( denom),
                    ),
                    _ =>
                    {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64( numer, denom)
                    }
                };

                if float.is_nan() { None } else { Some( float) }
            }
        }

        trait Bits
        {
            fn bits( &self ) -> u64;
        }
        
        impl Bits for BigInt
        {
            fn bits( &self ) -> u64 { self.bits() }
        }

        impl Bits for i128
        {
            fn bits( &self ) -> u64 { ( 128 - self.wrapping_abs().leading_zeros()).into() }
        }
        /// Converts a ratio of `T` to an f64.
        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>
        ( numer: T, denom: T ) -> f64
        {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!( RADIX, 2, "only floating point implementations with radix 2 are supported" );
            
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() { return flo_sign; }
            
            if let ( Some( n), Some( d) ) = ( numer.to_i64(), denom.to_i64() )
            {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                
                if exact.contains( &n ) && exact.contains( &d ) { return n.to_f64().unwrap() / d.to_f64().unwrap(); }
            }
            
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let ( is_diff_positive, absolute_diff ) = match numer.bits().checked_sub( denom.bits() )
            {
                Some( diff ) => ( true, diff),
                None => ( false, denom.bits() - numer.bits()),
            };
            
            if is_diff_positive && absolute_diff > MAX_EXP as u64 { return INFINITY * flo_sign; }

            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 
            { return 0.0 * flo_sign; }
            
            let diff = if is_diff_positive { absolute_diff.to_isize().unwrap() }
            else { -absolute_diff.to_isize().unwrap() };
            
            let shift: isize = diff.max( MIN_EXP as isize ) - MANTISSA_DIGITS as isize - 2;

            if shift >= 0 { denom <<= shift as usize } 
            else { numer <<= -shift as usize };

            let ( quotient, remainder ) = numer.div_rem( &denom );
            
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits =
            {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max( subnormal_bits ) - MANTISSA_DIGITS as isize
            } as usize;
            
            debug_assert!( n_rounding_bits == 2 || n_rounding_bits == 3 );
            let rounding_bit_mask = ( 1u64 << n_rounding_bits ) - 1;
            
            let ls_bit = quotient & ( 1u64 << n_rounding_bits ) != 0;
            let ms_rounding_bit = quotient & ( 1u64 << ( n_rounding_bits - 1) ) != 0;
            let ls_rounding_bits = quotient & ( rounding_bit_mask >> 1 ) != 0;
            
            if ms_rounding_bit && ( ls_bit || ls_rounding_bits || !remainder.is_zero() )
            { quotient += 1u64 << n_rounding_bits; }

            quotient &= !rounding_bit_mask;
            let q_float = quotient as f64 * flo_sign;
            ldexp( q_float, shift as i32)
        }
        /// Multiply `x` by 2 to the power of `exp`.
        fn ldexp( x: f64, exp: i32 ) -> f64 
        {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!( RADIX, 2, "only floating point implementations with radix 2 are supported" );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() { return x; }
            
            if exp > 3 * MAX_EXP { return INFINITY * x.signum(); }
            else if exp < -3 * MAX_EXP { return 0.0 * x.signum(); }
            
            let ( bits, curr_exp ) = if !x.is_normal()
            {
                let normal_x = x * 2f64.powi( MIN_SUBNORMAL_POWER );
                let bits = normal_x.to_bits();
                ( bits, ( ( bits & EXPONENT_MASK ) >> 52 ) as i32 - MIN_SUBNORMAL_POWER )
            }
            
            else
            {
                let bits = x.to_bits();
                let curr_exp = ( bits & EXPONENT_MASK ) >> 52;
                ( bits, curr_exp as i32)
            };
            
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT { INFINITY * x.signum() }
            else if new_exp > 0
            {
                let new_bits = ( bits & !EXPONENT_MASK ) | ( ( new_exp as u64 ) << 52 );
                f64::from_bits( new_bits)
            }

            else if new_exp >= -( MANTISSA_DIGITS as i32 )
            {
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!( new_exp >= 0 );
                let new_bits = ( bits & !EXPONENT_MASK ) | ( ( new_exp as u64 ) << 52 );
                f64::from_bits( new_bits ) * 2f64.powi( -MIN_SUBNORMAL_POWER)
            }

            else { return 0.0 * x.signum(); }
        }
    } 
    pub use self::rational::{ BigRational };

    pub mod traits
    {
        pub use ::
        {
            num_traits::{ * },
        };
    }
}
/// Overloadable operators.
pub mod ops
{
    pub use std::ops::{ * };
    /// Implemented for built-in range types
    pub trait RangeArgument<T>
    {
        /// Returns the start of range, if present.
        fn start(&self) -> Option<&T> { None }
        /// Returns the end of range, if present.
        fn end(&self) -> Option<&T> { None }
    }

    impl<T> RangeArgument<T> for Range<T>
    {
        fn start(&self) -> Option<&T> { Some(&self.start) }
        fn end(&self) -> Option<&T> { Some(&self.end) }
    }

    impl<T> RangeArgument<T> for RangeFrom<T>
    {
        fn start(&self) -> Option<&T> { Some(&self.start) }
    }

    impl<T> RangeArgument<T> for RangeTo<T>
    {
        fn end(&self) -> Option<&T> { Some(&self.end) }
    }

    impl<T> RangeArgument<T> for RangeFull {}
}
/// Optional values.
pub mod option
{
    pub use std::option::{ * };
}
/// OS-specific functionality.
pub mod os
{
    //! OS-specific functionality.
    pub use std::os::{ * };
    pub mod windows
    {
        //! Platform-specific extensions to `std` for Windows.
        use ::
        {
            *,
        };

        pub mod ffi
        {
            //! Windows-specific extensions to primitives in the [`std::ffi`] module.
            use ::
            {
                ffi::{OsStr, OsString},
                sealed::Sealed,
                system::
                {

                    common::wtf8::EncodeWide,
                    common::wtf8::Wtf8Buf,
                    common::{AsInner, FromInner},
                    os_str::{ Buf },
                },
                *,
            };
            /// Windows-specific extensions to [`OsString`].
            pub trait OsStringExt: Sealed
            {
                /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units.
                fn from_wide(wide: &[u16]) -> Self;
            }
            
            impl OsStringExt for OsString
            {
                fn from_wide(wide: &[u16]) -> OsString
                { FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) }) }
            }

            /// Windows-specific extensions to [`OsStr`].
            pub trait OsStrExt: Sealed
            {
                /// Re-encodes an `OsStr` as a wide character sequence, i.e., potentially ill-formed UTF-16.
                fn encode_wide(&self) -> EncodeWide<'_>;
            }
            
            impl OsStrExt for OsStr
            {
                #[inline] fn encode_wide(&self) -> EncodeWide<'_> { self.as_inner().inner.encode_wide() }
            }
        }

        pub mod fs
        {
            //! Windows-specific extensions to primitives in the [`std::fs`] module.
            use ::
            {
                fs::{ self, Metadata, OpenOptions },
                path::{ Path },
                sealed::{ Sealed },
                system::
                {
                    common::{ AsInner, AsInnerMut, IntoInner },
                },
                time::SystemTime,
                *,
            };
            /// Windows-specific extensions to [`fs::File`].
            pub trait FileExt
            {
                /// Seeks to a given position and reads a number of bytes.
                fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;
                /// Seeks to a given position and writes a number of bytes.
                fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>;
            }
            
            impl FileExt for fs::File
            {
                fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>
                { self.as_inner().read_at(buf, offset) }

                fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>
                { self.as_inner().write_at(buf, offset) }
            }
            /// Windows-specific extensions to [`fs::OpenOptions`].
            pub trait OpenOptionsExt
            {
                /// Overrides the `dwDesiredAccess` argument to the call to [`CreateFile`]
                /// with the specified value.
                fn access_mode(&mut self, access: u32) -> &mut Self;

                /// Overrides the `dwShareMode` argument to the call to [`CreateFile`] with
                /// the specified value.
                fn share_mode(&mut self, val: u32) -> &mut Self;
                /// Sets extra flags for the `dwFileFlags` argument to the call to
                /// [`CreateFile2`] to the specified value (or combines it with
                /// `attributes` and `security_qos_flags` to set the `dwFlagsAndAttributes`
                /// for [`CreateFile`]).
                fn custom_flags(&mut self, flags: u32) -> &mut Self;
                /// Sets the `dwFileAttributes` argument to the call to [`CreateFile2`] to
                /// the specified value (or combines it with `custom_flags` and
                /// `security_qos_flags` to set the `dwFlagsAndAttributes` for
                /// [`CreateFile`]).
                fn attributes(&mut self, val: u32) -> &mut Self;
                /// Sets the `dwSecurityQosFlags` argument to the call to [`CreateFile2`] to
                /// the specified value (or combines it with `custom_flags` and `attributes`
                /// to set the `dwFlagsAndAttributes` for [`CreateFile`]).
                fn security_qos_flags(&mut self, flags: u32) -> &mut Self;
            }
            
            impl OpenOptionsExt for OpenOptions
            {
                fn access_mode(&mut self, access: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().access_mode(access);
                    self
                }

                fn share_mode(&mut self, share: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().share_mode(share);
                    self
                }

                fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().custom_flags(flags);
                    self
                }

                fn attributes(&mut self, attributes: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().attributes(attributes);
                    self
                }

                fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions 
                {
                    self.as_inner_mut().security_qos_flags(flags);
                    self
                }
            }
            /// Windows-specific extensions to [`fs::Metadata`].
            pub trait MetadataExt
            {
                /// Returns the value of the `dwFileAttributes` field of this metadata.
                fn file_attributes(&self) -> u32;
                /// Returns the value of the `ftCreationTime` field of this metadata.
                fn creation_time(&self) -> u64;
                /// Returns the value of the `ftLastAccessTime` field of this metadata.
                fn last_access_time(&self) -> u64;
                /// Returns the value of the `ftLastWriteTime` field of this metadata.
                fn last_write_time(&self) -> u64;
                /// Returns the value of the `nFileSize` fields of this metadata.
                fn file_size(&self) -> u64;
                /// Returns the value of the `dwVolumeSerialNumber` field of this metadata.
                fn volume_serial_number(&self) -> Option<u32>;
                /// Returns the value of the `nNumberOfLinks` field of this metadata.
                fn number_of_links(&self) -> Option<u32>;
                /// Returns the value of the `nFileIndex` fields of this metadata.
                fn file_index(&self) -> Option<u64>;
                /// Returns the value of the `ChangeTime` fields of this metadata.
                fn change_time(&self) -> Option<u64>;
            }
            
            impl MetadataExt for Metadata
            {
                fn file_attributes(&self) -> u32 {
                    self.as_inner().attrs()
                }
                fn creation_time(&self) -> u64 {
                    self.as_inner().created_u64()
                }
                fn last_access_time(&self) -> u64 {
                    self.as_inner().accessed_u64()
                }
                fn last_write_time(&self) -> u64 {
                    self.as_inner().modified_u64()
                }
                fn file_size(&self) -> u64 {
                    self.as_inner().size()
                }
                fn volume_serial_number(&self) -> Option<u32> {
                    self.as_inner().volume_serial_number()
                }
                fn number_of_links(&self) -> Option<u32> {
                    self.as_inner().number_of_links()
                }
                fn file_index(&self) -> Option<u64> {
                    self.as_inner().file_index()
                }
                fn change_time(&self) -> Option<u64> {
                    self.as_inner().changed_u64()
                }
            }
            /// Windows-specific extensions to [`fs::FileType`].
            pub trait FileTypeExt: Sealed
            {
                /// Returns `true` if this file type is a symbolic link that is also a directory.
                fn is_symlink_dir(&self) -> bool;
                /// Returns `true` if this file type is a symbolic link that is also a file.
                fn is_symlink_file(&self) -> bool;
            }
            
            impl Sealed for fs::FileType {}
            
            impl FileTypeExt for fs::FileType
            {
                fn is_symlink_dir(&self) -> bool { self.as_inner().is_symlink_dir() }

                fn is_symlink_file(&self) -> bool { self.as_inner().is_symlink_file() }
            }
            /// Windows-specific extensions to [`fs::FileTimes`].
            pub trait FileTimesExt: Sealed
            {
                /// Set the creation time of a file.
                fn set_created(self, t: SystemTime) -> Self;
            }
            
            impl FileTimesExt for fs::FileTimes
            {
                fn set_created(mut self, t: SystemTime) -> Self {
                    self.as_inner_mut().set_created(t.into_inner());
                    self
                }
            }
            /// Creates a new symlink to a non-directory file on the filesystem.
            pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()>
            {
                sys::fs::symlink_inner(original.as_ref(), link.as_ref(), false)
            }
            /// Creates a new symlink to a directory on the filesystem.
            pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()>
            {
                sys::fs::symlink_inner(original.as_ref(), link.as_ref(), true)
            }
            /// Creates a junction point.
            pub fn junction_point<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()>
            {
                sys::fs::junction_point(original.as_ref(), link.as_ref())
            }
        }

        pub mod io
        {
            use ::
            {
                *,
            };
        }

        pub mod process
        {
            use ::
            {
                *,
            };
        }

        pub mod raw
        {
            use ::
            {
                *,
            };
        }

        pub mod thread
        {
            use ::
            {
                *,
            };
        }
    }
}
/// Panic support in the standard library.
pub mod panic
{
    pub use std::panic::{ * };
}
/**/
pub mod parsers
{
    pub mod line
    {
        use ::
        {
            primitive::{ LineInfo, Redirection, Tokens },
            regex::{ contains, Regex },
            *,
        };
        /// Parse command line to tokens.
        /// pub fn parse_line( ... ) -> LineInfo
        pub fn parse( line:&str ) -> LineInfo
        {
            let mut result = Vec::new();
            if is::arithmetic( line )
            {
                for x in line.split( ' ' )
                {
                    result.push( ( String::from( "" ), x.to_string() ) );
                }
                
                return LineInfo::new( result );
            }

            let mut sep = String::new();
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;
            let mut sep_made = String::new();
            let mut semi_ok = false;
            let count_chars = line.chars().count();

            for ( i, c ) in line.chars().enumerate()
            {
                if skip_next
                {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && ( c == '>' || c == '<' )
                {
                    sep_made = String::from( "'" );
                    token.push( c );
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"'
                {
                    token.push( '\\' );
                    token.push( c );
                    has_backslash = false;
                    continue;
                }

                if has_backslash
                {
                    if new_round && sep.is_empty() && ( c == '|' || c == '$' ) && token.is_empty()
                    {
                        sep = String::from( "\\" );
                        token = format!( "{}", c );
                    }
                    
                    else { token.push( c ); }
                    
                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' { has_dollar = true; }
                
                if c == '(' && sep.is_empty()
                {
                    if !has_dollar && token.is_empty()
                    {
                        parens_left_ignored = true;
                        continue;
                    }

                    met_parenthesis = true;
                }

                if c == ')'
                {
                    if parens_left_ignored && !has_dollar
                    {
                        if i == count_chars - 1 || ( i + 1 < count_chars && line.chars().nth( i + 1 ).unwrap() == ' ' )
                        { continue; }
                    }

                    if sep.is_empty() { met_parenthesis = false; }
                }

                if c == '\\'
                {
                    if sep == "'" || !sep_second.is_empty() { token.push( c ) }
                    else { has_backslash = true; }
                    continue;
                }

                if new_round
                {
                    if c == ' ' { continue; }
                    else if c == '"' || c == '\'' || c == '`'
                    {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' { break; }

                    if c == '|'
                    {
                        if i + 1 < count_chars && line.chars().nth( i + 1 ).unwrap() == '|'
                        {
                            result.push( ( String::from( "" ), "||".to_string() ) );
                            skip_next = true;
                        }
                        else { result.push( ( String::from( "" ), "|".to_string() ) ); }

                        new_round = true;
                        continue;
                    }

                    token.push( c );
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        }
                        else { result.push( ( sep.to_string(), token ) ); }

                        result.push( ( String::from( "" ), "|".to_string() ) );
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }
                    else if !met_parenthesis && sep_second.is_empty() && sep.is_empty()
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        } else {
                            result.push( ( String::from( "" ), token ) );
                        }
                        result.push( ( String::from( "" ), "|".to_string() ) );
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' '
                {
                    if semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        }
                        else { result.push( ( sep.to_string(), token ) ); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash
                    {
                        has_backslash = false;
                        token.push( c );
                        continue;
                    }

                    if met_parenthesis
                    {
                        token.push( c );
                        continue;
                    }

                    if sep == "\\"
                    {
                        result.push( ( String::from( "\\" ), token ) );
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty()
                    {
                        if sep_second.is_empty()
                        {
                            if sep.is_empty() && !sep_made.is_empty()
                            {
                                result.push( ( sep_made.clone(), token ) );
                                sep_made = String::new();
                            }
                            else { result.push( ( String::from( "" ), token ) ); }
                            token = String::new();
                            new_round = true;
                            continue;
                        }
                        
                        else
                        {
                            token.push( c );
                            continue;
                        }
                    }
                    
                    else
                    {
                        token.push( c );
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`'
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        token.push( c );
                        continue;
                    }

                    if sep != c.to_string() && semi_ok
                    {
                        if sep.is_empty() && !sep_made.is_empty()
                        {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        }

                        else { result.push( ( sep.to_string(), token ) ); }

                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                    }

                    if sep != c.to_string() && met_parenthesis
                    {
                        token.push( c );
                        continue;
                    }
                    
                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string()
                    {
                        token.push( c );
                        continue;
                    }

                    if sep.is_empty()
                    {
                        let is_an_env = regex::contains( &token, r"^[a-zA-Z0-9_]+=.*$" );
                        if !is_an_env && ( c == '\'' || c == '"' )
                        {
                            sep = c.to_string();
                            continue;
                        }

                        token.push( c );

                        if sep_second.is_empty() { sep_second = c.to_string(); }                        
                        else if sep_second == c.to_string() { sep_second = String::new(); }

                        continue;
                    }
                    
                    else if sep == c.to_string()
                    {
                        semi_ok = true;
                        continue;
                    }

                    else { token.push( c ); }
                }

                else
                {
                    if has_backslash
                    {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" { token.push( '\\' ); }
                    }

                    token.push( c );
                }
            }
            
            if !token.is_empty() || semi_ok
            {
                if sep.is_empty() && !sep_made.is_empty() { result.push( ( sep_made.clone(), token ) ); }
                else { result.push( ( sep.clone(), token ) ); }
            }

            let mut is_line_complete = true;

            if !result.is_empty()
            {
                let token_last = result[result.len() - 1].clone();
                
                if token_last.0.is_empty() && token_last.1 == "|" { is_line_complete = false; }
            }

            if !sep.is_empty() { is_line_complete = semi_ok; }
            
            if has_backslash { is_line_complete = false; }

            LineInfo { tokens: result, is_complete: is_line_complete }
        }
        //  pub fn line_to_cmds( ... ) -> Vec<String>
        /// Parse command line for multiple commands.
        pub fn to_cmds( line:&str ) -> Vec<String>
        {
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();

            for ( i, c ) in line.chars().enumerate()
            {
                if has_backslash
                {
                    token.push( '\\' );
                    token.push( c );
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'"
                {
                    has_backslash = true;
                    continue;
                }

                if c == '#'
                {
                    if sep.is_empty() { break; }
                    else
                    {
                        token.push( c );
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`'
                {
                    if sep.is_empty()
                    {
                        sep.push( c );
                        token.push( c );
                        continue;
                    }
                    
                    else if sep == c.to_string()
                    {
                        token.push( c );
                        sep = String::new();
                        continue;
                    }
                    
                    else
                    {
                        token.push( c );
                        continue;
                    }
                }

                if c == '&' || c == '|'
                {
                    if sep.is_empty()
                    {
                        if i + 1 == len
                        {
                            token.push( c );
                            continue;
                        }
                        
                        else
                        {
                            let c_next = match line.chars().nth( i + 1 )
                            {
                                Some( x ) => x,
                                None =>
                                {
                                    println!( "chars nth error - should never happen" );
                                    continue;
                                }
                            };

                            if c_next != c
                            {
                                token.push( c );
                                continue;
                            }
                        }
                    }

                    if sep.is_empty()
                    {
                        sep.push( c );
                        continue;
                    }
                    
                    else if c.to_string() == sep
                    {
                        let _token = token.trim().to_string();
                        
                        if !_token.is_empty() { result.push( _token ); }

                        token = String::new();
                        result.push( format!( "{}{}", sep, sep ) );
                        sep = String::new();
                        continue;
                    }
                    
                    else
                    {
                        token.push( c );
                        continue;
                    }
                }

                if c == ';'
                {
                    if sep.is_empty()
                    {
                        let _token = token.trim().to_string();
                        
                        if !_token.is_empty() { result.push( _token ); }

                        result.push( String::from( ";" ) );
                        token = String::new();
                        continue;
                    }
                    
                    else
                    {
                        token.push( c );
                        continue;
                    }
                }

                token.push( c );
            }

            if !token.is_empty() { result.push( token.trim().to_string() ); }

            result
        }

        pub fn tokens_to_line(tokens: &Tokens) -> String
        {
            let mut result = String::new();
            for t in tokens
            {
                if t.0.is_empty() { result.push_str(&t.1); }
                
                else
                {
                    let s = string::wrap_separator(&t.0, &t.1);
                    result.push_str(&s);
                }

                result.push(' ');
            }

            if result.ends_with(' ')
            {
                let len = result.len();
                result.truncate(len - 1);
            }

            result
        }

        pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String>
        {
            let mut tokens_new = Vec::new();
            let mut redirects = Vec::new();
            let mut to_be_continued = false;
            let mut to_be_continued_s1 = String::new();
            let mut to_be_continued_s2 = String::new();

            for token in tokens
            {
                let sep = &token.0;
                
                if !sep.is_empty() && !to_be_continued
                {
                    tokens_new.push(token.clone());
                    continue;
                }

                let word = &token.1;

                if to_be_continued
                {
                    if sep.is_empty() && word.starts_with('&')
                    { return Err(String::from("bad redirection syntax near &")); }

                    let s3 = word.to_string();
                    
                    if contains(&to_be_continued_s1, r"^\d+$")
                    {
                        if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" { return Err(String::from("Bad file descriptor #3")); }
                        let s1 = to_be_continued_s1.clone();
                        let s2 = to_be_continued_s2.clone();
                        redirects.push((s1, s2, s3));
                    }

                    else
                    {
                        if !to_be_continued_s1.is_empty()
                        { tokens_new.push((sep.clone(), to_be_continued_s1.to_string())); }
                        
                        redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
                    }

                    to_be_continued = false;
                    continue;
                }

                let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
                let ptn2 = r"^([^>]*)(>>?)$";
                if !contains(word, r">") { tokens_new.push(token.clone()); }
                
                else if contains(word, ptn1)
                {
                    let re;

                    if let Ok(x) = Regex::new(ptn1) { re = x; }
                    else { return Err(String::from("Failed to build Regex")); }

                    if let Some(caps) = re.captures(word)
                    {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();
                        let s3 = caps.get(3).unwrap().as_str();
                        if s3.starts_with('&') && s3 != "&1" && s3 != "&2" { return Err(String::from("Bad file descriptor #1")); }

                        if contains(s1, r"^\d+$")
                        {
                            if s1 != "1" && s1 != "2" { return Err(String::from("Bad file descriptor #2")); }

                            redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
                        }

                        else
                        {
                            if !s1.is_empty() { tokens_new.push((sep.clone(), s1.to_string())); }

                            redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
                        }
                    }
                }
                
                else if contains(word, ptn2)
                {
                    let re;

                    if let Ok(x) = Regex::new(ptn2) { re = x; }

                    else { return Err(String::from("Failed to build Regex")); }

                    if let Some(caps) = re.captures(word)
                    {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();
                        to_be_continued = true;
                        to_be_continued_s1 = s1.to_string();
                        to_be_continued_s2 = s2.to_string();
                    }
                }
            }

            if to_be_continued { return Err(String::from("redirection syntax error")); }

            Ok((tokens_new, redirects))
        }

        pub fn unquote(text: &str) -> String
        {
            let mut new_str = String::from(text);
            for &c in ['"', '\''].iter()
            {
                if text.starts_with(c) && text.ends_with(c)
                {
                    new_str.remove(0);
                    new_str.pop();
                    break;
                }
            }

            new_str
        }
    }

    pub mod over
    {
        //! Module containing parsing functions.
        use ::
        {
            
            collections::{ HashMap, HashSet, VecDeque },
            database::{ Arr, Obj, Tup },
            error::over::
            {
                ParseErrorKind::*,
                parse_err, ParseError,
            },
            io::
            {
                reader::{ read_file_str },
            },
            num::
            {
                big::{ BigInt },
                rational::BigRational,
                traits::{ ToPrimitive, Zero },
            },
            ops::{ Deref },
            parsers::
            {
                over::
                {
                    chars::{ CharStream },
                },
            },
            path::{ Path },
            primitive::{ Type, Value },
            *,
        };
        
        pub mod chars
        {
            //! Character stream used for parsing.
            use ::
            {
                cell::{ RefCell },
                database::{ INDENT_STEP },
                fs::{ File },
                io::{ self, Read },
                iter::{ Peekable },
                rc::{ Rc },
                str::{ Chars },
                *,
            };

            #[derive( Clone, Debug )]
            struct Inner
            {
                file: Option<String>,
                contents: String,
                stream: Peekable<Chars<'static>>,
                line: usize,
                col: usize,
            }

            #[derive( Clone, Debug )]
            pub struct CharStream
            {
                inner: Rc<RefCell<Inner>>,
            }

            impl CharStream
            {
                pub fn from_file( path: &str ) -> io::Result<CharStream>
                {
                    let mut file = File::open( path )?;
                    let len = file.metadata()?.len();
                    let mut contents = String::with_capacity( len as usize );
                    file.read_to_string( &mut contents )?;
                    Self::from_string_impl( Some( String::from( path ) ), contents )
                }

                pub fn from_string( contents: String ) -> io::Result<CharStream>
                { Self::from_string_impl( None, contents ) }

                pub fn peek( &self ) -> Option<char>
                {
                    let mut inner = self.inner.borrow_mut();
                    let opt = inner.stream.peek();

                    match opt
                    {
                        Some( ch ) => Some( *ch ),
                        None => None,
                    }
                }

                pub fn file( &self ) -> Option<String>
                {
                    let inner = self.inner.borrow();
                    inner.file.clone()
                }

                pub fn line( &self ) -> usize
                {
                    let inner = self.inner.borrow();
                    inner.line
                }

                pub fn col( &self ) -> usize
                {
                    let inner = self.inner.borrow();
                    inner.col
                }

                fn from_string_impl( file: Option<String>, contents: String ) -> io::Result<CharStream>
                {
                    let chars: Chars = unsafe { mem::transmute( contents.chars() ) };
                    let stream = chars.peekable();
                    Ok( CharStream
                    {
                        inner: Rc::new( RefCell::new( Inner
                        {
                            file,
                            contents,
                            stream,
                            line: 1,
                            col: 1,
                        } ) ),
                    } )
                }

                fn set_line( &mut self, value: usize )
                {
                    let mut inner = self.inner.borrow_mut();
                    inner.line = value;
                }

                fn set_col( &mut self, value: usize )
                {
                    let mut inner = self.inner.borrow_mut();
                    inner.col = value;
                }
            }

            impl Iterator for CharStream
            {
                type Item = char;
                fn next( &mut self ) -> Option<Self::Item>
                {
                    let opt =
                    {
                        let mut inner = self.inner.borrow_mut();
                        inner.stream.next()
                    };

                    match opt
                    {
                        Some( ch ) =>
                        {
                            if ch == '\n'
                            {
                                let line = self.line();
                                self.set_line( line + 1 );
                                self.set_col( 1 );
                            }
                            
                            else
                            {
                                let col = self.col();
                                self.set_col( col + 1 );
                            }
                            
                            Some( ch )
                        }

                        None => None,
                    }
                }
            }
        } 

        pub mod format
        {
            //! Module containing functions for formatting output of objects.
            use ::
            {
                database::{ INDENT_STEP },
                num::
                {
                    big::{ BigInt },
                    rational::{ BigRational },
                    traits::{ One },
                },
                parsers::
                {
                    over::{ Arr, Obj, Tup },
                },
                primitive::{ Type::{ self, * }, Value },
                *,
            };
            /// Returns a `String` with the given amount of spaces.
            pub fn indent( amount: usize ) -> String { " ".repeat( amount ) }

            fn get_char_map( ch: char ) -> Option<&'static str>
            {
                match ch {
                    '\\' => Some( "\\\\" ),
                    '\"' => Some( "\\\"" ),
                    '\'' => Some( "\\\'" ),
                    '$' => Some( "\\$" ),
                    '\n' => Some( "\\n" ),
                    '\r' => Some( "\\r" ),
                    '\t' => Some( "\\t" ),
                    _ => None,
                }
            }

            fn replace_all( s: &str ) -> String
            {
                let mut string = String::with_capacity( s.len() );

                for ch in s.chars()
                {
                    if let Some( s ) = get_char_map( ch ) {
                        string.push_str( s );
                    } else {
                        string.push( ch );
                    }
                }
                string
            }

            /// Trait for formatting a .over representation of an object.
            pub trait Format {
                fn format( &self, full: bool, indent_amt: usize ) -> String;
            }

            impl Format for BigRational {
                fn format( &self, _full: bool, _indent_amt: usize ) -> String {
                    let frac_fmt = format!( "{}", *self );

                    if *self.denom() == BigInt::one() {
                        format!( "{}.0", frac_fmt )
                    } else {
                        frac_fmt
                    }
                }
            }

            impl Format for char {
                fn format( &self, _full: bool, _indent_amt: usize ) -> String {
                    if let Some( s ) = get_char_map( *self ) {
                        format!( "\'{}\'", s )
                    } else {
                        format!( "\'{}\'", *self )
                    }
                }
            }

            impl Format for String {
                fn format( &self, _full: bool, _indent_amt: usize ) -> String {
                    format!( "\"{}\"", replace_all( self ) )
                }
            }

            impl Format for Value {
                fn format( &self, _full: bool, indent_amt: usize ) -> String {
                    match *self {
                        Value::Null => String::from( "null" ),

                        Value::Bool( ref inner ) => {
                            if *inner {
                                String::from( "true" )
                            } else {
                                String::from( "false" )
                            }
                        }

                        Value::Int( ref inner ) => format!( "{}", inner ),

                        Value::Frac( ref inner ) => inner.format( true, indent_amt ),
                        Value::Char( ref inner ) => inner.format( true, indent_amt ),
                        Value::Str( ref inner ) => inner.format( true, indent_amt ),
                        Value::Arr( ref inner ) => inner.format( true, indent_amt ),
                        Value::Tup( ref inner ) => inner.format( true, indent_amt ),
                        Value::Obj( ref inner ) => inner.format( true, indent_amt ),
                    }
                }
            }

            impl Format for Arr {
                fn format( &self, full: bool, indent_amt: usize ) -> String {
                    match self.len() {
                        0 => {
                            if full {
                                String::from( "[]" )
                            } else {
                                String::new()
                            }
                        }
                        1 => {
                            let f = self.get( 0 ).unwrap().format( true, indent_amt );
                            if full {
                                format!( "[{}]", f )
                            } else {
                                f
                            }
                        }
                        _ => {
                            let mut s = if full {
                                String::from( "[\n" )
                            } else {
                                String::new()
                            };

                            self.with_each( |value| {
                                s.push_str( &format!( 
                                    "{}{}\n",
                                    indent( indent_amt ),
                                    value.format( true, indent_amt + INDENT_STEP )
                                ) )
                            });

                            if full {
                                let actual_indent_amt = if indent_amt == 0 {
                                    0
                                } else {
                                    indent_amt - INDENT_STEP
                                };
                                s.push_str( &format!( "{}]", indent( actual_indent_amt ) ) );
                            }
                            s
                        }
                    }
                }
            }

            impl Format for Tup {
                fn format( &self, full: bool, indent_amt: usize ) -> String {
                    match self.len() {
                        0 => {
                            if full {
                                String::from( "()" )
                            } else {
                                String::new()
                            }
                        }
                        1 => {
                            let f = self.get( 0 ).unwrap().format( true, indent_amt );
                            if full {
                                format!( "( {} )", f )
                            } else {
                                f
                            }
                        }
                        _ => {
                            let mut s = if full {
                                String::from( "( \n" )
                            } else {
                                String::new()
                            };

                            self.with_each( |value| {
                                s.push_str( &format!( 
                                    "{}{}\n",
                                    indent( indent_amt ),
                                    value.format( true, indent_amt + INDENT_STEP )
                                ) )
                            });

                            if full {
                                s.push_str( &format!( "{} )", indent( indent_amt - INDENT_STEP ) ) );
                            }
                            s
                        }
                    }
                }
            }

            impl Format for Obj
            {
                fn format( &self, full: bool, indent_amt: usize ) -> String
                {
                    if self.is_empty() && !self.has_parent()
                    {
                        if full { String::from( "{}" ) }
                        else { String::new() }
                    } 

                    else
                    {
                        let mut s = if full { String::from( "{\n" ) } 
                        else { String::new() };

                        if let Some( parent ) = self.get_parent()
                        {
                            s.push_str( &format!
                            ( 
                                "{}^: {}\n",
                                indent( indent_amt ),
                                parent.format( true, indent_amt + INDENT_STEP )
                            ) );
                        }

                        self.with_each( |field, value|
                        {
                            s.push_str( &format!
                            ( 
                                "{}{}: {}\n",
                                indent( indent_amt ),
                                field,
                                value.format( true, indent_amt + INDENT_STEP )
                            ) );
                        });

                        if full { s.push_str( &format!( "{}}}", indent( indent_amt - INDENT_STEP ) ) ); }

                        s
                    }
                }
            }
        }
        
        pub type ParseResult<T> = Result<T, ParseError>;
        type ObjMap = HashMap<String, Value>;
        type GlobalMap = HashMap<String, Value>;
        type IncludedMap = ( HashMap<String, Value>, HashSet<String> );

        lazy_static!
        {
            static ref OBJ_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
            static ref STR_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
            static ref ARR_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
            static ref TUP_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        }
        
        pub const MAX_DEPTH: usize = 64;
        /// Load an `Obj` from a file.
        pub fn load_from_file(path: &str) -> ParseResult<Obj> { parser::parse_obj_file(path) }
        /// Load an `Obj` from a &str.
        pub fn load_from_str(contents: &str) -> ParseResult<Obj> { parser::parse_obj_str(contents) }

        pub fn parse_obj_file( path: &str ) -> ParseResult<Obj>
        {
            let stream = CharStream::from_file( path )?;
            parse_obj_stream( stream, &mut ( HashMap::new(), HashSet::new() ) )
        }
        
        pub fn parse_obj_str( contents: &str ) -> ParseResult<Obj>
        {
            let contents = String::from( contents );
            let stream = CharStream::from_string( contents )?;
            parse_obj_stream( stream, &mut ( HashMap::new(), HashSet::new() ) )
        }
        
        fn parse_obj_file_includes( path: &str, included: &mut IncludedMap ) -> ParseResult<Obj>
        {
            let stream = CharStream::from_file( path )?;
            parse_obj_stream( stream, included )
        }
        
        #[inline] fn parse_obj_stream( mut stream: CharStream, mut included: &mut IncludedMap ) -> ParseResult<Obj>
        {
            let mut obj: ObjMap = HashMap::new();
            
            if !find_char( stream.clone() ) { return Ok( Obj::from_map_unchecked( obj ) ); }

            let mut globals: GlobalMap = HashMap::new();
            let mut parent = None;
            
            while parse_field_value_pair
            (
                &mut stream,
                &mut obj,
                &mut globals,
                &mut included,
                &mut parent,
                1,
                None,
            )? {}

            Ok( match parent
            {
                Some( parent ) => Obj::from_map_with_parent_unchecked( obj, parent ),
                None => Obj::from_map_unchecked( obj ),
            } )
        }
        
        fn parse_obj
        (
            mut stream: &mut CharStream,
            globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            depth: usize,
        ) -> ParseResult<Value>
        {
            if depth > MAX_DEPTH { return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) ); }
            
            let ch = stream.next().unwrap();
            assert_eq!( ch, '{' );
            
            if !find_char( stream.clone() ) { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }

            let mut obj: ObjMap = HashMap::new();
            let mut parent = None;
            
            while parse_field_value_pair
            (
                &mut stream,
                &mut obj,
                globals,
                &mut included,
                &mut parent,
                depth,
                Some( '}' ),
            )? {}

            let obj = match parent
            {
                Some( parent ) => Obj::from_map_with_parent_unchecked( obj, parent ),
                None => Obj::from_map_unchecked( obj ),
            };
            Ok( obj.into() )
        }
        
        #[inline] fn parse_field_value_pair
        (
            mut stream: &mut CharStream,
            obj: &mut ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            parent: &mut Option<Obj>,
            depth: usize,
            cur_brace: Option<char>,
        ) -> ParseResult<bool>
        {
            let peek = stream.peek().unwrap();
            if peek == '}' && cur_brace.is_some()
            {
                let _ = stream.next();
                return Ok( false );
            }
            else if is_end_delimiter( peek )
            {
                return parse_err
                ( 
                    stream.file(),
                    InvalidClosingBracket( cur_brace, peek, stream.line(), stream.col() ),
                );
            }
            
            let ( field_line, field_col ) = ( stream.line(), stream.col() );            
            let ( field, is_global, is_parent ) = parse_field( stream.clone(), field_line, field_col )?;

            if !is_global && !is_parent && obj.contains_key( &field )
            { return parse_err( stream.file(), DuplicateField( field, field_line, field_col ) ); }            
            else if is_parent && parent.is_some()
            { return parse_err( stream.file(), DuplicateField( "^".into(), field_line, field_col ) ); }
            
            if !find_char( stream.clone() ) { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }
            
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value
            ( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                depth,
                cur_brace,
                true,
            )?;
            
            if is_global 
            {
                if globals.contains_key( &field )
                { return parse_err( stream.file(), DuplicateGlobal( field, field_line, field_col ) ); }

                globals.insert( field, value );
            }
            
            else if is_parent
            {
                let par = value
                .get_obj()
                .map_err( |e| ParseError::from_over( &e, stream.file(), value_line, value_col ) )?;
                *parent = Some( par );
            }

            else { obj.insert( field, value ); }
            
            if !find_char( stream.clone() )
            {
                match cur_brace
                {
                    Some( _ ) => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                    None => return Ok( false ),
                }
            }

            Ok( true )
        }
        
        fn parse_arr_file( path: &str, mut included: &mut IncludedMap ) -> ParseResult<Arr>
        {
            let mut stream = CharStream::from_file( path )?;
            let obj: ObjMap = HashMap::new();
            let mut globals: GlobalMap = HashMap::new();
            let mut vec = Vec::new();
            let mut tcur = Type::Any;
            let mut has_any = true;

            loop
            {
                if !find_char( stream.clone() ) { break; }

                let ( value_line, value_col ) = ( stream.line(), stream.col() );
                let value = parse_value
                (
                    &mut stream,
                    &obj,
                    &mut globals,
                    &mut included,
                    value_line,
                    value_col,
                    1,
                    None,
                    true,
                )?;

                let tnew = value.get_type();

                if has_any
                {
                    match Type::most_specific( &tcur, &tnew )
                    {
                        Some(( t, any )) =>
                        {
                            tcur = t;
                            has_any = any;
                        }
                        
                        None =>
                        {
                            return parse_err
                            (
                                stream.file(),
                                ExpectedType( tcur, tnew, value_line, value_col ),
                            );
                        }
                    }
                }

                else if tcur != tnew
                {
                    return parse_err
                    (
                        stream.file(),
                        ExpectedType( tcur, tnew, value_line, value_col ),
                    );
                }

                vec.push( value );
            }

            let arr = Arr::from_vec_unchecked( vec, tcur );
            Ok( arr )
        }
        
        fn parse_arr
        (
            mut stream: &mut CharStream,
            obj: &ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            depth: usize,
        ) -> ParseResult<Value>
        {
            if depth > MAX_DEPTH { return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) ); }
            
            let ch = stream.next().unwrap();
            assert_eq!( ch, '[' );

            let mut vec = Vec::new();
            let mut tcur = Type::Any;
            let mut has_any = true;

            loop
            {
                if !find_char( stream.clone() ) { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }

                let peek = stream.peek().unwrap();

                if peek == ']'
                {
                    let _ = stream.next();
                    break;
                }
                else if is_end_delimiter( peek )
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidClosingBracket( Some( ']' ), peek, stream.line(), stream.col() ),
                    );
                }
                
                let ( value_line, value_col ) = ( stream.line(), stream.col() );
                let value = parse_value
                (
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    value_line,
                    value_col,
                    depth,
                    Some( ']' ),
                    true,
                )?;

                let tnew = value.get_type();

                if has_any
                {
                    match Type::most_specific( &tcur, &tnew )
                    {
                        Some(( t, any )) =>
                        {
                            tcur = t;
                            has_any = any;
                        }
                        
                        None =>
                        {
                            return parse_err
                            (
                                stream.file(),
                                ExpectedType( tcur, tnew, value_line, value_col ),
                            );
                        }
                    }
                }
                
                else if tcur != tnew
                {
                    return parse_err
                    (
                        stream.file(),
                        ExpectedType( tcur, tnew, value_line, value_col ),
                    );
                }

                vec.push( value );
            }

            let arr = Arr::from_vec_unchecked( vec, tcur );
            Ok( arr.into() )
        }
        
        fn parse_tup_file( path: &str, mut included: &mut IncludedMap ) -> ParseResult<Tup>
        {
            let mut stream = CharStream::from_file( path )?;
            let mut vec: Vec<Value> = Vec::new();
            let obj: ObjMap = HashMap::new();
            let mut globals: GlobalMap = HashMap::new();

            loop
            {
                if !find_char( stream.clone() ) { break; }
                
                let ( value_line, value_col ) = ( stream.line(), stream.col() );
                let value = parse_value
                (
                    &mut stream,
                    &obj,
                    &mut globals,
                    &mut included,
                    value_line,
                    value_col,
                    1,
                    None,
                    true,
                )?;

                vec.push( value );
            }

            Ok( vec.into() )
        }
        
        fn parse_tup
        (
            mut stream: &mut CharStream,
            obj: &ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            depth: usize,
        ) -> ParseResult<Value>
        {
            if depth > MAX_DEPTH { return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) ); }
            
            let ch = stream.next().unwrap();
            assert_eq!( ch, '(' );

            let mut vec = Vec::new();

            loop
            {
                if !find_char( stream.clone() )
                { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }

                let peek = stream.peek().unwrap();
                
                if peek == ')'
                {
                    let _ = stream.next();
                    break;
                }
                else if is_end_delimiter( peek )
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidClosingBracket( Some( ')' ), peek, stream.line(), stream.col() ),
                    );
                }
                
                let ( value_line, value_col ) = ( stream.line(), stream.col() );
                let value = parse_value
                (
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    value_line,
                    value_col,
                    depth,
                    Some( ')' ),
                    true,
                )?;

                vec.push( value );
            }

            let tup = Tup::from_vec( vec );
            Ok( tup.into() )
        }
        
        fn parse_field
        (
            mut stream: CharStream,
            line: usize,
            col: usize,
        ) -> ParseResult<( String, bool, bool )>
        {
            let mut field = String::new();
            let mut first = true;
            let mut is_global = false;

            let ch = stream.peek().unwrap();
            if ch == '@' {
                let ch = stream.next().unwrap();
                is_global = true;
                field.push( ch );
            }

            while let Some( ch ) = stream.next()
            {
                match ch
                {
                    ':' if !first => { break; }
                    ch if Obj::is_valid_field_char( ch, first ) => field.push( ch ),
                    ch =>
                    {
                        return parse_err
                        (
                            stream.file(),
                            InvalidFieldChar( ch, stream.line(), stream.col() - 1 ),
                        );
                    }
                }

                first = false;
            }
            
            match field.as_str()
            {
                _field_str if is_reserved( _field_str ) =>
                { parse_err( stream.file(), InvalidFieldName( field.clone(), line, col ) ) }

                "^" => Ok( ( field.clone(), false, true ) ), bad if bad.starts_with( '^' ) =>
                { parse_err( stream.file(), InvalidFieldName( field.clone(), line, col ) ) }

                _ => Ok( ( field.clone(), is_global, false ) ),
            }
        }
        
        fn parse_value
        ( 
            mut stream: &mut CharStream,
            obj: &ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            line: usize,
            col: usize,
            depth: usize,
            cur_brace: Option<char>,
            is_first: bool,
        ) -> ParseResult<Value>
        {
            let res = match stream.peek().unwrap()
            {
                '"' => parse_str( &mut stream )?,
                '\'' => parse_char( &mut stream )?,
                '{' => parse_obj( &mut stream, &mut globals, included, depth + 1 )?,
                '[' => parse_arr( &mut stream, obj, &mut globals, included, depth + 1 )?,
                '(' => parse_tup( &mut stream, obj, &mut globals, included, depth + 1 )?,
                '@' => parse_variable( &mut stream, globals, included, line, col, depth, cur_brace )?,
                '<' => parse_include( &mut stream, obj, &mut globals, &mut included, depth + 1 )?,
                ch @ '+' | ch @ '-' => parse_unary_op( &mut stream, obj, globals, included, depth, cur_brace, ch )?,
                ch if is_numeric_char( ch ) => parse_numeric( &mut stream, line, col )?,
                ch if Obj::is_valid_field_char( ch, true ) => 
                { parse_variable( &mut stream, obj, globals, included, line, col, depth, cur_brace )? }

                ch => { return parse_err( stream.file(), InvalidValueChar( ch, line, col ) ); }
            };
            
            if is_first
            {
                let mut val_deque: VecDeque<( Value, usize, usize )> = VecDeque::new();
                let mut op_deque: VecDeque<char> = VecDeque::new();
                val_deque.push_back( ( res, line, col ) );

                loop
                {
                    match stream.peek()
                    {
                        Some( ch ) if is_operator( ch ) =>
                        {
                            let _ = stream.next();
                            if stream.peek().is_none()
                            { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }

                            let ( line2, col2 ) = ( stream.line(), stream.col() );
                            let val2 = parse_value
                            (
                                &mut stream,
                                obj,
                                &mut globals,
                                &mut included,
                                line2,
                                col2,
                                depth,
                                cur_brace,
                                false,
                            )?;

                            if is_priority_operator( ch )
                            {
                                let ( val1, line1, col1 ) = val_deque.pop_back().unwrap();
                                let res = binary_op_on_values( stream, val1, val2, ch, line2, col2 )?;
                                val_deque.push_back( ( res, line1, col1 ) );
                            }
                            
                            else
                            {
                                val_deque.push_back( ( val2, line2, col2 ) );
                                op_deque.push_back( ch );
                            }
                        }
                        _ => break,
                    }
                }
                
                check_value_end( stream, cur_brace )?;
                let ( mut val1, _, _ ) = val_deque.pop_front().unwrap();
                
                while !op_deque.is_empty()
                {
                    let ( val2, line2, col2 ) = val_deque.pop_front().unwrap();
                    val1 = binary_op_on_values
                    (
                        stream,
                        val1,
                        val2,
                        op_deque.pop_front().unwrap(),
                        line2,
                        col2,
                    )?;
                }

                Ok( val1 )
            }
            else { Ok( res ) }
        }

        fn parse_unary_op
        (
            mut stream: &mut CharStream,
            obj: &ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            depth: usize,
            cur_brace: Option<char>,
            ch: char,
        ) -> ParseResult<Value>
        {
            let _ = stream.next();
            let line = stream.line();
            let col = stream.col();
            let res = match stream.peek()
            {
                Some( _ ) => parse_value
                (
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    line,
                    col,
                    depth + 1,
                    cur_brace,
                    false,
                )?,
                None => return parse_err( stream.file(), UnexpectedEnd( line ) ),
            };
            unary_op_on_value( stream, res, ch, line, col )
        }
        
        fn parse_numeric( stream: &mut CharStream, line: usize, col: usize ) -> ParseResult<Value>
        {
            let mut s1 = String::new();
            let mut s2 = String::new();
            let mut dec = false;
            let mut under = false;

            while let Some( ch ) = stream.peek()
            {
                match ch
                {
                    ch if is_value_end_char( ch ) => break,
                    ch if is_digit( ch ) =>
                    {
                        if !dec { s1.push( ch ); }
                        else { s2.push( ch ); }
                    }

                    '.' | ',' =>
                    {
                        if !dec { dec = true; }
                        else { return parse_err(stream.file(), InvalidValueChar(ch, stream.line(), stream.col())); }
                    }

                    '_' =>
                    {
                        if !under { under = true; }
                        else { return parse_err(stream.file(), InvalidValueChar(ch, stream.line(), stream.col())); }
                    }

                    _ => { return parse_err( stream.file(), InvalidValueChar( ch, stream.line(), stream.col() ) ); }
                }

                if ch != '_' { under = false; }

                let _ = stream.next();
            }

            if dec
            {
                if s1.is_empty() && s2.is_empty() { return parse_err( stream.file(), InvalidNumeric( line, col ) ); }

                let whole: BigInt = if s1.is_empty() { 0u8.into() } else { s1.parse()? };
                let s2 = s2.trim_end_matches( '0' );
                let ( decimal, dec_len ): ( BigInt, usize ) = if s2.is_empty() { ( 0u8.into(), 1 ) } 
                else { ( s2.parse()?, s2.len() ) };

                let f = frac_from_whole_and_dec( whole, decimal, dec_len );
                Ok( f.into() )
            }

            else
            {
                if s1.is_empty() { return parse_err( stream.file(), InvalidNumeric( line, col ) ); }

                let i: BigInt = s1.parse()?;
                Ok( i.into() )
            }
        }
        
        fn parse_variable
        (
            mut stream: &mut CharStream,
            obj: &ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            line: usize,
            col: usize,
            depth: usize,
            cur_brace: Option<char>,
        ) -> ParseResult<Value>
        {
            let mut var = String::new();
            let mut is_global = false;
            let mut dot = false;
            let mut dot_global = false;
            let ch = stream.peek().unwrap();

            if ch == '@'
            {
                let ch = stream.next().unwrap();
                is_global = true;
                var.push( ch );
            }

            while let Some( ch ) = stream.peek()
            {
                match ch
                {
                    '.' =>
                    {
                        let _ = stream.next();
                        match stream.peek()
                        {
                            Some( '@' ) => dot_global = true,
                            Some( ch ) if Obj::is_valid_field_char( ch, true ) || is_numeric_char( ch ) => (),
                            Some( ch ) =>
                            {
                                return parse_err
                                (
                                    stream.file(),
                                    InvalidValueChar( ch, stream.line(), stream.col() ),
                                );
                            }
                            None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                        }

                        dot = true;
                        break;
                    }
                    ch if is_value_end_char( ch ) => break,
                    ch if Obj::is_valid_field_char( ch, false ) =>
                    {
                        let _ = stream.next();
                        var.push( ch );
                    }

                    ch =>
                    {
                        return parse_err
                        (
                            stream.file(),
                            InvalidValueChar( ch, stream.line(), stream.col() ),
                        );
                    }
                }
            }

            let mut value = match var.as_str()
            {
                "null" => Value::Null,
                "true" => Value::Bool( true ),
                "false" => Value::Bool( false ),
                "Obj" => Value::Obj( OBJ_SENTINEL.clone() ),
                "Str" => Value::Obj( STR_SENTINEL.clone() ),
                "Arr" => Value::Obj( ARR_SENTINEL.clone() ),
                "Tup" => Value::Obj( TUP_SENTINEL.clone() ),
                var @ "@" => return parse_err( stream.file(), InvalidValue( var.into(), line, col ) ),
                var if is_global =>
                {
                    match globals.get( var )
                    {
                        Some( value ) => value.clone(),
                        None =>
                        {
                            let var = String::from( var );
                            return parse_err( stream.file(), GlobalNotFound( var, line, col ) );
                        }
                    }
                }
                var =>
                {
                    match obj.get( var ) 
                    {
                        Some( value ) => value.clone(),
                        None =>
                        {
                            let var = String::from( var );
                            return parse_err( stream.file(), VariableNotFound( var, line, col ) );
                        }
                    }
                }
            };

            if dot
            {
                value = match value
                {
                    Value::Arr( arr ) =>
                    {
                        let ( line, col ) = ( stream.line(), stream.col() );
                        let value = parse_value
                        (
                            &mut stream,
                            obj,
                            &mut globals,
                            &mut included,
                            line,
                            col,
                            depth + 1,
                            cur_brace,
                            false,
                        )?;

                        match value
                        {
                            Value::Int( int ) => match int.to_usize()
                            {
                                Some( index ) => arr
                                .get( index )
                                .map_err( |e| ParseError::from_over( &e, stream.file(), line, col ) )?,
                                None => return parse_err( stream.file(), InvalidIndex( int, line, col ) ),
                            },
                            _ =>
                            {
                                return parse_err(stream.file(), ExpectedType(Type::Int, value.get_type(), line, col));
                            }
                        }
                    }

                    Value::Tup( tup ) =>
                    {
                        let ( line, col ) = ( stream.line(), stream.col() );
                        let value = parse_value
                        (
                            &mut stream,
                            obj,
                            &mut globals,
                            &mut included,
                            line,
                            col,
                            depth + 1,
                            cur_brace,
                            false,
                        )?;

                        match value
                        {
                            Value::Int( int ) => match int.to_usize()
                            {
                                Some( index ) => tup
                                .get( index )
                                .map_err( |e| ParseError::from_over( &e, stream.file(), line, col ) )?,
                                None => return parse_err( stream.file(), InvalidIndex( int, line, col ) ),
                            },

                            _ =>
                            {
                                return parse_err
                                ( 
                                    stream.file(),
                                    ExpectedType( Type::Int, value.get_type(), line, col ),
                                );
                            }
                        }
                    }

                    Value::Obj( obj ) =>
                    {
                        let ( line, col ) = ( stream.line(), stream.col() );

                        if dot_global { return parse_err( stream.file(), InvalidValueChar( '@', line, col ) ); }

                        parse_variable
                        (
                            &mut stream,
                            obj.map_ref(),
                            globals,
                            included,
                            line,
                            col,
                            depth + 1,
                            cur_brace,
                        )?
                    }

                    _ => return parse_err( stream.file(), InvalidDot( value.get_type(), line, col ) ),
                }
            }

            Ok( value )
        }
        
        fn parse_char( stream: &mut CharStream ) -> ParseResult<Value>
        {
            let ch = stream.next().unwrap();
            assert_eq!( ch, '\'' );

            let ( escape, mut ch ) = match stream.next()
            {
                Some( '\\' ) => ( true, '\0' ),
                Some( ch ) if ch == '\n' || ch == '\r' || ch == '\t' =>
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() - 1 ),
                    );
                }
                Some( ch ) => ( false, ch ),
                None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
            };

            if escape
            {
                ch = match stream.next()
                {
                    Some( ch ) => match get::escape_char( ch )
                    {
                        Some( ch ) => ch,
                        None =>
                        {
                            return parse_err
                            (
                                stream.file(),
                                InvalidEscapeChar( ch, stream.line(), stream.col() - 1 ),
                            );
                        }
                    },
                    None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                }
            }

            match stream.next()
            {
                Some( '\'' ) => (),
                Some( ch ) =>
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() - 1 ),
                    );
                }
                None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
            }

            Ok( ch.into() )
        }

        fn parse_str_file( path: &str ) -> ParseResult<String>
        {
            let s = read_file_str( path )?.replace( "\r\n", "\n" );
            Ok( s )
        }
        
        fn parse_str( stream: &mut CharStream ) -> ParseResult<Value>
        {
            let ch = stream.next().unwrap();
            
            assert_eq!( ch, '"' );

            let mut s = String::new();
            let mut escape = false;

            loop
            {
                match stream.next()
                {
                    Some( ch ) =>
                    {
                        if escape
                        {
                            match get::escape_char( ch )
                            {
                                Some( ch ) => s.push( ch ),
                                None =>
                                {
                                    return parse_err
                                    (
                                        stream.file(),
                                        InvalidEscapeChar( ch, stream.line(), stream.col() - 1 ),
                                    );
                                }
                            }
                            escape = false;
                        }
                        
                        else
                        {
                            match ch {
                                '"' => break,
                                '\\' => escape = true,
                                _ => s.push( ch ),
                            }
                        }
                    }

                    None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                }
            }
            
            let s = s.replace( "\r\n", "\n" );
            Ok( s.into() )
        }

        fn parse_include
        (
            mut stream: &mut CharStream,
            obj: &ObjMap,
            mut globals: &mut GlobalMap,
            mut included: &mut IncludedMap,
            depth: usize,
        ) -> ParseResult<Value>
        {
            enum IncludeType
            {
                Obj,
                Str,
                Arr,
                Tup,
            }
            
            if depth > MAX_DEPTH { return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) ); }

            let ch = stream.next().unwrap();
            
            assert_eq!( ch, '<' );
            
            if !find_char( stream.clone() ) { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }

            let ( mut line, mut col ) = ( stream.line(), stream.col() );
            let mut value = parse_value
            (
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                line,
                col,
                depth,
                Some( '>' ),
                true,
            )?;
            let mut include_type = IncludeType::Obj;
            let mut parse_again = true;
            match value
            {
                Value::Obj( ref obj ) if obj.ptr_eq( &OBJ_SENTINEL ) => include_type = IncludeType::Obj,
                Value::Obj( ref obj ) if obj.ptr_eq( &STR_SENTINEL ) => include_type = IncludeType::Str,
                Value::Obj( ref obj ) if obj.ptr_eq( &ARR_SENTINEL ) => include_type = IncludeType::Arr,
                Value::Obj( ref obj ) if obj.ptr_eq( &TUP_SENTINEL ) => include_type = IncludeType::Tup,
                Value::Str( _ ) => parse_again = false,
                _ =>
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidIncludeToken( value.get_type(), line, col ),
                    );
                }
            }

            if parse_again
            {
                if !find_char( stream.clone() ) { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }
                line = stream.line();
                col = stream.col();
                value = parse_value
                (
                    &mut stream,
                    obj,
                    &mut globals,
                    &mut included,
                    line,
                    col,
                    depth,
                    Some( '>' ),
                    true,
                )?;
            }
            
            if !find_char( stream.clone() ) { return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ); }

            match stream.next().unwrap()
            {
                '>' => (),
                ch =>
                {
                    return parse_err
                    (
                        stream.file(),
                        InvalidClosingBracket( Some( '>' ), ch, stream.line(), stream.col() - 1 ),
                    );
                }
            }
            
            let include_file = match value
            {
                Value::Str( s ) => s,
                _ =>
                {
                    return parse_err
                    (
                        stream.file(),
                        ExpectedType( Type::Str, value.get_type(), line, col ),
                    );
                }
            };

            let pathbuf = match stream.file().as_ref()
            {
                Some( file ) => Path::new( file ).parent().unwrap().join( Path::new( &include_file ) ),
                None => Path::new( &include_file ).to_path_buf(),
            };
            let path = pathbuf.as_path();
            
            if !path.is_file() { return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ); }
            
            let path_str = match path.to_str()
            {
                Some( path ) => path,
                None => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
            };
            
            let path = match path.canonicalize()
            {
                Ok( path ) => path,
                Err( _ ) => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
            };

            let full_path_str = match path.to_str()
            {
                Some( path ) => path,
                None => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
            };
            
            let storing = if let Some( file ) = stream.file()
            {
                let full_file = String::from( Path::new( &file ).canonicalize().unwrap().to_str().unwrap() );
                included.1.insert( full_file.clone() );
                Some( full_file )
            }
            else { None };

            if included.1.contains( full_path_str )
            { return parse_err( stream.file(), CyclicInclude( include_file, line, col ) ); }
            
            let value = if included.0.contains_key( full_path_str )
            {
                let value = &included.0[full_path_str];
                value.clone()
            }
            else
            {
                let value: Value = match include_type
                {
                    IncludeType::Obj => parse_obj_file_includes( path_str, included )?.into(),
                    IncludeType::Str => parse_str_file( path_str )?.into(),
                    IncludeType::Arr => parse_arr_file( path_str, included )?.into(),
                    IncludeType::Tup => parse_tup_file( path_str, included )?.into(),
                };
                
                included.0.insert( full_path_str.into(), value.clone() );
                value
            };
            
            if let Some( file ) = storing { included.1.remove( &file ); }

            Ok( value )
        }
        
        fn unary_op_on_value
        (
            stream: &CharStream,
            val: Value,
            op: char,
            line: usize,
            col: usize,
        ) -> ParseResult<Value>
        {
            use self::Type::{ * };
            let t = val.get_type();
            let ret = match op
            {
                '+' => match t
                {
                    Int | Frac => val,
                    _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
                },
                '-' => match t
                {
                    Int => ( -val.get_int().unwrap() ).into(),
                    Frac => ( -val.get_frac().unwrap() ).into(),
                    _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
                },
                _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
            };

            Ok( ret )
        }
        
        fn binary_op_on_values
        (
            stream: &CharStream,
            mut val1: Value,
            mut val2: Value,
            op: char,
            line: usize,
            col: usize,
        ) -> ParseResult<Value>
        {
            use ::primitive::Type::*;

            let ( mut type1, mut type2 ) = ( val1.get_type(), val2.get_type() );
            
            if type1 == Int && type2 == Frac {
                val1 = Value::Frac( BigRational::new( val1.get_int().unwrap(), 1.into() ) );
                type1 = Frac;
            } else if type1 == Frac && type2 == Int {
                val2 = Value::Frac( BigRational::new( val2.get_int().unwrap(), 1.into() ) );
                type2 = Frac;
            }

            Ok( match op {
                '+' => {
                    match type1 {
                        Int if type2 == Int => ( val1.get_int().unwrap() + val2.get_int().unwrap() ).into(),
                        Frac if type2 == Frac => {
                            ( val1.get_frac().unwrap() + val2.get_frac().unwrap() ).into()
                        }
                        Char if type2 == Char => {
                            let mut s = String::with_capacity( 2 );
                            s.push( val1.get_char().unwrap() );
                            s.push( val2.get_char().unwrap() );
                            s.into()
                        }
                        Char if type2 == Str => {
                            let str2 = val2.get_str().unwrap();
                            let mut s = String::with_capacity( 1 + str2.len() );
                            s.push( val1.get_char().unwrap() );
                            s.push_str( &str2 );
                            s.into()
                        }
                        Str if type2 == Char => {
                            let str1 = val1.get_str().unwrap();
                            let mut s = String::with_capacity( str1.len() + 1 );
                            s.push_str( &str1 );
                            s.push( val2.get_char().unwrap() );
                            s.into()
                        }
                        Str if type2 == Str => {
                            let str1 = val1.get_str().unwrap();
                            let str2 = val2.get_str().unwrap();
                            let mut s = String::with_capacity( str1.len() + str2.len() );
                            s.push_str( &str1 );
                            s.push_str( &str2 );
                            s.into()
                        }
                        Arr( _ ) => {
                            match Type::most_specific( &type1, &type2 ) {
                                Some(( t, _ )) => {
                                    let ( arr1, arr2 ) = ( val1.get_arr().unwrap(), val2.get_arr().unwrap() );
                                    let ( mut vec1, mut vec2 ) =
                                        ( arr1.vec_ref().clone(), arr2.vec_ref().clone() );

                                    let mut vec = Vec::with_capacity( vec1.len() + vec2.len() );
                                    vec.append( &mut vec1 );
                                    vec.append( &mut vec2 );

                                    // Get the inner type.
                                    let arr = if let Arr( ref t ) = t {
                                        // Because we know the type already, we can safely use `_unchecked`.
                                        arrays::Arr::from_vec_unchecked( vec, t.deref().clone() )
                                    } else {
                                        panic!( "Logic error" )
                                    };

                                    arr.into()
                                }
                                None => {
                                    return parse_err( 
                                        stream.file(),
                                        BinaryOperatorError( type1, type2, op, line, col ),
                                    );
                                }
                            }
                        }
                        _ => {
                            return parse_err( 
                                stream.file(),
                                BinaryOperatorError( type1, type2, op, line, col ),
                            );
                        }
                    }
                }
                '-' => match type1 {
                    Int if type2 == Int => ( val1.get_int().unwrap() - val2.get_int().unwrap() ).into(),
                    Frac if type2 == Frac => ( val1.get_frac().unwrap() - val2.get_frac().unwrap() ).into(),
                    _ => {
                        return parse_err( 
                            stream.file(),
                            BinaryOperatorError( type1, type2, op, line, col ),
                        );
                    }
                },
                '*' => match type1 {
                    Int if type2 == Int => ( val1.get_int().unwrap() * val2.get_int().unwrap() ).into(),
                    Frac if type2 == Frac => ( val1.get_frac().unwrap() * val2.get_frac().unwrap() ).into(),
                    _ => {
                        return parse_err( 
                            stream.file(),
                            BinaryOperatorError( type1, type2, op, line, col ),
                        );
                    }
                },
                '/' => match type1 {
                    Int if type2 == Int => {
                        let ( int1, int2 ) = ( val1.get_int().unwrap(), val2.get_int().unwrap() );
                        if int2.is_zero() {
                            return parse_err( stream.file(), InvalidNumeric( line, col ) );
                        }
                        BigRational::new( int1, int2 ).into()
                    }
                    Frac if type2 == Frac => {
                        let ( frac1, frac2 ) = ( val1.get_frac().unwrap(), val2.get_frac().unwrap() );
                        if frac2.is_zero() {
                            return parse_err( stream.file(), InvalidNumeric( line, col ) );
                        }
                        ( frac1 / frac2 ).into()
                    }
                    _ => {
                        return parse_err( 
                            stream.file(),
                            BinaryOperatorError( type1, type2, op, line, col ),
                        );
                    }
                },
                '%' => match type1 {
                    Int if type2 == Int => {
                        let int2 = val2.get_int().unwrap();
                        if int2.is_zero() {
                            return parse_err( stream.file(), InvalidNumeric( line, col ) );
                        }
                        ( val1.get_int().unwrap() % int2 ).into()
                    }
                    _ => {
                        return parse_err( 
                            stream.file(),
                            BinaryOperatorError( type1, type2, op, line, col ),
                        );
                    }
                },
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                    );
                }
            } )
        }
        
        fn find_char( mut stream: CharStream ) -> bool
        {
            while let Some( ch ) = stream.peek() {
                match ch {
                    '#' =>
                    {
                        loop {
                            let ch = stream.next();
                            if ch.is_none() {
                                return false;
                            }
                            if ch.unwrap() == '\n' {
                                break;
                            }
                        }
                    }
                    ch if ch.is_whitespace() => {
                        let _ = stream.next();
                    }
                    _ => return true,
                }
            }

            false
        }
        
        fn check_value_end( stream: &CharStream, cur_brace: Option<char> ) -> ParseResult<()>
        {
            match stream.peek() {
                Some( ch ) => match ch {
                    ch if is_value_end_char( ch ) => {
                        if is_end_delimiter( ch ) && Some( ch ) != cur_brace {
                            parse_err( 
                                stream.file(),
                                InvalidClosingBracket( cur_brace, ch, stream.line(), stream.col() ),
                            )
                        } else {
                            Ok( () )
                        }
                    }
                    ch => parse_err( 
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() ),
                    ),
                },
                None => Ok( () ),
            }
        }
    }
    /*
    terminfo v0.9.0::parsers */
    pub mod metadata
    {
        use ::
        {
            borrow::{ Cow },
            *,
        };
        /*
        use nom::branch::alt;
        use nom::character::streaming::char;
        use nom::character::{is_digit, streaming::line_ending as eol};
        use nom::combinator::eof;
        use nom::IResult;
        */

        /*
        pub fn ws(input: &[u8]) -> IResult<&[u8], char> {
            alt((char(' '), char('\t')))(input)
        }

        pub fn end(input: &[u8]) -> IResult<&[u8], &[u8]> {
            alt((eof, eol))(input)
        }
        */

        #[inline] pub fn number(i: &[u8]) -> i32
        {
            let mut n: i32 = 0;

            for &ch in i
            {
                let d = (ch as i32).wrapping_sub(b'0' as i32);
                if d <= 9 { n = n.saturating_mul(10).saturating_add(d); }
            }

            n
        }

        pub fn unescape(i: &[u8]) -> Cow<[u8]>
        {
            unsafe
            {
                fn escape<I: Iterator<Item = u8>>(output: &mut Vec<u8>, iter: &mut I)
                {
                    match iter.next()
                    {
                        None => (),
                        Some(b'a') => output.push(0x07),
                        Some(b'b') => output.push(0x08),
                        Some(b'E') | Some(b'e') => output.push(0x1B),
                        Some(b'f') => output.push(0x0C),
                        Some(b'l') | Some(b'n') => output.push(b'\n'),
                        Some(b'r') => output.push(b'\r'),
                        Some(b's') => output.push(b' '),
                        Some(b't') => output.push(b'\t'),
                        Some(b'^') => output.push(b'^'),
                        Some(b'\\') => output.push(b'\\'),
                        Some(b',') => output.push(b','),
                        Some(b':') => output.push(b':'),
                        Some(b'0') => output.push(0x00),
                        Some(a) if is_digit(a) => match (iter.next(), iter.next())
                        {
                            (Some(b), Some(c)) if is_digit(b) && is_digit(c) =>
                            {
                                if let Ok(number) = u8::from_str_radix( str::from_utf8_unchecked(&[a, b, c]), 8 )
                                { output.push(number); }
                                
                                else
                                { output.extend(&[a, b, c]); }
                            }

                            (Some(b), None) => output.extend(&[b'\\', a, b]),

                            (None, None) => output.extend(&[b'\\', a]),

                            _ => unreachable!(),
                        },

                        Some(ch) => output.extend(&[b'\\', ch]),
                    }
                }

                fn control<I: Iterator<Item = u8>>(output: &mut Vec<u8>, iter: &mut I)
                {
                    match iter.next()
                    {
                        None => (),
                        Some(ch) if ch.is_ascii_uppercase() => output.push(ch - b'A' + 1),
                        Some(ch) if ch.is_ascii_lowercase() => output.push(ch - b'a' + 1),
                        Some(ch) => output.extend(&[b'^', ch]),
                    }
                }

                let mut chars = i.iter().cloned();
                let mut offset = 0;

                while let Some(ch) = chars.next()
                {
                    if ch == b'\\' || ch == b'^'
                    {
                        let mut output = i[..offset].to_vec();

                        match ch
                        {
                            b'\\' => escape(&mut output, &mut chars),
                            b'^' => control(&mut output, &mut chars),
                            _ => unreachable!(),
                        }

                        while let Some(ch) = chars.next()
                        {
                            match ch
                            {
                                b'\\' => escape(&mut output, &mut chars),
                                b'^' => control(&mut output, &mut chars),
                                ch => output.push(ch),
                            }
                        }

                        return Cow::Owned(output);
                    }

                    offset += 1;
                }

                Cow::Borrowed(i)
            }
        }

        pub mod compiled
        {
            use ::
            {
                *,
            };
            /*
            use nom::branch::alt;
            use nom::bytes::streaming::{tag, take, take_until};
            use nom::combinator::{complete, cond, map, map_opt, map_parser, opt};
            use nom::multi::count;
            use nom::number::streaming::{le_i16, le_i32};
            use nom::IResult;
            use std::str;

            use terminfo::capability::Value;
            use terminfo::names; aka terminal::metadata
            */

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct Database<'a> {
                names: &'a [u8],
                standard: Standard<'a>,
                extended: Option<Extended<'a>>,
            }

            impl<'a> From<Database<'a>> for crate::Database {
                fn from(source: Database<'a>) -> Self {
                    let mut names = source
                        .names
                        .split(|&c| c == b'|')
                        .map(|s| unsafe { str::from_utf8_unchecked(s) })
                        .map(|s| s.trim())
                        .collect::<Vec<_>>();

                    let mut database = crate::Database::new();

                    database.name(names.remove(0));
                    names.pop().map(|name| database.description(name));
                    database.aliases(names);

                    for (index, _) in source.standard.booleans.iter().enumerate().filter(|&(_, &value)| value) {
                        if let Some(&name) = names::BOOLEAN.get(&(index as u16)) {
                            database.raw(name, Value::True);
                        }
                    }

                    for (index, &value) in source.standard.numbers.iter().enumerate().filter(|&(_, &n)| n >= 0)
                    {
                        if let Some(&name) = names::NUMBER.get(&(index as u16)) {
                            database.raw(name, Value::Number(value));
                        }
                    }

                    for (index, &offset) in source.standard.strings.iter().enumerate().filter(|&(_, &n)| n >= 0)
                    {
                        if let Some(&name) = names::STRING.get(&(index as u16)) {
                            let string = &source.standard.table[offset as usize..];
                            let edge = string.iter().position(|&c| c == 0).unwrap();

                            database.raw(name, Value::String(Vec::from(&string[..edge])));
                        }
                    }

                    if let Some(extended) = source.extended {
                        let names = extended
                            .table
                            .split(|&c| c == 0)
                            .skip(extended.strings.iter().cloned().filter(|&n| n >= 0).count())
                            .map(|s| unsafe { str::from_utf8_unchecked(s) })
                            .collect::<Vec<_>>();

                        for (index, _) in extended.booleans.iter().enumerate().filter(|&(_, &value)| value) {
                            database.raw(names[index], Value::True);
                        }

                        for (index, &value) in extended.numbers.iter().enumerate().filter(|&(_, &n)| n >= 0) {
                            database.raw(names[extended.booleans.len() + index], Value::Number(value));
                        }

                        for (index, &offset) in extended.strings.iter().enumerate().filter(|&(_, &n)| n >= 0) {
                            let string = &extended.table[offset as usize..];
                            let edge = string.iter().position(|&c| c == 0).unwrap();

                            database.raw(
                                names[extended.booleans.len() + extended.numbers.len() + index],
                                Value::String(Vec::from(&string[..edge])),
                            );
                        }
                    }

                    database.build().unwrap()
                }
            }

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct Standard<'a> {
                booleans: Vec<bool>,
                numbers: Vec<i32>,
                strings: Vec<i32>,
                table: &'a [u8],
            }

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct Extended<'a> {
                booleans: Vec<bool>,
                numbers: Vec<i32>,
                strings: Vec<i32>,
                names: Vec<i32>,
                table: &'a [u8],
            }

            fn bit_size(magic: &[u8]) -> usize {
                match magic[1] {
                    0x01 => 16,
                    0x02 => 32,

                    _ => unreachable!("unknown magic number"),
                }
            }

            pub fn parse(input: &[u8]) -> IResult<&[u8], Database> {
                let (input, magic) = alt((tag([0x1A, 0x01]), tag([0x1E, 0x02])))(input)?;

                let (input, name_size) = size(input)?;
                let (input, bool_count) = size(input)?;
                let (input, num_count) = size(input)?;
                let (input, string_count) = size(input)?;
                let (input, table_size) = size(input)?;

                let (input, names) = map_parser(take(name_size), take_until("\x00"))(input)?;

                let (input, booleans) = count(boolean, bool_count)(input)?;

                let (input, _) = cond((name_size + bool_count) % 2 != 0, take(1_usize))(input)?;

                let (input, numbers) = count(|input| capability(input, bit_size(magic)), num_count)(input)?;

                let (input, strings) = count(|input| capability(input, 16), string_count)(input)?;

                let (input, table) = take(table_size)(input)?;

                let (input, extended) = opt(complete(|input| {
                    let (input, _) = cond(table_size % 2 != 0, take(1_usize))(input)?;

                    let (input, ext_bool_count) = size(input)?;
                    let (input, ext_num_count) = size(input)?;
                    let (input, ext_string_count) = size(input)?;
                    let (input, _ext_offset_count) = size(input)?;
                    let (input, ext_table_size) = size(input)?;

                    let (input, booleans) = count(boolean, ext_bool_count)(input)?;

                    let (input, _) = cond(ext_bool_count % 2 != 0, take(1_usize))(input)?;

                    let (input, numbers) =
                        count(|input| capability(input, bit_size(magic)), ext_num_count)(input)?;

                    let (input, strings) = count(|input| capability(input, 16), ext_string_count)(input)?;

                    let (input, names) = count(
                        |input| capability(input, 16),
                        ext_bool_count + ext_num_count + ext_string_count,
                    )(input)?;

                    let (input, table) = take(ext_table_size)(input)?;

                    Ok((input, Extended { booleans, numbers, strings, names, table }))
                }))(input)?;

                Ok((
                    input,
                    Database { names, standard: Standard { booleans, numbers, strings, table }, extended },
                ))
            }

            fn boolean(input: &[u8]) -> IResult<&[u8], bool> {
                alt((map(tag([0]), |_| false), map(tag([1]), |_| true)))(input)
            }

            fn size(input: &[u8]) -> IResult<&[u8], usize> {
                map_opt(le_i16, |n| match n {
                    -1 => Some(0),
                    n if n >= 0 => Some(n as usize),
                    _ => None,
                })(input)
            }

            fn capability(input: &[u8], bits: usize) -> IResult<&[u8], i32> {
                alt((
                    map_opt(
                        cond(bits == 16, map_opt(le_i16, |n| if n >= -2 { Some(n as i32) } else { None })),
                        |o| o,
                    ),
                    map_opt(cond(bits == 32, map_opt(le_i32, |n| if n >= -2 { Some(n) } else { None })), |o| o),
                ))(input)
            }

        }

        pub mod expansion
        {
            use ::
            {
                *,
            };
            /*
            use terminfo::parser::util::number;
            //
            // NOM NOT INCLUDED; REWRITE LIBRARY WITHOUT ITS USE
            //
            use nom::branch::alt;
            use nom::bytes::complete;
            use nom::bytes::streaming::{tag, take, take_while};
            use nom::character::is_digit;
            use nom::character::streaming::one_of;
            use nom::combinator::{map, opt, value};
            use nom::error::{make_error, ErrorKind};
            use nom::IResult;
            */
            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Item<'a> {
                String(&'a [u8]),
                Constant(Constant),
                Variable(Variable),
                Operation(Operation),
                Conditional(Conditional),
                Print(Print),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Constant {
                Character(u8),
                Integer(i32),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Variable {
                Length,
                Push(u8),
                Set(bool, u8),
                Get(bool, u8),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Operation {
                Increment,
                Unary(Unary),
                Binary(Binary),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Unary {
                Not,
                NOT,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Binary {
                Add,
                Subtract,
                Multiply,
                Divide,
                Remainder,

                AND,
                OR,
                XOR,

                And,
                Or,

                Equal,
                Greater,
                Lesser,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Conditional {
                If,
                Then,
                Else,
                End,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub struct Print 
            {
                pub flags: Flags,
                pub format: Format,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Format 
            {
                Chr,
                Uni,
                Str,
                Dec,
                Oct,
                Hex,
                HEX,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Default, Debug)]
            pub struct Flags
            {
                pub width: usize,
                pub precision: usize,
                pub alternate: bool,
                pub left: bool,
                pub sign: bool,
                pub space: bool,
            }
            /*
            pub fn parse(input: &[u8]) -> IResult<&[u8], Item> {
                alt((expansion, string))(input)
            }

            fn string(input: &[u8]) -> IResult<&[u8], Item> {
                map(complete::take_till(|b| b == b'%'), Item::String)(input)
            }

            fn expansion(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = tag("%")(input)?;
                let (input, item) = alt((percent, constant, variable, operation, conditional, print))(input)?;

                Ok((input, item))
            }

            fn percent(input: &[u8]) -> IResult<&[u8], Item> {
                value(Item::String(b"%"), tag("%"))(input)
            }

            fn constant(input: &[u8]) -> IResult<&[u8], Item> {
                alt((constant_char, constant_integer))(input)
            }

            fn constant_char(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = tag("'")(input)?;
                let (input, ch) = take(1_usize)(input)?;
                let (input, _) = tag("'")(input)?;

                Ok((input, Item::Constant(Constant::Character(ch[0]))))
            }

            fn constant_integer(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = tag("{")(input)?;
                let (input, digit) = take_while(is_digit)(input)?;
                let (input, _) = tag("}")(input)?;

                Ok((input, Item::Constant(Constant::Integer(number(digit)))))
            }

            fn variable(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, c) = take(1_usize)(input)?;
                match c {
                    b"l" => Ok((input, Item::Variable(Variable::Length))),

                    b"p" => map(one_of("123456789"), |n| Item::Variable(Variable::Push(n as u8 - b'1')))(input),

                    b"P" => alt((
                        map(one_of("abcdefghijklmnopqrstuvwxyz"), |n| {
                            Item::Variable(Variable::Set(true, n as u8 - b'a'))
                        }),
                        map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| {
                            Item::Variable(Variable::Set(false, n as u8 - b'A'))
                        }),
                    ))(input),

                    b"g" => alt((
                        map(one_of("abcdefghijklmnopqrstuvwxyz"), |n| {
                            Item::Variable(Variable::Get(true, n as u8 - b'a'))
                        }),
                        map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| {
                            Item::Variable(Variable::Get(false, n as u8 - b'A'))
                        }),
                    ))(input),

                    _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch))),
                }
            }

            fn operation(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, c) = take(1_usize)(input)?;
                match c {
                    b"+" => Ok((input, Item::Operation(Operation::Binary(Binary::Add)))),
                    b"-" => Ok((input, Item::Operation(Operation::Binary(Binary::Subtract)))),
                    b"*" => Ok((input, Item::Operation(Operation::Binary(Binary::Multiply)))),
                    b"/" => Ok((input, Item::Operation(Operation::Binary(Binary::Divide)))),
                    b"m" => Ok((input, Item::Operation(Operation::Binary(Binary::Remainder)))),
                    b"i" => Ok((input, Item::Operation(Operation::Increment))),

                    b"&" => Ok((input, Item::Operation(Operation::Binary(Binary::AND)))),
                    b"|" => Ok((input, Item::Operation(Operation::Binary(Binary::OR)))),
                    b"^" => Ok((input, Item::Operation(Operation::Binary(Binary::XOR)))),
                    b"~" => Ok((input, Item::Operation(Operation::Unary(Unary::NOT)))),

                    b"A" => Ok((input, Item::Operation(Operation::Binary(Binary::And)))),
                    b"O" => Ok((input, Item::Operation(Operation::Binary(Binary::Or)))),
                    b"!" => Ok((input, Item::Operation(Operation::Unary(Unary::Not)))),

                    b"=" => Ok((input, Item::Operation(Operation::Binary(Binary::Equal)))),
                    b">" => Ok((input, Item::Operation(Operation::Binary(Binary::Greater)))),
                    b"<" => Ok((input, Item::Operation(Operation::Binary(Binary::Lesser)))),

                    _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch))),
                }
            }

            fn conditional(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, c) = take(1_usize)(input)?;
                match c {
                    b"?" => Ok((input, Item::Conditional(Conditional::If))),
                    b"t" => Ok((input, Item::Conditional(Conditional::Then))),
                    b"e" => Ok((input, Item::Conditional(Conditional::Else))),
                    b";" => Ok((input, Item::Conditional(Conditional::End))),

                    _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch))),
                }
            }

            fn print(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = opt(tag(":"))(input)?;

                let (input, flags) = take_while(is_flag)(input)?;
                let (input, width) = opt(take_while(is_digit))(input)?;
                let (input, precision) = opt(|input| {
                    let (input, _) = tag(".")(input)?;
                    let (input, amount) = take_while(is_digit)(input)?;

                    Ok((input, amount))
                })(input)?;

                let (input, format) = one_of("doxXsc")(input)?;

                Ok((
                    input,
                    Item::Print(Print {
                        flags: Flags {
                            width: number(width.unwrap_or(b"0")) as usize,
                            precision: number(precision.unwrap_or(b"0")) as usize,

                            alternate: flags.contains(&b'#'),
                            left: flags.contains(&b'-'),
                            sign: flags.contains(&b'+'),
                            space: flags.contains(&b' '),
                        },

                        format: match format {
                            'd' => Format::Dec,
                            'o' => Format::Oct,
                            'x' => Format::Hex,
                            'X' => Format::HEX,
                            's' => Format::Str,
                            'c' => Format::Chr,
                            'u' => Format::Uni,
                            _ => unreachable!(),
                        },
                    }),
                ))
            }
            */
            fn is_flag(i: u8) -> bool {
                i == b' ' || i == b'-' || i == b'+' || i == b'#'
            }

        }

        pub mod source
        {
            use ::
            {
                borrow::{ Cow },
                *,
            };
            /*
            use terminfo::parser::util::unescape;
            use terminfo::parser::util::{end, is_eol, is_ws, ws};
            use terminfo::parser::util::{is_printable_no_comma, is_printable_no_control, is_printable_no_pipe};
            //
            // Nom not included; Rewrite without its use.
            //
            use nom::branch::alt;
            use nom::bytes::streaming::{tag, take, take_until, take_while};
            use nom::character::{is_digit, streaming::line_ending as eol};
            use nom::combinator::{complete, map, map_res, opt};
            use nom::error::{make_error, ErrorKind};
            use nom::sequence::terminated;
            use nom::IResult;
            use std::borrow::Cow;
            use std::str;
            */
            #[derive(Eq, PartialEq, Clone, Debug)]
            pub enum Item<'a>
            {
                Comment(&'a str),
                Definition { name: &'a str, aliases: Vec<&'a str>, description: &'a str },
                True(&'a str),
                Number(&'a str, i16),
                String(&'a str, Cow<'a, [u8]>),
                Disable(&'a str),
            }
            /*
            //
            // Nom not included; Rewrite without its use.
            //
            pub fn parse(input: &[u8]) -> IResult<&[u8], Item> {
                alt((comment, definition, disable, entry))(input)
            }

            fn comment(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = tag("#")(input)?;
                let (input, content) = map_res(terminated(take_until("\n"), tag("\n")), str::from_utf8)(input)?;
                let (input, _) = opt(complete(take_while(is::eol)))(input)?;

                Ok((input, Item::Comment(content.trim())))
            }

            fn definition(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, name) =
                    map(take_while(is::printable_no_pipe), |n| unsafe { str::from_utf8_unchecked(n) })(input)?;

                let (input, _) = tag("|")(input)?;

                let (input, content) =
                    map(take_while(is::printable_no_comma), |n| unsafe { str::from_utf8_unchecked(n) })(input)?;

                let (input, _) = tag(",")(input)?;

                let (input, _) = take_while(is_ws)(input)?;

                let (input, _) = eol(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;

                Ok((input, {
                    let mut aliases = content.split(|c| c == '|').map(|n| n.trim()).collect::<Vec<_>>();

                    Item::Definition { name, description: aliases.pop().unwrap(), aliases }
                }))
            }

            fn disable(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = ws(input)?;
                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = tag("@")(input)?;

                let (input, name) =
                    map(take_while(is_printable_no_control), |n| unsafe { str::from_utf8_unchecked(n) })(
                        input,
                    )?;

                let (input, _) = tag(",")(input)?;
                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = end(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;

                Ok((input, Item::Disable(name)))
            }

            fn entry(input: &[u8]) -> IResult<&[u8], Item> {
                let (input, _) = ws(input)?;
                let (input, _) = take_while(is_ws)(input)?;

                let (input, name) =
                    map(take_while(is_printable_no_control), |n| unsafe { str::from_utf8_unchecked(n) })(
                        input,
                    )?;

                let (input, c) = take(1_usize)(input)?;
                let (input, value) = match c {
                    b"," => (input, Item::True(name)),

                    b"#" => {
                        let (input, value) =
                            map(take_while(is_digit), |n| unsafe { str::from_utf8_unchecked(n) })(input)?;

                        let (input, _) = tag(",")(input)?;

                        (input, Item::Number(name, value.parse().unwrap()))
                    }

                    b"=" => {
                        let (input, value) = take_while(is_printable_no_comma)(input)?;

                        let (input, _) = tag(",")(input)?;

                        (input, Item::String(name, unescape(value)))
                    }

                    _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch)))?,
                };

                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = end(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;

                Ok((input, value))
            }
            */
        }
    }
}
/// Cross-platform path manipulation.
pub mod path
{
    pub use std::path::{ * };

    use ::
    {
        *,
    };

    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir()
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                log!( "cicada: PROMPT: env current_dir error: {}", e );
                return String::new();
            }
        };

        let current_dir = match _current_dir.to_str()
        {
            Some( x ) => x,
            None =>
            {
                log!( "cicada: PROMPT: to_str error" );
                return String::new();
            }
        };

        current_dir.to_string()
    }
}
/// Types that pin data to a location in memory.
pub mod pin
{
    pub use std::pin::{ * };
}
/// Types that pin data to a location in memory.
pub mod prelude
{
    pub use std::prelude::v1::{ * };
    
    pub use std::
    {
      assert, assert_eq, assert_ne, cfg, column, compile_error, concat, dbg, debug_assert, debug_assert_eq, 
      debug_assert_ne, env, eprint, eprintln, file, format, format_args, include, include_bytes, include_str, 
      is_x86_feature_detected, line, matches, module_path, option_env, panic, print, println, stringify, thread_local,
      todo, try, unimplemented, unreachable, vec, write, writeln
    };

}
pub use self::prelude::{ * };
/// Reexports the primitive types to allow usage that is not possibly shadowed by other declared types.
pub mod primitive
{
    pub use std::primitive::{ * };

    use ::
    {
        collections::{ HashMap, HashSet },
        database::
        {
            arrays, objects, tuples, INDENT_STEP
        },
        error::over::{ OverError, OverResult },
        num::
        {
            big::{ BigInt },
            rational::{ BigRational },
            traits::{ ToPrimitive }, // Sloppy
        },
        parsers::
        {
            self,
            line::{ tokens_to_redirections },
            over::{ format::Format },
        },
        regex::{ Regex },
    };
    /*
        use ::{ INDENT_STEP };
    */
    macro_rules! get_fn
    {
        ( $doc:expr, $name:tt, $type:ty, $variant:ident ) =>
        {
            #[doc=$doc]
            pub fn $name( &self ) -> OverResult<$type>
            {
                if let Value::$variant( ref inner ) = *self {
                    Ok( inner.clone() )
                } else {
                    Err( OverError::TypeMismatch( Type::$variant, self.get_type() ) )
                }
            }
        }
    }
    
    macro_rules! impl_eq
    {
        ( $valtype:ident, $type:ty ) =>
        {
            impl PartialEq<$type> for Value
            {
                fn eq( &self, other: &$type ) -> bool {
                    match *self {
                        Value::$valtype( ref value ) => value == other,
                        _ => false,
                    }
                }
            }

            impl PartialEq<Value> for $type
            {
                fn eq( &self, other: &Value ) -> bool {
                    match *other {
                        Value::$valtype( ref value ) => value == self,
                        _ => false,
                    }
                }
            }
        };
    }
    
    macro_rules! impl_eq_int
    {
        ( $type:ty, $fn:tt ) =>
        {
            impl PartialEq<$type> for Value
            {
                fn eq( &self, other: &$type ) -> bool {
                    match *self {
                        Value::Int( ref value ) => match value.$fn() {
                            Some( value ) => value == *other,
                            None => false,
                        },
                        _ => false,
                    }
                }
            }

            impl PartialEq<Value> for $type {
                fn eq( &self, other: &Value ) -> bool {
                    match *other {
                        Value::Int( ref value ) => match value.$fn() {
                            Some( value ) => value == *self,
                            None => false,
                        },
                        _ => false,
                    }
                }
            }
        };
    }
    
    macro_rules! impl_from
    {
        ( $type:ty, $fn:tt ) =>
        {
            impl From<$type> for Value
            {
                fn from( inner: $type ) -> Self { Value::$fn( inner.into() ) }
            }
        };
    }
    
    pub type Token = ( String, String );
    pub type Tokens = Vec<Token>;
    pub type Redirection = ( String, String, String );

    #[derive( Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
    pub struct WaitStatus( i32, i32, i32 );

    impl WaitStatus
    {
        pub fn from_exited( pid: i32, status: i32 ) -> Self { WaitStatus( pid, 0, status ) }

        pub fn from_signaled( pid: i32, sig: i32 ) -> Self { WaitStatus( pid, 1, sig ) }

        pub fn from_stopped( pid: i32, sig: i32 ) -> Self { WaitStatus( pid, 2, sig ) }

        pub fn from_continuted( pid: i32 ) -> Self { WaitStatus( pid, 3, 0 ) }

        pub fn from_others() -> Self { WaitStatus( 0, 9, 9 ) }

        pub fn from_error( errno: i32 ) -> Self { WaitStatus( 0, 255, errno ) }

        pub fn empty() -> Self { WaitStatus( 0, 0, 0 ) }

        pub fn is_error( &self ) -> bool { self.1 == 255 }

        pub fn is_others( &self ) -> bool { self.1 == 9 }

        pub fn is_signaled( &self ) -> bool { self.1 == 1 }

        pub fn get_errno( &self ) -> nix::Error { nix::Error::from_raw( self.2 ) }

        pub fn is_exited( &self ) -> bool { self.0 != 0 && self.1 == 0 }

        pub fn is_stopped( &self ) -> bool { self.1 == 2 }

        pub fn is_continued( &self ) -> bool { self.1 == 3 }

        pub fn get_pid( &self ) -> i32 { self.0 }

        fn _get_signaled_status( &self ) -> i32 { self.2 + 128 }

        pub fn get_signal( &self ) -> i32 { self.2 }

        pub fn get_name( &self ) -> String
        {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!( "unknown: {}", self.2 )
            }
        }

        pub fn get_status( &self ) -> i32
        {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl ::fmt::Debug for WaitStatus 
    {
        fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result {
            let mut formatter = f.debug_struct( "WaitStatus" );
            formatter.field( "pid", &self.0 );
            let name = self.get_name();
            formatter.field( "name", &name );
            formatter.field( "ext", &self.2 );
            formatter.finish()
        }
    }
    
    #[derive( Debug )]
    pub struct LineInfo
    {
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo
    {
        pub fn new( tokens: Tokens ) -> Self { LineInfo { tokens, is_complete: true } }
    }
    /// command line: `ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
    /// Command {
    ///     tokens: [( "", "ls" ), ( "", "-G" ), ( "\'", "foo bar" )],
    ///     redirects_to: [
    ///         ( "2", ">", "&1" ),
    ///         ( "1", ">", "/dev/null" ),
    ///     ],
    ///     redirect_from: Some(( "<", "one-file" ) ),
    /// }
    ///
    #[derive( Debug )]
    pub struct Command
    {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    impl Command
    {
        pub fn from_tokens( tokens: Tokens ) -> Result<Command, String>
        {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any( |x| x.1 == "<" || x.1 == "<<<" );

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some( idx ) = tokens_new.iter().position( |x| x.1 == "<" ) {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove( idx );
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove( idx ).1;
                        len -= 1;
                    }
                }
                if let Some( idx ) = tokens_new.iter().position( |x| x.1 == "<<<" ) {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove( idx );
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove( idx ).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any( |x| x.1 == "<" || x.1 == "<<<" );
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections( &tokens_new ) {
                Ok( ( _tokens, _redirects_to )) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err( e ) => {
                    return Err( e );
                }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some(( redirects_from_type, redirects_from_value ) )
            };

            Ok( Command{
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            } )
        }

        pub fn has_redirect_from( &self ) -> bool
        {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string( &self ) -> bool
        {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin( &self ) -> bool { is::builtin( &self.tokens[0].1 ) }
    }

    #[derive( Debug )]
    pub struct CommandLine
    {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl CommandLine
    {
        pub fn from_line( line: &str, sh: &mut shell::Shell ) -> Result<CommandLine, String>
        {
            let linfo = parsers::line::parse( line );
            let mut tokens = linfo.tokens;
            shell::do_expansion( sh, &mut tokens );
            let envs = drain_env_tokens( &mut tokens );

            let mut background = false;
            let len = tokens.len();
            if len > 1 && tokens[len - 1].1 == "&" {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes( &tokens ) {
                match Command::from_tokens( sub_tokens ) {
                    Ok( c ) => {
                        commands.push( c );
                    }
                    Err( e ) => {
                        return Err( e );
                    }
                }
            }

            Ok( CommandLine{
                line: line.to_string(),
                commands,
                envs,
                background,
            } )
        }

        pub fn is_empty( &self ) -> bool {
            self.commands.is_empty()
        }

        pub fn with_pipeline( &self ) -> bool {
            self.commands.len() > 1
        }

        pub fn is_single_and_builtin( &self ) -> bool {
            self.commands.len() == 1 && self.commands[0].is_builtin()
        }
    }

    #[derive( Debug, Clone, Default )]
    pub struct Job
    {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job
    {
        pub fn all_members_stopped( &self ) -> bool
        {
            for pid in &self.pids
            {
                if !self.pids_stopped.contains( pid ) { return false; }
            }

            true
        }

        pub fn all_members_running( &self ) -> bool { self.pids_stopped.is_empty() }
    }
    
    #[derive( Clone, Debug, Default )]
    pub struct CommandResult
    {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult
    {
        pub fn new() -> CommandResult
        {
            CommandResult
            {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status( gid: i32, status: i32 ) -> CommandResult
        {
            CommandResult
            {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult
        {
            CommandResult
            {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }
    
    #[derive( Clone, Debug, Default )]
    pub struct CommandOptions
    {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }
    /// Enum of possible types for `Value`s.
    #[derive( Clone, Debug )]
    pub enum Type
    {
        /// A type used to indicate an empty Arr.
        Any,
        /// Null value.
        Null,

        /// A boolean type.
        Bool,
        /// A signed integer type.
        Int,
        /// A fractional type.
        Frac,
        /// A character type.
        Char,
        /// A string type.
        Str,
        /// An array type, containing the type of its sub-elements.
        Arr( Box<Type> ),
        /// A tuple type, containing the types of its sub-elements.
        Tup( Vec<Type> ),
        /// An object type.
        Obj,
    }

    impl Type
    {
        /// Returns true if this type is strictly the same as `other`.
        pub fn is( &self, other: &Type ) -> bool
        {
            use self::Type::*;
            match *self
            {
                Any => {
                    if let Any = *other {
                        true
                    } else {
                        false
                    }
                }

                Null => {
                    if let Null = *other {
                        true
                    } else {
                        false
                    }
                }
                Bool => {
                    if let Bool = *other {
                        true
                    } else {
                        false
                    }
                }
                Int => {
                    if let Int = *other {
                        true
                    } else {
                        false
                    }
                }
                Frac => {
                    if let Frac = *other {
                        true
                    } else {
                        false
                    }
                }
                Char => {
                    if let Char = *other {
                        true
                    } else {
                        false
                    }
                }
                Str => {
                    if let Str = *other {
                        true
                    } else {
                        false
                    }
                }
                Obj => {
                    if let Obj = *other {
                        true
                    } else {
                        false
                    }
                }

                Arr( ref t1 ) => {
                    if let Arr( ref t2 ) = *other {
                        t1.is( t2 )
                    } else {
                        false
                    }
                }

                Tup( ref tvec1 ) => {
                    if let Tup( ref tvec2 ) = *other {
                        if tvec1.len() != tvec2.len() {
                            return false;
                        }
                        tvec1.iter().zip( tvec2.iter() ).all( |( t1, t2 )| t1.is( t2 ) )
                    } else {
                        false
                    }
                }
            }
        }
        /// Returns true if this `Type` contains `Any`.
        pub fn has_any( &self ) -> bool
        {
            match *self
            {
                Type::Any => true,
                Type::Arr( ref t ) => Self::has_any( t ),
                Type::Tup( ref tvec ) => tvec.iter().any( |t| Self::has_any( t ) ),
                _ => false,
            }
        }
        /// Returns a type with the most specificity that can be applied to the two input types
        /// as well as `true` if the returned type is not maximally specific, that is, it contains `Any`.
        pub fn most_specific( type1: &Type, type2: &Type ) -> Option<( Type, bool )>
        {
            use self::Type::*;

            if let Any = *type2 {
                return Some(( type1.clone(), type1.has_any() ) );
            }

            match *type1 {
                Any => Some(( type2.clone(), type2.has_any() ) ),

                Arr( ref t1 ) => {
                    if let Arr( ref t2 ) = *type2 {
                        Self::most_specific( t1, t2 ).map( |( t, any )| ( Arr( Box::new( t ) ), any ) )
                    } else {
                        None
                    }
                }

                Tup( ref tvec1 ) => {
                    if let Tup( ref tvec2 ) = *type2 {
                        if tvec1.len() == tvec2.len() {
                            let mut has_any = false;

                            let tvec: Option<Vec<Type>> = tvec1
                                .iter()
                                .zip( tvec2.iter() )
                                .map( |( t1, t2 )| {
                                    Self::most_specific( t1, t2 ).map( |( t, any )| {
                                        if !has_any && any {
                                            has_any = any;
                                        }
                                        t
                                    } )
                                } )
                                .collect();

                            tvec.map( |tvec| ( Tup( tvec ), has_any ) )
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                }

                ref t => {
                    if t == type2 {
                        Some(( t.clone(), false ) )
                    } else {
                        None
                    }
                }
            }
        }
    }
    /// Two types are considered equal if one of them is Any or they have the same variant.
    impl PartialEq for Type
    {
        fn eq( &self, other: &Self ) -> bool
        {
            use self::Type::*;
            
            if let Any = *other { return true; }

            match *self
            {
                Any => true,
                Arr( ref box1 ) =>
                {
                    if let Arr( ref box2 ) = *other {
                        box1 == box2
                    } else {
                        false
                    }
                }

                Tup( ref tvec1 ) =>
                {
                    if let Tup( ref tvec2 ) = *other {
                        tvec1 == tvec2
                    } else {
                        false
                    }
                }

                _ => self.is( other ),
            }
        }
    }

    impl Eq for Type {}

    impl ::fmt::Display for Type
    {
        fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
        {
            use self::Type::*;

            match *self
            {
                Any => write!( f, "Any" ),
                Null => write!( f, "Null" ),
                Bool => write!( f, "Bool" ),
                Int => write!( f, "Int" ),
                Frac => write!( f, "Frac" ),
                Char => write!( f, "Char" ),
                Str => write!( f, "Str" ),
                Arr( ref boxxy ) => write!( f, "Arr( {} )", boxxy ),
                Tup( ref tvec ) => write!
                ( 
                    f,
                    "Tup( {} )",
                    match tvec.get( 0 )
                    {
                        Some( t1 ) => tvec
                        .iter()
                        .skip( 1 )
                        .fold( format!( "{}", t1 ), |s, t| format!( "{}, {}", s, t ) ),
                        None => String::from( "" ),
                    }
                ),
                Obj => write!( f, "Obj" ),
            }
        }
    }
    /// Enum of possible values and their inner types.
    #[derive( Clone, Debug, PartialEq )]
    pub enum Value
    {
        /// A null value.
        Null,
        /// A boolean value.
        Bool( bool ),
        /// A signed integer value.
        Int( BigInt ),
        /// A fractional value.
        Frac( BigRational ),
        /// A character value.
        Char( char ),
        /// A string value.
        Str( String ),
        /// An array value.
        Arr( arr::Arr ),
        /// A tuple value.
        Tup( tup::Tup ),
        /// An object value.
        Obj( obj::Obj ),
    }

    impl Value
    {
        /// Returns true if this `Value` is null.
        pub fn is_null( &self ) -> bool
        {
            if let Value::Null = *self { true } else { false }
        }
        /// Returns the `Type` of this `Value`.
        pub fn get_type( &self ) -> Type
        {
            use self::Value::*;
            match *self
            {
                Null => Type::Null,
                Bool( _ ) => Type::Bool,
                Int( _ ) => Type::Int,
                Frac( _ ) => Type::Frac,
                Char( _ ) => Type::Char,
                Str( _ ) => Type::Str,
                Arr( ref arr ) => Type::Arr( Box::new( arr.inner_type() ) ),
                Tup( ref tup ) => Type::Tup( tup.inner_type_vec() ),
                Obj( _ ) => Type::Obj,
            }
        }

        get_fn!
        ( 
            "Returns the `bool` contained in this `Value`.",
            get_bool,
            bool,
            Bool
        );
        get_fn!
        ( 
            "Returns the `BigInt` contained in this `Value`.",
            get_int,
            BigInt,
            Int
        );
        /// Returns the `BigRational` contained in this `Value`.
        pub fn get_frac( &self ) -> OverResult<BigRational>
        {
            match *self
            {
                Value::Frac( ref inner ) => Ok( inner.clone() ),
                Value::Int( ref inner ) => Ok( frac!( inner.clone(), 1 ) ),
                _ => Err( OverError::TypeMismatch( Type::Frac, self.get_type() ) ),
            }
        }

        get_fn!
        ( 
            "Returns the `char` contained in this `Value`.",
            get_char,
            char,
            Char
        );
        get_fn!
        ( 
            "Returns the `String` contained in this `Value`.",
            get_str,
            String,
            Str
        );
        get_fn!
        ( 
            "Returns the `Obj` contained in this `Value`.",
            get_obj,
            obj::Obj,
            Obj
        );
        /// Returns the `Arr` contained in this `Value`.
        pub fn get_arr( &self ) -> OverResult<arr::Arr>
        {
            if let Value::Arr( ref inner ) = *self { Ok( inner.clone() ) }
            else
            {
                Err( OverError::TypeMismatch
                ( 
                    Type::Arr( Box::new( Type::Any ) ),
                    self.get_type(),
                ))
            }
        }
        /// Returns the `Tup` contained in this `Value`.
        pub fn get_tup( &self ) -> OverResult<tup::Tup>
        {
            if let Value::Tup( ref inner ) = *self { Ok( inner.clone() ) }
            else { Err( OverError::TypeMismatch( Type::Tup( vec![] ), self.get_type() ) ) }
        }
    }

    impl ::fmt::Display for Value
    {
        fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
        { write!( f, "{}", self.format( true, INDENT_STEP ) ) }
    }
    
    impl<'a> PartialEq<&'a str> for Value
    {
        fn eq( &self, other: &&str ) -> bool
        {
            match *self
            {
                Value::Str( ref value ) => value == &other.replace( "\r\n", "\n" ),
                _ => false,
            }
        }
    }

    impl<'a> PartialEq<Value> for &'a str
    {
        fn eq( &self, other: &Value ) -> bool
        {
            match *other
            {
                Value::Str( ref value ) => value == &self.replace( "\r\n", "\n" ),
                _ => false,
            }
        }
    }

    impl PartialEq<String> for Value
    {
        fn eq( &self, other: &String ) -> bool { &other.as_str() == self }
    }

    impl PartialEq<Value> for String
    {
        fn eq( &self, other: &Value ) -> bool { &self.as_str() == other }
    }

    impl<'a> From<&'a str> for Value
    {
        fn from( inner: &str ) -> Self { Value::Str( inner.into() ) }
    }

    impl_eq!( Bool, bool );
    impl_eq!( Int, BigInt );
    impl_eq!( Frac, BigRational );
    impl_eq!( Char, char );
    impl_eq!( Arr, arr::Arr );
    impl_eq!( Tup, tup::Tup );
    impl_eq!( Obj, obj::Obj );
    impl_eq_int!( usize, to_usize );
    impl_eq_int!( u8, to_u8 );
    impl_eq_int!( u16, to_u16 );
    impl_eq_int!( u32, to_u32 );
    impl_eq_int!( u64, to_u64 );
    impl_eq_int!( i8, to_i8 );
    impl_eq_int!( i16, to_i16 );
    impl_eq_int!( i32, to_i32 );
    impl_eq_int!( i64, to_i64 );
    impl_from!( bool, Bool );
    impl_from!( usize, Int );
    impl_from!( u8, Int );
    impl_from!( u16, Int );
    impl_from!( u32, Int );
    impl_from!( u64, Int );
    impl_from!( i8, Int );
    impl_from!( i16, Int );
    impl_from!( i32, Int );
    impl_from!( i64, Int );
    impl_from!( BigInt, Int );
    impl_from!( BigRational, Frac );
    impl_from!( char, Char );
    impl_from!( String, Str );
    impl_from!( arrays::Arr, Arr );
    impl_from!( tuples::Tup, Tup );
    impl_from!( objects::Obj, Obj );

    fn split_tokens_by_pipes( tokens: &[Token] ) -> Vec<Tokens>
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens
        {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push( cmd.clone() );
                cmd = Vec::new();
            } else {
                cmd.push( token.clone() );
            }
        }
        if cmd.is_empty() {
            return Vec::new();
        }
        cmds.push( cmd.clone() );
        cmds
    }

    fn drain_env_tokens( tokens: &mut Tokens ) -> HashMap<String, String>
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new( r"^( [a-zA-Z0-9_]+ )=( .* )$" ).unwrap();
        
        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !contains( text, r"^( [a-zA-Z0-9_]+ )=( .* )$" ) { break; }

            for cap in re.captures_iter( text )
            {
                let name = cap[1].to_string();
                let value = parsers::line::unquote( &cap[2] );
                envs.insert( name, value );
            }

            n += 1;
        }

        if n > 0 { tokens.drain( 0..n ); }

        envs
    }
}
/// A module for working with processes.
pub mod process
{
    pub use std::process::{ * };

    use ::
    {
        libc::{ c_int },
        nix::
        {
            unistd::{ fork as nix_fork, ForkResult },
            Error, Result,
        },
        os::fd::{ RawFd },
        *,
    };

    pub fn close( fd: i32 ) { unsafe { libc::close( fd ); } }

    pub fn dup( fd: i32 ) -> i32 { unsafe { libc::dup( fd ) } }

    pub fn dup2( src: i32, dst: i32 ) { unsafe { libc::dup2( src, dst ); } }
    
    pub fn fork() -> Result<ForkResult> { unsafe{ nix_fork() } }    

    pub fn pipe() -> ::result::Result<( RawFd, RawFd ), Error>
    {
        unsafe
        {
            let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
            let res = libc::pipe( fds.as_mut_ptr() as *mut c_int );
            Error::result( res )?;
            Ok( ( fds.assume_init()[0], fds.assume_init()[1] ) )
        }
    }
    /*
    fn proc_has_terminal(...) -> bool */
    pub fn has_terminal() -> bool
    {
        unsafe
        {
            let tgid = libc::tcgetpgrp( 0 );
            let pgid = libc::getpgid( 0 );
            tgid == pgid
        }
    }
}
/// A module for working with processes.
pub mod ptr
{
    pub use std::ptr::{ * };
}
/// Single-threaded reference-counting pointers.
pub mod rc
{
    pub use std::rc::{ * };
}
/// Regular expressions
pub mod regex
{
    pub use re::{ * };

    pub fn find_first_group( ptn:&str, text:&str ) -> Option<String>
    {
        let re = match regex::Regex::new( ptn )
        {
            Ok( x ) => x,
            Err( _ ) => return None,
        };

        match re.captures( text )
        {
            Some( caps ) =>
            {
                if let Some( x ) = caps.get( 1 )
            { return Some( x.as_str().to_owned() ); }
            }

            None => { return None; }
        }

        None
    }

    pub fn contains( text:&str, ptn:&str ) -> bool
    {
        let re = match regex::Regex::new( ptn )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println!( "Regex new error: {:?}", e );
                return false;
            }
        };

        re.is_match( text )
    }

    pub fn replace_all( text:&str, ptn:&str, ptn_to:&str ) -> String
    {
        let re = regex::Regex::new( ptn ).unwrap();
        let result = re.replace_all( text, ptn_to );
        result.to_string()
    }

    pub fn first_word(buf: &str, word_break: &str) -> Option<usize>
    {
        let mut chars = buf.char_indices();

        drop_while(&mut chars, |(_, ch)| word_break.contains(ch));

        chars.next().map(|(idx, _)| idx)
    }
    
    pub fn get_open_paren(ch: char) -> Option<char>
    {
        match ch
        {
            ')' => Some('('),
            ']' => Some('['),
            '}' => Some('{'),
            _ => None
        }
    }

    pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize>
    {
        let mut chars = s.char_indices().rev();
        let mut level = 0;
        let mut string_delim = None;

        while let Some((ind, ch)) = chars.next()
        {
            if string_delim == Some(ch) { string_delim = None; }
            else if quotes.contains(ch) { string_delim = Some(ch); }
            else if string_delim.is_none() && ch == close { level += 1; }
            
            else if string_delim.is_none() && ch == open
            {
                level -= 1;
                if level == 0 { return Some(ind); }
            }
        }

        None
    }
}
/// Error handling with the Result type.
pub mod result
{
    pub use std::result::{ * };
}
/**/
pub mod scripts
{
    use ::
    {
        path::{ self, Path },
        *,
    };
    /*
    pub fn run_script( ... ) -> i32 */
    pub fn run( sh:&mut shell::Shell, args:&Vec<String> ) -> i32
    {
        let src_file = &args[1];
        let full_src_file: String;
        if src_file.contains( '/' )
            {
            full_src_file = src_file.clone();
        } else {
            let full_path = path::find_file_in_path( src_file, false );
            if full_path.is_empty()
            {
                // not in PATH and not in current work directory
                if !Path::new( src_file ).exists()
            {
                    println_stderr!( "cicada: {}: no such file", src_file );
                    return 1;
                }
                full_src_file = format!( "./{}", src_file );
            } else {
                full_src_file = full_path.clone();
            }
        }

        if !Path::new( &full_src_file ).exists()
            {
            println_stderr!( "cicada: {}: no such file", src_file );
            return 1;
        }
        if Path::new( &full_src_file ).is_dir()
            {
            println_stderr!( "cicada: {}: is a directory", src_file );
            return 1;
        }

        let mut file;
        match File::open( &full_src_file )
            {
            Ok( x ) => file = x,
            Err( e ) => {
                println_stderr!( "cicada: {}: failed to open file - {:?}", &full_src_file, e.kind() );
                return 1;
            }
        }
        let mut text = String::new();
        match file.read_to_string( &mut text )
            {
            Ok( _ ) => {}
            Err( e ) => {
                match e.kind()
            {
                    ErrorKind::InvalidData => {
                        println_stderr!( "cicada: {}: not a valid script file", &full_src_file );
                    }
                    _ => {
                        println_stderr!( "cicada: {}: error: {:?}", &full_src_file, e );
                    }
                }
                return 1;
            }
        }

        if text.contains( "\\\n" )
            {
            let re = RegexBuilder::new( r#"( [ \t]*\\\n[ \t]+ )|( [ \t]+\\\n[ \t]* )"# )
                .multi_line( true ).build().unwrap();
            text = re.replace_all( &text, " " ).to_string();

            let re = RegexBuilder::new( r#"\\\n"# ).multi_line( true ).build().unwrap();
            text = re.replace_all( &text, "" ).to_string();
        }

        let re_func_head = Regex::new( r"^function ( [a-zA-Z_-][a-zA-Z0-9_-]* ) *( ?:\( \ ) )? *\{$" ).unwrap();
        let re_func_tail = Regex::new( r"^\}$" ).unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();
        for line in text.clone().lines()
            {
            if re_func_head.is_match( line.trim() )
            {
                enter_func = true;
                let cap = re_func_head.captures( line.trim() ).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }
            if re_func_tail.is_match( line.trim() )
            {
                sh.set_func( &func_name, &func_body );
                enter_func = false;
                continue;
            }
            if enter_func {
                func_body.push_str( line );
                func_body.push( '\n' );
            } else {
                text_new.push_str( line );
                text_new.push( '\n' );
            }
        }

        let mut status = 0;
        let cr_list = run_lines( sh, &text_new, args, false );
        if let Some( last ) = cr_list.last()
            {
            status = last.status;
        }
        
        sh.exit_on_error = false;

        status
    }
}
/// Prevents outside implementations of our extension traits.
mod sealed
{
    /// This trait being unreachable from outside the crate prevents outside implementations of our extension traits.
    pub trait Sealed {}
}
/// Shell
pub mod shell
{
    use ::
    {
        collections::{HashMap, HashSet},
        *,
    };
    /*
    use ::error::errno;
    use std::collections::{HashMap, HashSet};
    use std::env;
    use std::io::Write;
    use std::mem;

    use regex::Regex;
    use uuid::Uuid;

    use ::core;
    use ::libs;
    use ::parsers;
    use ::tools;
    use ::types::{self, CommandLine};
    */
    #[derive( Debug, Clone )]
    pub struct Shell
    {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login:bool,
        pub exit_on_error:bool,
        pub has_terminal:bool,
        pub session_id: String,
    }

    impl Shell
    {
        pub fn new() -> Shell {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = tools::get_current_dir();
            let has_terminal = process::has_terminal();
            let ( session_id, _ ) = uuid.split_at( 13 );
            Shell
            {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }

        pub fn insert_job( &mut self, gid: i32, pid: i32, cmd:&str, status:&str, bg:bool )
            {
            let mut i = 1;
            loop {
                let mut indexed_job_missing = false;
                if let Some( x ) = self.jobs.get_mut( &i )
            {
                    if x.gid == gid {
                        x.pids.push( pid );
                        x.cmd = format!( "{} | {}", x.cmd, cmd );
                        return;
                    }
                } else {
                    indexed_job_missing = true;
                }

                if indexed_job_missing {
                    self.jobs.insert( 
                        i,
                        types::Job {
                            cmd: cmd.to_string(),
                            id: i,
                            gid,
                            pids: vec![pid],
                            pids_stopped: HashSet::new(),
                            status: status.to_string(),
                            is_bg: bg,
                        },
                   );
                    return;
                }
                i += 1;
            }
        }

        pub fn get_job_by_id( &self, job_id: i32 ) -> Option<&types::Job> {
            self.jobs.get( &job_id )
        }

        pub fn mark_job_member_continued( &mut self, pid: i32,
                                        gid: i32 ) -> Option<&types::Job> {
            if self.jobs.is_empty()
            {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some( job ) = self.jobs.get_mut( &i )
            {
                    if job.gid == gid {
                        job.pids_stopped.remove( &pid );
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get( &idx_found )
        }

        pub fn mark_job_member_stopped( &mut self, pid: i32,
                                    gid: i32 ) -> Option<&types::Job> {
            if self.jobs.is_empty()
            {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some( job ) = self.jobs.get_mut( &i )
            {
                    if job.gid == gid {
                        job.pids_stopped.insert( pid );
                        idx_found = i;
                        break;
                    }
                }


                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            self.jobs.get( &idx_found )
        }

        pub fn get_job_by_gid( &self, gid: i32 ) -> Option<&types::Job> {
            if self.jobs.is_empty()
            {
                return None;
            }

            let mut i = 1;
            loop {
                if let Some( x ) = self.jobs.get( &i )
            {
                    if x.gid == gid {
                        return Some( x );
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
            None
        }

        pub fn mark_job_as_running( &mut self, gid: i32, bg:bool )
            {
            if self.jobs.is_empty()
            {
                return;
            }

            let mut i = 1;
            loop {
                if let Some( job ) = self.jobs.get_mut( &i )
            {
                    if job.gid == gid {
                        job.status = "Running".to_string();
                        job.pids_stopped.clear();
                        job.is_bg = bg;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn mark_job_as_stopped( &mut self, gid: i32 )
            {
            if self.jobs.is_empty()
            {
                return;
            }

            let mut i = 1;
            loop {
                if let Some( x ) = self.jobs.get_mut( &i )
            {
                    if x.gid == gid {
                        x.status = "Stopped".to_string();
                        x.is_bg = true;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }

        pub fn remove_pid_from_job( &mut self, gid: i32, pid: i32 ) -> Option<types::Job> {
            if self.jobs.is_empty()
            {
                return None;
            }

            let mut empty_pids = false;
            let mut i = 1;
            loop {
                if let Some( x ) = self.jobs.get_mut( &i )
            {
                    if x.gid == gid {
                        if let Ok( i_pid ) = x.pids.binary_search( &pid )
            {
                            x.pids.remove( i_pid );
                        }
                        empty_pids = x.pids.is_empty();
                        break;
                    }
                }

                i += 1;
                if i >= 65535 {
                    break;
                }
            }

            if empty_pids {
                return self.jobs.remove( &i );
            }
            None
        }

        /// Update existing *ENV Variable* if such name exists in ENVs,
        /// otherwise, we define a local *Shell Variable*, which would not
        /// be exported into child processes.
        pub fn set_env( &mut self, name:&str, value:&str )
            {
            if env::var( name ).is_ok()
            {
                env::set_var( name, value );
            } else {
                self.envs.insert( name.to_string(), value.to_string() );
            }
        }

        /// get *Shell Variable*, or *ENV Variable*.
        pub fn get_env( &self, name:&str ) -> Option<String> {
            match self.envs.get( name )
            {
                Some( x ) => Some( x.to_string() ),
                None => {
                    match env::var( name )
            {
                        Ok( x ) => Some( x ),
                        Err( _ ) => None,
                    }
                }
            }
        }

        /// Remove environment variable, function from the environment of
        /// the currently running process
        pub fn remove_env( &mut self, name:&str ) -> bool {
            // function names can contain the `-` char.
            let ptn_env = Regex::new( r"^[a-zA-Z_][a-zA-Z0-9_-]*$" ).unwrap();
            if !ptn_env.is_match( name )
            {
                return false;
            }

            env::remove_var( name );
            self.envs.remove( name );
            self.remove_func( name );
            true
        }

        pub fn remove_path( &mut self, path:&str )
            {
            if let Ok( paths ) = env::var( "PATH" )
            {
                let mut paths_new: Vec<&str> = paths.split( ":" ).collect();
                paths_new.retain( |&x| x != path );
                env::set_var( "PATH", paths_new.join( ":" ).as_str() );
            }
        }

        fn remove_func( &mut self, name:&str )
            {
            self.funcs.remove( name );
        }

        pub fn set_func( &mut self, name:&str, value:&str )
            {
            self.funcs.insert( name.to_string(), value.to_string() );
        }

        pub fn get_func( &self, name:&str ) -> Option<String> {
            self.funcs.get( name ).map( |x| x.to_string() )
        }

        pub fn get_alias_list( &self ) -> Vec<( String, String )> {
            let mut result = Vec::new();
            for ( name, value ) in &self.aliases {
                result.push( ( name.clone(), value.clone() ) );
            }
            result
        }

        pub fn add_alias( &mut self, name:&str, value:&str )
            {
            self.aliases.insert( name.to_string(), value.to_string() );
        }

        pub fn is_alias( &self, name:&str ) -> bool {
            self.aliases.contains_key( name )
        }

        pub fn remove_alias( &mut self, name:&str ) -> bool {
            let opt = self.aliases.remove( name );
            opt.is_some()
        }

        pub fn get_alias_content( &self, name:&str ) -> Option<String> {
            let result = match self.aliases.get( name )
            {
                Some( x ) => x.to_string(),
                None => String::new(),
            };
            if result.is_empty()
            {
                None
            } else {
                Some( result )
            }
        }
    }

    pub unsafe fn give_terminal_to( gid: i32 ) -> bool
    {
        let mut mask: libc::sigset_t = mem::zeroed();
        let mut old_mask: libc::sigset_t = mem::zeroed();

        libc::sigemptyset( &mut mask );
        libc::sigaddset( &mut mask, libc::SIGTSTP );
        libc::sigaddset( &mut mask, libc::SIGTTIN );
        libc::sigaddset( &mut mask, libc::SIGTTOU );
        libc::sigaddset( &mut mask, libc::SIGCHLD );

        let rcode = libc::pthread_sigmask( libc::SIG_BLOCK, &mask, &mut old_mask );
        if rcode != 0 {
            log!( "failed to call pthread_sigmask" );
        }
        let rcode = libc::tcsetpgrp( 1, gid );
        let given;
        if rcode == -1 {
            given = false;
            let e = errno();
            let code = e.0;
            log!( "error in give_terminal_to()
            {}: {}", code, e );
        } else {
            given = true;
        }
        let rcode = libc::pthread_sigmask( libc::SIG_SETMASK, &old_mask, &mut mask );
        if rcode != 0 {
            log!( "failed to call pthread_sigmask" );
        }
        given
    }

    pub fn env_in_token( token:&str ) -> bool
    {
        if regex::contains( token, r"\$\{?[\$\?]\}?" )
            {
            return true;
        }

        let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
        let ptn_env = format!( r"\$\{{?{}\}}?", ptn_env_name );
        if !regex::contains( token, &ptn_env )
            {
            return false;
        }

        // do not expand env in a command substitution, e.g.:
        // - echo $( echo '$HOME' )
        // - VERSION=$( foobar -h | grep 'version: v' | awk '{print $NF}' )
        let ptn_cmd_sub1 = format!( r"^{}=`.*`$", ptn_env_name );
        let ptn_cmd_sub2 = format!( r"^{}=\$\( .*\ )$", ptn_env_name );
        if regex::contains( token, &ptn_cmd_sub1 )
            || regex::contains( token, &ptn_cmd_sub2 )
            || regex::contains( token, r"^\$\( .+\ )$" )
        {
            return false;
        }

        // for cmd-line like `alias foo='echo $PWD'`
        let ptn_env = format!( r"='.*\$\{{?{}\}}?.*'$", ptn_env_name );
        !regex::contains( token, &ptn_env )
    }

    fn do_command_substitution_for_dollar( sh:&mut Shell, tokens:&mut Tokens )
            {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();

        for ( sep, token ) in tokens.iter()
            {
            if sep == "'" || sep == "\\" || !should_do_dollar_command_extension( token )
            {
                idx += 1;
                continue;
            }

            let mut line = token.to_string();
            loop {
                if !should_do_dollar_command_extension( &line )
            {
                    break;
                }

                let ptn_cmd = r"\$\( ( .+ )\ )";
                let cmd = match regex::find_first_group( ptn_cmd, &line )
            {
                    Some( x ) => x,
                    None => {
                        println_stderr!( "cicada: calculator: no first group" );
                        return;
                    }
                };

                let cmd_result = match CommandLine::from_line( &cmd, sh )
            {
                    Ok( c ) => {
                        log!( "run subcmd dollar: {:?}", &cmd );
                        let ( term_given, cr ) = core::run_pipeline( sh, &c, true, true, false );
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid( 0 );
                                give_terminal_to( gid );
                            }
                        }

                        cr
                    }
                    Err( e ) => {
                        println_stderr!( "cicada: {}", e );
                        continue;
                    }
                };

                let output_txt = cmd_result.stdout.trim();

                let ptn = r"( ?P<head>[^\$]* )\$\( .+\ )( ?P<tail>.* )";
                let re;
                if let Ok( x ) = Regex::new( ptn )
            {
                    re = x;
                } else {
                    return;
                }

                let to = format!( "${{head}}{}${{tail}}", output_txt );
                let line_ = line.clone();
                let result = re.replace( &line_, to.as_str() );
                line = result.to_string();
            }

            buff.insert( idx, line.clone() );
            idx += 1;
        }

        for ( i, text ) in buff.iter()
            {
            tokens[*i].1 = text.to_string();
        }
    }

    fn do_command_substitution_for_dot( sh:&mut Shell, tokens:&mut Tokens )
            {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();
        for ( sep, token ) in tokens.iter()
            {
            let new_token: String;
            if sep == "`" {
                log!( "run subcmd dot1: {:?}", token );
                let cr = match CommandLine::from_line( token, sh )
            {
                    Ok( c ) => {
                        let ( term_given, _cr ) = core::run_pipeline( sh, &c, true, true, false );
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid( 0 );
                                give_terminal_to( gid );
                            }
                        }

                        _cr
                    }
                    Err( e ) => {
                        println_stderr!( "cicada: {}", e );
                        continue;
                    }
                };

                new_token = cr.stdout.trim().to_string();
            } else if sep == "\"" || sep.is_empty()
            {
                let re;
                if let Ok( x ) = Regex::new( r"^( [^`]* )`( [^`]+ )`( .* )$" )
            {
                    re = x;
                } else {
                    println_stderr!( "cicada: re new error" );
                    return;
                }
                if !re.is_match( token )
            {
                    idx += 1;
                    continue;
                }
                let mut _token = token.clone();
                let mut _item = String::new();
                let mut _head = String::new();
                let mut _output = String::new();
                let mut _tail = String::new();
                loop {
                    if !re.is_match( &_token )
            {
                        if !_token.is_empty()
            {
                            _item = format!( "{}{}", _item, _token );
                        }
                        break;
                    }
                    for cap in re.captures_iter( &_token )
            {
                        _head = cap[1].to_string();
                        _tail = cap[3].to_string();
                        log!( "run subcmd dot2: {:?}", &cap[2] );

                        let cr = match CommandLine::from_line( &cap[2], sh )
            {
                            Ok( c ) => {
                                let ( term_given, _cr ) = core::run_pipeline( sh, &c, true, true, false );
                                if term_given {
                                    unsafe {
                                        let gid = libc::getpgid( 0 );
                                        give_terminal_to( gid );
                                    }
                                }

                                _cr
                            }
                            Err( e ) => {
                                println_stderr!( "cicada: {}", e );
                                continue;
                            }
                        };

                        _output = cr.stdout.trim().to_string();
                    }
                    _item = format!( "{}{}{}", _item, _head, _output );
                    if _tail.is_empty()
            {
                        break;
                    }
                    _token = _tail.clone();
                }
                new_token = _item;
            } else {
                idx += 1;
                continue;
            }

            buff.insert( idx, new_token.clone() );
            idx += 1;
        }

        for ( i, text ) in buff.iter()
            {
            tokens[*i].1 = text.to_string();
        }
    }

    pub fn do_expansion( sh:&mut Shell, tokens:&mut Tokens )
    {
        let line = parsers::line::tokens_to_line( tokens );
        if is::arithmetic( &line ) { return; }

        if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with( "PROMPT=" ) { return; }

        expand::alias( sh, tokens );
        expand::home( tokens );
        expand::env( sh, tokens );
        expand::brace( tokens );
        expand::glob( tokens );
        do_command_substitution( sh, tokens );
        expand::brace_range( tokens );
    }

    pub fn trim_multiline_prompts( line:&str ) -> String
    {
        let line_new = regex::replace_all( line, r"\\\n>> ", "" );
        let line_new = regex::replace_all( &line_new, r"\| *\n>> ", "| " );
        regex::replace_all( &line_new, r"( ?P<NEWLINE>\n )>> ", "$NEWLINE" )
    }

    fn do_command_substitution( sh:&mut Shell, tokens:&mut Tokens )
    {
        do_command_substitution_for_dot( sh, tokens );
        do_command_substitution_for_dollar( sh, tokens );
    }
}
/// Send and receive signals to processes
pub mod signals
{
    pub use nix::sys::signal::{ * };
    use ::
    {
        collections::{ HashMap, HashSet },
        error::{ errno, set_errno },
        iter::{ FromIterator },
        nix::
        {
            sys::wait::{ WaitPidFlag as WF, WaitStatus as WS, waitpid },
            unistd::{ Pid },
        },
        sync::{ Mutex },

        *,
    };

    macro_rules! impl_op
    {
        ( $tr:ident , $tr_meth:ident , $method:ident ) =>
        {
            impl ops::$tr for SignalSet
            {
                type Output = SignalSet;
                fn $tr_meth( self, rhs: SignalSet ) -> SignalSet { self.$method( rhs ) }
            }
        }
    }

    macro_rules! impl_mut_op
    {
        ( $tr:ident , $tr_meth:ident , $method:ident ) =>
        {
            impl ops::$tr for SignalSet 
            {
                fn $tr_meth( &mut self, rhs: SignalSet )
            { *self = self.$method( rhs ); }
            }
        }
    }

    macro_rules! impl_unary_op
    {
        ( $tr:ident , $tr_meth:ident , $method:ident ) =>
        {
            impl ops::$tr for SignalSet
            {
                type Output = SignalSet;
                fn $tr_meth( self ) -> SignalSet { self.$method() }
            }
        }
    }

    lazy_static!
    {
        static ref REAP_MAP: Mutex<HashMap<i32, i32>> = Mutex::new( HashMap::new() );
        static ref STOP_MAP: Mutex<HashSet<i32>> = Mutex::new( HashSet::new() );
        static ref CONT_MAP: Mutex<HashSet<i32>> = Mutex::new( HashSet::new() );
        static ref KILL_MAP: Mutex<HashMap<i32, i32>> = Mutex::new( HashMap::new() );
    }
    
    pub const NUM_SIGNALS: u8 = 6;
    /// Signal received through a terminal device
    #[derive( Copy, Clone, Debug, Eq, PartialEq )]
    pub enum Signal 
    {
        /// Break signal ( `CTRL_BREAK_EVENT` ); Windows only
        Break,
        /// Continue signal ( `SIGCONT` ); Unix only
        Continue,
        /// Interrupt signal ( `SIGINT` on Unix, `CTRL_C_EVENT` on Windows )
        Interrupt,
        /// Terminal window resize ( `SIGWINCH` on Unix,
        /// `WINDOW_BUFFER_SIZE_EVENT` on Windows )
        ///
        /// When this signal is received, it will be translated into an
        /// `Event::Resize( _ )` value containing the new size of the terminal.
        Resize,
        /// Suspend signal ( `SIGTSTP` ); Unix only
        Suspend,
        /// Quit signal ( `SIGQUIT` ); Unix only
        Quit
    }
    
    impl Signal
    {
        fn as_bit( &self ) -> u8 { 1 << ( *self as u8 ) }

        fn all_bits() -> u8 { ( 1 << NUM_SIGNALS ) - 1 }
    }

    impl ops::BitOr for Signal
    {
        type Output = SignalSet;

        fn bitor( self, rhs: Signal ) -> SignalSet
        {
            let mut set = SignalSet::new();

            set.insert( self );
            set.insert( rhs );
            set
        }
    }

    impl ops::Not for Signal
    {
        type Output = SignalSet;

        fn not( self ) -> SignalSet { !SignalSet::from( self ) }
    }
    /// Represents a set of `Signal` values
    #[derive( Copy, Clone, Default, Eq, PartialEq )]
    pub struct SignalSet( u8 );

    impl SignalSet
    {
        /// Returns an empty `SignalSet`.
        pub fn new() -> SignalSet { SignalSet( 0 ) }
        /// Returns a `SignalSet` containing all available signals.
        pub fn all() -> SignalSet { SignalSet( Signal::all_bits() ) }
        /// Returns whether this set contains the given `Signal`.
        pub fn contains( &self, sig: Signal ) -> bool { self.0 & sig.as_bit() != 0 }
        /// Returns whether this set contains all signals present in another set.
        pub fn contains_all( &self, other: SignalSet ) -> bool { self.0 & other.0 == other.0 }
        /// Returns whether this set contains any signals present in another set.
        pub fn intersects( &self, other: SignalSet ) -> bool { self.0 & other.0 != 0 }
        /// Returns whether this set contains any signals.
        pub fn is_empty( &self ) -> bool { self.0 == 0 }
        /// Inserts a `Signal` into this set.
        pub fn insert( &mut self, sig: Signal )
            { self.0 |= sig.as_bit(); }
        /// Removes a `Signal` from this set.
        pub fn remove( &mut self, sig: Signal )
            { self.0 &= !sig.as_bit(); }
        /// Sets whether this set contains the given `Signal`.
        pub fn set( &mut self, sig: Signal, set:bool )
        {
            if set { self.insert( sig ); }
            else { self.remove( sig ); }
        }
        /// Returns the difference of two sets.
        pub fn difference( &self, other: SignalSet ) -> SignalSet { SignalSet( self.0 & !other.0 ) }
        /// Returns the symmetric difference of two sets.
        pub fn symmetric_difference( &self, other: SignalSet ) -> SignalSet { SignalSet( self.0 ^ other.0 ) }
        /// Returns the intersection of two sets.
        pub fn intersection( &self, other: SignalSet ) -> SignalSet { SignalSet( self.0 & other.0 ) }
        /// Returns the union of two sets.
        pub fn union( &self, other: SignalSet ) -> SignalSet { SignalSet( self.0 | other.0 ) }
        /// Returns the inverse of the set.
        pub fn inverse( &self ) -> SignalSet { SignalSet( !self.0 & Signal::all_bits() ) }
    }

    impl fmt::Debug for SignalSet
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> Displayed
        {
            const SIGNALS:&[Signal] = &
            [
                Signal::Break,
                Signal::Continue,
                Signal::Interrupt,
                Signal::Resize,
                Signal::Suspend,
                Signal::Quit,
            ];

            let mut first = true;

            f.write_str( "SignalSet( " )?;

            for &sig in SIGNALS
            {
                if self.contains( sig )
                {
                    if !first { f.write_str( " | " )?; }

                    write!( f, "{:?}", sig )?;
                    first = false;
                }
            }

            f.write_str( " )" )
        }
    }

    impl From<Signal> for SignalSet
    {
        fn from( sig: Signal ) -> SignalSet
        {
            let mut set = SignalSet::new();
            set.insert( sig );
            set
        }
    }

    impl Extend<Signal> for SignalSet
    {
        fn extend<I: IntoIterator<Item=Signal>>( &mut self, iter: I )
        {
            for sig in iter
            {
                self.insert( sig );
            }
        }
    }

    impl FromIterator<Signal> for SignalSet
    {
        fn from_iter<I: IntoIterator<Item=Signal>>( iter: I ) -> SignalSet
        {
            let mut set = SignalSet::new();
            set.extend( iter );
            set
        }
    }

    impl_op!{ BitAnd, bitand, intersection }
    impl_op!{ BitOr, bitor, union }
    impl_op!{ BitXor, bitxor, symmetric_difference }
    impl_op!{ Sub, sub, difference }

    impl_unary_op!{ Not, not, inverse }

    impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
    impl_mut_op!{ BitOrAssign, bitor_assign, union }
    impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
    impl_mut_op!{ SubAssign, sub_assign, difference }

    pub fn killed_map_insert( pid: i32, sig: i32 )
            { if let Ok( mut m ) = KILL_MAP.try_lock()
            { m.insert( pid, sig ); } }

    pub fn killed_map_pop( pid: i32 ) -> Option<i32>
    {
        if let Ok( mut m ) = KILL_MAP.try_lock()
            { m.remove( &pid ) }
        else { None }
    }

    pub fn insert_cont_map( pid: i32 )
            { if let Ok( mut m ) = CONT_MAP.try_lock()
            { m.insert( pid ); } }

    pub fn pop_cont_map( pid: i32 ) -> bool
    {
        match CONT_MAP.try_lock()
        {
            Ok( mut m ) => m.remove( &pid ),
            Err( _ ) => false,
        }
    }

    pub fn insert_stopped_map( pid: i32 )
            { if let Ok( mut m ) = STOP_MAP.try_lock()
            { m.insert( pid ); } }

    pub fn pop_stopped_map( pid: i32 ) -> bool
    {
        match STOP_MAP.try_lock()
        {
            Ok( mut m ) => m.remove( &pid ),
            Err( _ ) => false,
        }
    }

    pub fn insert_reap_map( p:i32, s:i32 )
            { if let Ok( mut m ) = REAP_MAP.try_lock()
            { m.insert( p, s ); } }

    pub fn pop_reap_map( pid: i32 ) -> Option<i32>
    {
        match REAP_MAP.try_lock()
        {
            Ok( mut m ) => m.remove( &pid ),
            Err( _ ) => None,
        }
    }

    pub fn block_signals()
    {
        let mut sigset = SigSet::empty();
        sigset.add( SIGCHLD );
        match sigprocmask( SigmaskHow::SIG_BLOCK, Some( &sigset ), None )
        {
            Ok( _ ) => {},
            Err( e ) =>
            {
                log!( "sigprocmask block error: {:?}", e );
            }
        }
    }

    pub fn unblock_signals()
    {
        let mut sigset = SigSet::empty();
        sigset.add( SIGCHLD );
        match sigprocmask( SigmaskHow::SIG_UNBLOCK, Some( &sigset ), None )
        {
            Ok( _ ) => {},
            Err( e ) => { log!( "sigprocmask unblock error: {:?}", e ); }
        }
    }
    
    pub extern "C" fn handle_sigchld( _sig: i32 )
    {
        let saved_errno = errno();
        let options = Some( WF::WUNTRACED | WF::WNOHANG | WF::WCONTINUED );
        loop
        {
            match waitpid( Pid::from_raw( -1 ), options )
            {
                Ok( WS::Exited( pid, status )) => { insert_reap_map( i32::from( pid ), status ); }
                
                Ok( WS::Stopped( pid, _sig )) => { insert_stopped_map( i32::from( pid ) ); }

                Ok( WS::Continued( pid )) => { insert_cont_map( i32::from( pid ) ); }

                Ok( WS::Signaled( pid, sig, _core_dumped )) => { killed_map_insert( i32::from( pid ), sig as i32 ); }

                Ok( WS::StillAlive ) => { break; }

                Ok( _others ) => { log!( "sigchld others: {:?}", _others ); }

                Err( e ) =>
                {
                    if e == nix::Error::ECHILD { break; }
                    log!( "chld waitpid error: {:?}", e );
                    break;
                }
            }
        }

        set_errno( saved_errno );
    }

    pub fn setup_sigchld_handler()
    {
        unsafe 
        {
            let sigset = SigSet::empty();
            let handler = SigHandler::Handler( handle_sigchld );
            let flags = SaFlags::SA_RESTART;
            let sa = SigAction::new( handler, flags, sigset );

            match signal::sigaction( signal::SIGCHLD, &sa )
            {
                Ok( _ ) => {},
                Err( e ) => { log!( "sigaction error: {:?}", e ); }
            }
        }
    }
}
/// Utilities for the slice primitive type.
pub mod slice
{
    pub use std::slice::{ * };
}
/// Utilities for the str primitive type.
pub mod str
{
    pub use std::str::{ * };
    use ::
    {
        borrow::{ Borrow, BorrowMut, Cow::{ self, Borrowed, Owned } },
        boxed::{ Box },
        cmp::{ Ordering },
        ffi::{ OsStr, OsString },
        fs::{ File },
        hash::{ Hash, Hasher },
        iter::{ FromIterator, repeat, Skip },
        string::{ String },
        vec::{ Array, SmallVec },
        *,
    };
    /*
    use std::collections::{vec_deque, VecDeque};
    use std::fmt;
    use std::io;
    use std::iter::{repeat, Skip};
    use std::mem::swap;
    use std::ops::{Deref, DerefMut, Range};
    use std::sync::MutexGuard;
    use std::time::{Duration, Instant};

    use ::chars::{is_ctrl, unctrl, ESCAPE, RUBOUT};
    use ::reader::{START_INVISIBLE, END_INVISIBLE};
    use ::terminal::{CursorMode, Size, Terminal, TerminalWriter};
    use ::util::{
        backward_char, forward_char, backward_search_char, forward_search_char,
        filter_visible, is_combining_mark, is_wide, RangeArgument,
    };
    */
    /*
    smallstr 0.2.0 | Implements `SmallString`, a `String`-like container for small strings */
    macro_rules! eq_str
    {
        ( $rhs:ty ) =>
        {
            impl<'a, A: Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
            {
                #[inline] fn eq(&self, rhs: &$rhs) -> bool { &self[..] == &rhs[..] }
                #[inline] fn ne(&self, rhs: &$rhs) -> bool { &self[..] != &rhs[..] }
            }
        };
    }

    macro_rules! impl_index_str
    {
        ($index_type: ty) =>
        {
            impl<A: Array<Item = u8>> ops::Index<$index_type> for SmallString<A>
            {
                type Output = str;
                #[inline] fn index(&self, index: $index_type) -> &str { &self.as_str()[index] }
            }

            impl<A: Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A>
            {
                #[inline] fn index_mut(&mut self, index: $index_type) -> &mut str { &mut self.as_mut_str()[index] }
            }
        };
    }
    /// A `String`-like container that can store a small number of bytes inline.
    #[derive(Clone, Default)]
    pub struct SmallString<A: Array<Item = u8>>
    {
        data: SmallVec<A>,
    }

    impl<A: Array<Item = u8>> SmallString<A>
    {
        /// Construct an empty string.
        #[inline] pub fn new() -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::new(),
            }
        }
        /// Construct an empty string with enough capacity pre-allocated to store at least `n` bytes.
        #[inline] pub fn with_capacity(n: usize) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::with_capacity(n),
            }
        }
        /// Construct a `SmallString` by copying data from a `&str`.
        #[inline] pub fn from_str(s: &str) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_slice(s.as_bytes()),
            }
        }
        /// Construct a `SmallString` by using an existing allocation.
        #[inline] pub fn from_string(s: String) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_vec(s.into_bytes()),
            }
        }
        /// Constructs a new `SmallString` on the stack using UTF-8 bytes.
        #[inline] pub fn from_buf(buf: A) -> Result<SmallString<A>, FromUtf8Error<A>>
        {
            let data = SmallVec::from_buf(buf);

            match str::from_utf8(&data)
            {
                Ok(_) => Ok(SmallString { data }),
                Err(error) =>
                {
                    let buf = data.into_inner().ok().unwrap();
                    Err(FromUtf8Error { buf, error })
                }
            }
        }

        /// Constructs a new `SmallString` on the stack using the provided byte array
        /// without checking that the array contains valid UTF-8.
        #[inline] pub unsafe fn from_buf_unchecked(buf: A) -> SmallString<A>
        {
            SmallString
            {
                data: SmallVec::from_buf(buf),
            }
        }
        /// The maximum number of bytes this string can hold inline.
        #[inline] pub fn inline_size(&self) -> usize { A::size() }
        /// Returns the length of this string, in bytes.
        #[inline] pub fn len(&self) -> usize { self.data.len() }
        /// Returns `true` if this string is empty.
        #[inline] pub fn is_empty(&self) -> bool { self.data.is_empty() }
        /// Returns the number of bytes this string can hold without reallocating.
        #[inline] pub fn capacity(&self) -> usize { self.data.capacity() }
        /// Returns `true` if the data has spilled into a separate heap-allocated buffer.
        #[inline] pub fn spilled(&self) -> bool { self.data.spilled() }
        /// Empties the string and returns an iterator over its former contents.
        pub fn drain(&mut self) -> Drain
        {
            unsafe
            {
                let len = self.len();
                self.data.set_len(0);
                let ptr = self.as_ptr();
                let slice = slice::from_raw_parts(ptr, len);
                let s = str::from_utf8_unchecked(slice);
                Drain { iter: s.chars() }
            }
        }
        /// Appends the given `char` to the end of this string.
        #[inline] pub fn push(&mut self, ch: char)
        {
            match ch.len_utf8()
            {
                1 => self.data.push(ch as u8),
                _ => self.push_str(ch.encode_utf8(&mut [0; 4])),
            }
        }
        /// Appends the given string slice to the end of this string.
        #[inline] pub fn push_str(&mut self, s: &str) { self.data.extend_from_slice(s.as_bytes()); }
        /// Removes the last character from this string and returns it.
        #[inline] pub fn pop(&mut self) -> Option<char>
        {
            match self.chars().next_back()
            {
                Some(ch) => unsafe
                {
                    let new_len = self.len() - ch.len_utf8();
                    self.data.set_len(new_len);
                    Some(ch)
                },
                None => None,
            }
        }
        /// Reallocates to set the new capacity to `new_cap`.
        #[inline] pub fn grow(&mut self, new_cap: usize) { self.data.grow(new_cap); }
        /// Ensures that this string's capacity is at least `additional` bytes larger than its length.
        #[inline] pub fn reserve(&mut self, additional: usize) { self.data.reserve(additional); }
        /// Ensures that this string's capacity is `additional` bytes larger than its length.
        #[inline] pub fn reserve_exact(&mut self, additional: usize) { self.data.reserve(additional); }
        /// Shrink the capacity of the string as much as possible.
        #[inline] pub fn shrink_to_fit(&mut self) { self.data.shrink_to_fit(); }
        /// Shorten the string, keeping the first `len` bytes.
        #[inline] pub fn truncate(&mut self, len: usize)
        {
            assert!(self.is_char_boundary(len));
            self.data.truncate(len);
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_str(&self) -> &str { self }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_mut_str(&mut self) -> &mut str { self }
        /// Removes all contents of the string.
        #[inline] pub fn clear(&mut self) { self.data.clear(); }
        /// Removes a `char` from this string at a byte position and returns it.
        #[inline] pub fn remove(&mut self, idx: usize) -> char
        {
            unsafe
            {
                let ch = match self[idx..].chars().next()
                {
                    Some(ch) => ch,
                    None => panic!("cannot remove a char from the end of a string"),
                };

                let ch_len = ch.len_utf8();
                let next = idx + ch_len;
                let len = self.len();
                ptr::copy
                (
                    self.as_ptr().add(next),
                    self.as_mut_ptr().add(idx),
                    len - next,
                );
                self.data.set_len(len - ch_len);
            }

            ch
        }
        /// Inserts a `char` into this string at the given byte position.
        #[inline] pub fn insert(&mut self, idx: usize, ch: char)
        {
            assert!(self.is_char_boundary(idx));

            match ch.len_utf8()
            {
                1 => self.data.insert(idx, ch as u8),
                _ => self.insert_str(idx, ch.encode_utf8(&mut [0; 4])),
            }
        }
        /// Inserts a `&str` into this string at the given byte position.
        #[inline] pub fn insert_str(&mut self, idx: usize, s: &str)
        {
            unsafe
            {
                assert!(self.is_char_boundary(idx));
                let len = self.len();
                let amt = s.len();
                self.data.reserve(amt);
                ptr::copy
                (
                    self.as_ptr().add(idx),
                    self.as_mut_ptr().add(idx + amt),
                    len - idx,
                );
                ptr::copy_nonoverlapping(s.as_ptr(), self.as_mut_ptr().add(idx), amt);
                self.data.set_len(len + amt);
            }
        }
        /// Returns a mutable reference to the contents of the `SmallString`.
        #[inline] pub unsafe fn as_mut_vec(&mut self) -> &mut SmallVec<A> { &mut self.data }
        /// Converts the `SmallString` into a `String`, 
        /// without reallocating if the `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_string(self) -> String { unsafe { String::from_utf8_unchecked(self.data.into_vec()) } }
        /// Converts the `SmallString` into a `Box<str>`, 
        /// without reallocating if the `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_boxed_str(self) -> Box<str> { self.into_string().into_boxed_str() }
        /// Convert the `SmallString` into `A`, if possible. Otherwise, return `Err(self)`.
        #[inline] pub fn into_inner(self) -> Result<A, Self>
        { self.data.into_inner().map_err(|data| SmallString { data }) }
        /// Retains only the characters specified by the predicate.
        #[inline] pub fn retain<F: FnMut(char) -> bool>(&mut self, mut f: F)
        {
            unsafe
            {    
                struct SetLenOnDrop<'a, A: Array<Item = u8>>
                {
                    s: &'a mut SmallString<A>,
                    idx: usize,
                    del_bytes: usize,
                }

                impl<'a, A: Array<Item = u8>> Drop for SetLenOnDrop<'a, A>
                {
                    fn drop(&mut self)
                    {
                        unsafe
                        {
                            let new_len = self.idx - self.del_bytes;
                            debug_assert!(new_len <= self.s.len());
                            self.s.data.set_len(new_len)
                        };
                    }
                }

                let len = self.len();
                let mut guard = SetLenOnDrop
                {
                    s: self,
                    idx: 0,
                    del_bytes: 0,
                };

                while guard.idx < len
                {
                    let ch = guard
                    .s
                    .get_unchecked(guard.idx..len)
                    .chars()
                    .next()
                    .unwrap();
                    let ch_len = ch.len_utf8();

                    if !f(ch) { guard.del_bytes += ch_len; } else if guard.del_bytes > 0
                    {
                        ptr::copy
                        (
                            guard.s.data.as_ptr().add(guard.idx),
                            guard.s.data.as_mut_ptr().add(guard.idx - guard.del_bytes),
                            ch_len,
                        );
                    }
                    
                    guard.idx += ch_len;
                }

                drop(guard);
            }
        }

        fn as_mut_ptr(&mut self) -> *mut u8 { self.as_ptr() as *mut u8 }
    }

    impl<A: Array<Item = u8>> ops::Deref for SmallString<A>
    {
        type Target = str;
        #[inline] fn deref(&self) -> &str
        {
            unsafe
            { 
                let bytes: &[u8] = &self.data;
                str::from_utf8_unchecked(bytes)
            }
        }
    }

    impl<A: Array<Item = u8>> ops::DerefMut for SmallString<A>
    {
        #[inline] fn deref_mut(&mut self) -> &mut str
        {
            unsafe 
            {
                let bytes: &mut [u8] = &mut self.data;
                str::from_utf8_unchecked_mut(bytes)
            }
        }
    }

    impl<A: Array<Item = u8>> AsRef<str> for SmallString<A>
    {
        #[inline] fn as_ref(&self) -> &str { self }
    }

    impl<A: Array<Item = u8>> AsMut<str> for SmallString<A>
    {
        #[inline] fn as_mut(&mut self) -> &mut str { self }
    }

    impl<A: Array<Item = u8>> Borrow<str> for SmallString<A>
    {
        #[inline] fn borrow(&self) -> &str { self }
    }

    impl<A: Array<Item = u8>> BorrowMut<str> for SmallString<A>
    {
        #[inline] fn borrow_mut(&mut self) -> &mut str { self }
    }

    impl<A: Array<Item = u8>> AsRef<[u8]> for SmallString<A>
    {
        #[inline] fn as_ref(&self) -> &[u8] { self.data.as_ref() }
    }

    impl<A: Array<Item = u8>> fmt::Write for SmallString<A>
    {
        #[inline] fn write_str(&mut self, s: &str) -> fmt::Result
        {
            self.push_str(s);
            Ok(())
        }

        #[inline] fn write_char(&mut self, ch: char) -> fmt::Result
        {
            self.push(ch);
            Ok(())
        }
    }

    impl<A: Array<Item = u8>> From<char> for SmallString<A>
    {
        #[inline] fn from(ch: char) -> SmallString<A> { SmallString::from_str(ch.encode_utf8(&mut [0; 4])) }
    }

    impl<'a, A: Array<Item = u8>> From<&'a str> for SmallString<A>
    {
        #[inline] fn from(s: &str) -> SmallString<A> { SmallString::from_str(s) }
    }

    impl<A: Array<Item = u8>> From<Box<str>> for SmallString<A>
    {
        #[inline] fn from(s: Box<str>) -> SmallString<A> { SmallString::from_string(s.into()) }
    }

    impl<A: Array<Item = u8>> From<String> for SmallString<A>
    {
        #[inline] fn from(s: String) -> SmallString<A> { SmallString::from_string(s) }
    }

    impl<'a, A: Array<Item = u8>> From<Cow<'a, str>> for SmallString<A>
    {
        fn from(value: Cow<'a, str>) -> Self
        {
            match value
            {
                Cow::Borrowed(s) => Self::from_str(s),
                Cow::Owned(s) => Self::from_string(s),
            }
        }
    }

    impl_index_str!(ops::Range<usize>);
    impl_index_str!(ops::RangeFrom<usize>);
    impl_index_str!(ops::RangeTo<usize>);
    impl_index_str!(ops::RangeFull);

    impl<A: Array<Item = u8>> FromIterator<char> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a char> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter.into_iter().cloned());
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a str> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<A: Array<Item = u8>> FromIterator<String> for SmallString<A>
    {
        fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend(iter);
            s
        }
    }

    impl<A: Array<Item = u8>> Extend<char> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I)
        {
            let iter = iter.into_iter();
            let (lo, _) = iter.size_hint();
            self.reserve(lo);

            for ch in iter
            {
                self.push(ch);
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a char> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) { self.extend(iter.into_iter().cloned()); }
    }

    impl<'a, A: Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(&s);
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a str> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(s);
            }
        }
    }

    impl<A: Array<Item = u8>> Extend<String> for SmallString<A>
    {
        fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I)
        {
            for s in iter
            {
                self.push_str(&s);
            }
        }
    }

    impl<A: Array<Item = u8>> fmt::Debug for SmallString<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Debug::fmt(&**self, f) }
    }

    impl<A: Array<Item = u8>> fmt::Display for SmallString<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(&**self, f) }
    }

    eq_str!(str);
    eq_str!(&'a str);
    eq_str!(String);
    eq_str!(Cow<'a, str>);
    
    impl<A: Array<Item = u8>> PartialEq<OsStr> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &OsStr) -> bool { &self[..] == rhs }
        #[inline] fn ne(&self, rhs: &OsStr) -> bool { &self[..] != rhs }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &&OsStr) -> bool { &self[..] == *rhs }
        #[inline] fn ne(&self, rhs: &&OsStr) -> bool { &self[..] != *rhs }
    }
    
    impl<A: Array<Item = u8>> PartialEq<OsString> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &OsString) -> bool { &self[..] == rhs }
        #[inline] fn ne(&self, rhs: &OsString) -> bool { &self[..] != rhs }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A>
    {
        #[inline] fn eq(&self, rhs: &Cow<OsStr>) -> bool { self[..] == **rhs }
        #[inline] fn ne(&self, rhs: &Cow<OsStr>) -> bool { self[..] != **rhs }
    }

    impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
    A: Array<Item = u8>,
    B: Array<Item = u8>
    {
        #[inline] fn eq(&self, rhs: &SmallString<B>) -> bool { &self[..] == &rhs[..] }
        #[inline] fn ne(&self, rhs: &SmallString<B>) -> bool { &self[..] != &rhs[..] }
    }

    impl<A: Array<Item = u8>> Eq for SmallString<A> {}

    impl<A: Array<Item = u8>> PartialOrd for SmallString<A>
    {
        #[inline] fn partial_cmp(&self, rhs: &SmallString<A>) -> Option<Ordering> { self[..].partial_cmp(&rhs[..]) }
    }

    impl<A: Array<Item = u8>> Ord for SmallString<A>
    {
        #[inline] fn cmp(&self, rhs: &SmallString<A>) -> Ordering { self[..].cmp(&rhs[..]) }
    }

    impl<A: Array<Item = u8>> Hash for SmallString<A>
    {
        #[inline] fn hash<H: Hasher>(&self, state: &mut H) { self[..].hash(state) }
    }
    /// A draining iterator for `SmallString`.
    pub struct Drain<'a>
    {
        iter: Chars<'a>,
    }

    impl<'a> Iterator for Drain<'a>
    {
        type Item = char;
        #[inline] fn next(&mut self) -> Option<char> { self.iter.next() }
        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
    }

    impl<'a> DoubleEndedIterator for Drain<'a>
    {
        #[inline] fn next_back(&mut self) -> Option<char> { self.iter.next_back() }
    }
    /// A possible error value when creating a `SmallString` from a byte array.
    #[derive( Debug )]
    pub struct FromUtf8Error<A: Array<Item = u8>>
    {
        buf: A,
        error: Utf8Error,
    }

    impl<A: Array<Item = u8>> FromUtf8Error<A>
    {
        /// Returns the slice of `[u8]` bytes that were attempted to convert to a `SmallString`.
        #[inline] pub fn as_bytes(&self) -> &[u8]
        {
            unsafe
            {
                let ptr = &self.buf as *const _ as *const u8;
                slice::from_raw_parts(ptr, A::size())
            }
        }
        /// Returns the byte array that was attempted to convert into a `SmallString`.
        #[inline] pub fn into_buf(self) -> A { self.buf }
        /// Returns the `Utf8Error` to get more details about the conversion failure.
        #[inline] pub fn utf8_error(&self) -> Utf8Error { self.error }
    }

    impl<A: Array<Item = u8>> fmt::Display for FromUtf8Error<A>
    {
        #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
        {
            fmt::Display::fmt(&self.error, f)
        }
    }
    /*
    pub fn display_str<'a>( s:&'a str, style: Display ) -> Cow<'a, str> */
    pub fn display<'a>( s:&'a str, style: Display ) -> Cow<'a, str>
    {
        if s.chars().all( |ch| display( ch, style ) == DisplaySequence::Char( ch ) )
            { Borrowed( s ) }
        else { Owned( s.chars().flat_map( |ch| display( ch, style ) ).collect() ) }
    }

    /*
    pub fn write_file_str( ... ) -> io::Result<()> */
    /// Writes a string to a file.
    pub fn write_file( fname: &str, contents: &str ) -> io::Result<()>
    {
        // Open a file in write-only mode
        let mut file = File::create( fname )?;

        file.write_all( contents.as_bytes() )?;

        Ok( () )
    }
}
/// A UTF-8–encoded, growable string.
pub mod string
{
    pub use std::string::{ * };
    /*
    pub fn wrap_sep_string(...) -> String */
    pub fn wrap_separator(sep: &str, s: &str) -> String
    {
        let mut _token = String::new();
        let mut met_subsep = false;
        let mut previous_subsep = 'N';

        for c in s.chars()
        {
            if sep.is_empty() && (c == '`' || c == '"')
            {
                if !met_subsep
                {
                    met_subsep = true;
                    previous_subsep = c;
                }
                
                else if c == previous_subsep
                {
                    met_subsep = false;
                    previous_subsep = 'N';
                }
            }

            if c.to_string() == sep { _token.push('\\'); }
            
            if c == ' ' && sep.is_empty() && !met_subsep { _token.push('\\'); }
            
            _token.push(c);
        }

        format!("{}{}{}", sep, _token, sep)
    }
}
/// Useful synchronization primitives.
pub mod sync
{
    pub use std::sync::{ atomic as _, * };
    pub mod atomic
    {
        use ::
        {
            sealed::Sealed,
            *,
        };
        pub use std::sync::atomic::{ * };
        /// A marker trait for primitive types which can be modified atomically.
        pub unsafe trait AtomicPrimitive: Sized + Copy + Sealed
        {
            /// Temporary implementation detail.
            type AtomicInner: Sized;
        }
        /// A memory location which can be safely modified from multiple threads.
        pub type Atomic<T> = <T as AtomicPrimitive>::AtomicInner;
    }
}
/// Provides System implementations
pub mod system
{
    //! Mortal v.0.2.4 
    /*
    #[cfg(windows)] extern crate winapi;
    */
    use ::
    {
        sync::{ LockResult, PoisonError, TryLockError, TryLockResult },
        *,
    };
    
    #[macro_use] mod buffer
    {
        /*
        use smallstr::SmallString;

        use mortal::priv_util::is_visible;
        use mortal::terminal::{Color, Cursor, Size, Style, Theme};
        use mortal::util::{char_width, is_combining_mark};
        */
        use ::
        {
            mem::{ swap },
            ops::{ Range },
            str::{ SmallString },
            *,
        };
        pub const TAB_STOP: usize = 8;

        /// Generates buffer methods forwarded to a buffer contained in self.
        macro_rules! forward_screen_buffer_methods
        {
            ( |$slf:ident| $field:expr ) =>
            {
                pub fn size(&self) -> ::system::terminal::Size 
                {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> ::system::terminal::Cursor 
                {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&self, pos: ::system::terminal::Cursor) 
                {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&self, column: usize) 
                {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&self) 
                {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&self) 
                {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&self, style: ::system::terminal::Style) 
                {
                    let $slf = self;
                    $field.add_style(style);
                }

                pub fn remove_style(&self, style: ::system::terminal::Style) 
                {
                    let $slf = self;
                    $field.remove_style(style);
                }

                pub fn set_style(&self, style: ::system::terminal::Style) 
                {
                    let $slf = self;
                    $field.set_style(style);
                }

                pub fn set_fg(&self, fg: Option<::system::terminal::Color>) 
                {
                    let $slf = self;
                    $field.set_fg(fg);
                }

                pub fn set_bg(&self, bg: Option<::system::terminal::Color>) 
                {
                    let $slf = self;
                    $field.set_bg(bg);
                }

                pub fn set_theme(&self, theme: ::system::terminal::Theme) 
                {
                    let $slf = self;
                    $field.set_theme(theme)
                }

                pub fn write_char(&self, ch: char) 
                {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&self, s: &str) 
                {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&self, pos: ::system::terminal::Cursor, text: &str) 
                {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled
                (
                    &self,
                    fg: Option<::system::terminal::Color>,
                    bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style,
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at
                (
                    &self,
                    pos: ::system::terminal::Cursor,
                    fg: Option<::system::terminal::Color>,
                    bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style,
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }
        
        macro_rules! forward_screen_buffer_mut_methods
        {
            ( |$slf:ident| $field:expr ) =>
            {
                pub fn size(&self) -> ::system::terminal::Size
                {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> ::system::terminal::Cursor
                {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&mut self, pos: ::system::terminal::Cursor)
                {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&mut self, column: usize)
                {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&mut self)
                {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&mut self)
                {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&mut self, style: ::system::terminal::Style)
                {
                    let $slf = self;
                    $field.add_style(style);
                }

                pub fn remove_style(&mut self, style: ::system::terminal::Style)
                {
                    let $slf = self;
                    $field.remove_style(style);
                }

                pub fn set_style(&mut self, style: ::system::terminal::Style)
                {
                    let $slf = self;
                    $field.set_style(style);
                }

                pub fn set_fg(&mut self, fg: Option<::system::terminal::Color>)
                {
                    let $slf = self;
                    $field.set_fg(fg);
                }

                pub fn set_bg(&mut self, bg: Option<::system::terminal::Color>)
                {
                    let $slf = self;
                    $field.set_bg(bg);
                }

                pub fn set_theme(&mut self, theme: ::system::terminal::Theme)
                {
                    let $slf = self;
                    $field.set_theme(theme);
                }

                pub fn write_char(&mut self, ch: char)
                {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&mut self, s: &str)
                {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&mut self, pos: ::system::terminal::Cursor, text: &str)
                {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled
                (
                    &mut self,
                    fg: Option<::system::terminal::Color>,
                    bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style, 
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at
                (
                    &mut self, 
                    pos: ::system::terminal::Cursor,
                    fg: Option<::system::terminal::Color>, 
                    bg: Option<::system::terminal::Color>,
                    style: ::system::terminal::Style, 
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }

        pub struct ScreenBuffer
        {
            buffer: Vec<Cell>,
            back_buffer: Vec<Cell>,
            size: Size,
            cursor: Cursor,
            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
        }

        impl ScreenBuffer
        {
            pub fn new(size: Size) -> ScreenBuffer
            {
                let area = size.area();

                ScreenBuffer
                {
                    buffer: vec![Cell::default(); area],
                    back_buffer: vec![Cell::default(); area],
                    size: size,
                    cursor: Cursor::default(),
                    fg: None,
                    bg: None,
                    style: Style::empty(),
                }
            }

            pub fn cursor(&self) -> Cursor { self.cursor }

            pub fn size(&self) -> Size { self.size }

            pub fn resize(&mut self, new_size: Size)
            {
                resize_buffer(&mut self.buffer, self.size, new_size);
                new_buffer(&mut self.back_buffer, new_size);
                self.size = new_size;
            }

            pub fn set_cursor(&mut self, pos: Cursor) { self.cursor = pos; }

            pub fn next_line(&mut self, column: usize)
            {
                self.cursor.line += 1;
                self.cursor.column = column;
            }

            pub fn clear_attributes(&mut self)
            {
                self.fg = None;
                self.bg = None;
                self.style = Style::empty();
            }

            pub fn add_style(&mut self, style: Style) { self.style |= style; }
            pub fn remove_style(&mut self, style: Style) { self.style -= style; }
            pub fn set_style(&mut self, style: Style) { self.style = style; }
            pub fn set_fg(&mut self, fg: Option<Color>) { self.fg = fg; }
            pub fn set_bg(&mut self, bg: Option<Color>) { self.bg = bg; }
            pub fn set_theme(&mut self, theme: Theme)
            {
                self.set_fg(theme.fg);
                self.set_bg(theme.bg);
                self.set_style(theme.style);
            }

            pub fn clear_screen(&mut self)
            {
                for cell in &mut self.buffer
                {
                    *cell = Cell::default();
                }
            }

            pub fn indices(&self) -> Range<usize> { 0..self.size.area() }
            
            pub fn next_cell(&mut self, indices: &mut Range<usize>) -> Option<(Cursor, Cell)>
            {
                while let Some(idx) = indices.next()
                {
                    let first = self.buffer[idx].first_char();
                    let width = char_width(first).unwrap_or(0);
                    
                    if width == 2 { let _ = indices.next(); }

                    if self.buffer[idx] != self.back_buffer[idx]
                    {
                        let cell = self.buffer[idx].clone();
                        let line = idx / self.size.columns;
                        let column = idx % self.size.columns;
                        self.back_buffer[idx] = cell.clone();
                        return Some((Cursor{line, column}, cell));
                    }
                }

                None
            }

            pub fn write_char(&mut self, ch: char) -> Result<(), OutOfBounds>
            {
                if ch == '\t'
                {
                    self.try_cursor()?;
                    let rem = self.size.columns - self.cursor.column;
                    let n = rem.min(TAB_STOP - (self.cursor.column % TAB_STOP));

                    for _ in 0..n 
                    {
                        self.write_char(' ')?;
                    }
                }
                
                else if ch == '\r'
                {
                    self.cursor.column = 0;
                }
                
                else if ch == '\n'
                {
                    self.cursor.line += 1;
                    self.cursor.column = 0;
                }
                
                else if is_combining_mark(ch)
                {
                    if let Some(prev) = self.cursor.previous(self.size)
                    {
                        self.try_cursor_at(prev)?;
                        self.cell_mut(prev).text.push(ch);
                    }
                }
                
                else if is_visible(ch)
                {
                    self.try_cursor()?;

                    if let Some(prev) = self.cursor.previous(self.size)
                    {
                        let cell = self.cell_mut(prev);

                        if cell.is_wide() { *cell = Cell::default(); }
                    }

                    let rem = self.size.columns - self.cursor.column;
                    let width = char_width(ch).unwrap_or(0);
                    
                    if rem < width
                    {
                        self.try_cursor()?;
                        let mut pos = self.cursor;

                        for _ in 0..rem
                        {
                            self.set_cell(pos, ch);
                            pos.column += 1;
                        }

                        self.cursor.column = 0;
                        self.cursor.line += 1;
                    }

                    self.try_cursor()?;
                    let mut pos = self.cursor;
                    self.set_cell(pos, ch);

                    for _ in 1..width
                    {
                        pos.column += 1;
                        self.set_cell(pos, ' ');
                    }

                    self.cursor.column += width;

                    if self.cursor.column >= self.size.columns
                    {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                }

                Ok(())
            }

            pub fn write_str(&mut self, s: &str) -> Result<(), OutOfBounds>
            {
                for ch in s.chars()
                {
                    self.write_char(ch)?;
                }

                Ok(())
            }

            pub fn write_at(&mut self, pos: Cursor, text: &str) -> Result<(), OutOfBounds>
            {
                self.try_cursor_at(pos)?;
                self.cursor = pos;
                self.write_str(text)
            }

            pub fn write_styled
            (
                &mut self,
                fg: Option<Color>,
                bg: Option<Color>,
                style: Style,
                text: &str
            ) -> Result<(), OutOfBounds>
            {
                self.fg = fg;
                self.bg = bg;
                self.style = style;
                self.write_str(text)?;
                self.clear_attributes();
                Ok(())
            }

            pub fn write_styled_at
            (
                &mut self, 
                pos: Cursor, 
                fg: Option<Color>, 
                bg: Option<Color>, 
                style: Style, 
                text: &str
            ) -> Result<(), OutOfBounds>
            {
                self.try_cursor_at(pos)?;
                self.cursor = pos;
                self.write_styled(fg, bg, style, text)
            }

            fn try_cursor(&self) -> Result<(), OutOfBounds> { self.try_cursor_at(self.cursor) }

            fn try_cursor_at(&self, pos: Cursor) -> Result<(), OutOfBounds>
            {
                if pos.line >= self.size.lines || pos.column >= self.size.columns { Err(OutOfBounds(())) }
                else { Ok(()) }
            }
            
            fn cell_mut(&mut self, pos: Cursor) -> &mut Cell
            {
                let size = self.size;
                &mut self.buffer[pos.as_index(size)]
            }

            fn set_cell(&mut self, pos: Cursor, ch: char)
            {
                let fg = self.fg;
                let bg = self.bg;
                let style = self.style;
                let cell = self.cell_mut(pos);
                cell.fg = fg;
                cell.bg = bg;
                cell.style = style;
                cell.text = ch.into();
            }
        }

        #[derive( Debug )]
        pub struct OutOfBounds(());

        #[derive(Clone, Debug, Eq, PartialEq)]
        pub struct Cell
        {
            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
            text: SmallString<[u8; 8]>,
        }

        impl Cell
        {
            fn new(fg: Option<Color>, bg: Option<Color>, style: Style, chr: char) -> Cell
            {
                Cell
                {
                    fg,
                    bg,
                    style,
                    text: chr.into(),
                }
            }
            fn invalid() -> Cell
            {
                Cell
                {
                    fg: None,
                    bg: None,
                    style: Style::empty(),
                    text: SmallString::new(),
                }
            }
            pub fn attrs(&self) -> (Option<Color>, Option<Color>, Style) { (self.fg, self.bg, self.style) }
            pub fn text(&self) -> &str { &self.text }
            fn first_char(&self) -> char { self.text.chars().next().expect("empty cell text") }
            fn is_wide(&self) -> bool 
            {
                self.text.chars().next()
                    .and_then(char_width).unwrap_or(0) == 2
            }
        }

        impl Default for Cell
        {
            fn default() -> Cell { Cell::new(None, None, Style::empty(), ' ') }
        }

        fn resize_buffer(buf: &mut Vec<Cell>, old: Size, new: Size)
        {
            if old != new
            {
                let mut new_buf = vec![Cell::default(); new.area()];

                if !buf.is_empty()
                {
                    let n_cols = old.columns.min(new.columns);

                    for (old, new) in buf.chunks_mut(old.columns).zip(new_buf.chunks_mut(new.columns))
                    {
                        for i in 0..n_cols
                        {
                            swap(&mut new[i], &mut old[i]);
                        }
                    }
                }

                *buf = new_buf;
            }
        }

        fn new_buffer(buf: &mut Vec<Cell>, new_size: Size) { *buf = vec![Cell::invalid(); new_size.area()]; }
    }

    #[macro_use] pub mod macros
    {
        use ::{};
    }

    pub mod common
    {
        //! Platform-independent platform abstraction
        use ::
        {
            *,
        };

        pub mod fs
        {
            use ::
            {
                io::{ self, Error, ErrorKind },
                path::{ Path },
                sys::common::ignore_notfound,
                *,
            };
            
            pub const NOT_FILE_ERROR: Error = constant_error!(
                ErrorKind::InvalidInput,
                "the source path is neither a regular file nor a symlink to a regular file",
            );

            pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {
                let mut reader = fs::File::open(from)?;
                let metadata = reader.metadata()?;

                if !metadata.is_file() {
                    return Err(NOT_FILE_ERROR);
                }

                let mut writer = fs::File::create(to)?;
                let perm = metadata.permissions();

                let ret = io::copy(&mut reader, &mut writer)?;
                writer.set_permissions(perm)?;
                Ok(ret)
            }

            pub fn remove_dir_all(path: &Path) -> io::Result<()> {
                let filetype = fs::symlink_metadata(path)?.file_type();
                if filetype.is_symlink() { fs::remove_file(path) } else { remove_dir_all_recursive(path) }
            }

            fn remove_dir_all_recursive(path: &Path) -> io::Result<()> 
            {
                for child in fs::read_dir(path)? 
                {
                    let result: io::Result<()> = 
                    {
                        let child = child?;
                        if child.file_type()?.is_dir() {
                            remove_dir_all_recursive(&child.path())?;
                        } else {
                            fs::remove_file(&child.path())?;
                        }
                    };
                    
                    if let Err(err) = &result && err.kind() != io::ErrorKind::NotFound
                    {
                        return result;
                    }
                }
                ignore_notfound(fs::remove_dir(path))
            }

            pub fn exists(path: &Path) -> io::Result<bool> {
                match fs::metadata(path) {
                    Ok(_) => Ok(true),
                    Err(error) if error.kind() == io::ErrorKind::NotFound => Ok(false),
                    Err(error) => Err(error),
                }
            }
        }
        
        pub mod process
        {
            use ::
            {
                collections::BTreeMap,
                ffi::{OsStr, OsString},
                sys::pipe::read2,
                sys::process::{EnvKey, ExitStatus, Process, StdioPipes},
                *,
            };
            
            #[derive(Clone, Default)]
            pub struct CommandEnv
            {
                clear: bool,
                saw_path: bool,
                vars: BTreeMap<EnvKey, Option<OsString>>,
            }

            impl fmt::Debug for CommandEnv
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    let mut debug_command_env = f.debug_struct("CommandEnv");
                    debug_command_env.field("clear", &self.clear).field("vars", &self.vars);
                    debug_command_env.finish()
                }
            }

            impl CommandEnv
            {
                pub fn capture(&self) -> BTreeMap<EnvKey, OsString>
                {
                    let mut result = BTreeMap::<EnvKey, OsString>::new();
                    if !self.clear {
                        for (k, v) in env::vars_os() {
                            result.insert(k.into(), v);
                        }
                    }
                    for (k, maybe_v) in &self.vars {
                        if let &Some(ref v) = maybe_v {
                            result.insert(k.clone(), v.clone());
                        } else {
                            result.remove(k);
                        }
                    }
                    result
                }

                pub fn is_unchanged(&self) -> bool { !self.clear && self.vars.is_empty() }

                pub fn capture_if_changed(&self) -> Option<BTreeMap<EnvKey, OsString>>
                {
                    if self.is_unchanged() { None } else { Some(self.capture()) }
                }
                
                pub fn set(&mut self, key: &OsStr, value: &OsStr)
                {
                    let key = EnvKey::from(key);
                    self.maybe_saw_path(&key);
                    self.vars.insert(key, Some(value.to_owned()));
                }

                pub fn remove(&mut self, key: &OsStr)
                {
                    let key = EnvKey::from(key);
                    self.maybe_saw_path(&key);

                    if self.clear { self.vars.remove(&key); }
                    else { self.vars.insert(key, None); }
                }

                pub fn clear(&mut self)
                {
                    self.clear = true;
                    self.vars.clear();
                }

                pub fn does_clear(&self) -> bool { self.clear }

                pub fn have_changed_path(&self) -> bool { self.saw_path || self.clear }

                pub fn iter(&self) -> CommandEnvs<'_>
                {
                    let iter = self.vars.iter();
                    CommandEnvs { iter }
                }

                fn maybe_saw_path(&mut self, key: &EnvKey)
                {
                    if !self.saw_path && key == "PATH" { self.saw_path = true; }
                }
            }
            /// An iterator over the command environment variables.
            #[must_use = "iterators are lazy and do nothing unless consumed"]
            #[derive( Debug )]
            pub struct CommandEnvs<'a>
            {
                iter: ::collections::btree_map::Iter<'a, EnvKey, Option<OsString>>,
            }
            
            impl<'a> Iterator for CommandEnvs<'a>
            {
                type Item = (&'a OsStr, Option<&'a OsStr>);
                fn next(&mut self) -> Option<Self::Item>
                { self.iter.next().map(|(key, value)| (key.as_ref(), value.as_deref())) }
                fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
            }
            
            impl<'a> ExactSizeIterator for CommandEnvs<'a>
            {
                fn len(&self) -> usize { self.iter.len() }
                fn is_empty(&self) -> bool { self.iter.is_empty() }
            }

            pub fn wait_with_output( mut process: Process, mut pipes: StdioPipes ) -> 
            io::Result<(ExitStatus, Vec<u8>, Vec<u8>)>
            {
                drop(pipes.stdin.take());

                let (mut stdout, mut stderr) = (Vec::new(), Vec::new());
                match (pipes.stdout.take(), pipes.stderr.take()) {
                    (None, None) => {}
                    (Some(out), None) => {
                        let res = out.read_to_end(&mut stdout);
                        res.unwrap();
                    }
                    (None, Some(err)) => {
                        let res = err.read_to_end(&mut stderr);
                        res.unwrap();
                    }
                    (Some(out), Some(err)) => {
                        let res = read2(out, &mut stdout, err, &mut stderr);
                        res.unwrap();
                    }
                }

                let status = process.wait()?;
                Ok((status, stdout, stderr))
            }
        }

        pub mod wstr
        {
            //! This module contains constructs to work with 16-bit characters (UCS-2 or UTF-16)
            use ::
            {
                marker::PhantomData,
                num::NonZero,
                ptr::NonNull,
                *,
            };
            /// A safe iterator over a LPWSTR.
            pub struct WStrUnits<'a>
            {
                lpwstr: NonNull<u16>,
                lifetime: PhantomData<&'a [u16]>,
            }

            impl WStrUnits<'_>
            {
                /// Creates the iterator. Returns `None` if `lpwstr` is null.
                pub unsafe fn new(lpwstr: *const u16) -> Option<Self>
                {
                    Some(Self { lpwstr: NonNull::new(lpwstr as _)?, lifetime: PhantomData })
                }

                pub fn peek(&self) -> Option<NonZero<u16>>
                {
                    unsafe { NonZero::new(*self.lpwstr.as_ptr()) }
                }
                /// Advance the iterator while `predicate` returns true.
                pub fn advance_while<P: FnMut(NonZero<u16>) ->
                bool>(&mut self, mut predicate: P) -> usize
                {
                    let mut counter = 0;
                    while let Some(w) = self.peek()
                    {
                        if !predicate(w) {
                            break;
                        }
                        counter += 1;
                        self.next();
                    }
                    counter
                }
            }

            impl Iterator for WStrUnits<'_>
            {
                type Item = NonZero<u16>;
                fn next(&mut self) -> Option<Self::Item>
                {
                    unsafe
                    {
                        let next = self.peek()?;
                        self.lpwstr = NonNull::new_unchecked(self.lpwstr.as_ptr().add(1));
                        Some(next)
                    }
                }
            }
        }

        pub mod wtf8
        {
            //! Implementation of [the WTF-8 encoding](https://simonsapin.github.io/wtf-8/).
            use ::
            {
                char::{MAX_LEN_UTF8, MAX_LEN_UTF16, encode_utf8_raw, encode_utf16_raw},
                clone::CloneToUninit,
                str::next_code_point,
                borrow::Cow,
                collections::TryReserveError,
                hash::{Hash, Hasher},
                iter::FusedIterator,
                rc::Rc,
                sync::Arc,
                system::common::AsInner,
                *,
            };
            pub const UTF8_REPLACEMENT_CHARACTER: &str = "\u{FFFD}";
            /// A Unicode code point: from U+0000 to U+10FFFF.
            #[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]
            pub struct CodePoint
            {
                value: u32,
            }
            /// Format the code point as `U+` followed by four to six hexadecimal digits.
            impl fmt::Debug for CodePoint
            {
                #[inline] fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result
                { write!(formatter, "U+{:04X}", self.value) }
            }

            impl CodePoint
            {
                /// Unsafely creates a new `CodePoint` without checking the value.
                #[inline] pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint
                { CodePoint { value } }
                /// Creates a new `CodePoint` if the value is a valid code point.
                #[inline] pub fn from_u32(value: u32) -> Option<CodePoint>
                {
                    match value 
                    {
                        0..=0x10FFFF => Some(CodePoint { value }),
                        _ => None,
                    }
                }
                /// Creates a new `CodePoint` from a `char`.
                #[inline] pub fn from_char(value: char) -> CodePoint 
                { CodePoint { value: value as u32 } }
                /// Returns the numeric value of the code point.
                #[inline] pub fn to_u32(&self) -> u32 { self.value }
                /// Returns the numeric value of the code point if it is a leading surrogate.
                #[inline] pub fn to_lead_surrogate(&self) -> Option<u16>
                {
                    match self.value
                    {
                        lead @ 0xD800..=0xDBFF => Some(lead as u16),
                        _ => None,
                    }
                }
                /// Returns the numeric value of the code point if it is a trailing surrogate.
                #[inline] pub fn to_trail_surrogate(&self) -> Option<u16>
                {
                    match self.value
                    {
                        trail @ 0xDC00..=0xDFFF => Some(trail as u16),
                        _ => None,
                    }
                }
                /// Optionally returns a Unicode scalar value for the code point.
                #[inline] pub fn to_char(&self) -> Option<char>
                {
                    match self.value
                    {
                        0xD800..=0xDFFF => None,
                        _ => Some(unsafe { char::from_u32_unchecked(self.value) }),
                    }
                }
                /// Returns a Unicode scalar value for the code point.
                #[inline] pub fn to_char_lossy(&self) -> char
                { self.to_char().unwrap_or('\u{FFFD}') }
            }
            /// An owned, growable string of well-formed WTF-8 data.
            #[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]
            pub struct Wtf8Buf
            {
                bytes: Vec<u8>,
                is_known_utf8: bool,
            }

            impl ops::Deref for Wtf8Buf
            {
                type Target = Wtf8;
                fn deref(&self) -> &Wtf8 { self.as_slice() }
            }

            impl ops::DerefMut for Wtf8Buf 
            {
                fn deref_mut(&mut self) -> &mut Wtf8 { self.as_mut_slice() }
            }
            /// Formats the string in double quotes, with characters escaped according to
            /// [`char::escape_debug`] and unpaired surrogates represented as `\u{xxxx}`,
            /// where each `x` is a hexadecimal digit.
            impl fmt::Debug for Wtf8Buf
            {
                #[inline] fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result
                { fmt::Debug::fmt(&**self, formatter) }
            }
            /// Formats the string with unpaired surrogates substituted 
            /// with the replacement character, U+FFFD.
            impl fmt::Display for Wtf8Buf
            {
                fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    if let Some(s) = self.as_known_utf8() { fmt::Display::fmt(s, formatter) }
                    else { fmt::Display::fmt(&**self, formatter) }
                }
            }

            impl Wtf8Buf
            {
                /// Creates a new, empty WTF-8 string.
                #[inline] pub fn new() -> Wtf8Buf
                { Wtf8Buf { bytes: Vec::new(), is_known_utf8: true } }
                /// Creates a new, empty WTF-8 string with pre-allocated capacity for `capacity` bytes.
                #[inline] pub fn with_capacity(capacity: usize) -> Wtf8Buf
                { Wtf8Buf { bytes: Vec::with_capacity(capacity), is_known_utf8: true } }
                /// Creates a WTF-8 string from a WTF-8 byte vec.
                #[inline] pub unsafe fn from_bytes_unchecked(value: Vec<u8>) -> Wtf8Buf
                { Wtf8Buf { bytes: value, is_known_utf8: false } }
                /// Creates a WTF-8 string from a UTF-8 `String`.
                #[inline] pub fn from_string(string: String) -> Wtf8Buf
                { Wtf8Buf { bytes: string.into_bytes(), is_known_utf8: true } }
                /// Creates a WTF-8 string from a UTF-8 `&str` slice.
                #[inline] pub fn from_str(s: &str) -> Wtf8Buf
                { Wtf8Buf { bytes: s.as_bytes().to_vec(), is_known_utf8: true } }

                pub fn clear(&mut self)
                {
                    self.bytes.clear();
                    self.is_known_utf8 = true;
                }
                /// Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit
                /// code units.
                pub fn from_wide(v: &[u16]) -> Wtf8Buf
                {
                    let mut string = Wtf8Buf::with_capacity(v.len());
                    for item in char::decode_utf16(v.iter().cloned())
                    {
                        match item
                        {
                            Ok(ch) => string.push_char(ch),
                            Err(surrogate) =>
                            {
                                let surrogate = surrogate.unpaired_surrogate();
                                // Surrogates are known to be in the code point range.
                                let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };
                                // The string will now contain an unpaired surrogate.
                                string.is_known_utf8 = false;
                                // Skip the WTF-8 concatenation check,
                                // surrogate pairs are already decoded by decode_utf16
                                string.push_code_point_unchecked(code_point);
                            }
                        }
                    }
                    string
                }
                /// Appends the given `char` to the end of this string.
                fn push_code_point_unchecked(&mut self, code_point: CodePoint)
                {
                    let mut bytes = [0; MAX_LEN_UTF8];
                    let bytes = encode_utf8_raw(code_point.value, &mut bytes);
                    self.bytes.extend_from_slice(bytes)
                }

                #[inline] pub fn as_slice(&self) -> &Wtf8
                { unsafe { Wtf8::from_bytes_unchecked(&self.bytes) } }

                #[inline] pub fn as_mut_slice(&mut self) -> &mut Wtf8
                { unsafe { Wtf8::from_mut_bytes_unchecked(&mut self.bytes) } }
                /// Converts the string to UTF-8 without validation, 
                /// if it was created from valid UTF-8.
                #[inline] fn as_known_utf8(&self) -> Option<&str>
                {
                    if self.is_known_utf8
                    { Some(unsafe { str::from_utf8_unchecked(self.as_bytes()) }) }
                    else { None }
                }
                /// Reserves capacity for at least `additional` more bytes to be inserted
                /// in the given `Wtf8Buf`.
                #[inline] pub fn reserve(&mut self, additional: usize)
                { self.bytes.reserve(additional) }
                /// Tries to reserve capacity for at least `additional` more bytes to be
                /// inserted in the given `Wtf8Buf`.
                #[inline] pub fn try_reserve(&mut self, additional: usize) -> 
                Result<(), TryReserveError>
                { self.bytes.try_reserve(additional) }

                #[inline] pub fn reserve_exact(&mut self, additional: usize)
                { self.bytes.reserve_exact(additional) }
                /// Tries to reserve the minimum capacity for exactly `additional` more
                /// bytes to be inserted in the given `Wtf8Buf`.
                #[inline] pub fn try_reserve_exact(&mut self, additional: usize) -> 
                Result<(), TryReserveError>
                { self.bytes.try_reserve_exact(additional) }

                #[inline] pub fn shrink_to_fit(&mut self) { self.bytes.shrink_to_fit() }

                #[inline] pub fn shrink_to(&mut self, min_capacity: usize)
                { self.bytes.shrink_to(min_capacity) }

                #[inline] pub fn leak<'a>(self) -> &'a mut Wtf8
                { unsafe { Wtf8::from_mut_bytes_unchecked(self.bytes.leak()) } }
                /// Returns the number of bytes that this string buffer can hold 
                /// without reallocating.
                #[inline] pub fn capacity(&self) -> usize { self.bytes.capacity() }
                /// Append a UTF-8 slice at the end of the string.
                #[inline] pub fn push_str(&mut self, other: &str)
                { self.bytes.extend_from_slice(other.as_bytes()) }

                /// Append a WTF-8 slice at the end of the string.
                #[inline] pub fn push_wtf8(&mut self, other: &Wtf8)
                {
                    match ((&*self).final_lead_surrogate(), other.initial_trail_surrogate())
                    {
                        (Some(lead), Some(trail)) =>
                        {
                            let len_without_lead_surrogate = self.len() - 3;
                            self.bytes.truncate(len_without_lead_surrogate);
                            let other_without_trail_surrogate = &other.bytes[3..];
                            self.bytes.reserve(4 + other_without_trail_surrogate.len());
                            self.push_char(decode_surrogate_pair(lead, trail));
                            self.bytes.extend_from_slice(other_without_trail_surrogate);
                        }
                        _ =>
                        {
                            if self.is_known_utf8 && other.next_surrogate(0).is_some()
                            { self.is_known_utf8 = false; }

                            self.bytes.extend_from_slice(&other.bytes);
                        }
                    }
                }
                /// Append a Unicode scalar value at the end of the string.
                #[inline] pub fn push_char(&mut self, c: char)
                { self.push_code_point_unchecked(CodePoint::from_char(c)) }
                /// Append a code point at the end of the string.
                #[inline] pub fn push(&mut self, code_point: CodePoint)
                {
                    if let Some(trail) = code_point.to_trail_surrogate()
                    {
                        if let Some(lead) = (&*self).final_lead_surrogate()
                        {
                            let len_without_lead_surrogate = self.len() - 3;
                            self.bytes.truncate(len_without_lead_surrogate);
                            self.push_char(decode_surrogate_pair(lead, trail));
                            return;
                        }
                        
                        self.is_known_utf8 = false;
                    }
                    else if code_point.to_lead_surrogate().is_some()
                    { self.is_known_utf8 = false; }
                    
                    self.push_code_point_unchecked(code_point)
                }
                /// Shortens a string to the specified length.
                #[inline] pub fn truncate(&mut self, new_len: usize)
                {
                    assert!(is_code_point_boundary(self, new_len));
                    self.bytes.truncate(new_len)
                }
                /// Consumes the WTF-8 string and tries to convert it to a vec of bytes.
                #[inline] pub fn into_bytes(self) -> Vec<u8> { self.bytes }
                /// Consumes the WTF-8 string and tries to convert it to UTF-8.
                pub fn into_string(self) -> Result<String, Wtf8Buf>
                {
                    if self.is_known_utf8 || self.next_surrogate(0).is_none()
                    { Ok(unsafe { String::from_utf8_unchecked(self.bytes) }) }
                    else { Err(self) }
                }
                /// Consumes the WTF-8 string and converts it lossily to UTF-8.
                pub fn into_string_lossy(mut self) -> String
                {
                    if !self.is_known_utf8
                    {
                        let mut pos = 0;
                        while let Some((surrogate_pos, _)) = self.next_surrogate(pos)
                        {
                            pos = surrogate_pos + 3;
                            self.bytes[surrogate_pos..pos]
                            .copy_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());
                        }
                    }
                    unsafe { String::from_utf8_unchecked(self.bytes) }
                }
                /// Converts this `Wtf8Buf` into a boxed `Wtf8`.
                #[inline] pub fn into_box(self) -> Box<Wtf8>
                {
                    unsafe { mem::transmute(self.bytes.into_boxed_slice()) }
                }
                /// Converts a `Box<Wtf8>` into a `Wtf8Buf`.
                pub fn from_box(boxed: Box<Wtf8>) -> Wtf8Buf
                {
                    let bytes: Box<[u8]> = unsafe { mem::transmute(boxed) };
                    Wtf8Buf { bytes: bytes.into_vec(), is_known_utf8: false }
                }
                /// Provides plumbing to core `Vec::extend_from_slice`.
                #[inline] pub fn extend_from_slice(&mut self, other: &[u8])
                {
                    self.bytes.extend_from_slice(other);
                    self.is_known_utf8 = false;
                }
            }
            /// Creates a new WTF-8 string from an iterator of code points.
            impl FromIterator<CodePoint> for Wtf8Buf
            {
                fn from_iter<T: IntoIterator<Item = CodePoint>>(iter: T) -> Wtf8Buf
                {
                    let mut string = Wtf8Buf::new();
                    string.extend(iter);
                    string
                }
            }
            /// Append code points from an iterator to the string.
            impl Extend<CodePoint> for Wtf8Buf
            {
                fn extend<T: IntoIterator<Item = CodePoint>>(&mut self, iter: T)
                {
                    let iterator = iter.into_iter();
                    let (low, _high) = iterator.size_hint();
                    self.bytes.reserve(low);
                    iterator.for_each(move |code_point| self.push(code_point));
                }

                #[inline] fn extend_one(&mut self, code_point: CodePoint)
                { self.push(code_point); }

                #[inline] fn extend_reserve(&mut self, additional: usize)
                { self.bytes.reserve(additional); }
            }
            /// A borrowed slice of well-formed WTF-8 data.
            #[repr(transparent)] #[derive(Eq, Ord, PartialEq, PartialOrd)]
            pub struct Wtf8
            {
                bytes: [u8],
            }

            impl AsInner<[u8]> for Wtf8
            {
                #[inline] fn as_inner(&self) -> &[u8] { &self.bytes }
            }
            /// Formats the string in double quotes, with characters escaped according to
            /// [`char::escape_debug`] and unpaired surrogates represented as `\u{xxxx}`,
            /// where each `x` is a hexadecimal digit.
            impl fmt::Debug for Wtf8
            {
                fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fn write_str_escaped(f: &mut fmt::Formatter<'_>, s: &str) -> fmt::Result
                    {
                        use ::fmt::Write;
                        for c in s.chars().flat_map(|c| c.escape_debug())
                        {
                            f.write_char(c)?
                        }

                        Ok(())
                    }

                    formatter.write_str("\"")?;
                    let mut pos = 0;

                    while let Some((surrogate_pos, surrogate)) = self.next_surrogate(pos)
                    {
                        write_str_escaped(formatter, unsafe {
                            str::from_utf8_unchecked(&self.bytes[pos..surrogate_pos])
                        })?;
                        write!(formatter, "\\u{{{:x}}}", surrogate)?;
                        pos = surrogate_pos + 3;
                    }

                    write_str_escaped(formatter, unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) })?;
                    formatter.write_str("\"")
                }
            }
            /// Formats the string with unpaired surrogates substituted with the replacement
            /// character, U+FFFD.
            impl fmt::Display for Wtf8
            {
                fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    let wtf8_bytes = &self.bytes;
                    let mut pos = 0;
                    loop
                    {
                        match self.next_surrogate(pos)
                        {
                            Some((surrogate_pos, _)) =>
                            {
                                formatter.write_str(unsafe
                                {
                                    str::from_utf8_unchecked(&wtf8_bytes[pos..surrogate_pos])
                                })?;
                                formatter.write_str(UTF8_REPLACEMENT_CHARACTER)?;
                                pos = surrogate_pos + 3;
                            }

                            None =>
                            {
                                let s = unsafe { str::from_utf8_unchecked(&wtf8_bytes[pos..]) };
                                if pos == 0 { return s.fmt(formatter) } else { return formatter.write_str(s) }
                            }
                        }
                    }
                }
            }

            impl Wtf8
            {
                /// Creates a WTF-8 slice from a UTF-8 `&str` slice.
                #[inline] pub fn from_str(value: &str) -> &Wtf8
                {
                    unsafe { Wtf8::from_bytes_unchecked(value.as_bytes()) }
                }
                /// Creates a WTF-8 slice from a WTF-8 byte slice.
                #[inline] pub unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8
                {
                    unsafe { &*(value as *const [u8] as *const Wtf8) }
                }
                /// Creates a mutable WTF-8 slice from a mutable WTF-8 byte slice.
                #[inline] unsafe fn from_mut_bytes_unchecked(value: &mut [u8]) -> &mut Wtf8
                {
                    unsafe { &mut *(value as *mut [u8] as *mut Wtf8) }
                }
                /// Returns the length, in WTF-8 bytes.
                #[inline] pub fn len(&self) -> usize { self.bytes.len() }
                #[inline] pub fn is_empty(&self) -> bool { self.bytes.is_empty() }
                /// Returns the code point at `position` if it is in the ASCII range,
                /// or `b'\xFF'` otherwise.
                #[inline] pub fn ascii_byte_at(&self, position: usize) -> u8
                {
                    match self.bytes[position]
                    {
                        ascii_byte @ 0x00..=0x7F => ascii_byte,
                        _ => 0xFF,
                    }
                }
                /// Returns an iterator for the string’s code points.
                #[inline] pub fn code_points(&self) -> Wtf8CodePoints<'_>
                { Wtf8CodePoints { bytes: self.bytes.iter() } }
                /// Access raw bytes of WTF-8 data
                #[inline] pub fn as_bytes(&self) -> &[u8] { &self.bytes }
                /// Tries to convert the string to UTF-8 and return a `&str` slice.
                #[inline] pub fn as_str(&self) -> Result<&str, str::Utf8Error>
                { str::from_utf8(&self.bytes) }
                /// Creates an owned `Wtf8Buf` from a borrowed `Wtf8`.
                pub fn to_owned(&self) -> Wtf8Buf
                {
                    Wtf8Buf { bytes: self.bytes.to_vec(), is_known_utf8: false }
                }
                /// Lossily converts the string to UTF-8.
                pub fn to_string_lossy(&self) -> Cow<'_, str>
                {
                    let Some((surrogate_pos, _)) = self.next_surrogate(0) 
                    else { return Cow::Borrowed(unsafe { str::from_utf8_unchecked(&self.bytes) }); };
                    let wtf8_bytes = &self.bytes;
                    let mut utf8_bytes = Vec::with_capacity(self.len());
                    utf8_bytes.extend_from_slice(&wtf8_bytes[..surrogate_pos]);
                    utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());
                    let mut pos = surrogate_pos + 3;
                    loop
                    {
                        match self.next_surrogate(pos)
                        {
                            Some((surrogate_pos, _)) =>
                            {
                                utf8_bytes.extend_from_slice(&wtf8_bytes[pos..surrogate_pos]);
                                utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());
                                pos = surrogate_pos + 3;
                            }

                            None =>
                            {
                                utf8_bytes.extend_from_slice(&wtf8_bytes[pos..]);
                                return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) });
                            }
                        }
                    }
                }
                /// Converts the WTF-8 string to potentially ill-formed UTF-16
                /// and return an iterator of 16-bit code units.
                #[inline] pub fn encode_wide(&self) -> EncodeWide<'_>
                {
                    EncodeWide { code_points: self.code_points(), extra: 0 }
                }

                #[inline] fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)>
                {
                    let mut iter = self.bytes[pos..].iter();
                    loop
                    {
                        let b = *iter.next()?;
                        if b < 0x80 { pos += 1; }
                        else if b < 0xE0
                        {
                            iter.next();
                            pos += 2;
                        }
                        else if b == 0xED
                        {
                            match (iter.next(), iter.next())
                            {
                                (Some(&b2), Some(&b3)) if b2 >= 0xA0 =>
                                {
                                    return Some((pos, decode_surrogate(b2, b3)));
                                }
                                _ => pos += 3,
                            }
                        }
                        else if b < 0xF0
                        {
                            iter.next();
                            iter.next();
                            pos += 3;
                        }
                        else
                        {
                            iter.next();
                            iter.next();
                            iter.next();
                            pos += 4;
                        }
                    }
                }

                #[inline] fn final_lead_surrogate(&self) -> Option<u16>
                {
                    match self.bytes
                    {
                        [.., 0xED, b2 @ 0xA0..=0xAF, b3] => Some(decode_surrogate(b2, b3)),
                        _ => None,
                    }
                }

                #[inline] fn initial_trail_surrogate(&self) -> Option<u16>
                {
                    match self.bytes
                    {
                        [0xED, b2 @ 0xB0..=0xBF, b3, ..] => Some(decode_surrogate(b2, b3)),
                        _ => None,
                    }
                }

                pub fn clone_into(&self, buf: &mut Wtf8Buf)
                {
                    buf.is_known_utf8 = false;
                    self.bytes.clone_into(&mut buf.bytes);
                }
                /// Boxes this `Wtf8`.
                #[inline] pub fn into_box(&self) -> Box<Wtf8>
                {
                    let boxed: Box<[u8]> = self.bytes.into();
                    unsafe { mem::transmute(boxed) }
                }
                /// Creates a boxed, empty `Wtf8`.
                pub fn empty_box() -> Box<Wtf8>
                {
                    let boxed: Box<[u8]> = Default::default();
                    unsafe { mem::transmute(boxed) }
                }

                #[inline] pub fn into_arc(&self) -> Arc<Wtf8>
                {
                    let arc: Arc<[u8]> = Arc::from(&self.bytes);
                    unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Wtf8) }
                }

                #[inline] pub fn into_rc(&self) -> Rc<Wtf8>
                {
                    let rc: Rc<[u8]> = Rc::from(&self.bytes);
                    unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Wtf8) }
                }

                #[inline] pub fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }

                #[inline] pub fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }

                #[inline] pub fn to_ascii_lowercase(&self) -> Wtf8Buf { Wtf8Buf { bytes: self.bytes.to_ascii_lowercase(), is_known_utf8: false } }

                #[inline] pub fn to_ascii_uppercase(&self) -> Wtf8Buf { Wtf8Buf { bytes: self.bytes.to_ascii_uppercase(), is_known_utf8: false } }

                #[inline] pub fn is_ascii(&self) -> bool { self.bytes.is_ascii() }

                #[inline] pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool { self.bytes.eq_ignore_ascii_case(&other.bytes) }
            }
            /// Returns a slice of the given string for the byte range \[`begin`..`end`).
            impl ops::Index<ops::Range<usize>> for Wtf8
            {
                type Output = Wtf8;

                #[inline] fn index(&self, range: ops::Range<usize>) -> &Wtf8
                {
                    if range.start <= range.end
                        && is_code_point_boundary(self, range.start)
                        && is_code_point_boundary(self, range.end)
                    {
                        unsafe { slice_unchecked(self, range.start, range.end) }
                    } else {
                        slice_error_fail(self, range.start, range.end)
                    }
                }
            }
            /// Returns a slice of the given string from byte `begin` to its end.
            impl ops::Index<ops::RangeFrom<usize>> for Wtf8
            {
                type Output = Wtf8;
                #[inline] fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8
                {
                    if is_code_point_boundary(self, range.start)
                    { unsafe { slice_unchecked(self, range.start, self.len()) } }

                    else { slice_error_fail(self, range.start, self.len()) }
                }
            }
            /// Returns a slice of the given string from its beginning to byte `end`.
            impl ops::Index<ops::RangeTo<usize>> for Wtf8
            {
                type Output = Wtf8;
                #[inline] fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8
                {
                    if is_code_point_boundary(self, range.end) {
                        unsafe { slice_unchecked(self, 0, range.end) }
                    } else {
                        slice_error_fail(self, 0, range.end)
                    }
                }
            }

            impl ops::Index<ops::RangeFull> for Wtf8
            {
                type Output = Wtf8;
                #[inline] fn index(&self, _range: ops::RangeFull) -> &Wtf8 { self }
            }

            #[inline] fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16
            { 0xD800 | (second_byte as u16 & 0x3F) << 6 | third_byte as u16 & 0x3F }

            #[inline] fn decode_surrogate_pair(lead: u16, trail: u16) -> char
            {
                let code_point = 0x10000 + ((((lead - 0xD800) as u32) << 10) | (trail - 0xDC00) as u32);
                unsafe { char::from_u32_unchecked(code_point) }
            }
            
            #[inline] pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool
            {
                if index == 0 { return true; }

                match slice.bytes.get(index)
                {
                    None => index == slice.len(),
                    Some(&b) => (b as i8) >= -0x40,
                }
            }
            /// Verify that `index` is at the edge of either a valid UTF-8 codepoint
            /// (i.e. a codepoint that's not a surrogate) or of the whole string.
            #[inline] #[track_caller] pub fn check_utf8_boundary(slice: &Wtf8, index: usize)
            {
                if index == 0 { return; }

                match slice.bytes.get(index)
                {
                    Some(0xED) => (),
                    Some(&b) if (b as i8) >= -0x40 => return,
                    Some(_) => panic!("byte index {index} is not a codepoint boundary"),
                    None if index == slice.len() => return,
                    None => panic!("byte index {index} is out of bounds"),
                }
                
                if slice.bytes[index + 1] >= 0xA0
                {
                    if index >= 3 
                    && slice.bytes[index - 3] == 0xED
                    && slice.bytes[index - 2] >= 0xA0
                    {
                        panic!("byte index {index} lies between surrogate codepoints");
                    }
                }
            }
            
            #[inline] pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8
            {
                unsafe
                {
                    let len = end - begin;
                    let start = s.as_bytes().as_ptr().add(begin);
                    Wtf8::from_bytes_unchecked(slice::from_raw_parts(start, len))
                }
            }
            
            #[inline(never)] pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> !
            {
                assert!(begin <= end);
                panic!("index {begin} and/or {end} in `{s:?}` do not lie on character boundary");
            }

            /// Iterator for the code points of a WTF-8 string.
            #[derive(Clone)]
            pub struct Wtf8CodePoints<'a>
            {
                bytes: slice::Iter<'a, u8>,
            }

            impl Iterator for Wtf8CodePoints<'_>
            {
                type Item = CodePoint;

                #[inline] fn next(&mut self) -> Option<CodePoint>
                {
                    unsafe { next_code_point(&mut self.bytes).map(|c| CodePoint { value: c }) }
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>)
                {
                    let len = self.bytes.len();
                    (len.saturating_add(3) / 4, Some(len))
                }
            }
            /// Generates a wide character sequence for potentially ill-formed UTF-16.
            #[derive(Clone)]
            pub struct EncodeWide<'a>
            {
                code_points: Wtf8CodePoints<'a>,
                extra: u16,
            }
            
            impl Iterator for EncodeWide<'_>
            {
                type Item = u16;
                #[inline] fn next(&mut self) -> Option<u16>
                {
                    if self.extra != 0
                    {
                        let tmp = self.extra;
                        self.extra = 0;
                        return Some(tmp);
                    }

                    let mut buf = [0; MAX_LEN_UTF16];
                    self.code_points.next().map(|code_point|
                    {
                        let n = encode_utf16_raw(code_point.value, &mut buf).len();
                        if n == 2 { self.extra = buf[1]; }
                        buf[0]
                    })
                }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>)
                {
                    let (low, high) = self.code_points.size_hint();
                    let ext = (self.extra != 0) as usize;
                    (low + ext, high.and_then(|n| n.checked_mul(2)).and_then(|n| n.checked_add(ext)))
                }
            }
            
            impl FusedIterator for EncodeWide<'_> {}

            impl Hash for CodePoint
            {
                #[inline] fn hash<H: Hasher>(&self, state: &mut H) { self.value.hash(state) }
            }

            impl Hash for Wtf8Buf
            {
                #[inline] fn hash<H: Hasher>(&self, state: &mut H)
                {
                    state.write(&self.bytes);
                    0xfeu8.hash(state)
                }
            }

            impl Hash for Wtf8
            {
                #[inline] fn hash<H: Hasher>(&self, state: &mut H)
                {
                    state.write(&self.bytes);
                    0xfeu8.hash(state)
                }
            }
            
            unsafe impl CloneToUninit for Wtf8
            {
                #[inline]
                unsafe fn clone_to_uninit(&self, dst: *mut u8)
                {
                    unsafe { self.bytes.clone_to_uninit(dst) }
                }
            }
        }

        pub mod small_c_string
        {
            use ::
            {
                ffi::{CStr, CString},
                mem::MaybeUninit,
                path::Path,
                *,
            };
            
            const MAX_STACK_ALLOCATION: usize = 384;

            const NUL_ERR: io::Error = 
            constant_error!(io::ErrorKind::InvalidInput, "file name contained an unexpected NUL byte");

            #[inline] pub fn run_path_with_cstr<T>(path: &Path, f: &dyn Fn(&CStr) -> io::Result<T>) -> io::Result<T>
            { run_with_cstr(path.as_os_str().as_encoded_bytes(), f) }

            #[inline] pub fn run_with_cstr<T>(bytes: &[u8], f: &dyn Fn(&CStr) -> io::Result<T>) -> io::Result<T>
            {
                if bytes.len() >= MAX_STACK_ALLOCATION { run_with_cstr_allocating(bytes, f) }
                else { unsafe { run_with_cstr_stack(bytes, f) } }
            }
            
            pub unsafe fn run_with_cstr_stack<T> ( bytes: &[u8], f: &dyn Fn(&CStr) -> io::Result<T> ) -> 
            io::Result<T>
            {
                unsafe
                {
                    let mut buf = MaybeUninit::<[u8; MAX_STACK_ALLOCATION]>::uninit();
                    let buf_ptr = buf.as_mut_ptr() as *mut u8;
                    ptr::copy_nonoverlapping(bytes.as_ptr(), buf_ptr, bytes.len());
                    buf_ptr.add(bytes.len()).write(0);

                    match CStr::from_bytes_with_nul(unsafe { slice::from_raw_parts(buf_ptr, bytes.len() + 1) })
                    {
                        Ok(s) => f(s),
                        Err(_) => Err(NUL_ERR),
                    }
                }
            }

            #[cold] #[inline(never)] fn run_with_cstr_allocating<T>(bytes: &[u8], f: &dyn Fn(&CStr) -> io::Result<T>) 
            -> io::Result<T> 
            {
                match CString::new(bytes)
                {
                    Ok(s) => f(&s),
                    Err(_) => Err(NUL_ERR),
                }
            }
        }

        /// A trait for viewing representations from std types
        pub trait AsInner<Inner: ?Sized>
        {
            fn as_inner(&self) -> &Inner;
        }
        /// A trait for viewing representations from std types
        pub trait AsInnerMut<Inner: ?Sized>
        {
            fn as_inner_mut(&mut self) -> &mut Inner;
        }
        /// A trait for extracting representations from std types
        pub trait IntoInner<Inner>
        {
            fn into_inner(self) -> Inner;
        }
        /// A trait for creating std types from internal representations
        pub trait FromInner<Inner>
        {
            fn from_inner(inner: Inner) -> Self;
        }
        
        pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64
        {
            let q = value / denom;
            let r = value % denom;
            q * numer + r * numer / denom
        }

        pub fn ignore_notfound<T>(result: ::io::Result<T>) -> ::io::Result<()>
        {
            match result
            {
                Err(err) if err.kind() == ::io::ErrorKind::NotFound => Ok(()),
                Ok(_) => Ok(()),
                Err(err) => Err(err),
            }
        }
    }
    
    pub mod fd
    {
        use ::
        {
            *,
        };
        
        type ValidRawFd = ::num::niche_types::NotAllOnes<RawFd>;
        
        /// An owned file descriptor.
        #[repr(transparent)] #[rustc_nonnull_optimization_guaranteed]
        pub struct OwnedFd
        {
            fd: ValidRawFd,
        }
        #[derive(Debug)]
        pub struct FileDesc(OwnedFd);
    }

    pub mod fs
    {
        use ::
        {
            path::{ Path, PathBuf },
            *,
        };

        mod unix
        {
            use ::
            {
                ffi::{CStr, OsStr, OsString},
                fmt::{self, Write as _},
                io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom},
                libc::{dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, stat64},
                os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd},
                os::unix::prelude::*,
                path::{Path, PathBuf},
                sync::Arc,
                sys::common::small_c_string::run_path_with_cstr,
                sys::fd::FileDesc,
                sys::time::SystemTime,
                sys::{cvt, cvt_r},
                sys::common::{AsInner, AsInnerMut, FromInner, IntoInner},
                *,
            };
            pub use ::sys::common::fs::exists;
            
            pub struct File(FileDesc);
            
            #[derive(Clone)]
            pub struct FileAttr
            {
                stat: stat64,
            }
            
            struct InnerReadDir
            {
                dirp: Dir,
                root: PathBuf,
            }

            pub struct ReadDir
            {
                inner: Arc<InnerReadDir>,
                end_of_stream: bool,
            }

            impl ReadDir
            {
                fn new(inner: InnerReadDir) -> Self
                {
                    Self { inner: Arc::new(inner), end_of_stream: false }
                }
            }

            struct Dir(*mut libc::DIR);

            unsafe impl Send for Dir {}
            unsafe impl Sync for Dir {}
            
            pub struct DirEntry 
            {
                dir: Arc<InnerReadDir>,
                entry: dirent64,
            }

            #[derive(Clone)]
            pub struct OpenOptions {
                read: bool,
                write: bool,
                append: bool,
                truncate: bool,
                create: bool,
                create_new: bool,
                custom_flags: i32,
                mode: mode_t,
            }

            #[derive(Clone, PartialEq, Eq)]
            pub struct FilePermissions {
                mode: mode_t,
            }

            #[derive(Copy, Clone, Debug, Default)]
            pub struct FileTimes {
                accessed: Option<SystemTime>,
                modified: Option<SystemTime>,
                #[cfg(target_vendor = "apple")]
                created: Option<SystemTime>,
            }

            #[derive(Copy, Clone, Eq)]
            pub struct FileType {
                mode: mode_t,
            }

            impl PartialEq for FileType {
                fn eq(&self, other: &Self) -> bool {
                    self.masked() == other.masked()
                }
            }

            impl ::hash::Hash for FileType {
                fn hash<H: ::hash::Hasher>(&self, state: &mut H) {
                    self.masked().hash(state);
                }
            }

            pub struct DirBuilder {
                mode: mode_t,
            }

            #[derive(Copy, Clone)]
            struct Mode(mode_t);
            
            impl FileAttr
            {
                fn from_stat64(stat: stat64) -> Self { Self { stat } }
            }

            impl FileAttr
            {
                pub fn size(&self) -> u64 {
                    self.stat.st_size as u64
                }
                pub fn perm(&self) -> FilePermissions {
                    FilePermissions { mode: (self.stat.st_mode as mode_t) }
                }

                pub fn file_type(&self) -> FileType {
                    FileType { mode: self.stat.st_mode as mode_t }
                }
            }
            
            impl FileAttr
            {   
                pub fn modified(&self) -> io::Result<SystemTime> 
                {
                    SystemTime::new(self.stat.st_mtime as i64, self.stat.st_mtime_nsec as i64)
                }
                
                pub fn accessed(&self) -> io::Result<SystemTime>
                {
                    SystemTime::new(self.stat.st_atime as i64, self.stat.st_atime_nsec as i64)
                }
                
                pub fn created(&self) -> io::Result<SystemTime>
                {
                    SystemTime::new(self.stat.st_birthtime as i64, self.stat.st_birthtime_nsec as i64)
                }
            }

            impl AsInner<stat64> for FileAttr 
            {
                #[inline]
                fn as_inner(&self) -> &stat64 {
                    &self.stat
                }
            }

            impl FilePermissions 
            {
                pub fn readonly(&self) -> bool {
                    // check if any class (owner, group, others) has write permission
                    self.mode & 0o222 == 0
                }

                pub fn set_readonly(&mut self, readonly: bool) {
                    if readonly {
                        // remove write permission for all classes; equivalent to `chmod a-w <file>`
                        self.mode &= !0o222;
                    } else {
                        // add write permission for all classes; equivalent to `chmod a+w <file>`
                        self.mode |= 0o222;
                    }
                }
                pub fn mode(&self) -> u32 {
                    self.mode as u32
                }
            }

            impl FileTimes 
            {
                pub fn set_accessed(&mut self, t: SystemTime) {
                    self.accessed = Some(t);
                }

                pub fn set_modified(&mut self, t: SystemTime) {
                    self.modified = Some(t);
                }
            }

            impl FileType
            {
                pub fn is_dir(&self) -> bool {
                    self.is(libc::S_IFDIR)
                }
                pub fn is_file(&self) -> bool {
                    self.is(libc::S_IFREG)
                }
                pub fn is_symlink(&self) -> bool {
                    self.is(libc::S_IFLNK)
                }

                pub fn is(&self, mode: mode_t) -> bool {
                    self.masked() == mode
                }

                fn masked(&self) -> mode_t {
                    self.mode & libc::S_IFMT
                }
            }

            impl fmt::Debug for FileType 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let FileType { mode } = self;
                    f.debug_struct("FileType").field("mode", &Mode(*mode)).finish()
                }
            }

            impl FromInner<u32> for FilePermissions 
            {
                fn from_inner(mode: u32) -> FilePermissions {
                    FilePermissions { mode: mode as mode_t }
                }
            }

            impl fmt::Debug for FilePermissions
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let FilePermissions { mode } = self;
                    f.debug_struct("FilePermissions").field("mode", &Mode(*mode)).finish()
                }
            }

            impl fmt::Debug for ReadDir
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Debug::fmt(&*self.inner.root, f)
                }
            }

            impl Iterator for ReadDir
            {
                type Item = io::Result<DirEntry>;
                fn next(&mut self) -> Option<io::Result<DirEntry>>
                {
                    unsafe
                    {
                        if self.end_of_stream {
                            return None;
                        }
                        let mut ret = DirEntry { entry: mem::zeroed(), dir: Arc::clone(&self.inner) };
                        let mut entry_ptr = ptr::null_mut();
                        loop {
                            let err = readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr);
                            if err != 0 {
                                if entry_ptr.is_null() {
                                    self.end_of_stream = true;
                                }
                                return Some(Err(Error::from_raw_os_error(err)));
                            }
                            if entry_ptr.is_null() {
                                return None;
                            }
                            if ret.name_bytes() != b"." && ret.name_bytes() != b".." {
                                return Some(Ok(ret));
                            }
                        }
                    }
                }
            }
            /// Aborts the process if a file desceriptor is not open, if debug asserts are enabled.
            #[inline] pub fn debug_assert_fd_is_open(fd: RawFd)
            {
                use ::error::errno;
                
                if core::ub_checks::check_library_ub()
                {
                    if unsafe { libc::fcntl(fd, libc::F_GETFD) } == -1 && errno() == libc::EBADF
                    {
                        rtabort!("IO Safety violation: owned file descriptor already closed");
                    }
                }
            }

            impl Drop for Dir
            {
                fn drop(&mut self)
                {
                    let fd = unsafe { libc::dirfd(self.0) };
                    debug_assert_fd_is_open(fd);
                    let r = unsafe { libc::closedir(self.0) };
                    assert!
                    (
                        r == 0 || ::io::Error::last_os_error().is_interrupted(),
                        "unexpected error during closedir: {:?}",
                        ::io::Error::last_os_error()
                    );
                }
            }

            impl DirEntry
            {
                pub fn path(&self) -> PathBuf {
                    self.dir.root.join(self.file_name_os_str())
                }

                pub fn file_name(&self) -> OsString {
                    self.file_name_os_str().to_os_string()
                }
                
                pub fn metadata(&self) -> io::Result<FileAttr> 
                {
                    let fd = cvt(unsafe { dirfd(self.dir.dirp.0) })?;
                    let name = self.name_cstr().as_ptr();
                    let mut stat: stat64 = unsafe { mem::zeroed() };
                    cvt(unsafe { fstatat64(fd, name, &mut stat, libc::AT_SYMLINK_NOFOLLOW) })?;
                    Ok(FileAttr::from_stat64(stat))
                }
                
                pub fn file_type(&self) -> io::Result<FileType> {
                    match self.entry.d_type {
                        libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),
                        libc::DT_FIFO => Ok(FileType { mode: libc::S_IFIFO }),
                        libc::DT_LNK => Ok(FileType { mode: libc::S_IFLNK }),
                        libc::DT_REG => Ok(FileType { mode: libc::S_IFREG }),
                        libc::DT_SOCK => Ok(FileType { mode: libc::S_IFSOCK }),
                        libc::DT_DIR => Ok(FileType { mode: libc::S_IFDIR }),
                        libc::DT_BLK => Ok(FileType { mode: libc::S_IFBLK }),
                        _ => self.metadata().map(|m| m.file_type()),
                    }
                }
                
                pub fn ino(&self) -> u64 {
                    self.entry.d_fileno as u64
                }
                
                fn name_bytes(&self) -> &[u8] {
                    use ::slice;
                    unsafe {
                        slice::from_raw_parts(
                            self.entry.d_name.as_ptr() as *const u8,
                            self.entry.d_namlen as usize,
                        )
                    }
                }

                fn name_cstr(&self) -> &CStr {
                    &self.name
                }

                pub fn file_name_os_str(&self) -> &OsStr {
                    OsStr::from_bytes(self.name_bytes())
                }
            }

            impl OpenOptions
            {
                pub fn new() -> OpenOptions
                {
                    OpenOptions {
                        // generic
                        read: false,
                        write: false,
                        append: false,
                        truncate: false,
                        create: false,
                        create_new: false,
                        // system-specific
                        custom_flags: 0,
                        mode: 0o666,
                    }
                }

                pub fn read(&mut self, read: bool) { self.read = read; }
                pub fn write(&mut self, write: bool) { self.write = write; }
                pub fn append(&mut self, append: bool) { self.append = append; }
                pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
                pub fn create(&mut self, create: bool) { self.create = create; }
                pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }
                pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }
                pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }

                fn get_access_mode(&self) -> io::Result<c_int>
                {
                    match (self.read, self.write, self.append)
                    {
                        (true, false, false) => Ok(libc::O_RDONLY),
                        (false, true, false) => Ok(libc::O_WRONLY),
                        (true, true, false) => Ok(libc::O_RDWR),
                        (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),
                        (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),
                        (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),
                    }
                }

                fn get_creation_mode(&self) -> io::Result<c_int> {
                    match (self.write, self.append) {
                        (true, false) => {}
                        (false, false) => {
                            if self.truncate || self.create || self.create_new {
                                return Err(Error::from_raw_os_error(libc::EINVAL));
                            }
                        }
                        (_, true) => {
                            if self.truncate && !self.create_new {
                                return Err(Error::from_raw_os_error(libc::EINVAL));
                            }
                        }
                    }

                    Ok(match (self.create, self.truncate, self.create_new) {
                        (false, false, false) => 0,
                        (true, false, false) => libc::O_CREAT,
                        (false, true, false) => libc::O_TRUNC,
                        (true, true, false) => libc::O_CREAT | libc::O_TRUNC,
                        (_, _, true) => libc::O_CREAT | libc::O_EXCL,
                    })
                }
            }

            impl fmt::Debug for OpenOptions
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    let OpenOptions { read, write, append, truncate, create, create_new, custom_flags, mode } = self;
                    f.debug_struct("OpenOptions")
                    .field("read", read)
                    .field("write", write)
                    .field("append", append)
                    .field("truncate", truncate)
                    .field("create", create)
                    .field("create_new", create_new)
                    .field("custom_flags", custom_flags)
                    .field("mode", &Mode(*mode))
                    .finish()
                }
            }

            impl File
            {
                pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {
                    run_path_with_cstr(path, &|path| File::open_c(path, opts))
                }

                pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {
                    let flags = libc::O_CLOEXEC
                        | opts.get_access_mode()?
                        | opts.get_creation_mode()?
                        | (opts.custom_flags as c_int & !libc::O_ACCMODE);
                        
                    let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;
                    Ok(File(unsafe { FileDesc::from_raw_fd(fd) }))
                }

                pub fn file_attr(&self) -> io::Result<FileAttr> {
                    let fd = self.as_raw_fd();
                    let mut stat: stat64 = unsafe { mem::zeroed() };
                    cvt(unsafe { fstat64(fd, &mut stat) })?;
                    Ok(FileAttr::from_stat64(stat))
                }

                pub fn fsync(&self) -> io::Result<()> {
                    cvt_r(|| unsafe { os_fsync(self.as_raw_fd()) })?;
                    return Ok(());
                    
                    unsafe fn os_fsync(fd: c_int) -> c_int {
                        libc::fsync(fd)
                    }
                }

                pub fn datasync(&self) -> io::Result<()>
                {
                    cvt_r(|| unsafe { os_datasync(self.as_raw_fd()) })?;
                    return Ok(());
                    
                    unsafe fn os_datasync(fd: c_int) -> c_int {
                        libc::fdatasync(fd)
                    }
                }
                
                pub fn lock(&self) -> io::Result<()> {
                    Err(constant_error!(io::ErrorKind::Unsupported, "lock() not supported"))
                }
                
                pub fn lock_shared(&self) -> io::Result<()> {
                    Err(constant_error!(io::ErrorKind::Unsupported, "lock_shared() not supported"))
                }
                
                pub fn try_lock(&self) -> io::Result<bool> {
                    Err(constant_error!(io::ErrorKind::Unsupported, "try_lock() not supported"))
                }
                
                pub fn try_lock_shared(&self) -> io::Result<bool> {
                    Err(constant_error!(io::ErrorKind::Unsupported, "try_lock_shared() not supported"))
                }
                
                pub fn unlock(&self) -> io::Result<()> {
                    Err(constant_error!(io::ErrorKind::Unsupported, "unlock() not supported"))
                }

                pub fn truncate(&self, size: u64) -> io::Result<()> {
                    let size: off64_t =
                        size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
                    cvt_r(|| unsafe { ftruncate64(self.as_raw_fd(), size) }).map(drop)
                }

                pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }

                pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> { self.0.read_vectored(bufs) }

                #[inline] pub fn is_read_vectored(&self) -> bool { self.0.is_read_vectored() }

                pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> { self.0.read_at(buf, offset) }

                pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> { self.0.read_buf(cursor) }

                pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> { self.0.read_vectored_at(bufs, offset) }

                pub fn write(&self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }

                pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> { self.0.write_vectored(bufs) }

                #[inline] pub fn is_write_vectored(&self) -> bool { self.0.is_write_vectored() }

                pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> { self.0.write_at(buf, offset) }

                pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> { self.0.write_vectored_at(bufs, offset) }

                #[inline] pub fn flush(&self) -> io::Result<()> { Ok(()) }

                pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {
                    let (whence, pos) = match pos 
                    {
                        SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),
                        SeekFrom::End(off) => (libc::SEEK_END, off),
                        SeekFrom::Current(off) => (libc::SEEK_CUR, off),
                    };
                    let n = cvt(unsafe { lseek64(self.as_raw_fd(), pos as off64_t, whence) })?;
                    Ok(n as u64)
                }

                pub fn tell(&self) -> io::Result<u64> { self.seek(SeekFrom::Current(0)) }

                pub fn duplicate(&self) -> io::Result<File> { self.0.duplicate().map(File) }

                pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> 
                {
                    cvt_r(|| unsafe { libc::fchmod(self.as_raw_fd(), perm.mode) })?;
                    Ok(())
                }

                pub fn set_times(&self, times: FileTimes) -> io::Result<()> 
                {
                    let times = [to_timespec(times.accessed)?, to_timespec(times.modified)?];
                    cvt(unsafe { libc::futimens(self.as_raw_fd(), times.as_ptr()) })?;
                    Ok(())
                }
            }

            impl DirBuilder
            {
                pub fn new() -> DirBuilder { DirBuilder { mode: 0o777 } }

                pub fn mkdir(&self, p: &Path) -> io::Result<()>
                { run_path_with_cstr(p, &|p| cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) }).map(|_| ())) }

                pub fn set_mode(&mut self, mode: u32) { self.mode = mode as mode_t; }
            }

            impl fmt::Debug for DirBuilder
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    let DirBuilder { mode } = self;
                    f.debug_struct("DirBuilder").field("mode", &Mode(*mode)).finish()
                }
            }

            impl AsInner<FileDesc> for File
            {
                #[inline] fn as_inner(&self) -> &FileDesc { &self.0 }
            }

            impl AsInnerMut<FileDesc> for File
            {
                #[inline] fn as_inner_mut(&mut self) -> &mut FileDesc { &mut self.0 }
            }

            impl IntoInner<FileDesc> for File 
            {
                fn into_inner(self) -> FileDesc { self.0 }
            }

            impl FromInner<FileDesc> for File 
            {
                fn from_inner(file_desc: FileDesc) -> Self { Self(file_desc) }
            }

            impl AsFd for File
            {
                #[inline] fn as_fd(&self) -> BorrowedFd<'_> { self.0.as_fd() }
            }

            impl AsRawFd for File
            {
                #[inline] fn as_raw_fd(&self) -> RawFd { self.0.as_raw_fd() }
            }

            impl IntoRawFd for File 
            {
                fn into_raw_fd(self) -> RawFd { self.0.into_raw_fd() }
            }

            impl FromRawFd for File 
            {
                unsafe fn from_raw_fd(raw_fd: RawFd) -> Self { Self(FromRawFd::from_raw_fd(raw_fd)) }
            }

            impl fmt::Debug for File 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    
                    fn get_path(_fd: c_int) -> Option<PathBuf> {
                        None
                    }

                    fn get_mode(fd: c_int) -> Option<(bool, bool)> {
                        let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };
                        if mode == -1 {
                            return None;
                        }
                        match mode & libc::O_ACCMODE {
                            libc::O_RDONLY => Some((true, false)),
                            libc::O_RDWR => Some((true, true)),
                            libc::O_WRONLY => Some((false, true)),
                            _ => None,
                        }
                    }

                    let fd = self.as_raw_fd();
                    let mut b = f.debug_struct("File");
                    b.field("fd", &fd);
                    if let Some(path) = get_path(fd) {
                        b.field("path", &path);
                    }
                    if let Some((read, write)) = get_mode(fd) {
                        b.field("read", &read).field("write", &write);
                    }
                    b.finish()
                }
            }
            
            impl fmt::Debug for Mode 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let Self(mode) = *self;
                    write!(f, "0o{mode:06o}")?;

                    let entry_type = match mode & libc::S_IFMT {
                        libc::S_IFDIR => 'd',
                        libc::S_IFBLK => 'b',
                        libc::S_IFCHR => 'c',
                        libc::S_IFLNK => 'l',
                        libc::S_IFIFO => 'p',
                        libc::S_IFREG => '-',
                        _ => return Ok(()),
                    };

                    f.write_str(" (")?;
                    f.write_char(entry_type)?;
                    
                    f.write_char(if mode & libc::S_IRUSR != 0 { 'r' } else { '-' })?;
                    f.write_char(if mode & libc::S_IWUSR != 0 { 'w' } else { '-' })?;
                    let owner_executable = mode & libc::S_IXUSR != 0;
                    let setuid = mode as c_int & libc::S_ISUID as c_int != 0;
                    f.write_char(match (owner_executable, setuid) {
                        (true, true) => 's',  
                        (false, true) => 'S', 
                        (true, false) => 'x', 
                        (false, false) => '-',
                    })?;
                    
                    f.write_char(if mode & libc::S_IRGRP != 0 { 'r' } else { '-' })?;
                    f.write_char(if mode & libc::S_IWGRP != 0 { 'w' } else { '-' })?;
                    let group_executable = mode & libc::S_IXGRP != 0;
                    let setgid = mode as c_int & libc::S_ISGID as c_int != 0;
                    f.write_char(match (group_executable, setgid) {
                        (true, true) => 's', 
                        (false, true) => 'S', 
                        (true, false) => 'x', 
                        (false, false) => '-',
                    })?;
                    
                    f.write_char(if mode & libc::S_IROTH != 0 { 'r' } else { '-' })?;
                    f.write_char(if mode & libc::S_IWOTH != 0 { 'w' } else { '-' })?;
                    let other_executable = mode & libc::S_IXOTH != 0;
                    let sticky = mode as c_int & libc::S_ISVTX as c_int != 0;
                    f.write_char(match (entry_type, other_executable, sticky) {
                        ('d', true, true) => 't',  
                        ('d', false, true) => 'T', 
                        (_, true, _) => 'x',       
                        (_, false, _) => '-',
                    })?;

                    f.write_char(')')
                }
            }

            pub fn readdir(path: &Path) -> io::Result<ReadDir>
            {
                let ptr = run_path_with_cstr(path, &|p| unsafe { Ok(libc::opendir(p.as_ptr())) })?;
                if ptr.is_null() {
                    Err(Error::last_os_error())
                } else {
                    let root = path.to_path_buf();
                    let inner = InnerReadDir { dirp: Dir(ptr), root };
                    Ok(ReadDir::new(inner))
                }
            }

            pub fn unlink(p: &CStr) -> io::Result<()>
            {
                cvt(unsafe { libc::unlink(p.as_ptr()) }).map(|_| ())
            }

            pub fn rename(old: &CStr, new: &CStr) -> io::Result<()>
            {
                cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) }).map(|_| ())
            }

            pub fn set_perm(p: &CStr, perm: FilePermissions) -> io::Result<()>
            {
                cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) }).map(|_| ())
            }

            pub fn rmdir(p: &CStr) -> io::Result<()>
            {
                cvt(unsafe { libc::rmdir(p.as_ptr()) }).map(|_| ())
            }

            pub fn readlink(c_path: &CStr) -> io::Result<PathBuf> 
            {
                let p = c_path.as_ptr();

                let mut buf = Vec::with_capacity(256);

                loop {
                    let buf_read =
                        cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;

                    unsafe {
                        buf.set_len(buf_read);
                    }

                    if buf_read != buf.capacity() {
                        buf.shrink_to_fit();

                        return Ok(PathBuf::from(OsString::from_vec(buf)));
                    }
                    
                    buf.reserve(1);
                }
            }

            pub fn symlink(original: &CStr, link: &CStr) -> io::Result<()>
            {
                cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) }).map(|_| ())
            }

            pub fn link(original: &CStr, link: &CStr) -> io::Result<()>
            {
                cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;
                Ok(())
            }

            pub fn stat(p: &CStr) -> io::Result<FileAttr>
            {
                let mut stat: stat64 = unsafe { mem::zeroed() };
                cvt(unsafe { stat64(p.as_ptr(), &mut stat) })?;
                Ok(FileAttr::from_stat64(stat))
            }

            pub fn lstat(p: &CStr) -> io::Result<FileAttr>
            {
                let mut stat: stat64 = unsafe { mem::zeroed() };
                cvt(unsafe { lstat64(p.as_ptr(), &mut stat) })?;
                Ok(FileAttr::from_stat64(stat))
            }

            pub fn canonicalize(path: &CStr) -> io::Result<PathBuf>
            {
                let r = unsafe { libc::realpath(path.as_ptr(), ptr::null_mut()) };
                if r.is_null() {
                    return Err(io::Error::last_os_error());
                }
                Ok(PathBuf::from(OsString::from_vec(unsafe {
                    let buf = CStr::from_ptr(r).to_bytes().to_vec();
                    libc::free(r as *mut _);
                    buf
                })))
            }

            pub fn open_from(from: &Path) -> io::Result<(::fs::File, ::fs::Metadata)>
            {
                use ::fs::File;
                use ::sys::fs::common::NOT_FILE_ERROR;

                let reader = File::open(from)?;
                let metadata = reader.metadata()?;
                if !metadata.is_file() {
                    return Err(NOT_FILE_ERROR);
                }
                Ok((reader, metadata))
            }
            
            pub fn open_to_and_set_permissions( to: &Path, reader_metadata: &::fs::Metadata ) -> 
            io::Result<(::fs::File, ::fs::Metadata)> 
            {
                use ::fs::OpenOptions;
                use ::os::unix::fs::{OpenOptionsExt, PermissionsExt};

                let perm = reader_metadata.permissions();
                let writer = OpenOptions::new()
                .mode(perm.mode())
                .write(true)
                .create(true)
                .truncate(true)
                .open(to)?;

                let writer_metadata = writer.metadata()?;
                
                if writer_metadata.is_file() {
                    writer.set_permissions(perm)?;
                }
                Ok((writer, writer_metadata))
            }

            mod cfm
            {
                use ::fs::{File, Metadata};
                use ::io::{BorrowedCursor, IoSlice, IoSliceMut, Read, Result, Write};

                #[allow(dead_code)]
                pub struct CachedFileMetadata(pub File, pub Metadata);

                impl Read for CachedFileMetadata 
                {
                    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
                        self.0.read(buf)
                    }
                    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {
                        self.0.read_vectored(bufs)
                    }
                    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> Result<()> {
                        self.0.read_buf(cursor)
                    }
                    #[inline]
                    fn is_read_vectored(&self) -> bool {
                        self.0.is_read_vectored()
                    }
                    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {
                        self.0.read_to_end(buf)
                    }
                    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {
                        self.0.read_to_string(buf)
                    }
                }

                impl Write for CachedFileMetadata 
                {
                    fn write(&mut self, buf: &[u8]) -> Result<usize> {
                        self.0.write(buf)
                    }
                    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {
                        self.0.write_vectored(bufs)
                    }
                    #[inline]
                    fn is_write_vectored(&self) -> bool {
                        self.0.is_write_vectored()
                    }
                    #[inline]
                    fn flush(&mut self) -> Result<()> {
                        self.0.flush()
                    }
                }
            }
            
            pub fn copy(from: &Path, to: &Path) -> io::Result<u64>
            {
                let (reader, reader_metadata) = open_from(from)?;
                let (writer, writer_metadata) = open_to_and_set_permissions(to, &reader_metadata)?;

                io::copy(
                    &mut cfm::CachedFileMetadata(reader, reader_metadata),
                    &mut cfm::CachedFileMetadata(writer, writer_metadata),
                )
            }
            
            pub fn chown(path: &Path, uid: u32, gid: u32) -> io::Result<()>
            {
                run_path_with_cstr(path, &|path| {
                    cvt(unsafe { libc::chown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })
                        .map(|_| ())
                })
            }

            pub fn fchown(fd: c_int, uid: u32, gid: u32) -> io::Result<()>
            {
                cvt(unsafe { libc::fchown(fd, uid as libc::uid_t, gid as libc::gid_t) })?;
                Ok(())
            }
            
            pub fn lchown(path: &Path, uid: u32, gid: u32) -> io::Result<()>
            {
                run_path_with_cstr(path, &|path| {
                    cvt(unsafe { libc::lchown(path.as_ptr(), uid as libc::uid_t, gid as libc::gid_t) })
                        .map(|_| ())
                })
            }
            
            pub fn chroot(dir: &Path) -> io::Result<()>
            {
                run_path_with_cstr(dir, &|dir| cvt(unsafe { libc::chroot(dir.as_ptr()) }).map(|_| ()))
            }
            
            pub fn mkfifo(path: &Path, mode: u32) -> io::Result<()>
            {
                run_path_with_cstr(path, &|path| {
                    cvt(unsafe { libc::mkfifo(path.as_ptr(), mode.try_into().unwrap()) }).map(|_| ())
                })
            }
            
            mod remove_dir_impl
            {
                use libc::{fdopendir, openat, unlinkat};

                use super::{Dir, DirEntry, InnerReadDir, ReadDir, lstat};
                use ::ffi::CStr;
                use ::io;
                use ::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};
                use ::os::unix::prelude::{OwnedFd, RawFd};
                use ::path::{Path, PathBuf};
                use ::sys::common::small_c_string::run_path_with_cstr;
                use ::sys::{cvt, cvt_r};
                use ::sys::common::ignore_notfound;

                pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> 
                {
                    let fd = cvt_r(|| unsafe
                    {
                        openat
                        (
                            parent_fd.unwrap_or(libc::AT_FDCWD),
                            p.as_ptr(),
                            libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,
                        )
                    })?;
                    
                    Ok(unsafe { OwnedFd::from_raw_fd(fd) })
                }

                pub fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)>
                {
                    let ptr = unsafe { fdopendir(dir_fd.as_raw_fd()) };
                    if ptr.is_null() { return Err(io::Error::last_os_error()); }
                    let dirp = Dir(ptr);
                    let new_parent_fd = dir_fd.into_raw_fd();
                    let dummy_root = PathBuf::new();
                    let inner = InnerReadDir { dirp, root: dummy_root };
                    Ok((ReadDir::new(inner), new_parent_fd))
                }
                
                pub fn is_dir(ent: &DirEntry) -> Option<bool>
                {
                    match ent.entry.d_type
                    {
                        libc::DT_UNKNOWN => None,
                        libc::DT_DIR => Some(true),
                        _ => Some(false),
                    }
                }

                pub fn is_enoent(result: &io::Result<()>) -> bool
                {
                    if let Err(err) = result && matches!(err.raw_os_error(), Some(libc::ENOENT)) { true }
                    else { false }
                }

                pub fn remove_dir_all_recursive(parent_fd: Option<RawFd>, path: &CStr) -> io::Result<()>
                {
                    unsafe
                    {
                        let fd = match openat_nofollow_dironly(parent_fd, &path)
                        {
                            Err(err) if matches!(err.raw_os_error(), Some(libc::ENOTDIR | libc::ELOOP)) =>
                            {
                                return match parent_fd
                                {
                                    Some(parent_fd) =>
                                    { cvt(unsafe { unlinkat(parent_fd, path.as_ptr(), 0) }).map(drop) }
                                    
                                    None => Err(err),
                                };
                            }

                            result => result?,
                        };
                        
                        let (dir, fd) = fdreaddir(fd)?;
                        
                        for child in dir
                        {
                            let child = child?;
                            let child_name = child.name_cstr();
                            let result: io::Result<()> = match is_dir(&child)
                            {
                                Some(true) =>
                                {
                                    remove_dir_all_recursive(Some(fd), child_name)?;
                                }
                                
                                Some(false) =>
                                {
                                    cvt(unsafe { unlinkat(fd, child_name.as_ptr(), 0) })?;
                                }
                                
                                None =>
                                {
                                    remove_dir_all_recursive(Some(fd), child_name)?;
                                }
                            };
                            if result.is_err() && !is_enoent(&result) {
                                return result;
                            }
                        }
                        
                        ignore_notfound(cvt(
                        unsafe
                        {
                            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), path.as_ptr(), libc::AT_REMOVEDIR) 
                        }))?;

                        Ok(())
                    }
                }

                pub fn remove_dir_all_modern(p: &CStr) -> io::Result<()>
                {
                    let attr = lstat(p)?;

                    if attr.file_type().is_symlink() { super::unlink(p) }
                    else { remove_dir_all_recursive(None, &p) }
                }

                pub fn remove_dir_all(p: &Path) -> io::Result<()>
                { run_path_with_cstr(p, &remove_dir_all_modern) }
            } pub use self::remove_dir_impl::remove_dir_all;
        }

        mod windows
        {
            use ::
            {
                alloc::{Layout, alloc, dealloc},
                borrow::Cow,
                ffi::{OsStr, OsString, c_void},
                io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom},
                mem::{self, MaybeUninit, offset_of},
                os::windows::io::{AsHandle, BorrowedHandle},
                os::windows::prelude::*,
                path::{Path, PathBuf},
                sync::Arc,
                sys::handle::Handle,
                sys::pal::api::{self, WinError, set_file_information_by_handle},
                sys::pal::{IoResult, fill_utf16_buf, to_u16s, truncate_utf16_at_nul},
                sys::path::{WCStr, maybe_verbatim},
                sys::time::SystemTime,
                sys::{Align8, c, cvt},
                sys::common::{AsInner, FromInner, IntoInner},
                *,
            };
            
            mod remove_dir_all
            {
                //! The Windows implementation of std::fs::remove_dir_all.
                use ::
                {
                    sync::atomic::{Atomic, AtomicU32, Ordering},
                    sys::c,
                    sys::pal::api::WinError,
                    *,
                };
                /// The maximum number of times to spin when waiting for deletes to complete.
                pub const MAX_RETRIES: usize = 50;
                /// A wrapper around a raw NtOpenFile call.
                unsafe fn nt_open_file
                ( access: u32, object_attribute: &c::OBJECT_ATTRIBUTES, share: u32, options: u32 ) 
                -> Result<File, WinError>
                {
                    unsafe
                    {
                        let mut handle = ptr::null_mut();
                        let mut io_status = c::IO_STATUS_BLOCK::PENDING;
                        let status = c::NtOpenFile
                        (
                            &mut handle, 
                            access, 
                            object_attribute, 
                            &mut io_status, 
                            share, 
                            options
                        );

                        if c::nt_success(status) { Ok(File::from_raw_handle(handle)) }
                        else
                        {
                            let win_error = if status == c::STATUS_DELETE_PENDING { WinError::DELETE_PENDING }
                            else { WinError::new(c::RtlNtStatusToDosError(status)) };
                            Err(win_error)
                        }
                    }
                }
                /// Open the file `path` in the directory `parent`, requesting the given `access` rights.
                fn open_link_no_reparse
                (
                    parent: &File,
                    path: &[u16],
                    access: u32,
                    options: u32,
                ) -> Result<Option<File>, WinError>
                {
                    unsafe
                    {
                        static ATTRIBUTES: Atomic<u32> = AtomicU32::new(c::OBJ_DONT_REPARSE);
                        let result = 
                        {
                            let mut path_str = c::UNICODE_STRING::from_ref(path);
                            let mut object = c::OBJECT_ATTRIBUTES
                            {
                                ObjectName: &mut path_str,
                                RootDirectory: parent.as_raw_handle(),
                                Attributes: ATTRIBUTES.load(Ordering::Relaxed),
                                ..c::OBJECT_ATTRIBUTES::with_length()
                            };
                            let share = c::FILE_SHARE_DELETE | c::FILE_SHARE_READ | c::FILE_SHARE_WRITE;
                            let options = c::FILE_OPEN_REPARSE_POINT | options;
                            let result = nt_open_file(access, &object, share, options);
                            
                            if matches!(result, Err(WinError::INVALID_PARAMETER))
                            && ATTRIBUTES.load(Ordering::Relaxed) == c::OBJ_DONT_REPARSE
                            {
                                ATTRIBUTES.store(0, Ordering::Relaxed);
                                object.Attributes = 0;
                                nt_open_file(access, &object, share, options)
                            } 
                            else { result }
                        };
                        
                        match result
                        {
                            Ok(f) => Ok(Some(f)),
                            Err
                            (
                                WinError::FILE_NOT_FOUND
                                | WinError::PATH_NOT_FOUND
                                | WinError::BAD_NETPATH
                                | WinError::BAD_NET_NAME
                                | WinError::DELETE_PENDING,
                            ) => Ok(None),
                            Err(e) => Err(e),
                        }
                    }
                }

                fn open_dir(parent: &File, name: &[u16]) -> Result<Option<File>, WinError>
                {
                    open_link_no_reparse
                    (
                        parent,
                        name,
                        c::SYNCHRONIZE | c::FILE_LIST_DIRECTORY,
                        c::FILE_SYNCHRONOUS_IO_NONALERT,
                    )
                }

                fn delete(parent: &File, name: &[u16]) -> Result<(), WinError>
                {
                    match open_link_no_reparse(parent, name, c::DELETE, 0)
                    {
                        Ok(Some(f)) => f.delete(),
                        Ok(None) => Ok(()),
                        Err(e) => Err(e),
                    }
                }
                /// A simple retry loop that keeps running `f` 
                /// while it fails with the given error code or until `MAX_RETRIES` is reached.
                fn retry<T: PartialEq>( mut f: impl FnMut() -> Result<T, WinError>, ignore: WinError ) -> 
                Result<T, WinError>
                {
                    let mut i = MAX_RETRIES;
                    loop
                    {
                        i -= 1;
                        if i == 0 { return f(); }
                        else
                        {
                            let result = f();
                            if result != Err(ignore) { return result; }
                        }
                        thread::yield_now();
                    }
                }

                pub fn remove_dir_all_iterative(dir: File) -> Result<(), WinError>
                {
                    let mut buffer = DirBuff::new();
                    let mut dirlist = vec![dir];
                    let mut restart = true;
                    'outer: while let Some(dir) = dirlist.pop()
                    {
                        let more_data = dir.fill_dir_buff(&mut buffer, restart)?;
                        for (name, is_directory) in buffer.iter()
                        {
                            if is_directory
                            {
                                let Some(subdir) = open_dir(&dir, &name)? else { continue };
                                dirlist.push(dir);
                                dirlist.push(subdir);
                                continue 'outer;
                            }
                            else { retry(|| delete(&dir, &name), WinError::SHARING_VIOLATION)?; }
                        }
                        
                        if more_data
                        {
                            dirlist.push(dir);
                            restart = false;
                        }

                        else
                        {
                            retry(|| delete(&dir, &[]), WinError::DIR_NOT_EMPTY)?;
                            restart = true;
                        }
                    }
                    Ok(())
                }
            } use self::remove_dir_all::remove_dir_all_iterative;

            pub struct File
            {
                handle: Handle,
            }

            #[derive(Clone)]
            pub struct FileAttr
            {
                attributes: u32,
                creation_time: c::FILETIME,
                last_access_time: c::FILETIME,
                last_write_time: c::FILETIME,
                change_time: Option<c::FILETIME>,
                file_size: u64,
                reparse_tag: u32,
                volume_serial_number: Option<u32>,
                number_of_links: Option<u32>,
                file_index: Option<u64>,
            }

            #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
            pub struct FileType
            {
                is_directory: bool,
                is_symlink: bool,
            }

            pub struct ReadDir
            {
                handle: Option<FindNextFileHandle>,
                root: Arc<PathBuf>,
                first: Option<c::WIN32_FIND_DATAW>,
            }

            struct FindNextFileHandle(c::HANDLE);

            unsafe impl Send for FindNextFileHandle {}
            unsafe impl Sync for FindNextFileHandle {}

            pub struct DirEntry
            {
                root: Arc<PathBuf>,
                data: c::WIN32_FIND_DATAW,
            }

            unsafe impl Send for OpenOptions {}
            unsafe impl Sync for OpenOptions {}

            #[derive(Clone, Debug)]
            pub struct OpenOptions
            {
                read: bool,
                write: bool,
                append: bool,
                truncate: bool,
                create: bool,
                create_new: bool,
                custom_flags: u32,
                access_mode: Option<u32>,
                attributes: u32,
                share_mode: u32,
                security_qos_flags: u32,
                security_attributes: *mut c::SECURITY_ATTRIBUTES,
            }

            #[derive(Clone, PartialEq, Eq, Debug)]
            pub struct FilePermissions
            {
                attrs: u32,
            }

            #[derive(Copy, Clone, Debug, Default)]
            pub struct FileTimes
            {
                accessed: Option<c::FILETIME>,
                modified: Option<c::FILETIME>,
                created: Option<c::FILETIME>,
            }

            impl fmt::Debug for c::FILETIME
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    let time = ((self.dwHighDateTime as u64) << 32) | self.dwLowDateTime as u64;
                    f.debug_tuple("FILETIME").field(&time).finish()
                }
            }

            #[derive( Debug )]
            pub struct DirBuilder;

            impl fmt::Debug for ReadDir
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Debug::fmt(&*self.root, f)
                }
            }

            impl Iterator for ReadDir
            {
                type Item = io::Result<DirEntry>;
                fn next(&mut self) -> Option<io::Result<DirEntry>>
                {
                    unsafe
                    {
                        let Some(handle) = self.handle.as_ref() 
                        else { return None; };

                        if let Some(first) = self.first.take()
                        {
                            if let Some(e) = DirEntry::new(&self.root, &first) { return Some(Ok(e)); }
                        }
                        
                        let mut wfd = mem::zeroed();

                        loop
                        {
                            if c::FindNextFileW(handle.0, &mut wfd) == 0
                            {
                                match api::get_last_error()
                                {
                                    WinError::NO_MORE_FILES => return None,
                                    WinError { code } => { return Some(Err(Error::from_raw_os_error(code as i32))); }
                                }
                            }
                            
                            if let Some(e) = DirEntry::new(&self.root, &wfd) { return Some(Ok(e)); }
                        }
                    }
                }
            }

            impl Drop for FindNextFileHandle
            {
                fn drop(&mut self)
                {
                    let r = unsafe { c::FindClose(self.0) };
                    debug_assert!(r != 0);
                }
            }

            impl DirEntry
            {
                fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry>
                {
                    match &wfd.cFileName[0..3]
                    {
                        &[46, 0, ..] | &[46, 46, 0, ..] => return None,
                        _ => {}
                    }

                    Some(DirEntry { root: root.clone(), data: *wfd })
                }

                pub fn path(&self) -> PathBuf { self.root.join(self.file_name()) }

                pub fn file_name(&self) -> OsString
                {
                    let filename = truncate_utf16_at_nul(&self.data.cFileName);
                    OsString::from_wide(filename)
                }

                pub fn file_type(&self) -> io::Result<FileType>
                {
                    Ok(FileType::new
                    (
                        self.data.dwFileAttributes,
                        self.data.dwReserved0,
                    ))
                }

                pub fn metadata(&self) -> io::Result<FileAttr> { Ok(self.data.into()) }
            }

            impl OpenOptions
            {
                pub fn new() -> OpenOptions
                {
                    OpenOptions
                    {
                        read: false,
                        write: false,
                        append: false,
                        truncate: false,
                        create: false,
                        create_new: false,
                        custom_flags: 0,
                        access_mode: None,
                        share_mode: c::FILE_SHARE_READ | c::FILE_SHARE_WRITE | c::FILE_SHARE_DELETE,
                        attributes: 0,
                        security_qos_flags: 0,
                        security_attributes: ptr::null_mut(),
                    }
                }

                pub fn read(&mut self, read: bool) { self.read = read; }
                pub fn write(&mut self, write: bool) { self.write = write; }
                pub fn append(&mut self, append: bool) { self.append = append; }
                pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
                pub fn create(&mut self, create: bool) { self.create = create; }
                pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }
                pub fn custom_flags(&mut self, flags: u32) { self.custom_flags = flags; }
                pub fn access_mode(&mut self, access_mode: u32) { self.access_mode = Some(access_mode); }
                pub fn share_mode(&mut self, share_mode: u32) { self.share_mode = share_mode; }
                pub fn attributes(&mut self, attrs: u32) { self.attributes = attrs; } pub fn security_qos_flags(&mut self, flags: u32) { self.security_qos_flags = flags | c::SECURITY_SQOS_PRESENT; }
                pub fn security_attributes(&mut self, attrs: *mut c::SECURITY_ATTRIBUTES) { self.security_attributes = attrs; }

                pub fn get_access_mode(&self) -> io::Result<u32>
                {
                    match (self.read, self.write, self.append, self.access_mode)
                    {
                        (.., Some(mode)) => Ok(mode),
                        (true, false, false, None) => Ok(c::GENERIC_READ),
                        (false, true, false, None) => Ok(c::GENERIC_WRITE),
                        (true, true, false, None) => Ok(c::GENERIC_READ | c::GENERIC_WRITE),
                        (false, _, true, None) => Ok(c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA),
                        
                        (true, _, true, None) => 
                        { Ok(c::GENERIC_READ | (c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA)) }

                        (false, false, false, None) =>
                        { Err(Error::from_raw_os_error(c::ERROR_INVALID_PARAMETER as i32)) }
                    }
                }

                pub fn get_creation_mode(&self) -> io::Result<u32>
                {
                    match (self.write, self.append)
                    {
                        (true, false) => {}
                        (false, false) =>
                        {
                            if self.truncate || self.create || self.create_new 
                            { return Err(Error::from_raw_os_error(c::ERROR_INVALID_PARAMETER as i32)); }
                        }
                        
                        (_, true) =>
                        {
                            if self.truncate && !self.create_new
                            { return Err(Error::from_raw_os_error(c::ERROR_INVALID_PARAMETER as i32)); }
                        }
                    }

                    Ok(match (self.create, self.truncate, self.create_new)
                    {
                        (false, false, false) => c::OPEN_EXISTING,
                        (true, false, false) => c::OPEN_ALWAYS,
                        (false, true, false) => c::TRUNCATE_EXISTING,
                        (true, true, false) => c::OPEN_ALWAYS,
                        (_, _, true) => c::CREATE_NEW,
                    })
                }

                pub fn get_flags_and_attributes(&self) -> u32
                {
                    self.custom_flags
                    | self.attributes
                    | self.security_qos_flags
                    | if self.create_new { c::FILE_FLAG_OPEN_REPARSE_POINT } 
                    else { 0 }
                }
            }

            impl File 
            {
                pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File>
                {
                    let path = maybe_verbatim(path)?;
                    let path = unsafe { WCStr::from_wchars_with_null_unchecked(&path) };
                    Self::open_native(&path, opts)
                }

                fn open_native(path: &WCStr, opts: &OpenOptions) -> io::Result<File>
                {
                    let creation = opts.get_creation_mode()?;
                    let handle = unsafe 
                    {
                        c::CreateFileW(
                            path.as_ptr(),
                            opts.get_access_mode()?,
                            opts.share_mode,
                            opts.security_attributes,
                            creation,
                            opts.get_flags_and_attributes(),
                            ptr::null_mut(),
                        )
                    };
                    let handle = unsafe { HandleOrInvalid::from_raw_handle(handle) };
                    if let Ok(handle) = OwnedHandle::try_from(handle)
                    {
                        if opts.truncate
                        && creation == c::OPEN_ALWAYS
                        && api::get_last_error() == WinError::ALREADY_EXISTS
                        {
                            let alloc = c::FILE_ALLOCATION_INFO { AllocationSize: 0 };
                            set_file_information_by_handle(handle.as_raw_handle(), &alloc)
                            .or_else(|_|
                            {
                                let eof = c::FILE_END_OF_FILE_INFO { EndOfFile: 0 };
                                set_file_information_by_handle(handle.as_raw_handle(), &eof)
                            }).io_result()?;
                        }
                        Ok(File { handle: Handle::from_inner(handle) })
                    } else { Err(Error::last_os_error()) }
                }

                pub fn fsync(&self) -> io::Result<()>
                {
                    cvt(unsafe { c::FlushFileBuffers(self.handle.as_raw_handle()) })?;
                    Ok(())
                }

                pub fn datasync(&self) -> io::Result<()> { self.fsync() }

                pub fn acquire_lock(&self, flags: c::LOCK_FILE_FLAGS) -> io::Result<()>
                {
                    unsafe
                    {
                        let mut overlapped: c::OVERLAPPED = mem::zeroed();
                        let event = c::CreateEventW(ptr::null_mut(), c::FALSE, c::FALSE, ptr::null());
                        if event.is_null() {
                            return Err(io::Error::last_os_error());
                        }
                        overlapped.hEvent = event;
                        let lock_result = cvt(c::LockFileEx(
                            self.handle.as_raw_handle(),
                            flags,
                            0,
                            u32::MAX,
                            u32::MAX,
                            &mut overlapped,
                        ));

                        let final_result = match lock_result {
                            Ok(_) => Ok(()),
                            Err(err) => {
                                if err.raw_os_error() == Some(c::ERROR_IO_PENDING as i32) {
                                    let mut bytes_transferred = 0;
                                    cvt(c::GetOverlappedResult(
                                        self.handle.as_raw_handle(),
                                        &mut overlapped,
                                        &mut bytes_transferred,
                                        c::TRUE,
                                    ))
                                    .map(|_| ())
                                } else {
                                    Err(err)
                                }
                            }
                        };
                        c::CloseHandle(overlapped.hEvent);
                        final_result
                    }
                }

                pub fn lock(&self) -> io::Result<()> { self.acquire_lock(c::LOCKFILE_EXCLUSIVE_LOCK) }

                pub fn lock_shared(&self) -> io::Result<()> { self.acquire_lock(0) }

                pub fn try_lock(&self) -> io::Result<bool>
                {
                    let result = cvt(unsafe {
                        let mut overlapped = mem::zeroed();
                        c::LockFileEx(
                            self.handle.as_raw_handle(),
                            c::LOCKFILE_EXCLUSIVE_LOCK | c::LOCKFILE_FAIL_IMMEDIATELY,
                            0,
                            u32::MAX,
                            u32::MAX,
                            &mut overlapped,
                        )
                    });

                    match result {
                        Ok(_) => Ok(true),
                        Err(err)
                            if err.raw_os_error() == Some(c::ERROR_IO_PENDING as i32)
                                || err.raw_os_error() == Some(c::ERROR_LOCK_VIOLATION as i32) =>
                        {
                            Ok(false)
                        }
                        Err(err) => Err(err),
                    }
                }

                pub fn try_lock_shared(&self) -> io::Result<bool>
                {
                    let result = cvt(unsafe {
                        let mut overlapped = mem::zeroed();
                        c::LockFileEx(
                            self.handle.as_raw_handle(),
                            c::LOCKFILE_FAIL_IMMEDIATELY,
                            0,
                            u32::MAX,
                            u32::MAX,
                            &mut overlapped,
                        )
                    });

                    match result {
                        Ok(_) => Ok(true),
                        Err(err)
                            if err.raw_os_error() == Some(c::ERROR_IO_PENDING as i32)
                                || err.raw_os_error() == Some(c::ERROR_LOCK_VIOLATION as i32) =>
                        {
                            Ok(false)
                        }
                        Err(err) => Err(err),
                    }
                }

                pub fn unlock(&self) -> io::Result<()>
                {
                    cvt(unsafe { c::UnlockFile(self.handle.as_raw_handle(), 0, 0, u32::MAX, u32::MAX) })?;
                    let result =
                        cvt(unsafe { c::UnlockFile(self.handle.as_raw_handle(), 0, 0, u32::MAX, u32::MAX) });
                    match result {
                        Ok(_) => Ok(()),
                        Err(err) if err.raw_os_error() == Some(c::ERROR_NOT_LOCKED as i32) => Ok(()),
                        Err(err) => Err(err),
                    }
                }

                pub fn truncate(&self, size: u64) -> io::Result<()>
                {
                    let info = c::FILE_END_OF_FILE_INFO { EndOfFile: size as i64 };
                    api::set_file_information_by_handle(self.handle.as_raw_handle(), &info).io_result()
                }
                
                pub fn file_attr(&self) -> io::Result<FileAttr>
                {
                    unsafe
                    {
                        let mut info: c::FILE_BASIC_INFO = mem::zeroed();
                        let size = size_of_val(&info);
                        cvt(c::GetFileInformationByHandleEx(
                            self.handle.as_raw_handle(),
                            c::FileBasicInfo,
                            (&raw mut info) as *mut c_void,
                            size as u32,
                        ))?;
                        let mut attr = FileAttr {
                            attributes: info.FileAttributes,
                            creation_time: c::FILETIME {
                                dwLowDateTime: info.CreationTime as u32,
                                dwHighDateTime: (info.CreationTime >> 32) as u32,
                            },
                            last_access_time: c::FILETIME {
                                dwLowDateTime: info.LastAccessTime as u32,
                                dwHighDateTime: (info.LastAccessTime >> 32) as u32,
                            },
                            last_write_time: c::FILETIME {
                                dwLowDateTime: info.LastWriteTime as u32,
                                dwHighDateTime: (info.LastWriteTime >> 32) as u32,
                            },
                            change_time: Some(c::FILETIME {
                                dwLowDateTime: info.ChangeTime as u32,
                                dwHighDateTime: (info.ChangeTime >> 32) as u32,
                            }),
                            file_size: 0,
                            reparse_tag: 0,
                            volume_serial_number: None,
                            number_of_links: None,
                            file_index: None,
                        };
                        let mut info: c::FILE_STANDARD_INFO = mem::zeroed();
                        let size = size_of_val(&info);
                        cvt(c::GetFileInformationByHandleEx(
                            self.handle.as_raw_handle(),
                            c::FileStandardInfo,
                            (&raw mut info) as *mut c_void,
                            size as u32,
                        ))?;
                        attr.file_size = info.AllocationSize as u64;
                        attr.number_of_links = Some(info.NumberOfLinks);
                        if attr.attributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {
                            let mut attr_tag: c::FILE_ATTRIBUTE_TAG_INFO = mem::zeroed();
                            cvt(c::GetFileInformationByHandleEx(
                                self.handle.as_raw_handle(),
                                c::FileAttributeTagInfo,
                                (&raw mut attr_tag).cast(),
                                size_of::<c::FILE_ATTRIBUTE_TAG_INFO>().try_into().unwrap(),
                            ))?;
                            if attr_tag.FileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {
                                attr.reparse_tag = attr_tag.ReparseTag;
                            }
                        }
                        Ok(attr)
                    }
                }

                pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> { self.handle.read(buf) }

                pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> { self.handle.read_vectored(bufs) }

                #[inline] pub fn is_read_vectored(&self) -> bool { self.handle.is_read_vectored() }

                pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> { self.handle.read_at(buf, offset) }

                pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> { self.handle.read_buf(cursor) }

                pub fn write(&self, buf: &[u8]) -> io::Result<usize> { self.handle.write(buf) }

                pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> { self.handle.write_vectored(bufs) }

                #[inline] pub fn is_write_vectored(&self) -> bool { self.handle.is_write_vectored() }

                pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> { self.handle.write_at(buf, offset) }

                pub fn flush(&self) -> io::Result<()> { Ok(()) }

                pub fn seek(&self, pos: SeekFrom) -> io::Result<u64>
                {
                    let (whence, pos) = match pos
                    {
                        SeekFrom::Start(n) => (c::FILE_BEGIN, n as i64),
                        SeekFrom::End(n) => (c::FILE_END, n),
                        SeekFrom::Current(n) => (c::FILE_CURRENT, n),
                    };

                    let pos = pos as i64;
                    let mut newpos = 0;
                    cvt(unsafe { c::SetFilePointerEx(self.handle.as_raw_handle(), pos, &mut newpos, whence) })?;
                    Ok(newpos as u64)
                }

                pub fn tell(&self) -> io::Result<u64> { self.seek(SeekFrom::Current(0)) }

                pub fn duplicate(&self) -> io::Result<File> { Ok(Self { handle: self.handle.try_clone()? }) }
                
                pub fn reparse_point( &self, space: &mut Align8<[MaybeUninit<u8>]> ) -> 
                io::Result<(u32, *mut c::REPARSE_DATA_BUFFER)>
                {
                    unsafe
                    {
                        let mut bytes = 0;
                        cvt({
                            let len = space.0.len();
                            c::DeviceIoControl(
                                self.handle.as_raw_handle(),
                                c::FSCTL_GET_REPARSE_POINT,
                                ptr::null_mut(),
                                0,
                                space.0.as_mut_ptr().cast(),
                                len as u32,
                                &mut bytes,
                                ptr::null_mut(),
                            )
                        })?;
                        const _: () = assert!(align_of::<c::REPARSE_DATA_BUFFER>() <= 8);
                        Ok((bytes, space.0.as_mut_ptr().cast::<c::REPARSE_DATA_BUFFER>()))
                    }
                }

                pub fn readlink(&self) -> io::Result<PathBuf>
                {
                    let mut space =
                        Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);
                    let (_bytes, buf) = self.reparse_point(&mut space)?;
                    unsafe {
                        let (path_buffer, subst_off, subst_len, relative) = match (*buf).ReparseTag {
                            c::IO_REPARSE_TAG_SYMLINK => {
                                let info: *mut c::SYMBOLIC_LINK_REPARSE_BUFFER = (&raw mut (*buf).rest).cast();
                                assert!(info.is_aligned());
                                (
                                    (&raw mut (*info).PathBuffer).cast::<u16>(),
                                    (*info).SubstituteNameOffset / 2,
                                    (*info).SubstituteNameLength / 2,
                                    (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0,
                                )
                            }
                            c::IO_REPARSE_TAG_MOUNT_POINT => {
                                let info: *mut c::MOUNT_POINT_REPARSE_BUFFER = (&raw mut (*buf).rest).cast();
                                assert!(info.is_aligned());
                                (
                                    (&raw mut (*info).PathBuffer).cast::<u16>(),
                                    (*info).SubstituteNameOffset / 2,
                                    (*info).SubstituteNameLength / 2,
                                    false,
                                )
                            }
                            _ => {
                                return Err(constant_error!(
                                    io::ErrorKind::Uncategorized,
                                    "Unsupported reparse point type",
                                ));
                            }
                        };
                        let subst_ptr = path_buffer.add(subst_off.into());
                        let subst = slice::from_raw_parts_mut(subst_ptr, subst_len as usize);
                        // Absolute paths start with an NT internal namespace prefix `\??\`
                        // We should not let it leak through.
                        if !relative && subst.starts_with(&[92u16, 63u16, 63u16, 92u16]) {
                            // Turn `\??\` into `\\?\` (a verbatim path).
                            subst[1] = b'\\' as u16;
                            // Attempt to convert to a more user-friendly path.
                            let user = crate::sys::args::from_wide_to_user_path(
                                subst.iter().copied().chain([0]).collect(),
                            )?;
                            Ok(PathBuf::from(OsString::from_wide(user.strip_suffix(&[0]).unwrap_or(&user))))
                        } else {
                            Ok(PathBuf::from(OsString::from_wide(subst)))
                        }
                    }
                }

                pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()>
                {
                    let info = c::FILE_BASIC_INFO
                    {
                        CreationTime: 0,
                        LastAccessTime: 0,
                        LastWriteTime: 0,
                        ChangeTime: 0,
                        FileAttributes: perm.attrs,
                    };
                    api::set_file_information_by_handle(self.handle.as_raw_handle(), &info).io_result()
                }

                pub fn set_times(&self, times: FileTimes) -> io::Result<()>
                {
                    let is_zero = |t: c::FILETIME| t.dwLowDateTime == 0 && t.dwHighDateTime == 0;
                    if times.accessed.map_or(false, is_zero)
                        || times.modified.map_or(false, is_zero)
                        || times.created.map_or(false, is_zero)
                    {
                        return Err(constant_error!(
                            io::ErrorKind::InvalidInput,
                            "cannot set file timestamp to 0",
                        ));
                    }
                    let is_max = |t: c::FILETIME| t.dwLowDateTime == u32::MAX && t.dwHighDateTime == u32::MAX;
                    if times.accessed.map_or(false, is_max)
                        || times.modified.map_or(false, is_max)
                        || times.created.map_or(false, is_max)
                    {
                        return Err(constant_error!(
                            io::ErrorKind::InvalidInput,
                            "cannot set file timestamp to 0xFFFF_FFFF_FFFF_FFFF",
                        ));
                    }
                    cvt(unsafe {
                        let created =
                            times.created.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());
                        let accessed =
                            times.accessed.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());
                        let modified =
                            times.modified.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());
                        c::SetFileTime(self.as_raw_handle(), created, accessed, modified)
                    })?;
                    Ok(())
                }
                /// Gets only basic file information such as attributes and file times.
                pub fn basic_info(&self) -> io::Result<c::FILE_BASIC_INFO>
                {
                    unsafe
                    {
                        let mut info: c::FILE_BASIC_INFO = mem::zeroed();
                        let size = size_of_val(&info);
                        cvt(c::GetFileInformationByHandleEx(
                            self.handle.as_raw_handle(),
                            c::FileBasicInfo,
                            (&raw mut info) as *mut c_void,
                            size as u32,
                        ))?;
                        Ok(info)
                    }
                }
                /// Deletes the file, 
                /// consuming the file handle to ensure the delete occurs as immediately as possible.
                pub fn delete(self) -> Result<(), WinError>
                {
                    match self.posix_delete()
                    {
                        Err(WinError::INVALID_PARAMETER)
                        | Err(WinError::NOT_SUPPORTED)
                        | Err(WinError::INVALID_FUNCTION) => self.win32_delete(),
                        result => result,
                    }
                }
                /// Delete using POSIX semantics.
                pub fn posix_delete(&self) -> Result<(), WinError>
                {
                    let info = c::FILE_DISPOSITION_INFO_EX
                    {
                        Flags: c::FILE_DISPOSITION_FLAG_DELETE
                        | c::FILE_DISPOSITION_FLAG_POSIX_SEMANTICS
                        | c::FILE_DISPOSITION_FLAG_IGNORE_READONLY_ATTRIBUTE,
                    };
                    api::set_file_information_by_handle(self.handle.as_raw_handle(), &info)
                }

                /// Delete a file using win32 semantics.
                fn win32_delete(&self) -> Result<(), WinError>
                {
                    let info = c::FILE_DISPOSITION_INFO { DeleteFile: true };
                    api::set_file_information_by_handle(self.handle.as_raw_handle(), &info)
                }
                /// Fill the given buffer with as many directory entries as will fit.
                fn fill_dir_buff(&self, buffer: &mut DirBuff, restart: bool) -> Result<bool, WinError>
                {
                    let class =
                        if restart { c::FileIdBothDirectoryRestartInfo } else { c::FileIdBothDirectoryInfo };

                    unsafe {
                        let result = c::GetFileInformationByHandleEx(
                            self.as_raw_handle(),
                            class,
                            buffer.as_mut_ptr().cast(),
                            buffer.capacity() as _,
                        );
                        if result == 0 {
                            let err = api::get_last_error();
                            if err.code == c::ERROR_NO_MORE_FILES { Ok(false) } else { Err(err) }
                        } else {
                            Ok(true)
                        }
                    }
                }
            }
            /// A buffer for holding directory entries.
            struct DirBuff
            {
                buffer: Box<Align8<[MaybeUninit<u8>; Self::BUFFER_SIZE]>>,
            }

            impl DirBuff
            {
                const BUFFER_SIZE: usize = 1024;
                fn new() -> Self
                {
                    Self 
                    {
                        buffer: unsafe { Box::new_uninit().assume_init() },
                    }
                }

                fn capacity(&self) -> usize { self.buffer.0.len() }

                fn as_mut_ptr(&mut self) -> *mut u8 { self.buffer.0.as_mut_ptr().cast() }
                /// Returns a `DirBuffIter`.
                fn iter(&self) -> DirBuffIter<'_> { DirBuffIter::new(self) }
            }

            impl AsRef<[MaybeUninit<u8>]> for DirBuff
            {
                fn as_ref(&self) -> &[MaybeUninit<u8>] { &self.buffer.0 }
            }
            /// An iterator over entries stored in a `DirBuff`.
            pub struct DirBuffIter<'a>
            {
                buffer: Option<&'a [MaybeUninit<u8>]>,
                cursor: usize,
            }

            impl<'a> DirBuffIter<'a>
            {
                fn new(buffer: &'a DirBuff) -> Self { Self { buffer: Some(buffer.as_ref()), cursor: 0 } }
            }
            
            impl<'a> Iterator for DirBuffIter<'a>
            {
                type Item = (Cow<'a, [u16]>, bool);
                fn next(&mut self) -> Option<Self::Item>
                {
                    let buffer = &self.buffer?[self.cursor..];
                    let (name, is_directory, next_entry) = unsafe
                    {
                        let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();
                        let next_entry = (&raw const (*info).NextEntryOffset).read_unaligned() as usize;
                        let length = (&raw const (*info).FileNameLength).read_unaligned() as usize;
                        let attrs = (&raw const (*info).FileAttributes).read_unaligned();
                        let name = from_maybe_unaligned(
                            (&raw const (*info).FileName).cast::<u16>(),
                            length / size_of::<u16>(),
                        );
                        let is_directory = (attrs & c::FILE_ATTRIBUTE_DIRECTORY) != 0;

                        (name, is_directory, next_entry)
                    };

                    if next_entry == 0 {
                        self.buffer = None
                    } else {
                        self.cursor += next_entry
                    }
                    
                    const DOT: u16 = b'.' as u16;
                    match &name[..]
                    {
                        [DOT] | [DOT, DOT] => self.next(),
                        _ => Some((name, is_directory)),
                    }
                }
            }

            unsafe fn from_maybe_unaligned<'a>(p: *const u16, len: usize) -> Cow<'a, [u16]>
            {
                unsafe
                {
                    if p.is_aligned() { Cow::Borrowed( ::slice::from_raw_parts(p, len)) }
                    else { Cow::Owned((0..len).map(|i| p.add(i).read_unaligned()).collect()) }
                }
            }

            impl AsInner<Handle> for File
            {
                #[inline] fn as_inner(&self) -> &Handle { &self.handle }
            }

            impl IntoInner<Handle> for File 
            {
                fn into_inner(self) -> Handle { self.handle }
            }

            impl FromInner<Handle> for File 
            {
                fn from_inner(handle: Handle) -> File { File { handle } }
            }

            impl AsHandle for File 
            {
                fn as_handle(&self) -> BorrowedHandle<'_> { self.as_inner().as_handle() }
            }

            impl AsRawHandle for File
            {
                fn as_raw_handle(&self) -> RawHandle { self.as_inner().as_raw_handle() }
            }

            impl IntoRawHandle for File
            {
                fn into_raw_handle(self) -> RawHandle
                {
                    self.into_inner().into_raw_handle()
                }
            }

            impl FromRawHandle for File 
            {
                unsafe fn from_raw_handle(raw_handle: RawHandle) -> Self
                {
                    unsafe
                    {
                        Self { handle: FromInner::from_inner(FromRawHandle::from_raw_handle(raw_handle)) }
                    }
                }
            }

            impl fmt::Debug for File
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    let mut b = f.debug_struct("File");
                    b.field("handle", &self.handle.as_raw_handle());
                    if let Ok(path) = get_path(self) {
                        b.field("path", &path);
                    }
                    b.finish()
                }
            }

            impl FileAttr
            {
                pub fn size(&self) -> u64 { self.file_size }
                pub fn perm(&self) -> FilePermissions { FilePermissions { attrs: self.attributes } }
                pub fn attrs(&self) -> u32 { self.attributes }
                pub fn file_type(&self) -> FileType { FileType::new(self.attributes, self.reparse_tag) }
                pub fn modified(&self) -> io::Result<SystemTime> { Ok(SystemTime::from(self.last_write_time)) }
                pub fn accessed(&self) -> io::Result<SystemTime> { Ok(SystemTime::from(self.last_access_time)) }
                pub fn created(&self) -> io::Result<SystemTime> { Ok(SystemTime::from(self.creation_time)) }
                pub fn modified_u64(&self) -> u64 { to_u64(&self.last_write_time) }
                pub fn accessed_u64(&self) -> u64 { to_u64(&self.last_access_time) }
                pub fn created_u64(&self) -> u64 { to_u64(&self.creation_time) }
                pub fn changed_u64(&self) -> Option<u64> { self.change_time.as_ref().map(|c| to_u64(c)) }
                pub fn volume_serial_number(&self) -> Option<u32> { self.volume_serial_number }
                pub fn number_of_links(&self) -> Option<u32> { self.number_of_links }
                pub fn file_index(&self) -> Option<u64> { self.file_index }            
            }

            impl From<c::WIN32_FIND_DATAW> for FileAttr
            {
                fn from(wfd: c::WIN32_FIND_DATAW) -> Self
                {
                    FileAttr
                    {
                        attributes: wfd.dwFileAttributes,
                        creation_time: wfd.ftCreationTime,
                        last_access_time: wfd.ftLastAccessTime,
                        last_write_time: wfd.ftLastWriteTime,
                        change_time: None,
                        file_size: ((wfd.nFileSizeHigh as u64) << 32) | (wfd.nFileSizeLow as u64),
                        reparse_tag: if wfd.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 
                        {
                            wfd.dwReserved0
                        } else {
                            0
                        },
                        volume_serial_number: None,
                        number_of_links: None,
                        file_index: None,
                    }
                }
            }

            pub fn to_u64(ft: &c::FILETIME) -> u64 
            { (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32) }

            impl FilePermissions
            {
                pub fn readonly(&self) -> bool { self.attrs & c::FILE_ATTRIBUTE_READONLY != 0 }

                pub fn set_readonly(&mut self, readonly: bool)
                {
                    if readonly { self.attrs |= c::FILE_ATTRIBUTE_READONLY; }
                    else { self.attrs &= !c::FILE_ATTRIBUTE_READONLY; }
                }
            }

            impl FileTimes
            {
                pub fn set_accessed(&mut self, t: SystemTime) { self.accessed = Some(t.into_inner()); }
                pub fn set_modified(&mut self, t: SystemTime) { self.modified = Some(t.into_inner()); }
                pub fn set_created(&mut self, t: SystemTime) { self.created = Some(t.into_inner()); }
            }

            impl FileType
            {
                fn new(attributes: u32, reparse_tag: u32) -> FileType
                {
                    let is_directory = attributes & c::FILE_ATTRIBUTE_DIRECTORY != 0;
                    let is_symlink =
                    {
                        let is_reparse_point = attributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0;
                        let is_reparse_tag_name_surrogate = reparse_tag & 0x20000000 != 0;
                        is_reparse_point && is_reparse_tag_name_surrogate
                    };
                    FileType { is_directory, is_symlink }
                }
                pub fn is_dir(&self) -> bool { !self.is_symlink && self.is_directory }
                pub fn is_file(&self) -> bool { !self.is_symlink && !self.is_directory }
                pub fn is_symlink(&self) -> bool { self.is_symlink }
                pub fn is_symlink_dir(&self) -> bool { self.is_symlink && self.is_directory }
                pub fn is_symlink_file(&self) -> bool { self.is_symlink && !self.is_directory }
            }

            impl DirBuilder
            {
                pub fn new() -> DirBuilder { DirBuilder }

                pub fn mkdir(&self, p: &Path) -> io::Result<()>
                {
                    let p = maybe_verbatim(p)?;
                    cvt(unsafe { c::CreateDirectoryW(p.as_ptr(), ptr::null_mut()) })?;
                    Ok(())
                }
            }

            pub fn readdir(p: &Path) -> io::Result<ReadDir>
            {
                unsafe
                {
                    if p.as_os_str().is_empty()
                    { return Err(io::Error::from_raw_os_error(c::ERROR_PATH_NOT_FOUND as i32)); }

                    let root = p.to_path_buf();
                    let star = p.join("*");
                    let path = maybe_verbatim(&star)?;
                    let mut wfd: c::WIN32_FIND_DATAW = mem::zeroed();
                    let find_handle = c::FindFirstFileExW
                    (
                        path.as_ptr(),
                        c::FindExInfoBasic,
                        &mut wfd as *mut _ as _,
                        c::FindExSearchNameMatch,
                        ptr::null(),
                        0,
                    );

                    if find_handle != c::INVALID_HANDLE_VALUE
                    {
                        Ok(ReadDir
                        {
                            handle: Some(FindNextFileHandle(find_handle)),
                            root: Arc::new(root),
                            first: Some(wfd),
                        })
                    }
                    else 
                    {
                        let last_error = api::get_last_error();
                        if last_error == WinError::FILE_NOT_FOUND {
                            return Ok(ReadDir { handle: None, root: Arc::new(root), first: None });
                        }
                        
                        Err(Error::from_raw_os_error(last_error.code as i32))
                    }
                }
            }

            pub fn unlink(path: &WCStr) -> io::Result<()>
            {
                if unsafe { c::DeleteFileW(path.as_ptr()) } == 0
                {
                    let err = api::get_last_error();
                    if err == WinError::ACCESS_DENIED {
                        let mut opts = OpenOptions::new();
                        opts.access_mode(c::DELETE);
                        opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT);
                        if let Ok(f) = File::open_native(&path, &opts) {
                            if f.posix_delete().is_ok() {
                                return Ok(());
                            }
                        }
                    }
                    Err(io::Error::from_raw_os_error(err.code as i32))
                } else {
                    Ok(())
                }
            }

            pub fn rename(old: &WCStr, new: &WCStr) -> io::Result<()>
            {
                if unsafe { c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING) } == 0
                {
                    let err = api::get_last_error();
                    
                    if err == WinError::ACCESS_DENIED
                    {
                        let mut opts = OpenOptions::new();
                        opts.access_mode(c::DELETE);
                        opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);
                        let Ok(f) = File::open_native(&old, &opts) else { return Err(err).io_result() };
                        
                        let Ok(new_len_without_nul_in_bytes): Result<u32, _> =
                            ((new.count_bytes() - 1) * 2).try_into()
                        else {
                            return Err(err).io_result();
                        };
                        let offset: u32 = offset_of!(c::FILE_RENAME_INFO, FileName).try_into().unwrap();
                        let struct_size = offset + new_len_without_nul_in_bytes + 2;
                        let layout = Layout::from_size_align(struct_size as usize, align_of::<c::FILE_RENAME_INFO>())
                        .unwrap();
                                
                        let file_rename_info;
                        unsafe {
                            file_rename_info = alloc(layout).cast::<c::FILE_RENAME_INFO>();
                            if file_rename_info.is_null() {
                                return Err(io::ErrorKind::OutOfMemory.into());
                            }

                            (&raw mut (*file_rename_info).Anonymous).write(c::FILE_RENAME_INFO_0 {
                                Flags: c::FILE_RENAME_FLAG_REPLACE_IF_EXISTS
                                    | c::FILE_RENAME_FLAG_POSIX_SEMANTICS,
                            });

                            (&raw mut (*file_rename_info).RootDirectory).write(ptr::null_mut());
                            (&raw mut (*file_rename_info).FileNameLength).write(new_len_without_nul_in_bytes);

                            new.as_ptr().copy_to_nonoverlapping(
                                (&raw mut (*file_rename_info).FileName).cast::<u16>(),
                                new.count_bytes(),
                            );
                        }

                        let result = unsafe {
                            c::SetFileInformationByHandle(
                                f.as_raw_handle(),
                                c::FileRenameInfoEx,
                                file_rename_info.cast::<c_void>(),
                                struct_size,
                            )
                        };
                        unsafe { dealloc(file_rename_info.cast::<u8>(), layout) };
                        if result == 0 {
                            if api::get_last_error() == WinError::DIR_NOT_EMPTY {
                                return Err(WinError::DIR_NOT_EMPTY).io_result();
                            } else {
                                return Err(err).io_result();
                            }
                        }
                    } else {
                        return Err(err).io_result();
                    }
                }
                Ok(())
            }

            pub fn rmdir(p: &WCStr) -> io::Result<()>
            {
                cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) })?;
                Ok(())
            }

            pub fn remove_dir_all(path: &WCStr) -> io::Result<()>
            {
                let mut opts = OpenOptions::new();
                opts.access_mode(c::FILE_LIST_DIRECTORY);
                opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);
                let file = File::open_native(path, &opts)?;
                
                if (file.basic_info()?.FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) == 0
                { return Err(io::Error::from_raw_os_error(c::ERROR_DIRECTORY as _)); }
                
                remove_dir_all_iterative(file).io_result()
            }

            pub fn readlink(path: &WCStr) -> io::Result<PathBuf>
            {
                let mut opts = OpenOptions::new();
                opts.access_mode(0);
                opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);
                let file = File::open_native(&path, &opts)?;
                file.readlink()
            }

            pub fn symlink(original: &Path, link: &Path) -> io::Result<()> { symlink_inner(original, link, false) }

            pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()>
            {
                let original = to_u16s(original)?;
                let link = maybe_verbatim(link)?;
                let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };
                
                let result = cvt(unsafe
                {
                    c::CreateSymbolicLinkW(
                        link.as_ptr(),
                        original.as_ptr(),
                        flags | c::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,
                    ) as c::BOOL
                });

                if let Err(err) = result
                {
                    if err.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32)
                    {
                        cvt(unsafe {
                            c::CreateSymbolicLinkW(link.as_ptr(), original.as_ptr(), flags) as c::BOOL
                        })?;
                    } else {
                        return Err(err);
                    }
                }

                Ok(())
            }
            
            pub fn link(original: &WCStr, link: &WCStr) -> io::Result<()>
            {
                cvt(unsafe { c::CreateHardLinkW(link.as_ptr(), original.as_ptr(), ptr::null_mut()) })?;
                Ok(())
            }

            pub fn stat(path: &WCStr) -> io::Result<FileAttr>
            {
                match metadata(path, ReparsePoint::Follow)
                {
                    Err(err) if err.raw_os_error() == Some(c::ERROR_CANT_ACCESS_FILE as i32) => {
                        if let Ok(attrs) = lstat(path) {
                            if !attrs.file_type().is_symlink() {
                                return Ok(attrs);
                            }
                        }
                        Err(err)
                    }
                    result => result,
                }
            }

            pub fn lstat(path: &WCStr) -> io::Result<FileAttr> { metadata(path, ReparsePoint::Open) }

            #[repr(u32)] #[derive(Clone, Copy, PartialEq, Eq)]
            pub enum ReparsePoint
            {
                Follow = 0,
                Open = c::FILE_FLAG_OPEN_REPARSE_POINT,
            }

            impl ReparsePoint
            {
                fn as_flag(self) -> u32 { self as u32 }
            }

            pub fn metadata(path: &WCStr, reparse: ReparsePoint) -> io::Result<FileAttr>
            {
                let mut opts = OpenOptions::new();
                opts.access_mode(0);
                opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | reparse.as_flag());
                
                match File::open_native(&path, &opts)
                {
                    Ok(file) => file.file_attr(),
                    Err(e) if 
                    [
                        Some(c::ERROR_SHARING_VIOLATION as _), 
                        Some(c::ERROR_ACCESS_DENIED as _)
                    ].contains(&e.raw_os_error()) =>
                    {
                        unsafe {
                            let mut wfd: c::WIN32_FIND_DATAW = mem::zeroed();
                            let handle = c::FindFirstFileExW(
                                path.as_ptr(),
                                c::FindExInfoBasic,
                                &mut wfd as *mut _ as _,
                                c::FindExSearchNameMatch,
                                ptr::null(),
                                0,
                            );

                            if handle == c::INVALID_HANDLE_VALUE
                            {
                                Err(e)
                            }
                            
                            else
                            {
                                c::FindClose(handle);
                                
                                let attrs = FileAttr::from(wfd);
                                if reparse == ReparsePoint::Follow && attrs.file_type().is_symlink() {
                                    Err(e)
                                } else {
                                    Ok(attrs)
                                }
                            }
                        }
                    }
                    Err(e) => Err(e),
                }
            }

            pub fn set_perm(p: &WCStr, perm: FilePermissions) -> io::Result<()>
            {
                unsafe {
                    cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs))?;
                    Ok(())
                }
            }

            pub fn get_path(f: &File) -> io::Result<PathBuf> 
            {
                fill_utf16_buf(
                    |buf, sz| unsafe {
                        c::GetFinalPathNameByHandleW(f.handle.as_raw_handle(), buf, sz, c::VOLUME_NAME_DOS)
                    },
                    |buf| PathBuf::from(OsString::from_wide(buf)),
                )
            }

            pub fn canonicalize(p: &WCStr) -> io::Result<PathBuf>
            {
                let mut opts = OpenOptions::new();
                opts.access_mode(0);
                opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);
                let f = File::open_native(p, &opts)?;
                get_path(&f)
            }

            pub fn copy(from: &WCStr, to: &WCStr) -> io::Result<u64>
            {
                unsafe extern "system" fn callback(
                    _TotalFileSize: i64,
                    _TotalBytesTransferred: i64,
                    _StreamSize: i64,
                    StreamBytesTransferred: i64,
                    dwStreamNumber: u32,
                    _dwCallbackReason: u32,
                    _hSourceFile: c::HANDLE,
                    _hDestinationFile: c::HANDLE,
                    lpData: *const c_void,
                ) -> u32 {
                    unsafe {
                        if dwStreamNumber == 1 {
                            *(lpData as *mut i64) = StreamBytesTransferred;
                        }
                        c::PROGRESS_CONTINUE
                    }
                }
                let mut size = 0i64;
                cvt(unsafe {
                    c::CopyFileExW(
                        from.as_ptr(),
                        to.as_ptr(),
                        Some(callback),
                        (&raw mut size) as *mut _,
                        ptr::null_mut(),
                        0,
                    )
                })?;
                Ok(size as u64)
            }
        }

        mod uefi
        {
            
            use ::
            {
                ffi::OsString,
                hash::Hash,
                io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom},
                path::{Path, PathBuf},
                sys::time::SystemTime,
                sys::unsupported,
                *,
            };
            
            pub mod protocols
            {
                use ::
                {
                    *,
                };
                pub mod base
                {
                    //! UEFI Base Environment
                    use ::
                    {
                        *,
                    };

                    #[macro_export] macro_rules! eficall_abi
                    {
                        (($($prefix:tt)*),($($suffix:tt)*)) => { $($prefix)* extern "efiapi" $($suffix)* };
                    }
                    /// Annotate function with UEFI calling convention.
                    #[macro_export] macro_rules! eficall
                    {
                        (@munch(($($prefix:tt)*),(pub $($suffix:tt)*))) => { eficall!{@munch(($($prefix)* pub),($($suffix)*))} };
                        (@munch(($($prefix:tt)*),(unsafe $($suffix:tt)*))) => { eficall!{@munch(($($prefix)* unsafe),($($suffix)*))} };
                        (@munch(($($prefix:tt)*),($($suffix:tt)*))) => { eficall_abi!{($($prefix)*),($($suffix)*)} };
                        ($($arg:tt)*) => { eficall!{@munch((),($($arg)*))} };
                    }
                    /// Boolean Type.
                    #[repr( C )] #[derive(Clone, Copy, Debug)]
                    pub struct Boolean(u8);
                    /// Single-byte Character Type.
                    pub type Char8 = u8;
                    /// Dual-byte Character Type.
                    pub type Char16 = u16;
                    /// Status Codes.
                    #[repr( C )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
                    pub struct Status(usize);
                    /// Object Handles.
                    pub type Handle = *mut ::ffi::c_void;
                    /// Event Objects.
                    pub type Event = *mut ::ffi::c_void;
                    /// Logical Block Addresses.
                    pub type Lba = u64;
                    /// Thread Priority Levels.
                    pub type Tpl = usize;
                    /// Physical Memory Address.
                    pub type PhysicalAddress = u64;
                    /// Virtual Memory Address.
                    pub type VirtualAddress = u64;
                    /// Application Entry Point.
                    pub type ImageEntryPoint = eficall! {fn(Handle, *mut crate::system::SystemTable) -> Status};
                    /// Globally Unique Identifiers.
                    #[repr( C, align(4) )]
                    #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
                    pub struct Guid
                    {
                        time_low: [u8; 4],
                        time_mid: [u8; 2],
                        time_hi_and_version: [u8; 2],
                        clk_seq_hi_res: u8,
                        clk_seq_low: u8,
                        node: [u8; 6],
                    }
                    /// Network MAC Address.
                    #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
                    pub struct MacAddress
                    {
                        pub addr: [u8; 32],
                    }
                    /// IPv4 Address.
                    #[repr( C )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
                    pub struct Ipv4Address
                    {
                        pub addr: [u8; 4],
                    }
                    /// IPv6 Address.
                    #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
                    pub struct Ipv6Address
                    {
                        pub addr: [u8; 16],
                    }
                    /// IP Address.
                    #[repr(C, align(4))] #[derive( Clone, Copy )]
                    pub union IpAddress
                    {
                        pub addr: [u32; 4],
                        pub v4: Ipv4Address,
                        pub v6: Ipv6Address,
                    }

                    impl Boolean
                    {
                        /// Literal False
                        pub const FALSE: Boolean = Boolean(0u8);
                        /// Literal True
                        pub const TRUE: Boolean = Boolean(1u8);
                    }

                    impl From<u8> for Boolean
                    {
                        fn from(v: u8) -> Self { Boolean(v) }
                    }

                    impl From<bool> for Boolean
                    {
                        fn from(v: bool) -> Self
                        {
                            match v
                            {
                                false => Boolean::FALSE,
                                true => Boolean::TRUE,
                            }
                        }
                    }

                    impl Default for Boolean
                    {
                        fn default() -> Self { Self::FALSE }
                    }

                    impl From<Boolean> for u8
                    {
                        fn from(v: Boolean) -> Self
                        {
                            match v.0
                            {
                                0 => 0,
                                _ => 1,
                            }
                        }
                    }

                    impl From<Boolean> for bool
                    {
                        fn from(v: Boolean) -> Self
                        {
                            match v.0
                            {
                                0 => false,
                                _ => true,
                            }
                        }
                    }

                    impl Eq for Boolean {}

                    impl ::hash::Hash for Boolean
                    {
                        fn hash<H: ::hash::Hasher>(&self, state: &mut H) { bool::from(*self).hash(state) }
                    }

                    impl Ord for Boolean
                    {
                        fn cmp(&self, other: &Boolean) -> ::cmp::Ordering { bool::from(*self).cmp(&(*other).into()) }
                    }

                    impl PartialEq for Boolean
                    {
                        fn eq(&self, other: &Boolean) -> bool { bool::from(*self).eq(&(*other).into()) }
                    }

                    impl PartialEq<bool> for Boolean
                    {
                        fn eq(&self, other: &bool) -> bool { bool::from(*self).eq(other) }
                    }

                    impl PartialOrd for Boolean
                    {
                        fn partial_cmp(&self, other: &Boolean) -> Option<::cmp::Ordering>
                        { bool::from(*self).partial_cmp(&(*other).into()) }
                    }

                    impl PartialOrd<bool> for Boolean
                    {
                        fn partial_cmp(&self, other: &bool) -> Option<::cmp::Ordering>
                        { bool::from(*self).partial_cmp(other) }
                    }

                    impl Status
                    {
                        pub const WIDTH: usize = 8usize * ::mem::size_of::<Status>();
                        pub const MASK: usize = 0xc0 << (Status::WIDTH - 8);
                        pub const ERROR_MASK: usize = 0x80 << (Status::WIDTH - 8);
                        pub const WARNING_MASK: usize = 0x00 << (Status::WIDTH - 8);

                        /// Success Code.
                        pub const SUCCESS: Status = Status::from_usize(0);
                        /// List of predefined error codes.
                        pub const LOAD_ERROR: Status = Status::from_usize(1 | Status::ERROR_MASK);
                        pub const INVALID_PARAMETER: Status = Status::from_usize(2 | Status::ERROR_MASK);
                        pub const UNSUPPORTED: Status = Status::from_usize(3 | Status::ERROR_MASK);
                        pub const BAD_BUFFER_SIZE: Status = Status::from_usize(4 | Status::ERROR_MASK);
                        pub const BUFFER_TOO_SMALL: Status = Status::from_usize(5 | Status::ERROR_MASK);
                        pub const NOT_READY: Status = Status::from_usize(6 | Status::ERROR_MASK);
                        pub const DEVICE_ERROR: Status = Status::from_usize(7 | Status::ERROR_MASK);
                        pub const WRITE_PROTECTED: Status = Status::from_usize(8 | Status::ERROR_MASK);
                        pub const OUT_OF_RESOURCES: Status = Status::from_usize(9 | Status::ERROR_MASK);
                        pub const VOLUME_CORRUPTED: Status = Status::from_usize(10 | Status::ERROR_MASK);
                        pub const VOLUME_FULL: Status = Status::from_usize(11 | Status::ERROR_MASK);
                        pub const NO_MEDIA: Status = Status::from_usize(12 | Status::ERROR_MASK);
                        pub const MEDIA_CHANGED: Status = Status::from_usize(13 | Status::ERROR_MASK);
                        pub const NOT_FOUND: Status = Status::from_usize(14 | Status::ERROR_MASK);
                        pub const ACCESS_DENIED: Status = Status::from_usize(15 | Status::ERROR_MASK);
                        pub const NO_RESPONSE: Status = Status::from_usize(16 | Status::ERROR_MASK);
                        pub const NO_MAPPING: Status = Status::from_usize(17 | Status::ERROR_MASK);
                        pub const TIMEOUT: Status = Status::from_usize(18 | Status::ERROR_MASK);
                        pub const NOT_STARTED: Status = Status::from_usize(19 | Status::ERROR_MASK);
                        pub const ALREADY_STARTED: Status = Status::from_usize(20 | Status::ERROR_MASK);
                        pub const ABORTED: Status = Status::from_usize(21 | Status::ERROR_MASK);
                        pub const ICMP_ERROR: Status = Status::from_usize(22 | Status::ERROR_MASK);
                        pub const TFTP_ERROR: Status = Status::from_usize(23 | Status::ERROR_MASK);
                        pub const PROTOCOL_ERROR: Status = Status::from_usize(24 | Status::ERROR_MASK);
                        pub const INCOMPATIBLE_VERSION: Status = Status::from_usize(25 | Status::ERROR_MASK);
                        pub const SECURITY_VIOLATION: Status = Status::from_usize(26 | Status::ERROR_MASK);
                        pub const CRC_ERROR: Status = Status::from_usize(27 | Status::ERROR_MASK);
                        pub const END_OF_MEDIA: Status = Status::from_usize(28 | Status::ERROR_MASK);
                        pub const END_OF_FILE: Status = Status::from_usize(31 | Status::ERROR_MASK);
                        pub const INVALID_LANGUAGE: Status = Status::from_usize(32 | Status::ERROR_MASK);
                        pub const COMPROMISED_DATA: Status = Status::from_usize(33 | Status::ERROR_MASK);
                        pub const IP_ADDRESS_CONFLICT: Status = Status::from_usize(34 | Status::ERROR_MASK);
                        pub const HTTP_ERROR: Status = Status::from_usize(35 | Status::ERROR_MASK);
                        /// Error Codes | UDP4
                        pub const NETWORK_UNREACHABLE: Status = Status::from_usize(100 | Status::ERROR_MASK);
                        pub const HOST_UNREACHABLE: Status = Status::from_usize(101 | Status::ERROR_MASK);
                        pub const PROTOCOL_UNREACHABLE: Status = Status::from_usize(102 | Status::ERROR_MASK);
                        pub const PORT_UNREACHABLE: Status = Status::from_usize(103 | Status::ERROR_MASK);
                        /// Error Codes |  TCP4
                        pub const CONNECTION_FIN: Status = Status::from_usize(104 | Status::ERROR_MASK);
                        pub const CONNECTION_RESET: Status = Status::from_usize(105 | Status::ERROR_MASK);
                        pub const CONNECTION_REFUSED: Status = Status::from_usize(106 | Status::ERROR_MASK);
                        ///  Error Codes | Various
                        pub const WARN_UNKNOWN_GLYPH: Status = Status::from_usize(1 | Status::WARNING_MASK);
                        pub const WARN_DELETE_FAILURE: Status = Status::from_usize(2 | Status::WARNING_MASK);
                        pub const WARN_WRITE_FAILURE: Status = Status::from_usize(3 | Status::WARNING_MASK);
                        pub const WARN_BUFFER_TOO_SMALL: Status = Status::from_usize(4 | Status::WARNING_MASK);
                        pub const WARN_STALE_DATA: Status = Status::from_usize(5 | Status::WARNING_MASK);
                        pub const WARN_FILE_SYSTEM: Status = Status::from_usize(6 | Status::WARNING_MASK);
                        pub const WARN_RESET_REQUIRED: Status = Status::from_usize(7 | Status::WARNING_MASK);
                        /// Create Status Code from Integer.
                        pub const fn from_usize(v: usize) -> Status { Status(v) }
                        /// Return Underlying Integer Representation.
                        pub const fn as_usize(&self) -> usize { self.0 }

                        pub fn value(&self) -> usize { self.0 }

                        pub fn mask(&self) -> usize { self.value() & Status::MASK }
                        /// Check whether this is an error.
                        pub fn is_error(&self) -> bool { self.mask() == Status::ERROR_MASK }
                        /// Check whether this is a warning.
                        pub fn is_warning(&self) -> bool { self.value() != 0 && self.mask() == Status::WARNING_MASK }
                    }

                    impl From<Status> for Result<Status, Status>
                    {
                        fn from(status: Status) -> Self
                        {
                            if status.is_error() { Err(status) }
                            else { Ok(status) }
                        }
                    }

                    impl Guid
                    {
                        pub const fn u32_to_bytes_le(num: u32) -> [u8; 4]
                        {
                            [
                                num as u8,
                                (num >> 8) as u8,
                                (num >> 16) as u8,
                                (num >> 24) as u8,
                            ]
                        }

                        pub const fn u32_from_bytes_le(bytes: &[u8; 4]) -> u32
                        {
                            (bytes[0] as u32)
                            | ((bytes[1] as u32) << 8)
                            | ((bytes[2] as u32) << 16)
                            | ((bytes[3] as u32) << 24)
                        }

                        pub const fn u16_to_bytes_le(num: u16) -> [u8; 2]
                        {
                            [num as u8, (num >> 8) as u8]
                        }

                        pub const fn u16_from_bytes_le(bytes: &[u8; 2]) -> u16
                        {
                            (bytes[0] as u16) | ((bytes[1] as u16) << 8)
                        }

                        /// Initialize a Guid from its individual fields.
                        pub const fn from_fields
                        (
                            time_low: u32,
                            time_mid: u16,
                            time_hi_and_version: u16,
                            clk_seq_hi_res: u8,
                            clk_seq_low: u8,
                            node: &[u8; 6],
                        ) -> Guid
                        {
                            Guid
                            {
                                time_low: Self::u32_to_bytes_le(time_low),
                                time_mid: Self::u16_to_bytes_le(time_mid),
                                time_hi_and_version: Self::u16_to_bytes_le(time_hi_and_version),
                                clk_seq_hi_res: clk_seq_hi_res,
                                clk_seq_low: clk_seq_low,
                                node: *node,
                            }
                        }
                        /// Access a Guid as individual fields.
                        pub const fn as_fields(&self) -> (u32, u16, u16, u8, u8, &[u8; 6])
                        {
                            (
                                Self::u32_from_bytes_le(&self.time_low),
                                Self::u16_from_bytes_le(&self.time_mid),
                                Self::u16_from_bytes_le(&self.time_hi_and_version),
                                self.clk_seq_hi_res,
                                self.clk_seq_low,
                                &self.node,
                            )
                        }
                        /// Initialize a Guid from its byte representation.
                        pub const fn from_bytes(bytes: &[u8; 16]) -> Self
                        { unsafe { ::mem::transmute::<[u8; 16], Guid>(*bytes) } }
                        /// Access a Guid as raw byte array.
                        pub const fn as_bytes(&self) -> &[u8; 16]
                        { unsafe { ::mem::transmute::<&Guid, &[u8; 16]>(self) } }
                    }
                }

                pub mod system
                {
                    //! UEFI System Integration
                    use ::
                    {
                        *,
                    };

                    pub const TIME_ADJUST_DAYLIGHT: u8 = 0x01u8;
                    pub const TIME_IN_DAYLIGHT: u8 = 0x02u8;
                    pub const UNSPECIFIED_TIMEZONE: i16 = 0x07ffi16;
                    
                    #[repr( C )] #[derive( Clone, Copy, Debug, Default )]
                    pub struct Time
                    {
                        pub year: u16,
                        pub month: u8,
                        pub day: u8,
                        pub hour: u8,
                        pub minute: u8,
                        pub second: u8,
                        pub pad1: u8,
                        pub nanosecond: u32,
                        pub timezone: i16,
                        pub daylight: u8,
                        pub pad2: u8,
                    }
                }

                pub mod file
                {
                    //! File Protocol
                    use ::
                    {
                        *,
                    };
                    pub const REVISION: u64 = 0x0000_0000_0001_0000u64;
                    pub const REVISION2: u64 = 0x0000_0000_0002_0000u64;
                    pub const LATEST_REVISION: u64 = REVISION2;

                    pub const MODE_READ: u64 = 0x0000000000000001u64;
                    pub const MODE_WRITE: u64 = 0x0000000000000002u64;
                    pub const MODE_CREATE: u64 = 0x8000000000000000u64;

                    pub const READ_ONLY: u64 = 0x0000000000000001u64;
                    pub const HIDDEN: u64 = 0x0000000000000002u64;
                    pub const SYSTEM: u64 = 0x0000000000000004u64;
                    pub const RESERVED: u64 = 0x0000000000000008u64;
                    pub const DIRECTORY: u64 = 0x0000000000000010u64;
                    pub const ARCHIVE: u64 = 0x0000000000000020u64;
                    pub const VALID_ATTR: u64 = 0x0000000000000037u64;

                    pub const INFO_ID: super::base::Guid = super::base::Guid::from_fields
                    (
                        0x09576e92,
                        0x6d3f,
                        0x11d2,
                        0x8e,
                        0x39,
                        &[0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b],
                    );

                    pub const SYSTEM_INFO_ID: super::base::Guid = super::base::Guid::from_fields
                    (
                        0x09576e93,
                        0x6d3f,
                        0x11d2,
                        0x8e,
                        0x39,
                        &[0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b],
                    );

                    pub const SYSTEM_VOLUME_LABEL_ID: super::base::Guid = super::base::Guid::from_fields
                    (
                        0xdb47d7d3,
                        0xfe81,
                        0x11d3,
                        0x9a,
                        0x35,
                        &[0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d],
                    );

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct IoToken
                    {
                        pub event: super::base::Event,
                        pub status: super::base::Status,
                        pub buffer_size: usize,
                        pub buffer: *mut ::ffi::c_void,
                    }

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct Info<const N: usize = 0> 
                    {
                        pub size: u64,
                        pub file_size: u64,
                        pub physical_size: u64,
                        pub create_time: super::system::Time,
                        pub last_access_time: super::system::Time,
                        pub modification_time: super::system::Time,
                        pub attribute: u64,
                        pub file_name: [super::base::Char16; N],
                    }

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct SystemInfo<const N: usize = 0>
                    {
                        pub size: u64,
                        pub read_only: super::base::Boolean,
                        pub volume_size: u64,
                        pub free_space: u64,
                        pub block_size: u32,
                        pub volume_label: [super::base::Char16; N],
                    }

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct SystemVolumeLabel<const N: usize = 0>
                    {
                        pub volume_label: [super::base::Char16; N],
                    }

                    pub type ProtocolOpen = eficall! {fn
                    (
                        *mut Protocol,
                        *mut *mut Protocol,
                        *mut super::base::Char16,
                        u64,
                        u64,
                    ) -> super::base::Status};

                    pub type ProtocolClose = eficall! {fn
                    (
                        *mut Protocol,
                    ) -> super::base::Status};

                    pub type ProtocolDelete = eficall! {fn
                    (
                        *mut Protocol,
                    ) -> super::base::Status};

                    pub type ProtocolRead = eficall! {fn
                    (
                        *mut Protocol,
                        *mut usize,
                        *mut ::ffi::c_void,
                    ) -> super::base::Status};

                    pub type ProtocolWrite = eficall! {fn
                    (
                        *mut Protocol,
                        *mut usize,
                        *mut ::ffi::c_void,
                    ) -> super::base::Status};

                    pub type ProtocolGetPosition = eficall! {fn
                    (
                        *mut Protocol,
                        *mut u64,
                    ) -> super::base::Status};

                    pub type ProtocolSetPosition = eficall! {fn
                    (
                        *mut Protocol,
                        u64,
                    ) -> super::base::Status};

                    pub type ProtocolGetInfo = eficall! {fn
                    (
                        *mut Protocol,
                        *mut super::base::Guid,
                        *mut usize,
                        *mut ::ffi::c_void,
                    ) -> super::base::Status};

                    pub type ProtocolSetInfo = eficall! {fn
                    (
                        *mut Protocol,
                        *mut super::base::Guid,
                        usize,
                        *mut ::ffi::c_void,
                    ) -> super::base::Status};

                    pub type ProtocolFlush = eficall! {fn( *mut Protocol ) -> super::base::Status};

                    pub type ProtocolOpenEx = eficall! {fn
                    (
                        *mut Protocol,
                        *mut *mut Protocol,
                        *mut super::base::Char16,
                        u64,
                        u64,
                        *mut IoToken
                    ) -> super::base::Status};

                    pub type ProtocolReadEx = eficall! {fn( *mut Protocol, *mut IoToken ) -> super::base::Status};

                    pub type ProtocolWriteEx = eficall! {fn( *mut Protocol, *mut IoToken ) -> super::base::Status};

                    pub type ProtocolFlushEx = eficall! {fn( *mut Protocol, *mut IoToken ) -> super::base::Status};

                    #[repr( C )] pub struct Protocol
                    {
                        pub revision: u64,
                        pub open: ProtocolOpen,
                        pub close: ProtocolClose,
                        pub delete: ProtocolDelete,
                        pub read: ProtocolRead,
                        pub write: ProtocolWrite,
                        pub get_position: ProtocolGetPosition,
                        pub set_position: ProtocolSetPosition,
                        pub get_info: ProtocolGetInfo,
                        pub set_info: ProtocolSetInfo,
                        pub flush: ProtocolFlush,
                        pub open_ex: ProtocolOpenEx,
                        pub read_ex: ProtocolReadEx,
                        pub write_ex: ProtocolWriteEx,
                        pub flush_ex: ProtocolFlushEx,
                    }
                }

                pub mod device_path
                {
                    //! Device Path Protocol
                    use ::
                    {
                        *,
                    };
                    
                    pub const PROTOCOL_GUID: super::base::Guid = super::base::Guid::from_fields
                    (
                        0x09576e91,
                        0x6d3f,
                        0x11d2,
                        0x8e,
                        0x39,
                        &[0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b],
                    );

                    pub const TYPE_HARDWARE: u8 = 0x01;
                    pub const TYPE_ACPI: u8 = 0x02;
                    pub const TYPE_MESSAGING: u8 = 0x03;
                    pub const TYPE_MEDIA: u8 = 0x04;
                    pub const TYPE_BIOS: u8 = 0x05;
                    pub const TYPE_END: u8 = 0x7f;

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct Protocol
                    {
                        pub r#type: u8,
                        pub sub_type: u8,
                        pub length: [u8; 2],
                    }

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct End
                    {
                        pub header: Protocol,
                    }

                    impl End
                    {
                        pub const SUBTYPE_INSTANCE: u8 = 0x01;
                        pub const SUBTYPE_ENTIRE: u8 = 0xff;
                    }

                    #[repr( C )] #[derive( Clone, Copy, Debug )]
                    pub struct Hardware
                    {
                        pub header: Protocol,
                    }

                    impl Hardware
                    {
                        pub const SUBTYPE_PCI: u8 = 0x01;
                        pub const SUBTYPE_PCCARD: u8 = 0x02;
                        pub const SUBTYPE_MMAP: u8 = 0x03;
                        pub const SUBTYPE_VENDOR: u8 = 0x04;
                        pub const SUBTYPE_CONTROLLER: u8 = 0x05;
                        pub const SUBTYPE_BMC: u8 = 0x06;
                    }

                    #[repr( C, packed )] #[derive( Clone, Copy, Debug )]
                    pub struct HardDriveMedia
                    {
                        pub header: Protocol,
                        pub partition_number: u32,
                        pub partition_start: u64,
                        pub partition_size: u64,
                        pub partition_signature: [u8; 16],
                        pub partition_format: u8,
                        pub signature_type: u8,
                    }

                    pub struct Media
                    {
                        pub header: Protocol,
                    }

                    impl Media
                    {
                        pub const SUBTYPE_HARDDRIVE: u8 = 0x01;
                        pub const SUBTYPE_CDROM: u8 = 0x02;
                        pub const SUBTYPE_VENDOR: u8 = 0x03;
                        pub const SUBTYPE_FILE_PATH: u8 = 0x04;
                        pub const SUBTYPE_MEDIA_PROTOCOL: u8 = 0x05;
                        pub const SUBTYPE_PIWG_FIRMWARE_FILE: u8 = 0x06;
                        pub const SUBTYPE_PIWG_FIRMWARE_VOLUME: u8 = 0x07;
                        pub const SUBTYPE_RELATIVE_OFFSET_RANGE: u8 = 0x08;
                        pub const SUBTYPE_RAM_DISK: u8 = 0x09;
                    }
                }

                pub mod simple_file_system
                {
                    //! Simple File System Protocol
                    use ::
                    {
                        *,
                    };
                    
                    pub const PROTOCOL_GUID: super::base::Guid = super::base::Guid::from_fields
                    (
                        0x964e5b22,
                        0x6459,
                        0x11d2,
                        0x8e,
                        0x39,
                        &[0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b],
                    );

                    pub const REVISION: u64 = 0x0000000000010000u64;

                    pub type ProtocolOpenVolume = eficall! {fn
                    (
                        *mut Protocol,
                        *mut *mut super::protocols::file::Protocol,
                    ) -> super::base::Status};

                    #[repr( C )] pub struct Protocol 
                    {
                        pub revision: u64,
                        pub open_volume: ProtocolOpenVolume,
                    }
                }

            } pub use self::protocols::file;

            #[expect(dead_code)]
            const FILE_PERMISSIONS_MASK: u64 = self::file::READ_ONLY;

            pub struct File(!);

            #[derive(Clone)]
            pub struct FileAttr 
            {
                attr: u64,
                size: u64,
            }

            pub struct ReadDir(!);

            pub struct DirEntry(!);

            #[derive(Clone, Debug)]
            pub struct OpenOptions 
            {
                mode: u64,
                append: bool,
                truncate: bool,
                create_new: bool,
            }

            #[derive(Copy, Clone, Debug, Default)]
            pub struct FileTimes {}

            #[derive(Clone, PartialEq, Eq, Debug)]
            pub struct FilePermissions(bool);

            #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
            pub struct FileType(bool);

            #[derive( Debug )]
            pub struct DirBuilder;

            impl FileAttr 
            {
                pub fn size(&self) -> u64 { self.size }
                pub fn perm(&self) -> FilePermissions { FilePermissions::from_attr(self.attr) }
                pub fn file_type(&self) -> FileType { FileType::from_attr(self.attr) }
                pub fn modified(&self) -> io::Result<SystemTime> { unsupported() }
                pub fn accessed(&self) -> io::Result<SystemTime> { unsupported() }
                pub fn created(&self) -> io::Result<SystemTime> { unsupported() }
            }

            impl FilePermissions
            {
                pub fn readonly(&self) -> bool { self.0 }

                pub fn set_readonly(&mut self, readonly: bool) { self.0 = readonly }

                const fn from_attr(attr: u64) -> Self { Self(attr & file::READ_ONLY != 0) }
                
                const fn to_attr(&self) -> u64 { if self.0 { file::READ_ONLY } else { 0 } }
            }

            impl FileTimes
            {
                pub fn set_accessed(&mut self, _t: SystemTime) {}
                pub fn set_modified(&mut self, _t: SystemTime) {}
            }

            impl FileType
            {
                pub fn is_dir(&self) -> bool { self.0 }
                pub fn is_file(&self) -> bool { !self.is_dir() }                
                pub fn is_symlink(&self) -> bool { false }
                const fn from_attr(attr: u64) -> Self { Self(attr & file::DIRECTORY != 0) }
            }

            impl fmt::Debug for ReadDir
            {
                fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result { self.0 }
            }

            impl Iterator for ReadDir
            {
                type Item = io::Result<DirEntry>;
                fn next(&mut self) -> Option<io::Result<DirEntry>> { self.0 }
            }

            impl DirEntry
            {
                pub fn path(&self) -> PathBuf { self.0 }
                pub fn file_name(&self) -> OsString { self.0 }
                pub fn metadata(&self) -> io::Result<FileAttr> { self.0 }
                pub fn file_type(&self) -> io::Result<FileType> { self.0 }
            }

            impl OpenOptions
            {
                pub fn new() -> OpenOptions
                {
                    OpenOptions 
                    { 
                        mode: 0, 
                        append: false, 
                        create_new: false, 
                        truncate: false
                    }
                }

                pub fn read(&mut self, read: bool)
                {
                    if read { self.mode |= file::MODE_READ; }
                    else { self.mode &= !file::MODE_READ; }
                }

                pub fn write(&mut self, write: bool)
                {
                    if write
                    {
                        self.read(true);
                        self.mode |= file::MODE_WRITE;
                    }
                    else { self.mode &= !file::MODE_WRITE; }
                }

                pub fn append(&mut self, append: bool)
                {
                    if append { self.write(true); }
                    self.append = append;
                }

                pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }

                pub fn create(&mut self, create: bool)
                {
                    if create { self.mode |= file::MODE_CREATE; }
                    else { self.mode &= !file::MODE_CREATE; }
                }

                pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }
                
                const fn is_mode_valid(&self) -> bool
                {
                    self.mode == file::MODE_READ
                    || self.mode == (file::MODE_READ | file::MODE_WRITE)
                    || self.mode == (file::MODE_READ | file::MODE_WRITE | file::MODE_CREATE)
                }
            }

            impl File
            {
                pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> { unsupported() }
                pub fn file_attr(&self) -> io::Result<FileAttr> { self.0 }
                pub fn fsync(&self) -> io::Result<()> { self.0 }
                pub fn datasync(&self) -> io::Result<()> { self.0 }
                pub fn lock(&self) -> io::Result<()> { self.0 }
                pub fn lock_shared(&self) -> io::Result<()> { self.0 }
                pub fn try_lock(&self) -> io::Result<bool> { self.0 }
                pub fn try_lock_shared(&self) -> io::Result<bool> { self.0 }
                pub fn unlock(&self) -> io::Result<()> { self.0 }
                pub fn truncate(&self, _size: u64) -> io::Result<()> { self.0 }
                pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> { self.0 }
                pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> { self.0 }
                pub fn is_read_vectored(&self) -> bool { self.0 }
                pub fn read_buf(&self, _cursor: BorrowedCursor<'_>) -> io::Result<()> { self.0 }
                pub fn write(&self, _buf: &[u8]) -> io::Result<usize> { self.0 }
                pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> { self.0 }
                pub fn is_write_vectored(&self) -> bool { self.0 }
                pub fn flush(&self) -> io::Result<()> { self.0 }
                pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> { self.0 }
                pub fn tell(&self) -> io::Result<u64> { self.0 }
                pub fn duplicate(&self) -> io::Result<File> { self.0 }
                pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> { self.0 }
                pub fn set_times(&self, _times: FileTimes) -> io::Result<()> { self.0 }
            }

            impl DirBuilder
            {
                pub fn new() -> DirBuilder
                {
                    DirBuilder
                }

                pub fn mkdir(&self, p: &Path) -> io::Result<()>
                {
                    efi::mkdir(p)
                }
            }

            impl fmt::Debug for File
            {
                fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result { self.0 }
            }

            pub fn readdir(_p: &Path) -> io::Result<ReadDir> { unsupported() }
            pub fn unlink(_p: &Path) -> io::Result<()> { unsupported() }
            pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> { unsupported() }
            pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> { unsupported() }
            pub fn rmdir(_p: &Path) -> io::Result<()> { unsupported() }
            pub fn remove_dir_all(_path: &Path) -> io::Result<()> { unsupported() }
            pub fn exists(path: &Path) -> io::Result<bool>
            {
                let f = uefi_fs::File::from_path(path, file::MODE_READ, 0);
                match f
                {
                    Ok(_) => Ok(true),
                    Err(e) if e.kind() == io::ErrorKind::NotFound => Ok(false),
                    Err(e) => Err(e),
                }
            }

            pub fn readlink(_p: &Path) -> io::Result<PathBuf> { unsupported() }
            pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> { unsupported() }
            pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> { unsupported() }
            pub fn stat(_p: &Path) -> io::Result<FileAttr> { unsupported() }
            pub fn lstat(p: &Path) -> io::Result<FileAttr> { stat(p) }
            pub fn canonicalize(p: &Path) -> io::Result<PathBuf> { ::path::absolute(p) }
            pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> { unsupported() }

            mod efi
            {
                use ::
                {
                    boxed::Box,
                    path::Path,
                    ptr::NonNull,
                    sys::helpers,
                    *,
                };
                use super::protocols::{device_path, file, simple_file_system};
                
                pub struct File(NonNull<file::Protocol>);

                impl File
                {
                    pub fn from_path(path: &Path, open_mode: u64, attr: u64) -> io::Result<Self>
                    {
                        let absolute = ::path::absolute(path)?;
                        let p = helpers::OwnedDevicePath::from_text(absolute.as_os_str())?;
                        let (vol, mut path_remaining) = Self::open_volume_from_device_path(p.borrow())?;
                        vol.open(&mut path_remaining, open_mode, attr)
                    }
                    /// Open Filesystem volume given a devicepath to the volume, or a file/directory in the volume.
                    fn open_volume_from_device_path ( path: helpers::BorrowedDevicePath<'_> ) -> 
                    io::Result<(Self, Box<[u16]>)>
                    {
                        let handles = match helpers::locate_handles(simple_file_system::PROTOCOL_GUID) {
                            Ok(x) => x,
                            Err(e) => return Err(e),
                        };
                        for handle in handles {
                            let volume_device_path: NonNull<device_path::Protocol> =
                                match helpers::open_protocol(handle, device_path::PROTOCOL_GUID) {
                                    Ok(x) => x,
                                    Err(_) => continue,
                                };
                            let volume_device_path = helpers::BorrowedDevicePath::new(volume_device_path);

                            if let Some(left_path) = path_best_match(&volume_device_path, &path) {
                                return Ok((Self::open_volume(handle)?, left_path));
                            }
                        }

                        Err(constant_error!(io::ErrorKind::NotFound, "Volume Not Found"))
                    }
                    
                    pub fn open_volume(device_handle: NonNull<::ffi::c_void>) -> io::Result<Self>
                    {
                        let simple_file_system_protocol = helpers::open_protocol::<simple_file_system::Protocol>(
                            device_handle,
                            simple_file_system::PROTOCOL_GUID,
                        )?;

                        let mut file_protocol = ::ptr::null_mut();
                        let r = unsafe {
                            ((*simple_file_system_protocol.as_ptr()).open_volume)(
                                simple_file_system_protocol.as_ptr(),
                                &mut file_protocol,
                            )
                        };
                        if r.is_error() {
                            return Err(io::Error::from_raw_os_error(r.as_usize()));
                        }
                        
                        let p = NonNull::new(file_protocol).unwrap();
                        Ok(Self(p))
                    }

                    fn open(&self, path: &mut [u16], open_mode: u64, attr: u64) -> io::Result<Self> {
                        let file_ptr = self.0.as_ptr();
                        let mut file_opened = ::ptr::null_mut();

                        let r = unsafe {
                            ((*file_ptr).open)(file_ptr, &mut file_opened, path.as_mut_ptr(), open_mode, attr)
                        };

                        if r.is_error() {
                            return Err(io::Error::from_raw_os_error(r.as_usize()));
                        }
                        
                        let p = NonNull::new(file_opened).unwrap();
                        Ok(File(p))
                    }
                }

                impl Drop for File {
                    fn drop(&mut self) {
                        let file_ptr = self.0.as_ptr();
                        let _ = unsafe { ((*self.0.as_ptr()).close)(file_ptr) };
                    }
                }

                /// A helper to check that target path is a descendent of source.
                fn path_best_match(
                    source: &helpers::BorrowedDevicePath<'_>,
                    target: &helpers::BorrowedDevicePath<'_>,
                ) -> Option<Box<[u16]>> {
                    let mut source_iter = source.iter().take_while(|x| !x.is_end_instance());
                    let mut target_iter = target.iter().take_while(|x| !x.is_end_instance());

                    loop {
                        match (source_iter.next(), target_iter.next()) {
                            (Some(x), Some(y)) if x == y => continue,
                            (None, Some(y)) => {
                                let p = y.to_path().to_text().ok()?;
                                return helpers::os_string_to_raw(&p);
                            }
                            _ => return None,
                        }
                    }
                }

                /// An implementation of mkdir to allow creating new directory without having to open the
                /// volume twice (once for checking and once for creating)
                pub fn mkdir(path: &Path) -> io::Result<()> {
                    let absolute = crate::path::absolute(path)?;

                    let p = helpers::OwnedDevicePath::from_text(absolute.as_os_str())?;
                    let (vol, mut path_remaining) = File::open_volume_from_device_path(p.borrow())?;

                    // Check if file exists
                    match vol.open(&mut path_remaining, file::MODE_READ, 0) {
                        Ok(_) => {
                            return Err(io::Error::new(io::ErrorKind::AlreadyExists, "Path already exists"));
                        }
                        Err(e) if e.kind() == io::ErrorKind::NotFound => {}
                        Err(e) => return Err(e),
                    }

                    let _ = vol.open(
                        &mut path_remaining,
                        file::MODE_READ | file::MODE_WRITE | file::MODE_CREATE,
                        file::DIRECTORY,
                    )?;

                    Ok(())
                }
            }
        }

        mod unsupported
        {
            use ::
            {
                ffi::OsString,
                hash::{Hash, Hasher},
                io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom},
                path::{Path, PathBuf},
                sys::time::SystemTime,
                sys::unsupported,
                *,
            };
            
            pub struct File(!);

            pub struct FileAttr(!);

            pub struct ReadDir(!);

            pub struct DirEntry(!);

            #[derive(Clone, Debug)]
            pub struct OpenOptions {}

            #[derive(Copy, Clone, Debug, Default)]
            pub struct FileTimes {}

            pub struct FilePermissions(!);

            pub struct FileType(!);

            #[derive( Debug )]
            pub struct DirBuilder {}

            impl FileAttr
            {
                pub fn size(&self) -> u64 {
                    self.0
                }

                pub fn perm(&self) -> FilePermissions {
                    self.0
                }

                pub fn file_type(&self) -> FileType {
                    self.0
                }

                pub fn modified(&self) -> io::Result<SystemTime> {
                    self.0
                }

                pub fn accessed(&self) -> io::Result<SystemTime> {
                    self.0
                }

                pub fn created(&self) -> io::Result<SystemTime> {
                    self.0
                }
            }

            impl Clone for FileAttr 
            {
                fn clone(&self) -> FileAttr {
                    self.0
                }
            }

            impl FilePermissions 
            {
                pub fn readonly(&self) -> bool {
                    self.0
                }

                pub fn set_readonly(&mut self, _readonly: bool) {
                    self.0
                }
            }

            impl Clone for FilePermissions 
            {
                fn clone(&self) -> FilePermissions {
                    self.0
                }
            }

            impl PartialEq for FilePermissions 
            {
                fn eq(&self, _other: &FilePermissions) -> bool {
                    self.0
                }
            }

            impl Eq for FilePermissions {}

            impl fmt::Debug for FilePermissions 
            {
                fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    self.0
                }
            }

            impl FileTimes 
            {
                pub fn set_accessed(&mut self, _t: SystemTime) {}
                pub fn set_modified(&mut self, _t: SystemTime) {}
            }

            impl FileType 
            {
                pub fn is_dir(&self) -> bool {
                    self.0
                }

                pub fn is_file(&self) -> bool {
                    self.0
                }

                pub fn is_symlink(&self) -> bool {
                    self.0
                }
            }

            impl Clone for FileType 
            {
                fn clone(&self) -> FileType {
                    self.0
                }
            }

            impl Copy for FileType {}

            impl PartialEq for FileType 
            {
                fn eq(&self, _other: &FileType) -> bool {
                    self.0
                }
            }

            impl Eq for FileType {}

            impl Hash for FileType {
                fn hash<H: Hasher>(&self, _h: &mut H) {
                    self.0
                }
            }

            impl fmt::Debug for FileType 
            {
                fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    self.0
                }
            }

            impl fmt::Debug for ReadDir 
            {
                fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    self.0
                }
            }

            impl Iterator for ReadDir 
            {
                type Item = io::Result<DirEntry>;

                fn next(&mut self) -> Option<io::Result<DirEntry>> {
                    self.0
                }
            }

            impl DirEntry 
            {
                pub fn path(&self) -> PathBuf {
                    self.0
                }

                pub fn file_name(&self) -> OsString {
                    self.0
                }

                pub fn metadata(&self) -> io::Result<FileAttr> {
                    self.0
                }

                pub fn file_type(&self) -> io::Result<FileType> {
                    self.0
                }
            }

            impl OpenOptions 
            {
                pub fn new() -> OpenOptions {
                    OpenOptions {}
                }

                pub fn read(&mut self, _read: bool) {}
                pub fn write(&mut self, _write: bool) {}
                pub fn append(&mut self, _append: bool) {}
                pub fn truncate(&mut self, _truncate: bool) {}
                pub fn create(&mut self, _create: bool) {}
                pub fn create_new(&mut self, _create_new: bool) {}
            }

            impl File 
            {
                pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {
                    unsupported()
                }

                pub fn file_attr(&self) -> io::Result<FileAttr> {
                    self.0
                }

                pub fn fsync(&self) -> io::Result<()> {
                    self.0
                }

                pub fn datasync(&self) -> io::Result<()> {
                    self.0
                }

                pub fn lock(&self) -> io::Result<()> {
                    self.0
                }

                pub fn lock_shared(&self) -> io::Result<()> {
                    self.0
                }

                pub fn try_lock(&self) -> io::Result<bool> {
                    self.0
                }

                pub fn try_lock_shared(&self) -> io::Result<bool> {
                    self.0
                }

                pub fn unlock(&self) -> io::Result<()> {
                    self.0
                }

                pub fn truncate(&self, _size: u64) -> io::Result<()> {
                    self.0
                }

                pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {
                    self.0
                }

                pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
                    self.0
                }

                pub fn is_read_vectored(&self) -> bool {
                    self.0
                }

                pub fn read_buf(&self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {
                    self.0
                }

                pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {
                    self.0
                }

                pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {
                    self.0
                }

                pub fn is_write_vectored(&self) -> bool {
                    self.0
                }

                pub fn flush(&self) -> io::Result<()> {
                    self.0
                }

                pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {
                    self.0
                }

                pub fn tell(&self) -> io::Result<u64> {
                    self.0
                }

                pub fn duplicate(&self) -> io::Result<File> {
                    self.0
                }

                pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {
                    self.0
                }

                pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {
                    self.0
                }
            }

            impl DirBuilder 
            {
                pub fn new() -> DirBuilder {
                    DirBuilder {}
                }

                pub fn mkdir(&self, _p: &Path) -> io::Result<()> {
                    unsupported()
                }
            }

            impl fmt::Debug for File 
            {
                fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    self.0
                }
            }

            pub fn readdir(_p: &Path) -> io::Result<ReadDir> 
            {
                unsupported()
            }

            pub fn unlink(_p: &Path) -> io::Result<()> 
            {
                unsupported()
            }

            pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> 
            {
                unsupported()
            }

            pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> 
            {
                match perm.0 {}
            }

            pub fn rmdir(_p: &Path) -> io::Result<()> 
            {
                unsupported()
            }

            pub fn remove_dir_all(_path: &Path) -> io::Result<()> 
            {
                unsupported()
            }

            pub fn exists(_path: &Path) -> io::Result<bool> 
            {
                unsupported()
            }

            pub fn readlink(_p: &Path) -> io::Result<PathBuf> 
            {
                unsupported()
            }

            pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> 
            {
                unsupported()
            }

            pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> 
            {
                unsupported()
            }

            pub fn stat(_p: &Path) -> io::Result<FileAttr> 
            {
                unsupported()
            }

            pub fn lstat(_p: &Path) -> io::Result<FileAttr> 
            {
                unsupported()
            }

            pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> 
            {
                unsupported()
            }

            pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> 
            {
                unsupported()
            }
        }

        #[cfg( unix )] pub use self::unix::{ * };
        #[cfg( windows )] pub use self::windows::{ * };
        #[cfg(target_os = "uefi")]  pub use self::uefi::{ * };

        pub fn read_dir(path: &Path) -> io::Result<ReadDir> { imp::readdir(path) }

        pub fn remove_file(path: &Path) -> io::Result<()> { with_native_path(path, &imp::unlink) }

        pub fn rename(old: &Path, new: &Path) -> io::Result<()>
        { with_native_path(old, &|old| with_native_path(new, &|new| imp::rename(old, new))) }

        pub fn remove_dir(path: &Path) -> io::Result<()> { with_native_path(path, &imp::rmdir) }

        pub fn remove_dir_all(path: &Path) -> io::Result<()>
        {
            #[cfg(not(windows))] return imp::remove_dir_all(path);
            #[cfg(windows)] with_native_path(path, &imp::remove_dir_all)
        }

        pub fn read_link(path: &Path) -> io::Result<PathBuf> { with_native_path(path, &imp::readlink) }

        pub fn symlink(original: &Path, link: &Path) -> io::Result<()>
        {
            #[cfg(windows)] 
            return imp::symlink(original, link);

            #[cfg(not(windows))] 
            with_native_path(original, &|original| { with_native_path(link, &|link| imp::symlink(original, link)) })
        }

        pub fn hard_link(original: &Path, link: &Path) -> io::Result<()>
        { with_native_path(original, &|original| { with_native_path(link, &|link| imp::link(original, link))})}

        pub fn metadata(path: &Path) -> io::Result<FileAttr> { with_native_path(path, &imp::stat) }

        pub fn symlink_metadata(path: &Path) -> io::Result<FileAttr> { with_native_path(path, &imp::lstat) }

        pub fn set_permissions(path: &Path, perm: FilePermissions) -> io::Result<()>
        { with_native_path(path, &|path| imp::set_perm(path, perm.clone())) }

        pub fn canonicalize(path: &Path) -> io::Result<PathBuf> { with_native_path(path, &imp::canonicalize) }

        pub fn copy(from: &Path, to: &Path) -> io::Result<u64>
        {
            #[cfg(not(windows))] return imp::copy(from, to);
            #[cfg(windows)] with_native_path(from, &|from| with_native_path(to, &|to| imp::copy(from, to)))
        }

        pub fn exists(path: &Path) -> io::Result<bool>
        {
            #[cfg(not(windows))] return imp::exists(path);
            #[cfg(windows)] with_native_path(path, &imp::exists)
        }
    }

    pub mod os_str
    {
        mod bytes
        {
            //! The underlying OsString/OsStr implementation on Unix and many other systems: `Vec<u8>`/`[u8]`.
            use ::
            {
                clone::CloneToUninit,
                borrow::Cow,
                collections::TryReserveError,
                fmt::Write,
                rc::Rc,
                sync::Arc,
                sys::common::{AsInner, FromInner, IntoInner},
                *,
            };

            #[repr(transparent)] #[derive(Hash)]
            pub struct Buf
            {
                pub inner: Vec<u8>,
            }

            #[repr(transparent)]
            pub struct Slice
            {
                pub inner: [u8],
            }

            impl IntoInner<Vec<u8>> for Buf
            {
                fn into_inner(self) -> Vec<u8>
                {
                    self.inner
                }
            }

            impl FromInner<Vec<u8>> for Buf
            {
                fn from_inner(inner: Vec<u8>) -> Self
                {
                    Buf { inner }
                }
            }

            impl AsInner<[u8]> for Buf
            {
                #[inline]
                fn as_inner(&self) -> &[u8]
                {
                    &self.inner
                }
            }

            impl fmt::Debug for Buf
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Debug::fmt(self.as_slice(), f)
                }
            }

            impl fmt::Display for Buf
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Display::fmt(self.as_slice(), f)
                }
            }

            impl fmt::Debug for Slice
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Debug::fmt(&self.inner.utf8_chunks().debug(), f)
                }
            }

            impl fmt::Display for Slice
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    if self.inner.is_empty()
                    {
                        return "".fmt(f);
                    }

                    for chunk in self.inner.utf8_chunks()
                    {
                        let valid = chunk.valid();
                        if chunk.invalid().is_empty() {
                            return valid.fmt(f);
                        }

                        f.write_str(valid)?;
                        f.write_char(char::REPLACEMENT_CHARACTER)?;
                    }
                    Ok(())
                }
            }

            impl Clone for Buf
            {
                #[inline]
                fn clone(&self) -> Self
                {
                    Buf { inner: self.inner.clone() }
                }

                #[inline]
                fn clone_from(&mut self, source: &Self)
                {
                    self.inner.clone_from(&source.inner)
                }
            }

            impl Buf
            {
                #[inline] pub fn into_encoded_bytes(self) -> Vec<u8>
                {
                    self.inner
                }

                #[inline]
                pub unsafe fn from_encoded_bytes_unchecked(s: Vec<u8>) -> Self
                {
                    Self { inner: s }
                }

                #[inline] pub fn into_string(self) -> Result<String, Buf>
                {
                    String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() })
                }

                #[inline] pub fn from_string(s: String) -> Buf
                {
                    Buf { inner: s.into_bytes() }
                }

                #[inline] pub fn with_capacity(capacity: usize) -> Buf
                {
                    Buf { inner: Vec::with_capacity(capacity) }
                }

                #[inline] pub fn clear(&mut self)
                {
                    self.inner.clear()
                }

                #[inline] pub fn capacity(&self) -> usize
                {
                    self.inner.capacity()
                }

                #[inline] pub fn push_slice(&mut self, s: &Slice)
                {
                    self.inner.extend_from_slice(&s.inner)
                }

                #[inline] pub fn push_str(&mut self, s: &str)
                {
                    self.inner.extend_from_slice(s.as_bytes());
                }

                #[inline] pub fn reserve(&mut self, additional: usize)
                {
                    self.inner.reserve(additional)
                }

                #[inline] pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>
                {
                    self.inner.try_reserve(additional)
                }

                #[inline] pub fn reserve_exact(&mut self, additional: usize)
                {
                    self.inner.reserve_exact(additional)
                }

                #[inline] pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>
                {
                    self.inner.try_reserve_exact(additional)
                }

                #[inline] pub fn shrink_to_fit(&mut self)
                {
                    self.inner.shrink_to_fit()
                }

                #[inline] pub fn shrink_to(&mut self, min_capacity: usize)
                {
                    self.inner.shrink_to(min_capacity)
                }

                #[inline] pub fn as_slice(&self) -> &Slice
                {
                    unsafe { mem::transmute(self.inner.as_slice()) }
                }

                #[inline] pub fn as_mut_slice(&mut self) -> &mut Slice
                {
                    unsafe { mem::transmute(self.inner.as_mut_slice()) }
                }

                #[inline] pub fn leak<'a>(self) -> &'a mut Slice
                {
                    unsafe { mem::transmute(self.inner.leak()) }
                }

                #[inline] pub fn into_box(self) -> Box<Slice>
                {
                    unsafe { mem::transmute(self.inner.into_boxed_slice()) }
                }

                #[inline] pub fn from_box(boxed: Box<Slice>) -> Buf
                {
                    let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };
                    Buf { inner: inner.into_vec() }
                }

                #[inline] pub fn into_arc(&self) -> Arc<Slice>
                {
                    self.as_slice().into_arc()
                }

                #[inline] pub fn into_rc(&self) -> Rc<Slice>
                {
                    self.as_slice().into_rc()
                }
                
                #[inline] pub fn truncate(&mut self, len: usize)
                {
                    self.inner.truncate(len);
                }
                
                #[inline] pub fn extend_from_slice(&mut self, other: &[u8])
                {
                    self.inner.extend_from_slice(other);
                }
            }

            impl Slice
            {
                #[inline] pub fn as_encoded_bytes(&self) -> &[u8]
                {
                    &self.inner
                }

                #[inline]
                pub unsafe fn from_encoded_bytes_unchecked(s: &[u8]) -> &Slice
                {
                    unsafe { mem::transmute(s) }
                }

                #[track_caller]
                #[inline] pub fn check_public_boundary(&self, index: usize)
                {
                    if index == 0 || index == self.inner.len() {
                        return;
                    }
                    if index < self.inner.len()
                        && (self.inner[index - 1].is_ascii() || self.inner[index].is_ascii())
                    {
                        return;
                    }

                    slow_path(&self.inner, index);
                    
                    #[track_caller]
                    #[inline(never)]
                    fn slow_path(bytes: &[u8], index: usize)
                    {
                        let (before, after) = bytes.split_at(index);
                        let after = after.get(..4).unwrap_or(after);
                        match str::from_utf8(after)
                        {
                            Ok(_) => return,
                            Err(err) if err.valid_up_to() != 0 => return,
                            Err(_) => (),
                        }

                        for len in 2..=4.min(index)
                        {
                            let before = &before[index - len..];
                            if str::from_utf8(before).is_ok()
                            {
                                return;
                            }
                        }

                        panic!("byte index {index} is not an OsStr boundary");
                    }
                }

                #[inline] pub fn from_str(s: &str) -> &Slice
                {
                    unsafe { Slice::from_encoded_bytes_unchecked(s.as_bytes()) }
                }

                #[inline] pub fn to_str(&self) -> Result<&str, crate::str::Utf8Error>
                {
                    str::from_utf8(&self.inner)
                }

                #[inline] pub fn to_string_lossy(&self) -> Cow<'_, str>
                {
                    String::from_utf8_lossy(&self.inner)
                }

                #[inline] pub fn to_owned(&self) -> Buf
                {
                    Buf { inner: self.inner.to_vec() }
                }

                #[inline] pub fn clone_into(&self, buf: &mut Buf)
                {
                    self.inner.clone_into(&mut buf.inner)
                }

                #[inline] pub fn into_box(&self) -> Box<Slice>
                {
                    let boxed: Box<[u8]> = self.inner.into();
                    unsafe { mem::transmute(boxed) }
                }

                #[inline] pub fn empty_box() -> Box<Slice>
                {
                    let boxed: Box<[u8]> = Default::default();
                    unsafe { mem::transmute(boxed) }
                }

                #[inline] pub fn into_arc(&self) -> Arc<Slice>
                {
                    let arc: Arc<[u8]> = Arc::from(&self.inner);
                    unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Slice) }
                }

                #[inline] pub fn into_rc(&self) -> Rc<Slice>
                {
                    let rc: Rc<[u8]> = Rc::from(&self.inner);
                    unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }
                }

                #[inline] pub fn make_ascii_lowercase(&mut self)
                {
                    self.inner.make_ascii_lowercase()
                }

                #[inline] pub fn make_ascii_uppercase(&mut self)
                {
                    self.inner.make_ascii_uppercase()
                }

                #[inline] pub fn to_ascii_lowercase(&self) -> Buf
                {
                    Buf { inner: self.inner.to_ascii_lowercase() }
                }

                #[inline] pub fn to_ascii_uppercase(&self) -> Buf
                {
                    Buf { inner: self.inner.to_ascii_uppercase() }
                }

                #[inline] pub fn is_ascii(&self) -> bool {
                    self.inner.is_ascii()
                }

                #[inline] pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool
                {
                    self.inner.eq_ignore_ascii_case(&other.inner)
                }
            }
            unsafe impl CloneToUninit for Slice
            {
                #[inline] unsafe fn clone_to_uninit(&self, dst: *mut u8)
                {
                    unsafe { self.inner.clone_to_uninit(dst) }
                }
            }
        }
        
        mod wtf8
        {
            //! The underlying OsString/OsStr implementation on Windows is a wrapper around the "WTF-8" encoding.
            use ::
            {
                clone::CloneToUninit,
                borrow::Cow,
                collections::TryReserveError,
                rc::Rc,
                sync::Arc,
                sys::common::wtf8::{ AsInner, FromInner, IntoInner, Wtf8, Wtf8Buf, check_utf8_boundary },
                *,
            };
            
            #[derive(Hash)]
            pub struct Buf
            {
                pub inner: Wtf8Buf,
            }

            #[repr(transparent)]
            pub struct Slice
            {
                pub inner: Wtf8,
            }

            impl IntoInner<Wtf8Buf> for Buf
            {
                fn into_inner(self) -> Wtf8Buf
                {
                    self.inner
                }
            }

            impl FromInner<Wtf8Buf> for Buf
            {
                fn from_inner(inner: Wtf8Buf) -> Self
                {
                    Buf { inner }
                }
            }

            impl AsInner<Wtf8> for Buf
            {
                #[inline]
                fn as_inner(&self) -> &Wtf8
                {
                    &self.inner
                }
            }

            impl fmt::Debug for Buf
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Debug::fmt(&self.inner, f)
                }
            }

            impl fmt::Display for Buf
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Display::fmt(&self.inner, f)
                }
            }

            impl fmt::Debug for Slice
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Debug::fmt(&self.inner, f)
                }
            }

            impl fmt::Display for Slice
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    fmt::Display::fmt(&self.inner, f)
                }
            }

            impl Clone for Buf
            {
                #[inline]
                fn clone(&self) -> Self
                {
                    Buf { inner: self.inner.clone() }
                }

                #[inline]
                fn clone_from(&mut self, source: &Self)
                {
                    self.inner.clone_from(&source.inner)
                }
            }

            impl Buf
            {
                #[inline] pub fn into_encoded_bytes(self) -> Vec<u8>
                {
                    self.inner.into_bytes()
                }

                #[inline]  pub unsafe fn from_encoded_bytes_unchecked(s: Vec<u8>) -> Self
                {
                    unsafe { Self { inner: Wtf8Buf::from_bytes_unchecked(s) } }
                }

                #[inline] pub fn into_string(self) -> Result<String, Buf>
                {
                    self.inner.into_string().map_err(|buf| Buf { inner: buf })
                }

                #[inline] pub fn from_string(s: String) -> Buf
                {
                    Buf { inner: Wtf8Buf::from_string(s) }
                }

                #[inline] pub fn with_capacity(capacity: usize) -> Buf
                {
                    Buf { inner: Wtf8Buf::with_capacity(capacity) }
                }

                #[inline] pub fn clear(&mut self)
                {
                    self.inner.clear()
                }

                #[inline] pub fn capacity(&self) -> usize
                {
                    self.inner.capacity()
                }

                #[inline] pub fn push_slice(&mut self, s: &Slice)
                {
                    self.inner.push_wtf8(&s.inner)
                }

                #[inline] pub fn push_str(&mut self, s: &str)
                {
                    self.inner.push_str(s);
                }

                #[inline] pub fn reserve(&mut self, additional: usize)
                {
                    self.inner.reserve(additional)
                }

                #[inline] pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>
                {
                    self.inner.try_reserve(additional)
                }

                #[inline] pub fn reserve_exact(&mut self, additional: usize)
                {
                    self.inner.reserve_exact(additional)
                }

                #[inline] pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>
                {
                    self.inner.try_reserve_exact(additional)
                }

                #[inline] pub fn shrink_to_fit(&mut self)
                {
                    self.inner.shrink_to_fit()
                }

                #[inline] pub fn shrink_to(&mut self, min_capacity: usize)
                {
                    self.inner.shrink_to(min_capacity)
                }

                #[inline] pub fn as_slice(&self) -> &Slice
                {
                    unsafe { mem::transmute(self.inner.as_slice()) }
                }

                #[inline] pub fn as_mut_slice(&mut self) -> &mut Slice
                {
                    unsafe { mem::transmute(self.inner.as_mut_slice()) }
                }

                #[inline] pub fn leak<'a>(self) -> &'a mut Slice
                {
                    unsafe { mem::transmute(self.inner.leak()) }
                }

                #[inline] pub fn into_box(self) -> Box<Slice>
                {
                    unsafe { mem::transmute(self.inner.into_box()) }
                }

                #[inline] pub fn from_box(boxed: Box<Slice>) -> Buf
                {
                    let inner: Box<Wtf8> = unsafe { mem::transmute(boxed) };
                    Buf { inner: Wtf8Buf::from_box(inner) }
                }

                #[inline] pub fn into_arc(&self) -> Arc<Slice>
                {
                    self.as_slice().into_arc()
                }

                #[inline] pub fn into_rc(&self) -> Rc<Slice>
                {
                    self.as_slice().into_rc()
                }
                
                #[inline] pub fn truncate(&mut self, len: usize)
                {
                    self.inner.truncate(len);
                }
                
                #[inline] pub fn extend_from_slice(&mut self, other: &[u8])
                {
                    self.inner.extend_from_slice(other);
                }
            }

            impl Slice
            {
                #[inline] pub fn as_encoded_bytes(&self) -> &[u8]
                {
                    self.inner.as_bytes()
                }

                #[inline] pub unsafe fn from_encoded_bytes_unchecked(s: &[u8]) -> &Slice
                {
                    unsafe { mem::transmute(Wtf8::from_bytes_unchecked(s)) }
                }

                #[track_caller] #[inline] pub fn check_public_boundary(&self, index: usize)
                {
                    check_utf8_boundary(&self.inner, index);
                }

                #[inline] pub fn from_str(s: &str) -> &Slice
                {
                    unsafe { mem::transmute(Wtf8::from_str(s)) }
                }

                #[inline] pub fn to_str(&self) -> Result<&str, crate::str::Utf8Error>
                {
                    self.inner.as_str()
                }

                #[inline] pub fn to_string_lossy(&self) -> Cow<'_, str>
                {
                    self.inner.to_string_lossy()
                }

                #[inline] pub fn to_owned(&self) -> Buf
                {
                    Buf { inner: self.inner.to_owned() }
                }

                #[inline] pub fn clone_into(&self, buf: &mut Buf)
                {
                    self.inner.clone_into(&mut buf.inner)
                }

                #[inline] pub fn into_box(&self) -> Box<Slice>
                {
                    unsafe { mem::transmute(self.inner.into_box()) }
                }

                #[inline] pub fn empty_box() -> Box<Slice>
                {
                    unsafe { mem::transmute(Wtf8::empty_box()) }
                }

                #[inline] pub fn into_arc(&self) -> Arc<Slice>
                {
                    let arc = self.inner.into_arc();
                    unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Slice) }
                }

                #[inline] pub fn into_rc(&self) -> Rc<Slice>
                {
                    let rc = self.inner.into_rc();
                    unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }
                }

                #[inline] pub fn make_ascii_lowercase(&mut self)
                {
                    self.inner.make_ascii_lowercase()
                }

                #[inline] pub fn make_ascii_uppercase(&mut self)
                {
                    self.inner.make_ascii_uppercase()
                }

                #[inline] pub fn to_ascii_lowercase(&self) -> Buf
                {
                    Buf { inner: self.inner.to_ascii_lowercase() }
                }

                #[inline] pub fn to_ascii_uppercase(&self) -> Buf
                {
                    Buf { inner: self.inner.to_ascii_uppercase() }
                }

                #[inline] pub fn is_ascii(&self) -> bool
                {
                    self.inner.is_ascii()
                }

                #[inline] pub fn eq_ignore_ascii_case(&self, other: &Self) -> bool
                {
                    self.inner.eq_ignore_ascii_case(&other.inner)
                }
            }
            
            unsafe impl CloneToUninit for Slice
            {
                #[inline] unsafe fn clone_to_uninit(&self, dst: *mut u8)
                {
                    unsafe { self.inner.clone_to_uninit(dst) }
                }
            }
        }

        #[cfg( unix )] pub use self::bytes::{ Buf, Slice };
        #[cfg( windows )] pub use self::wtf8::{ Buf, Slice };
        #[cfg(target_os = "uefi")]  pub use self::wtf8::{ Buf, Slice };
    }

    pub mod pipe
    {
        use ::
        {
            *,
        };
    }

    pub mod process
    {
        use ::
        {
            *,
        };
    }

    pub mod prepare
    {
        use ::
        {
            system::{ api, SignalSet },
            *,
        };
        /// Configures a [`Terminal`] or [`Screen`] instance to read special input.
        #[derive(Copy, Clone, Debug)]
        pub struct PrepareConfig
        {
            /// Whether to block signals that result from user input.
            pub block_signals: bool,
            /// Whether to enable control flow characters.
            pub enable_control_flow: bool,
            /// If `true`, the terminal will be configured to generate events from function keys.
            pub enable_keypad: bool,
            /// If `true`, the terminal will be configured to generate events for
            /// mouse input, if supported, and `read_event` may return `Event::Mouse(_)`.
            pub enable_mouse: bool,
            /// If `true`, mouse motion events will always be reported.
            /// If `false`, such events will only be reported while at least one mouse button is pressed.
            pub always_track_motion: bool,
            /// For each signal in the set, 
            /// a signal handler will intercept the signal and report it by returning an `Event::Signal(_)` value.
            pub report_signals: SignalSet,
        }

        impl Default for PrepareConfig
        {
            fn default() -> PrepareConfig
            {
                PrepareConfig
                {
                    block_signals: true,
                    enable_control_flow: false,
                    enable_keypad: true,
                    enable_mouse: false,
                    always_track_motion: false,
                    report_signals: SignalSet::new(),
                }
            }
        }

        /// Represents a previous device state of a [`Terminal`].
        #[must_use = "the result of `terminal.prepare()` should be passed to \
            `terminal.restore()` to restore terminal to its original state"]
        pub struct PrepareState( api::PrepareState );

    }
    
    pub mod screen
    {
        //! Provides a drawable buffer on terminal devices.
        use ::
        {
            sync::{ LockResult, TryLockResult },
            system::
            {
                terminal::{ Color, Cursor, CursorMode, Event, Size, Style, Theme },
                api, map_lock_result, map_try_lock_result
            },
            time::{ Duration },
            *,
        };
        /*
        use ::priv_util::{map_lock_result, map_try_lock_result};
        use ::sys;
        */
        /// Provides operations on an underlying terminal device in screen mode.
        pub struct Screen(api::Screen);
        /// Holds an exclusive lock for read operations on a `Screen`.
        pub struct ScreenReadGuard<'a>(api::ScreenReadGuard<'a>);
        /// Holds an exclusive lock for write operations on a `Screen`.
        pub struct ScreenWriteGuard<'a>(api::ScreenWriteGuard<'a>);

        impl Screen
        {
            /// Opens a new screen interface on `stdout`.
            pub fn new(config: PrepareConfig) -> io::Result<Screen> { api::Screen::stdout(config).map(Screen) }
            /// Opens a new screen interface on `stderr`.
            pub fn stderr(config: PrepareConfig) -> io::Result<Screen> { api::Screen::stderr(config).map(Screen) }
            /// Begins a new screen session using the given `Terminal` instance.
            pub fn with_terminal(term: Terminal, config: PrepareConfig) -> io::Result<Screen> { api::Screen::new(term.0, config).map(Screen) }
            /// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str { self.0.name() }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<ScreenReadGuard> { map_lock_result(self.0.lock_read(), ScreenReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> { map_lock_result(self.0.lock_write(), ScreenWriteGuard) }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> { map_try_lock_result(self.0.try_lock_read(), ScreenReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> { map_try_lock_result(self.0.try_lock_write(), ScreenWriteGuard) }
        }
        /// # Locking
        /// The following methods internally acquire the read lock.
        impl Screen
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_event(timeout) }
        }
        /// # Locking
        /// The following methods internally acquire the write lock.
        impl Screen
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size { self.0.size() }
            /// Returns the current cursor position.
            #[inline] pub fn cursor(&self) -> Cursor { self.0.cursor() }
            /// Sets the cursor position.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&self, pos: C) { self.0.set_cursor(pos.into()); }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn next_line(&self, column: usize) { self.0.next_line(column); }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Clears the internal screen buffer.
            pub fn clear_screen(&self) { self.0.clear_screen(); }
            /// Adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&self, style: Style) { self.0.add_style(style); }
            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn remove_style(&self, style: Style) { self.0.remove_style(style); }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&self, style: S) { self.0.set_style(style.into().unwrap_or_default()); }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) { self.0.set_fg(fg.into()); }
            /// Sets or removes background text color.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) { self.0.set_bg(bg.into()); }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&self, theme: Theme) { self.0.set_theme(theme) }
            /// Removes color and style attributes.
            #[inline] pub fn clear_attributes(&self) { self.0.clear_attributes(); }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&self) { self.add_style(Style::BOLD); }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&self) { self.add_style(Style::ITALIC); }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&self) { self.add_style(Style::UNDERLINE); }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&self) { self.add_style(Style::REVERSE); }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&self) -> io::Result<()> { self.0.refresh() }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&self, position: C, text: &str) where 
            C: Into<Cursor>
            { self.0.write_at(position.into(), text); }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            { self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text); }
            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&self, position: C, fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            {
                self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text);
            }
            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&self, ch: char) { self.0.write_char(ch); }
            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&self, s: &str) { self.0.write_str(s); }
            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments)
            {
                let s = args.to_string();
                self.write_str(&s) 
            }

            pub fn borrow_term_write_guard(&self) -> ScreenWriteGuard { self.lock_write().unwrap() }
        }

        impl<'a> ScreenReadGuard<'a>
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool>
            { self.0.wait_event(timeout) }
            /// Reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_event(timeout) }
        }

        impl<'a> ScreenWriteGuard<'a>
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size { self.0.size() }
            /// Sets the cursor position.
            #[inline] pub fn cursor(&self) -> Cursor { self.0.cursor() }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&mut self, pos: C) { self.0.set_cursor(pos.into()); }
            /// Set the current cursor mode.
            #[inline] pub fn next_line(&mut self, column: usize) { self.0.next_line(column); }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn clear_screen(&mut self) { self.0.clear_screen(); }
            /// Removes a set of `Style` flags to the current style setting.
            /// Adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&mut self, style: Style) { self.0.add_style(style) }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn remove_style(&mut self, style: Style) { self.0.remove_style(style) }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&mut self, style: S) { self.0.set_style(style.into().unwrap_or_default()) }
            /// Sets or removes background text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) { self.0.set_fg(fg.into()) }
            /// Removes color and style attributes.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) { self.0.set_bg(bg.into()) }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&mut self, theme: Theme) { self.0.set_theme(theme) }
            /// Adds bold to the current style setting.
            #[inline] pub fn clear_attributes(&mut self) { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&mut self) { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&mut self) { self.add_style(Style::ITALIC); }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&mut self) { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&mut self) { self.add_style(Style::REVERSE) }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&mut self) -> io::Result<()> { self.0.refresh() }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&mut self, position: C, text: &str) where
            C: Into<Cursor> 
            { self.0.write_at(position.into(), text) }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            { self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text) }
            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&mut self, position: C, fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text) }
            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&mut self, ch: char) { self.0.write_char(ch) }
            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&mut self, s: &str) { self.0.write_str(s) }
            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments)
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&mut self) -> &mut Self { self }
        }

        #[cfg(unix)]
        impl system::api::TerminalExt for Screen
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }
        }

        #[cfg(unix)]
        impl<'a> system::api::TerminalExt for ScreenReadGuard<'a>
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }
        }

        #[cfg(windows)]
        impl system::api::TerminalExt for Screen
        {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }

            fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD], timeout: Option<Duration>) ->
            io::Result<Option<Event>>
            { self.0.read_raw_event(events, timeout) }
        }

        #[cfg(windows)]
        impl<'a> system::api::TerminalExt for ScreenReadGuard<'a>
        {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }

            fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD], timeout: Option<Duration>) ->
            io::Result<Option<Event>> 
            { self.0.read_raw_event(events, timeout) }
        }
    } pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };
    
    pub mod signal
    {
        //! Contains types relating to operating system signals
        use ::
        {
            iter::{ FromIterator },
            *,
        };

        pub const NUM_SIGNALS: u8 = 6;

        macro_rules! impl_op
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) =>
            {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self, rhs: SignalSet) -> SignalSet {
                        self.$method(rhs)
                    }
                }
            }
        }

        macro_rules! impl_mut_op
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    fn $tr_meth(&mut self, rhs: SignalSet) {
                        *self = self.$method(rhs);
                    }
                }
            }
        }

        macro_rules! impl_unary_op
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self) -> SignalSet {
                        self.$method()
                    }
                }
            }
        }
        /// Signal received through a terminal device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Signal
        {
            /// Break signal (`CTRL_BREAK_EVENT`); Windows only
            Break,
            /// Continue signal (`SIGCONT`); Unix only
            Continue,
            /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
            Interrupt,
            /// Terminal window resize (`SIGWINCH` on Unix, `WINDOW_BUFFER_SIZE_EVENT` on Windows).
            Resize,
            /// Suspend signal (`SIGTSTP`); Unix only
            Suspend,
            /// Quit signal (`SIGQUIT`); Unix only
            Quit,
        }

        impl Signal
        {
            fn as_bit(&self) -> u8 { 1 << (*self as u8) }
            fn all_bits() -> u8 { (1 << NUM_SIGNALS) - 1 }
        }

        impl ops::BitOr for Signal
        {
            type Output = SignalSet;
            fn bitor(self, rhs: Signal) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.insert(self);
                set.insert(rhs);
                set
            }
        }

        impl ops::Not for Signal
        {
            type Output = SignalSet;

            fn not(self) -> SignalSet { !SignalSet::from(self) }
        }
        /// Represents a set of `Signal` values
        #[derive(Copy, Clone, Default, Eq, PartialEq)]
        pub struct SignalSet(u8);

        impl SignalSet
        {
            /// Returns an empty `SignalSet`.
            pub fn new() -> SignalSet { SignalSet(0) }
            /// Returns a `SignalSet` containing all available signals.
            pub fn all() -> SignalSet { SignalSet(Signal::all_bits()) }
            /// Returns whether this set contains the given `Signal`.
            pub fn contains(&self, sig: Signal) -> bool { self.0 & sig.as_bit() != 0 }
            /// Returns whether this set contains all signals present in another set.
            pub fn contains_all(&self, other: SignalSet) -> bool { self.0 & other.0 == other.0 }
            /// Returns whether this set contains any signals present in another set.
            pub fn intersects(&self, other: SignalSet) -> bool { self.0 & other.0 != 0 }
            /// Returns whether this set contains any signals.
            pub fn is_empty(&self) -> bool { self.0 == 0 }
            /// Inserts a `Signal` into this set.
            pub fn insert(&mut self, sig: Signal) { self.0 |= sig.as_bit(); }
            /// Removes a `Signal` from this set.
            pub fn remove(&mut self, sig: Signal) { self.0 &= !sig.as_bit(); }
            /// Sets whether this set contains the given `Signal`.
            pub fn set(&mut self, sig: Signal, set: bool) { if set { self.insert(sig); } else { self.remove(sig); } }
            /// Returns the difference of two sets.
            pub fn difference(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 & !other.0) }
            /// Returns the symmetric difference of two sets.
            pub fn symmetric_difference(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 ^ other.0) }
            /// Returns the intersection of two sets.
            pub fn intersection(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 & other.0) }
            /// Returns the union of two sets.
            pub fn union(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 | other.0) }
            /// Returns the inverse of the set.
            pub fn inverse(&self) -> SignalSet { SignalSet(!self.0 & Signal::all_bits()) }
        }

        impl fmt::Debug for SignalSet
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                const SIGNALS: &[Signal] = &[
                    Signal::Break,
                    Signal::Continue,
                    Signal::Interrupt,
                    Signal::Resize,
                    Signal::Suspend,
                    Signal::Quit,
                ];

                let mut first = true;

                f.write_str("SignalSet(")?;

                for &sig in SIGNALS {
                    if self.contains(sig) {
                        if !first {
                            f.write_str(" | ")?;
                        }

                        write!(f, "{:?}", sig)?;
                        first = false;
                    }
                }

                f.write_str(")")
            }
        }

        impl From<Signal> for SignalSet
        {
            fn from(sig: Signal) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.insert(sig);
                set
            }
        }

        impl Extend<Signal> for SignalSet
        {
            fn extend<I: IntoIterator<Item=Signal>>(&mut self, iter: I)
            {
                for sig in iter {
                    self.insert(sig);
                }
            }
        }

        impl FromIterator<Signal> for SignalSet
        {
            fn from_iter<I: IntoIterator<Item=Signal>>(iter: I) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.extend(iter);
                set
            }
        }

        impl_op!{ BitAnd, bitand, intersection }
        impl_op!{ BitOr, bitor, union }
        impl_op!{ BitXor, bitxor, symmetric_difference }
        impl_op!{ Sub, sub, difference }

        impl_unary_op!{ Not, not, inverse }

        impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
        impl_mut_op!{ BitOrAssign, bitor_assign, union }
        impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
        impl_mut_op!{ SubAssign, sub_assign, difference }
    } pub use self::signal::{ Signal, SignalSet };
    
    pub mod terminal
    {
        //! Provides an interface to terminal devices
        use ::
        {
            system::
            {
                signal::{ Signal, SignalSet },
            },
            *,
        };
        /*
        use std::fmt;
        use std::io;
        use std::sync::{LockResult, TryLockResult};
        use std::time::Duration;

        use ::priv_util::{map_lock_result, map_try_lock_result};
        use ::sys;
        */

        /// Represents a color attribute applied to text foreground or background.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Color
        {
            /// Black
            Black,
            /// Blue
            Blue,
            /// Cyan
            Cyan,
            /// Green
            Green,
            /// Magenta
            Magenta,
            /// Red
            Red,
            /// White
            White,
            /// Yellow
            Yellow,
        }

        bitflags!
        {
            /// Represents a set of style attributes applied to text.
            #[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
            pub struct Style: u8
            {
                /// Bold
                const BOLD      = 1 << 0;
                /// Italic
                const ITALIC    = 1 << 1;
                /// Reverse; foreground and background color swapped
                const REVERSE   = 1 << 2;
                /// Underline
                const UNDERLINE = 1 << 3;
            }
        }
        /// Represents a terminal output theme.
        #[derive(Copy, Clone, Debug, Default)]
        pub struct Theme
        {
            /// Foreground color
            pub fg: Option<Color>,
            /// Background color
            pub bg: Option<Color>,
            /// Style
            pub style: Style,
        }

        impl Theme
        {
            /// Creates a new theme with given values.
            pub fn new<F,B,S>(fg: F, bg: B, style: S) -> Theme where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>
            {
                Theme
                {
                    fg: fg.into(),
                    bg: bg.into(),
                    style: style.into().unwrap_or_default(),
                }
            }
            /// Sets the foreground color on the given Theme and returns the new.
            pub fn fg<F>(mut self, fg: F) -> Theme where 
            F: Into<Option<Color>>
            {
                self.fg = fg.into();
                self
            }
            /// Sets the background color on the given Theme and returns the new.
            pub fn bg<B>(mut self, bg: B) -> Theme where 
            B: Into<Option<Color>> 
            {
                self.bg = bg.into();
                self
            }
            /// Sets the style on the given Theme and returns the new.
            pub fn style<S>(mut self, style: S) -> Theme where 
            S: Into<Option<Style>>
            {
                self.style = style.into().unwrap_or_default();
                self
            }
        }
        /// Represents a keyboard key press event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Key
        {
            /// Backspace
            Backspace,
            /// Enter
            Enter,
            /// Escape
            Escape,
            /// Tab
            Tab,
            /// Up arrow
            Up,
            /// Down arrow
            Down,
            /// Left arrow
            Left,
            /// Right arrow
            Right,
            /// Delete
            Delete,
            /// Insert
            Insert,
            /// Home
            Home,
            /// End
            End,
            /// PageUp
            PageUp,
            /// PageDown
            PageDown,
            /// Character key
            Char(char),
            /// Control character.
            Ctrl(char),
            /// Function `n` key; e.g. F1, F2, ...
            F(u32),
        }

        impl From<char> for Key
        {
            fn from(ch: char) -> Key
            {
                use ::char::unctrl_lower;
                match ch
                {
                    '\x1b' => Key::Escape,
                    '\x7f' => Key::Backspace,
                    '\r' | '\n' => Key::Enter,
                    '\t' => Key::Tab,
                    _ if is::ctrl(ch) => Key::Ctrl( unctrl_lower(ch) ),
                    _ => Key::Char(ch),
                }
            }
        }
        /// Represents the cursor position in a terminal device
        #[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
        pub struct Cursor
        {
            /// Index of line in terminal, beginning at `0`.
            pub line: usize,
            /// Index of column in terminal, beginning at `0`.
            pub column: usize,
        }

        impl Cursor
        {
            /// Returns the position of the next cell within a terminal of the given size.
            #[inline] pub fn next(&self, size: Size) -> Option<Cursor>
            {
                let mut line = self.line;
                let mut column = self.column + 1;

                if column >= size.columns
                {
                    column = 0;
                    line += 1;
                }

                if line >= size.lines { None } else { Some(Cursor{line, column}) }
            }
            /// Returns the position of the previous cell within a terminal of the given size.
            #[inline] pub fn previous(&self, size: Size) -> Option<Cursor>
            {
                if self.column == 0
                {
                    if self.line == 0 { None } else { Some(Cursor{line: self.line - 1, column: size.columns - 1}) }
                }
                else { Some(Cursor{line: self.line, column: self.column - 1}) }
            }
            /// Returns a `Cursor` pointing to the first cell, i.e. `(0, 0)`.
            #[inline] pub fn first() -> Cursor
            {
                Cursor
                {
                    line: 0,
                    column: 0,
                }
            }
            /// Returns a `Cursor` pointing to the last cell of a screen of the given size.
            #[inline] pub fn last(size: Size) -> Cursor
            {
                Cursor
                {
                    line: size.lines - 1,
                    column: size.columns - 1,
                }
            }
            /// Returns whether the cursor is out of bounds of the given size.
            #[inline] pub fn is_out_of_bounds(&self, size: Size) -> bool
            { self.line >= size.lines || self.column >= size.columns }
            /// Returns the index of the cursor position within a one-dimensional array of the given size.
            pub fn as_index(&self, size: Size) -> usize { self.line * size.columns + self.column }
        }

        impl From<(usize, usize)> for Cursor
        {
            /// Returns a `Cursor` value from a `(line, column)` or `(y, x)` tuple.
            fn from((line, column): (usize, usize)) -> Cursor { Cursor{line, column} }
        }
        /// Represents the visual appearance of the cursor in the terminal.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum CursorMode
        {
            /// Normal mode
            Normal,
            /// Invisible mode
            Invisible,
            /// Overwrite mode
            Overwrite,
        }
        /// Represents a button on a mouse device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseButton
        {
            /// Left mouse button
            Left,
            /// Right mouse button
            Right,
            /// Middle mouse button
            Middle,
            /// Other mouse button
            Other(u32),
        }
        /// Represents the type of mouse input event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseInput
        {
            /// The mouse cursor was moved
            Motion,
            /// A mouse button was pressed
            ButtonPressed(MouseButton),
            /// A mouse button was released
            ButtonReleased(MouseButton),
            /// The mouse wheel was scrolled up
            WheelUp,
            /// The mouse wheel was scrolled down
            WheelDown,
        }

        bitflags!
        {
            /// Represents a set of modifier keys
            #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
            pub struct ModifierState: u8
            {
                /// Alt key
                const ALT   = 1 << 0;
                /// Ctrl key
                const CTRL  = 1 << 1;
                /// Shift key
                const SHIFT = 1 << 2;
            }
        }
        /// Represents a mouse event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Mouse
        {
            /// The position of the mouse within the terminal when the event occurred
            pub position: Cursor,
            /// The input event that occurred
            pub input: MouseInput,
            /// Modifier keys held when the input event occurred.
            pub modifiers: ModifierState,
        }
        /// Represents an event generated from a terminal interface
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Event
        {
            /// Keyboard event
            Key( Key ),
            /// Mouse event
            Mouse( Mouse ),
            /// Raw data read
            Raw( usize ),
            /// Terminal window size changed; contained value is the new size.
            Resize( Size ),
            /// Terminal signal received
            Signal( Signal ),
            /// No event.
            NoEvent,
        }
        /// Represents the size of a terminal window.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Size
        {
            /// Number of lines in the terminal
            pub lines: usize,
            /// Number of columns in the terminal
            pub columns: usize,
        }

        impl Size
        {
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn area(&self) -> usize
            { self.checked_area().unwrap_or_else( || panic!("overflow in Size::area {:?}", self)) }
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn checked_area(&self) -> Option<usize> { self.lines.checked_mul(self.columns) }
        }
    }
    pub use self::terminal::
    { 
        Color, Cursor, CursorMode, Size, Style, Theme, Event, Key, Mouse, MouseInput, MouseButton, ModifierState
    };

    pub mod variable
    {
        //! Contains types associated with user-configurable variables
        use ::
        {
            borrow::{ Cow },
            mem::{ replace },
            time::{ Duration },
            *,
        };

        macro_rules! define_variables
        {
            ( $( $field:ident : $ty:ty => ( $name:expr , $conv:ident ,
                    |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , )+ ) => {
                static VARIABLE_NAMES: &[&str] = &[ $( $name ),+ ];

                pub struct Variables {
                    $( pub $field : $ty ),*
                }

                impl Variables {
                    pub fn get_variable(&self, name: &str) -> Option<Variable> {
                        match name {
                            $( $name => {
                                let $gr = self;
                                Some(Variable::from($getter))
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable(&mut self, name: &str, value: &str)
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some($v) = $conv(value) {
                                    let $sr = self;
                                    Some(Variable::from($setter))
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter(&self) -> VariableIter {
                        VariableIter{vars: self, n: 0}
                    }
                }

                impl<'a> Iterator for VariableIter<'a> {
                    type Item = (&'static str, Variable);

                    fn next(&mut self) -> Option<Self::Item> {
                        let res = match VARIABLE_NAMES.get(self.n).cloned() {
                            $( Some($name) => ($name, {
                                let $gr = self.vars;
                                Variable::from($getter)
                            }) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some(res)
                    }
                }
            }
        }
        /// Default `keyseq_timeout`, in milliseconds
        pub const KEYSEQ_TIMEOUT_MS: u64 = 500;
        /// Iterator over `Reader` variable values
        #[derive(Clone)]
        pub struct VariableIter<'a>
        {
            vars: &'a Variables,
            n: usize,
        }
        /// Represents a `Reader` variable of a given type
        #[derive(Clone, Debug)]
        pub enum Variable
        {
            /// Boolean variable
            Boolean(bool),
            /// Integer variable
            Integer(i32),
            /// String variable
            String(Cow<'static, str>),
        }

        impl From<bool> for Variable
        {
            fn from(b: bool) -> Variable { Variable::Boolean(b) }
        }

        impl From<i32> for Variable
        {
            fn from(i: i32) -> Variable { Variable::Integer(i) }
        }

        impl From<&'static str> for Variable 
        {
            fn from(s: &'static str) -> Variable { Variable::String(s.into()) }
        }

        impl From<Cow<'static, str>> for Variable 
        {
            fn from(s: Cow<'static, str>) -> Variable { Variable::String(s) }
        }

        impl From<String> for Variable 
        {
            fn from(s: String) -> Variable { Variable::String(s.into()) }
        }

        impl fmt::Display for Variable 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                match *self
                {
                    Variable::Boolean(b) => f.write_str(if b { "on" } else { "off" }),
                    Variable::Integer(n) => fmt::Display::fmt(&n, f),
                    Variable::String(ref s) => fmt::Display::fmt(&s[..], f),
                }
            }
        }

        define_variables!{
            blink_matching_paren: bool => ("blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace(&mut r.blink_matching_paren, v)),
            comment_begin: Cow<'static, str> => ("comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace(&mut r.comment_begin, v.into())),
            completion_display_width: usize => ("completion-display-width", parse_usize,
                |r| usize_as_i32(r.completion_display_width),
                |r, v| usize_as_i32(replace(&mut r.completion_display_width, v))),
            completion_query_items: usize => ("completion-query-items", parse_usize,
                |r| usize_as_i32(r.completion_query_items),
                |r, v| usize_as_i32(replace(&mut r.completion_query_items, v))),
            disable_completion: bool => ("disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace(&mut r.disable_completion, v)),
            echo_control_characters: bool => ("echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace(&mut r.echo_control_characters, v)),
            keyseq_timeout: Option<Duration> => ("keyseq-timeout", parse_duration,
                |r| as_millis(r.keyseq_timeout),
                |r, v| as_millis(replace(&mut r.keyseq_timeout, v))),
            page_completions: bool => ("page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace(&mut r.page_completions, v)),
            print_completions_horizontally: bool => ("print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace(&mut r.print_completions_horizontally, v)),
        }

        impl Default for Variables
        {
            fn default() -> Variables
            {
                Variables
                {
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    keyseq_timeout: Some(Duration::from_millis(KEYSEQ_TIMEOUT_MS)),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool(s: &str) -> Option<bool>
        {
            match s
            {
                "0" => Some(false),
                "1" => Some(true),
                s if s.eq_ignore_ascii_case("off") => Some(false),
                s if s.eq_ignore_ascii_case("on") => Some(true),
                _ => None
            }
        }

        fn parse_string(s: &str) -> Option<String> { Some(s.to_owned()) }

        fn as_millis(timeout: Option<Duration>) -> i32
        {
            match timeout
            {
                Some(t) =>
                {
                    let s = (t.as_secs() * 1_000) as i32;
                    let ms = (t.subsec_nanos() / 1_000_000) as i32;

                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration(s: &str) -> Option<Option<Duration>> 
        {
            match s.parse::<i32>() 
            {
                Ok(n) if n <= 0 => Some(None),
                Ok(n) => Some(Some(Duration::from_millis(n as u64))),
                Err(_) => Some(None)
            }
        }

        fn usize_as_i32(u: usize) -> i32 
        {
            match u 
            {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize(s: &str) -> Option<usize> 
        {
            match s.parse::<i32>() 
            {
                Ok(n) if n < 0 => Some(usize::max_value()),
                Ok(n) => Some(n as usize),
                Err(_) => None
            }
        }
    }

    pub mod unix
    {
        macro_rules! impl_is_minus_one
        {
            ($($t:ident)*) => ($(impl IsMinusOne for $t
            {
                fn is_minus_one(&self) -> bool { *self == -1 }
            })*)
        }

        pub mod ext
        {
            //! Unix extension trait
            use ::
            {
                path::{ Path },
                system::{ Private },
                time::{ Duration },
                *,
            };
            /*
            use ::terminal::Event;
            */
            /// Implements Unix-only extensions for terminal interfaces.
            pub trait OpenTerminalExt: Sized + Private
            {
                /// Opens a terminal interface on the device at the given path.
                fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self>;
            }

            /// Implements Unix-only extensions for terminal interfaces.
            pub trait TerminalExt: Private 
            {
                /// Reads raw data from the terminal.
                fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>;
            }
        }

        mod terminal
        {
            use ::
            {
                collections::{ FindResult, SequenceMap },
                convert::{ TryFrom },
                fs::{ File },
                libc::{ ioctl, c_int, c_ushort, termios, STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, TIOCGWINSZ },
                mem::{ replace, zeroed },
                nix::
                {
                    errno::{ Errno },
                    sys::
                    {
                        signal::{ sigaction, SaFlags, SigAction, SigHandler, Signal as NixSignal, SigSet, },
                        termios::{ tcgetattr, tcsetattr, SetArg, InputFlags, LocalFlags, },
                        time::{ TimeVal, TimeValLike },
                    },
                    unistd::{ read, write },
                },
                os::unix::io::{ FromRawFd, IntoRawFd, RawFd },
                path::{ Path },
                str::{ from_utf8, SmallString },
                sync::
                {
                    atomic::{ AtomicUsize, Ordering },
                    LockResult, Mutex, MutexGuard, TryLockResult,
                },
                system::
                {
                    signal::{ Signal, SignalSet },
                    terminal::{ Color, Cursor, CursorMode, Event, Key, Size, Style, Theme, MouseButton, Mouse, MouseInput, ModifierState },
                },
                *,
            };
            /*
            use terminfo::{self, capability as cap, Database};
            use terminfo::capability::Expansion;
            use terminfo::expand::Context;
            */
            pub const OUT_BUFFER_SIZE: usize = 8192;
            pub const XTERM_ENABLE_MOUSE: &str = "\x1b[?1006h\x1b[?1002h";
            pub const XTERM_DISABLE_MOUSE: &str = "\x1b[?1006l\x1b[?1002l";
            pub const XTERM_ENABLE_MOUSE_MOTION: &str = "\x1b[?1003h";
            pub const XTERM_DISABLE_MOUSE_MOTION: &str = "\x1b[?1003l";
            pub const XTERM_MOUSE_INTRO: &str = "\x1b[<";
            pub const XTERM_SHIFT_MASK: u32 = 0x04;
            pub const XTERM_META_MASK: u32  = 0x08;
            pub const XTERM_CTRL_MASK: u32  = 0x10;
            pub const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;

            pub type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

            #[derive(Copy, Clone)]
            enum SeqData
            {
                XTermMouse,
                Key(Key),
            }

            pub struct Terminal {
                info: Database,
                out_fd: RawFd,
                in_fd: RawFd,
                owned_fd: bool,
                sequences: SeqMap,
                reader: Mutex<Reader>,
                writer: Mutex<Writer>,
            }

            pub struct TerminalReadGuard<'a> {
                term: &'a Terminal,
                reader: MutexGuard<'a, Reader>,
            }

            pub struct TerminalWriteGuard<'a> {
                term: &'a Terminal,
                writer: MutexGuard<'a, Writer>,
            }

            struct Reader {
                in_buffer: Vec<u8>,
                resume: Option<Resume>,
                report_signals: SignalSet,
            }

            struct Writer {
                context: Context,
                out_buffer: Vec<u8>,
                fg: Option<Color>,
                bg: Option<Color>,
                cur_style: Style,
            }

            impl Terminal {
                fn new(in_fd: RawFd, out_fd: RawFd, owned_fd: bool) -> io::Result<Terminal> {
                    let info = Database::from_env().map_err(ti_to_io)?;
                    let sequences = sequences(&info);

                    Ok(Terminal{
                        info,
                        in_fd,
                        out_fd,
                        owned_fd,
                        sequences,
                        reader: Mutex::new(Reader{
                            in_buffer: Vec::new(),
                            resume: None,
                            report_signals: SignalSet::new(),
                        }),
                        writer: Mutex::new(Writer::new()),
                    })
                }

                pub fn open<P: AsRef<Path>>(path: P) -> io::Result<Terminal> {
                    let fd = open_rw(path)?;

                    let r = Terminal::new(fd, fd, true);

                    if r.is_err() {
                        unsafe { close_fd(fd); }
                    }

                    r
                }

                pub fn stdout() -> io::Result<Terminal> {
                    Terminal::new(STDIN_FILENO, STDOUT_FILENO, false)
                }

                pub fn stderr() -> io::Result<Terminal> {
                    Terminal::new(STDIN_FILENO, STDERR_FILENO, false)
                }

                pub fn name(&self) -> &str {
                    self.info.name()
                }

                fn is_xterm(&self) -> bool {
                    is_xterm(self.name())
                }

                pub fn size(&self) -> io::Result<Size> {
                    self.lock_writer().size()
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn enter_screen(&self) -> io::Result<()> {
                    self.lock_writer().enter_screen()
                }

                pub fn exit_screen(&self) -> io::Result<()> {
                    self.lock_writer().exit_screen()
                }

                pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> {
                    self.lock_reader().prepare(config)
                }

                pub fn restore(&self, state: PrepareState) -> io::Result<()> {
                    self.lock_reader().restore(state)
                }

                pub fn clear_screen(&self) -> io::Result<()> {
                    self.lock_writer().clear_screen()
                }

                pub fn clear_to_line_end(&self) -> io::Result<()> {
                    self.lock_writer().clear_to_line_end()
                }

                pub fn clear_to_screen_end(&self) -> io::Result<()> {
                    self.lock_writer().clear_to_screen_end()
                }

                pub fn move_up(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_up(n)?;
                    }
                    Ok(())
                }

                pub fn move_down(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_down(n)?;
                    }
                    Ok(())
                }

                pub fn move_left(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_left(n)?;
                    }
                    Ok(())
                }

                pub fn move_right(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_right(n)?;
                    }
                    Ok(())
                }

                pub fn move_to_first_column(&self) -> io::Result<()> {
                    self.lock_writer().move_to_first_column()
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                    self.lock_writer().set_cursor_mode(mode)
                }

                pub fn write_char(&self, ch: char) -> io::Result<()> {
                    self.write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&self, s: &str) -> io::Result<()> {
                    self.lock_writer().write_str(s)
                }

                pub fn write_styled(&self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.lock_writer().write_styled(fg, bg, style, text)
                }

                pub fn clear_attributes(&self) -> io::Result<()> {
                    self.lock_writer().clear_attributes()
                }

                pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> {
                    self.lock_writer().set_fg(fg)
                }

                pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> {
                    self.lock_writer().set_bg(bg)
                }

                pub fn add_style(&self, style: Style) -> io::Result<()> {
                    self.lock_writer().add_style(style)
                }

                pub fn remove_style(&self, style: Style) -> io::Result<()> {
                    self.lock_writer().remove_style(style)
                }

                pub fn set_style(&self, style: Style) -> io::Result<()> {
                    self.lock_writer().set_style(style)
                }

                pub fn set_theme(&self, theme: Theme) -> io::Result<()> {
                    self.lock_writer().set_theme(theme)
                }

                pub fn lock_read(&self) -> LockResult<TerminalReadGuard> {
                    map_lock_result(self.reader.lock(),
                        |r| TerminalReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> {
                    map_lock_result(self.writer.lock(),
                        |w| TerminalWriteGuard::new(self, w))
                }

                pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard> {
                    map_try_lock_result(self.reader.try_lock(),
                        |r| TerminalReadGuard::new(self, r))
                }

                pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard> {
                    map_try_lock_result(self.writer.try_lock(),
                        |w| TerminalWriteGuard::new(self, w))
                }

                fn lock_reader(&self) -> TerminalReadGuard {
                    self.lock_read().expect("Terminal::lock_reader")
                }

                fn lock_writer(&self) -> TerminalWriteGuard {
                    self.lock_write().expect("Terminal::lock_writer")
                }
            }

            impl Drop for Terminal {
                fn drop(&mut self) {
                    if let Err(e) = self.set_cursor_mode(CursorMode::Normal) {
                        eprintln!("failed to restore terminal: {}", e);
                    }

                    if self.owned_fd {
                        unsafe { close_fd(self.out_fd); }
                    }
                }
            }

            impl<'a> TerminalReadGuard<'a> {
                fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> {
                    TerminalReadGuard{term, reader}
                }

                pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState> {
                    let mut writer = self.term.lock_writer();
                    self.prepare_with_lock(&mut writer, config)
                }

                pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuard,
                        config: PrepareConfig) -> io::Result<PrepareState> {
                    use nix::sys::termios::SpecialCharacterIndices::*;

                    let old_tio = tcgetattr(self.term.in_fd).map_err(nix_to_io)?;
                    let mut tio = old_tio.clone();

                    let mut state = PrepareState{
                        old_tio: old_tio.into(),
                        old_sigcont: None,
                        old_sigint: None,
                        old_sigtstp: None,
                        old_sigquit: None,
                        old_sigwinch: None,
                        restore_keypad: false,
                        restore_mouse: false,
                        prev_resume: self.reader.resume,
                    };

                    tio.input_flags.remove(
                        // Disable carriage return/line feed conversion
                        InputFlags::INLCR | InputFlags::ICRNL
                    );

                    tio.local_flags.remove(
                        // Disable canonical mode;
                        // this gives us input without waiting for newline or EOF
                        // and disables line-editing, treating such inputs as characters.
                        // Disable ECHO, preventing input from being written to output.
                        LocalFlags::ICANON | LocalFlags::ECHO
                    );

                    // ISIG, when enabled, causes the process to receive signals when
                    // Ctrl-C, Ctrl-\, etc. are input
                    if config.block_signals {
                        tio.local_flags.remove(LocalFlags::ISIG);
                    } else {
                        tio.local_flags.insert(LocalFlags::ISIG);
                    }

                    // IXON, when enabled, allows Ctrl-S/Ctrl-Q to suspend and restart inputs
                    if config.enable_control_flow {
                        tio.input_flags.insert(InputFlags::IXON);
                    } else {
                        tio.input_flags.remove(InputFlags::IXON);
                    }

                    // Allow a read to return with 0 characters ready
                    tio.control_chars[VMIN as usize] = 0;
                    // Allow a read to return after 0 deciseconds
                    tio.control_chars[VTIME as usize] = 0;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &tio).map_err(nix_to_io)?;

                    if config.enable_mouse {
                        if writer.enable_mouse(config.always_track_motion)? {
                            state.restore_mouse = true;
                        }
                    }

                    if config.enable_keypad {
                        if writer.enable_keypad()? {
                            state.restore_keypad = true;
                        }
                    }

                    writer.flush()?;

                    let action = SigAction::new(SigHandler::Handler(handle_signal),
                        SaFlags::empty(), SigSet::all());

                    // Continue and Resize are always handled by the internals,
                    // but only reported if requested.
                    state.old_sigcont = Some(unsafe { sigaction(NixSignal::SIGCONT, &action).map_err(nix_to_io)? });
                    state.old_sigwinch = Some(unsafe { sigaction(NixSignal::SIGWINCH, &action).map_err(nix_to_io)? });

                    if config.report_signals.contains(Signal::Interrupt) {
                        state.old_sigint = Some(unsafe { sigaction(NixSignal::SIGINT, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Suspend) {
                        state.old_sigtstp = Some(unsafe { sigaction(NixSignal::SIGTSTP, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Quit) {
                        state.old_sigquit = Some(unsafe { sigaction(NixSignal::SIGQUIT, &action).map_err(nix_to_io)? });
                    }

                    self.reader.report_signals = config.report_signals;
                    self.reader.resume = Some(Resume{config});

                    Ok(state)
                }

                pub fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                    let mut writer = self.term.lock_writer();
                    self.restore_with_lock(&mut writer, state)
                }

                pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard,
                        state: PrepareState) -> io::Result<()> {
                    self.reader.resume = state.prev_resume;

                    if state.restore_mouse {
                        writer.disable_mouse()?;
                    }

                    if state.restore_keypad {
                        writer.disable_keypad()?;
                    }

                    writer.flush()?;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &state.old_tio.into()).map_err(nix_to_io)?;

                    unsafe {
                        if let Some(ref old) = state.old_sigcont {
                            sigaction(NixSignal::SIGCONT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigint {
                            sigaction(NixSignal::SIGINT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigtstp {
                            sigaction(NixSignal::SIGTSTP, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigquit {
                            sigaction(NixSignal::SIGQUIT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigwinch {
                            sigaction(NixSignal::SIGWINCH, old).map_err(nix_to_io)?;
                        }
                    }

                    Ok(())
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    if get_signal().is_some() {
                        return Ok(true);
                    }

                    if peek_event(&self.reader.in_buffer, &self.term.sequences)?.is_some() {
                        return Ok(true);
                    }

                    let mut timeout = timeout.map(to_timeval);

                    let n = loop {
                        let in_fd = self.term.in_fd;

                        let mut r_fds = FdSet::new();
                        r_fds.insert(in_fd);

                        // FIXME: FdSet does not implement Copy or Clone
                        let mut e_fds = FdSet::new();
                        e_fds.insert(in_fd);

                        match select(in_fd + 1,
                                Some(&mut r_fds), None, Some(&mut e_fds), timeout.as_mut()) {
                            Ok(n) => break n,
                            Err(Errno::EINTR) =>
                                if get_signal().is_some() {
                                    return Ok(true);
                                }
                            
                            Err(e) => return Err(nix_to_io(e))
                        }
                    };

                    Ok(n != 0)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if let Some(ev) = self.try_read()? {
                        return Ok(Some(ev));
                    }

                    match self.read_into_buffer(timeout)? {
                        Some(Event::Raw(_)) => self.try_read(),
                        Some(Event::Signal(sig)) => {
                            if let Some(ev) = self.handle_signal(sig)? {
                                Ok(Some(ev))
                            } else {
                                Ok(None)
                            }
                        }
                        r => Ok(r)
                    }
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if !self.reader.in_buffer.is_empty() {
                        let n = buf.len().min(self.reader.in_buffer.len());
                        buf[..n].copy_from_slice(&self.reader.in_buffer[..n]);

                        let _ = self.reader.in_buffer.drain(..n);

                        return Ok(Some(Event::Raw(n)));
                    }

                    match self.read_input(buf, timeout)? {
                        Some(Event::Signal(sig)) => {
                            if let Some(event) = self.handle_signal(sig)? {
                                Ok(Some(event))
                            } else {
                                Ok(None)
                            }
                        }
                        r => Ok(r)
                    }
                }

                fn read_into_buffer(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    // Temporarily replace the buffer to prevent borrow errors
                    let mut buf = replace(&mut self.reader.in_buffer, Vec::new());

                    buf.reserve(128);

                    let len = buf.len();
                    let cap = buf.capacity();
                    let r;

                    unsafe {
                        buf.set_len(cap);

                        r = self.read_input(&mut buf[len..], timeout);

                        match r {
                            Ok(Some(Event::Raw(n))) => buf.set_len(len + n),
                            _ => buf.set_len(len)
                        }
                    }

                    // Restore the buffer before returning
                    self.reader.in_buffer = buf;

                    r
                }

                fn read_input(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    // Check for a signal that may have already arrived.
                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }

                    // Check for a signal again after waiting
                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    loop {
                        match read(self.term.in_fd, buf) {
                            Ok(n) => break Ok(Some(Event::Raw(n))),
                            Err(Errno::EINTR) => {
                                if let Some(sig) = take_signal() {
                                    return Ok(Some(Event::Signal(sig)));
                                }
                            }
                            Err(e) => return Err(nix_to_io(e))
                        }
                    }
                }

                fn try_read(&mut self) -> io::Result<Option<Event>> {
                    let in_buffer = &mut self.reader.in_buffer;

                    if in_buffer.is_empty() {
                        Ok(None)
                    } else {
                        match peek_event(&in_buffer, &self.term.sequences) {
                            Ok(Some((ev, n))) => {
                                let _ = in_buffer.drain(..n);
                                Ok(Some(ev))
                            }
                            Ok(None) => Ok(None),
                            Err(e) => Err(e)
                        }
                    }
                }

                fn handle_signal(&mut self, sig: Signal) -> io::Result<Option<Event>> {
                    match sig {
                        Signal::Continue => {
                            self.resume()?;
                        }
                        Signal::Resize => {
                            let size = self.term.size()?;
                            return Ok(Some(Event::Resize(size)));
                        }
                        _ => ()
                    }

                    if self.reader.report_signals.contains(sig) {
                        Ok(Some(Event::Signal(sig)))
                    } else {
                        Ok(None)
                    }
                }

                fn resume(&mut self) -> io::Result<()> {
                    if let Some(resume) = self.reader.resume {
                        let _ = self.prepare(resume.config)?;
                    }
                    Ok(())
                }
            }

            macro_rules! expand_opt {
                ( $slf:expr , $cap:path ) => { {
                    if let Some(cap) = $slf.term.info.get::<$cap>() {
                        $slf.expand(cap.expand())
                    } else {
                        Ok(())
                    }
                } };
                ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => { {
                    if let Some(cap) = $slf.term.info.get::<$cap>() {
                        let $ex = cap.expand();
                        $slf.expand($expansion)
                    } else {
                        Ok(())
                    }
                } }
            }

            macro_rules! expand_req {
                ( $slf:expr , $cap:path , $name:expr ) => { {
                    $slf.term.info.get::<$cap>()
                        .ok_or_else(|| not_supported($name))
                        .and_then(|cap| $slf.expand(cap.expand()))
                } };
                ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => { {
                    $slf.term.info.get::<$cap>()
                        .ok_or_else(|| not_supported($name))
                        .and_then(|cap| {
                            let $ex = cap.expand();
                            $slf.expand($expansion)
                        })
                } }
            }

            impl<'a> TerminalWriteGuard<'a> {
                fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                    TerminalWriteGuard{term, writer}
                }

                pub fn size(&self) -> io::Result<Size> {
                    get_winsize(self.term.out_fd)
                }

                fn disable_keypad(&mut self) -> io::Result<()> {
                    if let Some(local) = self.term.info.get::<cap::KeypadLocal>() {
                        self.expand(local.expand())?;
                    }
                    Ok(())
                }

                fn enable_keypad(&mut self) -> io::Result<bool> {
                    if let Some(xmit) = self.term.info.get::<cap::KeypadXmit>() {
                        self.expand(xmit.expand())?;
                        Ok(true)
                    } else {
                        Ok(false)
                    }
                }

                fn disable_mouse(&mut self) -> io::Result<()> {
                    self.write_bytes(XTERM_DISABLE_MOUSE.as_bytes())?;
                    self.write_bytes(XTERM_DISABLE_MOUSE_MOTION.as_bytes())
                }

                fn enable_mouse(&mut self, track_motion: bool) -> io::Result<bool> {
                    if self.term.is_xterm() {
                        self.write_bytes(XTERM_ENABLE_MOUSE.as_bytes())?;
                        if track_motion {
                            self.write_bytes(XTERM_ENABLE_MOUSE_MOTION.as_bytes())?;
                        }
                        Ok(true)
                    } else {
                        Ok(false)
                    }
                }

                fn enter_screen(&mut self) -> io::Result<()> {
                    match (self.term.info.get::<cap::EnterCaMode>(),
                            self.term.info.get::<cap::ChangeScrollRegion>(),
                            self.term.info.get::<cap::CursorHome>()) {
                        (enter, Some(scroll), Some(home)) => {
                            let size = self.size()?;

                            if let Some(enter) = enter {
                                self.expand(enter.expand())?;
                            }

                            self.expand(scroll.expand()
                                .parameters(0, to_u32(size.lines - 1)))?;
                            self.expand(home.expand())?;
                        }
                        (_, None, _) => return Err(not_supported("change_scroll_region")),
                        (_, _, None) => return Err(not_supported("cursor_home")),
                    }

                    self.clear_attributes()?;
                    self.clear_screen()?;

                    Ok(())
                }

                fn exit_screen(&mut self) -> io::Result<()> {
                    if let Some(exit) = self.term.info.get::<cap::ExitCaMode>() {
                        self.expand(exit.expand())?;
                        self.flush()?;
                    }

                    Ok(())
                }

                pub fn clear_attributes(&mut self) -> io::Result<()> {
                    if self.writer.fg.is_some() || self.writer.bg.is_some() ||
                            !self.writer.cur_style.is_empty() {
                        self.writer.fg = None;
                        self.writer.bg = None;
                        self.writer.cur_style = Style::empty();
                        expand_opt!(self, cap::ExitAttributeMode)?;
                    }

                    Ok(())
                }

                pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                    if self.writer.fg == fg {
                        Ok(())
                    } else {
                        if let Some(fg) = fg {
                            self.set_fg_color(fg)?;
                        } else {
                            self.clear_fg()?;
                        }

                        self.writer.fg = fg;
                        Ok(())
                    }
                }

                pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                    if self.writer.bg == bg {
                        Ok(())
                    } else {
                        if let Some(bg) = bg {
                            self.set_bg_color(bg)?;
                        } else {
                            self.clear_bg()?;
                        }

                        self.writer.bg = bg;
                        Ok(())
                    }
                }

                pub fn add_style(&mut self, style: Style) -> io::Result<()> {
                    let add = style - self.writer.cur_style;

                    if add.contains(Style::BOLD) {
                        expand_opt!(self, cap::EnterBoldMode)?;
                    }
                    if add.contains(Style::ITALIC) {
                        expand_opt!(self, cap::EnterItalicsMode)?;
                    }
                    if add.contains(Style::REVERSE) {
                        expand_opt!(self, cap::EnterReverseMode)?;
                    }
                    if add.contains(Style::UNDERLINE) {
                        expand_opt!(self, cap::EnterUnderlineMode)?;
                    }

                    self.writer.cur_style |= add;

                    Ok(())
                }

                pub fn remove_style(&mut self, style: Style) -> io::Result<()> {
                    let remove = style & self.writer.cur_style;

                    if remove.intersects(Style::BOLD | Style::REVERSE) {
                        // terminfo does not contain entries to remove bold or reverse.
                        // Instead, we must reset all attributes.
                        let new_style = self.writer.cur_style - remove;
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.add_style(new_style)?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                    } else {
                        if remove.contains(Style::ITALIC) {
                            expand_opt!(self, cap::ExitItalicsMode)?;
                        }
                        if remove.contains(Style::UNDERLINE) {
                            expand_opt!(self, cap::ExitUnderlineMode)?;
                        }

                        self.writer.cur_style -= remove;
                    }

                    Ok(())
                }

                pub fn set_style(&mut self, style: Style) -> io::Result<()> {
                    let add = style - self.writer.cur_style;
                    let remove = self.writer.cur_style - style;

                    if remove.intersects(Style::BOLD | Style::REVERSE) {
                        // terminfo does not contain entries to remove bold or reverse.
                        // Instead, we must reset all attributes.
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                        self.add_style(style)?;
                    } else {
                        self.add_style(add)?;
                        self.remove_style(remove)?;
                    }

                    Ok(())
                }

                pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> {
                    self.set_attrs(theme.fg, theme.bg, theme.style)
                }

                pub fn set_attrs(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()> {
                    if (self.writer.fg.is_some() && fg.is_none()) ||
                            (self.writer.bg.is_some() && bg.is_none()) {
                        self.clear_attributes()?;
                    }

                    self.set_style(style)?;
                    self.set_fg(fg)?;
                    self.set_bg(bg)?;

                    Ok(())
                }

                fn clear_fg(&mut self) -> io::Result<()> {
                    let bg = self.writer.bg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_bg(bg)?;
                    self.set_style(style)
                }

                fn clear_bg(&mut self) -> io::Result<()> {
                    let fg = self.writer.fg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_fg(fg)?;
                    self.set_style(style)
                }

                fn set_fg_color(&mut self, fg: Color) -> io::Result<()> {
                    expand_opt!(self, cap::SetAForeground,
                        |ex| ex.parameters(color_code(fg)))
                }

                fn set_bg_color(&mut self, bg: Color) -> io::Result<()> {
                    expand_opt!(self, cap::SetABackground,
                        |ex| ex.parameters(color_code(bg)))
                }

                pub fn clear_screen(&mut self) -> io::Result<()> {
                    expand_req!(self, cap::ClearScreen, "clear_screen")
                }

                pub fn clear_to_line_end(&mut self) -> io::Result<()> {
                    expand_req!(self, cap::ClrEol, "clr_eol")
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                    expand_req!(self, cap::ClrEos, "clr_eos")
                }

                pub fn move_up(&mut self, n: usize) -> io::Result<()> {
                    if n == 1 {
                        expand_req!(self, cap::CursorUp, "cursor_up")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmUpCursor, "parm_cursor_up",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_down(&mut self, n: usize) -> io::Result<()> {
                    // Always use ParmDownCursor because CursorDown does not behave
                    // as expected outside EnterCaMode state.
                    if n != 0 {
                        expand_req!(self, cap::ParmDownCursor, "parm_cursor_down",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_left(&mut self, n: usize) -> io::Result<()> {
                    if n == 1 {
                        expand_req!(self, cap::CursorLeft, "cursor_left")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmLeftCursor, "parm_cursor_left",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                    if n == 1 {
                        expand_req!(self, cap::CursorRight, "cursor_right")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmRightCursor, "parm_cursor_right",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_to_first_column(&mut self) -> io::Result<()> {
                    self.write_bytes(b"\r")
                }

                pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    match (self.term.info.get::<cap::CursorAddress>(),
                            self.term.info.get::<cap::CursorHome>()) {
                        (_, Some(ref home)) if pos == Cursor::default() => {
                            self.expand(home.expand())?;
                        }
                        (Some(addr), _) => {
                            self.expand(addr.expand()
                                .parameters(to_u32(pos.line), to_u32(pos.column)))?;
                        }
                        (None, _) => return Err(not_supported("cursor_address"))
                    }

                    Ok(())
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                    match mode {
                        CursorMode::Normal | CursorMode::Overwrite => {
                            // Overwrite is not supported by Unix terminals.
                            // We set to normal in this case as it will reverse
                            // a setting of Invisible
                            expand_opt!(self, cap::CursorNormal)?;
                        }
                        CursorMode::Invisible => {
                            expand_opt!(self, cap::CursorInvisible)?;
                        }
                    }

                    Ok(())
                }

                pub fn write_char(&mut self, ch: char) -> io::Result<()> {
                    self.write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                    self.write_bytes(s.as_bytes())
                }

                pub fn write_styled(&mut self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.set_attrs(fg, bg, style)?;

                    self.write_str(text)?;
                    self.clear_attributes()
                }

                fn write_bytes(&mut self, buf: &[u8]) -> io::Result<()> {
                    if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                        self.flush()?;
                    }

                    if buf.len() > self.writer.out_buffer.capacity() {
                        self.write_data(buf).1
                    } else {
                        self.writer.out_buffer.extend(buf);
                        Ok(())
                    }
                }

                pub fn flush(&mut self) -> io::Result<()> {
                    let (n, res) = self.write_data(&self.writer.out_buffer);
                    self.writer.out_buffer.drain(..n);
                    res
                }

                fn write_data(&self, buf: &[u8]) -> (usize, io::Result<()>) {
                    let mut offset = 0;

                    let r = loop {
                        if offset == buf.len() {
                            break Ok(());
                        }

                        match write(self.term.out_fd, buf) {
                            Ok(0) => break Err(io::Error::from(io::ErrorKind::WriteZero)),
                            Ok(n) => offset += n,
                            Err(Errno::EINTR) => continue,
                            Err(e) => break Err(nix_to_io(e))
                        }
                    };

                    (offset, r)
                }

                fn expand<T: AsRef<[u8]>>(&mut self, exp: Expansion<T>) -> io::Result<()> {
                    let writer = &mut *self.writer;
                    exp
                        .with(&mut writer.context)
                        .to(&mut writer.out_buffer)
                        .map_err(ti_to_io)
                }
            }

            impl<'a> Drop for TerminalWriteGuard<'a> {
                fn drop(&mut self) {
                    if let Err(e) = self.flush() {
                        eprintln!("failed to flush terminal: {}", e);
                    }
                }
            }

            impl Writer {
                fn new() -> Writer {
                    Writer{
                        context: Context::default(),
                        out_buffer: Vec::with_capacity(OUT_BUFFER_SIZE),
                        fg: None,
                        bg: None,
                        cur_style: Style::empty(),
                    }
                }
            }

            fn is_xterm(name: &str) -> bool {
                // Includes such terminal names as "xterm-256color"
                name == "xterm" || name.starts_with("xterm-")
            }

            fn sequences(info: &Database) -> SeqMap {
                let mut sequences = SequenceMap::new();

                macro_rules! add {
                    ( $seq:ty , $key:expr ) => { {
                        if let Some(seq) = info.get::<$seq>() {
                            if let Some(s) = ascii_str(seq.as_ref()) {
                                sequences.insert(s.into(), SeqData::Key($key));
                            }
                        }
                    } }
                }

                add!(cap::KeyUp,        Key::Up);
                add!(cap::KeyDown,      Key::Down);
                add!(cap::KeyLeft,      Key::Left);
                add!(cap::KeyRight,     Key::Right);
                add!(cap::KeyHome,      Key::Home);
                add!(cap::KeyEnd,       Key::End);
                add!(cap::KeyNPage,     Key::PageDown);
                add!(cap::KeyPPage,     Key::PageUp);
                add!(cap::KeyDc,        Key::Delete);
                add!(cap::KeyIc,        Key::Insert);
                add!(cap::KeyF1,        Key::F(1));
                add!(cap::KeyF2,        Key::F(2));
                add!(cap::KeyF3,        Key::F(3));
                add!(cap::KeyF4,        Key::F(4));
                add!(cap::KeyF5,        Key::F(5));
                add!(cap::KeyF6,        Key::F(6));
                add!(cap::KeyF7,        Key::F(7));
                add!(cap::KeyF8,        Key::F(8));
                add!(cap::KeyF9,        Key::F(9));
                add!(cap::KeyF10,       Key::F(10));
                add!(cap::KeyF11,       Key::F(11));
                add!(cap::KeyF12,       Key::F(12));

                if is_xterm(info.name()) {
                    sequences.insert(XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse);
                }

                sequences
            }

            pub struct PrepareState {
                old_tio: termios,
                old_sigcont: Option<SigAction>,
                old_sigint: Option<SigAction>,
                old_sigtstp: Option<SigAction>,
                old_sigquit: Option<SigAction>,
                old_sigwinch: Option<SigAction>,
                restore_keypad: bool,
                restore_mouse: bool,
                prev_resume: Option<Resume>,
            }

            #[derive(Copy, Clone, Debug)]
            struct Resume {
                config: PrepareConfig,
            }

            unsafe fn close_fd(fd: RawFd) {
                drop(File::from_raw_fd(fd));
            }

            fn open_rw<P: AsRef<Path>>(path: P) -> io::Result<RawFd> {
                use std::fs::OpenOptions;

                let file = OpenOptions::new()
                    .read(true)
                    .write(true)
                    .open(path)?;

                Ok(file.into_raw_fd())
            }

            #[repr(C)]
            struct Winsize {
                ws_row: c_ushort,
                ws_col: c_ushort,
                ws_xpixel: c_ushort,
                ws_ypixel: c_ushort,
            }

            fn get_winsize(fd: c_int) -> io::Result<Size> {
                let mut winsz: Winsize = unsafe { zeroed() };

                // `TIOCGWINSZ.into()` is a workaround to a bug in the libc crate:
                //  https://github.com/rust-lang/libc/pull/704
                let res = unsafe { ioctl(fd, TIOCGWINSZ.into(), &mut winsz) };

                if res == -1 {
                    Err(io::Error::last_os_error())
                } else {
                    let size = Size{
                        lines: winsz.ws_row as usize,
                        columns: winsz.ws_col as usize,
                    };

                    Ok(size)
                }
            }

            fn nix_to_io(e: nix::Error) -> io::Error {
                io::Error::from_raw_os_error(e as i32)
            }

            fn ti_to_io(e: terminfo::Error) -> io::Error {
                match e {
                    terminfo::Error::Io(e) => e,
                    terminfo::Error::NotFound => io::Error::new(
                        io::ErrorKind::NotFound, "terminfo entry not found"),
                    terminfo::Error::Parse => io::Error::new(
                        io::ErrorKind::Other, "failed to parse terminfo entry"),
                    terminfo::Error::Expand(_) => io::Error::new(
                        io::ErrorKind::Other, "failed to expand terminfo entry"),
                }
            }

            fn to_timeval(d: Duration) -> TimeVal {
                const MAX_SECS: i64 = i64::max_value() / 1_000;

                let secs = match d.as_secs() {
                    n if n > MAX_SECS as u64 => MAX_SECS,
                    n => n as i64,
                };

                let millis = d.subsec_millis() as i64;

                TimeVal::milliseconds(secs * 1_000 + millis)
            }

            fn peek_event(buf: &[u8], sequences: &SeqMap)
                    -> io::Result<Option<(Event, usize)>> {
                let (res, n) = {
                    let s = utf8_prefix(buf)?;

                    if s.is_empty() {
                        return Ok(None);
                    }

                    let mut last_match = None;

                    for pfx in prefixes(s) {
                        match sequences.find(pfx) {
                            FindResult::NotFound => break,
                            FindResult::Found(value) => {
                                last_match = Some((pfx, *value));
                                break;
                            }
                            FindResult::Incomplete => (),
                            FindResult::Undecided(value) => {
                                last_match = Some((pfx, *value));
                            }
                        }
                    }

                    let res = last_match.and_then(|(seq, value)| {
                        match value {
                            SeqData::Key(key) => Some((Event::Key(key), seq.len())),
                            SeqData::XTermMouse => {
                                if let Some((data, len)) = parse_mouse_data(&buf[seq.len()..]) {
                                    Some((Event::Mouse(data), seq.len() + len))
                                } else {
                                    // Input sequence was incomplete
                                    None
                                }
                            }
                        }
                    });

                    if let Some(res) = res {
                        res
                    } else {
                        let ch = s.chars().next().unwrap();
                        (Event::Key(ch.into()), ch.len_utf8())
                    }
                };

                Ok(Some((res, n)))
            }

            fn parse_mouse_data(mut buf: &[u8]) -> Option<(Mouse, usize)> {
                let orig_len = buf.len();

                let (mut input, end) = parse_integer(&mut buf)?;

                if end != b';' {
                    return None;
                }

                let (column, end) = parse_integer(&mut buf)?;

                if end != b';' {
                    return None;
                }

                let (line, end) = parse_integer(&mut buf)?;

                let is_pressed = match end {
                    b'M' => true,
                    b'm' => false,
                    _ => return None
                };

                let mut mods = ModifierState::empty();

                if (input & XTERM_SHIFT_MASK) != 0 {
                    mods |= ModifierState::SHIFT;
                }
                if (input & XTERM_META_MASK) != 0 {
                    mods |= ModifierState::ALT;
                }
                if (input & XTERM_CTRL_MASK) != 0 {
                    mods |= ModifierState::CTRL;
                }

                input &= !XTERM_MODIFIER_MASK;

                let input = match input {
                    0 ..= 3 => mouse_button_event(input, is_pressed),
                    64 => MouseInput::WheelUp,
                    65 => MouseInput::WheelDown,
                    _ => MouseInput::Motion,
                };

                let position = Cursor{
                    // Parsed line and column begin at 1; we begin at 0
                    line: (line - 1) as usize,
                    column: (column - 1) as usize,
                };

                Some((Mouse{
                    position,
                    input,
                    modifiers: mods,
                }, orig_len - buf.len()))
            }

            fn parse_integer(buf: &mut &[u8]) -> Option<(u32, u8)> {
                let mut n = 0u32;
                let mut iter = buf.iter();

                while let Some(&b) = iter.next() {
                    match b {
                        b'0' ..= b'9' => {
                            n = n.checked_mul(10)?
                                .checked_add((b - b'0') as u32)?;
                        }
                        _ => {
                            *buf = iter.as_slice();
                            return Some((n, b));
                        }
                    }
                }

                None
            }

            fn mouse_button_event(input: u32, is_pressed: bool) -> MouseInput {
                let button = match input {
                    0 => MouseButton::Left,
                    1 => MouseButton::Middle,
                    2 => MouseButton::Right,
                    _ => MouseButton::Other(input)
                };

                if is_pressed {
                    MouseInput::ButtonPressed(button)
                } else {
                    MouseInput::ButtonReleased(button)
                }
            }

            fn utf8_prefix(buf: &[u8]) -> io::Result<&str> {
                match from_utf8(buf) {
                    Ok(s) => Ok(s),
                    Err(e) => {
                        if e.valid_up_to() != 0 {
                            from_utf8(&buf[..e.valid_up_to()])
                                .map_err(|_| unreachable!())
                        } else if e.error_len().is_some() {
                            Err(io::Error::new(io::ErrorKind::Other,
                                "read invalid utf-8 data from terminal"))
                        } else {
                            Ok("")
                        }
                    }
                }
            }

            static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(0);

            extern "C" fn handle_signal(signum: c_int) {
                LAST_SIGNAL.store(signum as usize, Ordering::Relaxed);
            }

            fn conv_signal(sig: c_int) -> Option<Signal> {
                match NixSignal::try_from(sig).ok() {
                    Some(NixSignal::SIGCONT)  => Some(Signal::Continue),
                    Some(NixSignal::SIGINT)   => Some(Signal::Interrupt),
                    Some(NixSignal::SIGQUIT)  => Some(Signal::Quit),
                    Some(NixSignal::SIGTSTP)  => Some(Signal::Suspend),
                    Some(NixSignal::SIGWINCH) => Some(Signal::Resize),
                    _ => None
                }
            }

            fn get_signal() -> Option<Signal> {
                conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as c_int)
            }

            fn take_signal() -> Option<Signal> {
                conv_signal(LAST_SIGNAL.swap(0, Ordering::Relaxed) as c_int)
            }

            fn ascii_str(s: &[u8]) -> Option<&str> {
                use std::str::from_utf8_unchecked;

                if s.is_ascii() {
                    Some(unsafe { from_utf8_unchecked(s) })
                } else {
                    None
                }
            }

            fn color_code(color: Color) -> u8 {
                match color {
                    Color::Black =>     0,
                    Color::Red =>       1,
                    Color::Green =>     2,
                    Color::Yellow =>    3,
                    Color::Blue =>      4,
                    Color::Magenta =>   5,
                    Color::Cyan =>      6,
                    Color::White =>     7,
                }
            }

            fn not_supported(op: &str) -> io::Error {
                io::Error::new(io::ErrorKind::Other,
                    format!("operation not supported: {}", op))
            }
            
            fn to_u32(u: usize) -> u32 {
                if u > u32::max_value() as usize {
                    u32::max_value()
                } else {
                    u as u32
                }
            }
        } pub use self::terminal::{ PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard };

        mod screen
        {
            use ::
            {
                *,
            };
            /*
            use std::io;
            use std::sync::{LockResult, Mutex, MutexGuard, TryLockResult};
            use std::time::Duration;

            use ::buffer::ScreenBuffer;
            use ::priv_util::{
                map_lock_result, map_try_lock_result,
                map2_lock_result, map2_try_lock_result,
            };
            use ::sys::{Terminal, TerminalReadGuard, TerminalWriteGuard, PrepareState};
            use ::terminal::{Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig};
            */
            pub struct Screen {
                term: Terminal,

                state: Option<PrepareState>,
                writer: Mutex<Writer>,
            }

            pub struct ScreenReadGuard<'a> {
                screen: &'a Screen,
                reader: TerminalReadGuard<'a>,
            }

            pub struct ScreenWriteGuard<'a> {
                writer: TerminalWriteGuard<'a>,
                data: MutexGuard<'a, Writer>,
            }

            struct Writer {
                buffer: ScreenBuffer,
                clear_screen: bool,
                real_cursor: Cursor,
            }

            impl Screen {
                pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen> {
                    let size = term.size()?;
                    let state = term.prepare(config)?;

                    let screen = Screen{
                        term: term,
                        state: Some(state),

                        writer: Mutex::new(Writer{
                            buffer: ScreenBuffer::new(size),
                            clear_screen: false,
                            real_cursor: Cursor::default(),
                        }),
                    };

                    screen.term.enter_screen()?;

                    Ok(screen)
                }

                pub fn stdout(config: PrepareConfig) -> io::Result<Screen> {
                    Screen::new(Terminal::stdout()?, config)
                }

                pub fn stderr(config: PrepareConfig) -> io::Result<Screen> {
                    Screen::new(Terminal::stderr()?, config)
                }

                forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                pub fn lock_read(&self) -> LockResult<ScreenReadGuard> {
                    map_lock_result(self.term.lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> {
                    map_try_lock_result(self.term.try_lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> {
                    map2_lock_result(self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> {
                    map2_try_lock_result(self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                fn lock_reader(&self) -> ScreenReadGuard {
                    self.lock_read().expect("Screen::lock_reader")
                }

                fn lock_writer(&self) -> ScreenWriteGuard {
                    self.lock_write().expect("Screen::lock_writer")
                }

                fn lock_write_data(&self) -> MutexGuard<Writer> {
                    self.writer.lock().expect("Screen::lock_write_data")
                }

                pub fn name(&self) -> &str {
                    self.term.name()
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                    self.term.set_cursor_mode(mode)
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn refresh(&self) -> io::Result<()> {
                    self.lock_writer().refresh()
                }
            }

            impl Drop for Screen {
                fn drop(&mut self) {
                    let res = if let Some(state) = self.state.take() {
                        self.term.restore(state)
                    } else {
                        Ok(())
                    };

                    if let Err(e) = res.and_then(|_| self.term.exit_screen()) {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            impl<'a> ScreenReadGuard<'a> {
                fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> {
                    ScreenReadGuard{screen, reader}
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.reader.wait_event(timeout)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    let r = self.reader.read_event(timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    let r = self.reader.read_raw(buf, timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }
            }

            impl<'a> ScreenWriteGuard<'a> {
                fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>)
                        -> ScreenWriteGuard<'a> {
                    ScreenWriteGuard{writer, data}
                }

                forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                    self.writer.set_cursor_mode(mode)
                }

                pub fn refresh(&mut self) -> io::Result<()> {
                    if self.data.clear_screen {
                        self.writer.clear_screen()?;
                        self.data.clear_screen = false;
                    }

                    self.writer.clear_attributes()?;

                    let mut indices = self.data.buffer.indices();

                    while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices) {
                        self.move_cursor(pos)?;

                        self.apply_attrs(cell.attrs())?;
                        self.writer.write_str(cell.text())?;
                        self.data.real_cursor.column += 1;
                    }

                    self.writer.clear_attributes()?;

                    let size = self.data.buffer.size();
                    let pos = self.data.buffer.cursor();

                    if pos.is_out_of_bounds(size) {
                        self.move_cursor(Cursor::last(size))?;
                    } else {
                        self.move_cursor(pos)?;
                    }

                    self.writer.flush()
                }

                fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    if self.data.real_cursor != pos {
                        self.writer.move_cursor(pos)?;
                        self.data.real_cursor = pos;
                    }

                    Ok(())
                }

                fn apply_attrs(&mut self,
                        (fg, bg, style): (Option<Color>, Option<Color>, Style))
                        -> io::Result<()> {
                    self.writer.set_attrs(fg, bg, style)
                }
            }

            impl<'a> Drop for ScreenWriteGuard<'a> {
                fn drop(&mut self) {
                    if let Err(e) = self.refresh() {
                        eprintln!("failed to refresh screen: {}", e);
                    }
                }
            }

            impl Writer {
                fn update_size(&mut self, new_size: Size) {
                    if self.real_cursor.is_out_of_bounds(new_size) {
                        // Force cursor move on next refresh
                        self.real_cursor = (!0, !0).into();
                    }
                    self.buffer.resize(new_size);
                    self.clear_screen = true;
                }
            }
        } pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };

        use ::io::ErrorKind;

        #[doc(hidden)]
        pub trait IsMinusOne {
            fn is_minus_one(&self) -> bool;
        }

        impl_is_minus_one! { i8 i16 i32 i64 isize }

        pub fn cvt<T: IsMinusOne>(t: T) -> ::io::Result<T>
        {
            if t.is_minus_one() { Err(::io::Error::last_os_error()) }
            else { Ok(t) }
        }

        pub fn cvt_r<T, F>(mut f: F) -> ::io::Result<T> where 
        T: IsMinusOne,
        F: FnMut() -> T
        {
            loop
            {
                match cvt(f())
                {
                    Err(ref e) if e.kind() == ErrorKind::Interrupted => {}
                    other => return other,
                }
            }
        }
    }
    
    pub mod support
    {
        use ::
        {
            *,
        };

        pub mod os
        {
            use ::
            {
                error::Error as StdError,
                ffi::{OsStr, OsString},
                marker::PhantomData,
                path::{self, PathBuf},
                *,
            }; use super::unsupported;
            
            pub fn errno() -> i32 { 0 }
            pub fn error_string(_errno: i32) -> String { "operation successful".to_string() }
            pub fn getcwd() -> io::Result<PathBuf> { unsupported() }
            pub fn chdir(_: &path::Path) -> io::Result<()> { unsupported() }
            pub struct SplitPaths<'a>(!, PhantomData<&'a ()>);
            pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> { panic!("unsupported") }

            impl<'a> Iterator for SplitPaths<'a>
            {
                type Item = PathBuf;
                fn next(&mut self) -> Option<PathBuf> { self.0 }
            }

            #[derive( Debug )]
            pub struct JoinPathsError;

            pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError> where
            I: Iterator<Item = T>,
            T: AsRef<OsStr>
            { Err(JoinPathsError) }

            impl fmt::Display for JoinPathsError
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { "not supported on this platform yet".fmt(f) }
            }

            impl StdError for JoinPathsError
            {
                fn description(&self) -> &str { "not supported on this platform yet" }
            }

            pub fn current_exe() -> io::Result<PathBuf> { unsupported() }
            pub fn temp_dir() -> PathBuf { panic!("no filesystem on this platform") }
            pub fn home_dir() -> Option<PathBuf> { None }
            pub fn exit(_code: i32) -> ! { crate::intrinsics::abort() }
            pub fn getpid() -> u32 { panic!("no pids on this platform") }
        }

        pub mod pipe
        {
            use ::
            {
                io::{ self, BorrowedCursor, IoSlice, IoSliceMut },
                sys::common::{FromInner, IntoInner},
                *,
            };
            
            pub struct AnonPipe(!);

            impl fmt::Debug for AnonPipe
            {
                fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result { self.0 }
            }

            impl AnonPipe
            {
                pub fn try_clone(&self) -> io::Result<Self> { self.0 }
                pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> { self.0 }
                pub fn read_buf(&self, _buf: BorrowedCursor<'_>) -> io::Result<()> { self.0 }
                pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> { self.0 }
                pub fn is_read_vectored(&self) -> bool { self.0 }
                pub fn read_to_end(&self, _buf: &mut Vec<u8>) -> io::Result<usize> { self.0 }
                pub fn write(&self, _buf: &[u8]) -> io::Result<usize> { self.0 }
                pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> { self.0 }
                pub fn is_write_vectored(&self) -> bool { self.0 }
                pub fn diverge(&self) -> ! { self.0 }
            }

            pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()>
            { match p1.0 {} }

            impl FromInner<!> for AnonPipe 
            {
                fn from_inner(inner: !) -> Self { inner }
            }

            impl IntoInner<!> for AnonPipe
            {
                fn into_inner(self) -> ! { self.0 }
            }
        }

        pub mod thread
        {
            use ::
            {
                ffi::CStr,
                num::NonZero,
                time::Duration,
                *,
            }; use super::unsupported;
            
            pub struct Thread(!);

            pub const DEFAULT_MIN_STACK_SIZE: usize = 64 * 1024;

            impl Thread
            {
                pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> { unsupported() }
                pub fn yield_now() {}
                pub fn set_name(_name: &CStr) {}
                pub fn sleep(_dur: Duration) { panic!("can't sleep"); }
                pub fn join(self) { self.0 }
            }

            pub fn available_parallelism() -> io::Result<NonZero<usize>> { unsupported() }
        }

        pub mod time
        {
            use ::
            {
                time::Duration,
                *,
            };

            #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
            pub struct Instant(Duration);

            #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
            pub struct SystemTime(Duration);

            pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));

            impl Instant 
            {
                pub fn now() -> Instant { panic!("time not implemented on this platform") }
                pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> { self.0.checked_sub(other.0) }
                pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> { Some(Instant(self.0.checked_add(*other)?)) }
                pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> { Some(Instant(self.0.checked_sub(*other)?)) }
            }

            impl SystemTime
            {
                pub fn now() -> SystemTime { panic!("time not implemented on this platform") }

                pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration>
                { self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0) }

                pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime>
                { Some(SystemTime(self.0.checked_add(*other)?)) }

                pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime>
                { Some(SystemTime(self.0.checked_sub(*other)?)) }
            }
        }

        pub mod common
        {
            use ::
            {
                io::{ self as stdio },
                *,
            };
            
            pub unsafe fn init(_argc: isize, _argv: *const *const u8, _sigpipe: u8) {}
            
            pub unsafe fn cleanup() {}

            pub fn unsupported<T>() -> stdio::Result<T> {
                Err(unsupported_err())
            }

            pub fn unsupported_err() -> stdio::Error {
                stdio::Error::UNSUPPORTED_PLATFORM
            }

            pub fn is_interrupted(_code: i32) -> bool {
                false
            }

            pub fn decode_error_kind(_code: i32) -> ::io::ErrorKind {
                ::io::ErrorKind::Uncategorized
            }

            pub fn abort_internal() -> ! {
                ::intrinsics::abort();
            }
        }
        pub use self::common::*;
    } use self::system::support::unsupported;

    pub mod windows
    {
        pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard, };

        pub use self::terminal::{ PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard, };

        macro_rules! impl_is_zero
        {
            ($($t:ident)*) => ($(impl IsZero for $t
            {
                fn is_zero(&self) -> bool { *self == 0 }
            })*)
        }

        pub mod ext
        {
            //! Windows console extension trait
            use ::
            {
                *,
            };
            /*
            use std::io;
            use std::time::Duration;

            use winapi::um::wincon::INPUT_RECORD;

            use ::priv_util::Private;
            use ::terminal::Event;
            */
            /// Implements Windows-only extensions for terminal interfaces.
            pub trait TerminalExt: Private
            {
                /// Reads raw data from the console.
                ///
                /// Data read will be UTF-16 encoded, but may be incomplete. The caller may
                /// consume any valid UTF-16 data before performing another `read_raw` call
                /// to complete previously read data.
                ///
                /// If `timeout` elapses without an event occurring, this method will return
                /// `Ok(None)`. If `timeout` is `None`, this method will wait indefinitely.
                fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>)
                        -> io::Result<Option<Event>>;

                /// Reads raw event data from the console.
                ///
                /// If `timeout` elapses without an event occurring, this method will return
                /// `Ok(None)`. If `timeout` is `None`, this method will wait indefinitely.
                fn read_raw_event(&mut self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>>;
            }
        }

        mod terminal
        {
            use ::
            {
                ffi::{ OsStr },
                mem::{ replace, zeroed },
                os::windows::ffi::{ OsStrExt },
                sync::{ atomic::{AtomicUsize, Ordering}, LockResult, Mutex, MutexGuard, TryLockResult },
                system::
                {
                    prepare::{ PrepareConfig },
                    terminal::
                    { 
                        Color, Cursor, CursorMode, Event, Key, Size, Style, Theme, MouseButton, Mouse, MouseInput, 
                        ModifierState
                    },
                    signal::{ Signal, SignalSet },
                },
                *,
            };
            /*
            use std::char;
            use std::ffi::OsStr;
            use std::io;
            use std::mem::{replace, zeroed};
            use std::os::windows::ffi::OsStrExt;
            use std::ptr;
            use std::sync::atomic::{AtomicUsize, Ordering};
            use std::sync::{LockResult, Mutex, MutexGuard, TryLockResult};
            use std::time::Duration;
            */
            pub mod ctypes
            {
                use ::
                {
                    winapi::{ ctypes },
                    *,
                };
            }
            
            pub mod shared
            {
                use ::
                {
                    *,
                };

                pub mod winerror
                {
                    use ::
                    {
                        winapi::shared::winerror::{ * },
                        *,
                    };
                }

                pub mod minwindef
                {
                    use ::
                    {
                         winapi::shared::minwindef::{ * },
                        *,
                    };
                }

                pub mod ntdef
                {
                    use ::
                    {
                         winapi::shared::ntdef::{ * },
                        *,
                    };
                }
            }
            
            pub mod um
            {
                use ::
                {
                    *,
                };

                pub mod consoleapi
                {
                    use ::
                    {
                        winapi::um::consoleapi::{ * },
                        *,
                    };
                }

                pub mod handleapi
                {
                    use ::
                    {
                        winapi::um::handleapi::{ * },
                        *,
                    };
                }

                pub mod processenv
                {
                    use ::
                    {
                        winapi::um::processenv::{ * },
                        *,
                    };
                }

                pub mod synchapi
                {
                    use ::
                    {
                        winapi::um::synchapi::{ * },
                        *,
                    };
                }

                pub mod winbase
                {
                    use ::
                    {
                        winapi::um::winbase::{ * },
                        *,
                    };
                }

                pub mod wincon
                {
                    use ::
                    {
                        winapi::um::wincon::{ * },
                        *,
                    };
                }

                pub mod winuser
                {
                    use ::
                    {
                        winapi::um::winuser::{ * },
                        *,
                    };
                }

                pub mod winnt
                {
                    use ::
                    {
                        winapi::um::winnt::{ * },
                        *,
                    };
                }
            }
            /*
            use ::util::unctrl_lower;
            */
            pub struct Terminal {
                in_handle: HANDLE,
                default_attrs: WORD,
                old_out_mode: DWORD,
                reader: Mutex<Reader>,
                writer: Mutex<Writer>,
            }

            pub struct TerminalReadGuard<'a> {
                term: &'a Terminal,
                reader: MutexGuard<'a, Reader>,
            }

            pub struct TerminalWriteGuard<'a> {
                term: &'a Terminal,
                writer: MutexGuard<'a, Writer>,
            }

            unsafe impl Send for Terminal {}
            unsafe impl Sync for Terminal {}

            struct Reader {
                always_track_motion: bool,
                prev_buttons: DWORD,
            }

            struct Writer {
                out_handle: HANDLE,
                fg: Option<Color>,
                bg: Option<Color>,
                style: Style,
            }

            pub struct PrepareState {
                old_in_mode: u32,
                clear_handler: bool,
            }

            impl Terminal {
                fn new(out: DWORD) -> io::Result<Terminal> {
                    let in_handle = result_handle(
                        unsafe { GetStdHandle(STD_INPUT_HANDLE) })?;
                    let out_handle = result_handle(
                        unsafe { GetStdHandle(out) })?;

                    let default_attrs = unsafe { console_info(out_handle)?.wAttributes };

                    let old_out_mode = unsafe { prepare_output(out_handle)? };

                    Ok(Terminal{
                        in_handle,
                        default_attrs,
                        old_out_mode,
                        reader: Mutex::new(Reader{
                            always_track_motion: false,
                            prev_buttons: 0,
                        }),
                        writer: Mutex::new(Writer{
                            out_handle,
                            fg: None,
                            bg: None,
                            style: Style::empty(),
                        }),
                    })
                }

                pub fn stdout() -> io::Result<Terminal> {
                    Terminal::new(STD_OUTPUT_HANDLE)
                }

                pub fn stderr() -> io::Result<Terminal> {
                    Terminal::new(STD_ERROR_HANDLE)
                }

                pub fn name(&self) -> &str {
                    "windows-console"
                }

                pub fn size(&self) -> io::Result<Size> {
                    self.lock_writer().size()
                }

                pub fn clear_screen(&self) -> io::Result<()> {
                    self.lock_writer().clear_screen()
                }

                pub fn clear_to_line_end(&self) -> io::Result<()> {
                    self.lock_writer().clear_to_line_end()
                }

                pub fn clear_to_screen_end(&self) -> io::Result<()> {
                    self.lock_writer().clear_to_screen_end()
                }

                pub fn move_to_first_column(&self) -> io::Result<()> {
                    self.lock_writer().move_to_first_column()
                }

                pub fn move_up(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_up(n)?;
                    }
                    Ok(())
                }

                pub fn move_down(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_down(n)?;
                    }
                    Ok(())
                }

                pub fn move_left(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_left(n)?;
                    }
                    Ok(())
                }

                pub fn move_right(&self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        self.lock_writer().move_right(n)?;
                    }
                    Ok(())
                }

                pub fn enter_screen(&self) -> io::Result<HANDLE> {
                    self.lock_writer().enter_screen()
                }
                
                pub unsafe fn exit_screen(&self, old_handle: HANDLE) -> io::Result<()> {
                    self.lock_writer().exit_screen(old_handle)
                }

                pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> {
                    self.lock_reader().prepare(config)
                }

                pub fn restore(&self, state: PrepareState) -> io::Result<()> {
                    self.lock_reader().restore(state)
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u16],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn read_raw_event(&self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw_event(events, timeout)
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                    self.lock_writer().set_cursor_mode(mode)
                }

                pub fn clear_attributes(&self) -> io::Result<()> {
                    self.lock_writer().clear_attributes()
                }

                pub fn add_style(&self, style: Style) -> io::Result<()> {
                    self.lock_writer().add_style(style)
                }

                pub fn remove_style(&self, style: Style) -> io::Result<()> {
                    self.lock_writer().remove_style(style)
                }

                pub fn set_style(&self, style: Style) -> io::Result<()> {
                    self.lock_writer().set_style(style)
                }

                pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> {
                    self.lock_writer().set_fg(fg)
                }

                pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> {
                    self.lock_writer().set_bg(bg)
                }

                pub fn set_theme(&self, theme: Theme) -> io::Result<()> {
                    self.lock_writer().set_theme(theme)
                }

                pub fn write_char(&self, ch: char) -> io::Result<()> {
                    self.lock_writer().write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&self, s: &str) -> io::Result<()> {
                    self.lock_writer().write_str(s)
                }

                pub fn write_styled(&self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.lock_writer().write_styled(fg, bg, style, text)
                }

                pub fn lock_read(&self) -> LockResult<TerminalReadGuard> {
                    map_lock_result(self.reader.lock(),
                        |r| TerminalReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> {
                    map_lock_result(self.writer.lock(),
                        |w| TerminalWriteGuard::new(self, w))
                }

                pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard> {
                    map_try_lock_result(self.reader.try_lock(),
                        |r| TerminalReadGuard::new(self, r))
                }

                pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard> {
                    map_try_lock_result(self.writer.try_lock(),
                        |w| TerminalWriteGuard::new(self, w))
                }

                fn lock_reader(&self) -> TerminalReadGuard {
                    self.lock_read().expect("Terminal::lock_reader")
                }

                fn lock_writer(&self) -> TerminalWriteGuard {
                    self.lock_write().expect("Terminal::lock_writer")
                }
            }

            impl Drop for Terminal {
                fn drop(&mut self) {
                    let r = self.set_cursor_mode(CursorMode::Normal);
                    let r2 = r.and_then(|_| {
                        let lock = self.lock_writer();
                        unsafe { set_console_mode(lock.writer.out_handle, self.old_out_mode)?; }
                        Ok(())
                    });

                    if let Err(e) = r2 {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            impl<'a> TerminalReadGuard<'a> {
                fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> {
                    TerminalReadGuard{term, reader}
                }

                pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState> {
                    let mut writer = self.term.lock_writer();
                    self.prepare_with_lock(&mut writer, config)
                }

                pub fn prepare_with_lock(&mut self, _writer: &mut TerminalWriteGuard,
                        config: PrepareConfig) -> io::Result<PrepareState> {
                    let old_in_mode = unsafe { console_mode(self.term.in_handle)? };

                    let mut state = PrepareState{
                        old_in_mode,
                        clear_handler: false,
                    };

                    let mut in_mode = old_in_mode;
                    
                    in_mode |= ENABLE_EXTENDED_FLAGS;
                    
                    in_mode &= !ENABLE_ECHO_INPUT;
                    
                    in_mode &= !ENABLE_LINE_INPUT;
                    
                    if config.block_signals {
                        in_mode &= !ENABLE_PROCESSED_INPUT;
                    } else {
                        in_mode |= ENABLE_PROCESSED_INPUT;
                    }
                    
                    if config.enable_mouse {
                        self.reader.always_track_motion = config.always_track_motion;
                        in_mode |= ENABLE_MOUSE_INPUT;
                    } else {
                        in_mode &= !ENABLE_MOUSE_INPUT;
                    }
                    
                    in_mode &= !ENABLE_QUICK_EDIT_MODE;
                    
                    in_mode |= ENABLE_WINDOW_INPUT;
                    
                    in_mode &= !ENABLE_VIRTUAL_TERMINAL_INPUT;

                    unsafe {
                        set_console_mode(self.term.in_handle, in_mode)?;

                        if config.report_signals.intersects(Signal::Break | Signal::Interrupt) {
                            catch_signals(config.report_signals);
                            result_bool(SetConsoleCtrlHandler(Some(ctrl_handler), TRUE))?;
                            state.clear_handler = true;
                        }
                    }

                    Ok(state)
                }

                pub fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                    let mut writer = self.term.lock_writer();
                    self.restore_with_lock(&mut writer, state)
                }

                pub fn restore_with_lock(&mut self, _writer: &mut TerminalWriteGuard,
                        state: PrepareState) -> io::Result<()> {
                    unsafe {
                        if state.clear_handler {
                            result_bool(SetConsoleCtrlHandler(Some(ctrl_handler), FALSE))?;
                        }

                        set_console_mode(self.term.in_handle,
                            state.old_in_mode | ENABLE_EXTENDED_FLAGS)?;
                    }

                    Ok(())
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    if get_signal().is_some() {
                        return Ok(true);
                    }

                    let res = unsafe { WaitForSingleObject(
                        self.term.in_handle, as_millis(timeout)) };

                    match res {
                        WAIT_OBJECT_0 => Ok(true),
                        WAIT_TIMEOUT => Ok(false),
                        WAIT_FAILED | _ => Err(io::Error::last_os_error())
                    }
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    let mut event: [INPUT_RECORD; 1] = unsafe { zeroed() };

                    let n = match self.read_raw_event(&mut event, timeout)? {
                        Some(Event::Raw(n)) => n,
                        r => return Ok(r)
                    };

                    if n == 0 {
                        Ok(None)
                    } else {
                        let event = event[0];

                        if let Some(key) = key_press_event(&event) {
                            Ok(Some(Event::Key(key)))
                        } else if let Some(mouse) = self.mouse_event(&event) {
                            Ok(Some(Event::Mouse(mouse)))
                        } else if let Some(size) = size_event(&event) {
                            Ok(Some(Event::Resize(size)))
                        } else {
                            Ok(Some(Event::NoEvent))
                        }
                    }
                }

                pub fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>)
                        -> io::Result<Option<Event>> {
                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }

                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    unsafe {
                        let len = to_dword(buf.len());
                        let mut n_read = 0;

                        result_bool(ReadConsoleW(
                            self.term.in_handle,
                            buf.as_ptr() as *mut VOID,
                            len,
                            &mut n_read,
                            ptr::null_mut()))?;

                        if n_read == 0 {
                            Ok(None)
                        } else {
                            Ok(Some(Event::Raw(n_read as usize)))
                        }
                    }
                }

                pub fn read_raw_event(&mut self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }

                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    let len = to_dword(events.len());
                    let mut n = 0;

                    result_bool(unsafe { ReadConsoleInputW(
                        self.term.in_handle,
                        events.as_mut_ptr(),
                        len,
                        &mut n) })?;

                    Ok(Some(Event::Raw(n as usize)))
                }

                fn mouse_event(&mut self, event: &INPUT_RECORD) -> Option<Mouse> {
                    if event.EventType == MOUSE_EVENT {
                        let mouse = unsafe { event.Event.Mouse() };

                        let input = if mouse.dwEventFlags & wincon::MOUSE_WHEELED != 0 {
                            let direction = (mouse.dwButtonState >> 16) as i16;

                            if direction > 0 {
                                MouseInput::WheelUp
                            } else {
                                MouseInput::WheelDown
                            }
                        } else {
                            let prev_buttons = self.reader.prev_buttons;
                            let now_buttons = mouse.dwButtonState;

                            self.reader.prev_buttons = mouse.dwButtonState;

                            if prev_buttons == now_buttons {
                                if now_buttons == 0 && !self.reader.always_track_motion {
                                    return None;
                                }

                                MouseInput::Motion
                            } else {
                                button_changed(prev_buttons, now_buttons)?
                            }
                        };

                        let position = coord_to_cursor(mouse.dwMousePosition);

                        let mut mods = ModifierState::empty();

                        if has_alt(mouse.dwControlKeyState) {
                            mods |= ModifierState::ALT;
                        }
                        if has_ctrl(mouse.dwControlKeyState) {
                            mods |= ModifierState::CTRL;
                        }
                        if has_shift(mouse.dwControlKeyState) {
                            mods |= ModifierState::SHIFT;
                        }

                        Some(Mouse{
                            position,
                            input,
                            modifiers: mods,
                        })
                    } else {
                        None
                    }
                }
            }

            impl<'a> TerminalWriteGuard<'a> {
                fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                    TerminalWriteGuard{term, writer: writer}
                }

                fn enter_screen(&mut self) -> io::Result<HANDLE> {
                    let size = self.size()?;

                    let handle = result_handle(unsafe { CreateConsoleScreenBuffer(
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        ptr::null(),
                        CONSOLE_TEXTMODE_BUFFER,
                        ptr::null_mut()) })?;

                    if let Err(e) = unsafe { setup_screen(handle, size) } {
                        let _ = unsafe { close_handle(handle) };
                        return Err(e);
                    }

                    let old_handle = self.swap_out_handle(handle);

                    let mut out_mode = unsafe { console_mode(handle)? };
                    
                    out_mode &= !(ENABLE_WRAP_AT_EOL_OUTPUT | DISABLE_NEWLINE_AUTO_RETURN);

                    unsafe { set_console_mode(handle, out_mode)?; }

                    Ok(old_handle)
                }

                unsafe fn exit_screen(&mut self, old_handle: HANDLE) -> io::Result<()> {
                    result_bool(SetConsoleActiveScreenBuffer(old_handle))?;

                    let handle = self.swap_out_handle(old_handle);

                    close_handle(handle)
                }

                pub fn size(&self) -> io::Result<Size> {
                    unsafe { console_size(self.writer.out_handle) }
                }

                pub fn flush(&mut self) -> io::Result<()> {
                    Ok(())
                }

                pub fn clear_screen(&mut self) -> io::Result<()> {
                    let mut info = self.get_info()?;

                    let win_height = (info.srWindow.Bottom - info.srWindow.Top) + 1;

                    if win_height == info.dwSize.Y {
                        self.clear_area(
                            COORD{X: 0, Y: 0},
                            info.dwSize.X as DWORD * info.dwSize.Y as DWORD)?;
                    } else {
                        let max = info.dwSize.Y - (info.srWindow.Bottom + 1);
                        let dist = (info.dwCursorPosition.Y + 1) - info.srWindow.Top;

                        let down = dist.min(max);
                        
                        if down > 0 {
                            info.srWindow.Top += down as SHORT;
                            info.srWindow.Bottom += down as SHORT;

                            result_bool(unsafe { SetConsoleWindowInfo(
                                self.writer.out_handle,
                                TRUE,
                                &info.srWindow) })?;
                        }

                        let clear = info.srWindow.Bottom - info.dwCursorPosition.Y;
                        if clear < win_height {
                            let dist = (win_height - clear) as SHORT;

                            let src = SMALL_RECT{
                                Top: dist,
                                Bottom: info.dwCursorPosition.Y,
                                Left: 0,
                                Right: info.dwSize.X,
                            };

                            let dest = COORD{
                                X: 0,
                                Y: 0,
                            };

                            let fill = CHAR_INFO{
                                Char: unicode_char(b' ' as WCHAR),
                                Attributes: 0,
                            };

                            result_bool(unsafe { ScrollConsoleScreenBufferW(
                                self.writer.out_handle,
                                &src,
                                ptr::null(),
                                dest,
                                &fill) })?;
                        }
                    }
                    
                    self.move_abs(COORD{
                        X: info.srWindow.Left,
                        Y: info.srWindow.Top,
                    })
                }

                pub fn clear_to_line_end(&mut self) -> io::Result<()> {
                    let info = self.get_info()?;

                    let start = info.dwCursorPosition;
                    let size = info.dwSize;

                    self.clear_area(start, (size.X - start.X) as DWORD)
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                    let info = self.get_info()?;

                    let start = info.dwCursorPosition;
                    let size = info.dwSize;

                    let lines = (size.Y - start.Y) as DWORD;
                    let columns = (size.X - start.X) as DWORD;

                    let n = lines * size.X as DWORD + columns;

                    self.clear_area(start, n)
                }

                pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    self.move_abs(cursor_to_coord(pos))
                }

                pub fn move_to_first_column(&mut self) -> io::Result<()> {
                    let info = self.get_info()?;
                    self.move_abs(COORD{X: 0, Y: info.dwCursorPosition.Y})
                }

                pub fn move_up(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: 0, Y: to_short_neg(n)})
                }

                pub fn move_down(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: 0, Y: to_short(n)})
                }

                pub fn move_left(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: to_short_neg(n), Y: 0})
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                    self.move_rel(COORD{X: to_short(n), Y: 0})
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                    let (size, vis) = match mode {
                        CursorMode::Normal => (25, TRUE),
                        CursorMode::Invisible => (1, FALSE),
                        CursorMode::Overwrite => (100, TRUE),
                    };

                    let info = CONSOLE_CURSOR_INFO {
                        dwSize: size,
                        bVisible: vis,
                    };

                    result_bool(unsafe { SetConsoleCursorInfo(self.writer.out_handle, &info) })
                }

                pub fn clear_attributes(&mut self) -> io::Result<()> {
                    self.set_attributes(None, None, Style::empty())
                }

                pub fn add_style(&mut self, style: Style) -> io::Result<()> {
                    let add = style - self.writer.style;

                    if !add.is_empty() {
                        self.writer.style |= add;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                pub fn remove_style(&mut self, style: Style) -> io::Result<()> {
                    let remove = style & self.writer.style;

                    if !remove.is_empty() {
                        self.writer.style -= remove;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                pub fn set_style(&mut self, style: Style) -> io::Result<()> {
                    if self.writer.style != style {
                        self.writer.style = style;
                        self.update_attrs()?;
                    }
                    Ok(())
                }

                pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                    if self.writer.fg != fg {
                        self.writer.fg = fg;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                    if self.writer.bg != bg {
                        self.writer.bg = bg;
                        self.update_attrs()?;
                    }
                    Ok(())
                }

                pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> {
                    self.set_attributes(theme.fg, theme.bg, theme.style)
                }
                
                pub fn set_attributes(&mut self,
                        fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()> {
                    if self.writer.fg != fg || self.writer.bg != bg || self.writer.style != style {
                        self.writer.fg = fg;
                        self.writer.bg = bg;
                        self.writer.style = style;
                        self.update_attrs()?;
                    }

                    Ok(())
                }

                fn update_attrs(&mut self) -> io::Result<()> {
                    let mut attrs = self.term.default_attrs;

                    if let Some(fg) = self.writer.fg {
                        attrs &= !fg_code(Color::White);
                        attrs |= fg_code(fg);
                    }

                    if let Some(bg) = self.writer.bg {
                        attrs &= !bg_code(Color::White);
                        attrs |= bg_code(bg);
                    }

                    attrs |= style_code(self.writer.style);

                    if self.writer.style.contains(Style::REVERSE) {
                        attrs = swap_colors(attrs);
                    }

                    self.set_attrs(attrs)
                }

                pub fn write_char(&mut self, ch: char) -> io::Result<()> {
                    let mut buf = [0; 4];
                    self.write_str(ch.encode_utf8(&mut buf))
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                    let buf = OsStr::new(s).encode_wide().collect::<Vec<_>>();
                    let mut n = 0;

                    while buf.len() > n {
                        let mut n_dw = 0;
                        let len = to_dword(buf.len() - n);

                        result_bool(unsafe { WriteConsoleW(
                            self.writer.out_handle,
                            buf[n..].as_ptr() as *const VOID,
                            len,
                            &mut n_dw,
                            ptr::null_mut()) })?;

                        n += n_dw as usize;
                    }

                    Ok(())
                }

                pub fn write_styled(&mut self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.set_attributes(fg, bg, style)?;
                    self.write_str(text)?;
                    self.clear_attributes()
                }

                fn clear_area(&mut self, start: COORD, n: DWORD) -> io::Result<()> {
                    let mut n_chars = 0;

                    result_bool(unsafe { FillConsoleOutputAttribute(
                        self.writer.out_handle,
                        self.term.default_attrs,
                        n,
                        start,
                        &mut n_chars) })?;

                    result_bool(unsafe { FillConsoleOutputCharacterA(
                        self.writer.out_handle,
                        b' ' as CHAR,
                        n,
                        start,
                        &mut n_chars) })?;

                    Ok(())
                }

                fn move_abs(&mut self, pos: COORD) -> io::Result<()> {
                    result_bool(unsafe { SetConsoleCursorPosition(
                        self.writer.out_handle, pos) })
                }

                fn move_rel(&mut self, off: COORD) -> io::Result<()> {
                    let info = self.get_info()?;

                    let size = info.dwSize;
                    let cursor = info.dwCursorPosition;

                    let dest = COORD{
                        X: cursor.X.saturating_add(off.X).min(size.X - 1),
                        Y: cursor.Y.saturating_add(off.Y).min(size.Y - 1),
                    };

                    self.move_abs(dest)
                }

                fn set_attrs(&mut self, attrs: WORD) -> io::Result<()> {
                    result_bool(unsafe { SetConsoleTextAttribute(
                        self.writer.out_handle, attrs) })
                }

                fn get_info(&self) -> io::Result<CONSOLE_SCREEN_BUFFER_INFO> {
                    unsafe { console_info(self.writer.out_handle) }
                }

                fn swap_out_handle(&mut self, handle: HANDLE) -> HANDLE {
                    replace(&mut self.writer.out_handle, handle)
                }
            }

            fn as_millis(timeout: Option<Duration>) -> DWORD {
                match timeout {
                    Some(t) => {
                        let s = (t.as_secs() * 1_000) as DWORD;
                        let ms = (t.subsec_nanos() / 1_000_000) as DWORD;

                        s + ms
                    }
                    None => INFINITE,
                }
            }

            fn fg_code(color: Color) -> WORD {
                (match color {
                    Color::Black => 0,
                    Color::Blue => wincon::FOREGROUND_BLUE,
                    Color::Cyan => wincon::FOREGROUND_BLUE | wincon::FOREGROUND_GREEN,
                    Color::Green => wincon::FOREGROUND_GREEN,
                    Color::Magenta => wincon::FOREGROUND_BLUE | wincon::FOREGROUND_RED,
                    Color::Red => wincon::FOREGROUND_RED,
                    Color::White => wincon::FOREGROUND_RED | wincon::FOREGROUND_GREEN | wincon::FOREGROUND_BLUE,
                    Color::Yellow => wincon::FOREGROUND_RED | wincon::FOREGROUND_GREEN,
                }) as WORD
            }

            fn bg_code(color: Color) -> WORD {
                (match color {
                    Color::Black => 0,
                    Color::Blue => wincon::BACKGROUND_BLUE,
                    Color::Cyan => wincon::BACKGROUND_BLUE | wincon::BACKGROUND_GREEN,
                    Color::Green => wincon::BACKGROUND_GREEN,
                    Color::Magenta => wincon::BACKGROUND_BLUE | wincon::BACKGROUND_RED,
                    Color::Red => wincon::BACKGROUND_RED,
                    Color::White => wincon::BACKGROUND_RED | wincon::BACKGROUND_GREEN | wincon::BACKGROUND_BLUE,
                    Color::Yellow => wincon::BACKGROUND_RED | wincon::BACKGROUND_GREEN,
                }) as WORD
            }

            fn style_code(style: Style) -> WORD {
                let mut code = 0;

                if style.contains(Style::BOLD) {
                    code |= wincon::FOREGROUND_INTENSITY as WORD;
                }

                code
            }

            fn swap_colors(code: WORD) -> WORD {
                let fg_mask = fg_code(Color::White);
                let bg_mask = bg_code(Color::White);

                let fg_shift = fg_mask.trailing_zeros();
                let bg_shift = bg_mask.trailing_zeros();
                let shift = bg_shift - fg_shift;

                let fg = code & fg_mask;
                let bg = code & bg_mask;

                let swapped_fg = fg << shift;
                let swapped_bg = bg >> shift;

                (code & !(fg_mask | bg_mask)) | swapped_fg | swapped_bg
            }

            unsafe fn close_handle(handle: HANDLE) -> io::Result<()> {
                result_bool(CloseHandle(handle))
            }

            unsafe fn console_info(handle: HANDLE) -> io::Result<CONSOLE_SCREEN_BUFFER_INFO> {
                let mut info = zeroed();

                result_bool(GetConsoleScreenBufferInfo(handle, &mut info))?;

                Ok(info)
            }

            unsafe fn console_mode(handle: HANDLE) -> io::Result<DWORD> {
                let mut mode = 0;

                result_bool(GetConsoleMode(handle, &mut mode))?;

                Ok(mode)
            }

            unsafe fn console_size(handle: HANDLE) -> io::Result<Size> {
                let info = console_info(handle)?;

                Ok(coord_to_size(info.dwSize))
            }

            unsafe fn set_console_mode(handle: HANDLE, mode: DWORD) -> io::Result<()> {
                result_bool(SetConsoleMode(handle, mode))
            }
            
            unsafe fn setup_screen(handle: HANDLE, size: Size) -> io::Result<()> {
                result_bool(SetConsoleScreenBufferSize(handle, size_to_coord(size)))?;
                result_bool(SetConsoleActiveScreenBuffer(handle))
            }

            unsafe fn prepare_output(handle: HANDLE) -> io::Result<DWORD> {
                let old_out_mode = console_mode(handle)?;

                let mut out_mode = old_out_mode;
                
                out_mode |= ENABLE_PROCESSED_OUTPUT;
                
                out_mode |= ENABLE_WRAP_AT_EOL_OUTPUT;

                set_console_mode(handle, out_mode)?;

                Ok(old_out_mode)
            }

            fn button_changed(prev_buttons: DWORD, now_buttons: DWORD) -> Option<MouseInput> {
                use std::mem::size_of;

                let n_bits = size_of::<DWORD>() * 8;

                for i in 0..n_bits {
                    let bit = 1 << i;

                    let changed = (prev_buttons ^ now_buttons) & bit != 0;

                    if changed {
                        let button = bit_to_button(bit);

                        let input = if prev_buttons & bit == 0 {
                            MouseInput::ButtonPressed(button)
                        } else {
                            MouseInput::ButtonReleased(button)
                        };

                        return Some(input);
                    }
                }

                None
            }

            fn bit_to_button(mut bit: DWORD) -> MouseButton {
                assert!(bit != 0);

                match bit {
                    wincon::FROM_LEFT_1ST_BUTTON_PRESSED => MouseButton::Left,
                    wincon::RIGHTMOST_BUTTON_PRESSED => MouseButton::Right,
                    wincon::FROM_LEFT_2ND_BUTTON_PRESSED => MouseButton::Middle,
                    _ => {
                        bit >>= 3;
                        let mut n = 3;

                        while bit != 1 {
                            bit >>= 1;
                            n += 1;
                        }

                        MouseButton::Other(n)
                    }
                }
            }

            fn coord_to_cursor(pos: COORD) -> Cursor {
                Cursor{
                    line: pos.Y as usize,
                    column: pos.X as usize,
                }
            }

            fn coord_to_size(size: COORD) -> Size {
                Size{
                    lines: size.Y as usize,
                    columns: size.X as usize,
                }
            }

            fn cursor_to_coord(pos: Cursor) -> COORD {
                COORD{
                    Y: to_short(pos.line),
                    X: to_short(pos.column),
                }
            }

            fn size_to_coord(size: Size) -> COORD {
                COORD{
                    Y: to_short(size.lines),
                    X: to_short(size.columns),
                }
            }

            fn has_alt(state: DWORD) -> bool {
                state & (wincon::LEFT_ALT_PRESSED | wincon::RIGHT_ALT_PRESSED) != 0
            }

            fn has_ctrl(state: DWORD) -> bool {
                state & (wincon::LEFT_CTRL_PRESSED | wincon::RIGHT_CTRL_PRESSED) != 0
            }

            fn has_shift(state: DWORD) -> bool {
                state & wincon::SHIFT_PRESSED != 0
            }

            fn to_dword(n: usize) -> DWORD {
                if n > DWORD::max_value() as usize {
                    DWORD::max_value()
                } else {
                    n as DWORD
                }
            }

            fn to_short(n: usize) -> SHORT {
                if n > SHORT::max_value() as usize {
                    SHORT::max_value()
                } else {
                    n as SHORT
                }
            }

            fn to_short_neg(n: usize) -> SHORT {
                let n = if n > isize::max_value() as usize {
                    isize::min_value()
                } else {
                    -(n as isize)
                };

                if n < SHORT::min_value() as isize {
                    SHORT::min_value()
                } else {
                    n as SHORT
                }
            }

            fn key_press_event(event: &INPUT_RECORD) -> Option<Key> {
                if event.EventType == KEY_EVENT {
                    let key = unsafe { event.Event.KeyEvent() };

                    if key.bKeyDown == FALSE {
                        return None;
                    }

                    let key = match key.wVirtualKeyCode as c_int {
                        winuser::VK_BACK => Key::Backspace,
                        winuser::VK_RETURN => Key::Enter,
                        winuser::VK_ESCAPE => Key::Escape,
                        winuser::VK_TAB => Key::Tab,
                        winuser::VK_UP => Key::Up,
                        winuser::VK_DOWN => Key::Down,
                        winuser::VK_LEFT => Key::Left,
                        winuser::VK_RIGHT => Key::Right,
                        winuser::VK_DELETE => Key::Delete,
                        winuser::VK_INSERT => Key::Insert,
                        winuser::VK_HOME => Key::Home,
                        winuser::VK_END => Key::End,
                        winuser::VK_PRIOR => Key::PageUp,
                        winuser::VK_NEXT => Key::PageDown,
                        winuser::VK_F1 => Key::F(1),
                        winuser::VK_F2 => Key::F(2),
                        winuser::VK_F3 => Key::F(3),
                        winuser::VK_F4 => Key::F(4),
                        winuser::VK_F5 => Key::F(5),
                        winuser::VK_F6 => Key::F(6),
                        winuser::VK_F7 => Key::F(7),
                        winuser::VK_F8 => Key::F(8),
                        winuser::VK_F9 => Key::F(9),
                        winuser::VK_F10 => Key::F(10),
                        winuser::VK_F11 => Key::F(11),
                        winuser::VK_F12 => Key::F(12),
                        _ => {
                            if has_alt(key.dwControlKeyState) {
                                return None;
                            }

                            let is_ctrl = has_ctrl(key.dwControlKeyState);

                            let u_char = unsafe { *key.uChar.UnicodeChar() };

                            if u_char != 0 {
                                match char::from_u32(u_char as u32) {
                                    Some(ch) if is_ctrl => Key::Ctrl(unctrl_lower(ch)),
                                    Some(ch) => ch.into(),
                                    None => return None
                                }
                            } else {
                                return None;
                            }
                        }
                    };

                    Some(key)
                } else {
                    None
                }
            }

            pub fn size_event(event: &INPUT_RECORD) -> Option<Size> {
                if event.EventType == WINDOW_BUFFER_SIZE_EVENT {
                    let size = unsafe { event.Event.WindowBufferSizeEvent() };

                    Some(Size{
                        lines: size.dwSize.Y as usize,
                        columns: size.dwSize.X as usize,
                    })
                } else {
                    None
                }
            }

            fn unicode_char(wch: WCHAR) -> CHAR_INFO_Char {
                let mut ch: CHAR_INFO_Char = unsafe { zeroed() };

                unsafe { *ch.UnicodeChar_mut() = wch; }

                ch
            }

            fn result_bool(b: BOOL) -> io::Result<()> {
                if b == FALSE {
                    Err(io::Error::last_os_error())
                } else {
                    Ok(())
                }
            }

            fn result_handle(ptr: HANDLE) -> io::Result<HANDLE> {
                if ptr.is_null() {
                    Err(io::Error::last_os_error())
                } else {
                    Ok(ptr)
                }
            }

            static CATCH_SIGNALS: AtomicUsize = AtomicUsize::new(0);
            
            static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(!0);

            fn catch_signals(set: SignalSet) {
                let mut sigs = 0;

                if set.contains(Signal::Break) {
                    sigs |= (1 << CTRL_BREAK_EVENT) as usize;
                }
                if set.contains(Signal::Interrupt) {
                    sigs |= (1 << CTRL_C_EVENT) as usize;
                }

                CATCH_SIGNALS.store(sigs, Ordering::Relaxed);
            }

            unsafe extern "system" fn ctrl_handler(ctrl_type: DWORD) -> BOOL {
                match ctrl_type {
                    CTRL_BREAK_EVENT | CTRL_C_EVENT => {
                        let catch = CATCH_SIGNALS.load(Ordering::Relaxed);

                        if catch & (1 << ctrl_type) as usize == 0 {
                            return FALSE;
                        }

                        LAST_SIGNAL.store(ctrl_type as usize, Ordering::Relaxed);

                        if let Ok(handle) = result_handle( GetStdHandle(STD_INPUT_HANDLE))
                        {
                            let input = INPUT_RECORD{
                                EventType: KEY_EVENT,
                                // KEY_EVENT { bKeyDown: FALSE, ... }
                                Event: zeroed(),
                            };

                            let mut n = 0;

                            // Ignore any errors from this
                            let _ = WriteConsoleInputW(
                                handle,
                                &input,
                                1,
                                &mut n);
                        }

                        TRUE
                    }
                    _ => FALSE
                }
            }

            fn conv_signal(sig: DWORD) -> Option<Signal> {
                match sig {
                    CTRL_BREAK_EVENT => Some(Signal::Break),
                    CTRL_C_EVENT => Some(Signal::Interrupt),
                    _ => None
                }
            }

            fn get_signal() -> Option<Signal> {
                conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as DWORD)
            }

            fn take_signal() -> Option<Signal> {
                conv_signal(LAST_SIGNAL.swap(!0, Ordering::Relaxed) as DWORD)
            }
        }

        mod screen
        {
            use ::
            {
                *,
            };
            /*
            use std::io;
            use std::sync::{LockResult, Mutex, MutexGuard, TryLockResult};
            use std::time::Duration;

            use winapi::shared::ntdef::HANDLE;
            use winapi::um::wincon::INPUT_RECORD;

            use ::buffer::ScreenBuffer;
            use ::priv_util::{
                map_lock_result, map_try_lock_result,
                map2_lock_result, map2_try_lock_result,
            };
            use ::sys::terminal::{
                size_event, PrepareState,
                Terminal, TerminalReadGuard, TerminalWriteGuard,
            };
            use ::terminal::{Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style};
            */
            pub struct Screen {
                term: Terminal,

                state: Option<PrepareState>,
                old_handle: HANDLE,
                writer: Mutex<Writer>,
            }

            pub struct ScreenReadGuard<'a> {
                screen: &'a Screen,
                reader: TerminalReadGuard<'a>,
            }

            pub struct ScreenWriteGuard<'a> {
                writer: TerminalWriteGuard<'a>,
                data: MutexGuard<'a, Writer>,
            }

            struct Writer {
                buffer: ScreenBuffer,
                clear_screen: bool,
                real_cursor: Cursor,
            }

            impl Screen {
                pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen> {
                    let size = term.size()?;

                    let old_handle = term.enter_screen()?;
                    let state = term.prepare(config)?;

                    Ok(Screen{
                        term,
                        state: Some(state),
                        writer: Mutex::new(Writer{
                            buffer: ScreenBuffer::new(size),
                            clear_screen: false,
                            real_cursor: Cursor::default(),
                        }),
                        old_handle,
                    })
                }

                pub fn stdout(config: PrepareConfig) -> io::Result<Screen> {
                    Screen::new(Terminal::stdout()?, config)
                }

                pub fn stderr(config: PrepareConfig) -> io::Result<Screen> {
                    Screen::new(Terminal::stderr()?, config)
                }

                forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                pub fn lock_read(&self) -> LockResult<ScreenReadGuard> {
                    map_lock_result(self.term.lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> {
                    map_try_lock_result(self.term.try_lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> {
                    map2_lock_result(self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard> {
                    map2_try_lock_result(self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                fn lock_reader(&self) -> ScreenReadGuard {
                    self.lock_read().expect("Screen::lock_reader")
                }

                fn lock_writer(&self) -> ScreenWriteGuard {
                    self.lock_write().expect("Screen::lock_writer")
                }

                fn lock_write_data(&self) -> MutexGuard<Writer> {
                    self.writer.lock().expect("Screen::lock_writer")
                }

                pub fn name(&self) -> &str {
                    self.term.name()
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                    self.term.set_cursor_mode(mode)
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn read_raw_event(&self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.lock_reader().read_raw_event(events, timeout)
                }

                pub fn refresh(&self) -> io::Result<()> {
                    self.lock_writer().refresh()
                }
            }

            impl Drop for Screen {
                fn drop(&mut self) {
                    let res = if let Some(state) = self.state.take() {
                        self.term.restore(state)
                    } else {
                        Ok(())
                    };

                    if let Err(e) = res.and_then(
                            |_| unsafe { self.term.exit_screen(self.old_handle) }) {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            unsafe impl Send for Screen {}
            unsafe impl Sync for Screen {}

            impl<'a> ScreenReadGuard<'a> {
                fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> {
                    ScreenReadGuard{screen, reader}
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    self.reader.wait_event(timeout)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    let r = self.reader.read_event(timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    let r = self.reader.read_raw(buf, timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw_event(&mut self, events: &mut [INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    let r = self.reader.read_raw_event(events, timeout)?;

                    if let Some(Event::Raw(n)) = r {
                        for ev in events[..n].iter().rev() {
                            if let Some(size) = size_event(ev) {
                                self.screen.lock_write_data().update_size(size);
                                break;
                            }
                        }
                    }

                    Ok(r)
                }
            }

            impl<'a> ScreenWriteGuard<'a> {
                fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>)
                        -> ScreenWriteGuard<'a> {
                    ScreenWriteGuard{writer, data}
                }

                forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                    self.writer.set_cursor_mode(mode)
                }

                pub fn refresh(&mut self) -> io::Result<()> {
                    if self.data.clear_screen {
                        self.writer.clear_screen()?;
                        self.data.clear_screen = false;
                    }

                    let mut real_attrs = (None, None, Style::empty());

                    self.writer.clear_attributes()?;

                    let mut indices = self.data.buffer.indices();

                    while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices) {
                        self.move_cursor(pos)?;

                        self.apply_attrs(real_attrs, cell.attrs())?;
                        self.writer.write_str(cell.text())?;
                        self.data.real_cursor.column += 1;

                        real_attrs = cell.attrs();
                    }

                    self.writer.clear_attributes()?;

                    let size = self.data.buffer.size();
                    let pos = self.data.buffer.cursor();

                    if pos.is_out_of_bounds(size) {
                        self.move_cursor(Cursor::last(size))?;
                    } else {
                        self.move_cursor(pos)?;
                    }

                    Ok(())
                }

                fn apply_attrs(&mut self,
                        src: (Option<Color>, Option<Color>, Style),
                        dest: (Option<Color>, Option<Color>, Style)) -> io::Result<()> {
                    if src != dest {
                        self.writer.set_attributes(dest.0, dest.1, dest.2)?;
                    }
                    Ok(())
                }

                fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    if self.data.real_cursor != pos {
                        self.writer.move_cursor(pos)?;
                        self.data.real_cursor = pos;
                    }
                    Ok(())
                }
            }

            impl<'a> Drop for ScreenWriteGuard<'a> {
                fn drop(&mut self) {
                    if let Err(e) = self.refresh() {
                        eprintln!("failed to refresh screen: {}", e);
                    }
                }
            }

            impl Writer {
                fn update_size(&mut self, new_size: Size) {
                    if self.real_cursor.is_out_of_bounds(new_size) {
                        // Force cursor move on next refresh
                        self.real_cursor = (!0, !0).into();
                    }
                    self.buffer.resize(new_size);
                    self.clear_screen = true;
                }
            }
        }
        
        pub trait IsZero
        {
            fn is_zero(&self) -> bool;
        }

        impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }

        pub fn cvt<I: IsZero>(i: I) -> ::io::Result<I>
        {
            if i.is_zero() { Err( ::io::Error::last_os_error() ) }
            else { Ok(i) }
        }

        /// Just to provide the same interface as sys/pal/unix/net.rs
        pub fn cvt_r<T, F>(mut f: F) -> io::Result<T> where
        T: IsMinusOne,
        F: FnMut() -> T,
        {
            cvt(f())
        }
    }
    #[cfg( unix )] pub use self::unix as api;
    #[cfg( windows )] pub use self::windows as api;
    pub use self::api::{ Terminal, TerminalReadGuard, TerminalWriteGuard };
    
    /// Private trait used to prevent external crates from implementing extension traits
    pub trait Private {}

    impl Private for Screen {}
    impl<'a> Private for ScreenReadGuard<'a> {}
    impl Private for Terminal {}
    impl<'a> Private for TerminalReadGuard<'a> {}
    
    pub fn map_lock_result<F, T, U>(res: LockResult<T>, f: F) -> LockResult<U> where
    F: FnOnce(T) -> U
    {
        match res
        {
            Ok(t) => Ok(f(t)),
            Err(e) => Err(PoisonError::new(f(e.into_inner()))),
        }
    
    }

    pub fn map_try_lock_result<F, T, U>(res: TryLockResult<T>, f: F) -> TryLockResult<U> where
    F: FnOnce(T) -> U
    {
        match res
        {
            Ok(t) => Ok(f(t)),
            Err(TryLockError::Poisoned(p)) => Err(TryLockError::Poisoned( PoisonError::new(f(p.into_inner())))),
            Err(TryLockError::WouldBlock) => Err(TryLockError::WouldBlock),
        }
    }

    pub fn map2_lock_result<F, T, U, R>(res: LockResult<T>, res2: LockResult<U>, f: F) -> LockResult<R> where 
    F: FnOnce(T, U) -> R
    {
        match (res, res2)
        {
            (Ok(a), Ok(b)) => Ok(f(a, b)),
            (Ok(a), Err(b)) => Err(PoisonError::new(f(a, b.into_inner()))),
            (Err(a), Ok(b)) => Err(PoisonError::new(f(a.into_inner(), b))),
            (Err(a), Err(b)) => Err(PoisonError::new(f(a.into_inner(), b.into_inner()))),
        }
    }

    pub fn map2_try_lock_result<F, T, U, R>( res: TryLockResult<T>, res2: TryLockResult<U>, f: F) -> 
    TryLockResult<R> where 
    F: FnOnce(T, U) -> R
    {
        match (res, res2)
        {
            (Ok(a), Ok(b)) => Ok(f(a, b)), (Err(TryLockError::WouldBlock), _) => 
            Err(TryLockError::WouldBlock),

            (_, Err(TryLockError::WouldBlock)) => 
            Err(TryLockError::WouldBlock),
            
            (Ok(a), Err(TryLockError::Poisoned(b))) => 
            Err(TryLockError::Poisoned(PoisonError::new(f(a, b.into_inner())))),

            (Err(TryLockError::Poisoned(a)), Ok(b)) =>
            Err(TryLockError::Poisoned(PoisonError::new(f(a.into_inner(), b)))),

            (Err(TryLockError::Poisoned(a)), Err(TryLockError::Poisoned(b))) =>
            Err(TryLockError::Poisoned(PoisonError::new( f(a.into_inner(), b.into_inner())))),
        }
    }

    pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T>
    {
        if t.is_minus_one() { Err(last_error()) } else { Ok(t) }
    }
} pub use self::system as sys;
/// Types and Traits for working with asynchronous tasks.
pub mod task
{
    pub use std::task::{ * };
}
/**/
pub mod terminal
{
    use ::
    {
        borrow::{ Cow },
        ffi::{ Function },
        fmt::{ columns },
        fs::{ File, OpenOptions },
        io::
        { 
            self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _,
            reader::{ Read, Reader, ReadLock, ReadResult },
            writer::{ Write, Writer, WriteLock },
        },
        path::{ Path },
        primitive::{ Command },
        sync::{ Arc, Mutex, MutexGuard },
        time::{ Duration },
        *,
    };
    /*
    use linefeed::command::Command;
    use linefeed::complete::Completer;
    use linefeed::function::Function;
    use linefeed::inputrc::Directive;
    use linefeed::variables::Variable;
    */
    /// ANSI color codes wrapped with \x01 and \x02 for lineread
    pub const GREEN:&str = "\x01\x1b[0;32m\x02";
    /// Metadata Database
    pub mod metadata
    {
        use ::
        {
            *,
        };
        /*
        use std::env;
        use std::fs::File;
        use std::io::{BufWriter, Write};
        use std::path::Path;
        */
        
        pub const BOOLEAN: &[&str] = &
        [
            "auto_left_margin", "auto_right_margin", "no_esc_ctlc", "ceol_standout_glitch", "eat_newline_glitch",
            "erase_overstrike", "generic_type", "hard_copy", "has_meta_key", "has_status_line", "insert_null_glitch",
            "memory_above", "memory_below", "move_insert_mode", "move_standout_mode", "over_strike",
            "status_line_esc_ok", "dest_tabs_magic_smso", "tilde_glitch", "transparent_underline", "xon_xoff",
            "needs_xon_xoff", "prtr_silent", "hard_cursor", "non_rev_rmcup", "no_pad_char", "non_dest_scroll_region",
            "can_change", "back_color_erase", "hue_lightness_saturation", "col_addr_glitch", "cr_cancels_micro_mode",
            "has_print_wheel", "row_addr_glitch", "semi_auto_right_margin", "cpi_changes_res", "lpi_changes_res",
            "backspaces_with_bs", "crt_no_scrolling", "no_correctly_working_cr", "gnu_has_meta_key",
            "linefeed_is_newline", "has_hardware_tabs", "return_does_clr_eol"
        ];

        pub const NUMBER: &[&str] = &
        [
            "columns", "init_tabs", "lines", "lines_of_memory", "magic_cookie_glitch", "padding_baud_rate", 
            "virtual_terminal", "width_status_line", "num_labels", "label_height", "label_width", "max_attributes",
            "maximum_windows", "max_colors", "max_pairs", "no_color_video", "buffer_capacity", "dot_vert_spacing",
            "dot_horz_spacing", "max_micro_address", "max_micro_jump", "micro_col_size", "micro_line_size",
            "number_of_pins", "output_res_char", "output_res_line", "output_res_horz_inch", "output_res_vert_inch",
            "print_rate", "wide_char_size", "buttons", "bit_image_entwining", "bit_image_type",
            "magic_cookie_glitch_ul", "carriage_return_delay", "new_line_delay", "backspace_delay",
            "horizontal_tab_delay", "number_of_function_keys"
        ];

        pub const STRING: &[&str] = &
        [
            "back_tab", "bell", "carriage_return", "change_scroll_region", "clear_all_tabs", "clear_screen", "clr_eol",
            "clr_eos", "column_address", "command_character", "cursor_address", "cursor_down", "cursor_home", 
            "cursor_invisible", "cursor_left", "cursor_mem_address", "cursor_normal", "cursor_right", "cursor_to_ll",
            "cursor_up", "cursor_visible", "delete_character", "delete_line", "dis_status_line", "down_half_line",
            "enter_alt_charset_mode", "enter_blink_mode", "enter_bold_mode", "enter_ca_mode", "enter_delete_mode",
            "enter_dim_mode", "enter_insert_mode", "enter_secure_mode", "enter_protected_mode", "enter_reverse_mode",
            "enter_standout_mode", "enter_underline_mode", "erase_chars", "exit_alt_charset_mode",
            "exit_attribute_mode", "exit_ca_mode", "exit_delete_mode", "exit_insert_mode", "exit_standout_mode",
            "exit_underline_mode", "flash_screen", "form_feed", "from_status_line", "init_1string", "init_2string",
            "init_3string", "init_file", "insert_character", "insert_line", "insert_padding", "key_backspace",
            "key_catab", "key_clear", "key_ctab", "key_dc", "key_dl", "key_down", "key_eic", "key_eol", "key_eos",
            "key_f0", "key_f1", "key_f10", "key_f2", "key_f3", "key_f4", "key_f5", "key_f6", "key_f7", "key_f8",
            "key_f9", "key_home", "key_ic", "key_il", "key_left", "key_ll", "key_npage", "key_ppage", "key_right",
            "key_sf", "key_sr", "key_stab", "key_up", "keypad_local", "keypad_xmit", "lab_f0", "lab_f1", "lab_f10",
            "lab_f2", "lab_f3", "lab_f4", "lab_f5", "lab_f6", "lab_f7", "lab_f8", "lab_f9", "meta_off", "meta_on",
            "newline", "pad_char", "parm_dch", "parm_delete_line", "parm_down_cursor", "parm_ich", "parm_index",
            "parm_insert_line", "parm_left_cursor", "parm_right_cursor", "parm_rindex", "parm_up_cursor", "pkey_key",
            "pkey_local", "pkey_xmit", "print_screen", "prtr_off", "prtr_on", "repeat_char", "reset_1string",
            "reset_2string", "reset_3string", "reset_file", "restore_cursor", "row_address", "save_cursor",
            "scroll_forward", "scroll_reverse", "set_attributes", "set_tab", "set_window", "tab", "to_status_line",
            "underline_char", "up_half_line", "init_prog", "key_a1", "key_a3", "key_b2", "key_c1", "key_c3",
            "prtr_non", "char_padding", "acs_chars", "plab_norm", "key_btab", "enter_xon_mode", "exit_xon_mode",
            "enter_am_mode", "exit_am_mode", "xon_character", "xoff_character", "ena_acs", "label_on", "label_off",
            "key_beg", "key_cancel",
            "key_close", "key_command", "key_copy", "key_create", "key_end", "key_enter", "key_exit",
            "key_find", "key_help", "key_mark", "key_message", "key_move", "key_next", "key_open",
            "key_options", "key_previous", "key_print", "key_redo", "key_reference", "key_refresh",
            "key_replace", "key_restart", "key_resume", "key_save", "key_suspend", "key_undo", "key_sbeg",
            "key_scancel", "key_scommand", "key_scopy", "key_screate", "key_sdc", "key_sdl", "key_select",
            "key_send", "key_seol", "key_sexit", "key_sfind", "key_shelp", "key_shome", "key_sic",
            "key_sleft", "key_smessage", "key_smove", "key_snext", "key_soptions", "key_sprevious",
            "key_sprint", "key_sredo", "key_sreplace", "key_sright", "key_srsume", "key_ssave",
            "key_ssuspend", "key_sundo", "req_for_input", "key_f11", "key_f12", "key_f13", "key_f14",
            "key_f15", "key_f16", "key_f17", "key_f18", "key_f19", "key_f20", "key_f21", "key_f22",
            "key_f23", "key_f24", "key_f25", "key_f26", "key_f27", "key_f28", "key_f29", "key_f30",
            "key_f31", "key_f32", "key_f33", "key_f34", "key_f35", "key_f36", "key_f37", "key_f38",
            "key_f39", "key_f40", "key_f41", "key_f42", "key_f43", "key_f44", "key_f45", "key_f46",
            "key_f47", "key_f48", "key_f49", "key_f50", "key_f51", "key_f52", "key_f53", "key_f54",
            "key_f55", "key_f56", "key_f57", "key_f58", "key_f59", "key_f60", "key_f61", "key_f62",
            "key_f63", "clr_bol", "clear_margins", "set_left_margin", "set_right_margin", "label_format",
            "set_clock", "display_clock", "remove_clock", "create_window", "goto_window", "hangup",
            "dial_phone", "quick_dial", "tone", "pulse", "flash_hook", "fixed_pause", "wait_tone", "user0",
            "user1", "user2", "user3", "user4", "user5", "user6", "user7", "user8", "user9", "orig_pair",
            "orig_colors", "initialize_color", "initialize_pair", "set_color_pair", "set_foreground",
            "set_background", "change_char_pitch", "change_line_pitch", "change_res_horz",
            "change_res_vert", "define_char", "enter_doublewide_mode", "enter_draft_quality",
            "enter_italics_mode", "enter_leftward_mode", "enter_micro_mode", "enter_near_letter_quality",
            "enter_normal_quality", "enter_shadow_mode", "enter_subscript_mode", "enter_superscript_mode",
            "enter_upward_mode", "exit_doublewide_mode", "exit_italics_mode", "exit_leftward_mode",
            "exit_micro_mode", "exit_shadow_mode", "exit_subscript_mode", "exit_superscript_mode",
            "exit_upward_mode", "micro_column_address", "micro_down", "micro_left", "micro_right",
            "micro_row_address", "micro_up", "order_of_pins", "parm_down_micro", "parm_left_micro",
            "parm_right_micro", "parm_up_micro", "select_char_set", "set_bottom_margin",
            "set_bottom_margin_parm", "set_left_margin_parm", "set_right_margin_parm", "set_top_margin",
            "set_top_margin_parm", "start_bit_image", "start_char_set_def", "stop_bit_image",
            "stop_char_set_def", "subscript_characters", "superscript_characters", "these_cause_cr",
            "zero_motion", "char_set_names", "key_mouse", "mouse_info", "req_mouse_pos", "get_mouse",
            "set_a_foreground", "set_a_background", "pkey_plab", "device_type", "code_set_init",
            "set0_des_seq", "set1_des_seq", "set2_des_seq", "set3_des_seq", "set_lr_margin",
            "set_tb_margin", "bit_image_repeat", "bit_image_newline", "bit_image_carriage_return",
            "color_names", "define_bit_image_region", "end_bit_image_region", "set_color_band",
            "set_page_length", "display_pc_char", "enter_pc_charset_mode", "exit_pc_charset_mode",
            "enter_scancode_mode", "exit_scancode_mode", "pc_term_options", "scancode_escape",
            "alt_scancode_esc", "enter_horizontal_hl_mode", "enter_left_hl_mode", "enter_low_hl_mode",
            "enter_right_hl_mode", "enter_top_hl_mode", "enter_vertical_hl_mode", "set_a_attributes",
            "set_pglen_inch", "termcap_init2", "termcap_reset", "linefeed_if_not_lf",
            "backspace_if_not_bs", "other_non_function_keys", "arrow_key_map", "acs_ulcorner",
            "acs_llcorner", "acs_urcorner", "acs_lrcorner", "acs_ltee", "acs_rtee", "acs_btee", "acs_ttee",
            "acs_hline", "acs_vline", "acs_plus", "memory_lock", "memory_unlock", "box_chars_1"
        ];

        pub const TERMINFO: &[(&str, &str)] = &
        [
            ("auto_left_margin", "bw"),
            ("auto_right_margin", "am"),
            ("back_color_erase", "bce"),
            ("can_change", "ccc"),
            ("ceol_standout_glitch", "xhp"),
            ("col_addr_glitch", "xhpa"),
            ("cpi_changes_res", "cpix"),
            ("cr_cancels_micro_mode", "crxm"),
            ("dest_tabs_magic_smso", "xt"),
            ("eat_newline_glitch", "xenl"),
            ("erase_overstrike", "eo"),
            ("generic_type", "gn"),
            ("hard_copy", "hc"),
            ("hard_cursor", "chts"),
            ("has_meta_key", "km"),
            ("has_print_wheel", "daisy"),
            ("has_status_line", "hs"),
            ("hue_lightness_saturation", "hls"),
            ("insert_null_glitch", "in"),
            ("lpi_changes_res", "lpix"),
            ("memory_above", "da"),
            ("memory_below", "db"),
            ("move_insert_mode", "mir"),
            ("move_standout_mode", "msgr"),
            ("needs_xon_xoff", "nxon"),
            ("no_esc_ctlc", "xsb"),
            ("no_pad_char", "npc"),
            ("non_dest_scroll_region", "ndscr"),
            ("non_rev_rmcup", "nrrmc"),
            ("over_strike", "os"),
            ("prtr_silent", "mc5i"),
            ("row_addr_glitch", "xvpa"),
            ("semi_auto_right_margin", "sam"),
            ("status_line_esc_ok", "eslok"),
            ("tilde_glitch", "hz"),
            ("transparent_underline", "ul"),
            ("xon_xoff", "xon"),
            ("bit_image_entwining", "bitwin"),
            ("bit_image_type", "bitype"),
            ("buffer_capacity", "bufsz"),
            ("buttons", "btns"),
            ("columns", "cols"),
            ("dot_horz_spacing", "spinh"),
            ("dot_vert_spacing", "spinv"),
            ("init_tabs", "it"),
            ("label_height", "lh"),
            ("label_width", "lw"),
            ("lines", "lines"),
            ("lines_of_memory", "lm"),
            ("max_attributes", "ma"),
            ("magic_cookie_glitch", "xmc"),
            ("max_colors", "colors"),
            ("max_micro_address", "maddr"),
            ("max_micro_jump", "mjump"),
            ("max_pairs", "pairs"),
            ("maximum_windows", "wnum"),
            ("micro_col_size", "mcs"),
            ("micro_line_size", "mls"),
            ("no_color_video", "ncv"),
            ("num_labels", "nlab"),
            ("number_of_pins", "npins"),
            ("output_res_char", "orc"),
            ("output_res_line", "orl"),
            ("output_res_horz_inch", "orhi"),
            ("output_res_vert_inch", "orvi"),
            ("padding_baud_rate", "pb"),
            ("print_rate", "cps"),
            ("virtual_terminal", "vt"),
            ("wide_char_size", "widcs"),
            ("width_status_line", "wsl"),
            ("acs_chars", "acsc"),
            ("alt_scancode_esc", "scesa"),
            ("back_tab", "cbt"),
            ("bell", "bel"),
            ("bit_image_carriage_return", "bicr"),
            ("bit_image_newline", "binel"),
            ("bit_image_repeat", "birep"),
            ("carriage_return", "cr"),
            ("change_char_pitch", "cpi"),
            ("change_line_pitch", "lpi"),
            ("change_res_horz", "chr"),
            ("change_res_vert", "cvr"),
            ("change_scroll_region", "csr"),
            ("char_padding", "rmp"),
            ("char_set_names", "csnm"),
            ("clear_all_tabs", "tbc"),
            ("clear_margins", "mgc"),
            ("clear_screen", "clear"),
            ("clr_bol", "el1"),
            ("clr_eol", "el"),
            ("clr_eos", "ed"),
            ("code_set_init", "csin"),
            ("color_names", "colornm"),
            ("column_address", "hpa"),
            ("command_character", "cmdch"),
            ("create_window", "cwin"),
            ("cursor_address", "cup"),
            ("cursor_down", "cud1"),
            ("cursor_home", "home"),
            ("cursor_invisible", "civis"),
            ("cursor_left", "cub1"),
            ("cursor_mem_address", "mrcup"),
            ("cursor_normal", "cnorm"),
            ("cursor_right", "cuf1"),
            ("cursor_to_ll", "ll"),
            ("cursor_up", "cuu1"),
            ("cursor_visible", "cvvis"),
            ("define_bit_image_region", "defbi"),
            ("define_char", "defc"),
            ("delete_character", "dch1"),
            ("delete_line", "dl1"),
            ("device_type", "devt"),
            ("dial_phone", "dial"),
            ("dis_status_line", "dsl"),
            ("display_clock", "dclk"),
            ("display_pc_char", "dispc"),
            ("down_half_line", "hd"),
            ("ena_acs", "enacs"),
            ("end_bit_image_region", "endbi"),
            ("enter_alt_charset_mode", "smacs"),
            ("enter_am_mode", "smam"),
            ("enter_blink_mode", "blink"),
            ("enter_bold_mode", "bold"),
            ("enter_ca_mode", "smcup"),
            ("enter_delete_mode", "smdc"),
            ("enter_dim_mode", "dim"),
            ("enter_doublewide_mode", "swidm"),
            ("enter_draft_quality", "sdrfq"),
            ("enter_horizontal_hl_mode", "ehhlm"),
            ("enter_insert_mode", "smir"),
            ("enter_italics_mode", "sitm"),
            ("enter_left_hl_mode", "elhlm"),
            ("enter_leftward_mode", "slm"),
            ("enter_low_hl_mode", "elohlm"),
            ("enter_micro_mode", "smicm"),
            ("enter_near_letter_quality", "snlq"),
            ("enter_normal_quality", "snrmq"),
            ("enter_pc_charset_mode", "smpch"),
            ("enter_protected_mode", "prot"),
            ("enter_reverse_mode", "rev"),
            ("enter_right_hl_mode", "erhlm"),
            ("enter_scancode_mode", "smsc"),
            ("enter_secure_mode", "invis"),
            ("enter_shadow_mode", "sshm"),
            ("enter_standout_mode", "smso"),
            ("enter_subscript_mode", "ssubm"),
            ("enter_superscript_mode", "ssupm"),
            ("enter_top_hl_mode", "ethlm"),
            ("enter_underline_mode", "smul"),
            ("enter_upward_mode", "sum"),
            ("enter_vertical_hl_mode", "evhlm"),
            ("enter_xon_mode", "smxon"),
            ("erase_chars", "ech"),
            ("exit_alt_charset_mode", "rmacs"),
            ("exit_am_mode", "rmam"),
            ("exit_attribute_mode", "sgr0"),
            ("exit_ca_mode", "rmcup"),
            ("exit_delete_mode", "rmdc"),
            ("exit_doublewide_mode", "rwidm"),
            ("exit_insert_mode", "rmir"),
            ("exit_italics_mode", "ritm"),
            ("exit_leftward_mode", "rlm"),
            ("exit_micro_mode", "rmicm"),
            ("exit_pc_charset_mode", "rmpch"),
            ("exit_scancode_mode", "rmsc"),
            ("exit_shadow_mode", "rshm"),
            ("exit_standout_mode", "rmso"),
            ("exit_subscript_mode", "rsubm"),
            ("exit_superscript_mode", "rsupm"),
            ("exit_underline_mode", "rmul"),
            ("exit_upward_mode", "rum"),
            ("exit_xon_mode", "rmxon"),
            ("fixed_pause", "pause"),
            ("flash_hook", "hook"),
            ("flash_screen", "flash"),
            ("form_feed", "ff"),
            ("from_status_line", "fsl"),
            ("get_mouse", "getm"),
            ("goto_window", "wingo"),
            ("hangup", "hup"),
            ("init_1string", "is1"),
            ("init_2string", "is2"),
            ("init_3string", "is3"),
            ("init_file", "if"),
            ("init_prog", "iprog"),
            ("initialize_color", "initc"),
            ("initialize_pair", "initp"),
            ("insert_character", "ich1"),
            ("insert_line", "il1"),
            ("insert_padding", "ip"),
            ("key_a1", "ka1"),
            ("key_a3", "ka3"),
            ("key_b2", "kb2"),
            ("key_backspace", "kbs"),
            ("key_beg", "kbeg"),
            ("key_btab", "kcbt"),
            ("key_c1", "kc1"),
            ("key_c3", "kc3"),
            ("key_cancel", "kcan"),
            ("key_catab", "ktbc"),
            ("key_clear", "kclr"),
            ("key_close", "kclo"),
            ("key_command", "kcmd"),
            ("key_copy", "kcpy"),
            ("key_create", "kcrt"),
            ("key_ctab", "kctab"),
            ("key_dc", "kdch1"),
            ("key_dl", "kdl1"),
            ("key_down", "kcud1"),
            ("key_eic", "krmir"),
            ("key_end", "kend"),
            ("key_enter", "kent"),
            ("key_eol", "kel"),
            ("key_eos", "ked"),
            ("key_exit", "kext"),
            ("key_f0", "kf0"),
            ("key_f1", "kf1"),
            ("key_f62", "kf62"),
            ("key_f63", "kf63"),
            ("key_find", "kfnd"),
            ("key_help", "khlp"),
            ("key_home", "khome"),
            ("key_ic", "kich1"),
            ("key_il", "kil1"),
            ("key_left", "kcub1"),
            ("key_ll", "kll"),
            ("key_mark", "kmrk"),
            ("key_message", "kmsg"),
            ("key_mouse", "kmous"),
            ("key_move", "kmov"),
            ("key_next", "knxt"),
            ("key_npage", "knp"),
            ("key_open", "kopn"),
            ("key_options", "kopt"),
            ("key_ppage", "kpp"),
            ("key_previous", "kprv"),
            ("key_print", "kprt"),
            ("key_redo", "krdo"),
            ("key_reference", "kref"),
            ("key_refresh", "krfr"),
            ("key_replace", "krpl"),
            ("key_restart", "krst"),
            ("key_resume", "kres"),
            ("key_right", "kcuf1"),
            ("key_save", "ksav"),
            ("key_sbeg", "kBEG"),
            ("key_scancel", "kCAN"),
            ("key_scommand", "kCMD"),
            ("key_scopy", "kCPY"),
            ("key_screate", "kCRT"),
            ("key_sdc", "kDC"),
            ("key_sdl", "kDL"),
            ("key_select", "kslt"),
            ("key_send", "kEND"),
            ("key_seol", "kEOL"),
            ("key_sexit", "kEXT"),
            ("key_sf", "kind"),
            ("key_sfind", "kFND"),
            ("key_shelp", "kHLP"),
            ("key_shome", "kHOM"),
            ("key_sic", "kIC"),
            ("key_sleft", "kLFT"),
            ("key_smessage", "kMSG"),
            ("key_smove", "kMOV"),
            ("key_snext", "kNXT"),
            ("key_soptions", "kOPT"),
            ("key_sprevious", "kPRV"),
            ("key_sprint", "kPRT"),
            ("key_sr", "kri"),
            ("key_sredo", "kRDO"),
            ("key_sreplace", "kRPL"),
            ("key_sright", "kRIT"),
            ("key_srsume", "kRES"),
            ("key_ssave", "kSAV"),
            ("key_ssuspend", "kSPD"),
            ("key_stab", "khts"),
            ("key_sundo", "kUND"),
            ("key_suspend", "kspd"),
            ("key_undo", "kund"),
            ("key_up", "kcuu1"),
            ("keypad_local", "rmkx"),
            ("keypad_xmit", "smkx"),
            ("lab_f0", "lf0"),
            ("lab_f1", "lf1"),
            ("lab_f2", "lf2"),
            ("lab_f3", "lf3"),
            ("lab_f4", "lf4"),
            ("lab_f5", "lf5"),
            ("lab_f6", "lf6"),
            ("lab_f7", "lf7"),
            ("lab_f8", "lf8"),
            ("lab_f9", "lf9"),
            ("lab_f10", "lf10"),
            ("label_format", "fln"),
            ("label_off", "rmln"),
            ("label_on", "smln"),
            ("meta_off", "rmm"),
            ("meta_on", "smm"),
            ("micro_column_address", "mhpa"),
            ("micro_down", "mcud1"),
            ("micro_left", "mcub1"),
            ("micro_right", "mcuf1"),
            ("micro_row_address", "mvpa"),
            ("micro_up", "mcuu1"),
            ("mouse_info", "minfo"),
            ("newline", "nel"),
            ("order_of_pins", "porder"),
            ("orig_colors", "oc"),
            ("orig_pair", "op"),
            ("pad_char", "pad"),
            ("parm_dch", "dch"),
            ("parm_delete_line", "dl"),
            ("parm_down_cursor", "cud"),
            ("parm_down_micro", "mcud"),
            ("parm_ich", "ich"),
            ("parm_index", "indn"),
            ("parm_insert_line", "il"),
            ("parm_left_cursor", "cub"),
            ("parm_left_micro", "mcub"),
            ("parm_right_cursor", "cuf"),
            ("parm_right_micro", "mcuf"),
            ("parm_rindex", "rin"),
            ("parm_up_cursor", "cuu"),
            ("parm_up_micro", "mcuu"),
            ("pc_term_options", "pctrm"),
            ("pkey_key", "pfkey"),
            ("pkey_local", "pfloc"),
            ("pkey_plab", "pfxl"),
            ("pkey_xmit", "pfx"),
            ("plab_norm", "pln"),
            ("print_screen", "mc0"),
            ("prtr_non", "mc5p"),
            ("prtr_off", "mc4"),
            ("prtr_on", "mc5"),
            ("pulse", "pulse"),
            ("quick_dial", "qdial"),
            ("remove_clock", "rmclk"),
            ("repeat_char", "rep"),
            ("req_for_input", "rfi"),
            ("req_mouse_pos", "reqmp"),
            ("reset_1string", "rs1"),
            ("reset_2string", "rs2"),
            ("reset_3string", "rs3"),
            ("reset_file", "rf"),
            ("restore_cursor", "rc"),
            ("row_address", "vpa"),
            ("save_cursor", "sc"),
            ("scancode_escape", "scesc"),
            ("scroll_forward", "ind"),
            ("scroll_reverse", "ri"),
            ("select_char_set", "scs"),
            ("set0_des_seq", "s0ds"),
            ("set1_des_seq", "s1ds"),
            ("set2_des_seq", "s2ds"),
            ("set3_des_seq", "s3ds"),
            ("set_a_attributes", "sgr1"),
            ("set_a_background", "setab"),
            ("set_a_foreground", "setaf"),
            ("set_attributes", "sgr"),
            ("set_background", "setb"),
            ("set_bottom_margin", "smgb"),
            ("set_bottom_margin_parm", "smgbp"),
            ("set_clock", "sclk"),
            ("set_color_band", "setcolor"),
            ("set_color_pair", "scp"),
            ("set_foreground", "setf"),
            ("set_left_margin", "smgl"),
            ("set_left_margin_parm", "smglp"),
            ("set_lr_margin", "smglr"),
            ("set_page_length", "slines"),
            ("set_pglen_inch", "slength"),
            ("set_right_margin", "smgr"),
            ("set_right_margin_parm", "smgrp"),
            ("set_tab", "hts"),
            ("set_tb_margin", "smgtb"),
            ("set_top_margin", "smgt"),
            ("set_top_margin_parm", "smgtp"),
            ("set_window", "wind"),
            ("start_bit_image", "sbim"),
            ("start_char_set_def", "scsd"),
            ("stop_bit_image", "rbim"),
            ("stop_char_set_def", "rcsd"),
            ("subscript_characters", "subcs"),
            ("superscript_characters", "supcs"),
            ("tab", "ht"),
            ("these_cause_cr", "docr"),
            ("to_status_line", "tsl"),
            ("tone", "tone"),
            ("user0", "u0"),
            ("user1", "u1"),
            ("user2", "u2"),
            ("user3", "u3"),
            ("user4", "u4"),
            ("user5", "u5"),
            ("user6", "u6"),
            ("user7", "u7"),
            ("user8", "u8"),
            ("user9", "u9"),
            ("underline_char", "uc"),
            ("up_half_line", "hu"),
            ("wait_tone", "wait"),
            ("xoff_character", "xoffc"),
            ("xon_character", "xonc"),
            ("zero_motion", "zerom"),
        ];

        pub const TERMCAP: &[(&str, &str)] = &
        [
            // Boolean names.
            ("auto_left_margin", "bw"),
            ("auto_right_margin", "am"),
            ("back_color_erase", "ut"),
            ("can_change", "cc"),
            ("ceol_standout_glitch", "xs"),
            ("col_addr_glitch", "YA"),
            ("cpi_changes_res", "YF"),
            ("cr_cancels_micro_mode", "YB"),
            ("dest_tabs_magic_smso", "xt"),
            ("eat_newline_glitch", "xn"),
            ("erase_overstrike", "eo"),
            ("generic_type", "gn"),
            ("hard_copy", "hc"),
            ("hard_cursor", "HC"),
            ("has_meta_key", "km"),
            ("has_print_wheel", "YC"),
            ("has_status_line", "hs"),
            ("hue_lightness_saturation", "hl"),
            ("insert_null_glitch", "in"),
            ("lpi_changes_res", "YG"),
            ("memory_above", "da"),
            ("memory_below", "db"),
            ("move_insert_mode", "mi"),
            ("move_standout_mode", "ms"),
            ("needs_xon_xoff", "nx"),
            ("no_esc_ctlc", "xb"),
            ("no_pad_char", "NP"),
            ("non_dest_scroll_region", "ND"),
            ("non_rev_rmcup", "NR"),
            ("over_strike", "os"),
            ("prtr_silent", "5i"),
            ("row_addr_glitch", "YD"),
            ("semi_auto_right_margin", "YE"),
            ("status_line_esc_ok", "es"),
            ("tilde_glitch", "hz"),
            ("transparent_underline", "ul"),
            ("xon_xoff", "xo"),
            ("bit_image_entwining", "Yo"),
            ("bit_image_type", "Yp"),
            ("buffer_capacity", "Ya"),
            ("buttons", "BT"),
            ("columns", "co"),
            ("dot_horz_spacing", "Yc"),
            ("dot_vert_spacing", "Yb"),
            ("init_tabs", "it"),
            ("label_height", "lh"),
            ("label_width", "lw"),
            ("lines", "li"),
            ("lines_of_memory", "lm"),
            ("max_attributes", "ma"),
            ("magic_cookie_glitch", "sg"),
            ("max_colors", "Co"),
            ("max_micro_address", "Yd"),
            ("max_micro_jump", "Ye"),
            ("max_pairs", "pa"),
            ("maximum_windows", "MW"),
            ("micro_col_size", "Yf"),
            ("micro_line_size", "Yg"),
            ("no_color_video", "NC"),
            ("num_labels", "Nl"),
            ("number_of_pins", "Yh"),
            ("output_res_char", "Yi"),
            ("output_res_line", "Yj"),
            ("output_res_horz_inch", "Yk"),
            ("output_res_vert_inch", "Yl"),
            ("padding_baud_rate", "pb"),
            ("print_rate", "Ym"),
            ("virtual_terminal", "vt"),
            ("wide_char_size", "Yn"),
            ("width_status_line", "ws"),
            ("acs_chars", "ac"),
            ("alt_scancode_esc", "S8"),
            ("back_tab", "bt"),
            ("bell", "bl"),
            ("bit_image_carriage_return", "Yv"),
            ("bit_image_newline", "Zz"),
            ("bit_image_repeat", "Xy"),
            ("carriage_return", "cr"),
            ("change_char_pitch", "ZA"),
            ("change_line_pitch", "ZB"),
            ("change_res_horz", "ZC"),
            ("change_res_vert", "ZD"),
            ("change_scroll_region", "cs"),
            ("char_padding", "rP"),
            ("char_set_names", "Zy"),
            ("clear_all_tabs", "ct"),
            ("clear_margins", "MC"),
            ("clear_screen", "cl"),
            ("clr_bol", "cb"),
            ("clr_eol", "ce"),
            ("clr_eos", "cd"),
            ("code_set_init", "ci"),
            ("color_names", "Yw"),
            ("column_address", "ch"),
            ("command_character", "CC"),
            ("cursor_address", "cm"),
            ("cursor_down", "do"),
            ("cursor_home", "ho"),
            ("cursor_invisible", "vi"),
            ("cursor_left", "le"),
            ("cursor_mem_address", "CM"),
            ("cursor_normal", "ve"),
            ("cursor_right", "nd"),
            ("cursor_to_ll", "ll"),
            ("cursor_up", "up"),
            ("cursor_visible", "vs"),
            ("define_bit_image_region", "Yx"),
            ("define_char", "ZE"),
            ("delete_character", "dc"),
            ("delete_line", "dl"),
            ("device_type", "dv"),
            ("dial_phone", "DI"),
            ("dis_status_line", "ds"),
            ("display_clock", "DK"),
            ("display_pc_char", "S1"),
            ("down_half_line", "hd"),
            ("ena_acs", "eA"),
            ("end_bit_image_region", "Yy"),
            ("enter_alt_charset_mode", "as"),
            ("enter_am_mode", "SA"),
            ("enter_blink_mode", "mb"),
            ("enter_bold_mode", "md"),
            ("enter_ca_mode", "ti"),
            ("enter_delete_mode", "dm"),
            ("enter_dim_mode", "mh"),
            ("enter_doublewide_mode", "ZF"),
            ("enter_draft_quality", "ZG"),
            ("enter_insert_mode", "im"),
            ("enter_italics_mode", "ZH"),
            ("enter_leftward_mode", "ZI"),
            ("enter_micro_mode", "ZJ"),
            ("enter_near_letter_quality", "ZK"),
            ("enter_normal_quality", "ZL"),
            ("enter_pc_charset_mode", "S2"),
            ("enter_protected_mode", "mp"),
            ("enter_reverse_mode", "mr"),
            ("enter_scancode_mode", "S4"),
            ("enter_secure_mode", "mk"),
            ("enter_shadow_mode", "ZM"),
            ("enter_standout_mode", "so"),
            ("enter_subscript_mode", "ZN"),
            ("enter_superscript_mode", "ZO"),
            ("enter_underline_mode", "us"),
            ("enter_upward_mode", "ZP"),
            ("enter_xon_mode", "SX"),
            ("erase_chars", "ec"),
            ("exit_alt_charset_mode", "ae"),
            ("exit_am_mode", "RA"),
            ("exit_attribute_mode", "me"),
            ("exit_ca_mode", "te"),
            ("exit_delete_mode", "ed"),
            ("exit_doublewide_mode", "ZQ"),
            ("exit_insert_mode", "ei"),
            ("exit_italics_mode", "ZR"),
            ("exit_leftward_mode", "ZS"),
            ("exit_micro_mode", "ZT"),
            ("exit_pc_charset_mode", "S3"),
            ("exit_scancode_mode", "S5"),
            ("exit_shadow_mode", "ZU"),
            ("exit_standout_mode", "se"),
            ("exit_subscript_mode", "ZV"),
            ("exit_superscript_mode", "ZW"),
            ("exit_underline_mode", "ue"),
            ("exit_upward_mode", "ZX"),
            ("exit_xon_mode", "RX"),
            ("fixed_pause", "PA"),
            ("flash_hook", "fh"),
            ("flash_screen", "vb"),
            ("form_feed", "ff"),
            ("from_status_line", "fs"),
            ("get_mouse", "Gm"),
            ("goto_window", "WG"),
            ("hangup", "HU"),
            ("init_1string", "i1"),
            ("init_2string", "is"),
            ("init_3string", "i3"),
            ("init_file", "if"),
            ("init_prog", "iP"),
            ("initialize_color", "Ic"),
            ("initialize_pair", "Ip"),
            ("insert_character", "ic"),
            ("insert_line", "al"),
            ("insert_padding", "ip"),
            ("key_a1", "K1"),
            ("key_a3", "K3"),
            ("key_b2", "K2"),
            ("key_backspace", "kb"),
            ("key_btab", "kB"),
            ("key_c1", "K4"),
            ("key_c3", "K5"),
            ("key_catab", "ka"),
            ("key_clear", "kC"),
            ("key_ctab", "kt"),
            ("key_dc", "kD"),
            ("key_dl", "kL"),
            ("key_down", "kd"),
            ("key_eic", "kM"),
            ("key_eol", "kE"),
            ("key_eos", "kS"),
            ("key_f0", "k0"),
            ("key_f1", "k1"),
            ("key_f62", "Fq"),
            ("key_f63", "Fr"),
            ("key_help", "%1"),
            ("key_home", "kh"),
            ("key_ic", "kI"),
            ("key_il", "kA"),
            ("key_left", "kl"),
            ("key_ll", "kH"),
            ("key_mark", "%2"),
            ("key_message", "%3"),
            ("key_mouse", "Km"),
            ("key_move", "%4"),
            ("key_next", "%5"),
            ("key_npage", "kN"),
            ("key_open", "%6"),
            ("key_options", "%7"),
            ("key_ppage", "kP"),
            ("key_previous", "%8"),
            ("key_print", "%9"),
            ("key_redo", "%0"),
            ("key_reference", "&1"),
            ("key_refresh", "&2"),
            ("key_replace", "&3"),
            ("key_restart", "&4"),
            ("key_resume", "&5"),
            ("key_right", "kr"),
            ("key_save", "&6"),
            ("key_sbeg", "&9"),
            ("key_scancel", "&0"),
            ("key_scommand", "*1"),
            ("key_scopy", "*2"),
            ("key_screate", "*3"),
            ("key_sdc", "*4"),
            ("key_sdl", "*5"),
            ("key_select", "*6"),
            ("key_send", "*7"),
            ("key_seol", "*8"),
            ("key_sexit", "*9"),
            ("key_sf", "kF"),
            ("key_sfind", "*0"),
            ("key_shelp", "#1"),
            ("key_shome", "#2"),
            ("key_sic", "#3"),
            ("key_sleft", "#4"),
            ("key_smessage", "%a"),
            ("key_smove", "%b"),
            ("key_snext", "%c"),
            ("key_soptions", "%d"),
            ("key_sprevious", "%e"),
            ("key_sprint", "%f"),
            ("key_sr", "kR"),
            ("key_sredo", "%g"),
            ("key_sreplace", "%h"),
            ("key_sright", "%i"),
            ("key_srsume", "%j"),
            ("key_ssave", "!1"),
            ("key_ssuspend", "!2"),
            ("key_stab", "kT"),
            ("key_sundo", "!3"),
            ("key_suspend", "&7"),
            ("key_undo", "&8"),
            ("key_up", "ku"),
            ("keypad_local", "ke"),
            ("keypad_xmit", "ks"),
            ("lab_f0", "l0"),
            ("lab_f1", "l1"),
            ("lab_f2", "l2"),
            ("lab_f3", "l3"),
            ("lab_f4", "l4"),
            ("lab_f5", "l5"),
            ("lab_f6", "l6"),
            ("lab_f7", "l7"),
            ("lab_f8", "l8"),
            ("lab_f9", "l9"),
            ("lab_f10", "la"),
            ("label_format", "Lf"),
            ("label_off", "LF"),
            ("label_on", "LO"),
            ("meta_off", "mo"),
            ("meta_on", "mm"),
            ("micro_column_address", "ZY"),
            ("micro_down", "ZZ"),
            ("micro_left", "Za"),
            ("micro_right", "Zb"),
            ("micro_row_address", "Zc"),
            ("micro_up", "Zd"),
            ("mouse_info", "Mi"),
            ("newline", "nw"),
            ("order_of_pins", "Ze"),
            ("orig_colors", "oc"),
            ("orig_pair", "op"),
            ("pad_char", "pc"),
            ("parm_dch", "DC"),
            ("parm_delete_line", "DL"),
            ("parm_down_cursor", "DO"),
            ("parm_down_micro", "Zf"),
            ("parm_ich", "IC"),
            ("parm_index", "SF"),
            ("parm_insert_line", "AL"),
            ("parm_left_cursor", "LE"),
            ("parm_left_micro", "Zg"),
            ("parm_right_cursor", "RI"),
            ("parm_right_micro", "Zh"),
            ("parm_rindex", "SR"),
            ("parm_up_cursor", "UP"),
            ("parm_up_micro", "Zi"),
            ("pc_term_options", "S6"),
            ("pkey_key", "pk"),
            ("pkey_local", "pl"),
            ("pkey_plab", "xl"),
            ("pkey_xmit", "px"),
            ("plab_norm", "pn"),
            ("print_screen", "ps"),
            ("prtr_non", "pO"),
            ("prtr_off", "pf"),
            ("prtr_on", "po"),
            ("pulse", "PU"),
            ("quick_dial", "QD"),
            ("remove_clock", "RC"),
            ("repeat_char", "rp"),
            ("req_for_input", "RF"),
            ("req_mouse_pos", "RQ"),
            ("reset_1string", "r1"),
            ("reset_2string", "r2"),
            ("reset_3string", "r3"),
            ("reset_file", "rf"),
            ("restore_cursor", "rc"),
            ("row_address", "cv"),
            ("save_cursor", "sc"),
            ("scancode_escape", "S7"),
            ("scroll_forward", "sf"),
            ("scroll_reverse", "sr"),
            ("select_char_set", "Zj"),
            ("set0_des_seq", "s0"),
            ("set1_des_seq", "s1"),
            ("set2_des_seq", "s2"),
            ("set3_des_seq", "s3"),
            ("set_a_background", "AB"),
            ("set_a_foreground", "AF"),
            ("set_attributes", "sa"),
            ("set_background", "Sb"),
            ("set_bottom_margin", "Zk"),
            ("set_bottom_margin_parm", "Zl"),
            ("set_clock", "SC"),
            ("set_color_band", "Yz"),
            ("set_color_pair", "sp"),
            ("set_foreground", "Sf"),
            ("set_left_margin", "ML"),
            ("set_left_margin_parm", "Zm"),
            ("set_page_length", "YZ"),
            ("set_pglen_inch", "YI"),
            ("set_right_margin", "MR"),
            ("set_right_margin_parm", "Zn"),
            ("set_tab", "st"),
            ("set_tb_margin", "MT"),
            ("set_top_margin", "Zo"),
            ("set_top_margin_parm", "Zp"),
            ("set_window", "wi"),
            ("start_bit_image", "Zq"),
            ("start_char_set_def", "Zr"),
            ("stop_bit_image", "Zs"),
            ("stop_char_set_def", "Zt"),
            ("subscript_characters", "Zu"),
            ("superscript_characters", "Zv"),
            ("tab", "ta"),
            ("these_cause_cr", "Zw"),
            ("to_status_line", "ts"),
            ("tone", "TO"),
            ("user0", "u0"),
            ("user1", "u1"),
            ("user2", "u2"),
            ("user3", "u3"),
            ("user4", "u4"),
            ("user5", "u5"),
            ("user6", "u6"),
            ("user7", "u7"),
            ("user8", "u8"),
            ("user9", "u9"),
            ("underline_char", "uc"),
            ("up_half_line", "hu"),
            ("wait_tone", "WA"),
            ("xoff_character", "XF"),
            ("xon_character", "XN"),
            ("zero_motion", "Zx"),
        ];
        /*
        fn main() 
        {
            let path = Path::new(&env::var("OUT_DIR").unwrap()).join("names.rs");
            let mut file = BufWriter::new(File::create(&path).unwrap());

            write!(&mut file, "pub static BOOLEAN: ::phf::Map<u16, &'static str> = ").unwrap();
            let mut builder = phf_codegen::Map::new();
            for (index, name) in BOOLEAN.iter().enumerate() {
                builder.entry(index as u16, &format!("\"{}\"", name));
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            let keys = BOOLEAN.iter().map(|n| format!("\"{}\"", n)).collect::<Vec<_>>();
            write!(&mut file, "pub static BOOLEAN_INDEX: ::phf::Map<&'static str, u16> = ").unwrap();
            let mut builder = phf_codegen::Map::<&str>::new();
            for (index, name) in keys.iter().enumerate() {
                builder.entry(name, &index.to_string());
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            write!(&mut file, "pub static NUMBER: ::phf::Map<u16, &'static str> = ").unwrap();
            let mut builder = phf_codegen::Map::new();
            for (index, name) in NUMBER.iter().enumerate() {
                builder.entry(index as u16, &format!("\"{}\"", name));
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            let keys = NUMBER.iter().map(|n| format!("\"{}\"", n)).collect::<Vec<_>>();
            write!(&mut file, "pub static NUMBER_INDEX: ::phf::Map<&'static str, u16> = ").unwrap();
            let mut builder = phf_codegen::Map::<&str>::new();
            for (index, name) in keys.iter().enumerate() {
                builder.entry(name, &index.to_string());
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            write!(&mut file, "pub static STRING: ::phf::Map<u16, &'static str> = ").unwrap();
            let mut builder = phf_codegen::Map::new();
            for (index, name) in STRING.iter().enumerate() {
                builder.entry(index as u16, &format!("\"{}\"", name));
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            let keys = STRING.iter().map(|n| format!("\"{}\"", n)).collect::<Vec<_>>();
            write!(&mut file, "pub static STRING_INDEX: ::phf::Map<&'static str, u16> = ").unwrap();
            let mut builder = phf_codegen::Map::<&str>::new();
            for (index, name) in keys.iter().enumerate() {
                builder.entry(name, &index.to_string());
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            write!(&mut file, "pub static TERMINFO: ::phf::Map<&'static str, &'static str> = ").unwrap();
            let mut builder = phf_codegen::Map::new();
            for &(name, value) in TERMINFO {
                builder.entry(name, &format!("\"{}\"", value));
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            write!(&mut file, "pub static TERMCAP: ::phf::Map<&'static str, &'static str> = ").unwrap();
            let mut builder = phf_codegen::Map::new();
            for &(name, value) in TERMCAP {
                builder.entry(name, &format!("\"{}\"", value));
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();

            write!(&mut file, "pub static ALIASES: ::phf::Map<&'static str, &'static str> = ").unwrap();
            let mut builder = phf_codegen::Map::new();
            for &(value, name) in TERMINFO {
                builder.entry(name, &format!("\"{}\"", value));
            }
            for &(value, name) in TERMCAP {
                if !TERMINFO.iter().any(|entry| name == entry.1) {
                    builder.entry(name, &format!("\"{}\"", value));
                }
            }
            write!(&mut file, "{}", builder.build()).unwrap();
            writeln!(&mut file, ";").unwrap();
        }
        */
    }
    /// Metadata Capabilities
    pub mod capabilities
    {
        /// Metadata Capabilities
        use ::
        {
            borrow::{ Cow },
            error::metadata::{ self as error },
            expand::{ Context, Expand, Parameter },
            io::{ Write },
            *,
        };

        macro_rules! from 
        {
            (number $ty:ty) => {
                impl From<$ty> for Value {
                    fn from(value: $ty) -> Self {
                        Value::Number(value as i32)
                    }
                }
            };

            (string ref $ty:ty) => {
                impl<'a> From<&'a $ty> for Value {
                    fn from(value: &'a $ty) -> Self {
                        Value::String(value.into())
                    }
                }
            };

            (string $ty:ty) => {
                impl From<$ty> for Value {
                    fn from(value: $ty) -> Self {
                        Value::String(value.into())
                    }
                }
            };
        }

        macro_rules! define 
        {
            (boolean $ident:ident => $capability:expr) => (
                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub struct $ident(pub bool);

                impl<'a> Capability<'a> for $ident {
                    #[inline] fn name() -> &'static str {
                        $capability
                    }

                    #[inline] fn from(value: Option<&Value>) -> Option<Self> {
                        if let Some(&Value::True) = value {
                            Some($ident(true))
                        }
                        else {
                            Some($ident(false))
                        }
                    }

                    #[inline] fn into(self) -> Option<Value> {
                        if self.0 {
                            Some(Value::True)
                        }
                        else {
                            None
                        }
                    }
                }

                impl From<$ident> for bool {
                    fn from(cap: $ident) -> Self {
                        cap.0
                    }
                }
            );

            (number $ident:ident => $capability:expr) => (
                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub struct $ident(pub i32);

                impl<'a> Capability<'a> for $ident {
                    #[inline] fn name() -> &'static str {
                        $capability
                    }

                    #[inline] fn from(value: Option<&Value>) -> Option<Self> {
                        if let Some(&Value::Number(value)) = value {
                            Some($ident(value))
                        }
                        else {
                            None
                        }
                    }

                    #[inline] fn into(self) -> Option<Value> {
                        Some(Value::Number(self.0))
                    }
                }

                impl From<$ident> for i32 {
                    fn from(cap: $ident) -> Self {
                        cap.0
                    }
                }
            );

            (string define $ident:ident => $capability:expr) => (
                #[derive(Eq, PartialEq, Clone, Debug)]
                pub struct $ident<'a>(Cow<'a, [u8]>);

                impl<'a> Capability<'a> for $ident<'a> {
                    #[inline] fn name() -> &'static str {
                        $capability
                    }

                    #[inline] fn from(value: Option<&'a Value>) -> Option<$ident<'a>> {
                        if let Some(&Value::String(ref value)) = value {
                            Some($ident(Cow::Borrowed(value)))
                        }
                        else {
                            None
                        }
                    }

                    #[inline] fn into(self) -> Option<Value> {
                        Some(Value::String(match self.0 {
                            Cow::Borrowed(value) =>
                                value.into(),

                            Cow::Owned(value) =>
                                value
                        }))
                    }
                }

                impl<'a, T: AsRef<&'a [u8]>> From<T> for $ident<'a> {
                    #[inline] fn from(value: T) -> Self {
                        $ident(Cow::Borrowed(value.as_ref()))
                    }
                }

                impl<'a> AsRef<[u8]> for $ident<'a> {
                    #[inline] fn as_ref(&self) -> &[u8] {
                        &self.0
                    }
                }

                impl<'a> $ident<'a> {
                    /// Begin expanding the capability.
                    #[inline]
                    pub fn expand(&self) -> Expansion<$ident> {
                        Expansion {
                            string:  self,
                            params:  Default::default(),
                            context: None,
                        }
                    }
                }
            );

            (string $ident:ident => $capability:expr) => (
                define!(string define $ident => $capability);
            );

            (string $ident:ident => $capability:expr; $($rest:tt)+) => (
                define!(string define $ident => $capability);
                define!(string parameters $ident; $($rest)+);
                define!(string builder $ident; 0, $($rest)+, );
            );

            (string parameters $ident:ident; $($name:ident : $ty:ty),+) => (
                impl<'a> Expansion<'a, $ident<'a>> {
                    /// Pass all expansion parameters at once.
                    #[allow(unused_assignments)]
                    #[inline]
                    // https://github.com/meh/rust-terminfo/issues/28
                    #[allow(clippy::too_many_arguments)]
                    pub fn parameters(mut self, $($name: $ty),*) -> Self {
                        let mut index = 0;

                        $({
                            self.params[index]  = $name.into();
                            index              += 1;
                        })*;

                        self
                    }
                }
            );

            (string builder $ident:ident; $index:expr, ) => ();

            (string builder $ident:ident; $index:expr, $name:ident : u8, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : u8);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : i8, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : i8);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : u16, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : u16);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : i16 $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : i16);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : u32, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : u32);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : i32, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : i32);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : $ty:ty, $($rest:tt)*) => (
                define!(string builder into $ident; $index, $name : $ty);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder direct $ident:ident; $index:expr, $name:ident : $ty:ty) => (
                impl<'a> Expansion<'a, $ident<'a>> {
                    /// Set the given parameter.
                    #[inline]
                    pub fn $name(mut self, value: $ty) -> Self {
                        self.params[$index] = value.into();
                        self
                    }
                }
            );

            (string builder into $ident:ident; $index:expr, $name:ident : $ty:ty) => (
                impl<'a> Expansion<'a, $ident<'a>> {
                    /// Set the given parameter.
                    #[inline]
                    pub fn $name<T: Into<$ty>>(mut self, value: T) -> Self {
                        self.params[$index] = value.into().into();
                        self
                    }
                }
            );
        }
        /// A trait for any object that will represent a terminal capability.
        pub trait Capability<'a>: Sized
        {
            /// Returns the name of the capability in its long form.
            fn name() -> &'static str;
            /// Parse the capability from its raw value.
            fn from(value: Option<&'a Value>) -> Option<Self>;
            /// Convert the capability into its raw value.
            fn into(self) -> Option<Value>;
        }
        /// Possible value types for capabilities.
        #[derive(Eq, PartialEq, Clone, Debug)]
        pub enum Value 
        {
            /// A boolean.
            True,
            /// A number.
            Number(i32),
            /// An ASCII string requiring expansion.
            String(Vec<u8>),
        }
        /// Expansion helper struct.
        #[derive( Debug )]
        pub struct Expansion<'a, T: 'a + AsRef<[u8]>> 
        {
            string: &'a T,
            params: [Parameter; 9],
            context: Option<&'a mut Context>,
        }

        impl<'a, T: AsRef<[u8]>> Expansion<'a, T> 
        {
            /// Expand using the given context.
            pub fn with<'c: 'a>(mut self, context: &'c mut Context) -> Self {
                self.context = Some(context);
                self
            }

            /// Expand to the given output.
            pub fn to<W: Write>(self, output: W) -> error::Result<()> {
                self.string.as_ref().expand(
                    output,
                    &self.params,
                    self.context.unwrap_or(&mut Default::default()),
                )
            }

            /// Expand into a vector.
            pub fn to_vec(self) -> error::Result<Vec<u8>> {
                let mut result = Vec::with_capacity(self.string.as_ref().len());
                self.to(&mut result)?;
                Ok(result)
            }
        }

        impl From<()> for Value 
        {
            fn from(_: ()) -> Self {
                Value::True
            }
        }

        from!(number u8);
        from!(number i8);
        from!(number u16);
        from!(number i16);
        from!(number u32);
        from!(number i32);

        from!(string String);
        from!(string ref str);
        from!(string Vec<u8>);
        from!(string ref [u8]);

        define!(boolean AutoLeftMargin => "auto_left_margin");
        define!(boolean AutoRightMargin => "auto_right_margin");
        define!(boolean NoEscCtlc => "no_esc_ctlc");
        define!(boolean CeolStandoutGlitch => "ceol_standout_glitch");
        define!(boolean EatNewlineGlitch => "eat_newline_glitch");
        define!(boolean EraseOverstrike => "erase_overstrike");
        define!(boolean GenericType => "generic_type");
        define!(boolean HardCopy => "hard_copy");
        define!(boolean HasMetaKey => "has_meta_key");
        define!(boolean HasStatusLine => "has_status_line");
        define!(boolean InsertNullGlitch => "insert_null_glitch");
        define!(boolean MemoryAbove => "memory_above");
        define!(boolean MemoryBelow => "memory_below");
        define!(boolean MoveInsertMode => "move_insert_mode");
        define!(boolean MoveStandoutMode => "move_standout_mode");
        define!(boolean OverStrike => "over_strike");
        define!(boolean StatusLineEscOk => "status_line_esc_ok");
        define!(boolean DestTabsMagicSmso => "dest_tabs_magic_smso");
        define!(boolean TildeGlitch => "tilde_glitch");
        define!(boolean TransparentUnderline => "transparent_underline");
        define!(boolean XonXoff => "xon_xoff");
        define!(boolean NeedsXonXoff => "needs_xon_xoff");
        define!(boolean PrtrSilent => "prtr_silent");
        define!(boolean HardCursor => "hard_cursor");
        define!(boolean NonRevRmcup => "non_rev_rmcup");
        define!(boolean NoPadChar => "no_pad_char");
        define!(boolean NonDestScrollRegion => "non_dest_scroll_region");
        define!(boolean CanChange => "can_change");
        define!(boolean BackColorErase => "back_color_erase");
        define!(boolean HueLightnessSaturation => "hue_lightness_saturation");
        define!(boolean ColAddrGlitch => "col_addr_glitch");
        define!(boolean CrCancelsMicroMode => "cr_cancels_micro_mode");
        define!(boolean HasPrintWheel => "has_print_wheel");
        define!(boolean RowAddrGlitch => "row_addr_glitch");
        define!(boolean SemiAutoRightMargin => "semi_auto_right_margin");
        define!(boolean CpiChangesRes => "cpi_changes_res");
        define!(boolean LpiChangesRes => "lpi_changes_res");
        define!(boolean BackspacesWithBs => "backspaces_with_bs");
        define!(boolean CrtNoScrolling => "crt_no_scrolling");
        define!(boolean NoCorrectlyWorkingCr => "no_correctly_working_cr");
        define!(boolean GnuHasMetaKey => "gnu_has_meta_key");
        define!(boolean LinefeedIsNewline => "linefeed_is_newline");
        define!(boolean HasHardwareTabs => "has_hardware_tabs");
        define!(boolean ReturnDoesClrEol => "return_does_clr_eol");

        define!(number Columns => "columns");
        define!(number InitTabs => "init_tabs");
        define!(number Lines => "lines");
        define!(number LinesOfMemory => "lines_of_memory");
        define!(number MagicCookieGlitch => "magic_cookie_glitch");
        define!(number PaddingBaudRate => "padding_baud_rate");
        define!(number VirtualTerminal => "virtual_terminal");
        define!(number WidthStatusLine => "width_status_line");
        define!(number NumLabels => "num_labels");
        define!(number LabelHeight => "label_height");
        define!(number LabelWidth => "label_width");
        define!(number MaxAttributes => "max_attributes");
        define!(number MaximumWindows => "maximum_windows");
        define!(number MaxColors => "max_colors");
        define!(number MaxPairs => "max_pairs");
        define!(number NoColorVideo => "no_color_video");
        define!(number BufferCapacity => "buffer_capacity");
        define!(number DotVertSpacing => "dot_vert_spacing");
        define!(number DotHorzSpacing => "dot_horz_spacing");
        define!(number MaxMicroAddress => "max_micro_address");
        define!(number MaxMicroJump => "max_micro_jump");
        define!(number MicroColSize => "micro_col_size");
        define!(number MicroLineSize => "micro_line_size");
        define!(number NumberOfPins => "number_of_pins");
        define!(number OutputResChar => "output_res_char");
        define!(number OutputResLine => "output_res_line");
        define!(number OutputResHorzInch => "output_res_horz_inch");
        define!(number OutputResVertInch => "output_res_vert_inch");
        define!(number PrintRate => "print_rate");
        define!(number WideCharSize => "wide_char_size");
        define!(number Buttons => "buttons");
        define!(number BitImageEntwining => "bit_image_entwining");
        define!(number BitImageType => "bit_image_type");
        define!(number MagicCookieGlitchUl => "magic_cookie_glitch_ul");
        define!(number CarriageReturnDelay => "carriage_return_delay");
        define!(number NewLineDelay => "new_line_delay");
        define!(number BackspaceDelay => "backspace_delay");
        define!(number HorizontalTabDelay => "horizontal_tab_delay");
        define!(number NumberOfFunctionKeys => "number_of_function_keys");

        define!(string BackTab => "back_tab");
        define!(string Bell => "bell");
        define!(string CarriageReturn => "carriage_return");
        define!(string ClearAllTabs => "clear_all_tabs");
        define!(string ClearScreen => "clear_screen");
        define!(string ClrEol => "clr_eol");
        define!(string ClrEos => "clr_eos");
        define!(string CommandCharacter => "command_character");
        define!(string CursorDown => "cursor_down");
        define!(string CursorHome => "cursor_home");
        define!(string CursorInvisible => "cursor_invisible");
        define!(string CursorLeft => "cursor_left");
        define!(string CursorMemAddress => "cursor_mem_address");
        define!(string CursorNormal => "cursor_normal");
        define!(string CursorRight => "cursor_right");
        define!(string CursorToLl => "cursor_to_ll");
        define!(string CursorUp => "cursor_up");
        define!(string CursorVisible => "cursor_visible");
        define!(string DeleteCharacter => "delete_character");
        define!(string DeleteLine => "delete_line");
        define!(string DisStatusLine => "dis_status_line");
        define!(string DownHalfLine => "down_half_line");
        define!(string EnterAltCharsetMode => "enter_alt_charset_mode");
        define!(string EnterBlinkMode => "enter_blink_mode");
        define!(string EnterBoldMode => "enter_bold_mode");
        define!(string EnterCaMode => "enter_ca_mode");
        define!(string EnterDeleteMode => "enter_delete_mode");
        define!(string EnterDimMode => "enter_dim_mode");
        define!(string EnterInsertMode => "enter_insert_mode");
        define!(string EnterSecureMode => "enter_secure_mode");
        define!(string EnterProtectedMode => "enter_protected_mode");
        define!(string EnterReverseMode => "enter_reverse_mode");
        define!(string EnterStandoutMode => "enter_standout_mode");
        define!(string EnterUnderlineMode => "enter_underline_mode");
        define!(string ExitAltCharsetMode => "exit_alt_charset_mode");
        define!(string ExitAttributeMode => "exit_attribute_mode");
        define!(string ExitCaMode => "exit_ca_mode");
        define!(string ExitDeleteMode => "exit_delete_mode");
        define!(string ExitInsertMode => "exit_insert_mode");
        define!(string ExitStandoutMode => "exit_standout_mode");
        define!(string ExitUnderlineMode => "exit_underline_mode");
        define!(string FlashScreen => "flash_screen");
        define!(string FormFeed => "form_feed");
        define!(string FromStatusLine => "from_status_line");
        define!(string Init1String => "init_1string");
        define!(string Init2String => "init_2string");
        define!(string Init3String => "init_3string");
        define!(string InitFile => "init_file");
        define!(string InsertCharacter => "insert_character");
        define!(string InsertLine => "insert_line");
        define!(string InsertPadding => "insert_padding");
        define!(string KeyBackspace => "key_backspace");
        define!(string KeyCATab => "key_catab");
        define!(string KeyClear => "key_clear");
        define!(string KeyCTab => "key_ctab");
        define!(string KeyDc => "key_dc");
        define!(string KeyDl => "key_dl");
        define!(string KeyDown => "key_down");
        define!(string KeyEic => "key_eic");
        define!(string KeyEol => "key_eol");
        define!(string KeyEos => "key_eos");
        define!(string KeyF0 => "key_f0");
        define!(string KeyF1 => "key_f1");
        define!(string KeyF10 => "key_f10");
        define!(string KeyF2 => "key_f2");
        define!(string KeyF3 => "key_f3");
        define!(string KeyF4 => "key_f4");
        define!(string KeyF5 => "key_f5");
        define!(string KeyF6 => "key_f6");
        define!(string KeyF7 => "key_f7");
        define!(string KeyF8 => "key_f8");
        define!(string KeyF9 => "key_f9");
        define!(string KeyHome => "key_home");
        define!(string KeyIc => "key_ic");
        define!(string KeyIl => "key_il");
        define!(string KeyLeft => "key_left");
        define!(string KeyLl => "key_ll");
        define!(string KeyNPage => "key_npage");
        define!(string KeyPPage => "key_ppage");
        define!(string KeyRight => "key_right");
        define!(string KeySf => "key_sf");
        define!(string KeySr => "key_sr");
        define!(string KeySTab => "key_stab");
        define!(string KeyUp => "key_up");
        define!(string KeypadLocal => "keypad_local");
        define!(string KeypadXmit => "keypad_xmit");
        define!(string LabF0 => "lab_f0");
        define!(string LabF1 => "lab_f1");
        define!(string LabF10 => "lab_f10");
        define!(string LabF2 => "lab_f2");
        define!(string LabF3 => "lab_f3");
        define!(string LabF4 => "lab_f4");
        define!(string LabF5 => "lab_f5");
        define!(string LabF6 => "lab_f6");
        define!(string LabF7 => "lab_f7");
        define!(string LabF8 => "lab_f8");
        define!(string LabF9 => "lab_f9");
        define!(string MetaOff => "meta_off");
        define!(string MetaOn => "meta_on");
        define!(string Newline => "newline");
        define!(string PadChar => "pad_char");
        define!(string PKeyKey => "pkey_key");
        define!(string PKeyLocal => "pkey_local");
        define!(string PKeyXmit => "pkey_xmit");
        define!(string PrintScreen => "print_screen");
        define!(string PrtrOff => "prtr_off");
        define!(string PrtrOn => "prtr_on");
        define!(string RepeatChar => "repeat_char");
        define!(string Reset1String => "reset_1string");
        define!(string Reset2String => "reset_2string");
        define!(string Reset3String => "reset_3string");
        define!(string ResetFile => "reset_file");
        define!(string RestoreCursor => "restore_cursor");
        define!(string SaveCursor => "save_cursor");
        define!(string ScrollForward => "scroll_forward");
        define!(string ScrollReverse => "scroll_reverse");
        define!(string SetTab => "set_tab");
        define!(string SetWindow => "set_window");
        define!(string Tab => "tab");
        define!(string ToStatusLine => "to_status_line");
        define!(string UnderlineChar => "underline_char");
        define!(string UpHalfLine => "up_half_line");
        define!(string InitProg => "init_prog");
        define!(string KeyA1 => "key_a1");
        define!(string KeyA3 => "key_a3");
        define!(string KeyB2 => "key_b2");
        define!(string KeyC1 => "key_c1");
        define!(string KeyC3 => "key_c3");
        define!(string PrtrNon => "prtr_non");
        define!(string CharPadding => "char_padding");
        define!(string AcsChars => "acs_chars");
        define!(string PlabNorm => "plab_norm");
        define!(string KeyBTab => "key_btab");
        define!(string EnterXonMode => "enter_xon_mode");
        define!(string ExitXonMode => "exit_xon_mode");
        define!(string EnterAmMode => "enter_am_mode");
        define!(string ExitAmMode => "exit_am_mode");
        define!(string XonCharacter => "xon_character");
        define!(string XoffCharacter => "xoff_character");
        define!(string EnaAcs => "ena_acs");
        define!(string LabelOn => "label_on");
        define!(string LabelOff => "label_off");
        define!(string KeyBeg => "key_beg");
        define!(string KeyCancel => "key_cancel");
        define!(string KeyClose => "key_close");
        define!(string KeyCommand => "key_command");
        define!(string KeyCopy => "key_copy");
        define!(string KeyCreate => "key_create");
        define!(string KeyEnd => "key_end");
        define!(string KeyEnter => "key_enter");
        define!(string KeyExit => "key_exit");
        define!(string KeyFind => "key_find");
        define!(string KeyHelp => "key_help");
        define!(string KeyMark => "key_mark");
        define!(string KeyMessage => "key_message");
        define!(string KeyMove => "key_move");
        define!(string KeyNext => "key_next");
        define!(string KeyOpen => "key_open");
        define!(string KeyOptions => "key_options");
        define!(string KeyPrevious => "key_previous");
        define!(string KeyPrint => "key_print");
        define!(string KeyRedo => "key_redo");
        define!(string KeyReference => "key_reference");
        define!(string KeyRefresh => "key_refresh");
        define!(string KeyReplace => "key_replace");
        define!(string KeyRestart => "key_restart");
        define!(string KeyResume => "key_resume");
        define!(string KeySave => "key_save");
        define!(string KeySuspend => "key_suspend");
        define!(string KeyUndo => "key_undo");
        define!(string KeySBeg => "key_sbeg");
        define!(string KeySCancel => "key_scancel");
        define!(string KeySCommand => "key_scommand");
        define!(string KeySCopy => "key_scopy");
        define!(string KeySCreate => "key_screate");
        define!(string KeySDc => "key_sdc");
        define!(string KeySDl => "key_sdl");
        define!(string KeySelect => "key_select");
        define!(string KeySEnd => "key_send");
        define!(string KeySEol => "key_seol");
        define!(string KeySExit => "key_sexit");
        define!(string KeySFind => "key_sfind");
        define!(string KeySHelp => "key_shelp");
        define!(string KeySHome => "key_shome");
        define!(string KeySIc => "key_sic");
        define!(string KeySLeft => "key_sleft");
        define!(string KeySMessage => "key_smessage");
        define!(string KeySMove => "key_smove");
        define!(string KeySNext => "key_snext");
        define!(string KeySOptions => "key_soptions");
        define!(string KeySPrevious => "key_sprevious");
        define!(string KeySPrint => "key_sprint");
        define!(string KeySRedo => "key_sredo");
        define!(string KeySReplace => "key_sreplace");
        define!(string KeySRight => "key_sright");
        define!(string KeySRsume => "key_srsume");
        define!(string KeySSave => "key_ssave");
        define!(string KeySSuspend => "key_ssuspend");
        define!(string KeySUndo => "key_sundo");
        define!(string ReqForInput => "req_for_input");
        define!(string KeyF11 => "key_f11");
        define!(string KeyF12 => "key_f12");
        define!(string KeyF13 => "key_f13");
        define!(string KeyF14 => "key_f14");
        define!(string KeyF15 => "key_f15");
        define!(string KeyF16 => "key_f16");
        define!(string KeyF17 => "key_f17");
        define!(string KeyF18 => "key_f18");
        define!(string KeyF19 => "key_f19");
        define!(string KeyF20 => "key_f20");
        define!(string KeyF21 => "key_f21");
        define!(string KeyF22 => "key_f22");
        define!(string KeyF23 => "key_f23");
        define!(string KeyF24 => "key_f24");
        define!(string KeyF25 => "key_f25");
        define!(string KeyF26 => "key_f26");
        define!(string KeyF27 => "key_f27");
        define!(string KeyF28 => "key_f28");
        define!(string KeyF29 => "key_f29");
        define!(string KeyF30 => "key_f30");
        define!(string KeyF31 => "key_f31");
        define!(string KeyF32 => "key_f32");
        define!(string KeyF33 => "key_f33");
        define!(string KeyF34 => "key_f34");
        define!(string KeyF35 => "key_f35");
        define!(string KeyF36 => "key_f36");
        define!(string KeyF37 => "key_f37");
        define!(string KeyF38 => "key_f38");
        define!(string KeyF39 => "key_f39");
        define!(string KeyF40 => "key_f40");
        define!(string KeyF41 => "key_f41");
        define!(string KeyF42 => "key_f42");
        define!(string KeyF43 => "key_f43");
        define!(string KeyF44 => "key_f44");
        define!(string KeyF45 => "key_f45");
        define!(string KeyF46 => "key_f46");
        define!(string KeyF47 => "key_f47");
        define!(string KeyF48 => "key_f48");
        define!(string KeyF49 => "key_f49");
        define!(string KeyF50 => "key_f50");
        define!(string KeyF51 => "key_f51");
        define!(string KeyF52 => "key_f52");
        define!(string KeyF53 => "key_f53");
        define!(string KeyF54 => "key_f54");
        define!(string KeyF55 => "key_f55");
        define!(string KeyF56 => "key_f56");
        define!(string KeyF57 => "key_f57");
        define!(string KeyF58 => "key_f58");
        define!(string KeyF59 => "key_f59");
        define!(string KeyF60 => "key_f60");
        define!(string KeyF61 => "key_f61");
        define!(string KeyF62 => "key_f62");
        define!(string KeyF63 => "key_f63");
        define!(string ClrBol => "clr_bol");
        define!(string ClearMargins => "clear_margins");
        define!(string SetLeftMargin => "set_left_margin");
        define!(string SetRightMargin => "set_right_margin");
        define!(string LabelFormat => "label_format");
        define!(string SetClock => "set_clock");
        define!(string DisplayClock => "display_clock");
        define!(string RemoveClock => "remove_clock");
        define!(string CreateWindow => "create_window");
        define!(string GotoWindow => "goto_window");
        define!(string Hangup => "hangup");
        define!(string DialPhone => "dial_phone");
        define!(string QuickDial => "quick_dial");
        define!(string Tone => "tone");
        define!(string Pulse => "pulse");
        define!(string FlashHook => "flash_hook");
        define!(string FixedPause => "fixed_pause");
        define!(string WaitTone => "wait_tone");
        define!(string User0 => "user0");
        define!(string User1 => "user1");
        define!(string User2 => "user2");
        define!(string User3 => "user3");
        define!(string User4 => "user4");
        define!(string User5 => "user5");
        define!(string User6 => "user6");
        define!(string User7 => "user7");
        define!(string User8 => "user8");
        define!(string User9 => "user9");
        define!(string OrigPair => "orig_pair");
        define!(string OrigColors => "orig_colors");
        define!(string InitializeColor => "initialize_color");
        define!(string InitializePair => "initialize_pair");
        define!(string SetColorPair => "set_color_pair");
        define!(string ChangeCharPitch => "change_char_pitch");
        define!(string ChangeLinePitch => "change_line_pitch");
        define!(string ChangeResHorz => "change_res_horz");
        define!(string ChangeResVert => "change_res_vert");
        define!(string DefineChar => "define_char");
        define!(string EnterDoublewideMode => "enter_doublewide_mode");
        define!(string EnterDraftQuality => "enter_draft_quality");
        define!(string EnterItalicsMode => "enter_italics_mode");
        define!(string EnterLeftwardMode => "enter_leftward_mode");
        define!(string EnterMicroMode => "enter_micro_mode");
        define!(string EnterNearLetterQuality => "enter_near_letter_quality");
        define!(string EnterNormalQuality => "enter_normal_quality");
        define!(string EnterShadowMode => "enter_shadow_mode");
        define!(string EnterSubscriptMode => "enter_subscript_mode");
        define!(string EnterSuperscriptMode => "enter_superscript_mode");
        define!(string EnterUpwardMode => "enter_upward_mode");
        define!(string ExitDoublewideMode => "exit_doublewide_mode");
        define!(string ExitItalicsMode => "exit_italics_mode");
        define!(string ExitLeftwardMode => "exit_leftward_mode");
        define!(string ExitMicroMode => "exit_micro_mode");
        define!(string ExitShadowMode => "exit_shadow_mode");
        define!(string ExitSubscriptMode => "exit_subscript_mode");
        define!(string ExitSuperscriptMode => "exit_superscript_mode");
        define!(string ExitUpwardMode => "exit_upward_mode");
        define!(string MicroColumnAddress => "micro_column_address");
        define!(string MicroDown => "micro_down");
        define!(string MicroLeft => "micro_left");
        define!(string MicroRight => "micro_right");
        define!(string MicroRowAddress => "micro_row_address");
        define!(string MicroUp => "micro_up");
        define!(string OrderOfPins => "order_of_pins");
        define!(string SelectCharSet => "select_char_set");
        define!(string SetBottomMargin => "set_bottom_margin");
        define!(string SetBottomMarginParm => "set_bottom_margin_parm");
        define!(string SetLeftMarginParm => "set_left_margin_parm");
        define!(string SetRightMarginParm => "set_right_margin_parm");
        define!(string SetTopMargin => "set_top_margin");
        define!(string SetTopMarginParm => "set_top_margin_parm");
        define!(string StartBitImage => "start_bit_image");
        define!(string StartCharSetDef => "start_char_set_def");
        define!(string StopBitImage => "stop_bit_image");
        define!(string StopCharSetDef => "stop_char_set_def");
        define!(string SubscriptCharacters => "subscript_characters");
        define!(string SuperscriptCharacters => "superscript_characters");
        define!(string TheseCauseCr => "these_cause_cr");
        define!(string ZeroMotion => "zero_motion");
        define!(string CharSetNames => "char_set_names");
        define!(string KeyMouse => "key_mouse");
        define!(string MouseInfo => "mouse_info");
        define!(string ReqMousePos => "req_mouse_pos");
        define!(string GetMouse => "get_mouse");
        define!(string PkeyPlab => "pkey_plab");
        define!(string DeviceType => "device_type");
        define!(string CodeSetInit => "code_set_init");
        define!(string Set0DesSeq => "set0_des_seq");
        define!(string Set1DesSeq => "set1_des_seq");
        define!(string Set2DesSeq => "set2_des_seq");
        define!(string Set3DesSeq => "set3_des_seq");
        define!(string SetLrMargin => "set_lr_margin");
        define!(string SetTbMargin => "set_tb_margin");
        define!(string BitImageRepeat => "bit_image_repeat");
        define!(string BitImageNewline => "bit_image_newline");
        define!(string BitImageCarriageReturn => "bit_image_carriage_return");
        define!(string ColorNames => "color_names");
        define!(string DefineBitImageRegion => "define_bit_image_region");
        define!(string EndBitImageRegion => "end_bit_image_region");
        define!(string SetColorBand => "set_color_band");
        define!(string SetPageLength => "set_page_length");
        define!(string DisplayPcChar => "display_pc_char");
        define!(string EnterPcCharsetMode => "enter_pc_charset_mode");
        define!(string ExitPcCharsetMode => "exit_pc_charset_mode");
        define!(string EnterScancodeMode => "enter_scancode_mode");
        define!(string ExitScancodeMode => "exit_scancode_mode");
        define!(string PcTermOptions => "pc_term_options");
        define!(string ScancodeEscape => "scancode_escape");
        define!(string AltScancodeEsc => "alt_scancode_esc");
        define!(string EnterHorizontalHlMode => "enter_horizontal_hl_mode");
        define!(string EnterLeftHlMode => "enter_left_hl_mode");
        define!(string EnterLowHlMode => "enter_low_hl_mode");
        define!(string EnterRightHlMode => "enter_right_hl_mode");
        define!(string EnterTopHlMode => "enter_top_hl_mode");
        define!(string EnterVerticalHlMode => "enter_vertical_hl_mode");
        define!(string SetAAttributes => "set_a_attributes");
        define!(string SetPglenInch => "set_pglen_inch");
        define!(string TermcapInit2 => "termcap_init2");
        define!(string TermcapReset => "termcap_reset");
        define!(string LinefeedIfNotLf => "linefeed_if_not_lf");
        define!(string BackspaceIfNotBs => "backspace_if_not_bs");
        define!(string OtherNonFunctionKeys => "other_non_function_keys");
        define!(string ArrowKeyMap => "arrow_key_map");
        define!(string AcsULcorner => "acs_ulcorner");
        define!(string AcsLLcorner => "acs_llcorner");
        define!(string AcsURcorner => "acs_urcorner");
        define!(string AcsLRcorner => "acs_lrcorner");
        define!(string AcsLTee => "acs_ltee");
        define!(string AcsRTee => "acs_rtee");
        define!(string AcsBTee => "acs_btee");
        define!(string AcsTTee => "acs_ttee");
        define!(string AcsHLine => "acs_hline");
        define!(string AcsVLine => "acs_vline");
        define!(string AcsPlus => "acs_plus");
        define!(string MemoryLock => "memory_lock");
        define!(string MemoryUnlock => "memory_unlock");
        define!(string BoxChars1 => "box_chars_1");

        define!(string ChangeScrollRegion => "change_scroll_region";
            top:    u32,
            bottom: u32);

        define!(string ColumnAddress => "column_address";
            x: u32);

        define!(string CursorAddress => "cursor_address";
            y: u32,
            x: u32);

        define!(string EraseChars => "erase_chars";
            count: u32);

        define!(string ParmDch => "parm_dch";
            count: u32);

        define!(string ParmDeleteLine => "parm_delete_line";
            count: u32);

        define!(string ParmDownCursor => "parm_down_cursor";
            count: u32);

        define!(string ParmIch => "parm_ich";
            count: u32);

        define!(string ParmIndex => "parm_index";
            count: u32);

        define!(string ParmInsertLine => "parm_insert_line";
            count: u32);

        define!(string ParmLeftCursor => "parm_left_cursor";
            count: u32);

        define!(string ParmRightCursor => "parm_right_cursor";
            count: u32);

        define!(string ParmRindex => "parm_rindex";
            count: u32);

        define!(string ParmUpCursor => "parm_up_cursor";
            count: u32);

        define!(string ParmDownMicro => "parm_down_micro";
            count: u32);

        define!(string ParmLeftMicro => "parm_left_micro";
            count: u32);

        define!(string ParmRightMicro => "parm_right_micro";
            count: u32);

        define!(string ParmUpMicro => "parm_up_micro";
            count: u32);

        define!(string RowAddress => "row_address";
            y: u32);

        define!(string SetAttributes => "set_attributes";
            standout:    bool,
            underline:   bool,
            reverse:     bool,
            blink:       bool,
            dim:         bool,
            bold:        bool,
            invisible:   bool,
            protected:   bool,
            alt_charset: bool);

        define!(string SetAForeground => "set_a_foreground";
            color: u8);

        define!(string SetABackground => "set_a_background";
            color: u8);

        define!(string SetForeground => "set_foreground";
            color: u8);

        define!(string SetBackground => "set_background";
            color: u8);
            
        define!(boolean XTermTitle => "XT");
        define!(boolean BrightAttribute => "AX");
        define!(boolean XTermMouse => "XM");
        
        define!(boolean TrueColor => "Tc");

        define!(string SetClipboard => "Ms";
            selection: String,
            content:   Vec<u8>);

        define!(string SetCursorStyle => "Ss";
            kind: u8);

        define!(string ResetCursorStyle => "Se");
        
        define!(string SetTrueColorForeground => "8f";
            r: u8,
            g: u8,
            b: u8);

        define!(string SetTrueColorBackground => "8b";
            r: u8,
            g: u8,
            b: u8);

        define!(string ResetCursorColor => "Cr");

        define!(string SetCursorColor => "Cs";
            color: String);
    }
    /// CLI completions
    pub mod completers
    {
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            fs::{ read_dir },
            path::{ is_separator, MAIN_SEPARATOR, Path },
            regex::{ contains },
            sync::{ Arc },
            terminal::{ Terminals, Prompter },
            *,
        };
        /**/
        pub mod dots
        {

        }
        /**/
        pub mod env
        {

        }
        /**/
        pub mod make
        {

        }
        /**/
        pub mod path
        {

        }
        /**/
        pub mod ssh
        {

        }
        /**/
        pub mod utils
        {

        }
        /// Represents a single possible completion
        #[derive( Clone, Debug )]
        pub struct Completion
        {
            /// Whole completion text
            pub completion: String,
            /// Listing display string; `None` if matches completion
            pub display:Option<String>,
            /// Completion suffix; replaces append character
            pub suffix: Suffix,
        }

        impl Completion
        {
            /// Returns a simple `Completion` value, with display string matching
            /// completion and using the default completion suffix.
            pub fn simple( s: String ) -> Completion
            {
                Completion
                {
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }
            /// Returns the full completion string, including suffix, 
            /// using the given default suffix if one is not assigned to this completion.
            pub fn completion( &self, def_suffix:Option<char> ) -> Cow<str>
            {
                let mut s = Borrowed( &self.completion[..] );

                if let Some( suffix ) = self.suffix.with_default( def_suffix ) { s.to_mut().push( suffix ); }

                s
            }
            /// Returns the display string, including suffix
            pub fn display( &self ) -> Cow<str>
            {
                let mut s = Borrowed( self.display_str() );

                if let Suffix::Some( suffix ) = self.suffix { s.to_mut().push( suffix ); }

                s
            }
            /// Returns the number of characters displayed
            pub fn display_chars( &self ) -> usize
            {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str( &self ) -> &str
            {
                match self.display
                {
                    Some( ref dis ) => dis,
                    None => &self.completion
                }
            }
        }
        /// Specifies an optional suffix to override the default value
        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum Suffix
        {
            /// Use the default suffix
            Default,
            /// Use no suffix
            None,
            /// Use the given suffix
            Some( char ),
        }

        impl Suffix
        {
            /// Returns whether the `Suffix` value is the `Default` variant.
            pub fn is_default( &self ) -> bool
            {
                match *self
                {
                    Suffix::Default => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `Some( _ )` variant.
            pub fn is_some( &self ) -> bool
            {
                match *self
                {
                    Suffix::Some( _ ) => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `None` variant.
            pub fn is_none( &self ) -> bool
            {
                match *self
                {
                    Suffix::None => true,
                    _ => false
                }
            }
            /// Returns an `Option<char>`, using the given value in place of `Default`.
            pub fn with_default( self, default:Option<char> ) -> Option<char>
            {
                match self
                {
                    Suffix::None => None,
                    Suffix::Some( ch ) => Some( ch ),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix
        {
            fn default() -> Suffix { Suffix::Default }
        }
        /// Performs completion for `Prompter` when triggered by a user input sequence
        pub trait Completer<Term: Terminals>: Send + Sync
        {
            /// Returns the set of possible completions for the prefix `word`.
            fn complete( &self, word:&str, prompter:&Prompter<Term>, start:usize, end: usize ) ->
            Option<Vec<Completion>>;
            /// Returns the starting position of the word under the cursor.
            fn word_start( &self, line:&str, end:usize, prompter:&Prompter<Term> ) -> usize
            { word_break_start( &line[..end], prompter.word_break_chars() ) }
            /// Quotes a possible completion for insertion into input.
            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str> { Borrowed( word ) }
            /// Unquotes a piece of user input before searching for completions.
            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str> { Borrowed( word ) }
        }
        /// `Completer` type that performs no completion.
        pub struct DummyCompleter;

        impl<Term: Terminals> Completer<Term> for DummyCompleter
        {
            fn complete( &self, _word:&str, _reader:&Prompter<Term>, _start:usize, _end:usize ) ->
            Option<Vec<Completion>> { None }
        }
        /// Performs completion by searching for filenames matching the word prefix.
        pub struct PathCompleter;

        impl<Term: Terminals> Completer<Term> for PathCompleter
        {
            fn complete( &self, word:&str, _reader:&Prompter<Term>, _start:usize, _end: usize )
            -> Option<Vec<Completion>>
            { Some( complete_path( word ) ) }

            fn word_start( &self, line:&str, end:usize, _reader:&Prompter<Term> ) -> usize
            { escaped_word_start( &line[..end] ) }

            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str> { escape( word ) }

            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str> { unescape( word ) }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path( path:&str ) -> Vec<Completion>
        {
            let ( base_dir, fname ) = split_path( path );
            let mut res = Vec::new();
            let lookup_dir = base_dir.unwrap_or( "." );

            if let Ok( list ) = read_dir( lookup_dir )
            {
                for ent in list
                {
                    if let Ok( ent ) = ent
                    {
                        let ent_name = ent.file_name();
                        
                        if let Ok( path ) = ent_name.into_string()
                        {
                            if path.starts_with( fname )
                            {
                                let ( name, display ) = if let Some( dir ) = base_dir
                                {
                                    ( format!( "{}{}{}", dir, MAIN_SEPARATOR, path ),
                                        Some( path ) )
                                }
                                else { ( path, None ) };

                                let is_dir = ent.metadata().ok().map_or( false, |m| m.is_dir() );

                                let suffix = if is_dir { Suffix::Some( MAIN_SEPARATOR ) }                                
                                else { Suffix::Default };

                                res.push( Completion
                                {
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                });
                            }
                        }
                    }
                }
            }

            res.sort_by( |a, b| a.display_str().cmp( b.display_str() ) );
            res
        }
        /// Returns the start position of the word that ends at the end of the string.
        pub fn word_break_start( s:&str, word_break:&str ) -> usize
        {
            let mut start = s.len();

            for ( idx, ch ) in s.char_indices().rev()
            {
                if word_break.contains( ch )
            { break; }
                start = idx;
            }

            start
        }
        /// Returns the start position of a word with non-word characters escaped by backslash ( `\\` ).
        pub fn escaped_word_start( s:&str ) -> usize
        {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some(( idx, ch ) ) = chars.next()
            {
                if needs_escape( ch )
                {
                    let n = 
                    {
                        let mut n = 0;

                        loop
                        {
                            let mut clone = chars.clone();
                            let ch = match clone.next()
                            {
                                Some(( _, ch )) => ch,
                                None => break
                            };

                            if ch == '\\'
                            {
                                chars = clone;
                                n += 1;
                            }
                            
                            else { break; }
                        }

                        n
                    };

                    if n % 2 == 0 { break; }
                }

                start = idx;
            }

            start
        }
        /// Escapes a word by prefixing a backslash ( `\\` ) to non-word characters.
        pub fn escape( s:&str ) -> Cow<str>
        {
            let n = s.chars().filter( |&ch| needs_escape( ch ) ).count();

            if n == 0 { Borrowed( s ) }
            else
            {
                let mut res = String::with_capacity( s.len() + n );

                for ch in s.chars()
                {
                    if needs_escape( ch ) { res.push( '\\' ); }

                    res.push( ch );
                }

                Owned( res )
            }
        }
        /// Unescapes a word by removing the backslash ( `\\` ) from escaped characters.
        pub fn unescape( s:&str ) -> Cow<str>
        {
            if s.contains( '\\' )
            {
                let mut res = String::with_capacity( s.len() );
                let mut chars = s.chars();

                while let Some( ch ) = chars.next()
                {
                    if ch == '\\'
                    {
                        if let Some( ch ) = chars.next() { res.push( ch ); }
                    }

                    else { res.push( ch ); }
                }

                Owned( res )
            }

            else { Borrowed( s ) }
        }

        fn needs_escape( ch: char ) -> bool
        {
            match ch
            {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path( path:&str ) -> ( Option<&str>, &str )
        {
            match path.rfind( is_separator )
            {
                Some( pos ) => ( Some( &path[..pos] ), &path[pos + 1..] ),
                None => ( None, path )
            }
        }
        /**/
        pub struct CicadaCompleter
        {
            pub sh: Arc<shell::Shell>,
        }

        fn for_make( line:&str ) -> bool { contains( line, r"^ *make " ) }

        fn for_env( line:&str ) -> bool { contains( line, r" *\$[_a-zA-Z0-9]*$" ) }

        fn for_ssh( line:&str ) -> bool { contains( line, r"^ *( ssh|scp ).* +[^ \./]+ *$" ) }

        fn for_cd( line:&str ) -> bool { contains( line, r"^ *cd +" ) }

        fn for_bin( line:&str ) -> bool
        {
            let ptn = r"( ^ *( sudo|which|nohup )? *[a-zA-Z0-9_\.-]+$ )|( ^.+\| *( sudo|which|nohup )? *[a-zA-Z0-9_\.-]+$ )";
            contains( line, ptn )
        }

        fn for_dots( line:&str ) -> bool
        {
            let args = parsers::line::line_to_plain_tokens( line );
            let len = args.len();

            if len == 0 { return false; }
            
            let dir = tools::get_user_completer_dir();
            let dot_file = format!( "{}/{}.yaml", dir, args[0] );
            Path::new( dot_file.as_str() ).exists()
        }

        impl<Term: Terminals> Completer<Term> for CicadaCompleter 
        {
            fn complete( &self, word:&str, reader:&Prompter<Term>, start:usize, end: usize ) -> 
            Option<Vec<Completion>>
            {
                let line = reader.buffer();
                let completions:Option<Vec<Completion>>;

                if for_dots( line )
                {
                    let cpl = Arc::new( dots::DotsCompleter );
                    completions = cpl.complete( word, reader, start, _end );
                }
                
                else if for_ssh( line )
                {
                    let cpl = Arc::new( ssh::SshCompleter );
                    completions = cpl.complete( word, reader, start, _end );
                }
                
                else if for_make( line )
                {
                    let cpl = Arc::new( make::MakeCompleter );
                    completions = cpl.complete( word, reader, start, _end );
                }
                
                else if for_bin( line )
                {
                    let cpl = Arc::new( path::BinCompleter
                    {
                        sh: self.sh.clone(),
                    });
                    completions = cpl.complete( word, reader, start, _end );
                }
                
                else if for_env( line )
                {
                    let cpl = Arc::new( env::EnvCompleter
                    {
                        sh: self.sh.clone(),
                    });
                    
                    completions = cpl.complete( word, reader, start, _end );
                }
                
                else if for_cd( line )
                {
                    let cpl = Arc::new( path::CdCompleter );
                    return cpl.complete( word, reader, start, _end );
                }

                else { completions = None; }

                if let Some( x ) = completions
                {
                    if !x.is_empty() { return Some( x ); }
                }
                
                let cpl = Arc::new( path::PathCompleter );
                cpl.complete( word, reader, start, _end )
            }

            fn word_start( &self, line:&str, end:usize, _reader:&Prompter<Term> ) -> usize
            { escaped_word_start( &line[..end] ) }
        }
    }
    
    pub mod highlighter
    {
        //! Syntax highlighting functionality for the terminal interface.
        use ::
        {
            collections::{ HashSet },
            parsers::{ line },
            path::{ Path },
            os::unix::fs::{ PermissionsExt },
            ops::{ Range },
            sync::{ Arc, Mutex },
            *,
        };
        
        lazy_static!
        {
            static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new( HashSet::new() );
            static ref ALIASES: Mutex<HashSet<String>> = Mutex::new( HashSet::new() );
        }
        /// Represents a style to be applied to a text range.
        #[derive( Debug, Clone, PartialEq, Eq )]
        pub enum Style
        {
            /// A style using raw ANSI color codes
            AnsiColor( String ),
            /// The default terminal style
            Default,
        }
        /// A trait for providing style information for a line of text.
        pub trait Highlighter
        {
            /// Takes the current line buffer and returns a list of styled ranges.
            fn highlight( &self, line:&str ) -> Vec<( Range<usize>, Style )>;
        }
        /// Initialize the available commands cache by scanning PATH directories
        pub fn init_command_cache()
        {
            let commands = scan_available_commands();
            if let Ok( mut cache ) = AVAILABLE_COMMANDS.lock()
            {
                *cache = commands;
            }
        }
        /// Update aliases in the highlighter's cache
        pub fn update_aliases( sh:&shell::Shell )
        {
            if let Ok( mut aliases ) = ALIASES.lock()
            {
                aliases.clear();

                for alias_name in sh.aliases.keys()
                {
                    aliases.insert( alias_name.clone() );
                }
            }
        }

        fn scan_available_commands() -> HashSet<String>
        {
            let mut commands = HashSet::new();

            if let Ok( path_var ) = env::var( "PATH" )
            {
                for path in path_var.split( ':' )
                {
                    if path.is_empty() { continue; }

                    let dir_path = Path::new( path );

                    if !dir_path.is_dir() { continue; }

                    if let Ok( entries ) = fs::read_dir( dir_path )
                    {
                        for entry in entries.filter_map( Result::ok )
                        {
                            if let Ok( file_type ) = entry.file_type()
                            {
                                if file_type.is_file() || file_type.is_symlink()
                                {
                                    if let Ok( metadata ) = entry.metadata()
                                    {
                                        if metadata.permissions().mode() & 0o111 != 0
                                        {
                                            if let Some( name ) = entry.file_name().to_str()
                                            { commands.insert( name.to_string() ); }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            commands
        }
        
        #[derive( Clone )]
        pub struct CicadaHighlighter;
        
        impl Highlighter for CicadaHighlighter
        {
            fn highlight( &self, line:&str ) -> Vec<( Range<usize>, Style )>
            {
                let mut styles = Vec::new();

                if line.is_empty() { return styles; }

                let line_info = parsers::line::parse( line );
                
                if line_info.tokens.is_empty()
                {
                    styles.push( ( 0..line.len(), Style::Default ) );
                    return styles;
                }

                let mut current_byte_idx = 0;
                let mut is_start_of_segment = true;

                for token in &line_info.tokens
                {
                    match find_token_range_heuristic( line, current_byte_idx, token )
                    {
                        Some( token_range ) =>
                        {
                            if token_range.start > current_byte_idx
                            { styles.push( ( current_byte_idx..token_range.start, Style::Default ) ); }

                            let ( _sep, word ) = token;
                            let mut current_token_style = Style::Default;

                            if is_start_of_segment && !word.is_empty()
                            {
                                if is_command( word )
                                { current_token_style = Style::AnsiColor( GREEN.to_string() ); }

                                is_start_of_segment = false;
                            }

                            styles.push( ( token_range.clone(), current_token_style ) );
                            
                            if ["|", "&&", "||", ";"].contains( &word.as_str() ) { is_start_of_segment = true; }

                            current_byte_idx = token_range.end;
                        }
                        
                        None =>
                        {
                            if current_byte_idx < line.len() 
                            { styles.push( ( current_byte_idx..line.len(), Style::Default ) ); }

                            current_byte_idx = line.len();
                            break;
                        }
                    }
                }
                
                if current_byte_idx < line.len() { styles.push( ( current_byte_idx..line.len(), Style::Default ) ); }

                styles
            }
        }

        pub fn create_highlighter() -> Arc<CicadaHighlighter> { Arc::new( CicadaHighlighter ) }
    }
    pub use self::highlighter::{ Highlighter };
    
    pub mod main
    {
        use ::
        {
            env::{ var },
            terminal::
            {
                preset::{ apply_preset_item, apply_pyenv },
            },
            *,
        };
        
        pub const DEFAULT_PROMPT:&str = "${COLOR_STATUS}$USER${RESET}@${COLOR_STATUS}$HOSTNAME${RESET}: ${COLOR_STATUS}$CWD${RESET}$ ";
        
        pub fn get_prompt_string() -> String
        {
            if let Ok( x ) = var( "PROMPT" )
            { return x; }
            DEFAULT_PROMPT.to_string()
        }

        fn apply_prompt_item( sh:&shell::Shell, result:&mut String, token:&str )
        {
            if let Some( x ) = sh.get_env( token )
            {
                result.push_str( &x );
                return;
            }

            apply_preset_item( sh, result, token );
        }

        fn apply_command( result:&mut String, token:&str, prefix:&str, suffix:&str )
        {
            let cr = now::run( token );
            let output = cr.stdout.trim();
            
            if !output.is_empty()
            {
                result.push_str( prefix );
                result.push_str( output );
                result.push_str( suffix );
            }
        }

        pub fn render_prompt( sh:&shell::Shell, ps:&str ) -> String
        {
            let mut prompt = String::new();
            apply_pyenv( &mut prompt );
            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();

            for c in ps.chars()
            {
                if met_dollar
                {    
                    if c == '(' && !met_brace && !met_paren
                    {
                        met_paren = true;
                        continue;
                    }
                    
                    if c == ')' && met_paren
                    {
                        apply_command( &mut prompt, &token, &prefix, &suffix );
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }
                    
                    if c == '{' && !met_brace && !met_paren
                    {
                        met_brace = true;
                        continue;
                    }

                    else if c == '}' && met_brace
                    {
                        apply_prompt_item( sh, &mut prompt, &token );
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    }

                    else if c == '$'
                    {
                        if token.is_empty()
                        {
                            prompt.push( '$' );
                            met_dollar = true;
                            continue;
                        }
                        else
                        {
                            apply_prompt_item( sh, &mut prompt, &token );
                            token.clear();
                            continue;
                        }
                    }
                    
                    else if met_paren
                    {
                        if is::prefix_char( c ) { prefix.push( c ); }
                        else if is::suffix_char( c ) { suffix.push( c ); }
                        else { token.push( c ); }
                        continue;
                    }

                    else if is::prompt_item_char( c, &token )
                    {
                        token.push( c );
                        continue;
                    }

                    else if token.is_empty()
                    {
                        prompt.push( '$' );
                        prompt.push( c );
                        met_dollar = false;
                        continue;
                    }
                }

                if c == '$'
                {
                    met_dollar = true;
                    continue;
                }

                if !token.is_empty()
                {
                    apply_prompt_item( sh, &mut prompt, &token );
                    token.clear();
                }

                prompt.push( c );
                met_dollar = false;
            }

            if !token.is_empty()
            {
                apply_prompt_item( sh, &mut prompt, &token );
                met_dollar = false;
            }

            if met_dollar { prompt.push( '$' ); }

            if prompt.trim().is_empty() { return format!( "cicada-{} >> ", "25.4.15" ); }

            prompt
        }
    }
    
    pub mod preset
    {
        use ::
        {
            fs::{ File },
            io::{Read, Write},
            path::{ self, Path },
            terminal::{ color },
            *,
        };
        
        pub fn apply_pyenv( prompt:&mut String )
        {
            if let Ok( x ) = env::var( "VIRTUAL_ENV" )
            {
                if !x.is_empty()
                {
                    let _tokens: Vec<&str> = x.split( '/' ).collect();
                    let env_name = match _tokens.last()
                    {
                        Some( x ) => x,
                        None => {
                            log!( "prompt token last error" );
                            return;
                        }
                    };

                    apply_blue_b( prompt );
                    prompt.push( '(' );
                    prompt.push_str( env_name );
                    prompt.push( ')' );
                    apply_reset( prompt );
                }
            }
        }

        pub fn apply_preset_item( sh:&shell::Shell, prompt:&mut String, token:&str )
        {
            match token.to_ascii_lowercase().as_ref()
            {
                "black" => apply_black( prompt ),
                "black_b" => apply_black_b( prompt ),
                "black_bg" => apply_black_bg( prompt ),
                "blink" => apply_blink( prompt ),
                "blue" => apply_blue( prompt ),
                "blue_b" => apply_blue_b( prompt ),
                "blue_bg" => apply_blue_bg( prompt ),
                "blue_l" => apply_blue_l( prompt ),
                "blue_l_bg" => apply_blue_l_bg( prompt ),
                "bold" => apply_bold( prompt ),
                "color_status" => apply_color_status( sh, prompt ),
                "cwd" => apply_cwd( prompt ),
                "cyan" => apply_cyan( prompt ),
                "cyan_bg" => apply_cyan_bg( prompt ),
                "cyan_l" => apply_cyan_l( prompt ),
                "cyan_l_bg" => apply_cyan_l_bg( prompt ),
                "default" => apply_default( prompt ),
                "default_bg" => apply_default_bg( prompt ),
                "dim" => apply_dim( prompt ),
                "end_seq" => apply_end_seq( prompt ),
                "esc" => apply_esc( prompt ),
                "gitbr" => apply_gitbr( prompt ),
                "gray_d" => apply_gray_d( prompt ),
                "gray_d_bg" => apply_gray_d_bg( prompt ),
                "gray_l" => apply_gray_l( prompt ),
                "gray_l_bg" => apply_gray_l_bg( prompt ),
                "green" => apply_green( prompt ),
                "green_b" => apply_green_b( prompt ),
                "green_bg" => apply_green_bg( prompt ),
                "green_l" => apply_green_l( prompt ),
                "green_l_bg" => apply_green_l_bg( prompt ),
                "hidden" => apply_hidden( prompt ),
                "hostname" => apply_hostname( prompt ),
                "magenta" => apply_magenta( prompt ),
                "magenta_bg" => apply_magenta_bg( prompt ),
                "magenta_l" => apply_magenta_l( prompt ),
                "magenta_l_bg" => apply_magenta_l_bg( prompt ),
                "newline" => apply_newline( prompt ),
                "red" => apply_red( prompt ),
                "red_b" => apply_red_b( prompt ),
                "red_bg" => apply_red_bg( prompt ),
                "red_l" => apply_red_l( prompt ),
                "red_l_bg" => apply_red_l_bg( prompt ),
                "reset" => apply_reset( prompt ),
                "reset_blink" => apply_reset_blink( prompt ),
                "reset_bold" => apply_reset_bold( prompt ),
                "reset_dim" => apply_reset_dim( prompt ),
                "reset_hidden" => apply_reset_hidden( prompt ),
                "reset_reverse" => apply_reset_reverse( prompt ),
                "reset_underlined" => apply_reset_underlined( prompt ),
                "reverse" => apply_reverse( prompt ),
                "seq" => apply_seq( prompt ),
                "underlined" => apply_underlined( prompt ),
                "user" => apply_user( prompt ),
                "white" => apply_white( prompt ),
                "white_b" => apply_white_b( prompt ),
                "white_bg" => apply_white_bg( prompt ),
                "yellow" => apply_yellow( prompt ),
                "yellow_bg" => apply_yellow_bg( prompt ),
                "yellow_l" => apply_yellow_l( prompt ),
                "yellow_l_bg" => apply_yellow_l_bg( prompt ),
                _ => (),
            }
        }
        fn apply_seq( prompt:&mut String ) { prompt.push_str( color::SEQ ); }
        fn apply_end_seq( prompt:&mut String ) { prompt.push_str( color::END_SEQ ); }
        fn apply_esc( prompt:&mut String ) { prompt.push_str( color::ESC ); }
        fn apply_underlined( prompt:&mut String ) { prompt.push_str( color::UNDERLINED ); }
        fn apply_user( prompt:&mut String )
        {
            let username = get::username();
            prompt.push_str( &username );
        }
        fn apply_black( prompt:&mut String ) { prompt.push_str( color::BLACK ); }
        fn apply_black_b( prompt:&mut String ) { prompt.push_str( color::BLACK_B ); }
        fn apply_black_bg( prompt:&mut String ) { prompt.push_str( color::BLACK_BG ); }
        fn apply_blue( prompt:&mut String ) { prompt.push_str( color::BLUE ); }
        fn apply_blue_b( prompt:&mut String ) { prompt.push_str( color::BLUE_B ); }
        fn apply_blue_bg( prompt:&mut String ) { prompt.push_str( color::BLUE_BG ); }
        fn apply_bold( prompt:&mut String ) { prompt.push_str( color::BOLD ); }
        fn apply_green( prompt:&mut String ) { prompt.push_str( color::GREEN ); }
        fn apply_green_b( prompt:&mut String ) { prompt.push_str( color::GREEN_B ); }
        fn apply_green_bg( prompt:&mut String ) { prompt.push_str( color::GREEN_BG ); }
        fn apply_red( prompt:&mut String ) { prompt.push_str( color::RED ); }
        fn apply_red_b( prompt:&mut String ) { prompt.push_str( color::RED_B ); }
        fn apply_red_bg( prompt:&mut String ) { prompt.push_str( color::RED_BG ); }
        fn apply_white( prompt:&mut String ) { prompt.push_str( color::WHITE ); }
        fn apply_white_b( prompt:&mut String ) { prompt.push_str( color::WHITE_B ); }
        fn apply_white_bg( prompt:&mut String ) { prompt.push_str( color::WHITE_BG ); }
        fn apply_hidden( prompt:&mut String ) { prompt.push_str( color::HIDDEN ); }
        fn apply_reset( prompt:&mut String ) { prompt.push_str( color::RESET ); }
        fn apply_reverse( prompt:&mut String ) { prompt.push_str( color::REVERSE ); }
        fn apply_dim( prompt:&mut String ) { prompt.push_str( color::DIM ); }
        fn apply_blink( prompt:&mut String ) { prompt.push_str( color::BLINK ); }
        fn apply_reset_underlined( prompt:&mut String ) { prompt.push_str( color::RESET_UNDERLINED ); }
        fn apply_reset_dim( prompt:&mut String ) { prompt.push_str( color::RESET_DIM ); }
        fn apply_reset_reverse( prompt:&mut String ) { prompt.push_str( color::RESET_REVERSE ); }
        fn apply_reset_hidden( prompt:&mut String ) { prompt.push_str( color::RESET_HIDDEN ); }
        fn apply_reset_blink( prompt:&mut String ) { prompt.push_str( color::RESET_BLINK ); }
        fn apply_reset_bold( prompt:&mut String ) { prompt.push_str( color::RESET_BOLD ); }
        fn apply_default( prompt:&mut String ) { prompt.push_str( color::DEFAULT ); }
        fn apply_default_bg( prompt:&mut String ) { prompt.push_str( color::DEFAULT_BG ); }
        fn apply_cyan( prompt:&mut String ) { prompt.push_str( color::CYAN ); }
        fn apply_cyan_l( prompt:&mut String ) { prompt.push_str( color::CYAN_L ); }
        fn apply_cyan_bg( prompt:&mut String ) { prompt.push_str( color::CYAN_BG ); }
        fn apply_cyan_l_bg( prompt:&mut String ) { prompt.push_str( color::CYAN_L_BG ); }
        fn apply_red_l( prompt:&mut String ) { prompt.push_str( color::RED_L ); }
        fn apply_red_l_bg( prompt:&mut String ) { prompt.push_str( color::RED_L_BG ); }
        fn apply_green_l( prompt:&mut String ) { prompt.push_str( color::GREEN_L ); }
        fn apply_green_l_bg( prompt:&mut String ) { prompt.push_str( color::GREEN_L_BG ); }
        fn apply_gray_l( prompt:&mut String ) { prompt.push_str( color::GRAY_L ); }
        fn apply_gray_l_bg( prompt:&mut String ) { prompt.push_str( color::GRAY_L_BG ); }
        fn apply_gray_d( prompt:&mut String ) { prompt.push_str( color::GRAY_D ); }
        fn apply_gray_d_bg( prompt:&mut String ) { prompt.push_str( color::GRAY_D_BG ); }
        fn apply_magenta( prompt:&mut String ) { prompt.push_str( color::MAGENTA ); }
        fn apply_magenta_bg( prompt:&mut String ) { prompt.push_str( color::MAGENTA_BG ); }
        fn apply_magenta_l( prompt:&mut String ) { prompt.push_str( color::MAGENTA_L ); }
        fn apply_magenta_l_bg( prompt:&mut String ) { prompt.push_str( color::MAGENTA_L_BG ); }
        fn apply_yellow( prompt:&mut String ) { prompt.push_str( color::YELLOW ); }
        fn apply_yellow_bg( prompt:&mut String ) { prompt.push_str( color::YELLOW_BG ); }
        fn apply_yellow_l( prompt:&mut String ) { prompt.push_str( color::YELLOW_L ); }
        fn apply_yellow_l_bg( prompt:&mut String ) { prompt.push_str( color::YELLOW_L_BG ); }
        fn apply_blue_l( prompt:&mut String ) { prompt.push_str( color::BLUE_L ); }
        fn apply_blue_l_bg( prompt:&mut String ) { prompt.push_str( color::BLUE_L_BG ); }        
        fn _find_git_root() -> String
        {
            let current_dir = path::current_dir();
            let dir_git = format!( "{}/.git", current_dir );
            if Path::new( &dir_git ).exists()
            {
                return current_dir;
            }

            let mut _dir = current_dir.clone();
            while Path::new( &_dir ).parent().is_some()
            {
                match Path::new( &_dir ).parent()
            {
                    Some( p ) => {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!( "{}/.git", _dir );
                        if Path::new( &dir_git ).exists()
            {
                            return _dir;
                        }
                    }
                    None => {
                        break;
                    }
                }
            }

            String::new()
        }
              
        fn apply_color_status( sh:&shell::Shell, prompt:&mut String )
        {
            if sh.previous_status == 0 { prompt.push_str( color::GREEN_B ); }
            else { prompt.push_str( color::RED_B ); }
        }

        fn apply_gitbr( prompt:&mut String )
        {
            let git_root = _find_git_root();
            if git_root.is_empty()
            {
                return;
            }

            let file_head = format!( "{}/.git/HEAD", git_root );
            if !Path::new( &file_head ).exists()
            {
                return;
            }

            let mut file;
            match File::open( &file_head )
            {
                Ok( x ) => file = x,
                Err( e ) =>
                {
                    println!( "cicada: .git/HEAD err: {:?}", e );
                    return;
                }
            }

            let mut text = String::new();
            match file.read_to_string( &mut text )
            {
                Ok( _ ) => {}
                Err( e ) =>
                {
                    println!( "cicada: read_to_string error: {:?}", e );
                    return;
                }
            }

            if let Some( branch ) = regex::find_first_group( r"^[a-z]+: ?[a-z]+/[a-z]+/( .+ )$", text.trim() )
            {
                apply_blue_b( prompt );
                if let Ok( x ) = env::var( "CICADA_GITBR_PREFIX" ) { prompt.push_str( &x ); }

                let _len_default: i32 = 32;
                let mut len_max = if let Ok( x ) = env::var( "CICADA_GITBR_MAX_LEN" )
                {
                    match x.parse::<i32>()
                    {
                        Ok( n ) => n,
                        Err( _ ) => _len_default,
                    }
                } 
                else { _len_default };

                if len_max <= 0 { len_max = _len_default; }

                if branch.len() as i32 <= len_max { prompt.push_str( &branch ); }
                else
                {
                    let len = branch.len() as i32;
                    let offset = ( len - len_max + 2 ) as usize;
                    let branch_short = format!( "..{}", &branch[offset..] );
                    prompt.push_str( &branch_short );
                }

                if let Ok( x ) = env::var( "CICADA_GITBR_SUFFIX" ) { prompt.push_str( &x ); }

                apply_reset( prompt );
            }
        }

        fn apply_cwd( prompt:&mut String )
        {
            let _current_dir = match env::current_dir()
            {
                Ok( x ) => x,
                Err( e ) => {
                    println_stderr!( "cicada: PROMPT: env current_dir error: {}", e );
                    return;
                }
            };
            let current_dir = match _current_dir.to_str()
            {
                Some( x ) => x,
                None => {
                    println_stderr!( "cicada: PROMPT: to_str error" );
                    return;
                }
            };
            let _tokens: Vec<&str> = current_dir.split( '/' ).collect();

            let last = match _tokens.last()
            {
                Some( x ) => x,
                None => {
                    log!( "cicada: PROMPT: token last error" );
                    return;
                }
            };

            let home = tools::get_user_home();
            let pwd = if last.is_empty()
            {
                "/"
            } else if current_dir == home {
                "~"
            } else {
                last
            };
            prompt.push_str( pwd );
        }

        fn apply_hostname( prompt:&mut String )
        {
            let hostname = tools::get_hostname();
            prompt.push_str( &hostname );
        }

        fn apply_newline( prompt:&mut String ) { prompt.push( '\n' ); }
    }

    pub mod prompt
    {
        use ::
        {
            collections::{ FindResult },
            io::
            {
                reader::{ BindingIter, InputState, ReadLock, ReadResult },
                writer::{ BLINK_DURATION, display_str, Digit, Display, HistoryIter, PromptType, Writer, WriteLock },
            },
            mem::{ replace },
            ops::{ Range },
            sync::{ Arc },
            system::
            {
                signal::{ Signal },
                terminal::{ CursorMode, Size, Terminal },    
            },
            terminal::{ Terminals },
            time::{ Instant },
            *,
        };
        /*
            use linefeed::chars::{is_ctrl, is_printable, DELETE, EOF};
            use linefeed::command::{Category, Command};
            use linefeed::complete::Completion;
            use linefeed::function::Function;
            use linefeed::table::{format_columns, Line, Table};

            use linefeed::util::
            {
                get_open_paren, find_matching_paren, first_word, longest_common_prefix, repeat_char, back_n_words,
                forward_n_words, backward_char, forward_char, backward_word, forward_word, word_start, word_end,
                RangeArgument,
            };

            use linefeed::variables::VariableIter;

            use self::main::get_prompt_string;
            use self::main::render_prompt;
            pub use self::multilines::EnterFunction;
        */
        /// Provides access to the current state of input while a `read_line` call is in progress.
        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminals>
        {
            pub read:&'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminals> Prompter<'a, 'b, Term> 
        {
            pub fn new( read:&'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term> ) -> Prompter<'a, 'b, Term>
            {
                Prompter{read, write}
            }
            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_append<'c>( &'c mut self ) -> io::Result<Writer<'c, 'b, Term>> 
            { Writer::with_ref( &mut self.write, false ) }
            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_erase<'c>( &'c mut self ) -> io::Result<Writer<'c, 'b, Term>> 
            { Writer::with_ref( &mut self.write, true ) }
            /// Resets input state at the start of `read_line`
            fn reset_input( &mut self )
            {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub fn start_read_line( &mut self ) -> io::Result<()> 
            {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub fn end_read_line( &mut self ) -> io::Result<()> 
            {
                self.write.expire_blink()?;

                if self.read.overwrite_mode { self.write.set_cursor_mode( CursorMode::Normal )?; }
                
                if self.write.is_prompt_drawn
                {
                    self.write.move_to_end()?;
                    self.write.write_str( "\n" )?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok( () )
            }

            pub fn handle_input( &mut self, ch: char ) -> io::Result<Option<ReadResult>> 
            {
                self.write.expire_blink()?;

                match self.read.state 
                {
                    InputState::Inactive => panic!( "input received in inactive state" ),
                    InputState::NewSequence => 
                    {
                        if ch == EOF && self.write.buffer.is_empty()
                        {
                            self.write.write_str( "\n" )?;
                            self.write.is_prompt_drawn = false;
                            return Ok( Some( ReadResult::Eof ) );
                        }
                        
                        else
                        {
                            self.read.sequence.push( ch );
                            self.execute_sequence()?;

                            if self.read.input_accepted 
                            {
                                let s = replace( &mut self.write.buffer, String::new() );
                                return Ok( Some( ReadResult::Input( s ) ) );
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => 
                    {
                        self.read.sequence.push( ch );
                        self.execute_sequence()?;

                        if self.read.input_accepted 
                        {
                            let s = replace( &mut self.write.buffer, String::new() );
                            return Ok( Some( ReadResult::Input( s ) ) );
                        }
                    }

                    InputState::Number => 
                    {
                        if let Some( digit ) = ch.to_digit( 10 )
                        {
                            self.write.input_arg.input( digit as i32 );

                            if self.write.input_arg.is_out_of_bounds() 
                            {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt( PromptType::Normal )?;
                            }

                            else { self.write.redraw_prompt( PromptType::Number )?; }
                        }
                        
                        else
                        {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt( PromptType::Normal )?;
                            self.read.macro_buffer.insert( 0, ch );
                        }
                    }

                    InputState::CharSearch{n, backward} => 
                    {
                        if n != 0
                        {
                            if backward { self.write.backward_search_char( n, ch )?; }
                            else { self.write.forward_search_char( n, ch )?; }
                        }

                        self.read.state = InputState::NewSequence;
                    }

                    InputState::TextSearch => 
                    {
                        if ch == DELETE
                        {
                            let write = &mut *self.write;
                            write.search_buffer.pop();
                            write.last_search.clone_from( &write.search_buffer );
                            self.write.search_history_update()?;
                        }
                        
                        else if self.is_abort( ch )
                        {
                            self.abort_search_history()?;
                        }

                        else if is::ctrl( ch )
                        {
                            self.end_search_history()?;
                            self.read.macro_buffer.insert( 0, ch );
                        }
                        
                        else
                        {
                            let write = &mut *self.write;
                            write.search_buffer.push( ch );
                            write.last_search.clone_from( &write.search_buffer );
                            self.write.search_history_update()?;
                        }
                    }

                    InputState::CompleteIntro => 
                    {
                        match ch
                        {
                            'y' | 'Y' | ' ' =>
                            {
                                self.write.write_str( "\n" )?;
                                self.show_completions_page( 0 )?;
                            }
                            '\r' | '\n' =>
                            {
                                self.write.write_str( "\n" )?;
                                self.show_completions_line( 0 )?;
                            }
                            'q' | 'Q' | 'n' | 'N' | DELETE =>
                            {
                                self.write.write_str( "\n" )?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }

                    InputState::CompleteMore( offset ) => 
                    {
                        match ch
                        {
                            'y' | 'Y' | ' ' =>
                            {
                                self.write.clear_prompt()?;
                                self.show_completions_page( offset )?;
                            }
                            '\r' | '\n' =>
                            {
                                self.write.clear_prompt()?;
                                self.show_completions_line( offset )?;
                            }
                            'q' | 'Q' | 'n' | 'N' | DELETE =>
                            {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    
                    InputState::QuotedInsert( n ) => 
                    {
                        if n != 0 { self.insert( n, ch )?; }
                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok( None )
            }
            /// Returns the current buffer.
            pub fn buffer( &self ) -> &str { &self.write.buffer }
            /// Returns the "backup" buffer.
            pub fn backup_buffer( &self ) -> &str { &self.write.backup_buffer }
            /// Returns the command `Category` of the most recently executed command.
            pub fn last_command_category( &self ) -> Category { self.read.last_cmd }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars( &self ) -> &str { &self.read.word_break }
            /// Sets the buffer to the given value.
            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> { self.write.set_buffer( buf ) }
            /// Returns the current position of the cursor.
            pub fn cursor( &self ) -> usize { self.write.cursor }
            /// Sets the cursor to the given position within the buffer.
            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> { self.write.set_cursor( pos ) }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> { self.write.set_prompt( prompt ) }
            /// Returns the size of the terminal at the last draw operation.
            pub fn screen_size( &self ) -> Size { self.write.screen_size }
            /// Returns whether a numerical argument was explicitly supplied by the user.
            pub fn explicit_arg( &self ) -> bool { self.write.explicit_arg }
            /// Returns the current input sequence.
            pub fn sequence( &self ) -> &str { &self.read.sequence }
            /// Returns an iterator over bound sequences
            pub fn bindings( &self ) -> BindingIter { self.read.bindings() }
            /// Returns an iterator over variable values.
            pub fn variables( &self ) -> VariableIter { self.read.variables() }
            /// Returns an iterator over history entries
            pub fn history( &self ) -> HistoryIter { self.write.history() }
            /// Returns the index into history currently being edited.
            pub fn history_index( &self ) -> Option<usize> { self.write.history_index }
            /// Returns the current number of history entries.
            pub fn history_len( &self ) -> usize { self.write.history.len() }

            fn next_history( &mut self, n: usize ) -> io::Result<()> { self.write.next_history( n ) }

            fn prev_history( &mut self, n: usize ) -> io::Result<()> { self.write.prev_history( n ) }
            /// Selects the history entry currently being edited by the user.
            pub fn select_history_entry( &mut self, new:Option<usize> ) -> io::Result<()> 
            { self.write.select_history_entry( new ) }
            /// Returns the current set of completions.
            pub fn completions( &self ) -> Option<&[Completion]> 
            { self.read.completions.as_ref().map( |v| &v[..] ) }
            /// Sets the current set of completions.
            pub fn set_completions( &mut self, completions:Option<Vec<Completion>> )
            { self.read.completions = completions; }
            /// Attempts to execute the current sequence.
            fn execute_sequence( &mut self ) -> io::Result<()> 
            {
                match self.find_binding( &self.read.sequence )
                {
                    FindResult::Found( cmd ) => 
                    {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command( cmd, n, ch )?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => 
                    {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => 
                    {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided( _ ) => 
                    {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                }

                Ok( () )
            }

            fn force_execute_sequence( &mut self ) -> io::Result<()> 
            {
                self.read.state = InputState::NewSequence;

                match self.find_binding( &self.read.sequence )
                {
                    FindResult::Found( cmd ) | FindResult::Undecided( cmd ) =>
                    {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command( cmd, n, ch )?;
                        self.read.sequence.clear();
                    }
                    
                    FindResult::NotFound =>
                    {
                        self.insert_first_char()?;
                    }
                    
                    FindResult::Incomplete => unreachable!(),
                }

                Ok( () )
            }
            /// Execute the command `SelfInsert` on the first character in the input sequence, if it is printable.
            fn insert_first_char( &mut self ) -> io::Result<()>
            {
                let ( first, rest ) =
                {
                    let mut chars = self.read.sequence.chars();
                    ( chars.next().unwrap(), chars.as_str().to_owned() )
                };

                self.read.sequence.clear();

                if is::printable( first )
                {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command( Command::SelfInsert, n, first )?;
                }

                if !rest.is_empty() { self.read.queue_input( &rest ); }

                Ok( () )
            }

            fn find_binding( &self, seq:&str ) -> FindResult<Command>
            { self.read.bindings.find( seq ).cloned() }

            fn get_function( &self, name:&str ) -> Option<&Arc<dyn Function<Term>>>
            { self.read.functions.get( name ) }

            fn is_abort( &self, ch: char ) -> bool
            {
                let mut buf = [0; 4];
                let s = ch.encode_utf8( &mut buf );
                self.find_binding( &s ) == FindResult::Found( Command::Abort )
            }

            fn execute_command( &mut self, cmd: Command, n: i32, ch: char ) -> io::Result<()>
            {
                use ::command::Command::*;

                let mut category = cmd.category();

                if self.read.overwrite_mode
                {
                    match cmd
                    {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd
                {
                    Abort => (),
                    AcceptLine => { self.accept_input()?; }
                    Complete => 
                    {
                        if !self.read.disable_completion { self.complete_word()?; }
                        else if is::printable( ch )
                        { self.execute_command( SelfInsert, n, ch )?; }
                    }

                    InsertCompletions =>
                    {
                        if self.read.completions.is_none() { self.build_completions(); }

                        if let Some( completions ) = self.read.completions.take() 
                        {
                            self.insert_completions( &completions )?;
                            self.read.completions = Some( completions );
                        }
                    }

                    PossibleCompletions =>
                    {
                        if self.read.completions.is_none() { self.build_completions(); }

                        if let Some( completions ) = self.read.completions.take()
                        {
                            self.show_completions( &completions )?;
                            self.read.completions = Some( completions );
                        }
                    }

                    MenuComplete =>
                    {
                        if self.read.completions.is_none() { self.build_completions(); }

                        if n > 0 { self.next_completion( n as usize )?; }
                        else { self.prev_completion( ( -n ) as usize )?; }
                    }

                    MenuCompleteBackward =>
                    {
                        if self.read.completions.is_none() { self.build_completions(); }

                        if n > 0 { self.prev_completion( n as usize )?; }
                        else { self.next_completion( ( -n ) as usize )?; }
                    }

                    DigitArgument =>
                    {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char( ch );
                        self.write.redraw_prompt( PromptType::Number )?;
                    }

                    SelfInsert =>
                    {
                        if n > 0
                        {
                            let n = n as usize;

                            if self.read.overwrite_mode { self.overwrite( n, ch )?; }
                            else { self.insert( n, ch )?; }

                            if self.read.blink_matching_paren
                            {
                                if let Some( open ) = get_open_paren( ch )
                                {
                                    if let Some( pos ) = find_matching_paren
                                    ( 
                                        &self.write.buffer[..self.write.cursor],
                                        &self.read.string_chars, open, ch
                                    )
                                    { self.blink( pos )?; }
                                }
                            }
                        }
                    }

                    TabInsert =>
                    {
                        if n > 0 { self.insert( n as usize, '\t' )?; }
                    }

                    InsertComment =>
                    {
                        if self.explicit_arg() 
                        && self.write.buffer.starts_with( &self.read.comment_begin[..] )
                        {
                            self.write.move_to( 0 )?;
                            let n = self.read.comment_begin.len();
                            self.delete_range( ..n )?;
                            self.accept_input()?;
                        }
                        
                        else
                        {
                            self.write.move_to( 0 )?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str( &s )?;
                            self.accept_input()?;
                        }
                    }

                    BackwardChar =>
                    {
                        if n > 0 { self.write.backward_char( n as usize )?; }
                        else if n < 0
                        { self.write.forward_char( ( -n ) as usize )?; }
                    }
                    
                    ForwardChar =>
                    {
                        if n > 0 { self.write.forward_char( n as usize )?; }
                        else if n < 0 { self.write.backward_char( ( -n ) as usize )?; }
                    }

                    CharacterSearch =>
                    {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch
                            {
                                n: n as usize,
                                backward: false,
                            }
                        }

                        else
                        {
                            self.read.state = InputState::CharSearch
                            {
                                n: ( -n ) as usize,
                                backward: true
                            };
                        }
                    }

                    CharacterSearchBackward =>
                    {
                        if n >= 0
                        {
                            self.read.state = InputState::CharSearch
                            {
                                n: n as usize,
                                backward: true,
                            }
                        }
                        else
                        {
                            self.read.state = InputState::CharSearch
                            {
                                n: ( -n ) as usize,
                                backward: false,
                            };
                        }
                    }

                    BackwardWord =>
                    {
                        if n > 0 { self.backward_word( n as usize )?; }
                        else if n < 0 { self.forward_word( ( -n ) as usize )?; }
                    }

                    ForwardWord =>
                    {
                        if n > 0 
                        {
                            let pos = forward_word
                            ( n as usize, &self.write.buffer, self.write.cursor, &self.read.word_break );
                            self.write.move_to( pos )?;
                        }
                        else if n < 0
                        {
                            let pos = forward_word
                            ( ( -n ) as usize, &self.write.buffer, self.write.cursor, &self.read.word_break );
                            self.write.move_to( pos )?;
                        }
                    }

                    BackwardKillLine =>
                    {
                        let r = ..self.write.cursor;
                        self.kill_range( r )?;
                    }

                    KillLine =>
                    {
                        let r = self.write.cursor..;
                        self.kill_range( r )?;
                    }

                    BackwardKillWord =>
                    {
                        if n > 0 {
                            let pos = backward_word( n as usize, &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        }
                        else if n < 0
                        {
                            let pos = forward_word
                            ( ( -n ) as usize, &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                    }

                    KillWord =>
                    {
                        if n > 0
                        {
                            let pos = forward_word
                            ( n as usize, &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                        
                        else if n < 0
                        {
                            let pos = backward_word
                            ( ( -n ) as usize, &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        }
                    }

                    UnixWordRubout =>
                    {
                        if n > 0
                        {
                            let pos = backward_word( n as usize, &self.write.buffer, self.write.cursor, " \t\n" );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        }
                        
                        else if n < 0
                        {
                            let pos = forward_word
                            ( ( -n ) as usize, &self.write.buffer, self.write.cursor, " \t\n" );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                    }

                    ClearScreen => { self.write.clear_screen()?; }
                    BeginningOfLine => self.write.move_to( 0 )?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar =>
                    {
                        if n > 0
                        {
                            if self.read.overwrite_mode { self.overwrite_back( n as usize )?; }
                            else
                            {
                                let pos = char::backward( n as usize, &self.write.buffer, self.write.cursor );
                                let r = pos..self.write.cursor;
                                self.delete_range( r )?;
                            }
                        }

                        else if n < 0
                        {
                            let pos = char::forward(( -n ) as usize, &self.write.buffer, self.write.cursor );
                            let r = self.write.cursor..pos;
                            self.delete_range( r )?;
                        }
                    }
                    
                    DeleteChar =>
                    {
                        if n > 0 
                        {
                            let pos = char::forward( n as usize, &self.write.buffer, self.write.cursor );
                            let r = self.write.cursor..pos;
                            self.delete_range( r )?;
                        }

                        else if n < 0
                        {
                            let pos = char::backward( n as usize, &self.write.buffer, self.write.cursor );
                            let r = pos..self.write.cursor;
                            self.delete_range( r )?;
                        }
                    }
                    
                    TransposeChars =>
                    {
                        if n != 0 && self.write.cursor != 0
                        {
                            let ( src, dest );

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len()
                            {
                                let end = char::backward( 1, &self.write.buffer, self.write.cursor );
                                let start = char::backward( 1, &self.write.buffer, end );
                                src = start..end;
                                dest = end..self.write.cursor;
                            }
                            
                            else
                            {
                                let start = char::backward( 1, &self.write.buffer, self.write.cursor );
                                let end = self.write.cursor;
                                src = start..end;

                                dest = if n < 0 
                                {
                                    let back = char::backward( ( -n ) as usize, &self.write.buffer, start );
                                    back..start
                                }
                                
                                else
                                {
                                    let fwd = char::forward( n as usize + 1, &self.write.buffer, start );
                                    end..fwd
                                };
                            }

                            self.transpose_range( src, dest )?;
                        }
                    }

                    TransposeWords =>
                    {
                        if n != 0
                        {
                            if let Some( first ) = first_word
                            ( &self.write.buffer[..self.write.cursor], &self.read.word_break )
                            {
                                let start = word_start( &self.write.buffer, self.write.cursor, &self.read.word_break );

                                if first != start
                                {
                                    let ( src, dest );

                                    if !self.explicit_arg() && start == self.write.buffer.len()
                                    {
                                        let dest_start = backward_word
                                        ( 1, &self.write.buffer, start, &self.read.word_break );
                                        let dest_end = word_end
                                        ( &self.write.buffer, dest_start, &self.read.word_break );

                                        let src_start = backward_word
                                        ( 1, &self.write.buffer, dest_start, &self.read.word_break );
                                        let src_end = word_end
                                        ( &self.write.buffer, src_start, &self.read.word_break );

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    }
                                    
                                    else
                                    {
                                        let src_start = backward_word
                                        ( 1, &self.write.buffer, start, &self.read.word_break );
                                        let src_end = word_end
                                        ( &self.write.buffer, src_start, &self.read.word_break );

                                        src = src_start..src_end;

                                        dest = if n < 0 
                                        {
                                            back_n_words
                                            ( ( -n ) as usize, &self.write.buffer, src_start, &self.read.word_break )
                                        } 
                                        else 
                                        {
                                            forward_n_words
                                            ( n as usize, &self.write.buffer, src_start, &self.read.word_break )
                                        };
                                    }

                                    self.transpose_range( src, dest )?;
                                }
                            }
                        }
                    }

                    BeginningOfHistory => { self.select_history_entry( Some( 0 ) )?; }

                    EndOfHistory => { self.select_history_entry( None )?; }

                    NextHistory =>
                    {
                        if n > 0 { self.next_history( n as usize )?; } 
                        else if n < 0 { self.prev_history( ( -n ) as usize )?; }
                    }

                    PreviousHistory =>
                    {
                        if n > 0 { self.prev_history( n as usize )?; }
                        else if n < 0 { self.next_history( ( -n ) as usize )?; }
                    }

                    ForwardSearchHistory =>
                    {
                        self.read.state = InputState::TextSearch;

                        if self.read.last_cmd == Category::IncrementalSearch
                        { self.write.continue_search_history( false )?; }
                        else { self.write.start_search_history( false )?; }
                    }
                    
                    ReverseSearchHistory =>
                    {
                        self.read.state = InputState::TextSearch;
                        
                        if self.read.last_cmd == Category::IncrementalSearch
                        { self.write.continue_search_history( true )?; }
                        else { self.write.start_search_history( true )?; }
                    }

                    HistorySearchForward => 
                    {
                        if self.read.last_cmd == Category::Search
                        { self.write.continue_history_search( false )?; }                        
                        else { self.write.start_history_search( false )?; }
                    }

                    HistorySearchBackward => 
                    {
                        if self.read.last_cmd == Category::Search 
                        { self.write.continue_history_search( true )?; }                        
                        else { self.write.start_history_search( true )?; }
                    }

                    QuotedInsert => 
                    {
                        self.read.state = InputState::QuotedInsert( if n >= 0 { n as usize } else { 0 });
                    }

                    OverwriteMode => 
                    {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode 
                        {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode { CursorMode::Overwrite }
                        else  { CursorMode::Normal };

                        self.write.set_cursor_mode( mode )?;
                    }

                    Yank =>  { self.yank()?; }

                    YankPop =>  { self.yank_pop()?; }

                    Custom( ref name ) => 
                    {
                        if let Some( fun ) = self.get_function( name ).cloned()
                        {
                            fun.execute( self, n, ch )?;
                            category = fun.category();
                        }
                    }

                    Macro( ref seq ) => { self.read.queue_input( seq ); }
                }

                if category != Category::Digit
                {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;
                    self.read.last_cmd = category;

                    if category != Category::Complete { self.read.completions = None; }

                    if category != Category::Yank { self.read.last_yank = None; }
                }

                Ok( () )
            }
            /// Accepts the current input buffer as user input.
            pub fn accept_input( &mut self ) -> io::Result<()> 
            {
                self.write.move_to_end()?;
                self.write.write_str( "\n" )?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok( () )
            }
            /// Moves the cursor to the given position, waits for 500 milliseconds ( or until next user input ), 
            /// then restores the original cursor position.
            pub fn blink( &mut self, pos: usize ) -> io::Result<()> 
            {
                self.write.blink( pos )?;
                self.read.max_wait_duration = Some( BLINK_DURATION );
                Ok( () )
            }

            fn check_expire_blink( &mut self, now: Instant ) -> io::Result<()> 
            {
                if self.write.check_expire_blink( now )? { self.read.max_wait_duration = None; }

                Ok( () )
            }

            fn check_expire_sequence( &mut self, now: Instant ) -> io::Result<()> 
            {
                if let InputState::ContinueSequence{expiry: Some( expiry )} = self.read.state 
                {
                    if now >= expiry
                    {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok( () )
            }

            fn keyseq_expiry( &mut self ) -> Option<Instant> 
            {
                if let Some( t ) = self.read.keyseq_timeout 
                {
                    self.read.max_wait_duration = Some( t );
                    Some( Instant::now() + t )
                }
                else { None }
            }

            pub fn check_expire_timeout( &mut self ) -> io::Result<()> 
            {
                let now = Instant::now();
                self.check_expire_blink( now )?;
                self.check_expire_sequence( now )
            }

            fn expire_blink( &mut self ) -> io::Result<()> 
            {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions( &mut self )
            {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start( &self.write.buffer, end, self );

                if start > end
                {
                    panic!( "Completer::word_start returned invalid index; \
                        start > end ( {} > {} )", start, end );
                }

                let unquoted = compl.unquote( &self.write.buffer[start..end] ).into_owned();
                let completions = compl.complete( &unquoted, self, start, end );
                let n_completions = completions.as_ref().map_or( 0, |c| c.len() );
                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word( &mut self ) -> io::Result<()> 
            {
                if let Some( completions ) = self.read.completions.take()
                {
                    if completions.len() == 1 { self.substitute_completion( &completions[0] )?; }
                    else 
                    {
                        self.show_completions( &completions )?;
                        self.read.completions = Some( completions );
                    }
                }
                else 
                {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 { self.substitute_completion( &completions[0] )?; }                    
                    else if !completions.is_empty()
                    {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let pfx = get::longest_common_prefix
                        ( completions.iter().map( |compl| &compl.completion[..] ) ).unwrap_or_default();

                        self.replace_str_forward( start..end, &pfx )?;
                        self.read.completions = Some( completions );
                    }
                }

                Ok( () )
            }

            fn substitute_completion( &mut self, compl:&Completion ) -> io::Result<()> 
            {
                let mut s = self.read.completer.quote( &compl.completion );

                if let Some( suffix ) = compl.suffix.with_default( self.read.completion_append_character )
                { s.to_mut().push( suffix ); }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward( start..end, &s )
            }
            
            fn insert_completions( &mut self, completions:&[Completion] ) -> io::Result<()> 
            {
                let mut words = String::new();

                for compl in completions
                {
                    words.push_str( &self.read.completer.unquote( &compl.completion ) );
                    words.push( ' ' );
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward( start..end, &words )
            }

            fn show_completions( &mut self, completions:&[Completion] ) -> io::Result<()> 
            {
                if completions.is_empty() { return Ok( () ); }

                let eff_width = self.write.screen_size.columns.min( self.read.completion_display_width );

                let completions = completions.iter()
                .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                .collect::<Vec<_>>();

                let cols = columns( &completions, eff_width, self.read.print_completions_horizontally );
                let table = Table::new
                ( &completions, cols.as_ref().map( |c| &c[..] ), self.read.print_completions_horizontally );

                self.write.write_str( "\n" )?;
                let n_completions = completions.len();

                if self.read.page_completions && n_completions >= self.read.completion_query_items 
                { self.start_page_completions( n_completions ) }
                else 
                {
                    self.show_list_completions( table )?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions( &mut self, n_completions: usize ) -> io::Result<()> 
            {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt( PromptType::CompleteIntro( n_completions ) )
            }

            fn end_page_completions( &mut self ) -> io::Result<()> 
            {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions( &self ) -> bool 
            {
                match self.read.state
                {
                    InputState::CompleteMore( _ ) => true,
                    _ => false
                }
            }

            fn show_completions_page( &mut self, offset: usize ) -> io::Result<()> 
            {
                if let Some( compl ) = self.read.completions.take()
                {
                    let width = self.write.screen_size.columns.min( self.read.completion_display_width );
                    let n_lines = self.write.screen_size.lines - 1;
                    let completions = compl.iter()
                    .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                    .collect::<Vec<_>>();

                    let cols = columns( &completions, width, self.read.print_completions_horizontally );
                    let mut table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                        self.read.print_completions_horizontally );

                    for row in table.by_ref().skip( offset ).take( n_lines )
                    {
                        self.show_completion_line( row )?;
                    }

                    if table.has_more()
                    {
                        self.read.completions = Some( compl );
                        self.read.state = InputState::CompleteMore( offset + n_lines );
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    }
                    else { self.end_page_completions()?; }
                }

                Ok( () )
            }

            fn show_completions_line( &mut self, offset: usize ) -> io::Result<()>
            {
                if let Some( compl ) = self.read.completions.take()
                {
                    let width = self.write.screen_size.columns.min( self.read.completion_display_width );
                    let completions = compl.iter()
                    .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                    .collect::<Vec<_>>();
                    let cols = columns( &completions, width, self.read.print_completions_horizontally );
                    let mut table = Table::new
                    ( &completions, cols.as_ref().map( |c| &c[..] ), self.read.print_completions_horizontally );

                    if let Some( row ) = table.by_ref().skip( offset ).next()
                    {
                        self.show_completion_line( row )?;
                    }

                    if table.has_more()
                    {
                        self.read.completions = Some( compl );
                        self.read.state = InputState::CompleteMore( offset + 1 );
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    }
                    else { self.end_page_completions()?; }
                }

                Ok( () )
            }

            fn show_completion_line<S: AsRef<str>>( &mut self, line: Line<S> ) -> io::Result<()> 
            {
                let mut space = 0;

                for ( width, name ) in line 
                {
                    self.write.move_right( space )?;
                    self.write.write_str( name )?;
                    space = width - name.chars().count();
                }

                self.write.write_str( "\n" )
            }

            fn show_list_completions<S: AsRef<str>>( &mut self, table: Table<S> ) -> io::Result<()> 
            {
                for line in table 
                {
                    let mut space = 0;

                    for ( width, name ) in line 
                    {
                        self.write.move_right( space )?;
                        self.write.write_str( name )?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str( "\n" )?;
                }

                Ok( () )
            }

            fn next_completion( &mut self, n: usize ) -> io::Result<()> 
            {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let max = len + 1;

                let old = self.read.completion_index;
                let new = ( old + n ) % max;

                if old != new 
                {
                    self.set_completion( new )?;
                }

                Ok( () )
            }

            fn prev_completion( &mut self, n: usize ) -> io::Result<()> 
            {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old 
                {
                    max - old - n
                } else 
                {
                    old - n
                };

                self.set_completion( new )
            }

            fn set_completion( &mut self, new: usize ) -> io::Result<()>
            {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let old = self.read.completion_index;

                if old != new
                {
                    self.read.completion_index = new;

                    if new == len
                    {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range( start..end )?;
                    }
                    else
                    {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion( self.read.completion_append_character ).into_owned();

                        self.replace_str_forward( start..end, &s )?;
                    }
                }

                Ok( () )
            }

            fn abort_search_history( &mut self ) -> io::Result<()> 
            {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history( &mut self ) -> io::Result<()> 
            {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub fn handle_resize( &mut self, size:Size ) -> io::Result<()> 
            {
                self.expire_blink()?;

                if self.is_paging_completions()
                {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt( p )
            }

            pub fn handle_signal( &mut self, signal: Signal ) -> io::Result<()> 
            {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => {
                        self.write.draw_prompt()?;
                    }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters 
                        {
                            self.write.write_str( "^C" )?;
                        }

                        self.write.write_str( "\n" )?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok( () )
            }

            fn backward_word( &mut self, n: usize ) -> io::Result<()> 
            {
                let pos = backward_word( n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break );
                self.write.move_to( pos )
            }

            fn forward_word( &mut self, n: usize ) -> io::Result<()> 
            {
                let pos = forward_word( n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break );
                self.write.move_to( pos )
            }
            /// Deletes a range of text from the input buffer.
            pub fn delete_range<R: RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()> 
            {
                self.write.delete_range( range )
            }
            /// Deletes a range from the buffer and adds the removed text to the kill ring.
            pub fn kill_range<R: RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()> 
            {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.write.buffer.len() );
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring( buf );
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring( buf );
                    } else {
                        self.append_kill_ring( buf );
                    }

                    self.delete_range( start..end )?;
                }

                Ok( () )
            }

            fn push_kill_ring( &mut self, s: String )
            {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() { self.read.kill_ring.pop_back(); }

                self.read.kill_ring.push_front( s );
            }

            fn rotate_kill_ring( &mut self )
            {
                if let Some( kill ) = self.read.kill_ring.pop_front() { self.read.kill_ring.push_back( kill ); }
            }

            fn append_kill_ring( &mut self, s: String )
            {
                if let Some( kill ) = self.read.kill_ring.front_mut()
                {
                    kill.push_str( &s );
                    return;
                }

                self.push_kill_ring( s );
            }

            fn prepend_kill_ring( &mut self, s: String )
            {
                if let Some( kill ) = self.read.kill_ring.front_mut()
                {
                    kill.insert_str( 0, &s );
                    return;
                }

                self.push_kill_ring( s );
            }
            /// Transposes two regions of the buffer, `src` and `dest`.
            pub fn transpose_range( &mut self, src: Range<usize>, dest: Range<usize> ) -> io::Result<()>
            { self.write.transpose_range( src, dest ) }
            /// Insert text from the front of the kill ring at the current cursor position.
            pub fn yank( &mut self ) -> io::Result<()>
            {
                if let Some( kill ) = self.read.kill_ring.front().cloned()
                {
                    let start = self.write.cursor;
                    self.read.last_yank = Some(( start, start + kill.len() ) );
                    self.insert_str( &kill )?;
                }

                Ok( () )
            }
            /// Rotates the kill ring and replaces yanked text with the new front.
            pub fn yank_pop( &mut self ) -> io::Result<()>
            {
                if let Some(( start, end ) ) = self.read.last_yank
                {
                    self.rotate_kill_ring();

                    if let Some( kill ) = self.read.kill_ring.front().cloned()
                    {
                        self.read.last_yank = Some(( start, start + kill.len() ) );
                        self.write.move_to( start )?;
                        self.replace_str_forward( start..end, &kill )?;
                    }
                }

                Ok( () )
            }
            /// Overwrite `n` characters; assumes `n >= 1`
            fn overwrite( &mut self, n:usize, ch: char ) -> io::Result<()>
            {
                let start = self.write.cursor;
                let end = char::forward( n, &self.write.buffer, start );
                let over = &self.write.buffer[start..end];
                let n_chars = over.chars().count();

                if n > n_chars { self.read.overwritten_append += n - n_chars; }

                if !over.is_empty() { self.read.overwritten_chars.push_str( &over ); }

                let s = char::repeat( ch, n );
                self.replace_str_forward( start..end, &s )
            }

            fn overwrite_back( &mut self, mut n: usize ) -> io::Result<()>
            {
                if self.read.overwritten_append != 0 
                {
                    let n_del = n.min( self.read.overwritten_append );
                    let pos = char::backward( n_del, &self.write.buffer, self.write.cursor );
                    let r = pos..self.write.cursor;
                    self.delete_range( r )?;
                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty()
                {
                    let n_repl = n.min( self.read.overwritten_chars.chars().count() );
                    let pos = char::backward( n_repl, &self.write.buffer, self.write.cursor );
                    let over_pos = char::backward
                    ( 
                        n_repl,
                        &self.read.overwritten_chars,
                        self.read.overwritten_chars.len()
                    );
                    let over = self.read.overwritten_chars.drain( over_pos.. ).collect::<String>();
                    let r = pos..self.write.cursor;
                    self.replace_str_backward( r, &over )?;
                    n -= n_repl;
                }

                if n != 0 { self.write.backward_char( n )?; }

                Ok( () )
            }
            /// Insert a given character at the current cursor position `n` times.
            pub fn insert( &mut self, n:usize, ch: char ) -> io::Result<()>
            {
                if n != 0
                {
                    let s = char::repeat( ch, n );
                    self.insert_str( &s )?;
                }

                Ok( () )
            }
            /// Insert a string at the current cursor position.
            pub fn insert_str( &mut self, s:&str ) -> io::Result<()> { self.write.insert_str( s ) }
            /// Replaces a range in the buffer and redraws.
            pub fn replace_str_backward<R: RangeArgument<usize>>( &mut self, range: R, s:&str ) -> io::Result<()> 
            {
                self.replace_str_impl( range, s )?;
                let len = self.write.buffer.len();
                self.write.move_from( len )
            }
            /// Replaces a range in the buffer and redraws.
            pub fn replace_str_forward<R: RangeArgument<usize>>( &mut self, range: R, s:&str ) -> io::Result<()> 
            {
                self.replace_str_impl( range, s )?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from( len )
            }
            /// Replaces a range in the buffer and redraws.
            fn replace_str_impl<R: RangeArgument<usize>>( &mut self, range: R, s:&str ) -> io::Result<()>
            {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.write.buffer.len() );
                self.write.move_to( start )?;
                let _ = self.write.buffer.drain( start..end );
                let cursor = self.write.cursor;
                self.write.buffer.insert_str( cursor, s );
                self.write.draw_buffer( cursor )?;
                self.write.clear_to_screen_end()
            }
        }

        pub fn get_prompt( sh:&shell::Shell ) -> String
        {
            let ps = get_prompt_string();
            let mut prompt = render_prompt( sh, &ps );
            if let Some(( w, _h ) ) = libs::term_size::dimensions()
            {
                if get_prompt_len( &prompt ) > ( w / 2 ) as i32 && !regex::contains( &ps, r#"( ?i )\$\{?newline.\}?"# )
                {
                    prompt.push_str( "\n$ " );
                }
            }

            else { log!( "ERROR: Failed to get term size" ); }
            prompt
        }

        fn get_prompt_len( prompt:&str ) -> i32
        {
            let mut count = 0;
            let mut met_x01 = false;

            for c in prompt.chars()
            {
                if c == '\x01'
                {
                    met_x01 = true;
                    continue;
                }
                
                else if c == '\x02'
                {
                    met_x01 = false;
                    continue;
                }
                
                if !met_x01 { count += 1; }
            }

            count
        }
    }
    pub use self::prompt::{ Prompter };

    pub mod size
    {
        use ::
        {
            libc::{ c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO },
            mem::{ zeroed },
            *,
        };
        
        #[cfg( any( target_os = "linux", target_os = "android" ) )] static TIOCGWINSZ: c_ulong = 0x5413;
        #[cfg( any
        ( 
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
       ) )] static TIOCGWINSZ: c_ulong = 0x40087468;
        #[cfg( target_os = "solaris" )] static TIOCGWINSZ: c_ulong = 0x5468;

        extern "C"
        {
            fn ioctl( fd: c_int, request: c_ulong, ... ) -> c_int;
        }
        /// Runs the ioctl command.
        unsafe fn get_dimensions_any() -> winsize
        {
            let mut window: winsize = zeroed();
            let mut result = ioctl( STDOUT_FILENO, TIOCGWINSZ, &mut window );

            if result == -1
            {
                window = zeroed();
                result = ioctl( STDIN_FILENO, TIOCGWINSZ, &mut window );
                if result == -1
                {
                    window = zeroed();
                    result = ioctl( STDERR_FILENO, TIOCGWINSZ, &mut window );
                    if result == -1 { return zeroed(); }
                }
            }
            window
        }
        /// Query the current processes's stdout, stdin, and error stderr in that order, 
        // in the attempt to dtermine terminal width.
        pub fn dimensions() -> Option<( usize, usize )>
        {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 { None }
            else { Some(( w.ws_col as usize, w.ws_row as usize ) ) }
        }
        /// Represents the size of a terminal window.
        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub struct Size
        {
            /// Number of lines in the terminal
            pub lines:usize,
            /// Number of columns in the terminal
            pub columns:usize,
        }

        impl Size
        {
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn area( &self ) -> usize
            { self.checked_area().unwrap_or_else( || panic!( "overflow in Size::area {:?}", self ) ) }
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn checked_area( &self ) -> Option<usize> { self.lines.checked_mul( self.columns ) }
        }
    }
    pub use self::size::{ Size };

    pub mod color
    {
        pub const SEQ:&str = "\x01";
        pub const END_SEQ:&str = "\x02";
        pub const ESC:&str = "\x1B";
        pub const BOLD:&str = "\x01\x1B[1m\x02";
        pub const DIM:&str = "\x01\x1B[2m\x02";
        pub const UNDERLINED:&str = "\x01\x1B[4m\x02";
        pub const BLINK:&str = "\x01\x1B[5m\x02";
        pub const REVERSE:&str = "\x01\x1B[7m\x02";
        pub const HIDDEN:&str = "\x01\x1B[8m\x02";
        pub const RESET:&str = "\x01\x1B[0m\x02";
        pub const RESET_BOLD:&str = "\x01\x1B[21m\x02";
        pub const RESET_DIM:&str = "\x01\x1B[22m\x02";
        pub const RESET_UNDERLINED:&str = "\x01\x1B[24m\x02";
        pub const RESET_BLINK:&str = "\x01\x1B[25m\x02";
        pub const RESET_REVERSE:&str = "\x01\x1B[27m\x02";
        pub const RESET_HIDDEN:&str = "\x01\x1B[28m\x02";
        pub const DEFAULT:&str = "\x01\x1B[39m\x02";
        pub const BLACK:&str = "\x01\x1B[30m\x02";
        pub const RED:&str = "\x01\x1B[31m\x02";
        pub const GREEN:&str = "\x01\x1B[32m\x02";
        pub const YELLOW:&str = "\x01\x1B[33m\x02";
        pub const BLUE:&str = "\x01\x1B[34m\x02";
        pub const MAGENTA:&str = "\x01\x1B[35m\x02";
        pub const CYAN:&str = "\x01\x1B[36m\x02";
        pub const GRAY_L:&str = "\x01\x1B[37m\x02";
        pub const GRAY_D:&str = "\x01\x1B[90m\x02";
        pub const RED_L:&str = "\x01\x1B[91m\x02";
        pub const GREEN_L:&str = "\x01\x1B[92m\x02";
        pub const YELLOW_L:&str = "\x01\x1B[93m\x02";
        pub const BLUE_L:&str = "\x01\x1B[94m\x02";
        pub const MAGENTA_L:&str = "\x01\x1B[95m\x02";
        pub const CYAN_L:&str = "\x01\x1B[96m\x02";
        pub const WHITE:&str = "\x01\x1B[97m\x02";
        pub const BLUE_B:&str = "\x01\x1B[34m\x1B[1m\x02";
        pub const BLACK_B:&str = "\x01\x1B[30m\x1B[1m\x02";
        pub const WHITE_B:&str = "\x01\x1B[97m\x1B[1m\x02";
        pub const RED_B:&str = "\x01\x1B[31m\x1B[1m\x02";
        pub const GREEN_B:&str = "\x01\x1B[32m\x1B[1m\x02";
        pub const DEFAULT_BG:&str = "\x01\x1B[49m\x02";
        pub const BLACK_BG:&str   = "\x01\x1B[40m\x02";
        pub const RED_BG:&str     = "\x01\x1B[41m\x02";
        pub const GREEN_BG:&str   = "\x01\x1B[42m\x02";
        pub const YELLOW_BG:&str   = "\x01\x1B[43m\x02";
        pub const BLUE_BG:&str    = "\x01\x1B[44m\x02";
        pub const MAGENTA_BG:&str    = "\x01\x1B[45m\x02";
        pub const CYAN_BG:&str    = "\x01\x1B[46m\x02";
        pub const GRAY_L_BG:&str    = "\x01\x1B[47m\x02";
        pub const GRAY_D_BG:&str   = "\x01\x1B[100m\x02";
        pub const RED_L_BG:&str   = "\x01\x1B[101m\x02";
        pub const GREEN_L_BG:&str   = "\x01\x1B[102m\x02";
        pub const YELLOW_L_BG:&str   = "\x01\x1B[103m\x02";
        pub const BLUE_L_BG:&str   = "\x01\x1B[104m\x02";
        pub const MAGENTA_L_BG:&str   = "\x01\x1B[105m\x02";
        pub const CYAN_L_BG:&str   = "\x01\x1B[106m\x02";
        pub const WHITE_BG:&str   = "\x01\x1B[107m\x02";
    }
    /// Provides concurrent read and write access to a terminal device.
    pub struct Terminal( pub system::Terminal );
    /// Default `Terminal` interface
    pub struct DefaultTerminal( Terminal );
    /// Defines a low-level interface to the terminal
    pub trait Terminals: Sized + Send + Sync
    {
        /// Returned by `prepare`; passed to `restore` to restore state.
        type PrepareState;
        /*
        /// Holds an exclusive read lock and provides read operations
        type Reader: TerminalReader;
        /// Holds an exclusive write lock and provides write operations
        type Writer: TerminalWriter;
        */
        /// Returns the name of the terminal.
        fn name( &self ) -> &str;

        /// Acquires a lock on terminal read operations and returns a value holding
        /// that lock and granting access to such operations.
        fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a>;
        /// Acquires a lock on terminal write operations and returns a value holding
        /// that lock and granting access to such operations.
        fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a>;
    }
    /// The main interface to input reading and other terminal operations
    pub struct Interface<Term: Terminals>
    {
        term: Arc<Term>,
        read: Arc<Mutex<Read<Term>>>,
        write: Arc<Mutex<Write>>,
        highlighter:Option<Arc<dyn Highlighter + Send + Sync>>,
    }

    impl Interface<DefaultTerminal> 
    {
        /// Creates a new `Interface` with the given application name.
        pub fn new<T>( application:T ) -> io::Result<Interface<DefaultTerminal>> where
        T: Into<Cow<'static, str>>
        {
            let term = DefaultTerminal::new()?;
            Interface::with_term( application, term )
        }
    }

    impl<Term: Terminals> Interface<Term>
    {
        /// Creates a new `Interface` instance with a particular terminal implementation.
        pub fn with_term<T>( application:T, term: Term ) -> io::Result<Interface<Term>> where 
        T:Into<Cow<'static, str>>
        {
            let size = term.lock_write().size()?;
            let read = Read::new( &term, application.into() );

            Ok( Interface
            {
                term: Arc::new( term ),
                read: Arc::new( Mutex::new( read ) ),
                write: Arc::new( Mutex::new( Write::new( size ) ) ),
                highlighter: None,
            } )
        }
        /// Acquires the read lock and returns a `Reader` instance.
        pub fn lock_reader( &self ) -> Reader<Term> { Reader::new( self, self.lock_read() ) }
        /// Acquires the write lock and returns a `Writer` instance.
        pub fn lock_writer_append( &self ) -> io::Result<Writer<Term>>
        { Writer::with_lock( self.lock_write()?, false ) }
        /// Acquires the write lock and returns a `Writer` instance.
        pub fn lock_writer_erase( &self ) -> io::Result<Writer<Term>>
        { Writer::with_lock( self.lock_write()?, true ) }

        fn lock_read( &self ) -> ReadLock<Term>
        { ReadLock::new(  self.term.lock_read(), self.read.lock().expect( "Interface::lock_read" ) ) }

        pub fn lock_write( &self ) -> io::Result<WriteLock<Term>>
        {
            let guard = self.write.lock().unwrap();
            let term_writer = self.term.lock_write();
            Ok( WriteLock::new( term_writer, guard, self.highlighter.clone() ) )
        }

        pub fn lock_write_data( &self ) -> MutexGuard<Write> { self.write.lock().expect( "Interface::lock_write_data" ) }
    }
    /// ## Locking
    /// The following methods internally acquire the read lock.
    impl<Term: Terminals> Interface<Term> 
    {
        /// Interactively reads a line from the terminal device.
        pub fn read_line( &self ) -> io::Result<ReadResult> { self.lock_reader().read_line() }
        /// Performs one step of the interactive `read_line` loop.
        pub fn read_line_step( &self, timeout:Option<Duration> ) -> io::Result<Option<ReadResult>>
        { self.lock_reader().read_line_step( timeout ) }
        /// Cancels an in-progress `read_line` operation.
        pub fn cancel_read_line( &self ) -> io::Result<()> { self.lock_reader().cancel_read_line() }
        /// Returns a clone of the current completer instance.
        pub fn completer( &self ) -> Arc<dyn Completer<Term>> { self.lock_reader().completer().clone() }
        /// Replaces the current completer, returning the previous instance.
        pub fn set_completer( &self, completer: Arc<dyn Completer<Term>> )
        -> Arc<dyn Completer<Term>> { self.lock_reader().set_completer( completer ) }
        /// Returns the value of the named variable or `None` if no such variable exists.
        pub fn get_variable( &self, name:&str ) -> Option<Variable> { self.lock_reader().get_variable( name ) }
        /// Sets the value of the named variable and returns the previous value.
        pub fn set_variable( &self, name:&str, value:&str ) -> Option<Variable> { self.lock_reader().set_variable( name, value ) }
        /// Returns whether the given `Signal` is ignored.
        pub fn ignore_signal( &self, signal: Signal ) -> bool { self.lock_reader().ignore_signal( signal ) }
        /// Sets whether the given `Signal` will be ignored.
        pub fn set_ignore_signal( &self, signal: Signal, set:bool ) { self.lock_reader().set_ignore_signal( signal, set ) }
        /// Returns whether the given `Signal` is reported.
        pub fn report_signal( &self, signal: Signal ) -> bool { self.lock_reader().report_signal( signal ) }
        /// Sets whether the given `Signal` is reported.
        pub fn set_report_signal( &self, signal: Signal, set:bool ) 
        { self.lock_reader().set_report_signal( signal, set ) }
        /// Binds a sequence to a command.
        pub fn bind_sequence<T>( &self, seq:T, cmd: Command ) -> Option<Command> where 
        T: Into<Cow<'static, str>>
        { self.lock_reader().bind_sequence( seq, cmd ) }
        /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
        pub fn bind_sequence_if_unbound<T>( &self, seq:T, cmd: Command ) -> bool where
        T: Into<Cow<'static, str>>
        { self.lock_reader().bind_sequence_if_unbound( seq, cmd ) }
        /// Removes a binding for the given sequence.
        pub fn unbind_sequence( &self, seq:&str ) -> Option<Command> { self.lock_reader().unbind_sequence( seq ) }
        /// Defines a named function to which sequences may be bound.
        pub fn define_function<T>( &self, name:T, cmd: Arc<dyn Function<Term>> ) -> Option<Arc<dyn Function<Term>>>
        where
        T: Into<Cow<'static, str>>
        { self.lock_reader().define_function( name, cmd ) }
        /// Removes a function defined with the given name.
        pub fn remove_function( &self, name:&str ) -> Option<Arc<dyn Function<Term>>>
        { self.lock_reader().remove_function( name ) }
        /// Evaluates a series of configuration directives.
        pub fn evaluate_directives( &self, dirs: Vec<Directive> )
        { self.lock_reader().evaluate_directives( &self.term, dirs ) }
        /// Evaluates a single configuration directive.
        pub fn evaluate_directive( &self, dir: Directive )
        { self.lock_reader().evaluate_directive( &self.term, dir ) }
    }
    /// ## Locking
    /// The following methods internally acquire the write lock.
    impl<Term: Terminals> Interface<Term>
    {
        /// Returns the current input buffer.
        pub fn buffer( &self ) -> String { self.lock_write().map( |lock| lock.buffer.to_owned() ).unwrap_or_default() }
        /// Returns the current number of history entries.
        pub fn history_len( &self ) -> usize { self.lock_write().map( |lock| lock.history_len() ).unwrap_or( 0 ) }
        /// Returns the maximum number of history entries.
        pub fn history_size( &self ) -> usize { self.lock_write().map( |lock| lock.history_size() ).unwrap_or( 0 ) }
        /// Save history entries to the specified file.
        pub fn save_history<P: AsRef<Path>>( &self, path:P ) -> io::Result<()>
        {
            let path = path.as_ref();
            let mut w = self.lock_write()?;

            if !path.exists() || w.history_size() == !0 { self.append_history( path, &w )?; } 
            else { self.rewrite_history( path, &w )?; }

            w.reset_new_history();
            Ok( () )
        }

        fn append_history<P: AsRef<Path>>( &self, path: P, w:&WriteLock<Term> ) -> io::Result<()>
        {
            let file = OpenOptions::new()
            .append( true )
            .create( true )
            .open( path.as_ref() )?;

            self.append_history_to( &file, w )
        }

        fn append_history_to( &self, file:&File, w:&WriteLock<Term> ) -> io::Result<()>
        {
            let mut wtr = BufWriter::new( file );

            for entry in w.new_history()
            {
                wtr.write_all( entry.as_bytes() )?;
                wtr.write_all( b"\n" )?;
            }

            wtr.flush()
        }

        fn rewrite_history<P: AsRef<Path>>( &self, path: P, w:&WriteLock<Term> ) -> io::Result<()>
        {
            fn nth_line( s:&str, n: usize ) -> Option<usize>
            {
                let start = s.as_ptr() as usize;
                s.lines().nth( n ).map( |s| s.as_ptr() as usize - start )
            }

            let mut file = OpenOptions::new()
            .create( true )
            .read( true )
            .write( true )
            .open( path.as_ref() )?;

            let mut hist = String::new();
            file.read_to_string( &mut hist )?;
            let n_lines = hist.lines().count();
            let n = n_lines.saturating_sub( w.history_size() - w.new_history_entries() );

            if n != 0
            {
                if let Some( pos ) = nth_line( &hist, n )
                {
                    file.seek( SeekFrom::Start( 0 ) )?;
                    file.write_all( hist[pos..].as_bytes() )?;
                    let n = file.seek( SeekFrom::Current( 0 ) )?;
                    file.set_len( n )?;
                }
            }

            self.append_history_to( &file, w )
        }
        /// Load history entries from the specified file.
        pub fn load_history<P: AsRef<Path>>( &self, path:P ) -> io::Result<()>
        {
            let mut writer = self.lock_write()?;
            let file = File::open( &path )?;
            let rdr = BufReader::new( file );

            for line in rdr.lines()
            {
                writer.add_history( line? );
            }

            writer.reset_new_history();

            Ok( () )
        }
        /// Writes formatted text to the terminal display.
        pub fn write_fmt( &self, args:fmt::Arguments ) -> io::Result<()>
        {
            let s = args.to_string();
            self.write_str( &s )
        }

        fn write_str( &self, line:&str ) -> io::Result<()> { self.lock_writer_erase()?.write_str( line ) }
    }
    /// ## Locking
    /// The following methods internally acquire both the read and write locks.
    impl<Term: Terminals> Interface<Term> 
    {
        /// Sets the prompt that will be displayed when `read_line` is called.
        pub fn set_prompt( &self, prompt:&str ) -> io::Result<()> { self.lock_reader().set_prompt( prompt ) }
        /// Sets the input buffer to the given string.
        pub fn set_buffer( &self, buf:&str ) -> io::Result<()> { self.lock_reader().set_buffer( buf ) }
        /// Sets the cursor position in the input buffer.
        pub fn set_cursor( &self, pos: usize ) -> io::Result<()> { self.lock_reader().set_cursor( pos ) }
        /// Adds a line to history.
        pub fn add_history( &self, line: String ) { self.lock_reader().add_history( line ); }
        /// Adds a line to history, unless it is identical to the most recent entry.
        pub fn add_history_unique( &self, line: String ) { self.lock_reader().add_history_unique( line ); }
        /// Removes all history entries.
        pub fn clear_history( &self ) { self.lock_reader().clear_history(); }
        /// Removes the history entry at the given index.
        pub fn remove_history( &self, idx: usize ) { self.lock_reader().remove_history( idx ); }
        /// Sets the maximum number of history entries.
        pub fn set_history_size( &self, n: usize ) { self.lock_reader().set_history_size( n ); }
        /// Truncates history to the only the most recent `n` entries.
        pub fn truncate_history( &self, n: usize ) { self.lock_reader().truncate_history( n ); }
        /// Sets the syntax highlighter for the input line.
        pub fn set_highlighter( &mut self, highlighter: Arc<dyn Highlighter + Send + Sync> )
        { self.highlighter = Some( highlighter ); }
    }
}
/// Native threads.
pub mod thread
{
    pub use std::thread::{ * };
}
/// Temporal quantification.
pub mod time
{
    pub use std::time::{ * };

    pub mod c
    {
        pub use ::timed::{ * };
        use ::
        {
            fmt, 
        };

        #[derive( Debug, PartialEq, Eq )]
        pub struct DateTime
        {
            odt: OffsetDateTime,
        }

        impl DateTime
        {
            pub fn now() -> Self
            {
                let odt: OffsetDateTime = match OffsetDateTime::now_local()
                {
                    Ok( dt ) => dt,
                    Err( _ ) => OffsetDateTime::now_utc(),
                };
                DateTime { odt }
            }

            pub fn from_timestamp( ts: f64 ) -> Self
            {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = ( ts + offset_seconds as f64 ) * 1000000000.0;
                let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos( ts_nano as i128 )
                {
                    Ok( x ) => x,
                    Err( _ ) => OffsetDateTime::now_utc(),
                };

                DateTime { odt }
            }

            pub fn unix_timestamp( &self ) -> f64
            {
                self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
            }
        }

        impl fmt::Display for DateTime
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> Displayed
            {
                write!( f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
               )
            }
        }
    }
}
/// A contiguous growable array type with heap-allocated contents, written Vec<T>.
pub mod vec
{
    pub use std::vec::{ * };
    pub mod small
    {
        pub use smallvec::{ Drain as SmallDrain, IntoIter as SmallIntoIter, * };
    } pub use self::small::{ Array, SmallVec };
}

pub unsafe fn domain()
{
    use ::
    {
        command::{ Command },
        io::
        { 
            reader::{ ReadResult },
        },
        sync::{ Arc },
        terminal::{ completers, highlighter, Interface, prompt },
        *,
    };

    env::initialize_pathing();

    let mut sh = shell::Shell::new();
    let args: Vec<String> = env::args().collect();

    if is::login( &args )
    {
        fs::load_rc_files( &mut sh );
        sh.is_login = true;
    }
    
    highlighter::init_command_cache();
    highlighter::update_aliases( &sh );

    if is::script( &args )
    {
        log!( "run script: {:?} ", &args );
        let status = scripts::run( &mut sh, &args );
        process::exit( status );
    }

    if is::command_string( &args )
    {
        let line = env::args_to_command_line();
        log!( "run with -c args: {}", &line );
        now::run_command_line( &mut sh, &line, false, false );
        process::exit( sh.previous_status );
    }

    if is::non_tty()
    {
        now::run_procedures_for_non_tty( &mut sh );
        return;
    }

    let mut rl;
    match Interface::new( "cicada" )
    {
        Ok( x ) => rl = x,
        Err( e ) =>
        {
            println!( "cicada: lineread error: {}", e );
            return;
        }
    }

    rl.define_function( "enter-function", Arc::new( ffi::EnterFunction ) );
    rl.bind_sequence( "\r", Command::from_str( "enter-function" ) );

    let highlighter = highlighter::create_highlighter();
    rl.set_highlighter( highlighter );

    history::init( &mut rl );
    rl.set_completer( Arc::new( completers::CicadaCompleter 
    {
        sh: Arc::new( sh.clone() ),
    } ) );

    let sig_handler_enabled = is::signal_handler_enabled();
    
    if sig_handler_enabled
    {
        signals::setup_sigchld_handler();
        signals::block_signals();
    }

    loop
    {
        let prompt = prompt::get_prompt( &sh );
        match rl.set_prompt( &prompt )
        {
            Ok( _ ) => {}
            Err( e ) => { println_stderr!( "cicada: prompt error: {}", e ); }
        }

        if sig_handler_enabled { signals::unblock_signals(); }

        match rl.read_line()
        {
            Ok( ReadResult::Input( line )) =>
            {
                if sig_handler_enabled { signals::block_signals(); }

                let line = shell::trim_multiline_prompts( &line );
                if line.trim() == "" {
                    jobc::try_wait_bg_jobs( &mut sh, true, sig_handler_enabled );
                    continue;
                }
                sh.cmd = line.clone();

                let tsb = time::c::DateTime::now().unix_timestamp();
                let mut line = line.clone();
                tools::extend_bangbang( &sh, &mut line );

                let mut status = 0;
                let cr_list = now::run_command_line( &mut sh, &line, true, false );
                if let Some( last ) = cr_list.last()
            {
                    status = last.status;
                }
                let tse = time::c::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with( ' ' ) && line != sh.previous_cmd {
                    history::add( &sh, &mut rl, &line, status, tsb, tse );
                    sh.previous_cmd = line.clone();
                }

                if tools::is_shell_altering_command( &line ) 
                {
                    rl.set_completer( Arc::new( completers::CicadaCompleter {
                        sh: Arc::new( sh.clone() ),
                    } ) );

                    // Update aliases in the highlighter when they might have changed
                    highlight::update_aliases( &sh );
                }

                jobc::try_wait_bg_jobs( &mut sh, true, sig_handler_enabled );
                continue;
            }
            Ok( ReadResult::Eof ) => {
                if let Ok( x ) = env::var( "NO_EXIT_ON_CTRL_D" )
            {
                    if x == "1" {
                        println!();
                    }
                } else {
                    println!( "exit" );
                    break;
                }
            }
            Ok( ReadResult::Signal( s )) => {
                println_stderr!( "readline signal: {:?}", s );
            }

            Err( e ) =>
            {
                println_stderr!( "readline error: {}", e );
                let gid = libc::getpgid( 0 );
                shell::give_terminal_to( gid );
            }
        }

        if sig_handler_enabled { signals::block_signals(); }
    }
}

fn main()
{
    unsafe
    {
        libc::signal( libc::SIGPIPE, libc::SIG_DFL );
        libc::signal( libc::SIGTSTP, libc::SIG_IGN );
        libc::signal( libc::SIGQUIT, libc::SIG_IGN );
        domain();
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 40422
